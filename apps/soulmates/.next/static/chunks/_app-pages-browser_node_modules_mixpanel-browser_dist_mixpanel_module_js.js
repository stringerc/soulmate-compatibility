/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_mixpanel-browser_dist_mixpanel_module_js"],{

/***/ "(app-pages-browser)/../../node_modules/mixpanel-browser/dist/mixpanel.module.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/mixpanel-browser/dist/mixpanel.module.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ mixpanel; }\n/* harmony export */ });\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/../../../../node_modules/buffer/index.js\")[\"Buffer\"];\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/../../node_modules/next/dist/build/polyfills/process.js\");\n// since es6 imports are static and we run unit tests from the console, window won't be defined when importing this file\nvar win;\nif (typeof(window) === 'undefined') {\n    var loc = {\n        hostname: ''\n    };\n    win = {\n        crypto: {randomUUID: function() {throw Error('unsupported');}},\n        navigator: { userAgent: '', onLine: true },\n        document: {\n            createElement: function() { return {}; },\n            location: loc,\n            referrer: ''\n        },\n        screen: { width: 0, height: 0 },\n        location: loc,\n        addEventListener: function() {},\n        removeEventListener: function() {}\n    };\n} else {\n    win = window;\n}\n\nfunction _array_like_to_array(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _async_to_generator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _construct(Parent, args, Class) {\n    if (_is_native_reflect_construct()) {\n        _construct = Reflect.construct;\n    } else {\n        _construct = function construct(Parent, args, Class) {\n            var a = [\n                null\n            ];\n            a.push.apply(a, args);\n            var Constructor = Function.bind.apply(Parent, a);\n            var instance = new Constructor();\n            if (Class) _set_prototype_of(instance, Class.prototype);\n            return instance;\n        };\n    }\n    return _construct.apply(null, arguments);\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _create_class(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    return Constructor;\n}\nfunction _extends() {\n    _extends = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _get_prototype_of(o) {\n    _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _get_prototype_of(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass) _set_prototype_of(subClass, superClass);\n}\nfunction _instanceof(left, right) {\n    if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n        return !!right[Symbol.hasInstance](left);\n    } else {\n        return left instanceof right;\n    }\n}\nfunction _is_native_function(fn) {\n    return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\nfunction _object_without_properties_loose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction _set_prototype_of(o, p) {\n    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _set_prototype_of(o, p);\n}\nfunction _type_of(obj) {\n    \"@swc/helpers - typeof\";\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n}\nfunction _unsupported_iterable_to_array(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);\n}\nfunction _wrap_native_super(Class) {\n    var _cache = typeof Map === \"function\" ? new Map() : undefined;\n    _wrap_native_super = function wrapNativeSuper(Class) {\n        if (Class === null || !_is_native_function(Class)) return Class;\n        if (typeof Class !== \"function\") {\n            throw new TypeError(\"Super expression must either be null or a function\");\n        }\n        if (typeof _cache !== \"undefined\") {\n            if (_cache.has(Class)) return _cache.get(Class);\n            _cache.set(Class, Wrapper);\n        }\n        function Wrapper() {\n            return _construct(Class, arguments, _get_prototype_of(this).constructor);\n        }\n        Wrapper.prototype = Object.create(Class.prototype, {\n            constructor: {\n                value: Wrapper,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n        return _set_prototype_of(Wrapper, Class);\n    };\n    return _wrap_native_super(Class);\n}\nfunction _is_native_reflect_construct() {\n    try {\n        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (_) {}\n    return (_is_native_reflect_construct = function() {\n        return !!result;\n    })();\n}\nfunction _create_for_of_iterator_helper_loose(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = _unsupported_iterable_to_array(o)) || allowArrayLike) {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) {\n                return {\n                    done: true\n                };\n            }\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _ts_generator(thisArg, body) {\n    var f, y, t, g, _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    };\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\nfunction _ts_values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = function(obj, key, value) {\n    return key in obj ? __defProp$1(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: value\n    }) : obj[key] = value;\n};\nvar __publicField$1 = function(obj, key, value) {\n    return __defNormalProp$1(obj, (typeof key === \"undefined\" ? \"undefined\" : _type_of(key)) !== \"symbol\" ? key + \"\" : key, value);\n};\nvar _a;\nvar __defProp$1$1 = Object.defineProperty;\nvar __defNormalProp$1$1 = function(obj, key, value) {\n    return key in obj ? __defProp$1$1(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: value\n    }) : obj[key] = value;\n};\nvar __publicField$1$1 = function(obj, key, value) {\n    return __defNormalProp$1$1(obj, (typeof key === \"undefined\" ? \"undefined\" : _type_of(key)) !== \"symbol\" ? key + \"\" : key, value);\n};\nvar NodeType$3 = /* @__PURE__ */ function(NodeType2) {\n    NodeType2[NodeType2[\"Document\"] = 0] = \"Document\";\n    NodeType2[NodeType2[\"DocumentType\"] = 1] = \"DocumentType\";\n    NodeType2[NodeType2[\"Element\"] = 2] = \"Element\";\n    NodeType2[NodeType2[\"Text\"] = 3] = \"Text\";\n    NodeType2[NodeType2[\"CDATA\"] = 4] = \"CDATA\";\n    NodeType2[NodeType2[\"Comment\"] = 5] = \"Comment\";\n    return NodeType2;\n}(NodeType$3 || {});\nvar testableAccessors$1 = {\n    Node: [\n        \"childNodes\",\n        \"parentNode\",\n        \"parentElement\",\n        \"textContent\"\n    ],\n    ShadowRoot: [\n        \"host\",\n        \"styleSheets\"\n    ],\n    Element: [\n        \"shadowRoot\",\n        \"querySelector\",\n        \"querySelectorAll\"\n    ],\n    MutationObserver: []\n};\nvar testableMethods$1 = {\n    Node: [\n        \"contains\",\n        \"getRootNode\"\n    ],\n    ShadowRoot: [\n        \"getSelection\"\n    ],\n    Element: [],\n    MutationObserver: [\n        \"constructor\"\n    ]\n};\nvar untaintedBasePrototype$1 = {};\nvar isAngularZonePresent$1 = function() {\n    return !!globalThis.Zone;\n};\nfunction getUntaintedPrototype$1(key) {\n    if (untaintedBasePrototype$1[key]) return untaintedBasePrototype$1[key];\n    var defaultObj = globalThis[key];\n    var defaultPrototype = defaultObj.prototype;\n    var accessorNames = key in testableAccessors$1 ? testableAccessors$1[key] : void 0;\n    var isUntaintedAccessors = Boolean(accessorNames && // @ts-expect-error 2345\n    accessorNames.every(function(accessor) {\n        var _a2, _b;\n        return Boolean((_b = (_a2 = Object.getOwnPropertyDescriptor(defaultPrototype, accessor)) == null ? void 0 : _a2.get) == null ? void 0 : _b.toString().includes(\"[native code]\"));\n    }));\n    var methodNames = key in testableMethods$1 ? testableMethods$1[key] : void 0;\n    var isUntaintedMethods = Boolean(methodNames && methodNames.every(// @ts-expect-error 2345\n    function(method) {\n        var _a2;\n        return typeof defaultPrototype[method] === \"function\" && ((_a2 = defaultPrototype[method]) == null ? void 0 : _a2.toString().includes(\"[native code]\"));\n    }));\n    if (isUntaintedAccessors && isUntaintedMethods && !isAngularZonePresent$1()) {\n        untaintedBasePrototype$1[key] = defaultObj.prototype;\n        return defaultObj.prototype;\n    }\n    try {\n        var iframeEl = document.createElement(\"iframe\");\n        document.body.appendChild(iframeEl);\n        var win = iframeEl.contentWindow;\n        if (!win) return defaultObj.prototype;\n        var untaintedObject = win[key].prototype;\n        document.body.removeChild(iframeEl);\n        if (!untaintedObject) return defaultPrototype;\n        return untaintedBasePrototype$1[key] = untaintedObject;\n    } catch (e) {\n        return defaultPrototype;\n    }\n}\nvar untaintedAccessorCache$1 = {};\nfunction getUntaintedAccessor$1(key, instance, accessor) {\n    var _a2;\n    var cacheKey = key + \".\" + String(accessor);\n    if (untaintedAccessorCache$1[cacheKey]) return untaintedAccessorCache$1[cacheKey].call(instance);\n    var untaintedPrototype = getUntaintedPrototype$1(key);\n    var untaintedAccessor = (_a2 = Object.getOwnPropertyDescriptor(untaintedPrototype, accessor)) == null ? void 0 : _a2.get;\n    if (!untaintedAccessor) return instance[accessor];\n    untaintedAccessorCache$1[cacheKey] = untaintedAccessor;\n    return untaintedAccessor.call(instance);\n}\nvar untaintedMethodCache$1 = {};\nfunction getUntaintedMethod$1(key, instance, method) {\n    var cacheKey = key + \".\" + String(method);\n    if (untaintedMethodCache$1[cacheKey]) return untaintedMethodCache$1[cacheKey].bind(instance);\n    var untaintedPrototype = getUntaintedPrototype$1(key);\n    var untaintedMethod = untaintedPrototype[method];\n    if (typeof untaintedMethod !== \"function\") return instance[method];\n    untaintedMethodCache$1[cacheKey] = untaintedMethod;\n    return untaintedMethod.bind(instance);\n}\nfunction childNodes$1(n2) {\n    return getUntaintedAccessor$1(\"Node\", n2, \"childNodes\");\n}\nfunction parentNode$1(n2) {\n    return getUntaintedAccessor$1(\"Node\", n2, \"parentNode\");\n}\nfunction parentElement$1(n2) {\n    return getUntaintedAccessor$1(\"Node\", n2, \"parentElement\");\n}\nfunction textContent$1(n2) {\n    return getUntaintedAccessor$1(\"Node\", n2, \"textContent\");\n}\nfunction contains$1(n2, other) {\n    return getUntaintedMethod$1(\"Node\", n2, \"contains\")(other);\n}\nfunction getRootNode$1(n2) {\n    return getUntaintedMethod$1(\"Node\", n2, \"getRootNode\")();\n}\nfunction host$1(n2) {\n    if (!n2 || !(\"host\" in n2)) return null;\n    return getUntaintedAccessor$1(\"ShadowRoot\", n2, \"host\");\n}\nfunction styleSheets$1(n2) {\n    return n2.styleSheets;\n}\nfunction shadowRoot$1(n2) {\n    if (!n2 || !(\"shadowRoot\" in n2)) return null;\n    return getUntaintedAccessor$1(\"Element\", n2, \"shadowRoot\");\n}\nfunction querySelector$1(n2, selectors) {\n    return getUntaintedAccessor$1(\"Element\", n2, \"querySelector\")(selectors);\n}\nfunction querySelectorAll$1(n2, selectors) {\n    return getUntaintedAccessor$1(\"Element\", n2, \"querySelectorAll\")(selectors);\n}\nfunction mutationObserverCtor$1() {\n    return getUntaintedPrototype$1(\"MutationObserver\").constructor;\n}\nfunction patch$1(source, name, replacement) {\n    try {\n        if (!(name in source)) {\n            return function() {};\n        }\n        var original = source[name];\n        var wrapped = replacement(original);\n        if (typeof wrapped === \"function\") {\n            wrapped.prototype = wrapped.prototype || {};\n            Object.defineProperties(wrapped, {\n                __rrweb_original__: {\n                    enumerable: false,\n                    value: original\n                }\n            });\n        }\n        source[name] = wrapped;\n        return function() {\n            source[name] = original;\n        };\n    } catch (e) {\n        return function() {};\n    }\n}\nvar index$1 = {\n    childNodes: childNodes$1,\n    parentNode: parentNode$1,\n    parentElement: parentElement$1,\n    textContent: textContent$1,\n    contains: contains$1,\n    getRootNode: getRootNode$1,\n    host: host$1,\n    styleSheets: styleSheets$1,\n    shadowRoot: shadowRoot$1,\n    querySelector: querySelector$1,\n    querySelectorAll: querySelectorAll$1,\n    mutationObserver: mutationObserverCtor$1,\n    patch: patch$1\n};\nfunction isElement(n2) {\n    return n2.nodeType === n2.ELEMENT_NODE;\n}\nfunction isShadowRoot(n2) {\n    var hostEl = // anchor and textarea elements also have a `host` property\n    // but only shadow roots have a `mode` property\n    n2 && \"host\" in n2 && \"mode\" in n2 && index$1.host(n2) || null;\n    return Boolean(hostEl && \"shadowRoot\" in hostEl && index$1.shadowRoot(hostEl) === n2);\n}\nfunction isNativeShadowDom(shadowRoot2) {\n    return Object.prototype.toString.call(shadowRoot2) === \"[object ShadowRoot]\";\n}\nfunction fixBrowserCompatibilityIssuesInCSS(cssText) {\n    if (cssText.includes(\" background-clip: text;\") && !cssText.includes(\" -webkit-background-clip: text;\")) {\n        cssText = cssText.replace(/\\sbackground-clip:\\s*text;/g, \" -webkit-background-clip: text; background-clip: text;\");\n    }\n    return cssText;\n}\nfunction escapeImportStatement(rule2) {\n    var cssText = rule2.cssText;\n    if (cssText.split('\"').length < 3) return cssText;\n    var statement = [\n        \"@import\",\n        \"url(\" + JSON.stringify(rule2.href) + \")\"\n    ];\n    if (rule2.layerName === \"\") {\n        statement.push(\"layer\");\n    } else if (rule2.layerName) {\n        statement.push(\"layer(\" + rule2.layerName + \")\");\n    }\n    if (rule2.supportsText) {\n        statement.push(\"supports(\" + rule2.supportsText + \")\");\n    }\n    if (rule2.media.length) {\n        statement.push(rule2.media.mediaText);\n    }\n    return statement.join(\" \") + \";\";\n}\nfunction stringifyStylesheet(s2) {\n    try {\n        var rules2 = s2.rules || s2.cssRules;\n        if (!rules2) {\n            return null;\n        }\n        var sheetHref = s2.href;\n        if (!sheetHref && s2.ownerNode && s2.ownerNode.ownerDocument) {\n            sheetHref = s2.ownerNode.ownerDocument.location.href;\n        }\n        var stringifiedRules = Array.from(rules2, function(rule2) {\n            return stringifyRule(rule2, sheetHref);\n        }).join(\"\");\n        return fixBrowserCompatibilityIssuesInCSS(stringifiedRules);\n    } catch (error) {\n        return null;\n    }\n}\nfunction stringifyRule(rule2, sheetHref) {\n    if (isCSSImportRule(rule2)) {\n        var importStringified;\n        try {\n            importStringified = // we can access the imported stylesheet rules directly\n            stringifyStylesheet(rule2.styleSheet) || // work around browser issues with the raw string `@import url(...)` statement\n            escapeImportStatement(rule2);\n        } catch (error) {\n            importStringified = rule2.cssText;\n        }\n        if (rule2.styleSheet.href) {\n            return absolutifyURLs(importStringified, rule2.styleSheet.href);\n        }\n        return importStringified;\n    } else {\n        var ruleStringified = rule2.cssText;\n        if (isCSSStyleRule(rule2) && rule2.selectorText.includes(\":\")) {\n            ruleStringified = fixSafariColons(ruleStringified);\n        }\n        if (sheetHref) {\n            return absolutifyURLs(ruleStringified, sheetHref);\n        }\n        return ruleStringified;\n    }\n}\nfunction fixSafariColons(cssStringified) {\n    var regex = /(\\[(?:[\\w-]+)[^\\\\])(:(?:[\\w-]+)\\])/gm;\n    return cssStringified.replace(regex, \"$1\\\\$2\");\n}\nfunction isCSSImportRule(rule2) {\n    return \"styleSheet\" in rule2;\n}\nfunction isCSSStyleRule(rule2) {\n    return \"selectorText\" in rule2;\n}\nvar Mirror = /*#__PURE__*/ function() {\n    function Mirror() {\n        __publicField$1$1(this, \"idNodeMap\", /* @__PURE__ */ new Map());\n        __publicField$1$1(this, \"nodeMetaMap\", /* @__PURE__ */ new WeakMap());\n    }\n    var _proto = Mirror.prototype;\n    _proto.getId = function getId(n2) {\n        var _a2;\n        if (!n2) return -1;\n        var id = (_a2 = this.getMeta(n2)) == null ? void 0 : _a2.id;\n        return id != null ? id : -1;\n    };\n    _proto.getNode = function getNode(id) {\n        return this.idNodeMap.get(id) || null;\n    };\n    _proto.getIds = function getIds() {\n        return Array.from(this.idNodeMap.keys());\n    };\n    _proto.getMeta = function getMeta(n2) {\n        return this.nodeMetaMap.get(n2) || null;\n    };\n    // removes the node from idNodeMap\n    // doesn't remove the node from nodeMetaMap\n    _proto.removeNodeFromMap = function removeNodeFromMap(n2) {\n        var _this = this;\n        var id = this.getId(n2);\n        this.idNodeMap.delete(id);\n        if (n2.childNodes) {\n            n2.childNodes.forEach(function(childNode) {\n                return _this.removeNodeFromMap(childNode);\n            });\n        }\n    };\n    _proto.has = function has(id) {\n        return this.idNodeMap.has(id);\n    };\n    _proto.hasNode = function hasNode(node2) {\n        return this.nodeMetaMap.has(node2);\n    };\n    _proto.add = function add(n2, meta) {\n        var id = meta.id;\n        this.idNodeMap.set(id, n2);\n        this.nodeMetaMap.set(n2, meta);\n    };\n    _proto.replace = function replace(id, n2) {\n        var oldNode = this.getNode(id);\n        if (oldNode) {\n            var meta = this.nodeMetaMap.get(oldNode);\n            if (meta) this.nodeMetaMap.set(n2, meta);\n        }\n        this.idNodeMap.set(id, n2);\n    };\n    _proto.reset = function reset() {\n        this.idNodeMap = /* @__PURE__ */ new Map();\n        this.nodeMetaMap = /* @__PURE__ */ new WeakMap();\n    };\n    return Mirror;\n}();\nfunction createMirror$2() {\n    return new Mirror();\n}\nfunction maskInputValue(param) {\n    var element = param.element, maskInputOptions = param.maskInputOptions, tagName = param.tagName, type = param.type, value = param.value, maskInputFn = param.maskInputFn;\n    var text = value || \"\";\n    var actualType = type && toLowerCase(type);\n    if (maskInputOptions[tagName.toLowerCase()] || actualType && maskInputOptions[actualType]) {\n        if (maskInputFn) {\n            text = maskInputFn(text, element);\n        } else {\n            text = \"*\".repeat(text.length);\n        }\n    }\n    return text;\n}\nfunction toLowerCase(str) {\n    return str.toLowerCase();\n}\nvar ORIGINAL_ATTRIBUTE_NAME = \"__rrweb_original__\";\nfunction is2DCanvasBlank(canvas) {\n    var ctx = canvas.getContext(\"2d\");\n    if (!ctx) return true;\n    var chunkSize = 50;\n    for(var x2 = 0; x2 < canvas.width; x2 += chunkSize){\n        for(var y = 0; y < canvas.height; y += chunkSize){\n            var getImageData = ctx.getImageData;\n            var originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData ? getImageData[ORIGINAL_ATTRIBUTE_NAME] : getImageData;\n            var pixelBuffer = new Uint32Array(// eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access\n            originalGetImageData.call(ctx, x2, y, Math.min(chunkSize, canvas.width - x2), Math.min(chunkSize, canvas.height - y)).data.buffer);\n            if (pixelBuffer.some(function(pixel) {\n                return pixel !== 0;\n            })) return false;\n        }\n    }\n    return true;\n}\nfunction getInputType(element) {\n    var type = element.type;\n    return element.hasAttribute(\"data-rr-is-password\") ? \"password\" : type ? // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    toLowerCase(type) : null;\n}\nfunction extractFileExtension(path, baseURL) {\n    var url;\n    try {\n        url = new URL(path, baseURL != null ? baseURL : window.location.href);\n    } catch (err) {\n        return null;\n    }\n    var regex = /\\.([0-9a-z]+)(?:$)/i;\n    var match = url.pathname.match(regex);\n    var _ref;\n    return (_ref = match == null ? void 0 : match[1]) != null ? _ref : null;\n}\nfunction extractOrigin(url) {\n    var origin = \"\";\n    if (url.indexOf(\"//\") > -1) {\n        origin = url.split(\"/\").slice(0, 3).join(\"/\");\n    } else {\n        origin = url.split(\"/\")[0];\n    }\n    origin = origin.split(\"?\")[0];\n    return origin;\n}\nvar URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\nvar URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\\/\\//i;\nvar URL_WWW_MATCH = /^www\\..*/i;\nvar DATA_URI = /^(data:)([^,]*),(.*)/i;\nfunction absolutifyURLs(cssText, href) {\n    return (cssText || \"\").replace(URL_IN_CSS_REF, function(origin, quote1, path1, quote2, path2, path3) {\n        var filePath = path1 || path2 || path3;\n        var maybeQuote = quote1 || quote2 || \"\";\n        if (!filePath) {\n            return origin;\n        }\n        if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {\n            return \"url(\" + maybeQuote + filePath + maybeQuote + \")\";\n        }\n        if (DATA_URI.test(filePath)) {\n            return \"url(\" + maybeQuote + filePath + maybeQuote + \")\";\n        }\n        if (filePath[0] === \"/\") {\n            return \"url(\" + maybeQuote + (extractOrigin(href) + filePath) + maybeQuote + \")\";\n        }\n        var stack = href.split(\"/\");\n        var parts = filePath.split(\"/\");\n        stack.pop();\n        for(var _iterator = _create_for_of_iterator_helper_loose(parts), _step; !(_step = _iterator()).done;){\n            var part = _step.value;\n            if (part === \".\") {\n                continue;\n            } else if (part === \"..\") {\n                stack.pop();\n            } else {\n                stack.push(part);\n            }\n        }\n        return \"url(\" + maybeQuote + stack.join(\"/\") + maybeQuote + \")\";\n    });\n}\nfunction normalizeCssString(cssText, _testNoPxNorm) {\n    if (_testNoPxNorm === void 0) _testNoPxNorm = false;\n    if (_testNoPxNorm) {\n        return cssText.replace(/(\\/\\*[^*]*\\*\\/)|[\\s;]/g, \"\");\n    } else {\n        return cssText.replace(/(\\/\\*[^*]*\\*\\/)|[\\s;]/g, \"\").replace(/0px/g, \"0\");\n    }\n}\nfunction splitCssText(cssText, style, _testNoPxNorm) {\n    if (_testNoPxNorm === void 0) _testNoPxNorm = false;\n    var childNodes2 = Array.from(style.childNodes);\n    var splits = [];\n    var iterCount = 0;\n    if (childNodes2.length > 1 && cssText && typeof cssText === \"string\") {\n        var cssTextNorm = normalizeCssString(cssText, _testNoPxNorm);\n        var normFactor = cssTextNorm.length / cssText.length;\n        for(var i2 = 1; i2 < childNodes2.length; i2++){\n            if (childNodes2[i2].textContent && typeof childNodes2[i2].textContent === \"string\") {\n                var textContentNorm = normalizeCssString(childNodes2[i2].textContent, _testNoPxNorm);\n                var jLimit = 100;\n                var j = 3;\n                for(; j < textContentNorm.length; j++){\n                    if (// keep consuming css identifiers (to get a decent chunk more quickly)\n                    textContentNorm[j].match(/[a-zA-Z0-9]/) || // substring needs to be unique to this section\n                    textContentNorm.indexOf(textContentNorm.substring(0, j), 1) !== -1) {\n                        continue;\n                    }\n                    break;\n                }\n                for(; j < textContentNorm.length; j++){\n                    var startSubstring = textContentNorm.substring(0, j);\n                    var cssNormSplits = cssTextNorm.split(startSubstring);\n                    var splitNorm = -1;\n                    if (cssNormSplits.length === 2) {\n                        splitNorm = cssNormSplits[0].length;\n                    } else if (cssNormSplits.length > 2 && cssNormSplits[0] === \"\" && childNodes2[i2 - 1].textContent !== \"\") {\n                        splitNorm = cssTextNorm.indexOf(startSubstring, 1);\n                    } else if (cssNormSplits.length === 1) {\n                        startSubstring = startSubstring.substring(0, startSubstring.length - 1);\n                        cssNormSplits = cssTextNorm.split(startSubstring);\n                        if (cssNormSplits.length <= 1) {\n                            splits.push(cssText);\n                            return splits;\n                        }\n                        j = jLimit + 1;\n                    } else if (j === textContentNorm.length - 1) {\n                        splitNorm = cssTextNorm.indexOf(startSubstring);\n                    }\n                    if (cssNormSplits.length >= 2 && j > jLimit) {\n                        var prevTextContent = childNodes2[i2 - 1].textContent;\n                        if (prevTextContent && typeof prevTextContent === \"string\") {\n                            var prevMinLength = normalizeCssString(prevTextContent).length;\n                            splitNorm = cssTextNorm.indexOf(startSubstring, prevMinLength);\n                        }\n                        if (splitNorm === -1) {\n                            splitNorm = cssNormSplits[0].length;\n                        }\n                    }\n                    if (splitNorm !== -1) {\n                        var k = Math.floor(splitNorm / normFactor);\n                        for(; k > 0 && k < cssText.length;){\n                            iterCount += 1;\n                            if (iterCount > 50 * childNodes2.length) {\n                                splits.push(cssText);\n                                return splits;\n                            }\n                            var normPart = normalizeCssString(cssText.substring(0, k), _testNoPxNorm);\n                            if (normPart.length === splitNorm) {\n                                splits.push(cssText.substring(0, k));\n                                cssText = cssText.substring(k);\n                                cssTextNorm = cssTextNorm.substring(splitNorm);\n                                break;\n                            } else if (normPart.length < splitNorm) {\n                                k += Math.max(1, Math.floor((splitNorm - normPart.length) / normFactor));\n                            } else {\n                                k -= Math.max(1, Math.floor((normPart.length - splitNorm) * normFactor));\n                            }\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    splits.push(cssText);\n    return splits;\n}\nfunction markCssSplits(cssText, style) {\n    return splitCssText(cssText, style).join(\"/* rr_split */\");\n}\nvar _id = 1;\nvar tagNameRegex = new RegExp(\"[^a-z0-9-_:]\");\nvar IGNORED_NODE = -2;\nfunction genId() {\n    return _id++;\n}\nfunction getValidTagName$1(element) {\n    if (_instanceof(element, HTMLFormElement)) {\n        return \"form\";\n    }\n    var processedTagName = toLowerCase(element.tagName);\n    if (tagNameRegex.test(processedTagName)) {\n        return \"div\";\n    }\n    return processedTagName;\n}\nvar canvasService;\nvar canvasCtx;\nvar SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/;\nvar SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\nfunction getAbsoluteSrcsetString(doc, attributeValue) {\n    if (attributeValue.trim() === \"\") {\n        return attributeValue;\n    }\n    var pos = 0;\n    function collectCharacters(regEx) {\n        var chars2;\n        var match = regEx.exec(attributeValue.substring(pos));\n        if (match) {\n            chars2 = match[0];\n            pos += chars2.length;\n            return chars2;\n        }\n        return \"\";\n    }\n    var output = [];\n    while(true){\n        collectCharacters(SRCSET_COMMAS_OR_SPACES);\n        if (pos >= attributeValue.length) {\n            break;\n        }\n        var url = collectCharacters(SRCSET_NOT_SPACES);\n        if (url.slice(-1) === \",\") {\n            url = absoluteToDoc(doc, url.substring(0, url.length - 1));\n            output.push(url);\n        } else {\n            var descriptorsStr = \"\";\n            url = absoluteToDoc(doc, url);\n            var inParens = false;\n            while(true){\n                var c2 = attributeValue.charAt(pos);\n                if (c2 === \"\") {\n                    output.push((url + descriptorsStr).trim());\n                    break;\n                } else if (!inParens) {\n                    if (c2 === \",\") {\n                        pos += 1;\n                        output.push((url + descriptorsStr).trim());\n                        break;\n                    } else if (c2 === \"(\") {\n                        inParens = true;\n                    }\n                } else {\n                    if (c2 === \")\") {\n                        inParens = false;\n                    }\n                }\n                descriptorsStr += c2;\n                pos += 1;\n            }\n        }\n    }\n    return output.join(\", \");\n}\nvar cachedDocument = /* @__PURE__ */ new WeakMap();\nfunction absoluteToDoc(doc, attributeValue) {\n    if (!attributeValue || attributeValue.trim() === \"\") {\n        return attributeValue;\n    }\n    return getHref(doc, attributeValue);\n}\nfunction isSVGElement(el) {\n    return Boolean(el.tagName === \"svg\" || el.ownerSVGElement);\n}\nfunction getHref(doc, customHref) {\n    var a2 = cachedDocument.get(doc);\n    if (!a2) {\n        a2 = doc.createElement(\"a\");\n        cachedDocument.set(doc, a2);\n    }\n    if (!customHref) {\n        customHref = \"\";\n    } else if (customHref.startsWith(\"blob:\") || customHref.startsWith(\"data:\")) {\n        return customHref;\n    }\n    a2.setAttribute(\"href\", customHref);\n    return a2.href;\n}\nfunction transformAttribute(doc, tagName, name, value) {\n    if (!value) {\n        return value;\n    }\n    if (name === \"src\" || name === \"href\" && !(tagName === \"use\" && value[0] === \"#\")) {\n        return absoluteToDoc(doc, value);\n    } else if (name === \"xlink:href\" && value[0] !== \"#\") {\n        return absoluteToDoc(doc, value);\n    } else if (name === \"background\" && (tagName === \"table\" || tagName === \"td\" || tagName === \"th\")) {\n        return absoluteToDoc(doc, value);\n    } else if (name === \"srcset\") {\n        return getAbsoluteSrcsetString(doc, value);\n    } else if (name === \"style\") {\n        return absolutifyURLs(value, getHref(doc));\n    } else if (tagName === \"object\" && name === \"data\") {\n        return absoluteToDoc(doc, value);\n    }\n    return value;\n}\nfunction ignoreAttribute(tagName, name, _value) {\n    return (tagName === \"video\" || tagName === \"audio\") && name === \"autoplay\";\n}\nfunction _isBlockedElement(element, blockClass, blockSelector) {\n    try {\n        if (typeof blockClass === \"string\") {\n            if (element.classList.contains(blockClass)) {\n                return true;\n            }\n        } else {\n            for(var eIndex = element.classList.length; eIndex--;){\n                var className = element.classList[eIndex];\n                if (blockClass.test(className)) {\n                    return true;\n                }\n            }\n        }\n        if (blockSelector) {\n            return element.matches(blockSelector);\n        }\n    } catch (e2) {}\n    return false;\n}\nfunction classMatchesRegex(node2, regex, checkAncestors) {\n    if (!node2) return false;\n    if (node2.nodeType !== node2.ELEMENT_NODE) {\n        if (!checkAncestors) return false;\n        return classMatchesRegex(index$1.parentNode(node2), regex, checkAncestors);\n    }\n    for(var eIndex = node2.classList.length; eIndex--;){\n        var className = node2.classList[eIndex];\n        if (regex.test(className)) {\n            return true;\n        }\n    }\n    if (!checkAncestors) return false;\n    return classMatchesRegex(index$1.parentNode(node2), regex, checkAncestors);\n}\nfunction needMaskingText(node2, maskTextClass, maskTextSelector, checkAncestors) {\n    var el;\n    if (isElement(node2)) {\n        el = node2;\n        if (!index$1.childNodes(el).length) {\n            return false;\n        }\n    } else if (index$1.parentElement(node2) === null) {\n        return false;\n    } else {\n        el = index$1.parentElement(node2);\n    }\n    try {\n        if (typeof maskTextClass === \"string\") {\n            if (checkAncestors) {\n                if (el.closest(\".\" + maskTextClass)) return true;\n            } else {\n                if (el.classList.contains(maskTextClass)) return true;\n            }\n        } else {\n            if (classMatchesRegex(el, maskTextClass, checkAncestors)) return true;\n        }\n        if (maskTextSelector) {\n            if (checkAncestors) {\n                if (el.closest(maskTextSelector)) return true;\n            } else {\n                if (el.matches(maskTextSelector)) return true;\n            }\n        }\n    } catch (e2) {}\n    return false;\n}\nfunction onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {\n    var win = iframeEl.contentWindow;\n    if (!win) {\n        return;\n    }\n    var fired = false;\n    var readyState;\n    try {\n        readyState = win.document.readyState;\n    } catch (error) {\n        return;\n    }\n    if (readyState !== \"complete\") {\n        var timer = setTimeout(function() {\n            if (!fired) {\n                listener();\n                fired = true;\n            }\n        }, iframeLoadTimeout);\n        iframeEl.addEventListener(\"load\", function() {\n            clearTimeout(timer);\n            fired = true;\n            listener();\n        });\n        return;\n    }\n    var blankUrl = \"about:blank\";\n    if (win.location.href !== blankUrl || iframeEl.src === blankUrl || iframeEl.src === \"\") {\n        setTimeout(listener, 0);\n        return iframeEl.addEventListener(\"load\", listener);\n    }\n    iframeEl.addEventListener(\"load\", listener);\n}\nfunction onceStylesheetLoaded(link, listener, styleSheetLoadTimeout) {\n    var fired = false;\n    var styleSheetLoaded;\n    try {\n        styleSheetLoaded = link.sheet;\n    } catch (error) {\n        return;\n    }\n    if (styleSheetLoaded) return;\n    var timer = setTimeout(function() {\n        if (!fired) {\n            listener();\n            fired = true;\n        }\n    }, styleSheetLoadTimeout);\n    link.addEventListener(\"load\", function() {\n        clearTimeout(timer);\n        fired = true;\n        listener();\n    });\n}\nfunction serializeNode(n2, options) {\n    var doc = options.doc, mirror2 = options.mirror, blockClass = options.blockClass, blockSelector = options.blockSelector, needsMask = options.needsMask, inlineStylesheet = options.inlineStylesheet, _options_maskInputOptions = options.maskInputOptions, maskInputOptions = _options_maskInputOptions === void 0 ? {} : _options_maskInputOptions, maskTextFn = options.maskTextFn, maskInputFn = options.maskInputFn, _options_dataURLOptions = options.dataURLOptions, dataURLOptions = _options_dataURLOptions === void 0 ? {} : _options_dataURLOptions, inlineImages = options.inlineImages, recordCanvas = options.recordCanvas, keepIframeSrcFn = options.keepIframeSrcFn, _options_newlyAddedElement = options.newlyAddedElement, newlyAddedElement = _options_newlyAddedElement === void 0 ? false : _options_newlyAddedElement, _options_cssCaptured = options.cssCaptured, cssCaptured = _options_cssCaptured === void 0 ? false : _options_cssCaptured;\n    var rootId = getRootId(doc, mirror2);\n    switch(n2.nodeType){\n        case n2.DOCUMENT_NODE:\n            if (n2.compatMode !== \"CSS1Compat\") {\n                return {\n                    type: NodeType$3.Document,\n                    childNodes: [],\n                    compatMode: n2.compatMode\n                };\n            } else {\n                return {\n                    type: NodeType$3.Document,\n                    childNodes: []\n                };\n            }\n        case n2.DOCUMENT_TYPE_NODE:\n            return {\n                type: NodeType$3.DocumentType,\n                name: n2.name,\n                publicId: n2.publicId,\n                systemId: n2.systemId,\n                rootId: rootId\n            };\n        case n2.ELEMENT_NODE:\n            return serializeElementNode(n2, {\n                doc: doc,\n                blockClass: blockClass,\n                blockSelector: blockSelector,\n                inlineStylesheet: inlineStylesheet,\n                maskInputOptions: maskInputOptions,\n                maskInputFn: maskInputFn,\n                dataURLOptions: dataURLOptions,\n                inlineImages: inlineImages,\n                recordCanvas: recordCanvas,\n                keepIframeSrcFn: keepIframeSrcFn,\n                newlyAddedElement: newlyAddedElement,\n                rootId: rootId\n            });\n        case n2.TEXT_NODE:\n            return serializeTextNode(n2, {\n                doc: doc,\n                needsMask: needsMask,\n                maskTextFn: maskTextFn,\n                rootId: rootId,\n                cssCaptured: cssCaptured\n            });\n        case n2.CDATA_SECTION_NODE:\n            return {\n                type: NodeType$3.CDATA,\n                textContent: \"\",\n                rootId: rootId\n            };\n        case n2.COMMENT_NODE:\n            return {\n                type: NodeType$3.Comment,\n                textContent: index$1.textContent(n2) || \"\",\n                rootId: rootId\n            };\n        default:\n            return false;\n    }\n}\nfunction getRootId(doc, mirror2) {\n    if (!mirror2.hasNode(doc)) return void 0;\n    var docId = mirror2.getId(doc);\n    return docId === 1 ? void 0 : docId;\n}\nfunction serializeTextNode(n2, options) {\n    var needsMask = options.needsMask, maskTextFn = options.maskTextFn, rootId = options.rootId, cssCaptured = options.cssCaptured;\n    var parent = index$1.parentNode(n2);\n    var parentTagName = parent && parent.tagName;\n    var textContent2 = \"\";\n    var isStyle = parentTagName === \"STYLE\" ? true : void 0;\n    var isScript = parentTagName === \"SCRIPT\" ? true : void 0;\n    if (isScript) {\n        textContent2 = \"SCRIPT_PLACEHOLDER\";\n    } else if (!cssCaptured) {\n        textContent2 = index$1.textContent(n2);\n        if (isStyle && textContent2) {\n            textContent2 = absolutifyURLs(textContent2, getHref(options.doc));\n        }\n    }\n    if (!isStyle && !isScript && textContent2 && needsMask) {\n        textContent2 = maskTextFn ? maskTextFn(textContent2, index$1.parentElement(n2)) : textContent2.replace(/[\\S]/g, \"*\");\n    }\n    return {\n        type: NodeType$3.Text,\n        textContent: textContent2 || \"\",\n        rootId: rootId\n    };\n}\nfunction serializeElementNode(n2, options) {\n    var doc = options.doc, blockClass = options.blockClass, blockSelector = options.blockSelector, inlineStylesheet = options.inlineStylesheet, _options_maskInputOptions = options.maskInputOptions, maskInputOptions = _options_maskInputOptions === void 0 ? {} : _options_maskInputOptions, maskInputFn = options.maskInputFn, _options_dataURLOptions = options.dataURLOptions, dataURLOptions = _options_dataURLOptions === void 0 ? {} : _options_dataURLOptions, inlineImages = options.inlineImages, recordCanvas = options.recordCanvas, keepIframeSrcFn = options.keepIframeSrcFn, _options_newlyAddedElement = options.newlyAddedElement, newlyAddedElement = _options_newlyAddedElement === void 0 ? false : _options_newlyAddedElement, rootId = options.rootId;\n    var needBlock = _isBlockedElement(n2, blockClass, blockSelector);\n    var tagName = getValidTagName$1(n2);\n    var attributes = {};\n    var len = n2.attributes.length;\n    for(var i2 = 0; i2 < len; i2++){\n        var attr = n2.attributes[i2];\n        if (!ignoreAttribute(tagName, attr.name, attr.value)) {\n            attributes[attr.name] = transformAttribute(doc, tagName, toLowerCase(attr.name), attr.value);\n        }\n    }\n    if (tagName === \"link\" && inlineStylesheet) {\n        var stylesheet = Array.from(doc.styleSheets).find(function(s2) {\n            return s2.href === n2.href;\n        });\n        var cssText = null;\n        if (stylesheet) {\n            cssText = stringifyStylesheet(stylesheet);\n        }\n        if (cssText) {\n            delete attributes.rel;\n            delete attributes.href;\n            attributes._cssText = cssText;\n        }\n    }\n    if (tagName === \"style\" && n2.sheet) {\n        var cssText1 = stringifyStylesheet(n2.sheet);\n        if (cssText1) {\n            if (n2.childNodes.length > 1) {\n                cssText1 = markCssSplits(cssText1, n2);\n            }\n            attributes._cssText = cssText1;\n        }\n    }\n    if (tagName === \"input\" || tagName === \"textarea\" || tagName === \"select\") {\n        var value = n2.value;\n        var checked = n2.checked;\n        if (attributes.type !== \"radio\" && attributes.type !== \"checkbox\" && attributes.type !== \"submit\" && attributes.type !== \"button\" && value) {\n            attributes.value = maskInputValue({\n                element: n2,\n                type: getInputType(n2),\n                tagName: tagName,\n                value: value,\n                maskInputOptions: maskInputOptions,\n                maskInputFn: maskInputFn\n            });\n        } else if (checked) {\n            attributes.checked = checked;\n        }\n    }\n    if (tagName === \"option\") {\n        if (n2.selected && !maskInputOptions[\"select\"]) {\n            attributes.selected = true;\n        } else {\n            delete attributes.selected;\n        }\n    }\n    if (tagName === \"dialog\" && n2.open) {\n        attributes.rr_open_mode = n2.matches(\"dialog:modal\") ? \"modal\" : \"non-modal\";\n    }\n    if (tagName === \"canvas\" && recordCanvas) {\n        if (n2.__context === \"2d\") {\n            if (!is2DCanvasBlank(n2)) {\n                attributes.rr_dataURL = n2.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n            }\n        } else if (!(\"__context\" in n2)) {\n            var canvasDataURL = n2.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n            var blankCanvas = doc.createElement(\"canvas\");\n            blankCanvas.width = n2.width;\n            blankCanvas.height = n2.height;\n            var blankCanvasDataURL = blankCanvas.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n            if (canvasDataURL !== blankCanvasDataURL) {\n                attributes.rr_dataURL = canvasDataURL;\n            }\n        }\n    }\n    if (tagName === \"img\" && inlineImages) {\n        if (!canvasService) {\n            canvasService = doc.createElement(\"canvas\");\n            canvasCtx = canvasService.getContext(\"2d\");\n        }\n        var image = n2;\n        var imageSrc = image.currentSrc || image.getAttribute(\"src\") || \"<unknown-src>\";\n        var priorCrossOrigin = image.crossOrigin;\n        var recordInlineImage = function() {\n            image.removeEventListener(\"load\", recordInlineImage);\n            try {\n                canvasService.width = image.naturalWidth;\n                canvasService.height = image.naturalHeight;\n                canvasCtx.drawImage(image, 0, 0);\n                attributes.rr_dataURL = canvasService.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n            } catch (err) {\n                if (image.crossOrigin !== \"anonymous\") {\n                    image.crossOrigin = \"anonymous\";\n                    if (image.complete && image.naturalWidth !== 0) recordInlineImage();\n                    else image.addEventListener(\"load\", recordInlineImage);\n                    return;\n                } else {\n                    console.warn(\"Cannot inline img src=\" + imageSrc + \"! Error: \" + err);\n                }\n            }\n            if (image.crossOrigin === \"anonymous\") {\n                priorCrossOrigin ? attributes.crossOrigin = priorCrossOrigin : image.removeAttribute(\"crossorigin\");\n            }\n        };\n        if (image.complete && image.naturalWidth !== 0) recordInlineImage();\n        else image.addEventListener(\"load\", recordInlineImage);\n    }\n    if (tagName === \"audio\" || tagName === \"video\") {\n        var mediaAttributes = attributes;\n        mediaAttributes.rr_mediaState = n2.paused ? \"paused\" : \"played\";\n        mediaAttributes.rr_mediaCurrentTime = n2.currentTime;\n        mediaAttributes.rr_mediaPlaybackRate = n2.playbackRate;\n        mediaAttributes.rr_mediaMuted = n2.muted;\n        mediaAttributes.rr_mediaLoop = n2.loop;\n        mediaAttributes.rr_mediaVolume = n2.volume;\n    }\n    if (!newlyAddedElement) {\n        if (n2.scrollLeft) {\n            attributes.rr_scrollLeft = n2.scrollLeft;\n        }\n        if (n2.scrollTop) {\n            attributes.rr_scrollTop = n2.scrollTop;\n        }\n    }\n    if (needBlock) {\n        var _n2_getBoundingClientRect = n2.getBoundingClientRect(), width = _n2_getBoundingClientRect.width, height = _n2_getBoundingClientRect.height;\n        attributes = {\n            class: attributes.class,\n            rr_width: \"\" + width + \"px\",\n            rr_height: \"\" + height + \"px\"\n        };\n    }\n    if (tagName === \"iframe\" && !keepIframeSrcFn(attributes.src)) {\n        if (!n2.contentDocument) {\n            attributes.rr_src = attributes.src;\n        }\n        delete attributes.src;\n    }\n    var isCustomElement;\n    try {\n        if (customElements.get(tagName)) isCustomElement = true;\n    } catch (e2) {}\n    return {\n        type: NodeType$3.Element,\n        tagName: tagName,\n        attributes: attributes,\n        childNodes: [],\n        isSVG: isSVGElement(n2) || void 0,\n        needBlock: needBlock,\n        rootId: rootId,\n        isCustom: isCustomElement\n    };\n}\nfunction lowerIfExists(maybeAttr) {\n    if (maybeAttr === void 0 || maybeAttr === null) {\n        return \"\";\n    } else {\n        return maybeAttr.toLowerCase();\n    }\n}\nfunction slimDOMExcluded(sn, slimDOMOptions) {\n    if (slimDOMOptions.comment && sn.type === NodeType$3.Comment) {\n        return true;\n    } else if (sn.type === NodeType$3.Element) {\n        if (slimDOMOptions.script && // script tag\n        (sn.tagName === \"script\" || // (module)preload link\n        sn.tagName === \"link\" && (sn.attributes.rel === \"preload\" && sn.attributes.as === \"script\" || sn.attributes.rel === \"modulepreload\") || // prefetch link\n        sn.tagName === \"link\" && sn.attributes.rel === \"prefetch\" && typeof sn.attributes.href === \"string\" && extractFileExtension(sn.attributes.href) === \"js\")) {\n            return true;\n        } else if (slimDOMOptions.headFavicon && (sn.tagName === \"link\" && sn.attributes.rel === \"shortcut icon\" || sn.tagName === \"meta\" && (lowerIfExists(sn.attributes.name).match(/^msapplication-tile(image|color)$/) || lowerIfExists(sn.attributes.name) === \"application-name\" || lowerIfExists(sn.attributes.rel) === \"icon\" || lowerIfExists(sn.attributes.rel) === \"apple-touch-icon\" || lowerIfExists(sn.attributes.rel) === \"shortcut icon\"))) {\n            return true;\n        } else if (sn.tagName === \"meta\") {\n            if (slimDOMOptions.headMetaDescKeywords && lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {\n                return true;\n            } else if (slimDOMOptions.headMetaSocial && (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || // og = opengraph (facebook)\n            lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) || lowerIfExists(sn.attributes.name) === \"pinterest\")) {\n                return true;\n            } else if (slimDOMOptions.headMetaRobots && (lowerIfExists(sn.attributes.name) === \"robots\" || lowerIfExists(sn.attributes.name) === \"googlebot\" || lowerIfExists(sn.attributes.name) === \"bingbot\")) {\n                return true;\n            } else if (slimDOMOptions.headMetaHttpEquiv && sn.attributes[\"http-equiv\"] !== void 0) {\n                return true;\n            } else if (slimDOMOptions.headMetaAuthorship && (lowerIfExists(sn.attributes.name) === \"author\" || lowerIfExists(sn.attributes.name) === \"generator\" || lowerIfExists(sn.attributes.name) === \"framework\" || lowerIfExists(sn.attributes.name) === \"publisher\" || lowerIfExists(sn.attributes.name) === \"progid\" || lowerIfExists(sn.attributes.property).match(/^article:/) || lowerIfExists(sn.attributes.property).match(/^product:/))) {\n                return true;\n            } else if (slimDOMOptions.headMetaVerification && (lowerIfExists(sn.attributes.name) === \"google-site-verification\" || lowerIfExists(sn.attributes.name) === \"yandex-verification\" || lowerIfExists(sn.attributes.name) === \"csrf-token\" || lowerIfExists(sn.attributes.name) === \"p:domain_verify\" || lowerIfExists(sn.attributes.name) === \"verify-v1\" || lowerIfExists(sn.attributes.name) === \"verification\" || lowerIfExists(sn.attributes.name) === \"shopify-checkout-api-token\")) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction serializeNodeWithId(n2, options) {\n    var doc = options.doc, mirror2 = options.mirror, blockClass = options.blockClass, blockSelector = options.blockSelector, maskTextClass = options.maskTextClass, maskTextSelector = options.maskTextSelector, _options_skipChild = options.skipChild, skipChild = _options_skipChild === void 0 ? false : _options_skipChild, _options_inlineStylesheet = options.inlineStylesheet, inlineStylesheet = _options_inlineStylesheet === void 0 ? true : _options_inlineStylesheet, _options_maskInputOptions = options.maskInputOptions, maskInputOptions = _options_maskInputOptions === void 0 ? {} : _options_maskInputOptions, maskTextFn = options.maskTextFn, maskInputFn = options.maskInputFn, slimDOMOptions = options.slimDOMOptions, _options_dataURLOptions = options.dataURLOptions, dataURLOptions = _options_dataURLOptions === void 0 ? {} : _options_dataURLOptions, _options_inlineImages = options.inlineImages, inlineImages = _options_inlineImages === void 0 ? false : _options_inlineImages, _options_recordCanvas = options.recordCanvas, recordCanvas = _options_recordCanvas === void 0 ? false : _options_recordCanvas, onSerialize = options.onSerialize, onIframeLoad = options.onIframeLoad, _options_iframeLoadTimeout = options.iframeLoadTimeout, iframeLoadTimeout = _options_iframeLoadTimeout === void 0 ? 5e3 : _options_iframeLoadTimeout, onStylesheetLoad = options.onStylesheetLoad, _options_stylesheetLoadTimeout = options.stylesheetLoadTimeout, stylesheetLoadTimeout = _options_stylesheetLoadTimeout === void 0 ? 5e3 : _options_stylesheetLoadTimeout, _options_keepIframeSrcFn = options.keepIframeSrcFn, keepIframeSrcFn = _options_keepIframeSrcFn === void 0 ? function() {\n        return false;\n    } : _options_keepIframeSrcFn, _options_newlyAddedElement = options.newlyAddedElement, newlyAddedElement = _options_newlyAddedElement === void 0 ? false : _options_newlyAddedElement, _options_cssCaptured = options.cssCaptured, cssCaptured = _options_cssCaptured === void 0 ? false : _options_cssCaptured;\n    var needsMask = options.needsMask;\n    var _options_preserveWhiteSpace = options.preserveWhiteSpace, preserveWhiteSpace = _options_preserveWhiteSpace === void 0 ? true : _options_preserveWhiteSpace;\n    if (!needsMask) {\n        var checkAncestors = needsMask === void 0;\n        needsMask = needMaskingText(n2, maskTextClass, maskTextSelector, checkAncestors);\n    }\n    var _serializedNode = serializeNode(n2, {\n        doc: doc,\n        mirror: mirror2,\n        blockClass: blockClass,\n        blockSelector: blockSelector,\n        needsMask: needsMask,\n        inlineStylesheet: inlineStylesheet,\n        maskInputOptions: maskInputOptions,\n        maskTextFn: maskTextFn,\n        maskInputFn: maskInputFn,\n        dataURLOptions: dataURLOptions,\n        inlineImages: inlineImages,\n        recordCanvas: recordCanvas,\n        keepIframeSrcFn: keepIframeSrcFn,\n        newlyAddedElement: newlyAddedElement,\n        cssCaptured: cssCaptured\n    });\n    if (!_serializedNode) {\n        console.warn(n2, \"not serialized\");\n        return null;\n    }\n    var id;\n    if (mirror2.hasNode(n2)) {\n        id = mirror2.getId(n2);\n    } else if (slimDOMExcluded(_serializedNode, slimDOMOptions) || !preserveWhiteSpace && _serializedNode.type === NodeType$3.Text && !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, \"\").length) {\n        id = IGNORED_NODE;\n    } else {\n        id = genId();\n    }\n    var serializedNode = Object.assign(_serializedNode, {\n        id: id\n    });\n    mirror2.add(n2, serializedNode);\n    if (id === IGNORED_NODE) {\n        return null;\n    }\n    if (onSerialize) {\n        onSerialize(n2);\n    }\n    var recordChild = !skipChild;\n    if (serializedNode.type === NodeType$3.Element) {\n        recordChild = recordChild && !serializedNode.needBlock;\n        delete serializedNode.needBlock;\n        var shadowRootEl = index$1.shadowRoot(n2);\n        if (shadowRootEl && isNativeShadowDom(shadowRootEl)) serializedNode.isShadowHost = true;\n    }\n    if ((serializedNode.type === NodeType$3.Document || serializedNode.type === NodeType$3.Element) && recordChild) {\n        if (slimDOMOptions.headWhitespace && serializedNode.type === NodeType$3.Element && serializedNode.tagName === \"head\") {\n            preserveWhiteSpace = false;\n        }\n        var bypassOptions = {\n            doc: doc,\n            mirror: mirror2,\n            blockClass: blockClass,\n            blockSelector: blockSelector,\n            needsMask: needsMask,\n            maskTextClass: maskTextClass,\n            maskTextSelector: maskTextSelector,\n            skipChild: skipChild,\n            inlineStylesheet: inlineStylesheet,\n            maskInputOptions: maskInputOptions,\n            maskTextFn: maskTextFn,\n            maskInputFn: maskInputFn,\n            slimDOMOptions: slimDOMOptions,\n            dataURLOptions: dataURLOptions,\n            inlineImages: inlineImages,\n            recordCanvas: recordCanvas,\n            preserveWhiteSpace: preserveWhiteSpace,\n            onSerialize: onSerialize,\n            onIframeLoad: onIframeLoad,\n            iframeLoadTimeout: iframeLoadTimeout,\n            onStylesheetLoad: onStylesheetLoad,\n            stylesheetLoadTimeout: stylesheetLoadTimeout,\n            keepIframeSrcFn: keepIframeSrcFn,\n            cssCaptured: false\n        };\n        if (serializedNode.type === NodeType$3.Element && serializedNode.tagName === \"textarea\" && serializedNode.attributes.value !== void 0) ;\n        else {\n            if (serializedNode.type === NodeType$3.Element && serializedNode.attributes._cssText !== void 0 && typeof serializedNode.attributes._cssText === \"string\") {\n                bypassOptions.cssCaptured = true;\n            }\n            for(var _iterator = _create_for_of_iterator_helper_loose(Array.from(index$1.childNodes(n2))), _step; !(_step = _iterator()).done;){\n                var childN = _step.value;\n                var serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n                if (serializedChildNode) {\n                    serializedNode.childNodes.push(serializedChildNode);\n                }\n            }\n        }\n        var shadowRootEl1 = null;\n        if (isElement(n2) && (shadowRootEl1 = index$1.shadowRoot(n2))) {\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(Array.from(index$1.childNodes(shadowRootEl1))), _step1; !(_step1 = _iterator1()).done;){\n                var childN1 = _step1.value;\n                var serializedChildNode1 = serializeNodeWithId(childN1, bypassOptions);\n                if (serializedChildNode1) {\n                    isNativeShadowDom(shadowRootEl1) && (serializedChildNode1.isShadow = true);\n                    serializedNode.childNodes.push(serializedChildNode1);\n                }\n            }\n        }\n    }\n    var parent = index$1.parentNode(n2);\n    if (parent && isShadowRoot(parent) && isNativeShadowDom(parent)) {\n        serializedNode.isShadow = true;\n    }\n    if (serializedNode.type === NodeType$3.Element && serializedNode.tagName === \"iframe\") {\n        onceIframeLoaded(n2, function() {\n            var iframeDoc = n2.contentDocument;\n            if (iframeDoc && onIframeLoad) {\n                var serializedIframeNode = serializeNodeWithId(iframeDoc, {\n                    doc: iframeDoc,\n                    mirror: mirror2,\n                    blockClass: blockClass,\n                    blockSelector: blockSelector,\n                    needsMask: needsMask,\n                    maskTextClass: maskTextClass,\n                    maskTextSelector: maskTextSelector,\n                    skipChild: false,\n                    inlineStylesheet: inlineStylesheet,\n                    maskInputOptions: maskInputOptions,\n                    maskTextFn: maskTextFn,\n                    maskInputFn: maskInputFn,\n                    slimDOMOptions: slimDOMOptions,\n                    dataURLOptions: dataURLOptions,\n                    inlineImages: inlineImages,\n                    recordCanvas: recordCanvas,\n                    preserveWhiteSpace: preserveWhiteSpace,\n                    onSerialize: onSerialize,\n                    onIframeLoad: onIframeLoad,\n                    iframeLoadTimeout: iframeLoadTimeout,\n                    onStylesheetLoad: onStylesheetLoad,\n                    stylesheetLoadTimeout: stylesheetLoadTimeout,\n                    keepIframeSrcFn: keepIframeSrcFn\n                });\n                if (serializedIframeNode) {\n                    onIframeLoad(n2, serializedIframeNode);\n                }\n            }\n        }, iframeLoadTimeout);\n    }\n    if (serializedNode.type === NodeType$3.Element && serializedNode.tagName === \"link\" && typeof serializedNode.attributes.rel === \"string\" && (serializedNode.attributes.rel === \"stylesheet\" || serializedNode.attributes.rel === \"preload\" && typeof serializedNode.attributes.href === \"string\" && extractFileExtension(serializedNode.attributes.href) === \"css\")) {\n        onceStylesheetLoaded(n2, function() {\n            if (onStylesheetLoad) {\n                var serializedLinkNode = serializeNodeWithId(n2, {\n                    doc: doc,\n                    mirror: mirror2,\n                    blockClass: blockClass,\n                    blockSelector: blockSelector,\n                    needsMask: needsMask,\n                    maskTextClass: maskTextClass,\n                    maskTextSelector: maskTextSelector,\n                    skipChild: false,\n                    inlineStylesheet: inlineStylesheet,\n                    maskInputOptions: maskInputOptions,\n                    maskTextFn: maskTextFn,\n                    maskInputFn: maskInputFn,\n                    slimDOMOptions: slimDOMOptions,\n                    dataURLOptions: dataURLOptions,\n                    inlineImages: inlineImages,\n                    recordCanvas: recordCanvas,\n                    preserveWhiteSpace: preserveWhiteSpace,\n                    onSerialize: onSerialize,\n                    onIframeLoad: onIframeLoad,\n                    iframeLoadTimeout: iframeLoadTimeout,\n                    onStylesheetLoad: onStylesheetLoad,\n                    stylesheetLoadTimeout: stylesheetLoadTimeout,\n                    keepIframeSrcFn: keepIframeSrcFn\n                });\n                if (serializedLinkNode) {\n                    onStylesheetLoad(n2, serializedLinkNode);\n                }\n            }\n        }, stylesheetLoadTimeout);\n    }\n    return serializedNode;\n}\nfunction snapshot(n2, options) {\n    var _ref = options || {}, tmp = _ref.mirror, mirror2 = tmp === void 0 ? new Mirror() : tmp, _ref_blockClass = _ref.blockClass, blockClass = _ref_blockClass === void 0 ? \"rr-block\" : _ref_blockClass, _ref_blockSelector = _ref.blockSelector, blockSelector = _ref_blockSelector === void 0 ? null : _ref_blockSelector, _ref_maskTextClass = _ref.maskTextClass, maskTextClass = _ref_maskTextClass === void 0 ? \"rr-mask\" : _ref_maskTextClass, _ref_maskTextSelector = _ref.maskTextSelector, maskTextSelector = _ref_maskTextSelector === void 0 ? null : _ref_maskTextSelector, _ref_inlineStylesheet = _ref.inlineStylesheet, inlineStylesheet = _ref_inlineStylesheet === void 0 ? true : _ref_inlineStylesheet, _ref_inlineImages = _ref.inlineImages, inlineImages = _ref_inlineImages === void 0 ? false : _ref_inlineImages, _ref_recordCanvas = _ref.recordCanvas, recordCanvas = _ref_recordCanvas === void 0 ? false : _ref_recordCanvas, _ref_maskAllInputs = _ref.maskAllInputs, maskAllInputs = _ref_maskAllInputs === void 0 ? false : _ref_maskAllInputs, maskTextFn = _ref.maskTextFn, maskInputFn = _ref.maskInputFn, _ref_slimDOM = _ref.slimDOM, slimDOM = _ref_slimDOM === void 0 ? false : _ref_slimDOM, dataURLOptions = _ref.dataURLOptions, preserveWhiteSpace = _ref.preserveWhiteSpace, onSerialize = _ref.onSerialize, onIframeLoad = _ref.onIframeLoad, iframeLoadTimeout = _ref.iframeLoadTimeout, onStylesheetLoad = _ref.onStylesheetLoad, stylesheetLoadTimeout = _ref.stylesheetLoadTimeout, _ref_keepIframeSrcFn = _ref.keepIframeSrcFn, keepIframeSrcFn = _ref_keepIframeSrcFn === void 0 ? function() {\n        return false;\n    } : _ref_keepIframeSrcFn;\n    var maskInputOptions = maskAllInputs === true ? {\n        color: true,\n        date: true,\n        \"datetime-local\": true,\n        email: true,\n        month: true,\n        number: true,\n        range: true,\n        search: true,\n        tel: true,\n        text: true,\n        time: true,\n        url: true,\n        week: true,\n        textarea: true,\n        select: true,\n        password: true,\n        hidden: true\n    } : maskAllInputs === false ? {\n        password: true\n    } : maskAllInputs;\n    var slimDOMOptions = slimDOM === true || slimDOM === \"all\" ? // if true: set of sensible options that should not throw away any information\n    {\n        script: true,\n        comment: true,\n        headFavicon: true,\n        headWhitespace: true,\n        headMetaDescKeywords: slimDOM === \"all\",\n        // destructive\n        headMetaSocial: true,\n        headMetaRobots: true,\n        headMetaHttpEquiv: true,\n        headMetaAuthorship: true,\n        headMetaVerification: true\n    } : slimDOM === false ? {} : slimDOM;\n    return serializeNodeWithId(n2, {\n        doc: n2,\n        mirror: mirror2,\n        blockClass: blockClass,\n        blockSelector: blockSelector,\n        maskTextClass: maskTextClass,\n        maskTextSelector: maskTextSelector,\n        skipChild: false,\n        inlineStylesheet: inlineStylesheet,\n        maskInputOptions: maskInputOptions,\n        maskTextFn: maskTextFn,\n        maskInputFn: maskInputFn,\n        slimDOMOptions: slimDOMOptions,\n        dataURLOptions: dataURLOptions,\n        inlineImages: inlineImages,\n        recordCanvas: recordCanvas,\n        preserveWhiteSpace: preserveWhiteSpace,\n        onSerialize: onSerialize,\n        onIframeLoad: onIframeLoad,\n        iframeLoadTimeout: iframeLoadTimeout,\n        onStylesheetLoad: onStylesheetLoad,\n        stylesheetLoadTimeout: stylesheetLoadTimeout,\n        keepIframeSrcFn: keepIframeSrcFn,\n        newlyAddedElement: false\n    });\n}\nfunction getDefaultExportFromCjs$1(x2) {\n    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, \"default\") ? x2[\"default\"] : x2;\n}\nfunction getAugmentedNamespace$1(n2) {\n    if (n2.__esModule) return n2;\n    var f2 = n2.default;\n    if (typeof f2 == \"function\") {\n        var a2 = function a22() {\n            if (_instanceof(this, a22)) {\n                return Reflect.construct(f2, arguments, this.constructor);\n            }\n            return f2.apply(this, arguments);\n        };\n        a2.prototype = f2.prototype;\n    } else a2 = {};\n    Object.defineProperty(a2, \"__esModule\", {\n        value: true\n    });\n    Object.keys(n2).forEach(function(k) {\n        var d = Object.getOwnPropertyDescriptor(n2, k);\n        Object.defineProperty(a2, k, d.get ? d : {\n            enumerable: true,\n            get: function get() {\n                return n2[k];\n            }\n        });\n    });\n    return a2;\n}\nvar picocolors_browser$1 = {\n    exports: {}\n};\nvar x$1 = String;\nvar create$1 = function create$1() {\n    return {\n        isColorSupported: false,\n        reset: x$1,\n        bold: x$1,\n        dim: x$1,\n        italic: x$1,\n        underline: x$1,\n        inverse: x$1,\n        hidden: x$1,\n        strikethrough: x$1,\n        black: x$1,\n        red: x$1,\n        green: x$1,\n        yellow: x$1,\n        blue: x$1,\n        magenta: x$1,\n        cyan: x$1,\n        white: x$1,\n        gray: x$1,\n        bgBlack: x$1,\n        bgRed: x$1,\n        bgGreen: x$1,\n        bgYellow: x$1,\n        bgBlue: x$1,\n        bgMagenta: x$1,\n        bgCyan: x$1,\n        bgWhite: x$1\n    };\n};\npicocolors_browser$1.exports = create$1();\npicocolors_browser$1.exports.createColors = create$1;\nvar picocolors_browserExports$1 = picocolors_browser$1.exports;\nvar __viteBrowserExternal$2 = {};\nvar __viteBrowserExternal$1$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n    __proto__: null,\n    default: __viteBrowserExternal$2\n}, Symbol.toStringTag, {\n    value: \"Module\"\n}));\nvar require$$2$1 = /* @__PURE__ */ getAugmentedNamespace$1(__viteBrowserExternal$1$1);\nvar pico$1 = picocolors_browserExports$1;\nvar terminalHighlight$1$1 = require$$2$1;\nvar CssSyntaxError$3$1 = /*#__PURE__*/ function(Error1) {\n    _inherits(CssSyntaxError, Error1);\n    function CssSyntaxError(message, line, column, source, file, plugin22) {\n        var _this;\n        _this = Error1.call(this, message) || this;\n        _this.name = \"CssSyntaxError\";\n        _this.reason = message;\n        if (file) {\n            _this.file = file;\n        }\n        if (source) {\n            _this.source = source;\n        }\n        if (plugin22) {\n            _this.plugin = plugin22;\n        }\n        if (typeof line !== \"undefined\" && typeof column !== \"undefined\") {\n            if (typeof line === \"number\") {\n                _this.line = line;\n                _this.column = column;\n            } else {\n                _this.line = line.line;\n                _this.column = line.column;\n                _this.endLine = column.line;\n                _this.endColumn = column.column;\n            }\n        }\n        _this.setMessage();\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(_this, CssSyntaxError);\n        }\n        return _this;\n    }\n    var _proto = CssSyntaxError.prototype;\n    _proto.setMessage = function setMessage() {\n        this.message = this.plugin ? this.plugin + \": \" : \"\";\n        this.message += this.file ? this.file : \"<css input>\";\n        if (typeof this.line !== \"undefined\") {\n            this.message += \":\" + this.line + \":\" + this.column;\n        }\n        this.message += \": \" + this.reason;\n    };\n    _proto.showSourceCode = function showSourceCode(color) {\n        var _this = this;\n        if (!this.source) return \"\";\n        var css = this.source;\n        if (color == null) color = pico$1.isColorSupported;\n        if (terminalHighlight$1$1) {\n            if (color) css = terminalHighlight$1$1(css);\n        }\n        var lines = css.split(/\\r?\\n/);\n        var start = Math.max(this.line - 3, 0);\n        var end = Math.min(this.line + 2, lines.length);\n        var maxWidth = String(end).length;\n        var mark, aside;\n        if (color) {\n            var _pico$1_createColors = pico$1.createColors(true), bold = _pico$1_createColors.bold, gray = _pico$1_createColors.gray, red = _pico$1_createColors.red;\n            mark = function(text) {\n                return bold(red(text));\n            };\n            aside = function(text) {\n                return gray(text);\n            };\n        } else {\n            mark = aside = function(str) {\n                return str;\n            };\n        }\n        return lines.slice(start, end).map(function(line, index2) {\n            var number = start + 1 + index2;\n            var gutter = \" \" + (\" \" + number).slice(-maxWidth) + \" | \";\n            if (number === _this.line) {\n                var spacing = aside(gutter.replace(/\\d/g, \" \")) + line.slice(0, _this.column - 1).replace(/[^\\t]/g, \" \");\n                return mark(\">\") + aside(gutter) + line + \"\\n \" + spacing + mark(\"^\");\n            }\n            return \" \" + aside(gutter) + line;\n        }).join(\"\\n\");\n    };\n    _proto.toString = function toString() {\n        var code = this.showSourceCode();\n        if (code) {\n            code = \"\\n\\n\" + code + \"\\n\";\n        }\n        return this.name + \": \" + this.message + code;\n    };\n    return CssSyntaxError;\n}(_wrap_native_super(Error));\nvar cssSyntaxError$1 = CssSyntaxError$3$1;\nCssSyntaxError$3$1.default = CssSyntaxError$3$1;\nvar symbols$1 = {};\nsymbols$1.isClean = Symbol(\"isClean\");\nsymbols$1.my = Symbol(\"my\");\nvar DEFAULT_RAW$1 = {\n    after: \"\\n\",\n    beforeClose: \"\\n\",\n    beforeComment: \"\\n\",\n    beforeDecl: \"\\n\",\n    beforeOpen: \" \",\n    beforeRule: \"\\n\",\n    colon: \": \",\n    commentLeft: \" \",\n    commentRight: \" \",\n    emptyBody: \"\",\n    indent: \"    \",\n    semicolon: false\n};\nfunction capitalize$1(str) {\n    return str[0].toUpperCase() + str.slice(1);\n}\nvar Stringifier$2$1 = /*#__PURE__*/ function() {\n    function Stringifier(builder) {\n        this.builder = builder;\n    }\n    var _proto = Stringifier.prototype;\n    _proto.atrule = function atrule(node2, semicolon) {\n        var name = \"@\" + node2.name;\n        var params = node2.params ? this.rawValue(node2, \"params\") : \"\";\n        if (typeof node2.raws.afterName !== \"undefined\") {\n            name += node2.raws.afterName;\n        } else if (params) {\n            name += \" \";\n        }\n        if (node2.nodes) {\n            this.block(node2, name + params);\n        } else {\n            var end = (node2.raws.between || \"\") + (semicolon ? \";\" : \"\");\n            this.builder(name + params + end, node2);\n        }\n    };\n    _proto.beforeAfter = function beforeAfter(node2, detect) {\n        var value;\n        if (node2.type === \"decl\") {\n            value = this.raw(node2, null, \"beforeDecl\");\n        } else if (node2.type === \"comment\") {\n            value = this.raw(node2, null, \"beforeComment\");\n        } else if (detect === \"before\") {\n            value = this.raw(node2, null, \"beforeRule\");\n        } else {\n            value = this.raw(node2, null, \"beforeClose\");\n        }\n        var buf = node2.parent;\n        var depth = 0;\n        while(buf && buf.type !== \"root\"){\n            depth += 1;\n            buf = buf.parent;\n        }\n        if (value.includes(\"\\n\")) {\n            var indent = this.raw(node2, null, \"indent\");\n            if (indent.length) {\n                for(var step = 0; step < depth; step++)value += indent;\n            }\n        }\n        return value;\n    };\n    _proto.block = function block(node2, start) {\n        var between = this.raw(node2, \"between\", \"beforeOpen\");\n        this.builder(start + between + \"{\", node2, \"start\");\n        var after;\n        if (node2.nodes && node2.nodes.length) {\n            this.body(node2);\n            after = this.raw(node2, \"after\");\n        } else {\n            after = this.raw(node2, \"after\", \"emptyBody\");\n        }\n        if (after) this.builder(after);\n        this.builder(\"}\", node2, \"end\");\n    };\n    _proto.body = function body(node2) {\n        var last = node2.nodes.length - 1;\n        while(last > 0){\n            if (node2.nodes[last].type !== \"comment\") break;\n            last -= 1;\n        }\n        var semicolon = this.raw(node2, \"semicolon\");\n        for(var i2 = 0; i2 < node2.nodes.length; i2++){\n            var child = node2.nodes[i2];\n            var before = this.raw(child, \"before\");\n            if (before) this.builder(before);\n            this.stringify(child, last !== i2 || semicolon);\n        }\n    };\n    _proto.comment = function comment(node2) {\n        var left = this.raw(node2, \"left\", \"commentLeft\");\n        var right = this.raw(node2, \"right\", \"commentRight\");\n        this.builder(\"/*\" + left + node2.text + right + \"*/\", node2);\n    };\n    _proto.decl = function decl(node2, semicolon) {\n        var between = this.raw(node2, \"between\", \"colon\");\n        var string = node2.prop + between + this.rawValue(node2, \"value\");\n        if (node2.important) {\n            string += node2.raws.important || \" !important\";\n        }\n        if (semicolon) string += \";\";\n        this.builder(string, node2);\n    };\n    _proto.document = function document1(node2) {\n        this.body(node2);\n    };\n    _proto.raw = function raw(node2, own, detect) {\n        var value;\n        if (!detect) detect = own;\n        if (own) {\n            value = node2.raws[own];\n            if (typeof value !== \"undefined\") return value;\n        }\n        var parent = node2.parent;\n        if (detect === \"before\") {\n            if (!parent || parent.type === \"root\" && parent.first === node2) {\n                return \"\";\n            }\n            if (parent && parent.type === \"document\") {\n                return \"\";\n            }\n        }\n        if (!parent) return DEFAULT_RAW$1[detect];\n        var root2 = node2.root();\n        if (!root2.rawCache) root2.rawCache = {};\n        if (typeof root2.rawCache[detect] !== \"undefined\") {\n            return root2.rawCache[detect];\n        }\n        if (detect === \"before\" || detect === \"after\") {\n            return this.beforeAfter(node2, detect);\n        } else {\n            var method = \"raw\" + capitalize$1(detect);\n            if (this[method]) {\n                value = this[method](root2, node2);\n            } else {\n                root2.walk(function(i2) {\n                    value = i2.raws[own];\n                    if (typeof value !== \"undefined\") return false;\n                });\n            }\n        }\n        if (typeof value === \"undefined\") value = DEFAULT_RAW$1[detect];\n        root2.rawCache[detect] = value;\n        return value;\n    };\n    _proto.rawBeforeClose = function rawBeforeClose(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && i2.nodes.length > 0) {\n                if (typeof i2.raws.after !== \"undefined\") {\n                    value = i2.raws.after;\n                    if (value.includes(\"\\n\")) {\n                        value = value.replace(/[^\\n]+$/, \"\");\n                    }\n                    return false;\n                }\n            }\n        });\n        if (value) value = value.replace(/\\S/g, \"\");\n        return value;\n    };\n    _proto.rawBeforeComment = function rawBeforeComment(root2, node2) {\n        var value;\n        root2.walkComments(function(i2) {\n            if (typeof i2.raws.before !== \"undefined\") {\n                value = i2.raws.before;\n                if (value.includes(\"\\n\")) {\n                    value = value.replace(/[^\\n]+$/, \"\");\n                }\n                return false;\n            }\n        });\n        if (typeof value === \"undefined\") {\n            value = this.raw(node2, null, \"beforeDecl\");\n        } else if (value) {\n            value = value.replace(/\\S/g, \"\");\n        }\n        return value;\n    };\n    _proto.rawBeforeDecl = function rawBeforeDecl(root2, node2) {\n        var value;\n        root2.walkDecls(function(i2) {\n            if (typeof i2.raws.before !== \"undefined\") {\n                value = i2.raws.before;\n                if (value.includes(\"\\n\")) {\n                    value = value.replace(/[^\\n]+$/, \"\");\n                }\n                return false;\n            }\n        });\n        if (typeof value === \"undefined\") {\n            value = this.raw(node2, null, \"beforeRule\");\n        } else if (value) {\n            value = value.replace(/\\S/g, \"\");\n        }\n        return value;\n    };\n    _proto.rawBeforeOpen = function rawBeforeOpen(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.type !== \"decl\") {\n                value = i2.raws.between;\n                if (typeof value !== \"undefined\") return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawBeforeRule = function rawBeforeRule(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && (i2.parent !== root2 || root2.first !== i2)) {\n                if (typeof i2.raws.before !== \"undefined\") {\n                    value = i2.raws.before;\n                    if (value.includes(\"\\n\")) {\n                        value = value.replace(/[^\\n]+$/, \"\");\n                    }\n                    return false;\n                }\n            }\n        });\n        if (value) value = value.replace(/\\S/g, \"\");\n        return value;\n    };\n    _proto.rawColon = function rawColon(root2) {\n        var value;\n        root2.walkDecls(function(i2) {\n            if (typeof i2.raws.between !== \"undefined\") {\n                value = i2.raws.between.replace(/[^\\s:]/g, \"\");\n                return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawEmptyBody = function rawEmptyBody(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && i2.nodes.length === 0) {\n                value = i2.raws.after;\n                if (typeof value !== \"undefined\") return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawIndent = function rawIndent(root2) {\n        if (root2.raws.indent) return root2.raws.indent;\n        var value;\n        root2.walk(function(i2) {\n            var p = i2.parent;\n            if (p && p !== root2 && p.parent && p.parent === root2) {\n                if (typeof i2.raws.before !== \"undefined\") {\n                    var parts = i2.raws.before.split(\"\\n\");\n                    value = parts[parts.length - 1];\n                    value = value.replace(/\\S/g, \"\");\n                    return false;\n                }\n            }\n        });\n        return value;\n    };\n    _proto.rawSemicolon = function rawSemicolon(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && i2.nodes.length && i2.last.type === \"decl\") {\n                value = i2.raws.semicolon;\n                if (typeof value !== \"undefined\") return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawValue = function rawValue(node2, prop) {\n        var value = node2[prop];\n        var raw = node2.raws[prop];\n        if (raw && raw.value === value) {\n            return raw.raw;\n        }\n        return value;\n    };\n    _proto.root = function root(node2) {\n        this.body(node2);\n        if (node2.raws.after) this.builder(node2.raws.after);\n    };\n    _proto.rule = function rule(node2) {\n        this.block(node2, this.rawValue(node2, \"selector\"));\n        if (node2.raws.ownSemicolon) {\n            this.builder(node2.raws.ownSemicolon, node2, \"end\");\n        }\n    };\n    _proto.stringify = function stringify(node2, semicolon) {\n        if (!this[node2.type]) {\n            throw new Error(\"Unknown AST node type \" + node2.type + \". Maybe you need to change PostCSS stringifier.\");\n        }\n        this[node2.type](node2, semicolon);\n    };\n    return Stringifier;\n}();\nvar stringifier$1 = Stringifier$2$1;\nStringifier$2$1.default = Stringifier$2$1;\nvar Stringifier$1$1 = stringifier$1;\nfunction stringify$4$1(node2, builder) {\n    var str = new Stringifier$1$1(builder);\n    str.stringify(node2);\n}\nvar stringify_1$1 = stringify$4$1;\nstringify$4$1.default = stringify$4$1;\nvar isClean$2$1 = symbols$1.isClean, my$2$1 = symbols$1.my;\nvar CssSyntaxError$2$1 = cssSyntaxError$1;\nvar Stringifier2$1 = stringifier$1;\nvar stringify$3$1 = stringify_1$1;\nfunction cloneNode$1(obj, parent) {\n    var cloned = new obj.constructor();\n    for(var i2 in obj){\n        if (!Object.prototype.hasOwnProperty.call(obj, i2)) {\n            continue;\n        }\n        if (i2 === \"proxyCache\") continue;\n        var value = obj[i2];\n        var type = typeof value === \"undefined\" ? \"undefined\" : _type_of(value);\n        if (i2 === \"parent\" && type === \"object\") {\n            if (parent) cloned[i2] = parent;\n        } else if (i2 === \"source\") {\n            cloned[i2] = value;\n        } else if (Array.isArray(value)) {\n            cloned[i2] = value.map(function(j) {\n                return cloneNode$1(j, cloned);\n            });\n        } else {\n            if (type === \"object\" && value !== null) value = cloneNode$1(value);\n            cloned[i2] = value;\n        }\n    }\n    return cloned;\n}\nvar Node$4$1 = /*#__PURE__*/ function() {\n    function Node2(defaults) {\n        if (defaults === void 0) defaults = {};\n        this.raws = {};\n        this[isClean$2$1] = false;\n        this[my$2$1] = true;\n        for(var name in defaults){\n            if (name === \"nodes\") {\n                this.nodes = [];\n                for(var _iterator = _create_for_of_iterator_helper_loose(defaults[name]), _step; !(_step = _iterator()).done;){\n                    var node2 = _step.value;\n                    if (typeof node2.clone === \"function\") {\n                        this.append(node2.clone());\n                    } else {\n                        this.append(node2);\n                    }\n                }\n            } else {\n                this[name] = defaults[name];\n            }\n        }\n    }\n    var _proto = Node2.prototype;\n    _proto.addToError = function addToError(error) {\n        error.postcssNode = this;\n        if (error.stack && this.source && /\\n\\s{4}at /.test(error.stack)) {\n            var s2 = this.source;\n            error.stack = error.stack.replace(/\\n\\s{4}at /, \"$&\" + s2.input.from + \":\" + s2.start.line + \":\" + s2.start.column + \"$&\");\n        }\n        return error;\n    };\n    _proto.after = function after(add) {\n        this.parent.insertAfter(this, add);\n        return this;\n    };\n    _proto.assign = function assign(overrides) {\n        if (overrides === void 0) overrides = {};\n        for(var name in overrides){\n            this[name] = overrides[name];\n        }\n        return this;\n    };\n    _proto.before = function before(add) {\n        this.parent.insertBefore(this, add);\n        return this;\n    };\n    _proto.cleanRaws = function cleanRaws(keepBetween) {\n        delete this.raws.before;\n        delete this.raws.after;\n        if (!keepBetween) delete this.raws.between;\n    };\n    _proto.clone = function clone(overrides) {\n        if (overrides === void 0) overrides = {};\n        var cloned = cloneNode$1(this);\n        for(var name in overrides){\n            cloned[name] = overrides[name];\n        }\n        return cloned;\n    };\n    _proto.cloneAfter = function cloneAfter(overrides) {\n        if (overrides === void 0) overrides = {};\n        var cloned = this.clone(overrides);\n        this.parent.insertAfter(this, cloned);\n        return cloned;\n    };\n    _proto.cloneBefore = function cloneBefore(overrides) {\n        if (overrides === void 0) overrides = {};\n        var cloned = this.clone(overrides);\n        this.parent.insertBefore(this, cloned);\n        return cloned;\n    };\n    _proto.error = function error(message, opts) {\n        if (opts === void 0) opts = {};\n        if (this.source) {\n            var _this_rangeBy = this.rangeBy(opts), end = _this_rangeBy.end, start = _this_rangeBy.start;\n            return this.source.input.error(message, {\n                column: start.column,\n                line: start.line\n            }, {\n                column: end.column,\n                line: end.line\n            }, opts);\n        }\n        return new CssSyntaxError$2$1(message);\n    };\n    _proto.getProxyProcessor = function getProxyProcessor() {\n        return {\n            get: function get(node2, prop) {\n                if (prop === \"proxyOf\") {\n                    return node2;\n                } else if (prop === \"root\") {\n                    return function() {\n                        return node2.root().toProxy();\n                    };\n                } else {\n                    return node2[prop];\n                }\n            },\n            set: function set(node2, prop, value) {\n                if (node2[prop] === value) return true;\n                node2[prop] = value;\n                if (prop === \"prop\" || prop === \"value\" || prop === \"name\" || prop === \"params\" || prop === \"important\" || /* c8 ignore next */ prop === \"text\") {\n                    node2.markDirty();\n                }\n                return true;\n            }\n        };\n    };\n    _proto.markDirty = function markDirty() {\n        if (this[isClean$2$1]) {\n            this[isClean$2$1] = false;\n            var next = this;\n            while(next = next.parent){\n                next[isClean$2$1] = false;\n            }\n        }\n    };\n    _proto.next = function next() {\n        if (!this.parent) return void 0;\n        var index2 = this.parent.index(this);\n        return this.parent.nodes[index2 + 1];\n    };\n    _proto.positionBy = function positionBy(opts, stringRepresentation) {\n        var pos = this.source.start;\n        if (opts.index) {\n            pos = this.positionInside(opts.index, stringRepresentation);\n        } else if (opts.word) {\n            stringRepresentation = this.toString();\n            var index2 = stringRepresentation.indexOf(opts.word);\n            if (index2 !== -1) pos = this.positionInside(index2, stringRepresentation);\n        }\n        return pos;\n    };\n    _proto.positionInside = function positionInside(index2, stringRepresentation) {\n        var string = stringRepresentation || this.toString();\n        var column = this.source.start.column;\n        var line = this.source.start.line;\n        for(var i2 = 0; i2 < index2; i2++){\n            if (string[i2] === \"\\n\") {\n                column = 1;\n                line += 1;\n            } else {\n                column += 1;\n            }\n        }\n        return {\n            column: column,\n            line: line\n        };\n    };\n    _proto.prev = function prev() {\n        if (!this.parent) return void 0;\n        var index2 = this.parent.index(this);\n        return this.parent.nodes[index2 - 1];\n    };\n    _proto.rangeBy = function rangeBy(opts) {\n        var start = {\n            column: this.source.start.column,\n            line: this.source.start.line\n        };\n        var end = this.source.end ? {\n            column: this.source.end.column + 1,\n            line: this.source.end.line\n        } : {\n            column: start.column + 1,\n            line: start.line\n        };\n        if (opts.word) {\n            var stringRepresentation = this.toString();\n            var index2 = stringRepresentation.indexOf(opts.word);\n            if (index2 !== -1) {\n                start = this.positionInside(index2, stringRepresentation);\n                end = this.positionInside(index2 + opts.word.length, stringRepresentation);\n            }\n        } else {\n            if (opts.start) {\n                start = {\n                    column: opts.start.column,\n                    line: opts.start.line\n                };\n            } else if (opts.index) {\n                start = this.positionInside(opts.index);\n            }\n            if (opts.end) {\n                end = {\n                    column: opts.end.column,\n                    line: opts.end.line\n                };\n            } else if (typeof opts.endIndex === \"number\") {\n                end = this.positionInside(opts.endIndex);\n            } else if (opts.index) {\n                end = this.positionInside(opts.index + 1);\n            }\n        }\n        if (end.line < start.line || end.line === start.line && end.column <= start.column) {\n            end = {\n                column: start.column + 1,\n                line: start.line\n            };\n        }\n        return {\n            end: end,\n            start: start\n        };\n    };\n    _proto.raw = function raw(prop, defaultType) {\n        var str = new Stringifier2$1();\n        return str.raw(this, prop, defaultType);\n    };\n    _proto.remove = function remove() {\n        if (this.parent) {\n            this.parent.removeChild(this);\n        }\n        this.parent = void 0;\n        return this;\n    };\n    _proto.replaceWith = function replaceWith() {\n        for(var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++){\n            nodes[_key] = arguments[_key];\n        }\n        if (this.parent) {\n            var bookmark = this;\n            var foundSelf = false;\n            for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n                var node2 = _step.value;\n                if (node2 === this) {\n                    foundSelf = true;\n                } else if (foundSelf) {\n                    this.parent.insertAfter(bookmark, node2);\n                    bookmark = node2;\n                } else {\n                    this.parent.insertBefore(bookmark, node2);\n                }\n            }\n            if (!foundSelf) {\n                this.remove();\n            }\n        }\n        return this;\n    };\n    _proto.root = function root() {\n        var result2 = this;\n        while(result2.parent && result2.parent.type !== \"document\"){\n            result2 = result2.parent;\n        }\n        return result2;\n    };\n    _proto.toJSON = function toJSON(_, inputs) {\n        var fixed = {};\n        var emitInputs = inputs == null;\n        inputs = inputs || /* @__PURE__ */ new Map();\n        var inputsNextIndex = 0;\n        for(var name in this){\n            if (!Object.prototype.hasOwnProperty.call(this, name)) {\n                continue;\n            }\n            if (name === \"parent\" || name === \"proxyCache\") continue;\n            var value = this[name];\n            if (Array.isArray(value)) {\n                fixed[name] = value.map(function(i2) {\n                    if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && i2.toJSON) {\n                        return i2.toJSON(null, inputs);\n                    } else {\n                        return i2;\n                    }\n                });\n            } else if ((typeof value === \"undefined\" ? \"undefined\" : _type_of(value)) === \"object\" && value.toJSON) {\n                fixed[name] = value.toJSON(null, inputs);\n            } else if (name === \"source\") {\n                var inputId = inputs.get(value.input);\n                if (inputId == null) {\n                    inputId = inputsNextIndex;\n                    inputs.set(value.input, inputsNextIndex);\n                    inputsNextIndex++;\n                }\n                fixed[name] = {\n                    end: value.end,\n                    inputId: inputId,\n                    start: value.start\n                };\n            } else {\n                fixed[name] = value;\n            }\n        }\n        if (emitInputs) {\n            fixed.inputs = [].concat(inputs.keys()).map(function(input2) {\n                return input2.toJSON();\n            });\n        }\n        return fixed;\n    };\n    _proto.toProxy = function toProxy() {\n        if (!this.proxyCache) {\n            this.proxyCache = new Proxy(this, this.getProxyProcessor());\n        }\n        return this.proxyCache;\n    };\n    _proto.toString = function toString(stringifier2) {\n        if (stringifier2 === void 0) stringifier2 = stringify$3$1;\n        if (stringifier2.stringify) stringifier2 = stringifier2.stringify;\n        var result2 = \"\";\n        stringifier2(this, function(i2) {\n            result2 += i2;\n        });\n        return result2;\n    };\n    _proto.warn = function warn(result2, text, opts) {\n        var data = {\n            node: this\n        };\n        for(var i2 in opts)data[i2] = opts[i2];\n        return result2.warn(text, data);\n    };\n    _create_class(Node2, [\n        {\n            key: \"proxyOf\",\n            get: function get() {\n                return this;\n            }\n        }\n    ]);\n    return Node2;\n}();\nvar node$1 = Node$4$1;\nNode$4$1.default = Node$4$1;\nvar Node$3$1 = node$1;\nvar Declaration$4$1 = /*#__PURE__*/ function(Node$3$1) {\n    _inherits(Declaration, Node$3$1);\n    function Declaration(defaults) {\n        var _this;\n        if (defaults && typeof defaults.value !== \"undefined\" && typeof defaults.value !== \"string\") {\n            defaults = _extends({}, defaults, {\n                value: String(defaults.value)\n            });\n        }\n        _this = Node$3$1.call(this, defaults) || this;\n        _this.type = \"decl\";\n        return _this;\n    }\n    _create_class(Declaration, [\n        {\n            key: \"variable\",\n            get: function get() {\n                return this.prop.startsWith(\"--\") || this.prop[0] === \"$\";\n            }\n        }\n    ]);\n    return Declaration;\n}(Node$3$1);\nvar declaration$1 = Declaration$4$1;\nDeclaration$4$1.default = Declaration$4$1;\nvar urlAlphabet$1 = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nvar nanoid$1$1 = function(size) {\n    if (size === void 0) size = 21;\n    var id = \"\";\n    var i2 = size;\n    while(i2--){\n        id += urlAlphabet$1[Math.random() * 64 | 0];\n    }\n    return id;\n};\nvar nonSecure$1 = {\n    nanoid: nanoid$1$1\n};\nvar SourceMapConsumer$2$1 = require$$2$1.SourceMapConsumer, SourceMapGenerator$2$1 = require$$2$1.SourceMapGenerator;\nvar existsSync$1 = require$$2$1.existsSync, readFileSync$1 = require$$2$1.readFileSync;\nvar dirname$1$1 = require$$2$1.dirname, join$1 = require$$2$1.join;\nfunction fromBase64$1(str) {\n    if (Buffer) {\n        return Buffer.from(str, \"base64\").toString();\n    } else {\n        return window.atob(str);\n    }\n}\nvar PreviousMap$2$1 = /*#__PURE__*/ function() {\n    function PreviousMap(css, opts) {\n        if (opts.map === false) return;\n        this.loadAnnotation(css);\n        this.inline = this.startWith(this.annotation, \"data:\");\n        var prev = opts.map ? opts.map.prev : void 0;\n        var text = this.loadMap(opts.from, prev);\n        if (!this.mapFile && opts.from) {\n            this.mapFile = opts.from;\n        }\n        if (this.mapFile) this.root = dirname$1$1(this.mapFile);\n        if (text) this.text = text;\n    }\n    var _proto = PreviousMap.prototype;\n    _proto.consumer = function consumer() {\n        if (!this.consumerCache) {\n            this.consumerCache = new SourceMapConsumer$2$1(this.text);\n        }\n        return this.consumerCache;\n    };\n    _proto.decodeInline = function decodeInline(text) {\n        var baseCharsetUri = /^data:application\\/json;charset=utf-?8;base64,/;\n        var baseUri = /^data:application\\/json;base64,/;\n        var charsetUri = /^data:application\\/json;charset=utf-?8,/;\n        var uri = /^data:application\\/json,/;\n        if (charsetUri.test(text) || uri.test(text)) {\n            return decodeURIComponent(text.substr(RegExp.lastMatch.length));\n        }\n        if (baseCharsetUri.test(text) || baseUri.test(text)) {\n            return fromBase64$1(text.substr(RegExp.lastMatch.length));\n        }\n        var encoding = text.match(/data:application\\/json;([^,]+),/)[1];\n        throw new Error(\"Unsupported source map encoding \" + encoding);\n    };\n    _proto.getAnnotationURL = function getAnnotationURL(sourceMapString) {\n        return sourceMapString.replace(/^\\/\\*\\s*# sourceMappingURL=/, \"\").trim();\n    };\n    _proto.isMap = function isMap(map) {\n        if ((typeof map === \"undefined\" ? \"undefined\" : _type_of(map)) !== \"object\") return false;\n        return typeof map.mappings === \"string\" || typeof map._mappings === \"string\" || Array.isArray(map.sections);\n    };\n    _proto.loadAnnotation = function loadAnnotation(css) {\n        var comments = css.match(/\\/\\*\\s*# sourceMappingURL=/gm);\n        if (!comments) return;\n        var start = css.lastIndexOf(comments.pop());\n        var end = css.indexOf(\"*/\", start);\n        if (start > -1 && end > -1) {\n            this.annotation = this.getAnnotationURL(css.substring(start, end));\n        }\n    };\n    _proto.loadFile = function loadFile(path) {\n        this.root = dirname$1$1(path);\n        if (existsSync$1(path)) {\n            this.mapFile = path;\n            return readFileSync$1(path, \"utf-8\").toString().trim();\n        }\n    };\n    _proto.loadMap = function loadMap(file, prev) {\n        if (prev === false) return false;\n        if (prev) {\n            if (typeof prev === \"string\") {\n                return prev;\n            } else if (typeof prev === \"function\") {\n                var prevPath = prev(file);\n                if (prevPath) {\n                    var map = this.loadFile(prevPath);\n                    if (!map) {\n                        throw new Error(\"Unable to load previous source map: \" + prevPath.toString());\n                    }\n                    return map;\n                }\n            } else if (_instanceof(prev, SourceMapConsumer$2$1)) {\n                return SourceMapGenerator$2$1.fromSourceMap(prev).toString();\n            } else if (_instanceof(prev, SourceMapGenerator$2$1)) {\n                return prev.toString();\n            } else if (this.isMap(prev)) {\n                return JSON.stringify(prev);\n            } else {\n                throw new Error(\"Unsupported previous source map format: \" + prev.toString());\n            }\n        } else if (this.inline) {\n            return this.decodeInline(this.annotation);\n        } else if (this.annotation) {\n            var map1 = this.annotation;\n            if (file) map1 = join$1(dirname$1$1(file), map1);\n            return this.loadFile(map1);\n        }\n    };\n    _proto.startWith = function startWith(string, start) {\n        if (!string) return false;\n        return string.substr(0, start.length) === start;\n    };\n    _proto.withContent = function withContent() {\n        return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);\n    };\n    return PreviousMap;\n}();\nvar previousMap$1 = PreviousMap$2$1;\nPreviousMap$2$1.default = PreviousMap$2$1;\nvar SourceMapConsumer$1$1 = require$$2$1.SourceMapConsumer, SourceMapGenerator$1$1 = require$$2$1.SourceMapGenerator;\nvar fileURLToPath$1 = require$$2$1.fileURLToPath, pathToFileURL$1$1 = require$$2$1.pathToFileURL;\nvar isAbsolute$1 = require$$2$1.isAbsolute, resolve$1$1 = require$$2$1.resolve;\nvar nanoid$2 = nonSecure$1.nanoid;\nvar terminalHighlight$2 = require$$2$1;\nvar CssSyntaxError$1$1 = cssSyntaxError$1;\nvar PreviousMap$1$1 = previousMap$1;\nvar fromOffsetCache$1 = Symbol(\"fromOffsetCache\");\nvar sourceMapAvailable$1$1 = Boolean(SourceMapConsumer$1$1 && SourceMapGenerator$1$1);\nvar pathAvailable$1$1 = Boolean(resolve$1$1 && isAbsolute$1);\nvar Input$4$1 = /*#__PURE__*/ function() {\n    function Input(css, opts) {\n        if (opts === void 0) opts = {};\n        if (css === null || typeof css === \"undefined\" || (typeof css === \"undefined\" ? \"undefined\" : _type_of(css)) === \"object\" && !css.toString) {\n            throw new Error(\"PostCSS received \" + css + \" instead of CSS string\");\n        }\n        this.css = css.toString();\n        if (this.css[0] === \"\\uFEFF\" || this.css[0] === \"\") {\n            this.hasBOM = true;\n            this.css = this.css.slice(1);\n        } else {\n            this.hasBOM = false;\n        }\n        if (opts.from) {\n            if (!pathAvailable$1$1 || /^\\w+:\\/\\//.test(opts.from) || isAbsolute$1(opts.from)) {\n                this.file = opts.from;\n            } else {\n                this.file = resolve$1$1(opts.from);\n            }\n        }\n        if (pathAvailable$1$1 && sourceMapAvailable$1$1) {\n            var map = new PreviousMap$1$1(this.css, opts);\n            if (map.text) {\n                this.map = map;\n                var file = map.consumer().file;\n                if (!this.file && file) this.file = this.mapResolve(file);\n            }\n        }\n        if (!this.file) {\n            this.id = \"<input css \" + nanoid$2(6) + \">\";\n        }\n        if (this.map) this.map.file = this.from;\n    }\n    var _proto = Input.prototype;\n    _proto.error = function error(message, line, column, opts) {\n        if (opts === void 0) opts = {};\n        var result2, endLine, endColumn;\n        if (line && (typeof line === \"undefined\" ? \"undefined\" : _type_of(line)) === \"object\") {\n            var start = line;\n            var end = column;\n            if (typeof start.offset === \"number\") {\n                var pos = this.fromOffset(start.offset);\n                line = pos.line;\n                column = pos.col;\n            } else {\n                line = start.line;\n                column = start.column;\n            }\n            if (typeof end.offset === \"number\") {\n                var pos1 = this.fromOffset(end.offset);\n                endLine = pos1.line;\n                endColumn = pos1.col;\n            } else {\n                endLine = end.line;\n                endColumn = end.column;\n            }\n        } else if (!column) {\n            var pos2 = this.fromOffset(line);\n            line = pos2.line;\n            column = pos2.col;\n        }\n        var origin = this.origin(line, column, endLine, endColumn);\n        if (origin) {\n            result2 = new CssSyntaxError$1$1(message, origin.endLine === void 0 ? origin.line : {\n                column: origin.column,\n                line: origin.line\n            }, origin.endLine === void 0 ? origin.column : {\n                column: origin.endColumn,\n                line: origin.endLine\n            }, origin.source, origin.file, opts.plugin);\n        } else {\n            result2 = new CssSyntaxError$1$1(message, endLine === void 0 ? line : {\n                column: column,\n                line: line\n            }, endLine === void 0 ? column : {\n                column: endColumn,\n                line: endLine\n            }, this.css, this.file, opts.plugin);\n        }\n        result2.input = {\n            column: column,\n            endColumn: endColumn,\n            endLine: endLine,\n            line: line,\n            source: this.css\n        };\n        if (this.file) {\n            if (pathToFileURL$1$1) {\n                result2.input.url = pathToFileURL$1$1(this.file).toString();\n            }\n            result2.input.file = this.file;\n        }\n        return result2;\n    };\n    _proto.fromOffset = function fromOffset(offset) {\n        var lastLine, lineToIndex;\n        if (!this[fromOffsetCache$1]) {\n            var lines = this.css.split(\"\\n\");\n            lineToIndex = new Array(lines.length);\n            var prevIndex = 0;\n            for(var i2 = 0, l2 = lines.length; i2 < l2; i2++){\n                lineToIndex[i2] = prevIndex;\n                prevIndex += lines[i2].length + 1;\n            }\n            this[fromOffsetCache$1] = lineToIndex;\n        } else {\n            lineToIndex = this[fromOffsetCache$1];\n        }\n        lastLine = lineToIndex[lineToIndex.length - 1];\n        var min = 0;\n        if (offset >= lastLine) {\n            min = lineToIndex.length - 1;\n        } else {\n            var max = lineToIndex.length - 2;\n            var mid;\n            while(min < max){\n                mid = min + (max - min >> 1);\n                if (offset < lineToIndex[mid]) {\n                    max = mid - 1;\n                } else if (offset >= lineToIndex[mid + 1]) {\n                    min = mid + 1;\n                } else {\n                    min = mid;\n                    break;\n                }\n            }\n        }\n        return {\n            col: offset - lineToIndex[min] + 1,\n            line: min + 1\n        };\n    };\n    _proto.mapResolve = function mapResolve(file) {\n        if (/^\\w+:\\/\\//.test(file)) {\n            return file;\n        }\n        return resolve$1$1(this.map.consumer().sourceRoot || this.map.root || \".\", file);\n    };\n    _proto.origin = function origin(line, column, endLine, endColumn) {\n        if (!this.map) return false;\n        var consumer = this.map.consumer();\n        var from = consumer.originalPositionFor({\n            column: column,\n            line: line\n        });\n        if (!from.source) return false;\n        var to;\n        if (typeof endLine === \"number\") {\n            to = consumer.originalPositionFor({\n                column: endColumn,\n                line: endLine\n            });\n        }\n        var fromUrl;\n        if (isAbsolute$1(from.source)) {\n            fromUrl = pathToFileURL$1$1(from.source);\n        } else {\n            fromUrl = new URL(from.source, this.map.consumer().sourceRoot || pathToFileURL$1$1(this.map.mapFile));\n        }\n        var result2 = {\n            column: from.column,\n            endColumn: to && to.column,\n            endLine: to && to.line,\n            line: from.line,\n            url: fromUrl.toString()\n        };\n        if (fromUrl.protocol === \"file:\") {\n            if (fileURLToPath$1) {\n                result2.file = fileURLToPath$1(fromUrl);\n            } else {\n                throw new Error(\"file: protocol is not available in this PostCSS build\");\n            }\n        }\n        var source = consumer.sourceContentFor(from.source);\n        if (source) result2.source = source;\n        return result2;\n    };\n    _proto.toJSON = function toJSON() {\n        var json = {};\n        for(var _i = 0, _iter = [\n            \"hasBOM\",\n            \"css\",\n            \"file\",\n            \"id\"\n        ]; _i < _iter.length; _i++){\n            var name = _iter[_i];\n            if (this[name] != null) {\n                json[name] = this[name];\n            }\n        }\n        if (this.map) {\n            json.map = _extends({}, this.map);\n            if (json.map.consumerCache) {\n                json.map.consumerCache = void 0;\n            }\n        }\n        return json;\n    };\n    _create_class(Input, [\n        {\n            key: \"from\",\n            get: function get() {\n                return this.file || this.id;\n            }\n        }\n    ]);\n    return Input;\n}();\nvar input$1 = Input$4$1;\nInput$4$1.default = Input$4$1;\nif (terminalHighlight$2 && terminalHighlight$2.registerInput) {\n    terminalHighlight$2.registerInput(Input$4$1);\n}\nvar SourceMapConsumer$3 = require$$2$1.SourceMapConsumer, SourceMapGenerator$3 = require$$2$1.SourceMapGenerator;\nvar dirname$2 = require$$2$1.dirname, relative$1 = require$$2$1.relative, resolve$2 = require$$2$1.resolve, sep$1 = require$$2$1.sep;\nvar pathToFileURL$2 = require$$2$1.pathToFileURL;\nvar Input$3$1 = input$1;\nvar sourceMapAvailable$2 = Boolean(SourceMapConsumer$3 && SourceMapGenerator$3);\nvar pathAvailable$2 = Boolean(dirname$2 && resolve$2 && relative$1 && sep$1);\nvar MapGenerator$2$1 = /*#__PURE__*/ function() {\n    function MapGenerator(stringify2, root2, opts, cssString) {\n        this.stringify = stringify2;\n        this.mapOpts = opts.map || {};\n        this.root = root2;\n        this.opts = opts;\n        this.css = cssString;\n        this.originalCSS = cssString;\n        this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;\n        this.memoizedFileURLs = /* @__PURE__ */ new Map();\n        this.memoizedPaths = /* @__PURE__ */ new Map();\n        this.memoizedURLs = /* @__PURE__ */ new Map();\n    }\n    var _proto = MapGenerator.prototype;\n    _proto.addAnnotation = function addAnnotation() {\n        var content;\n        if (this.isInline()) {\n            content = \"data:application/json;base64,\" + this.toBase64(this.map.toString());\n        } else if (typeof this.mapOpts.annotation === \"string\") {\n            content = this.mapOpts.annotation;\n        } else if (typeof this.mapOpts.annotation === \"function\") {\n            content = this.mapOpts.annotation(this.opts.to, this.root);\n        } else {\n            content = this.outputFile() + \".map\";\n        }\n        var eol = \"\\n\";\n        if (this.css.includes(\"\\r\\n\")) eol = \"\\r\\n\";\n        this.css += eol + \"/*# sourceMappingURL=\" + content + \" */\";\n    };\n    _proto.applyPrevMaps = function applyPrevMaps() {\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.previous()), _step; !(_step = _iterator()).done;){\n            var prev = _step.value;\n            var from = this.toUrl(this.path(prev.file));\n            var root2 = prev.root || dirname$2(prev.file);\n            var map = void 0;\n            if (this.mapOpts.sourcesContent === false) {\n                map = new SourceMapConsumer$3(prev.text);\n                if (map.sourcesContent) {\n                    map.sourcesContent = null;\n                }\n            } else {\n                map = prev.consumer();\n            }\n            this.map.applySourceMap(map, from, this.toUrl(this.path(root2)));\n        }\n    };\n    _proto.clearAnnotation = function clearAnnotation() {\n        if (this.mapOpts.annotation === false) return;\n        if (this.root) {\n            var node2;\n            for(var i2 = this.root.nodes.length - 1; i2 >= 0; i2--){\n                node2 = this.root.nodes[i2];\n                if (node2.type !== \"comment\") continue;\n                if (node2.text.indexOf(\"# sourceMappingURL=\") === 0) {\n                    this.root.removeChild(i2);\n                }\n            }\n        } else if (this.css) {\n            this.css = this.css.replace(/\\n*?\\/\\*#[\\S\\s]*?\\*\\/$/gm, \"\");\n        }\n    };\n    _proto.generate = function generate() {\n        this.clearAnnotation();\n        if (pathAvailable$2 && sourceMapAvailable$2 && this.isMap()) {\n            return this.generateMap();\n        } else {\n            var result2 = \"\";\n            this.stringify(this.root, function(i2) {\n                result2 += i2;\n            });\n            return [\n                result2\n            ];\n        }\n    };\n    _proto.generateMap = function generateMap() {\n        if (this.root) {\n            this.generateString();\n        } else if (this.previous().length === 1) {\n            var prev = this.previous()[0].consumer();\n            prev.file = this.outputFile();\n            this.map = SourceMapGenerator$3.fromSourceMap(prev, {\n                ignoreInvalidMapping: true\n            });\n        } else {\n            this.map = new SourceMapGenerator$3({\n                file: this.outputFile(),\n                ignoreInvalidMapping: true\n            });\n            this.map.addMapping({\n                generated: {\n                    column: 0,\n                    line: 1\n                },\n                original: {\n                    column: 0,\n                    line: 1\n                },\n                source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : \"<no source>\"\n            });\n        }\n        if (this.isSourcesContent()) this.setSourcesContent();\n        if (this.root && this.previous().length > 0) this.applyPrevMaps();\n        if (this.isAnnotation()) this.addAnnotation();\n        if (this.isInline()) {\n            return [\n                this.css\n            ];\n        } else {\n            return [\n                this.css,\n                this.map\n            ];\n        }\n    };\n    _proto.generateString = function generateString() {\n        var _this = this;\n        this.css = \"\";\n        this.map = new SourceMapGenerator$3({\n            file: this.outputFile(),\n            ignoreInvalidMapping: true\n        });\n        var line = 1;\n        var column = 1;\n        var noSource = \"<no source>\";\n        var mapping = {\n            generated: {\n                column: 0,\n                line: 0\n            },\n            original: {\n                column: 0,\n                line: 0\n            },\n            source: \"\"\n        };\n        var lines, last;\n        this.stringify(this.root, function(str, node2, type) {\n            _this.css += str;\n            if (node2 && type !== \"end\") {\n                mapping.generated.line = line;\n                mapping.generated.column = column - 1;\n                if (node2.source && node2.source.start) {\n                    mapping.source = _this.sourcePath(node2);\n                    mapping.original.line = node2.source.start.line;\n                    mapping.original.column = node2.source.start.column - 1;\n                    _this.map.addMapping(mapping);\n                } else {\n                    mapping.source = noSource;\n                    mapping.original.line = 1;\n                    mapping.original.column = 0;\n                    _this.map.addMapping(mapping);\n                }\n            }\n            lines = str.match(/\\n/g);\n            if (lines) {\n                line += lines.length;\n                last = str.lastIndexOf(\"\\n\");\n                column = str.length - last;\n            } else {\n                column += str.length;\n            }\n            if (node2 && type !== \"start\") {\n                var p = node2.parent || {\n                    raws: {}\n                };\n                var childless = node2.type === \"decl\" || node2.type === \"atrule\" && !node2.nodes;\n                if (!childless || node2 !== p.last || p.raws.semicolon) {\n                    if (node2.source && node2.source.end) {\n                        mapping.source = _this.sourcePath(node2);\n                        mapping.original.line = node2.source.end.line;\n                        mapping.original.column = node2.source.end.column - 1;\n                        mapping.generated.line = line;\n                        mapping.generated.column = column - 2;\n                        _this.map.addMapping(mapping);\n                    } else {\n                        mapping.source = noSource;\n                        mapping.original.line = 1;\n                        mapping.original.column = 0;\n                        mapping.generated.line = line;\n                        mapping.generated.column = column - 1;\n                        _this.map.addMapping(mapping);\n                    }\n                }\n            }\n        });\n    };\n    _proto.isAnnotation = function isAnnotation() {\n        if (this.isInline()) {\n            return true;\n        }\n        if (typeof this.mapOpts.annotation !== \"undefined\") {\n            return this.mapOpts.annotation;\n        }\n        if (this.previous().length) {\n            return this.previous().some(function(i2) {\n                return i2.annotation;\n            });\n        }\n        return true;\n    };\n    _proto.isInline = function isInline() {\n        if (typeof this.mapOpts.inline !== \"undefined\") {\n            return this.mapOpts.inline;\n        }\n        var annotation = this.mapOpts.annotation;\n        if (typeof annotation !== \"undefined\" && annotation !== true) {\n            return false;\n        }\n        if (this.previous().length) {\n            return this.previous().some(function(i2) {\n                return i2.inline;\n            });\n        }\n        return true;\n    };\n    _proto.isMap = function isMap() {\n        if (typeof this.opts.map !== \"undefined\") {\n            return !!this.opts.map;\n        }\n        return this.previous().length > 0;\n    };\n    _proto.isSourcesContent = function isSourcesContent() {\n        if (typeof this.mapOpts.sourcesContent !== \"undefined\") {\n            return this.mapOpts.sourcesContent;\n        }\n        if (this.previous().length) {\n            return this.previous().some(function(i2) {\n                return i2.withContent();\n            });\n        }\n        return true;\n    };\n    _proto.outputFile = function outputFile() {\n        if (this.opts.to) {\n            return this.path(this.opts.to);\n        } else if (this.opts.from) {\n            return this.path(this.opts.from);\n        } else {\n            return \"to.css\";\n        }\n    };\n    _proto.path = function path(file) {\n        if (this.mapOpts.absolute) return file;\n        if (file.charCodeAt(0) === 60) return file;\n        if (/^\\w+:\\/\\//.test(file)) return file;\n        var cached = this.memoizedPaths.get(file);\n        if (cached) return cached;\n        var from = this.opts.to ? dirname$2(this.opts.to) : \".\";\n        if (typeof this.mapOpts.annotation === \"string\") {\n            from = dirname$2(resolve$2(from, this.mapOpts.annotation));\n        }\n        var path = relative$1(from, file);\n        this.memoizedPaths.set(file, path);\n        return path;\n    };\n    _proto.previous = function previous() {\n        var _this = this;\n        if (!this.previousMaps) {\n            this.previousMaps = [];\n            if (this.root) {\n                this.root.walk(function(node2) {\n                    if (node2.source && node2.source.input.map) {\n                        var map = node2.source.input.map;\n                        if (!_this.previousMaps.includes(map)) {\n                            _this.previousMaps.push(map);\n                        }\n                    }\n                });\n            } else {\n                var input2 = new Input$3$1(this.originalCSS, this.opts);\n                if (input2.map) this.previousMaps.push(input2.map);\n            }\n        }\n        return this.previousMaps;\n    };\n    _proto.setSourcesContent = function setSourcesContent() {\n        var _this = this;\n        var already = {};\n        if (this.root) {\n            this.root.walk(function(node2) {\n                if (node2.source) {\n                    var from = node2.source.input.from;\n                    if (from && !already[from]) {\n                        already[from] = true;\n                        var fromUrl = _this.usesFileUrls ? _this.toFileUrl(from) : _this.toUrl(_this.path(from));\n                        _this.map.setSourceContent(fromUrl, node2.source.input.css);\n                    }\n                }\n            });\n        } else if (this.css) {\n            var from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : \"<no source>\";\n            this.map.setSourceContent(from, this.css);\n        }\n    };\n    _proto.sourcePath = function sourcePath(node2) {\n        if (this.mapOpts.from) {\n            return this.toUrl(this.mapOpts.from);\n        } else if (this.usesFileUrls) {\n            return this.toFileUrl(node2.source.input.from);\n        } else {\n            return this.toUrl(this.path(node2.source.input.from));\n        }\n    };\n    _proto.toBase64 = function toBase64(str) {\n        if (Buffer) {\n            return Buffer.from(str).toString(\"base64\");\n        } else {\n            return window.btoa(unescape(encodeURIComponent(str)));\n        }\n    };\n    _proto.toFileUrl = function toFileUrl(path) {\n        var cached = this.memoizedFileURLs.get(path);\n        if (cached) return cached;\n        if (pathToFileURL$2) {\n            var fileURL = pathToFileURL$2(path).toString();\n            this.memoizedFileURLs.set(path, fileURL);\n            return fileURL;\n        } else {\n            throw new Error(\"`map.absolute` option is not available in this PostCSS build\");\n        }\n    };\n    _proto.toUrl = function toUrl(path) {\n        var cached = this.memoizedURLs.get(path);\n        if (cached) return cached;\n        if (sep$1 === \"\\\\\") {\n            path = path.replace(/\\\\/g, \"/\");\n        }\n        var url = encodeURI(path).replace(/[#?]/g, encodeURIComponent);\n        this.memoizedURLs.set(path, url);\n        return url;\n    };\n    return MapGenerator;\n}();\nvar mapGenerator$1 = MapGenerator$2$1;\nvar Node$2$1 = node$1;\nvar Comment$4$1 = /*#__PURE__*/ function(Node$2$1) {\n    _inherits(Comment, Node$2$1);\n    function Comment(defaults) {\n        var _this;\n        _this = Node$2$1.call(this, defaults) || this;\n        _this.type = \"comment\";\n        return _this;\n    }\n    return Comment;\n}(Node$2$1);\nvar comment$1 = Comment$4$1;\nComment$4$1.default = Comment$4$1;\nvar isClean$1$1 = symbols$1.isClean, my$1$1 = symbols$1.my;\nvar Declaration$3$1 = declaration$1;\nvar Comment$3$1 = comment$1;\nvar Node$1$1 = node$1;\nvar parse$4$1, Rule$4$1, AtRule$4$1, Root$6$1;\nfunction cleanSource$1(nodes) {\n    return nodes.map(function(i2) {\n        if (i2.nodes) i2.nodes = cleanSource$1(i2.nodes);\n        delete i2.source;\n        return i2;\n    });\n}\nfunction markDirtyUp$1(node2) {\n    node2[isClean$1$1] = false;\n    if (node2.proxyOf.nodes) {\n        for(var _iterator = _create_for_of_iterator_helper_loose(node2.proxyOf.nodes), _step; !(_step = _iterator()).done;){\n            var i2 = _step.value;\n            markDirtyUp$1(i2);\n        }\n    }\n}\nvar Container$7$1 = /*#__PURE__*/ function(Node$1$1) {\n    _inherits(Container, Node$1$1);\n    function Container() {\n        return Node$1$1.apply(this, arguments) || this;\n    }\n    var _proto = Container.prototype;\n    _proto.append = function append() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        for(var _iterator = _create_for_of_iterator_helper_loose(children), _step; !(_step = _iterator()).done;){\n            var child = _step.value;\n            var nodes = this.normalize(child, this.last);\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(nodes), _step1; !(_step1 = _iterator1()).done;){\n                var node2 = _step1.value;\n                this.proxyOf.nodes.push(node2);\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.cleanRaws = function cleanRaws(keepBetween) {\n        Node$1$1.prototype.cleanRaws.call(this, keepBetween);\n        if (this.nodes) {\n            for(var _iterator = _create_for_of_iterator_helper_loose(this.nodes), _step; !(_step = _iterator()).done;){\n                var node2 = _step.value;\n                node2.cleanRaws(keepBetween);\n            }\n        }\n    };\n    _proto.each = function each(callback) {\n        if (!this.proxyOf.nodes) return void 0;\n        var iterator = this.getIterator();\n        var index2, result2;\n        while(this.indexes[iterator] < this.proxyOf.nodes.length){\n            index2 = this.indexes[iterator];\n            result2 = callback(this.proxyOf.nodes[index2], index2);\n            if (result2 === false) break;\n            this.indexes[iterator] += 1;\n        }\n        delete this.indexes[iterator];\n        return result2;\n    };\n    _proto.every = function every(condition) {\n        return this.nodes.every(condition);\n    };\n    _proto.getIterator = function getIterator() {\n        if (!this.lastEach) this.lastEach = 0;\n        if (!this.indexes) this.indexes = {};\n        this.lastEach += 1;\n        var iterator = this.lastEach;\n        this.indexes[iterator] = 0;\n        return iterator;\n    };\n    _proto.getProxyProcessor = function getProxyProcessor() {\n        return {\n            get: function get(node2, prop) {\n                if (prop === \"proxyOf\") {\n                    return node2;\n                } else if (!node2[prop]) {\n                    return node2[prop];\n                } else if (prop === \"each\" || typeof prop === \"string\" && prop.startsWith(\"walk\")) {\n                    return function() {\n                        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                            args[_key] = arguments[_key];\n                        }\n                        var _node2;\n                        return (_node2 = node2)[prop].apply(_node2, [].concat(args.map(function(i2) {\n                            if (typeof i2 === \"function\") {\n                                return function(child, index2) {\n                                    return i2(child.toProxy(), index2);\n                                };\n                            } else {\n                                return i2;\n                            }\n                        })));\n                    };\n                } else if (prop === \"every\" || prop === \"some\") {\n                    return function(cb) {\n                        return node2[prop](function(child) {\n                            for(var _len = arguments.length, other = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                                other[_key - 1] = arguments[_key];\n                            }\n                            return cb.apply(void 0, [].concat([\n                                child.toProxy()\n                            ], other));\n                        });\n                    };\n                } else if (prop === \"root\") {\n                    return function() {\n                        return node2.root().toProxy();\n                    };\n                } else if (prop === \"nodes\") {\n                    return node2.nodes.map(function(i2) {\n                        return i2.toProxy();\n                    });\n                } else if (prop === \"first\" || prop === \"last\") {\n                    return node2[prop].toProxy();\n                } else {\n                    return node2[prop];\n                }\n            },\n            set: function set(node2, prop, value) {\n                if (node2[prop] === value) return true;\n                node2[prop] = value;\n                if (prop === \"name\" || prop === \"params\" || prop === \"selector\") {\n                    node2.markDirty();\n                }\n                return true;\n            }\n        };\n    };\n    _proto.index = function index(child) {\n        if (typeof child === \"number\") return child;\n        if (child.proxyOf) child = child.proxyOf;\n        return this.proxyOf.nodes.indexOf(child);\n    };\n    _proto.insertAfter = function insertAfter(exist, add) {\n        var existIndex = this.index(exist);\n        var nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();\n        existIndex = this.index(exist);\n        for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n            var node2 = _step.value;\n            this.proxyOf.nodes.splice(existIndex + 1, 0, node2);\n        }\n        var index2;\n        for(var id in this.indexes){\n            index2 = this.indexes[id];\n            if (existIndex < index2) {\n                this.indexes[id] = index2 + nodes.length;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.insertBefore = function insertBefore(exist, add) {\n        var existIndex = this.index(exist);\n        var type = existIndex === 0 ? \"prepend\" : false;\n        var nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse();\n        existIndex = this.index(exist);\n        for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n            var node2 = _step.value;\n            this.proxyOf.nodes.splice(existIndex, 0, node2);\n        }\n        var index2;\n        for(var id in this.indexes){\n            index2 = this.indexes[id];\n            if (existIndex <= index2) {\n                this.indexes[id] = index2 + nodes.length;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.normalize = function normalize(nodes, sample) {\n        var _this = this;\n        if (typeof nodes === \"string\") {\n            nodes = cleanSource$1(parse$4$1(nodes).nodes);\n        } else if (typeof nodes === \"undefined\") {\n            nodes = [];\n        } else if (Array.isArray(nodes)) {\n            nodes = nodes.slice(0);\n            for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n                var i2 = _step.value;\n                if (i2.parent) i2.parent.removeChild(i2, \"ignore\");\n            }\n        } else if (nodes.type === \"root\" && this.type !== \"document\") {\n            nodes = nodes.nodes.slice(0);\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(nodes), _step1; !(_step1 = _iterator1()).done;){\n                var i21 = _step1.value;\n                if (i21.parent) i21.parent.removeChild(i21, \"ignore\");\n            }\n        } else if (nodes.type) {\n            nodes = [\n                nodes\n            ];\n        } else if (nodes.prop) {\n            if (typeof nodes.value === \"undefined\") {\n                throw new Error(\"Value field is missed in node creation\");\n            } else if (typeof nodes.value !== \"string\") {\n                nodes.value = String(nodes.value);\n            }\n            nodes = [\n                new Declaration$3$1(nodes)\n            ];\n        } else if (nodes.selector) {\n            nodes = [\n                new Rule$4$1(nodes)\n            ];\n        } else if (nodes.name) {\n            nodes = [\n                new AtRule$4$1(nodes)\n            ];\n        } else if (nodes.text) {\n            nodes = [\n                new Comment$3$1(nodes)\n            ];\n        } else {\n            throw new Error(\"Unknown node type in node creation\");\n        }\n        var processed = nodes.map(function(i2) {\n            if (!i2[my$1$1]) Container.rebuild(i2);\n            i2 = i2.proxyOf;\n            if (i2.parent) i2.parent.removeChild(i2);\n            if (i2[isClean$1$1]) markDirtyUp$1(i2);\n            if (typeof i2.raws.before === \"undefined\") {\n                if (sample && typeof sample.raws.before !== \"undefined\") {\n                    i2.raws.before = sample.raws.before.replace(/\\S/g, \"\");\n                }\n            }\n            i2.parent = _this.proxyOf;\n            return i2;\n        });\n        return processed;\n    };\n    _proto.prepend = function prepend() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        children = children.reverse();\n        for(var _iterator = _create_for_of_iterator_helper_loose(children), _step; !(_step = _iterator()).done;){\n            var child = _step.value;\n            var nodes = this.normalize(child, this.first, \"prepend\").reverse();\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(nodes), _step1; !(_step1 = _iterator1()).done;){\n                var node2 = _step1.value;\n                this.proxyOf.nodes.unshift(node2);\n            }\n            for(var id in this.indexes){\n                this.indexes[id] = this.indexes[id] + nodes.length;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.push = function push(child) {\n        child.parent = this;\n        this.proxyOf.nodes.push(child);\n        return this;\n    };\n    _proto.removeAll = function removeAll() {\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.proxyOf.nodes), _step; !(_step = _iterator()).done;){\n            var node2 = _step.value;\n            node2.parent = void 0;\n        }\n        this.proxyOf.nodes = [];\n        this.markDirty();\n        return this;\n    };\n    _proto.removeChild = function removeChild(child) {\n        child = this.index(child);\n        this.proxyOf.nodes[child].parent = void 0;\n        this.proxyOf.nodes.splice(child, 1);\n        var index2;\n        for(var id in this.indexes){\n            index2 = this.indexes[id];\n            if (index2 >= child) {\n                this.indexes[id] = index2 - 1;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.replaceValues = function replaceValues(pattern, opts, callback) {\n        if (!callback) {\n            callback = opts;\n            opts = {};\n        }\n        this.walkDecls(function(decl) {\n            if (opts.props && !opts.props.includes(decl.prop)) return;\n            if (opts.fast && !decl.value.includes(opts.fast)) return;\n            decl.value = decl.value.replace(pattern, callback);\n        });\n        this.markDirty();\n        return this;\n    };\n    _proto.some = function some(condition) {\n        return this.nodes.some(condition);\n    };\n    _proto.walk = function walk(callback) {\n        return this.each(function(child, i2) {\n            var result2;\n            try {\n                result2 = callback(child, i2);\n            } catch (e2) {\n                throw child.addToError(e2);\n            }\n            if (result2 !== false && child.walk) {\n                result2 = child.walk(callback);\n            }\n            return result2;\n        });\n    };\n    _proto.walkAtRules = function walkAtRules(name, callback) {\n        if (!callback) {\n            callback = name;\n            return this.walk(function(child, i2) {\n                if (child.type === \"atrule\") {\n                    return callback(child, i2);\n                }\n            });\n        }\n        if (_instanceof(name, RegExp)) {\n            return this.walk(function(child, i2) {\n                if (child.type === \"atrule\" && name.test(child.name)) {\n                    return callback(child, i2);\n                }\n            });\n        }\n        return this.walk(function(child, i2) {\n            if (child.type === \"atrule\" && child.name === name) {\n                return callback(child, i2);\n            }\n        });\n    };\n    _proto.walkComments = function walkComments(callback) {\n        return this.walk(function(child, i2) {\n            if (child.type === \"comment\") {\n                return callback(child, i2);\n            }\n        });\n    };\n    _proto.walkDecls = function walkDecls(prop, callback) {\n        if (!callback) {\n            callback = prop;\n            return this.walk(function(child, i2) {\n                if (child.type === \"decl\") {\n                    return callback(child, i2);\n                }\n            });\n        }\n        if (_instanceof(prop, RegExp)) {\n            return this.walk(function(child, i2) {\n                if (child.type === \"decl\" && prop.test(child.prop)) {\n                    return callback(child, i2);\n                }\n            });\n        }\n        return this.walk(function(child, i2) {\n            if (child.type === \"decl\" && child.prop === prop) {\n                return callback(child, i2);\n            }\n        });\n    };\n    _proto.walkRules = function walkRules(selector, callback) {\n        if (!callback) {\n            callback = selector;\n            return this.walk(function(child, i2) {\n                if (child.type === \"rule\") {\n                    return callback(child, i2);\n                }\n            });\n        }\n        if (_instanceof(selector, RegExp)) {\n            return this.walk(function(child, i2) {\n                if (child.type === \"rule\" && selector.test(child.selector)) {\n                    return callback(child, i2);\n                }\n            });\n        }\n        return this.walk(function(child, i2) {\n            if (child.type === \"rule\" && child.selector === selector) {\n                return callback(child, i2);\n            }\n        });\n    };\n    _create_class(Container, [\n        {\n            key: \"first\",\n            get: function get() {\n                if (!this.proxyOf.nodes) return void 0;\n                return this.proxyOf.nodes[0];\n            }\n        },\n        {\n            key: \"last\",\n            get: function get() {\n                if (!this.proxyOf.nodes) return void 0;\n                return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];\n            }\n        }\n    ]);\n    return Container;\n}(Node$1$1);\nContainer$7$1.registerParse = function(dependant) {\n    parse$4$1 = dependant;\n};\nContainer$7$1.registerRule = function(dependant) {\n    Rule$4$1 = dependant;\n};\nContainer$7$1.registerAtRule = function(dependant) {\n    AtRule$4$1 = dependant;\n};\nContainer$7$1.registerRoot = function(dependant) {\n    Root$6$1 = dependant;\n};\nvar container$1 = Container$7$1;\nContainer$7$1.default = Container$7$1;\nContainer$7$1.rebuild = function(node2) {\n    if (node2.type === \"atrule\") {\n        Object.setPrototypeOf(node2, AtRule$4$1.prototype);\n    } else if (node2.type === \"rule\") {\n        Object.setPrototypeOf(node2, Rule$4$1.prototype);\n    } else if (node2.type === \"decl\") {\n        Object.setPrototypeOf(node2, Declaration$3$1.prototype);\n    } else if (node2.type === \"comment\") {\n        Object.setPrototypeOf(node2, Comment$3$1.prototype);\n    } else if (node2.type === \"root\") {\n        Object.setPrototypeOf(node2, Root$6$1.prototype);\n    }\n    node2[my$1$1] = true;\n    if (node2.nodes) {\n        node2.nodes.forEach(function(child) {\n            Container$7$1.rebuild(child);\n        });\n    }\n};\nvar Container$6$1 = container$1;\nvar LazyResult$4$1, Processor$3$1;\nvar Document$3$1 = /*#__PURE__*/ function(Container$6$1) {\n    _inherits(Document2, Container$6$1);\n    function Document2(defaults) {\n        var _this;\n        _this = Container$6$1.call(this, _extends({\n            type: \"document\"\n        }, defaults)) || this;\n        if (!_this.nodes) {\n            _this.nodes = [];\n        }\n        return _this;\n    }\n    var _proto = Document2.prototype;\n    _proto.toResult = function toResult(opts) {\n        if (opts === void 0) opts = {};\n        var lazy = new LazyResult$4$1(new Processor$3$1(), this, opts);\n        return lazy.stringify();\n    };\n    return Document2;\n}(Container$6$1);\nDocument$3$1.registerLazyResult = function(dependant) {\n    LazyResult$4$1 = dependant;\n};\nDocument$3$1.registerProcessor = function(dependant) {\n    Processor$3$1 = dependant;\n};\nvar document$1$1 = Document$3$1;\nDocument$3$1.default = Document$3$1;\nvar printed$1 = {};\nvar warnOnce$2$1 = function warnOnce(message) {\n    if (printed$1[message]) return;\n    printed$1[message] = true;\n    if (typeof console !== \"undefined\" && console.warn) {\n        console.warn(message);\n    }\n};\nvar Warning$2$1 = /*#__PURE__*/ function() {\n    function Warning(text, opts) {\n        if (opts === void 0) opts = {};\n        this.type = \"warning\";\n        this.text = text;\n        if (opts.node && opts.node.source) {\n            var range = opts.node.rangeBy(opts);\n            this.line = range.start.line;\n            this.column = range.start.column;\n            this.endLine = range.end.line;\n            this.endColumn = range.end.column;\n        }\n        for(var opt in opts)this[opt] = opts[opt];\n    }\n    var _proto = Warning.prototype;\n    _proto.toString = function toString() {\n        if (this.node) {\n            return this.node.error(this.text, {\n                index: this.index,\n                plugin: this.plugin,\n                word: this.word\n            }).message;\n        }\n        if (this.plugin) {\n            return this.plugin + \": \" + this.text;\n        }\n        return this.text;\n    };\n    return Warning;\n}();\nvar warning$1 = Warning$2$1;\nWarning$2$1.default = Warning$2$1;\nvar Warning$1$1 = warning$1;\nvar Result$3$1 = /*#__PURE__*/ function() {\n    function Result(processor2, root2, opts) {\n        this.processor = processor2;\n        this.messages = [];\n        this.root = root2;\n        this.opts = opts;\n        this.css = void 0;\n        this.map = void 0;\n    }\n    var _proto = Result.prototype;\n    _proto.toString = function toString() {\n        return this.css;\n    };\n    _proto.warn = function warn(text, opts) {\n        if (opts === void 0) opts = {};\n        if (!opts.plugin) {\n            if (this.lastPlugin && this.lastPlugin.postcssPlugin) {\n                opts.plugin = this.lastPlugin.postcssPlugin;\n            }\n        }\n        var warning2 = new Warning$1$1(text, opts);\n        this.messages.push(warning2);\n        return warning2;\n    };\n    _proto.warnings = function warnings() {\n        return this.messages.filter(function(i2) {\n            return i2.type === \"warning\";\n        });\n    };\n    _create_class(Result, [\n        {\n            key: \"content\",\n            get: function get() {\n                return this.css;\n            }\n        }\n    ]);\n    return Result;\n}();\nvar result$1 = Result$3$1;\nResult$3$1.default = Result$3$1;\nvar SINGLE_QUOTE$1 = \"'\".charCodeAt(0);\nvar DOUBLE_QUOTE$1 = '\"'.charCodeAt(0);\nvar BACKSLASH$1 = \"\\\\\".charCodeAt(0);\nvar SLASH$1 = \"/\".charCodeAt(0);\nvar NEWLINE$1 = \"\\n\".charCodeAt(0);\nvar SPACE$1 = \" \".charCodeAt(0);\nvar FEED$1 = \"\\f\".charCodeAt(0);\nvar TAB$1 = \"\t\".charCodeAt(0);\nvar CR$1 = \"\\r\".charCodeAt(0);\nvar OPEN_SQUARE$1 = \"[\".charCodeAt(0);\nvar CLOSE_SQUARE$1 = \"]\".charCodeAt(0);\nvar OPEN_PARENTHESES$1 = \"(\".charCodeAt(0);\nvar CLOSE_PARENTHESES$1 = \")\".charCodeAt(0);\nvar OPEN_CURLY$1 = \"{\".charCodeAt(0);\nvar CLOSE_CURLY$1 = \"}\".charCodeAt(0);\nvar SEMICOLON$1 = \";\".charCodeAt(0);\nvar ASTERISK$1 = \"*\".charCodeAt(0);\nvar COLON$1 = \":\".charCodeAt(0);\nvar AT$1 = \"@\".charCodeAt(0);\nvar RE_AT_END$1 = /[\\t\\n\\f\\r \"#'()/;[\\\\\\]{}]/g;\nvar RE_WORD_END$1 = /[\\t\\n\\f\\r !\"#'():;@[\\\\\\]{}]|\\/(?=\\*)/g;\nvar RE_BAD_BRACKET$1 = /.[\\r\\n\"'(/\\\\]/;\nvar RE_HEX_ESCAPE$1 = /[\\da-f]/i;\nvar tokenize$1 = function tokenizer(input2, options) {\n    if (options === void 0) options = {};\n    var css = input2.css.valueOf();\n    var ignore = options.ignoreErrors;\n    var code, next, quote, content, escape;\n    var escaped, escapePos, prev, n2, currentToken;\n    var length = css.length;\n    var pos = 0;\n    var buffer = [];\n    var returned = [];\n    function position() {\n        return pos;\n    }\n    function unclosed(what) {\n        throw input2.error(\"Unclosed \" + what, pos);\n    }\n    function endOfFile() {\n        return returned.length === 0 && pos >= length;\n    }\n    function nextToken(opts) {\n        if (returned.length) return returned.pop();\n        if (pos >= length) return;\n        var ignoreUnclosed = opts ? opts.ignoreUnclosed : false;\n        code = css.charCodeAt(pos);\n        switch(code){\n            case NEWLINE$1:\n            case SPACE$1:\n            case TAB$1:\n            case CR$1:\n            case FEED$1:\n                {\n                    next = pos;\n                    do {\n                        next += 1;\n                        code = css.charCodeAt(next);\n                    }while (code === SPACE$1 || code === NEWLINE$1 || code === TAB$1 || code === CR$1 || code === FEED$1);\n                    currentToken = [\n                        \"space\",\n                        css.slice(pos, next)\n                    ];\n                    pos = next - 1;\n                    break;\n                }\n            case OPEN_SQUARE$1:\n            case CLOSE_SQUARE$1:\n            case OPEN_CURLY$1:\n            case CLOSE_CURLY$1:\n            case COLON$1:\n            case SEMICOLON$1:\n            case CLOSE_PARENTHESES$1:\n                {\n                    var controlChar = String.fromCharCode(code);\n                    currentToken = [\n                        controlChar,\n                        controlChar,\n                        pos\n                    ];\n                    break;\n                }\n            case OPEN_PARENTHESES$1:\n                {\n                    prev = buffer.length ? buffer.pop()[1] : \"\";\n                    n2 = css.charCodeAt(pos + 1);\n                    if (prev === \"url\" && n2 !== SINGLE_QUOTE$1 && n2 !== DOUBLE_QUOTE$1 && n2 !== SPACE$1 && n2 !== NEWLINE$1 && n2 !== TAB$1 && n2 !== FEED$1 && n2 !== CR$1) {\n                        next = pos;\n                        do {\n                            escaped = false;\n                            next = css.indexOf(\")\", next + 1);\n                            if (next === -1) {\n                                if (ignore || ignoreUnclosed) {\n                                    next = pos;\n                                    break;\n                                } else {\n                                    unclosed(\"bracket\");\n                                }\n                            }\n                            escapePos = next;\n                            while(css.charCodeAt(escapePos - 1) === BACKSLASH$1){\n                                escapePos -= 1;\n                                escaped = !escaped;\n                            }\n                        }while (escaped);\n                        currentToken = [\n                            \"brackets\",\n                            css.slice(pos, next + 1),\n                            pos,\n                            next\n                        ];\n                        pos = next;\n                    } else {\n                        next = css.indexOf(\")\", pos + 1);\n                        content = css.slice(pos, next + 1);\n                        if (next === -1 || RE_BAD_BRACKET$1.test(content)) {\n                            currentToken = [\n                                \"(\",\n                                \"(\",\n                                pos\n                            ];\n                        } else {\n                            currentToken = [\n                                \"brackets\",\n                                content,\n                                pos,\n                                next\n                            ];\n                            pos = next;\n                        }\n                    }\n                    break;\n                }\n            case SINGLE_QUOTE$1:\n            case DOUBLE_QUOTE$1:\n                {\n                    quote = code === SINGLE_QUOTE$1 ? \"'\" : '\"';\n                    next = pos;\n                    do {\n                        escaped = false;\n                        next = css.indexOf(quote, next + 1);\n                        if (next === -1) {\n                            if (ignore || ignoreUnclosed) {\n                                next = pos + 1;\n                                break;\n                            } else {\n                                unclosed(\"string\");\n                            }\n                        }\n                        escapePos = next;\n                        while(css.charCodeAt(escapePos - 1) === BACKSLASH$1){\n                            escapePos -= 1;\n                            escaped = !escaped;\n                        }\n                    }while (escaped);\n                    currentToken = [\n                        \"string\",\n                        css.slice(pos, next + 1),\n                        pos,\n                        next\n                    ];\n                    pos = next;\n                    break;\n                }\n            case AT$1:\n                {\n                    RE_AT_END$1.lastIndex = pos + 1;\n                    RE_AT_END$1.test(css);\n                    if (RE_AT_END$1.lastIndex === 0) {\n                        next = css.length - 1;\n                    } else {\n                        next = RE_AT_END$1.lastIndex - 2;\n                    }\n                    currentToken = [\n                        \"at-word\",\n                        css.slice(pos, next + 1),\n                        pos,\n                        next\n                    ];\n                    pos = next;\n                    break;\n                }\n            case BACKSLASH$1:\n                {\n                    next = pos;\n                    escape = true;\n                    while(css.charCodeAt(next + 1) === BACKSLASH$1){\n                        next += 1;\n                        escape = !escape;\n                    }\n                    code = css.charCodeAt(next + 1);\n                    if (escape && code !== SLASH$1 && code !== SPACE$1 && code !== NEWLINE$1 && code !== TAB$1 && code !== CR$1 && code !== FEED$1) {\n                        next += 1;\n                        if (RE_HEX_ESCAPE$1.test(css.charAt(next))) {\n                            while(RE_HEX_ESCAPE$1.test(css.charAt(next + 1))){\n                                next += 1;\n                            }\n                            if (css.charCodeAt(next + 1) === SPACE$1) {\n                                next += 1;\n                            }\n                        }\n                    }\n                    currentToken = [\n                        \"word\",\n                        css.slice(pos, next + 1),\n                        pos,\n                        next\n                    ];\n                    pos = next;\n                    break;\n                }\n            default:\n                {\n                    if (code === SLASH$1 && css.charCodeAt(pos + 1) === ASTERISK$1) {\n                        next = css.indexOf(\"*/\", pos + 2) + 1;\n                        if (next === 0) {\n                            if (ignore || ignoreUnclosed) {\n                                next = css.length;\n                            } else {\n                                unclosed(\"comment\");\n                            }\n                        }\n                        currentToken = [\n                            \"comment\",\n                            css.slice(pos, next + 1),\n                            pos,\n                            next\n                        ];\n                        pos = next;\n                    } else {\n                        RE_WORD_END$1.lastIndex = pos + 1;\n                        RE_WORD_END$1.test(css);\n                        if (RE_WORD_END$1.lastIndex === 0) {\n                            next = css.length - 1;\n                        } else {\n                            next = RE_WORD_END$1.lastIndex - 2;\n                        }\n                        currentToken = [\n                            \"word\",\n                            css.slice(pos, next + 1),\n                            pos,\n                            next\n                        ];\n                        buffer.push(currentToken);\n                        pos = next;\n                    }\n                    break;\n                }\n        }\n        pos++;\n        return currentToken;\n    }\n    function back(token) {\n        returned.push(token);\n    }\n    return {\n        back: back,\n        endOfFile: endOfFile,\n        nextToken: nextToken,\n        position: position\n    };\n};\nvar Container$5$1 = container$1;\nvar AtRule$3$1 = /*#__PURE__*/ function(Container$5$1) {\n    _inherits(AtRule, Container$5$1);\n    function AtRule(defaults) {\n        var _this;\n        _this = Container$5$1.call(this, defaults) || this;\n        _this.type = \"atrule\";\n        return _this;\n    }\n    var _proto = AtRule.prototype;\n    _proto.append = function append() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        var _Container$5$1_prototype_append;\n        if (!this.proxyOf.nodes) this.nodes = [];\n        return (_Container$5$1_prototype_append = Container$5$1.prototype.append).call.apply(_Container$5$1_prototype_append, [].concat([\n            this\n        ], children));\n    };\n    _proto.prepend = function prepend() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        var _Container$5$1_prototype_prepend;\n        if (!this.proxyOf.nodes) this.nodes = [];\n        return (_Container$5$1_prototype_prepend = Container$5$1.prototype.prepend).call.apply(_Container$5$1_prototype_prepend, [].concat([\n            this\n        ], children));\n    };\n    return AtRule;\n}(Container$5$1);\nvar atRule$1 = AtRule$3$1;\nAtRule$3$1.default = AtRule$3$1;\nContainer$5$1.registerAtRule(AtRule$3$1);\nvar Container$4$1 = container$1;\nvar LazyResult$3$1, Processor$2$1;\nvar Root$5$1 = /*#__PURE__*/ function(Container$4$1) {\n    _inherits(Root, Container$4$1);\n    function Root(defaults) {\n        var _this;\n        _this = Container$4$1.call(this, defaults) || this;\n        _this.type = \"root\";\n        if (!_this.nodes) _this.nodes = [];\n        return _this;\n    }\n    var _proto = Root.prototype;\n    _proto.normalize = function normalize(child, sample, type) {\n        var nodes = Container$4$1.prototype.normalize.call(this, child);\n        if (sample) {\n            if (type === \"prepend\") {\n                if (this.nodes.length > 1) {\n                    sample.raws.before = this.nodes[1].raws.before;\n                } else {\n                    delete sample.raws.before;\n                }\n            } else if (this.first !== sample) {\n                for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n                    var node2 = _step.value;\n                    node2.raws.before = sample.raws.before;\n                }\n            }\n        }\n        return nodes;\n    };\n    _proto.removeChild = function removeChild(child, ignore) {\n        var index2 = this.index(child);\n        if (!ignore && index2 === 0 && this.nodes.length > 1) {\n            this.nodes[1].raws.before = this.nodes[index2].raws.before;\n        }\n        return Container$4$1.prototype.removeChild.call(this, child);\n    };\n    _proto.toResult = function toResult(opts) {\n        if (opts === void 0) opts = {};\n        var lazy = new LazyResult$3$1(new Processor$2$1(), this, opts);\n        return lazy.stringify();\n    };\n    return Root;\n}(Container$4$1);\nRoot$5$1.registerLazyResult = function(dependant) {\n    LazyResult$3$1 = dependant;\n};\nRoot$5$1.registerProcessor = function(dependant) {\n    Processor$2$1 = dependant;\n};\nvar root$1 = Root$5$1;\nRoot$5$1.default = Root$5$1;\nContainer$4$1.registerRoot(Root$5$1);\nvar list$2$1 = {\n    comma: function comma(string) {\n        return list$2$1.split(string, [\n            \",\"\n        ], true);\n    },\n    space: function space(string) {\n        var spaces = [\n            \" \",\n            \"\\n\",\n            \"\t\"\n        ];\n        return list$2$1.split(string, spaces);\n    },\n    split: function split(string, separators, last) {\n        var array = [];\n        var current = \"\";\n        var split = false;\n        var func = 0;\n        var inQuote = false;\n        var prevQuote = \"\";\n        var escape = false;\n        for(var _iterator = _create_for_of_iterator_helper_loose(string), _step; !(_step = _iterator()).done;){\n            var letter = _step.value;\n            if (escape) {\n                escape = false;\n            } else if (letter === \"\\\\\") {\n                escape = true;\n            } else if (inQuote) {\n                if (letter === prevQuote) {\n                    inQuote = false;\n                }\n            } else if (letter === '\"' || letter === \"'\") {\n                inQuote = true;\n                prevQuote = letter;\n            } else if (letter === \"(\") {\n                func += 1;\n            } else if (letter === \")\") {\n                if (func > 0) func -= 1;\n            } else if (func === 0) {\n                if (separators.includes(letter)) split = true;\n            }\n            if (split) {\n                if (current !== \"\") array.push(current.trim());\n                current = \"\";\n                split = false;\n            } else {\n                current += letter;\n            }\n        }\n        if (last || current !== \"\") array.push(current.trim());\n        return array;\n    }\n};\nvar list_1$1 = list$2$1;\nlist$2$1.default = list$2$1;\nvar Container$3$1 = container$1;\nvar list$1$1 = list_1$1;\nvar Rule$3$1 = /*#__PURE__*/ function(Container$3$1) {\n    _inherits(Rule, Container$3$1);\n    function Rule(defaults) {\n        var _this;\n        _this = Container$3$1.call(this, defaults) || this;\n        _this.type = \"rule\";\n        if (!_this.nodes) _this.nodes = [];\n        return _this;\n    }\n    _create_class(Rule, [\n        {\n            key: \"selectors\",\n            get: function get() {\n                return list$1$1.comma(this.selector);\n            },\n            set: function set(values) {\n                var match = this.selector ? this.selector.match(/,\\s*/) : null;\n                var sep2 = match ? match[0] : \",\" + this.raw(\"between\", \"beforeOpen\");\n                this.selector = values.join(sep2);\n            }\n        }\n    ]);\n    return Rule;\n}(Container$3$1);\nvar rule$1 = Rule$3$1;\nRule$3$1.default = Rule$3$1;\nContainer$3$1.registerRule(Rule$3$1);\nvar Declaration$2$1 = declaration$1;\nvar tokenizer2$1 = tokenize$1;\nvar Comment$2$1 = comment$1;\nvar AtRule$2$1 = atRule$1;\nvar Root$4$1 = root$1;\nvar Rule$2$1 = rule$1;\nvar SAFE_COMMENT_NEIGHBOR$1 = {\n    empty: true,\n    space: true\n};\nfunction findLastWithPosition$1(tokens) {\n    for(var i2 = tokens.length - 1; i2 >= 0; i2--){\n        var token = tokens[i2];\n        var pos = token[3] || token[2];\n        if (pos) return pos;\n    }\n}\nvar Parser$1$1 = /*#__PURE__*/ function() {\n    function Parser(input2) {\n        this.input = input2;\n        this.root = new Root$4$1();\n        this.current = this.root;\n        this.spaces = \"\";\n        this.semicolon = false;\n        this.createTokenizer();\n        this.root.source = {\n            input: input2,\n            start: {\n                column: 1,\n                line: 1,\n                offset: 0\n            }\n        };\n    }\n    var _proto = Parser.prototype;\n    _proto.atrule = function atrule(token) {\n        var node2 = new AtRule$2$1();\n        node2.name = token[1].slice(1);\n        if (node2.name === \"\") {\n            this.unnamedAtrule(node2, token);\n        }\n        this.init(node2, token[2]);\n        var type;\n        var prev;\n        var shift;\n        var last = false;\n        var open = false;\n        var params = [];\n        var brackets = [];\n        while(!this.tokenizer.endOfFile()){\n            token = this.tokenizer.nextToken();\n            type = token[0];\n            if (type === \"(\" || type === \"[\") {\n                brackets.push(type === \"(\" ? \")\" : \"]\");\n            } else if (type === \"{\" && brackets.length > 0) {\n                brackets.push(\"}\");\n            } else if (type === brackets[brackets.length - 1]) {\n                brackets.pop();\n            }\n            if (brackets.length === 0) {\n                if (type === \";\") {\n                    node2.source.end = this.getPosition(token[2]);\n                    node2.source.end.offset++;\n                    this.semicolon = true;\n                    break;\n                } else if (type === \"{\") {\n                    open = true;\n                    break;\n                } else if (type === \"}\") {\n                    if (params.length > 0) {\n                        shift = params.length - 1;\n                        prev = params[shift];\n                        while(prev && prev[0] === \"space\"){\n                            prev = params[--shift];\n                        }\n                        if (prev) {\n                            node2.source.end = this.getPosition(prev[3] || prev[2]);\n                            node2.source.end.offset++;\n                        }\n                    }\n                    this.end(token);\n                    break;\n                } else {\n                    params.push(token);\n                }\n            } else {\n                params.push(token);\n            }\n            if (this.tokenizer.endOfFile()) {\n                last = true;\n                break;\n            }\n        }\n        node2.raws.between = this.spacesAndCommentsFromEnd(params);\n        if (params.length) {\n            node2.raws.afterName = this.spacesAndCommentsFromStart(params);\n            this.raw(node2, \"params\", params);\n            if (last) {\n                token = params[params.length - 1];\n                node2.source.end = this.getPosition(token[3] || token[2]);\n                node2.source.end.offset++;\n                this.spaces = node2.raws.between;\n                node2.raws.between = \"\";\n            }\n        } else {\n            node2.raws.afterName = \"\";\n            node2.params = \"\";\n        }\n        if (open) {\n            node2.nodes = [];\n            this.current = node2;\n        }\n    };\n    _proto.checkMissedSemicolon = function checkMissedSemicolon(tokens) {\n        var colon = this.colon(tokens);\n        if (colon === false) return;\n        var founded = 0;\n        var token;\n        for(var j = colon - 1; j >= 0; j--){\n            token = tokens[j];\n            if (token[0] !== \"space\") {\n                founded += 1;\n                if (founded === 2) break;\n            }\n        }\n        throw this.input.error(\"Missed semicolon\", token[0] === \"word\" ? token[3] + 1 : token[2]);\n    };\n    _proto.colon = function colon(tokens) {\n        var brackets = 0;\n        var token, type, prev;\n        for(var _iterator = _create_for_of_iterator_helper_loose(tokens.entries()), _step; !(_step = _iterator()).done;){\n            var _step_value = _step.value, i2 = _step_value[0], element = _step_value[1];\n            token = element;\n            type = token[0];\n            if (type === \"(\") {\n                brackets += 1;\n            }\n            if (type === \")\") {\n                brackets -= 1;\n            }\n            if (brackets === 0 && type === \":\") {\n                if (!prev) {\n                    this.doubleColon(token);\n                } else if (prev[0] === \"word\" && prev[1] === \"progid\") {\n                    continue;\n                } else {\n                    return i2;\n                }\n            }\n            prev = token;\n        }\n        return false;\n    };\n    _proto.comment = function comment(token) {\n        var node2 = new Comment$2$1();\n        this.init(node2, token[2]);\n        node2.source.end = this.getPosition(token[3] || token[2]);\n        node2.source.end.offset++;\n        var text = token[1].slice(2, -2);\n        if (/^\\s*$/.test(text)) {\n            node2.text = \"\";\n            node2.raws.left = text;\n            node2.raws.right = \"\";\n        } else {\n            var match = text.match(/^(\\s*)([^]*\\S)(\\s*)$/);\n            node2.text = match[2];\n            node2.raws.left = match[1];\n            node2.raws.right = match[3];\n        }\n    };\n    _proto.createTokenizer = function createTokenizer() {\n        this.tokenizer = tokenizer2$1(this.input);\n    };\n    _proto.decl = function decl(tokens, customProperty) {\n        var node2 = new Declaration$2$1();\n        this.init(node2, tokens[0][2]);\n        var last = tokens[tokens.length - 1];\n        if (last[0] === \";\") {\n            this.semicolon = true;\n            tokens.pop();\n        }\n        node2.source.end = this.getPosition(last[3] || last[2] || findLastWithPosition$1(tokens));\n        node2.source.end.offset++;\n        while(tokens[0][0] !== \"word\"){\n            if (tokens.length === 1) this.unknownWord(tokens);\n            node2.raws.before += tokens.shift()[1];\n        }\n        node2.source.start = this.getPosition(tokens[0][2]);\n        node2.prop = \"\";\n        while(tokens.length){\n            var type = tokens[0][0];\n            if (type === \":\" || type === \"space\" || type === \"comment\") {\n                break;\n            }\n            node2.prop += tokens.shift()[1];\n        }\n        node2.raws.between = \"\";\n        var token;\n        while(tokens.length){\n            token = tokens.shift();\n            if (token[0] === \":\") {\n                node2.raws.between += token[1];\n                break;\n            } else {\n                if (token[0] === \"word\" && /\\w/.test(token[1])) {\n                    this.unknownWord([\n                        token\n                    ]);\n                }\n                node2.raws.between += token[1];\n            }\n        }\n        if (node2.prop[0] === \"_\" || node2.prop[0] === \"*\") {\n            node2.raws.before += node2.prop[0];\n            node2.prop = node2.prop.slice(1);\n        }\n        var firstSpaces = [];\n        var next;\n        while(tokens.length){\n            next = tokens[0][0];\n            if (next !== \"space\" && next !== \"comment\") break;\n            firstSpaces.push(tokens.shift());\n        }\n        this.precheckMissedSemicolon(tokens);\n        for(var i2 = tokens.length - 1; i2 >= 0; i2--){\n            token = tokens[i2];\n            if (token[1].toLowerCase() === \"!important\") {\n                node2.important = true;\n                var string = this.stringFrom(tokens, i2);\n                string = this.spacesFromEnd(tokens) + string;\n                if (string !== \" !important\") node2.raws.important = string;\n                break;\n            } else if (token[1].toLowerCase() === \"important\") {\n                var cache = tokens.slice(0);\n                var str = \"\";\n                for(var j = i2; j > 0; j--){\n                    var type1 = cache[j][0];\n                    if (str.trim().indexOf(\"!\") === 0 && type1 !== \"space\") {\n                        break;\n                    }\n                    str = cache.pop()[1] + str;\n                }\n                if (str.trim().indexOf(\"!\") === 0) {\n                    node2.important = true;\n                    node2.raws.important = str;\n                    tokens = cache;\n                }\n            }\n            if (token[0] !== \"space\" && token[0] !== \"comment\") {\n                break;\n            }\n        }\n        var hasWord = tokens.some(function(i2) {\n            return i2[0] !== \"space\" && i2[0] !== \"comment\";\n        });\n        if (hasWord) {\n            node2.raws.between += firstSpaces.map(function(i2) {\n                return i2[1];\n            }).join(\"\");\n            firstSpaces = [];\n        }\n        this.raw(node2, \"value\", firstSpaces.concat(tokens), customProperty);\n        if (node2.value.includes(\":\") && !customProperty) {\n            this.checkMissedSemicolon(tokens);\n        }\n    };\n    _proto.doubleColon = function doubleColon(token) {\n        throw this.input.error(\"Double colon\", {\n            offset: token[2]\n        }, {\n            offset: token[2] + token[1].length\n        });\n    };\n    _proto.emptyRule = function emptyRule(token) {\n        var node2 = new Rule$2$1();\n        this.init(node2, token[2]);\n        node2.selector = \"\";\n        node2.raws.between = \"\";\n        this.current = node2;\n    };\n    _proto.end = function end(token) {\n        if (this.current.nodes && this.current.nodes.length) {\n            this.current.raws.semicolon = this.semicolon;\n        }\n        this.semicolon = false;\n        this.current.raws.after = (this.current.raws.after || \"\") + this.spaces;\n        this.spaces = \"\";\n        if (this.current.parent) {\n            this.current.source.end = this.getPosition(token[2]);\n            this.current.source.end.offset++;\n            this.current = this.current.parent;\n        } else {\n            this.unexpectedClose(token);\n        }\n    };\n    _proto.endFile = function endFile() {\n        if (this.current.parent) this.unclosedBlock();\n        if (this.current.nodes && this.current.nodes.length) {\n            this.current.raws.semicolon = this.semicolon;\n        }\n        this.current.raws.after = (this.current.raws.after || \"\") + this.spaces;\n        this.root.source.end = this.getPosition(this.tokenizer.position());\n    };\n    _proto.freeSemicolon = function freeSemicolon(token) {\n        this.spaces += token[1];\n        if (this.current.nodes) {\n            var prev = this.current.nodes[this.current.nodes.length - 1];\n            if (prev && prev.type === \"rule\" && !prev.raws.ownSemicolon) {\n                prev.raws.ownSemicolon = this.spaces;\n                this.spaces = \"\";\n            }\n        }\n    };\n    // Helpers\n    _proto.getPosition = function getPosition(offset) {\n        var pos = this.input.fromOffset(offset);\n        return {\n            column: pos.col,\n            line: pos.line,\n            offset: offset\n        };\n    };\n    _proto.init = function init(node2, offset) {\n        this.current.push(node2);\n        node2.source = {\n            input: this.input,\n            start: this.getPosition(offset)\n        };\n        node2.raws.before = this.spaces;\n        this.spaces = \"\";\n        if (node2.type !== \"comment\") this.semicolon = false;\n    };\n    _proto.other = function other(start) {\n        var end = false;\n        var type = null;\n        var colon = false;\n        var bracket = null;\n        var brackets = [];\n        var customProperty = start[1].startsWith(\"--\");\n        var tokens = [];\n        var token = start;\n        while(token){\n            type = token[0];\n            tokens.push(token);\n            if (type === \"(\" || type === \"[\") {\n                if (!bracket) bracket = token;\n                brackets.push(type === \"(\" ? \")\" : \"]\");\n            } else if (customProperty && colon && type === \"{\") {\n                if (!bracket) bracket = token;\n                brackets.push(\"}\");\n            } else if (brackets.length === 0) {\n                if (type === \";\") {\n                    if (colon) {\n                        this.decl(tokens, customProperty);\n                        return;\n                    } else {\n                        break;\n                    }\n                } else if (type === \"{\") {\n                    this.rule(tokens);\n                    return;\n                } else if (type === \"}\") {\n                    this.tokenizer.back(tokens.pop());\n                    end = true;\n                    break;\n                } else if (type === \":\") {\n                    colon = true;\n                }\n            } else if (type === brackets[brackets.length - 1]) {\n                brackets.pop();\n                if (brackets.length === 0) bracket = null;\n            }\n            token = this.tokenizer.nextToken();\n        }\n        if (this.tokenizer.endOfFile()) end = true;\n        if (brackets.length > 0) this.unclosedBracket(bracket);\n        if (end && colon) {\n            if (!customProperty) {\n                while(tokens.length){\n                    token = tokens[tokens.length - 1][0];\n                    if (token !== \"space\" && token !== \"comment\") break;\n                    this.tokenizer.back(tokens.pop());\n                }\n            }\n            this.decl(tokens, customProperty);\n        } else {\n            this.unknownWord(tokens);\n        }\n    };\n    _proto.parse = function parse() {\n        var token;\n        while(!this.tokenizer.endOfFile()){\n            token = this.tokenizer.nextToken();\n            switch(token[0]){\n                case \"space\":\n                    this.spaces += token[1];\n                    break;\n                case \";\":\n                    this.freeSemicolon(token);\n                    break;\n                case \"}\":\n                    this.end(token);\n                    break;\n                case \"comment\":\n                    this.comment(token);\n                    break;\n                case \"at-word\":\n                    this.atrule(token);\n                    break;\n                case \"{\":\n                    this.emptyRule(token);\n                    break;\n                default:\n                    this.other(token);\n                    break;\n            }\n        }\n        this.endFile();\n    };\n    _proto.precheckMissedSemicolon = function precheckMissedSemicolon() {};\n    _proto.raw = function raw(node2, prop, tokens, customProperty) {\n        var token, type;\n        var length = tokens.length;\n        var value = \"\";\n        var clean = true;\n        var next, prev;\n        for(var i2 = 0; i2 < length; i2 += 1){\n            token = tokens[i2];\n            type = token[0];\n            if (type === \"space\" && i2 === length - 1 && !customProperty) {\n                clean = false;\n            } else if (type === \"comment\") {\n                prev = tokens[i2 - 1] ? tokens[i2 - 1][0] : \"empty\";\n                next = tokens[i2 + 1] ? tokens[i2 + 1][0] : \"empty\";\n                if (!SAFE_COMMENT_NEIGHBOR$1[prev] && !SAFE_COMMENT_NEIGHBOR$1[next]) {\n                    if (value.slice(-1) === \",\") {\n                        clean = false;\n                    } else {\n                        value += token[1];\n                    }\n                } else {\n                    clean = false;\n                }\n            } else {\n                value += token[1];\n            }\n        }\n        if (!clean) {\n            var raw = tokens.reduce(function(all, i2) {\n                return all + i2[1];\n            }, \"\");\n            node2.raws[prop] = {\n                raw: raw,\n                value: value\n            };\n        }\n        node2[prop] = value;\n    };\n    _proto.rule = function rule(tokens) {\n        tokens.pop();\n        var node2 = new Rule$2$1();\n        this.init(node2, tokens[0][2]);\n        node2.raws.between = this.spacesAndCommentsFromEnd(tokens);\n        this.raw(node2, \"selector\", tokens);\n        this.current = node2;\n    };\n    _proto.spacesAndCommentsFromEnd = function spacesAndCommentsFromEnd(tokens) {\n        var lastTokenType;\n        var spaces = \"\";\n        while(tokens.length){\n            lastTokenType = tokens[tokens.length - 1][0];\n            if (lastTokenType !== \"space\" && lastTokenType !== \"comment\") break;\n            spaces = tokens.pop()[1] + spaces;\n        }\n        return spaces;\n    };\n    // Errors\n    _proto.spacesAndCommentsFromStart = function spacesAndCommentsFromStart(tokens) {\n        var next;\n        var spaces = \"\";\n        while(tokens.length){\n            next = tokens[0][0];\n            if (next !== \"space\" && next !== \"comment\") break;\n            spaces += tokens.shift()[1];\n        }\n        return spaces;\n    };\n    _proto.spacesFromEnd = function spacesFromEnd(tokens) {\n        var lastTokenType;\n        var spaces = \"\";\n        while(tokens.length){\n            lastTokenType = tokens[tokens.length - 1][0];\n            if (lastTokenType !== \"space\") break;\n            spaces = tokens.pop()[1] + spaces;\n        }\n        return spaces;\n    };\n    _proto.stringFrom = function stringFrom(tokens, from) {\n        var result2 = \"\";\n        for(var i2 = from; i2 < tokens.length; i2++){\n            result2 += tokens[i2][1];\n        }\n        tokens.splice(from, tokens.length - from);\n        return result2;\n    };\n    _proto.unclosedBlock = function unclosedBlock() {\n        var pos = this.current.source.start;\n        throw this.input.error(\"Unclosed block\", pos.line, pos.column);\n    };\n    _proto.unclosedBracket = function unclosedBracket(bracket) {\n        throw this.input.error(\"Unclosed bracket\", {\n            offset: bracket[2]\n        }, {\n            offset: bracket[2] + 1\n        });\n    };\n    _proto.unexpectedClose = function unexpectedClose(token) {\n        throw this.input.error(\"Unexpected }\", {\n            offset: token[2]\n        }, {\n            offset: token[2] + 1\n        });\n    };\n    _proto.unknownWord = function unknownWord(tokens) {\n        throw this.input.error(\"Unknown word\", {\n            offset: tokens[0][2]\n        }, {\n            offset: tokens[0][2] + tokens[0][1].length\n        });\n    };\n    _proto.unnamedAtrule = function unnamedAtrule(node2, token) {\n        throw this.input.error(\"At-rule without name\", {\n            offset: token[2]\n        }, {\n            offset: token[2] + token[1].length\n        });\n    };\n    return Parser;\n}();\nvar parser$1 = Parser$1$1;\nvar Container$2$1 = container$1;\nvar Parser2$1 = parser$1;\nvar Input$2$1 = input$1;\nfunction parse$3$1(css, opts) {\n    var input2 = new Input$2$1(css, opts);\n    var parser2 = new Parser2$1(input2);\n    try {\n        parser2.parse();\n    } catch (e2) {\n        if (true) {\n            if (e2.name === \"CssSyntaxError\" && opts && opts.from) {\n                if (/\\.scss$/i.test(opts.from)) {\n                    e2.message += \"\\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser\";\n                } else if (/\\.sass/i.test(opts.from)) {\n                    e2.message += \"\\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser\";\n                } else if (/\\.less$/i.test(opts.from)) {\n                    e2.message += \"\\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser\";\n                }\n            }\n        }\n        throw e2;\n    }\n    return parser2.root;\n}\nvar parse_1$1 = parse$3$1;\nparse$3$1.default = parse$3$1;\nContainer$2$1.registerParse(parse$3$1);\nvar isClean$3 = symbols$1.isClean, my$3 = symbols$1.my;\nvar MapGenerator$1$1 = mapGenerator$1;\nvar stringify$2$1 = stringify_1$1;\nvar Container$1$1 = container$1;\nvar Document$2$1 = document$1$1;\nvar warnOnce$1$1 = warnOnce$2$1;\nvar Result$2$1 = result$1;\nvar parse$2$1 = parse_1$1;\nvar Root$3$1 = root$1;\nvar TYPE_TO_CLASS_NAME$1 = {\n    atrule: \"AtRule\",\n    comment: \"Comment\",\n    decl: \"Declaration\",\n    document: \"Document\",\n    root: \"Root\",\n    rule: \"Rule\"\n};\nvar PLUGIN_PROPS$1 = {\n    AtRule: true,\n    AtRuleExit: true,\n    Comment: true,\n    CommentExit: true,\n    Declaration: true,\n    DeclarationExit: true,\n    Document: true,\n    DocumentExit: true,\n    Once: true,\n    OnceExit: true,\n    postcssPlugin: true,\n    prepare: true,\n    Root: true,\n    RootExit: true,\n    Rule: true,\n    RuleExit: true\n};\nvar NOT_VISITORS$1 = {\n    Once: true,\n    postcssPlugin: true,\n    prepare: true\n};\nvar CHILDREN$1 = 0;\nfunction isPromise$1(obj) {\n    return (typeof obj === \"undefined\" ? \"undefined\" : _type_of(obj)) === \"object\" && typeof obj.then === \"function\";\n}\nfunction getEvents$1(node2) {\n    var key = false;\n    var type = TYPE_TO_CLASS_NAME$1[node2.type];\n    if (node2.type === \"decl\") {\n        key = node2.prop.toLowerCase();\n    } else if (node2.type === \"atrule\") {\n        key = node2.name.toLowerCase();\n    }\n    if (key && node2.append) {\n        return [\n            type,\n            type + \"-\" + key,\n            CHILDREN$1,\n            type + \"Exit\",\n            type + \"Exit-\" + key\n        ];\n    } else if (key) {\n        return [\n            type,\n            type + \"-\" + key,\n            type + \"Exit\",\n            type + \"Exit-\" + key\n        ];\n    } else if (node2.append) {\n        return [\n            type,\n            CHILDREN$1,\n            type + \"Exit\"\n        ];\n    } else {\n        return [\n            type,\n            type + \"Exit\"\n        ];\n    }\n}\nfunction toStack$1(node2) {\n    var events;\n    if (node2.type === \"document\") {\n        events = [\n            \"Document\",\n            CHILDREN$1,\n            \"DocumentExit\"\n        ];\n    } else if (node2.type === \"root\") {\n        events = [\n            \"Root\",\n            CHILDREN$1,\n            \"RootExit\"\n        ];\n    } else {\n        events = getEvents$1(node2);\n    }\n    return {\n        eventIndex: 0,\n        events: events,\n        iterator: 0,\n        node: node2,\n        visitorIndex: 0,\n        visitors: []\n    };\n}\nfunction cleanMarks$1(node2) {\n    node2[isClean$3] = false;\n    if (node2.nodes) node2.nodes.forEach(function(i2) {\n        return cleanMarks$1(i2);\n    });\n    return node2;\n}\nvar postcss$2$1 = {};\nvar LazyResult$2$1 = /*#__PURE__*/ function() {\n    function LazyResult(processor2, css, opts) {\n        var _this = this;\n        this.stringified = false;\n        this.processed = false;\n        var root2;\n        if ((typeof css === \"undefined\" ? \"undefined\" : _type_of(css)) === \"object\" && css !== null && (css.type === \"root\" || css.type === \"document\")) {\n            root2 = cleanMarks$1(css);\n        } else if (_instanceof(css, LazyResult) || _instanceof(css, Result$2$1)) {\n            root2 = cleanMarks$1(css.root);\n            if (css.map) {\n                if (typeof opts.map === \"undefined\") opts.map = {};\n                if (!opts.map.inline) opts.map.inline = false;\n                opts.map.prev = css.map;\n            }\n        } else {\n            var parser2 = parse$2$1;\n            if (opts.syntax) parser2 = opts.syntax.parse;\n            if (opts.parser) parser2 = opts.parser;\n            if (parser2.parse) parser2 = parser2.parse;\n            try {\n                root2 = parser2(css, opts);\n            } catch (error) {\n                this.processed = true;\n                this.error = error;\n            }\n            if (root2 && !root2[my$3]) {\n                Container$1$1.rebuild(root2);\n            }\n        }\n        this.result = new Result$2$1(processor2, root2, opts);\n        this.helpers = _extends({}, postcss$2$1, {\n            postcss: postcss$2$1,\n            result: this.result\n        });\n        this.plugins = this.processor.plugins.map(function(plugin22) {\n            if ((typeof plugin22 === \"undefined\" ? \"undefined\" : _type_of(plugin22)) === \"object\" && plugin22.prepare) {\n                return _extends({}, plugin22, plugin22.prepare(_this.result));\n            } else {\n                return plugin22;\n            }\n        });\n    }\n    var _proto = LazyResult.prototype;\n    _proto.async = function async() {\n        if (this.error) return Promise.reject(this.error);\n        if (this.processed) return Promise.resolve(this.result);\n        if (!this.processing) {\n            this.processing = this.runAsync();\n        }\n        return this.processing;\n    };\n    _proto.catch = function _catch(onRejected) {\n        return this.async().catch(onRejected);\n    };\n    _proto.finally = function _finally(onFinally) {\n        return this.async().then(onFinally, onFinally);\n    };\n    _proto.getAsyncError = function getAsyncError() {\n        throw new Error(\"Use process(css).then(cb) to work with async plugins\");\n    };\n    _proto.handleError = function handleError(error, node2) {\n        var plugin22 = this.result.lastPlugin;\n        try {\n            if (node2) node2.addToError(error);\n            this.error = error;\n            if (error.name === \"CssSyntaxError\" && !error.plugin) {\n                error.plugin = plugin22.postcssPlugin;\n                error.setMessage();\n            } else if (plugin22.postcssVersion) {\n                if (true) {\n                    var pluginName = plugin22.postcssPlugin;\n                    var pluginVer = plugin22.postcssVersion;\n                    var runtimeVer = this.result.processor.version;\n                    var a2 = pluginVer.split(\".\");\n                    var b = runtimeVer.split(\".\");\n                    if (a2[0] !== b[0] || parseInt(a2[1]) > parseInt(b[1])) {\n                        console.error(\"Unknown error from PostCSS plugin. Your current PostCSS version is \" + runtimeVer + \", but \" + pluginName + \" uses \" + pluginVer + \". Perhaps this is the source of the error below.\");\n                    }\n                }\n            }\n        } catch (err) {\n            if (console && console.error) console.error(err);\n        }\n        return error;\n    };\n    _proto.prepareVisitors = function prepareVisitors() {\n        var _this = this;\n        this.listeners = {};\n        var add = function(plugin22, type, cb) {\n            if (!_this.listeners[type]) _this.listeners[type] = [];\n            _this.listeners[type].push([\n                plugin22,\n                cb\n            ]);\n        };\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.plugins), _step; !(_step = _iterator()).done;){\n            var plugin22 = _step.value;\n            if ((typeof plugin22 === \"undefined\" ? \"undefined\" : _type_of(plugin22)) === \"object\") {\n                for(var event in plugin22){\n                    if (!PLUGIN_PROPS$1[event] && /^[A-Z]/.test(event)) {\n                        throw new Error(\"Unknown event \" + event + \" in \" + plugin22.postcssPlugin + \". Try to update PostCSS (\" + this.processor.version + \" now).\");\n                    }\n                    if (!NOT_VISITORS$1[event]) {\n                        if (_type_of(plugin22[event]) === \"object\") {\n                            for(var filter in plugin22[event]){\n                                if (filter === \"*\") {\n                                    add(plugin22, event, plugin22[event][filter]);\n                                } else {\n                                    add(plugin22, event + \"-\" + filter.toLowerCase(), plugin22[event][filter]);\n                                }\n                            }\n                        } else if (typeof plugin22[event] === \"function\") {\n                            add(plugin22, event, plugin22[event]);\n                        }\n                    }\n                }\n            }\n        }\n        this.hasListener = Object.keys(this.listeners).length > 0;\n    };\n    _proto.runAsync = function runAsync() {\n        var _this = this;\n        return _async_to_generator(function() {\n            var i2, plugin22, promise, error, root2, stack, promise1, e2, node2, _loop, _iterator, _step;\n            return _ts_generator(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        _this.plugin = 0;\n                        i2 = 0;\n                        _state.label = 1;\n                    case 1:\n                        if (!(i2 < _this.plugins.length)) return [\n                            3,\n                            6\n                        ];\n                        plugin22 = _this.plugins[i2];\n                        promise = _this.runOnRoot(plugin22);\n                        if (!isPromise$1(promise)) return [\n                            3,\n                            5\n                        ];\n                        _state.label = 2;\n                    case 2:\n                        _state.trys.push([\n                            2,\n                            4,\n                            ,\n                            5\n                        ]);\n                        return [\n                            4,\n                            promise\n                        ];\n                    case 3:\n                        _state.sent();\n                        return [\n                            3,\n                            5\n                        ];\n                    case 4:\n                        error = _state.sent();\n                        throw _this.handleError(error);\n                    case 5:\n                        i2++;\n                        return [\n                            3,\n                            1\n                        ];\n                    case 6:\n                        _this.prepareVisitors();\n                        if (!_this.hasListener) return [\n                            3,\n                            18\n                        ];\n                        root2 = _this.result.root;\n                        _state.label = 7;\n                    case 7:\n                        if (!!root2[isClean$3]) return [\n                            3,\n                            14\n                        ];\n                        root2[isClean$3] = true;\n                        stack = [\n                            toStack$1(root2)\n                        ];\n                        _state.label = 8;\n                    case 8:\n                        if (!(stack.length > 0)) return [\n                            3,\n                            13\n                        ];\n                        promise1 = _this.visitTick(stack);\n                        if (!isPromise$1(promise1)) return [\n                            3,\n                            12\n                        ];\n                        _state.label = 9;\n                    case 9:\n                        _state.trys.push([\n                            9,\n                            11,\n                            ,\n                            12\n                        ]);\n                        return [\n                            4,\n                            promise1\n                        ];\n                    case 10:\n                        _state.sent();\n                        return [\n                            3,\n                            12\n                        ];\n                    case 11:\n                        e2 = _state.sent();\n                        node2 = stack[stack.length - 1].node;\n                        throw _this.handleError(e2, node2);\n                    case 12:\n                        return [\n                            3,\n                            8\n                        ];\n                    case 13:\n                        return [\n                            3,\n                            7\n                        ];\n                    case 14:\n                        if (!_this.listeners.OnceExit) return [\n                            3,\n                            18\n                        ];\n                        _loop = function() {\n                            var _step_value, plugin22, visitor, roots, e2;\n                            return _ts_generator(this, function(_state) {\n                                switch(_state.label){\n                                    case 0:\n                                        _step_value = _step.value, plugin22 = _step_value[0], visitor = _step_value[1];\n                                        _this.result.lastPlugin = plugin22;\n                                        _state.label = 1;\n                                    case 1:\n                                        _state.trys.push([\n                                            1,\n                                            6,\n                                            ,\n                                            7\n                                        ]);\n                                        if (!(root2.type === \"document\")) return [\n                                            3,\n                                            3\n                                        ];\n                                        roots = root2.nodes.map(function(subRoot) {\n                                            return visitor(subRoot, _this.helpers);\n                                        });\n                                        return [\n                                            4,\n                                            Promise.all(roots)\n                                        ];\n                                    case 2:\n                                        _state.sent();\n                                        return [\n                                            3,\n                                            5\n                                        ];\n                                    case 3:\n                                        return [\n                                            4,\n                                            visitor(root2, _this.helpers)\n                                        ];\n                                    case 4:\n                                        _state.sent();\n                                        _state.label = 5;\n                                    case 5:\n                                        return [\n                                            3,\n                                            7\n                                        ];\n                                    case 6:\n                                        e2 = _state.sent();\n                                        throw _this.handleError(e2);\n                                    case 7:\n                                        return [\n                                            2\n                                        ];\n                                }\n                            });\n                        };\n                        _iterator = _create_for_of_iterator_helper_loose(_this.listeners.OnceExit);\n                        _state.label = 15;\n                    case 15:\n                        if (!!(_step = _iterator()).done) return [\n                            3,\n                            18\n                        ];\n                        return [\n                            5,\n                            _ts_values(_loop())\n                        ];\n                    case 16:\n                        _state.sent();\n                        _state.label = 17;\n                    case 17:\n                        return [\n                            3,\n                            15\n                        ];\n                    case 18:\n                        _this.processed = true;\n                        return [\n                            2,\n                            _this.stringify()\n                        ];\n                }\n            });\n        })();\n    };\n    _proto.runOnRoot = function runOnRoot(plugin22) {\n        var _this = this;\n        this.result.lastPlugin = plugin22;\n        try {\n            if ((typeof plugin22 === \"undefined\" ? \"undefined\" : _type_of(plugin22)) === \"object\" && plugin22.Once) {\n                if (this.result.root.type === \"document\") {\n                    var roots = this.result.root.nodes.map(function(root2) {\n                        return plugin22.Once(root2, _this.helpers);\n                    });\n                    if (isPromise$1(roots[0])) {\n                        return Promise.all(roots);\n                    }\n                    return roots;\n                }\n                return plugin22.Once(this.result.root, this.helpers);\n            } else if (typeof plugin22 === \"function\") {\n                return plugin22(this.result.root, this.result);\n            }\n        } catch (error) {\n            throw this.handleError(error);\n        }\n    };\n    _proto.stringify = function stringify() {\n        if (this.error) throw this.error;\n        if (this.stringified) return this.result;\n        this.stringified = true;\n        this.sync();\n        var opts = this.result.opts;\n        var str = stringify$2$1;\n        if (opts.syntax) str = opts.syntax.stringify;\n        if (opts.stringifier) str = opts.stringifier;\n        if (str.stringify) str = str.stringify;\n        var map = new MapGenerator$1$1(str, this.result.root, this.result.opts);\n        var data = map.generate();\n        this.result.css = data[0];\n        this.result.map = data[1];\n        return this.result;\n    };\n    _proto.sync = function sync() {\n        if (this.error) throw this.error;\n        if (this.processed) return this.result;\n        this.processed = true;\n        if (this.processing) {\n            throw this.getAsyncError();\n        }\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.plugins), _step; !(_step = _iterator()).done;){\n            var plugin22 = _step.value;\n            var promise = this.runOnRoot(plugin22);\n            if (isPromise$1(promise)) {\n                throw this.getAsyncError();\n            }\n        }\n        this.prepareVisitors();\n        if (this.hasListener) {\n            var root2 = this.result.root;\n            while(!root2[isClean$3]){\n                root2[isClean$3] = true;\n                this.walkSync(root2);\n            }\n            if (this.listeners.OnceExit) {\n                if (root2.type === \"document\") {\n                    for(var _iterator1 = _create_for_of_iterator_helper_loose(root2.nodes), _step1; !(_step1 = _iterator1()).done;){\n                        var subRoot = _step1.value;\n                        this.visitSync(this.listeners.OnceExit, subRoot);\n                    }\n                } else {\n                    this.visitSync(this.listeners.OnceExit, root2);\n                }\n            }\n        }\n        return this.result;\n    };\n    _proto.then = function then(onFulfilled, onRejected) {\n        if (true) {\n            if (!(\"from\" in this.opts)) {\n                warnOnce$1$1(\"Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.\");\n            }\n        }\n        return this.async().then(onFulfilled, onRejected);\n    };\n    _proto.toString = function toString() {\n        return this.css;\n    };\n    _proto.visitSync = function visitSync(visitors, node2) {\n        for(var _iterator = _create_for_of_iterator_helper_loose(visitors), _step; !(_step = _iterator()).done;){\n            var _step_value = _step.value, plugin22 = _step_value[0], visitor = _step_value[1];\n            this.result.lastPlugin = plugin22;\n            var promise = void 0;\n            try {\n                promise = visitor(node2, this.helpers);\n            } catch (e2) {\n                throw this.handleError(e2, node2.proxyOf);\n            }\n            if (node2.type !== \"root\" && node2.type !== \"document\" && !node2.parent) {\n                return true;\n            }\n            if (isPromise$1(promise)) {\n                throw this.getAsyncError();\n            }\n        }\n    };\n    _proto.visitTick = function visitTick(stack) {\n        var visit2 = stack[stack.length - 1];\n        var node2 = visit2.node, visitors = visit2.visitors;\n        if (node2.type !== \"root\" && node2.type !== \"document\" && !node2.parent) {\n            stack.pop();\n            return;\n        }\n        if (visitors.length > 0 && visit2.visitorIndex < visitors.length) {\n            var _visitors_visit2_visitorIndex = visitors[visit2.visitorIndex], plugin22 = _visitors_visit2_visitorIndex[0], visitor = _visitors_visit2_visitorIndex[1];\n            visit2.visitorIndex += 1;\n            if (visit2.visitorIndex === visitors.length) {\n                visit2.visitors = [];\n                visit2.visitorIndex = 0;\n            }\n            this.result.lastPlugin = plugin22;\n            try {\n                return visitor(node2.toProxy(), this.helpers);\n            } catch (e2) {\n                throw this.handleError(e2, node2);\n            }\n        }\n        if (visit2.iterator !== 0) {\n            var iterator = visit2.iterator;\n            var child;\n            while(child = node2.nodes[node2.indexes[iterator]]){\n                node2.indexes[iterator] += 1;\n                if (!child[isClean$3]) {\n                    child[isClean$3] = true;\n                    stack.push(toStack$1(child));\n                    return;\n                }\n            }\n            visit2.iterator = 0;\n            delete node2.indexes[iterator];\n        }\n        var events = visit2.events;\n        while(visit2.eventIndex < events.length){\n            var event = events[visit2.eventIndex];\n            visit2.eventIndex += 1;\n            if (event === CHILDREN$1) {\n                if (node2.nodes && node2.nodes.length) {\n                    node2[isClean$3] = true;\n                    visit2.iterator = node2.getIterator();\n                }\n                return;\n            } else if (this.listeners[event]) {\n                visit2.visitors = this.listeners[event];\n                return;\n            }\n        }\n        stack.pop();\n    };\n    _proto.walkSync = function walkSync(node2) {\n        var _this = this;\n        node2[isClean$3] = true;\n        var events = getEvents$1(node2);\n        for(var _iterator = _create_for_of_iterator_helper_loose(events), _step; !(_step = _iterator()).done;){\n            var event = _step.value;\n            if (event === CHILDREN$1) {\n                if (node2.nodes) {\n                    node2.each(function(child) {\n                        if (!child[isClean$3]) _this.walkSync(child);\n                    });\n                }\n            } else {\n                var visitors = this.listeners[event];\n                if (visitors) {\n                    if (this.visitSync(visitors, node2.toProxy())) return;\n                }\n            }\n        }\n    };\n    _proto.warnings = function warnings() {\n        return this.sync().warnings();\n    };\n    _create_class(LazyResult, [\n        {\n            key: \"content\",\n            get: function get() {\n                return this.stringify().content;\n            }\n        },\n        {\n            key: \"css\",\n            get: function get() {\n                return this.stringify().css;\n            }\n        },\n        {\n            key: \"map\",\n            get: function get() {\n                return this.stringify().map;\n            }\n        },\n        {\n            key: \"messages\",\n            get: function get() {\n                return this.sync().messages;\n            }\n        },\n        {\n            key: \"opts\",\n            get: function get() {\n                return this.result.opts;\n            }\n        },\n        {\n            key: \"processor\",\n            get: function get() {\n                return this.result.processor;\n            }\n        },\n        {\n            key: \"root\",\n            get: function get() {\n                return this.sync().root;\n            }\n        },\n        {\n            key: Symbol.toStringTag,\n            get: function get() {\n                return \"LazyResult\";\n            }\n        }\n    ]);\n    return LazyResult;\n}();\nLazyResult$2$1.registerPostcss = function(dependant) {\n    postcss$2$1 = dependant;\n};\nvar lazyResult$1 = LazyResult$2$1;\nLazyResult$2$1.default = LazyResult$2$1;\nRoot$3$1.registerLazyResult(LazyResult$2$1);\nDocument$2$1.registerLazyResult(LazyResult$2$1);\nvar MapGenerator2$1 = mapGenerator$1;\nvar stringify$1$1 = stringify_1$1;\nvar warnOnce2$1 = warnOnce$2$1;\nvar parse$1$1 = parse_1$1;\nvar Result$1$1 = result$1;\nvar NoWorkResult$1$1 = /*#__PURE__*/ function() {\n    function NoWorkResult(processor2, css, opts) {\n        css = css.toString();\n        this.stringified = false;\n        this._processor = processor2;\n        this._css = css;\n        this._opts = opts;\n        this._map = void 0;\n        var root2;\n        var str = stringify$1$1;\n        this.result = new Result$1$1(this._processor, root2, this._opts);\n        this.result.css = css;\n        var self = this;\n        Object.defineProperty(this.result, \"root\", {\n            get: function get() {\n                return self.root;\n            }\n        });\n        var map = new MapGenerator2$1(str, root2, this._opts, css);\n        if (map.isMap()) {\n            var _map_generate = map.generate(), generatedCSS = _map_generate[0], generatedMap = _map_generate[1];\n            if (generatedCSS) {\n                this.result.css = generatedCSS;\n            }\n            if (generatedMap) {\n                this.result.map = generatedMap;\n            }\n        } else {\n            map.clearAnnotation();\n            this.result.css = map.css;\n        }\n    }\n    var _proto = NoWorkResult.prototype;\n    _proto.async = function async() {\n        if (this.error) return Promise.reject(this.error);\n        return Promise.resolve(this.result);\n    };\n    _proto.catch = function _catch(onRejected) {\n        return this.async().catch(onRejected);\n    };\n    _proto.finally = function _finally(onFinally) {\n        return this.async().then(onFinally, onFinally);\n    };\n    _proto.sync = function sync() {\n        if (this.error) throw this.error;\n        return this.result;\n    };\n    _proto.then = function then(onFulfilled, onRejected) {\n        if (true) {\n            if (!(\"from\" in this._opts)) {\n                warnOnce2$1(\"Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.\");\n            }\n        }\n        return this.async().then(onFulfilled, onRejected);\n    };\n    _proto.toString = function toString() {\n        return this._css;\n    };\n    _proto.warnings = function warnings() {\n        return [];\n    };\n    _create_class(NoWorkResult, [\n        {\n            key: \"content\",\n            get: function get() {\n                return this.result.css;\n            }\n        },\n        {\n            key: \"css\",\n            get: function get() {\n                return this.result.css;\n            }\n        },\n        {\n            key: \"map\",\n            get: function get() {\n                return this.result.map;\n            }\n        },\n        {\n            key: \"messages\",\n            get: function get() {\n                return [];\n            }\n        },\n        {\n            key: \"opts\",\n            get: function get() {\n                return this.result.opts;\n            }\n        },\n        {\n            key: \"processor\",\n            get: function get() {\n                return this.result.processor;\n            }\n        },\n        {\n            key: \"root\",\n            get: function get() {\n                if (this._root) {\n                    return this._root;\n                }\n                var root2;\n                var parser2 = parse$1$1;\n                try {\n                    root2 = parser2(this._css, this._opts);\n                } catch (error) {\n                    this.error = error;\n                }\n                if (this.error) {\n                    throw this.error;\n                } else {\n                    this._root = root2;\n                    return root2;\n                }\n            }\n        },\n        {\n            key: Symbol.toStringTag,\n            get: function get() {\n                return \"NoWorkResult\";\n            }\n        }\n    ]);\n    return NoWorkResult;\n}();\nvar noWorkResult$1 = NoWorkResult$1$1;\nNoWorkResult$1$1.default = NoWorkResult$1$1;\nvar NoWorkResult2$1 = noWorkResult$1;\nvar LazyResult$1$1 = lazyResult$1;\nvar Document$1$1 = document$1$1;\nvar Root$2$1 = root$1;\nvar Processor$1$1 = /*#__PURE__*/ function() {\n    function Processor(plugins) {\n        if (plugins === void 0) plugins = [];\n        this.version = \"8.4.38\";\n        this.plugins = this.normalize(plugins);\n    }\n    var _proto = Processor.prototype;\n    _proto.normalize = function normalize(plugins) {\n        var normalized = [];\n        for(var _iterator = _create_for_of_iterator_helper_loose(plugins), _step; !(_step = _iterator()).done;){\n            var i2 = _step.value;\n            if (i2.postcss === true) {\n                i2 = i2();\n            } else if (i2.postcss) {\n                i2 = i2.postcss;\n            }\n            if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && Array.isArray(i2.plugins)) {\n                normalized = normalized.concat(i2.plugins);\n            } else if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && i2.postcssPlugin) {\n                normalized.push(i2);\n            } else if (typeof i2 === \"function\") {\n                normalized.push(i2);\n            } else if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && (i2.parse || i2.stringify)) {\n                if (true) {\n                    throw new Error(\"PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation.\");\n                }\n            } else {\n                throw new Error(i2 + \" is not a PostCSS plugin\");\n            }\n        }\n        return normalized;\n    };\n    _proto.process = function process1(css, opts) {\n        if (opts === void 0) opts = {};\n        if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) {\n            return new NoWorkResult2$1(this, css, opts);\n        } else {\n            return new LazyResult$1$1(this, css, opts);\n        }\n    };\n    _proto.use = function use(plugin22) {\n        this.plugins = this.plugins.concat(this.normalize([\n            plugin22\n        ]));\n        return this;\n    };\n    return Processor;\n}();\nvar processor$1 = Processor$1$1;\nProcessor$1$1.default = Processor$1$1;\nRoot$2$1.registerProcessor(Processor$1$1);\nDocument$1$1.registerProcessor(Processor$1$1);\nvar Declaration$1$1 = declaration$1;\nvar PreviousMap2$1 = previousMap$1;\nvar Comment$1$1 = comment$1;\nvar AtRule$1$1 = atRule$1;\nvar Input$1$1 = input$1;\nvar Root$1$1 = root$1;\nvar Rule$1$1 = rule$1;\nfunction fromJSON$1$1(json, inputs) {\n    if (Array.isArray(json)) return json.map(function(n2) {\n        return fromJSON$1$1(n2);\n    });\n    var ownInputs = json.inputs, defaults = _object_without_properties_loose(json, [\n        \"inputs\"\n    ]);\n    if (ownInputs) {\n        inputs = [];\n        for(var _iterator = _create_for_of_iterator_helper_loose(ownInputs), _step; !(_step = _iterator()).done;){\n            var input2 = _step.value;\n            var inputHydrated = _extends({}, input2, {\n                __proto__: Input$1$1.prototype\n            });\n            if (inputHydrated.map) {\n                inputHydrated.map = _extends({}, inputHydrated.map, {\n                    __proto__: PreviousMap2$1.prototype\n                });\n            }\n            inputs.push(inputHydrated);\n        }\n    }\n    if (defaults.nodes) {\n        defaults.nodes = json.nodes.map(function(n2) {\n            return fromJSON$1$1(n2, inputs);\n        });\n    }\n    if (defaults.source) {\n        var _defaults_source = defaults.source, inputId = _defaults_source.inputId, source = _object_without_properties_loose(_defaults_source, [\n            \"inputId\"\n        ]);\n        defaults.source = source;\n        if (inputId != null) {\n            defaults.source.input = inputs[inputId];\n        }\n    }\n    if (defaults.type === \"root\") {\n        return new Root$1$1(defaults);\n    } else if (defaults.type === \"decl\") {\n        return new Declaration$1$1(defaults);\n    } else if (defaults.type === \"rule\") {\n        return new Rule$1$1(defaults);\n    } else if (defaults.type === \"comment\") {\n        return new Comment$1$1(defaults);\n    } else if (defaults.type === \"atrule\") {\n        return new AtRule$1$1(defaults);\n    } else {\n        throw new Error(\"Unknown node type: \" + json.type);\n    }\n}\nvar fromJSON_1$1 = fromJSON$1$1;\nfromJSON$1$1.default = fromJSON$1$1;\nvar CssSyntaxError2$1 = cssSyntaxError$1;\nvar Declaration2$1 = declaration$1;\nvar LazyResult2$1 = lazyResult$1;\nvar Container2$1 = container$1;\nvar Processor2$1 = processor$1;\nvar stringify$5 = stringify_1$1;\nvar fromJSON$2 = fromJSON_1$1;\nvar Document22 = document$1$1;\nvar Warning2$1 = warning$1;\nvar Comment2$1 = comment$1;\nvar AtRule2$1 = atRule$1;\nvar Result2$1 = result$1;\nvar Input2$1 = input$1;\nvar parse$5 = parse_1$1;\nvar list$3 = list_1$1;\nvar Rule2$1 = rule$1;\nvar Root2$1 = root$1;\nvar Node2$1 = node$1;\nfunction postcss$3() {\n    for(var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++){\n        plugins[_key] = arguments[_key];\n    }\n    if (plugins.length === 1 && Array.isArray(plugins[0])) {\n        plugins = plugins[0];\n    }\n    return new Processor2$1(plugins);\n}\npostcss$3.plugin = function plugin(name, initializer) {\n    var warningPrinted = false;\n    function creator() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (console && console.warn && !warningPrinted) {\n            warningPrinted = true;\n            console.warn(name + \": postcss.plugin was deprecated. Migration guide:\\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration\");\n            if (process.env.LANG && process.env.LANG.startsWith(\"cn\")) {\n                console.warn(name + \":  postcss.plugin . :\\nhttps://www.w3ctech.com/topic/2226\");\n            }\n        }\n        var transformer = initializer.apply(void 0, [].concat(args));\n        transformer.postcssPlugin = name;\n        transformer.postcssVersion = new Processor2$1().version;\n        return transformer;\n    }\n    var cache;\n    Object.defineProperty(creator, \"postcss\", {\n        get: function get() {\n            if (!cache) cache = creator();\n            return cache;\n        }\n    });\n    creator.process = function(css, processOpts, pluginOpts) {\n        return postcss$3([\n            creator(pluginOpts)\n        ]).process(css, processOpts);\n    };\n    return creator;\n};\npostcss$3.stringify = stringify$5;\npostcss$3.parse = parse$5;\npostcss$3.fromJSON = fromJSON$2;\npostcss$3.list = list$3;\npostcss$3.comment = function(defaults) {\n    return new Comment2$1(defaults);\n};\npostcss$3.atRule = function(defaults) {\n    return new AtRule2$1(defaults);\n};\npostcss$3.decl = function(defaults) {\n    return new Declaration2$1(defaults);\n};\npostcss$3.rule = function(defaults) {\n    return new Rule2$1(defaults);\n};\npostcss$3.root = function(defaults) {\n    return new Root2$1(defaults);\n};\npostcss$3.document = function(defaults) {\n    return new Document22(defaults);\n};\npostcss$3.CssSyntaxError = CssSyntaxError2$1;\npostcss$3.Declaration = Declaration2$1;\npostcss$3.Container = Container2$1;\npostcss$3.Processor = Processor2$1;\npostcss$3.Document = Document22;\npostcss$3.Comment = Comment2$1;\npostcss$3.Warning = Warning2$1;\npostcss$3.AtRule = AtRule2$1;\npostcss$3.Result = Result2$1;\npostcss$3.Input = Input2$1;\npostcss$3.Rule = Rule2$1;\npostcss$3.Root = Root2$1;\npostcss$3.Node = Node2$1;\nLazyResult2$1.registerPostcss(postcss$3);\nvar postcss_1$1 = postcss$3;\npostcss$3.default = postcss$3;\nvar postcss$1$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(postcss_1$1);\npostcss$1$1.stringify;\npostcss$1$1.fromJSON;\npostcss$1$1.plugin;\npostcss$1$1.parse;\npostcss$1$1.list;\npostcss$1$1.document;\npostcss$1$1.comment;\npostcss$1$1.atRule;\npostcss$1$1.rule;\npostcss$1$1.decl;\npostcss$1$1.root;\npostcss$1$1.CssSyntaxError;\npostcss$1$1.Declaration;\npostcss$1$1.Container;\npostcss$1$1.Processor;\npostcss$1$1.Document;\npostcss$1$1.Comment;\npostcss$1$1.Warning;\npostcss$1$1.AtRule;\npostcss$1$1.Result;\npostcss$1$1.Input;\npostcss$1$1.Rule;\npostcss$1$1.Root;\npostcss$1$1.Node;\nvar __defProp2 = Object.defineProperty;\nvar __defNormalProp2 = function(obj, key, value) {\n    return key in obj ? __defProp2(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: value\n    }) : obj[key] = value;\n};\nvar __publicField2 = function(obj, key, value) {\n    return __defNormalProp2(obj, (typeof key === \"undefined\" ? \"undefined\" : _type_of(key)) !== \"symbol\" ? key + \"\" : key, value);\n};\nfunction getDefaultExportFromCjs(x2) {\n    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, \"default\") ? x2[\"default\"] : x2;\n}\nfunction getAugmentedNamespace(n2) {\n    if (n2.__esModule) return n2;\n    var f2 = n2.default;\n    if (typeof f2 == \"function\") {\n        var a2 = function a22() {\n            if (_instanceof(this, a22)) {\n                return Reflect.construct(f2, arguments, this.constructor);\n            }\n            return f2.apply(this, arguments);\n        };\n        a2.prototype = f2.prototype;\n    } else a2 = {};\n    Object.defineProperty(a2, \"__esModule\", {\n        value: true\n    });\n    Object.keys(n2).forEach(function(k) {\n        var d = Object.getOwnPropertyDescriptor(n2, k);\n        Object.defineProperty(a2, k, d.get ? d : {\n            enumerable: true,\n            get: function get() {\n                return n2[k];\n            }\n        });\n    });\n    return a2;\n}\nvar picocolors_browser = {\n    exports: {}\n};\nvar x = String;\nvar create = function create() {\n    return {\n        isColorSupported: false,\n        reset: x,\n        bold: x,\n        dim: x,\n        italic: x,\n        underline: x,\n        inverse: x,\n        hidden: x,\n        strikethrough: x,\n        black: x,\n        red: x,\n        green: x,\n        yellow: x,\n        blue: x,\n        magenta: x,\n        cyan: x,\n        white: x,\n        gray: x,\n        bgBlack: x,\n        bgRed: x,\n        bgGreen: x,\n        bgYellow: x,\n        bgBlue: x,\n        bgMagenta: x,\n        bgCyan: x,\n        bgWhite: x\n    };\n};\npicocolors_browser.exports = create();\npicocolors_browser.exports.createColors = create;\nvar picocolors_browserExports = picocolors_browser.exports;\nvar __viteBrowserExternal = {};\nvar __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n    __proto__: null,\n    default: __viteBrowserExternal\n}, Symbol.toStringTag, {\n    value: \"Module\"\n}));\nvar require$$2 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);\nvar pico = picocolors_browserExports;\nvar terminalHighlight$1 = require$$2;\nvar CssSyntaxError$3 = /*#__PURE__*/ function(Error1) {\n    _inherits(CssSyntaxError2, Error1);\n    function CssSyntaxError2(message, line, column, source, file, plugin22) {\n        var _this;\n        _this = Error1.call(this, message) || this;\n        _this.name = \"CssSyntaxError\";\n        _this.reason = message;\n        if (file) {\n            _this.file = file;\n        }\n        if (source) {\n            _this.source = source;\n        }\n        if (plugin22) {\n            _this.plugin = plugin22;\n        }\n        if (typeof line !== \"undefined\" && typeof column !== \"undefined\") {\n            if (typeof line === \"number\") {\n                _this.line = line;\n                _this.column = column;\n            } else {\n                _this.line = line.line;\n                _this.column = line.column;\n                _this.endLine = column.line;\n                _this.endColumn = column.column;\n            }\n        }\n        _this.setMessage();\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(_this, CssSyntaxError2);\n        }\n        return _this;\n    }\n    var _proto = CssSyntaxError2.prototype;\n    _proto.setMessage = function setMessage() {\n        this.message = this.plugin ? this.plugin + \": \" : \"\";\n        this.message += this.file ? this.file : \"<css input>\";\n        if (typeof this.line !== \"undefined\") {\n            this.message += \":\" + this.line + \":\" + this.column;\n        }\n        this.message += \": \" + this.reason;\n    };\n    _proto.showSourceCode = function showSourceCode(color) {\n        var _this = this;\n        if (!this.source) return \"\";\n        var css = this.source;\n        if (color == null) color = pico.isColorSupported;\n        if (terminalHighlight$1) {\n            if (color) css = terminalHighlight$1(css);\n        }\n        var lines = css.split(/\\r?\\n/);\n        var start = Math.max(this.line - 3, 0);\n        var end = Math.min(this.line + 2, lines.length);\n        var maxWidth = String(end).length;\n        var mark, aside;\n        if (color) {\n            var _pico_createColors = pico.createColors(true), bold = _pico_createColors.bold, gray = _pico_createColors.gray, red = _pico_createColors.red;\n            mark = function(text) {\n                return bold(red(text));\n            };\n            aside = function(text) {\n                return gray(text);\n            };\n        } else {\n            mark = aside = function(str) {\n                return str;\n            };\n        }\n        return lines.slice(start, end).map(function(line, index2) {\n            var number = start + 1 + index2;\n            var gutter = \" \" + (\" \" + number).slice(-maxWidth) + \" | \";\n            if (number === _this.line) {\n                var spacing = aside(gutter.replace(/\\d/g, \" \")) + line.slice(0, _this.column - 1).replace(/[^\\t]/g, \" \");\n                return mark(\">\") + aside(gutter) + line + \"\\n \" + spacing + mark(\"^\");\n            }\n            return \" \" + aside(gutter) + line;\n        }).join(\"\\n\");\n    };\n    _proto.toString = function toString() {\n        var code = this.showSourceCode();\n        if (code) {\n            code = \"\\n\\n\" + code + \"\\n\";\n        }\n        return this.name + \": \" + this.message + code;\n    };\n    return CssSyntaxError2;\n}(_wrap_native_super(Error));\nvar cssSyntaxError = CssSyntaxError$3;\nCssSyntaxError$3.default = CssSyntaxError$3;\nvar symbols = {};\nsymbols.isClean = Symbol(\"isClean\");\nsymbols.my = Symbol(\"my\");\nvar DEFAULT_RAW = {\n    after: \"\\n\",\n    beforeClose: \"\\n\",\n    beforeComment: \"\\n\",\n    beforeDecl: \"\\n\",\n    beforeOpen: \" \",\n    beforeRule: \"\\n\",\n    colon: \": \",\n    commentLeft: \" \",\n    commentRight: \" \",\n    emptyBody: \"\",\n    indent: \"    \",\n    semicolon: false\n};\nfunction capitalize(str) {\n    return str[0].toUpperCase() + str.slice(1);\n}\nvar Stringifier$2 = /*#__PURE__*/ function() {\n    function Stringifier2(builder) {\n        this.builder = builder;\n    }\n    var _proto = Stringifier2.prototype;\n    _proto.atrule = function atrule(node2, semicolon) {\n        var name = \"@\" + node2.name;\n        var params = node2.params ? this.rawValue(node2, \"params\") : \"\";\n        if (typeof node2.raws.afterName !== \"undefined\") {\n            name += node2.raws.afterName;\n        } else if (params) {\n            name += \" \";\n        }\n        if (node2.nodes) {\n            this.block(node2, name + params);\n        } else {\n            var end = (node2.raws.between || \"\") + (semicolon ? \";\" : \"\");\n            this.builder(name + params + end, node2);\n        }\n    };\n    _proto.beforeAfter = function beforeAfter(node2, detect) {\n        var value;\n        if (node2.type === \"decl\") {\n            value = this.raw(node2, null, \"beforeDecl\");\n        } else if (node2.type === \"comment\") {\n            value = this.raw(node2, null, \"beforeComment\");\n        } else if (detect === \"before\") {\n            value = this.raw(node2, null, \"beforeRule\");\n        } else {\n            value = this.raw(node2, null, \"beforeClose\");\n        }\n        var buf = node2.parent;\n        var depth = 0;\n        while(buf && buf.type !== \"root\"){\n            depth += 1;\n            buf = buf.parent;\n        }\n        if (value.includes(\"\\n\")) {\n            var indent = this.raw(node2, null, \"indent\");\n            if (indent.length) {\n                for(var step = 0; step < depth; step++)value += indent;\n            }\n        }\n        return value;\n    };\n    _proto.block = function block(node2, start) {\n        var between = this.raw(node2, \"between\", \"beforeOpen\");\n        this.builder(start + between + \"{\", node2, \"start\");\n        var after;\n        if (node2.nodes && node2.nodes.length) {\n            this.body(node2);\n            after = this.raw(node2, \"after\");\n        } else {\n            after = this.raw(node2, \"after\", \"emptyBody\");\n        }\n        if (after) this.builder(after);\n        this.builder(\"}\", node2, \"end\");\n    };\n    _proto.body = function body(node2) {\n        var last = node2.nodes.length - 1;\n        while(last > 0){\n            if (node2.nodes[last].type !== \"comment\") break;\n            last -= 1;\n        }\n        var semicolon = this.raw(node2, \"semicolon\");\n        for(var i2 = 0; i2 < node2.nodes.length; i2++){\n            var child = node2.nodes[i2];\n            var before = this.raw(child, \"before\");\n            if (before) this.builder(before);\n            this.stringify(child, last !== i2 || semicolon);\n        }\n    };\n    _proto.comment = function comment(node2) {\n        var left = this.raw(node2, \"left\", \"commentLeft\");\n        var right = this.raw(node2, \"right\", \"commentRight\");\n        this.builder(\"/*\" + left + node2.text + right + \"*/\", node2);\n    };\n    _proto.decl = function decl(node2, semicolon) {\n        var between = this.raw(node2, \"between\", \"colon\");\n        var string = node2.prop + between + this.rawValue(node2, \"value\");\n        if (node2.important) {\n            string += node2.raws.important || \" !important\";\n        }\n        if (semicolon) string += \";\";\n        this.builder(string, node2);\n    };\n    _proto.document = function document1(node2) {\n        this.body(node2);\n    };\n    _proto.raw = function raw(node2, own, detect) {\n        var value;\n        if (!detect) detect = own;\n        if (own) {\n            value = node2.raws[own];\n            if (typeof value !== \"undefined\") return value;\n        }\n        var parent = node2.parent;\n        if (detect === \"before\") {\n            if (!parent || parent.type === \"root\" && parent.first === node2) {\n                return \"\";\n            }\n            if (parent && parent.type === \"document\") {\n                return \"\";\n            }\n        }\n        if (!parent) return DEFAULT_RAW[detect];\n        var root2 = node2.root();\n        if (!root2.rawCache) root2.rawCache = {};\n        if (typeof root2.rawCache[detect] !== \"undefined\") {\n            return root2.rawCache[detect];\n        }\n        if (detect === \"before\" || detect === \"after\") {\n            return this.beforeAfter(node2, detect);\n        } else {\n            var method = \"raw\" + capitalize(detect);\n            if (this[method]) {\n                value = this[method](root2, node2);\n            } else {\n                root2.walk(function(i2) {\n                    value = i2.raws[own];\n                    if (typeof value !== \"undefined\") return false;\n                });\n            }\n        }\n        if (typeof value === \"undefined\") value = DEFAULT_RAW[detect];\n        root2.rawCache[detect] = value;\n        return value;\n    };\n    _proto.rawBeforeClose = function rawBeforeClose(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && i2.nodes.length > 0) {\n                if (typeof i2.raws.after !== \"undefined\") {\n                    value = i2.raws.after;\n                    if (value.includes(\"\\n\")) {\n                        value = value.replace(/[^\\n]+$/, \"\");\n                    }\n                    return false;\n                }\n            }\n        });\n        if (value) value = value.replace(/\\S/g, \"\");\n        return value;\n    };\n    _proto.rawBeforeComment = function rawBeforeComment(root2, node2) {\n        var value;\n        root2.walkComments(function(i2) {\n            if (typeof i2.raws.before !== \"undefined\") {\n                value = i2.raws.before;\n                if (value.includes(\"\\n\")) {\n                    value = value.replace(/[^\\n]+$/, \"\");\n                }\n                return false;\n            }\n        });\n        if (typeof value === \"undefined\") {\n            value = this.raw(node2, null, \"beforeDecl\");\n        } else if (value) {\n            value = value.replace(/\\S/g, \"\");\n        }\n        return value;\n    };\n    _proto.rawBeforeDecl = function rawBeforeDecl(root2, node2) {\n        var value;\n        root2.walkDecls(function(i2) {\n            if (typeof i2.raws.before !== \"undefined\") {\n                value = i2.raws.before;\n                if (value.includes(\"\\n\")) {\n                    value = value.replace(/[^\\n]+$/, \"\");\n                }\n                return false;\n            }\n        });\n        if (typeof value === \"undefined\") {\n            value = this.raw(node2, null, \"beforeRule\");\n        } else if (value) {\n            value = value.replace(/\\S/g, \"\");\n        }\n        return value;\n    };\n    _proto.rawBeforeOpen = function rawBeforeOpen(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.type !== \"decl\") {\n                value = i2.raws.between;\n                if (typeof value !== \"undefined\") return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawBeforeRule = function rawBeforeRule(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && (i2.parent !== root2 || root2.first !== i2)) {\n                if (typeof i2.raws.before !== \"undefined\") {\n                    value = i2.raws.before;\n                    if (value.includes(\"\\n\")) {\n                        value = value.replace(/[^\\n]+$/, \"\");\n                    }\n                    return false;\n                }\n            }\n        });\n        if (value) value = value.replace(/\\S/g, \"\");\n        return value;\n    };\n    _proto.rawColon = function rawColon(root2) {\n        var value;\n        root2.walkDecls(function(i2) {\n            if (typeof i2.raws.between !== \"undefined\") {\n                value = i2.raws.between.replace(/[^\\s:]/g, \"\");\n                return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawEmptyBody = function rawEmptyBody(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && i2.nodes.length === 0) {\n                value = i2.raws.after;\n                if (typeof value !== \"undefined\") return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawIndent = function rawIndent(root2) {\n        if (root2.raws.indent) return root2.raws.indent;\n        var value;\n        root2.walk(function(i2) {\n            var p = i2.parent;\n            if (p && p !== root2 && p.parent && p.parent === root2) {\n                if (typeof i2.raws.before !== \"undefined\") {\n                    var parts = i2.raws.before.split(\"\\n\");\n                    value = parts[parts.length - 1];\n                    value = value.replace(/\\S/g, \"\");\n                    return false;\n                }\n            }\n        });\n        return value;\n    };\n    _proto.rawSemicolon = function rawSemicolon(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && i2.nodes.length && i2.last.type === \"decl\") {\n                value = i2.raws.semicolon;\n                if (typeof value !== \"undefined\") return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawValue = function rawValue(node2, prop) {\n        var value = node2[prop];\n        var raw = node2.raws[prop];\n        if (raw && raw.value === value) {\n            return raw.raw;\n        }\n        return value;\n    };\n    _proto.root = function root(node2) {\n        this.body(node2);\n        if (node2.raws.after) this.builder(node2.raws.after);\n    };\n    _proto.rule = function rule(node2) {\n        this.block(node2, this.rawValue(node2, \"selector\"));\n        if (node2.raws.ownSemicolon) {\n            this.builder(node2.raws.ownSemicolon, node2, \"end\");\n        }\n    };\n    _proto.stringify = function stringify(node2, semicolon) {\n        if (!this[node2.type]) {\n            throw new Error(\"Unknown AST node type \" + node2.type + \". Maybe you need to change PostCSS stringifier.\");\n        }\n        this[node2.type](node2, semicolon);\n    };\n    return Stringifier2;\n}();\nvar stringifier = Stringifier$2;\nStringifier$2.default = Stringifier$2;\nvar Stringifier$1 = stringifier;\nfunction stringify$4(node2, builder) {\n    var str = new Stringifier$1(builder);\n    str.stringify(node2);\n}\nvar stringify_1 = stringify$4;\nstringify$4.default = stringify$4;\nvar isClean$2 = symbols.isClean, my$2 = symbols.my;\nvar CssSyntaxError$2 = cssSyntaxError;\nvar Stringifier22 = stringifier;\nvar stringify$3 = stringify_1;\nfunction cloneNode(obj, parent) {\n    var cloned = new obj.constructor();\n    for(var i2 in obj){\n        if (!Object.prototype.hasOwnProperty.call(obj, i2)) {\n            continue;\n        }\n        if (i2 === \"proxyCache\") continue;\n        var value = obj[i2];\n        var type = typeof value === \"undefined\" ? \"undefined\" : _type_of(value);\n        if (i2 === \"parent\" && type === \"object\") {\n            if (parent) cloned[i2] = parent;\n        } else if (i2 === \"source\") {\n            cloned[i2] = value;\n        } else if (Array.isArray(value)) {\n            cloned[i2] = value.map(function(j) {\n                return cloneNode(j, cloned);\n            });\n        } else {\n            if (type === \"object\" && value !== null) value = cloneNode(value);\n            cloned[i2] = value;\n        }\n    }\n    return cloned;\n}\nvar Node$4 = /*#__PURE__*/ function() {\n    function Node3(defaults) {\n        if (defaults === void 0) defaults = {};\n        this.raws = {};\n        this[isClean$2] = false;\n        this[my$2] = true;\n        for(var name in defaults){\n            if (name === \"nodes\") {\n                this.nodes = [];\n                for(var _iterator = _create_for_of_iterator_helper_loose(defaults[name]), _step; !(_step = _iterator()).done;){\n                    var node2 = _step.value;\n                    if (typeof node2.clone === \"function\") {\n                        this.append(node2.clone());\n                    } else {\n                        this.append(node2);\n                    }\n                }\n            } else {\n                this[name] = defaults[name];\n            }\n        }\n    }\n    var _proto = Node3.prototype;\n    _proto.addToError = function addToError(error) {\n        error.postcssNode = this;\n        if (error.stack && this.source && /\\n\\s{4}at /.test(error.stack)) {\n            var s2 = this.source;\n            error.stack = error.stack.replace(/\\n\\s{4}at /, \"$&\" + s2.input.from + \":\" + s2.start.line + \":\" + s2.start.column + \"$&\");\n        }\n        return error;\n    };\n    _proto.after = function after(add) {\n        this.parent.insertAfter(this, add);\n        return this;\n    };\n    _proto.assign = function assign(overrides) {\n        if (overrides === void 0) overrides = {};\n        for(var name in overrides){\n            this[name] = overrides[name];\n        }\n        return this;\n    };\n    _proto.before = function before(add) {\n        this.parent.insertBefore(this, add);\n        return this;\n    };\n    _proto.cleanRaws = function cleanRaws(keepBetween) {\n        delete this.raws.before;\n        delete this.raws.after;\n        if (!keepBetween) delete this.raws.between;\n    };\n    _proto.clone = function clone(overrides) {\n        if (overrides === void 0) overrides = {};\n        var cloned = cloneNode(this);\n        for(var name in overrides){\n            cloned[name] = overrides[name];\n        }\n        return cloned;\n    };\n    _proto.cloneAfter = function cloneAfter(overrides) {\n        if (overrides === void 0) overrides = {};\n        var cloned = this.clone(overrides);\n        this.parent.insertAfter(this, cloned);\n        return cloned;\n    };\n    _proto.cloneBefore = function cloneBefore(overrides) {\n        if (overrides === void 0) overrides = {};\n        var cloned = this.clone(overrides);\n        this.parent.insertBefore(this, cloned);\n        return cloned;\n    };\n    _proto.error = function error(message, opts) {\n        if (opts === void 0) opts = {};\n        if (this.source) {\n            var _this_rangeBy = this.rangeBy(opts), end = _this_rangeBy.end, start = _this_rangeBy.start;\n            return this.source.input.error(message, {\n                column: start.column,\n                line: start.line\n            }, {\n                column: end.column,\n                line: end.line\n            }, opts);\n        }\n        return new CssSyntaxError$2(message);\n    };\n    _proto.getProxyProcessor = function getProxyProcessor() {\n        return {\n            get: function get(node2, prop) {\n                if (prop === \"proxyOf\") {\n                    return node2;\n                } else if (prop === \"root\") {\n                    return function() {\n                        return node2.root().toProxy();\n                    };\n                } else {\n                    return node2[prop];\n                }\n            },\n            set: function set(node2, prop, value) {\n                if (node2[prop] === value) return true;\n                node2[prop] = value;\n                if (prop === \"prop\" || prop === \"value\" || prop === \"name\" || prop === \"params\" || prop === \"important\" || /* c8 ignore next */ prop === \"text\") {\n                    node2.markDirty();\n                }\n                return true;\n            }\n        };\n    };\n    _proto.markDirty = function markDirty() {\n        if (this[isClean$2]) {\n            this[isClean$2] = false;\n            var next = this;\n            while(next = next.parent){\n                next[isClean$2] = false;\n            }\n        }\n    };\n    _proto.next = function next() {\n        if (!this.parent) return void 0;\n        var index2 = this.parent.index(this);\n        return this.parent.nodes[index2 + 1];\n    };\n    _proto.positionBy = function positionBy(opts, stringRepresentation) {\n        var pos = this.source.start;\n        if (opts.index) {\n            pos = this.positionInside(opts.index, stringRepresentation);\n        } else if (opts.word) {\n            stringRepresentation = this.toString();\n            var index2 = stringRepresentation.indexOf(opts.word);\n            if (index2 !== -1) pos = this.positionInside(index2, stringRepresentation);\n        }\n        return pos;\n    };\n    _proto.positionInside = function positionInside(index2, stringRepresentation) {\n        var string = stringRepresentation || this.toString();\n        var column = this.source.start.column;\n        var line = this.source.start.line;\n        for(var i2 = 0; i2 < index2; i2++){\n            if (string[i2] === \"\\n\") {\n                column = 1;\n                line += 1;\n            } else {\n                column += 1;\n            }\n        }\n        return {\n            column: column,\n            line: line\n        };\n    };\n    _proto.prev = function prev() {\n        if (!this.parent) return void 0;\n        var index2 = this.parent.index(this);\n        return this.parent.nodes[index2 - 1];\n    };\n    _proto.rangeBy = function rangeBy(opts) {\n        var start = {\n            column: this.source.start.column,\n            line: this.source.start.line\n        };\n        var end = this.source.end ? {\n            column: this.source.end.column + 1,\n            line: this.source.end.line\n        } : {\n            column: start.column + 1,\n            line: start.line\n        };\n        if (opts.word) {\n            var stringRepresentation = this.toString();\n            var index2 = stringRepresentation.indexOf(opts.word);\n            if (index2 !== -1) {\n                start = this.positionInside(index2, stringRepresentation);\n                end = this.positionInside(index2 + opts.word.length, stringRepresentation);\n            }\n        } else {\n            if (opts.start) {\n                start = {\n                    column: opts.start.column,\n                    line: opts.start.line\n                };\n            } else if (opts.index) {\n                start = this.positionInside(opts.index);\n            }\n            if (opts.end) {\n                end = {\n                    column: opts.end.column,\n                    line: opts.end.line\n                };\n            } else if (typeof opts.endIndex === \"number\") {\n                end = this.positionInside(opts.endIndex);\n            } else if (opts.index) {\n                end = this.positionInside(opts.index + 1);\n            }\n        }\n        if (end.line < start.line || end.line === start.line && end.column <= start.column) {\n            end = {\n                column: start.column + 1,\n                line: start.line\n            };\n        }\n        return {\n            end: end,\n            start: start\n        };\n    };\n    _proto.raw = function raw(prop, defaultType) {\n        var str = new Stringifier22();\n        return str.raw(this, prop, defaultType);\n    };\n    _proto.remove = function remove() {\n        if (this.parent) {\n            this.parent.removeChild(this);\n        }\n        this.parent = void 0;\n        return this;\n    };\n    _proto.replaceWith = function replaceWith() {\n        for(var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++){\n            nodes[_key] = arguments[_key];\n        }\n        if (this.parent) {\n            var bookmark = this;\n            var foundSelf = false;\n            for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n                var node2 = _step.value;\n                if (node2 === this) {\n                    foundSelf = true;\n                } else if (foundSelf) {\n                    this.parent.insertAfter(bookmark, node2);\n                    bookmark = node2;\n                } else {\n                    this.parent.insertBefore(bookmark, node2);\n                }\n            }\n            if (!foundSelf) {\n                this.remove();\n            }\n        }\n        return this;\n    };\n    _proto.root = function root() {\n        var result2 = this;\n        while(result2.parent && result2.parent.type !== \"document\"){\n            result2 = result2.parent;\n        }\n        return result2;\n    };\n    _proto.toJSON = function toJSON(_, inputs) {\n        var fixed = {};\n        var emitInputs = inputs == null;\n        inputs = inputs || /* @__PURE__ */ new Map();\n        var inputsNextIndex = 0;\n        for(var name in this){\n            if (!Object.prototype.hasOwnProperty.call(this, name)) {\n                continue;\n            }\n            if (name === \"parent\" || name === \"proxyCache\") continue;\n            var value = this[name];\n            if (Array.isArray(value)) {\n                fixed[name] = value.map(function(i2) {\n                    if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && i2.toJSON) {\n                        return i2.toJSON(null, inputs);\n                    } else {\n                        return i2;\n                    }\n                });\n            } else if ((typeof value === \"undefined\" ? \"undefined\" : _type_of(value)) === \"object\" && value.toJSON) {\n                fixed[name] = value.toJSON(null, inputs);\n            } else if (name === \"source\") {\n                var inputId = inputs.get(value.input);\n                if (inputId == null) {\n                    inputId = inputsNextIndex;\n                    inputs.set(value.input, inputsNextIndex);\n                    inputsNextIndex++;\n                }\n                fixed[name] = {\n                    end: value.end,\n                    inputId: inputId,\n                    start: value.start\n                };\n            } else {\n                fixed[name] = value;\n            }\n        }\n        if (emitInputs) {\n            fixed.inputs = [].concat(inputs.keys()).map(function(input2) {\n                return input2.toJSON();\n            });\n        }\n        return fixed;\n    };\n    _proto.toProxy = function toProxy() {\n        if (!this.proxyCache) {\n            this.proxyCache = new Proxy(this, this.getProxyProcessor());\n        }\n        return this.proxyCache;\n    };\n    _proto.toString = function toString(stringifier2) {\n        if (stringifier2 === void 0) stringifier2 = stringify$3;\n        if (stringifier2.stringify) stringifier2 = stringifier2.stringify;\n        var result2 = \"\";\n        stringifier2(this, function(i2) {\n            result2 += i2;\n        });\n        return result2;\n    };\n    _proto.warn = function warn(result2, text, opts) {\n        var data = {\n            node: this\n        };\n        for(var i2 in opts)data[i2] = opts[i2];\n        return result2.warn(text, data);\n    };\n    _create_class(Node3, [\n        {\n            key: \"proxyOf\",\n            get: function get() {\n                return this;\n            }\n        }\n    ]);\n    return Node3;\n}();\nvar node = Node$4;\nNode$4.default = Node$4;\nvar Node$3 = node;\nvar Declaration$4 = /*#__PURE__*/ function(Node$3) {\n    _inherits(Declaration2, Node$3);\n    function Declaration2(defaults) {\n        var _this;\n        if (defaults && typeof defaults.value !== \"undefined\" && typeof defaults.value !== \"string\") {\n            defaults = _extends({}, defaults, {\n                value: String(defaults.value)\n            });\n        }\n        _this = Node$3.call(this, defaults) || this;\n        _this.type = \"decl\";\n        return _this;\n    }\n    _create_class(Declaration2, [\n        {\n            key: \"variable\",\n            get: function get() {\n                return this.prop.startsWith(\"--\") || this.prop[0] === \"$\";\n            }\n        }\n    ]);\n    return Declaration2;\n}(Node$3);\nvar declaration = Declaration$4;\nDeclaration$4.default = Declaration$4;\nvar urlAlphabet = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nvar nanoid$1 = function(size) {\n    if (size === void 0) size = 21;\n    var id = \"\";\n    var i2 = size;\n    while(i2--){\n        id += urlAlphabet[Math.random() * 64 | 0];\n    }\n    return id;\n};\nvar nonSecure = {\n    nanoid: nanoid$1\n};\nvar SourceMapConsumer$2 = require$$2.SourceMapConsumer, SourceMapGenerator$2 = require$$2.SourceMapGenerator;\nvar existsSync = require$$2.existsSync, readFileSync = require$$2.readFileSync;\nvar dirname$1 = require$$2.dirname, join = require$$2.join;\nfunction fromBase64(str) {\n    if (Buffer) {\n        return Buffer.from(str, \"base64\").toString();\n    } else {\n        return window.atob(str);\n    }\n}\nvar PreviousMap$2 = /*#__PURE__*/ function() {\n    function PreviousMap2(css, opts) {\n        if (opts.map === false) return;\n        this.loadAnnotation(css);\n        this.inline = this.startWith(this.annotation, \"data:\");\n        var prev = opts.map ? opts.map.prev : void 0;\n        var text = this.loadMap(opts.from, prev);\n        if (!this.mapFile && opts.from) {\n            this.mapFile = opts.from;\n        }\n        if (this.mapFile) this.root = dirname$1(this.mapFile);\n        if (text) this.text = text;\n    }\n    var _proto = PreviousMap2.prototype;\n    _proto.consumer = function consumer() {\n        if (!this.consumerCache) {\n            this.consumerCache = new SourceMapConsumer$2(this.text);\n        }\n        return this.consumerCache;\n    };\n    _proto.decodeInline = function decodeInline(text) {\n        var baseCharsetUri = /^data:application\\/json;charset=utf-?8;base64,/;\n        var baseUri = /^data:application\\/json;base64,/;\n        var charsetUri = /^data:application\\/json;charset=utf-?8,/;\n        var uri = /^data:application\\/json,/;\n        if (charsetUri.test(text) || uri.test(text)) {\n            return decodeURIComponent(text.substr(RegExp.lastMatch.length));\n        }\n        if (baseCharsetUri.test(text) || baseUri.test(text)) {\n            return fromBase64(text.substr(RegExp.lastMatch.length));\n        }\n        var encoding = text.match(/data:application\\/json;([^,]+),/)[1];\n        throw new Error(\"Unsupported source map encoding \" + encoding);\n    };\n    _proto.getAnnotationURL = function getAnnotationURL(sourceMapString) {\n        return sourceMapString.replace(/^\\/\\*\\s*# sourceMappingURL=/, \"\").trim();\n    };\n    _proto.isMap = function isMap(map) {\n        if ((typeof map === \"undefined\" ? \"undefined\" : _type_of(map)) !== \"object\") return false;\n        return typeof map.mappings === \"string\" || typeof map._mappings === \"string\" || Array.isArray(map.sections);\n    };\n    _proto.loadAnnotation = function loadAnnotation(css) {\n        var comments = css.match(/\\/\\*\\s*# sourceMappingURL=/gm);\n        if (!comments) return;\n        var start = css.lastIndexOf(comments.pop());\n        var end = css.indexOf(\"*/\", start);\n        if (start > -1 && end > -1) {\n            this.annotation = this.getAnnotationURL(css.substring(start, end));\n        }\n    };\n    _proto.loadFile = function loadFile(path) {\n        this.root = dirname$1(path);\n        if (existsSync(path)) {\n            this.mapFile = path;\n            return readFileSync(path, \"utf-8\").toString().trim();\n        }\n    };\n    _proto.loadMap = function loadMap(file, prev) {\n        if (prev === false) return false;\n        if (prev) {\n            if (typeof prev === \"string\") {\n                return prev;\n            } else if (typeof prev === \"function\") {\n                var prevPath = prev(file);\n                if (prevPath) {\n                    var map = this.loadFile(prevPath);\n                    if (!map) {\n                        throw new Error(\"Unable to load previous source map: \" + prevPath.toString());\n                    }\n                    return map;\n                }\n            } else if (_instanceof(prev, SourceMapConsumer$2)) {\n                return SourceMapGenerator$2.fromSourceMap(prev).toString();\n            } else if (_instanceof(prev, SourceMapGenerator$2)) {\n                return prev.toString();\n            } else if (this.isMap(prev)) {\n                return JSON.stringify(prev);\n            } else {\n                throw new Error(\"Unsupported previous source map format: \" + prev.toString());\n            }\n        } else if (this.inline) {\n            return this.decodeInline(this.annotation);\n        } else if (this.annotation) {\n            var map1 = this.annotation;\n            if (file) map1 = join(dirname$1(file), map1);\n            return this.loadFile(map1);\n        }\n    };\n    _proto.startWith = function startWith(string, start) {\n        if (!string) return false;\n        return string.substr(0, start.length) === start;\n    };\n    _proto.withContent = function withContent() {\n        return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);\n    };\n    return PreviousMap2;\n}();\nvar previousMap = PreviousMap$2;\nPreviousMap$2.default = PreviousMap$2;\nvar SourceMapConsumer$1 = require$$2.SourceMapConsumer, SourceMapGenerator$1 = require$$2.SourceMapGenerator;\nvar fileURLToPath = require$$2.fileURLToPath, pathToFileURL$1 = require$$2.pathToFileURL;\nvar isAbsolute = require$$2.isAbsolute, resolve$1 = require$$2.resolve;\nvar nanoid = nonSecure.nanoid;\nvar terminalHighlight = require$$2;\nvar CssSyntaxError$1 = cssSyntaxError;\nvar PreviousMap$1 = previousMap;\nvar fromOffsetCache = Symbol(\"fromOffsetCache\");\nvar sourceMapAvailable$1 = Boolean(SourceMapConsumer$1 && SourceMapGenerator$1);\nvar pathAvailable$1 = Boolean(resolve$1 && isAbsolute);\nvar Input$4 = /*#__PURE__*/ function() {\n    function Input2(css, opts) {\n        if (opts === void 0) opts = {};\n        if (css === null || typeof css === \"undefined\" || (typeof css === \"undefined\" ? \"undefined\" : _type_of(css)) === \"object\" && !css.toString) {\n            throw new Error(\"PostCSS received \" + css + \" instead of CSS string\");\n        }\n        this.css = css.toString();\n        if (this.css[0] === \"\\uFEFF\" || this.css[0] === \"\") {\n            this.hasBOM = true;\n            this.css = this.css.slice(1);\n        } else {\n            this.hasBOM = false;\n        }\n        if (opts.from) {\n            if (!pathAvailable$1 || /^\\w+:\\/\\//.test(opts.from) || isAbsolute(opts.from)) {\n                this.file = opts.from;\n            } else {\n                this.file = resolve$1(opts.from);\n            }\n        }\n        if (pathAvailable$1 && sourceMapAvailable$1) {\n            var map = new PreviousMap$1(this.css, opts);\n            if (map.text) {\n                this.map = map;\n                var file = map.consumer().file;\n                if (!this.file && file) this.file = this.mapResolve(file);\n            }\n        }\n        if (!this.file) {\n            this.id = \"<input css \" + nanoid(6) + \">\";\n        }\n        if (this.map) this.map.file = this.from;\n    }\n    var _proto = Input2.prototype;\n    _proto.error = function error(message, line, column, opts) {\n        if (opts === void 0) opts = {};\n        var result2, endLine, endColumn;\n        if (line && (typeof line === \"undefined\" ? \"undefined\" : _type_of(line)) === \"object\") {\n            var start = line;\n            var end = column;\n            if (typeof start.offset === \"number\") {\n                var pos = this.fromOffset(start.offset);\n                line = pos.line;\n                column = pos.col;\n            } else {\n                line = start.line;\n                column = start.column;\n            }\n            if (typeof end.offset === \"number\") {\n                var pos1 = this.fromOffset(end.offset);\n                endLine = pos1.line;\n                endColumn = pos1.col;\n            } else {\n                endLine = end.line;\n                endColumn = end.column;\n            }\n        } else if (!column) {\n            var pos2 = this.fromOffset(line);\n            line = pos2.line;\n            column = pos2.col;\n        }\n        var origin = this.origin(line, column, endLine, endColumn);\n        if (origin) {\n            result2 = new CssSyntaxError$1(message, origin.endLine === void 0 ? origin.line : {\n                column: origin.column,\n                line: origin.line\n            }, origin.endLine === void 0 ? origin.column : {\n                column: origin.endColumn,\n                line: origin.endLine\n            }, origin.source, origin.file, opts.plugin);\n        } else {\n            result2 = new CssSyntaxError$1(message, endLine === void 0 ? line : {\n                column: column,\n                line: line\n            }, endLine === void 0 ? column : {\n                column: endColumn,\n                line: endLine\n            }, this.css, this.file, opts.plugin);\n        }\n        result2.input = {\n            column: column,\n            endColumn: endColumn,\n            endLine: endLine,\n            line: line,\n            source: this.css\n        };\n        if (this.file) {\n            if (pathToFileURL$1) {\n                result2.input.url = pathToFileURL$1(this.file).toString();\n            }\n            result2.input.file = this.file;\n        }\n        return result2;\n    };\n    _proto.fromOffset = function fromOffset(offset) {\n        var lastLine, lineToIndex;\n        if (!this[fromOffsetCache]) {\n            var lines = this.css.split(\"\\n\");\n            lineToIndex = new Array(lines.length);\n            var prevIndex = 0;\n            for(var i2 = 0, l2 = lines.length; i2 < l2; i2++){\n                lineToIndex[i2] = prevIndex;\n                prevIndex += lines[i2].length + 1;\n            }\n            this[fromOffsetCache] = lineToIndex;\n        } else {\n            lineToIndex = this[fromOffsetCache];\n        }\n        lastLine = lineToIndex[lineToIndex.length - 1];\n        var min = 0;\n        if (offset >= lastLine) {\n            min = lineToIndex.length - 1;\n        } else {\n            var max = lineToIndex.length - 2;\n            var mid;\n            while(min < max){\n                mid = min + (max - min >> 1);\n                if (offset < lineToIndex[mid]) {\n                    max = mid - 1;\n                } else if (offset >= lineToIndex[mid + 1]) {\n                    min = mid + 1;\n                } else {\n                    min = mid;\n                    break;\n                }\n            }\n        }\n        return {\n            col: offset - lineToIndex[min] + 1,\n            line: min + 1\n        };\n    };\n    _proto.mapResolve = function mapResolve(file) {\n        if (/^\\w+:\\/\\//.test(file)) {\n            return file;\n        }\n        return resolve$1(this.map.consumer().sourceRoot || this.map.root || \".\", file);\n    };\n    _proto.origin = function origin(line, column, endLine, endColumn) {\n        if (!this.map) return false;\n        var consumer = this.map.consumer();\n        var from = consumer.originalPositionFor({\n            column: column,\n            line: line\n        });\n        if (!from.source) return false;\n        var to;\n        if (typeof endLine === \"number\") {\n            to = consumer.originalPositionFor({\n                column: endColumn,\n                line: endLine\n            });\n        }\n        var fromUrl;\n        if (isAbsolute(from.source)) {\n            fromUrl = pathToFileURL$1(from.source);\n        } else {\n            fromUrl = new URL(from.source, this.map.consumer().sourceRoot || pathToFileURL$1(this.map.mapFile));\n        }\n        var result2 = {\n            column: from.column,\n            endColumn: to && to.column,\n            endLine: to && to.line,\n            line: from.line,\n            url: fromUrl.toString()\n        };\n        if (fromUrl.protocol === \"file:\") {\n            if (fileURLToPath) {\n                result2.file = fileURLToPath(fromUrl);\n            } else {\n                throw new Error(\"file: protocol is not available in this PostCSS build\");\n            }\n        }\n        var source = consumer.sourceContentFor(from.source);\n        if (source) result2.source = source;\n        return result2;\n    };\n    _proto.toJSON = function toJSON() {\n        var json = {};\n        for(var _i = 0, _iter = [\n            \"hasBOM\",\n            \"css\",\n            \"file\",\n            \"id\"\n        ]; _i < _iter.length; _i++){\n            var name = _iter[_i];\n            if (this[name] != null) {\n                json[name] = this[name];\n            }\n        }\n        if (this.map) {\n            json.map = _extends({}, this.map);\n            if (json.map.consumerCache) {\n                json.map.consumerCache = void 0;\n            }\n        }\n        return json;\n    };\n    _create_class(Input2, [\n        {\n            key: \"from\",\n            get: function get() {\n                return this.file || this.id;\n            }\n        }\n    ]);\n    return Input2;\n}();\nvar input = Input$4;\nInput$4.default = Input$4;\nif (terminalHighlight && terminalHighlight.registerInput) {\n    terminalHighlight.registerInput(Input$4);\n}\nvar SourceMapConsumer = require$$2.SourceMapConsumer, SourceMapGenerator = require$$2.SourceMapGenerator;\nvar dirname = require$$2.dirname, relative = require$$2.relative, resolve$3 = require$$2.resolve, sep = require$$2.sep;\nvar pathToFileURL = require$$2.pathToFileURL;\nvar Input$3 = input;\nvar sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);\nvar pathAvailable = Boolean(dirname && resolve$3 && relative && sep);\nvar MapGenerator$2 = /*#__PURE__*/ function() {\n    function MapGenerator2(stringify2, root2, opts, cssString) {\n        this.stringify = stringify2;\n        this.mapOpts = opts.map || {};\n        this.root = root2;\n        this.opts = opts;\n        this.css = cssString;\n        this.originalCSS = cssString;\n        this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;\n        this.memoizedFileURLs = /* @__PURE__ */ new Map();\n        this.memoizedPaths = /* @__PURE__ */ new Map();\n        this.memoizedURLs = /* @__PURE__ */ new Map();\n    }\n    var _proto = MapGenerator2.prototype;\n    _proto.addAnnotation = function addAnnotation() {\n        var content;\n        if (this.isInline()) {\n            content = \"data:application/json;base64,\" + this.toBase64(this.map.toString());\n        } else if (typeof this.mapOpts.annotation === \"string\") {\n            content = this.mapOpts.annotation;\n        } else if (typeof this.mapOpts.annotation === \"function\") {\n            content = this.mapOpts.annotation(this.opts.to, this.root);\n        } else {\n            content = this.outputFile() + \".map\";\n        }\n        var eol = \"\\n\";\n        if (this.css.includes(\"\\r\\n\")) eol = \"\\r\\n\";\n        this.css += eol + \"/*# sourceMappingURL=\" + content + \" */\";\n    };\n    _proto.applyPrevMaps = function applyPrevMaps() {\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.previous()), _step; !(_step = _iterator()).done;){\n            var prev = _step.value;\n            var from = this.toUrl(this.path(prev.file));\n            var root2 = prev.root || dirname(prev.file);\n            var map = void 0;\n            if (this.mapOpts.sourcesContent === false) {\n                map = new SourceMapConsumer(prev.text);\n                if (map.sourcesContent) {\n                    map.sourcesContent = null;\n                }\n            } else {\n                map = prev.consumer();\n            }\n            this.map.applySourceMap(map, from, this.toUrl(this.path(root2)));\n        }\n    };\n    _proto.clearAnnotation = function clearAnnotation() {\n        if (this.mapOpts.annotation === false) return;\n        if (this.root) {\n            var node2;\n            for(var i2 = this.root.nodes.length - 1; i2 >= 0; i2--){\n                node2 = this.root.nodes[i2];\n                if (node2.type !== \"comment\") continue;\n                if (node2.text.indexOf(\"# sourceMappingURL=\") === 0) {\n                    this.root.removeChild(i2);\n                }\n            }\n        } else if (this.css) {\n            this.css = this.css.replace(/\\n*?\\/\\*#[\\S\\s]*?\\*\\/$/gm, \"\");\n        }\n    };\n    _proto.generate = function generate() {\n        this.clearAnnotation();\n        if (pathAvailable && sourceMapAvailable && this.isMap()) {\n            return this.generateMap();\n        } else {\n            var result2 = \"\";\n            this.stringify(this.root, function(i2) {\n                result2 += i2;\n            });\n            return [\n                result2\n            ];\n        }\n    };\n    _proto.generateMap = function generateMap() {\n        if (this.root) {\n            this.generateString();\n        } else if (this.previous().length === 1) {\n            var prev = this.previous()[0].consumer();\n            prev.file = this.outputFile();\n            this.map = SourceMapGenerator.fromSourceMap(prev, {\n                ignoreInvalidMapping: true\n            });\n        } else {\n            this.map = new SourceMapGenerator({\n                file: this.outputFile(),\n                ignoreInvalidMapping: true\n            });\n            this.map.addMapping({\n                generated: {\n                    column: 0,\n                    line: 1\n                },\n                original: {\n                    column: 0,\n                    line: 1\n                },\n                source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : \"<no source>\"\n            });\n        }\n        if (this.isSourcesContent()) this.setSourcesContent();\n        if (this.root && this.previous().length > 0) this.applyPrevMaps();\n        if (this.isAnnotation()) this.addAnnotation();\n        if (this.isInline()) {\n            return [\n                this.css\n            ];\n        } else {\n            return [\n                this.css,\n                this.map\n            ];\n        }\n    };\n    _proto.generateString = function generateString() {\n        var _this = this;\n        this.css = \"\";\n        this.map = new SourceMapGenerator({\n            file: this.outputFile(),\n            ignoreInvalidMapping: true\n        });\n        var line = 1;\n        var column = 1;\n        var noSource = \"<no source>\";\n        var mapping = {\n            generated: {\n                column: 0,\n                line: 0\n            },\n            original: {\n                column: 0,\n                line: 0\n            },\n            source: \"\"\n        };\n        var lines, last;\n        this.stringify(this.root, function(str, node2, type) {\n            _this.css += str;\n            if (node2 && type !== \"end\") {\n                mapping.generated.line = line;\n                mapping.generated.column = column - 1;\n                if (node2.source && node2.source.start) {\n                    mapping.source = _this.sourcePath(node2);\n                    mapping.original.line = node2.source.start.line;\n                    mapping.original.column = node2.source.start.column - 1;\n                    _this.map.addMapping(mapping);\n                } else {\n                    mapping.source = noSource;\n                    mapping.original.line = 1;\n                    mapping.original.column = 0;\n                    _this.map.addMapping(mapping);\n                }\n            }\n            lines = str.match(/\\n/g);\n            if (lines) {\n                line += lines.length;\n                last = str.lastIndexOf(\"\\n\");\n                column = str.length - last;\n            } else {\n                column += str.length;\n            }\n            if (node2 && type !== \"start\") {\n                var p = node2.parent || {\n                    raws: {}\n                };\n                var childless = node2.type === \"decl\" || node2.type === \"atrule\" && !node2.nodes;\n                if (!childless || node2 !== p.last || p.raws.semicolon) {\n                    if (node2.source && node2.source.end) {\n                        mapping.source = _this.sourcePath(node2);\n                        mapping.original.line = node2.source.end.line;\n                        mapping.original.column = node2.source.end.column - 1;\n                        mapping.generated.line = line;\n                        mapping.generated.column = column - 2;\n                        _this.map.addMapping(mapping);\n                    } else {\n                        mapping.source = noSource;\n                        mapping.original.line = 1;\n                        mapping.original.column = 0;\n                        mapping.generated.line = line;\n                        mapping.generated.column = column - 1;\n                        _this.map.addMapping(mapping);\n                    }\n                }\n            }\n        });\n    };\n    _proto.isAnnotation = function isAnnotation() {\n        if (this.isInline()) {\n            return true;\n        }\n        if (typeof this.mapOpts.annotation !== \"undefined\") {\n            return this.mapOpts.annotation;\n        }\n        if (this.previous().length) {\n            return this.previous().some(function(i2) {\n                return i2.annotation;\n            });\n        }\n        return true;\n    };\n    _proto.isInline = function isInline() {\n        if (typeof this.mapOpts.inline !== \"undefined\") {\n            return this.mapOpts.inline;\n        }\n        var annotation = this.mapOpts.annotation;\n        if (typeof annotation !== \"undefined\" && annotation !== true) {\n            return false;\n        }\n        if (this.previous().length) {\n            return this.previous().some(function(i2) {\n                return i2.inline;\n            });\n        }\n        return true;\n    };\n    _proto.isMap = function isMap() {\n        if (typeof this.opts.map !== \"undefined\") {\n            return !!this.opts.map;\n        }\n        return this.previous().length > 0;\n    };\n    _proto.isSourcesContent = function isSourcesContent() {\n        if (typeof this.mapOpts.sourcesContent !== \"undefined\") {\n            return this.mapOpts.sourcesContent;\n        }\n        if (this.previous().length) {\n            return this.previous().some(function(i2) {\n                return i2.withContent();\n            });\n        }\n        return true;\n    };\n    _proto.outputFile = function outputFile() {\n        if (this.opts.to) {\n            return this.path(this.opts.to);\n        } else if (this.opts.from) {\n            return this.path(this.opts.from);\n        } else {\n            return \"to.css\";\n        }\n    };\n    _proto.path = function path(file) {\n        if (this.mapOpts.absolute) return file;\n        if (file.charCodeAt(0) === 60) return file;\n        if (/^\\w+:\\/\\//.test(file)) return file;\n        var cached = this.memoizedPaths.get(file);\n        if (cached) return cached;\n        var from = this.opts.to ? dirname(this.opts.to) : \".\";\n        if (typeof this.mapOpts.annotation === \"string\") {\n            from = dirname(resolve$3(from, this.mapOpts.annotation));\n        }\n        var path = relative(from, file);\n        this.memoizedPaths.set(file, path);\n        return path;\n    };\n    _proto.previous = function previous() {\n        var _this = this;\n        if (!this.previousMaps) {\n            this.previousMaps = [];\n            if (this.root) {\n                this.root.walk(function(node2) {\n                    if (node2.source && node2.source.input.map) {\n                        var map = node2.source.input.map;\n                        if (!_this.previousMaps.includes(map)) {\n                            _this.previousMaps.push(map);\n                        }\n                    }\n                });\n            } else {\n                var input2 = new Input$3(this.originalCSS, this.opts);\n                if (input2.map) this.previousMaps.push(input2.map);\n            }\n        }\n        return this.previousMaps;\n    };\n    _proto.setSourcesContent = function setSourcesContent() {\n        var _this = this;\n        var already = {};\n        if (this.root) {\n            this.root.walk(function(node2) {\n                if (node2.source) {\n                    var from = node2.source.input.from;\n                    if (from && !already[from]) {\n                        already[from] = true;\n                        var fromUrl = _this.usesFileUrls ? _this.toFileUrl(from) : _this.toUrl(_this.path(from));\n                        _this.map.setSourceContent(fromUrl, node2.source.input.css);\n                    }\n                }\n            });\n        } else if (this.css) {\n            var from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : \"<no source>\";\n            this.map.setSourceContent(from, this.css);\n        }\n    };\n    _proto.sourcePath = function sourcePath(node2) {\n        if (this.mapOpts.from) {\n            return this.toUrl(this.mapOpts.from);\n        } else if (this.usesFileUrls) {\n            return this.toFileUrl(node2.source.input.from);\n        } else {\n            return this.toUrl(this.path(node2.source.input.from));\n        }\n    };\n    _proto.toBase64 = function toBase64(str) {\n        if (Buffer) {\n            return Buffer.from(str).toString(\"base64\");\n        } else {\n            return window.btoa(unescape(encodeURIComponent(str)));\n        }\n    };\n    _proto.toFileUrl = function toFileUrl(path) {\n        var cached = this.memoizedFileURLs.get(path);\n        if (cached) return cached;\n        if (pathToFileURL) {\n            var fileURL = pathToFileURL(path).toString();\n            this.memoizedFileURLs.set(path, fileURL);\n            return fileURL;\n        } else {\n            throw new Error(\"`map.absolute` option is not available in this PostCSS build\");\n        }\n    };\n    _proto.toUrl = function toUrl(path) {\n        var cached = this.memoizedURLs.get(path);\n        if (cached) return cached;\n        if (sep === \"\\\\\") {\n            path = path.replace(/\\\\/g, \"/\");\n        }\n        var url = encodeURI(path).replace(/[#?]/g, encodeURIComponent);\n        this.memoizedURLs.set(path, url);\n        return url;\n    };\n    return MapGenerator2;\n}();\nvar mapGenerator = MapGenerator$2;\nvar Node$2 = node;\nvar Comment$4 = /*#__PURE__*/ function(Node$2) {\n    _inherits(Comment2, Node$2);\n    function Comment2(defaults) {\n        var _this;\n        _this = Node$2.call(this, defaults) || this;\n        _this.type = \"comment\";\n        return _this;\n    }\n    return Comment2;\n}(Node$2);\nvar comment = Comment$4;\nComment$4.default = Comment$4;\nvar isClean$1 = symbols.isClean, my$1 = symbols.my;\nvar Declaration$3 = declaration;\nvar Comment$3 = comment;\nvar Node$1 = node;\nvar parse$4, Rule$4, AtRule$4, Root$6;\nfunction cleanSource(nodes) {\n    return nodes.map(function(i2) {\n        if (i2.nodes) i2.nodes = cleanSource(i2.nodes);\n        delete i2.source;\n        return i2;\n    });\n}\nfunction markDirtyUp(node2) {\n    node2[isClean$1] = false;\n    if (node2.proxyOf.nodes) {\n        for(var _iterator = _create_for_of_iterator_helper_loose(node2.proxyOf.nodes), _step; !(_step = _iterator()).done;){\n            var i2 = _step.value;\n            markDirtyUp(i2);\n        }\n    }\n}\nvar Container$7 = /*#__PURE__*/ function(Node$1) {\n    _inherits(Container2, Node$1);\n    function Container2() {\n        return Node$1.apply(this, arguments) || this;\n    }\n    var _proto = Container2.prototype;\n    _proto.append = function append() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        for(var _iterator = _create_for_of_iterator_helper_loose(children), _step; !(_step = _iterator()).done;){\n            var child = _step.value;\n            var nodes = this.normalize(child, this.last);\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(nodes), _step1; !(_step1 = _iterator1()).done;){\n                var node2 = _step1.value;\n                this.proxyOf.nodes.push(node2);\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.cleanRaws = function cleanRaws(keepBetween) {\n        Node$1.prototype.cleanRaws.call(this, keepBetween);\n        if (this.nodes) {\n            for(var _iterator = _create_for_of_iterator_helper_loose(this.nodes), _step; !(_step = _iterator()).done;){\n                var node2 = _step.value;\n                node2.cleanRaws(keepBetween);\n            }\n        }\n    };\n    _proto.each = function each(callback) {\n        if (!this.proxyOf.nodes) return void 0;\n        var iterator = this.getIterator();\n        var index2, result2;\n        while(this.indexes[iterator] < this.proxyOf.nodes.length){\n            index2 = this.indexes[iterator];\n            result2 = callback(this.proxyOf.nodes[index2], index2);\n            if (result2 === false) break;\n            this.indexes[iterator] += 1;\n        }\n        delete this.indexes[iterator];\n        return result2;\n    };\n    _proto.every = function every(condition) {\n        return this.nodes.every(condition);\n    };\n    _proto.getIterator = function getIterator() {\n        if (!this.lastEach) this.lastEach = 0;\n        if (!this.indexes) this.indexes = {};\n        this.lastEach += 1;\n        var iterator = this.lastEach;\n        this.indexes[iterator] = 0;\n        return iterator;\n    };\n    _proto.getProxyProcessor = function getProxyProcessor() {\n        return {\n            get: function get(node2, prop) {\n                if (prop === \"proxyOf\") {\n                    return node2;\n                } else if (!node2[prop]) {\n                    return node2[prop];\n                } else if (prop === \"each\" || typeof prop === \"string\" && prop.startsWith(\"walk\")) {\n                    return function() {\n                        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                            args[_key] = arguments[_key];\n                        }\n                        var _node2;\n                        return (_node2 = node2)[prop].apply(_node2, [].concat(args.map(function(i2) {\n                            if (typeof i2 === \"function\") {\n                                return function(child, index2) {\n                                    return i2(child.toProxy(), index2);\n                                };\n                            } else {\n                                return i2;\n                            }\n                        })));\n                    };\n                } else if (prop === \"every\" || prop === \"some\") {\n                    return function(cb) {\n                        return node2[prop](function(child) {\n                            for(var _len = arguments.length, other = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                                other[_key - 1] = arguments[_key];\n                            }\n                            return cb.apply(void 0, [].concat([\n                                child.toProxy()\n                            ], other));\n                        });\n                    };\n                } else if (prop === \"root\") {\n                    return function() {\n                        return node2.root().toProxy();\n                    };\n                } else if (prop === \"nodes\") {\n                    return node2.nodes.map(function(i2) {\n                        return i2.toProxy();\n                    });\n                } else if (prop === \"first\" || prop === \"last\") {\n                    return node2[prop].toProxy();\n                } else {\n                    return node2[prop];\n                }\n            },\n            set: function set(node2, prop, value) {\n                if (node2[prop] === value) return true;\n                node2[prop] = value;\n                if (prop === \"name\" || prop === \"params\" || prop === \"selector\") {\n                    node2.markDirty();\n                }\n                return true;\n            }\n        };\n    };\n    _proto.index = function index(child) {\n        if (typeof child === \"number\") return child;\n        if (child.proxyOf) child = child.proxyOf;\n        return this.proxyOf.nodes.indexOf(child);\n    };\n    _proto.insertAfter = function insertAfter(exist, add) {\n        var existIndex = this.index(exist);\n        var nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();\n        existIndex = this.index(exist);\n        for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n            var node2 = _step.value;\n            this.proxyOf.nodes.splice(existIndex + 1, 0, node2);\n        }\n        var index2;\n        for(var id in this.indexes){\n            index2 = this.indexes[id];\n            if (existIndex < index2) {\n                this.indexes[id] = index2 + nodes.length;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.insertBefore = function insertBefore(exist, add) {\n        var existIndex = this.index(exist);\n        var type = existIndex === 0 ? \"prepend\" : false;\n        var nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse();\n        existIndex = this.index(exist);\n        for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n            var node2 = _step.value;\n            this.proxyOf.nodes.splice(existIndex, 0, node2);\n        }\n        var index2;\n        for(var id in this.indexes){\n            index2 = this.indexes[id];\n            if (existIndex <= index2) {\n                this.indexes[id] = index2 + nodes.length;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.normalize = function normalize(nodes, sample) {\n        var _this = this;\n        if (typeof nodes === \"string\") {\n            nodes = cleanSource(parse$4(nodes).nodes);\n        } else if (typeof nodes === \"undefined\") {\n            nodes = [];\n        } else if (Array.isArray(nodes)) {\n            nodes = nodes.slice(0);\n            for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n                var i2 = _step.value;\n                if (i2.parent) i2.parent.removeChild(i2, \"ignore\");\n            }\n        } else if (nodes.type === \"root\" && this.type !== \"document\") {\n            nodes = nodes.nodes.slice(0);\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(nodes), _step1; !(_step1 = _iterator1()).done;){\n                var i21 = _step1.value;\n                if (i21.parent) i21.parent.removeChild(i21, \"ignore\");\n            }\n        } else if (nodes.type) {\n            nodes = [\n                nodes\n            ];\n        } else if (nodes.prop) {\n            if (typeof nodes.value === \"undefined\") {\n                throw new Error(\"Value field is missed in node creation\");\n            } else if (typeof nodes.value !== \"string\") {\n                nodes.value = String(nodes.value);\n            }\n            nodes = [\n                new Declaration$3(nodes)\n            ];\n        } else if (nodes.selector) {\n            nodes = [\n                new Rule$4(nodes)\n            ];\n        } else if (nodes.name) {\n            nodes = [\n                new AtRule$4(nodes)\n            ];\n        } else if (nodes.text) {\n            nodes = [\n                new Comment$3(nodes)\n            ];\n        } else {\n            throw new Error(\"Unknown node type in node creation\");\n        }\n        var processed = nodes.map(function(i2) {\n            if (!i2[my$1]) Container2.rebuild(i2);\n            i2 = i2.proxyOf;\n            if (i2.parent) i2.parent.removeChild(i2);\n            if (i2[isClean$1]) markDirtyUp(i2);\n            if (typeof i2.raws.before === \"undefined\") {\n                if (sample && typeof sample.raws.before !== \"undefined\") {\n                    i2.raws.before = sample.raws.before.replace(/\\S/g, \"\");\n                }\n            }\n            i2.parent = _this.proxyOf;\n            return i2;\n        });\n        return processed;\n    };\n    _proto.prepend = function prepend() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        children = children.reverse();\n        for(var _iterator = _create_for_of_iterator_helper_loose(children), _step; !(_step = _iterator()).done;){\n            var child = _step.value;\n            var nodes = this.normalize(child, this.first, \"prepend\").reverse();\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(nodes), _step1; !(_step1 = _iterator1()).done;){\n                var node2 = _step1.value;\n                this.proxyOf.nodes.unshift(node2);\n            }\n            for(var id in this.indexes){\n                this.indexes[id] = this.indexes[id] + nodes.length;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.push = function push(child) {\n        child.parent = this;\n        this.proxyOf.nodes.push(child);\n        return this;\n    };\n    _proto.removeAll = function removeAll() {\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.proxyOf.nodes), _step; !(_step = _iterator()).done;){\n            var node2 = _step.value;\n            node2.parent = void 0;\n        }\n        this.proxyOf.nodes = [];\n        this.markDirty();\n        return this;\n    };\n    _proto.removeChild = function removeChild(child) {\n        child = this.index(child);\n        this.proxyOf.nodes[child].parent = void 0;\n        this.proxyOf.nodes.splice(child, 1);\n        var index2;\n        for(var id in this.indexes){\n            index2 = this.indexes[id];\n            if (index2 >= child) {\n                this.indexes[id] = index2 - 1;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.replaceValues = function replaceValues(pattern, opts, callback) {\n        if (!callback) {\n            callback = opts;\n            opts = {};\n        }\n        this.walkDecls(function(decl) {\n            if (opts.props && !opts.props.includes(decl.prop)) return;\n            if (opts.fast && !decl.value.includes(opts.fast)) return;\n            decl.value = decl.value.replace(pattern, callback);\n        });\n        this.markDirty();\n        return this;\n    };\n    _proto.some = function some(condition) {\n        return this.nodes.some(condition);\n    };\n    _proto.walk = function walk(callback) {\n        return this.each(function(child, i2) {\n            var result2;\n            try {\n                result2 = callback(child, i2);\n            } catch (e2) {\n                throw child.addToError(e2);\n            }\n            if (result2 !== false && child.walk) {\n                result2 = child.walk(callback);\n            }\n            return result2;\n        });\n    };\n    _proto.walkAtRules = function walkAtRules(name, callback) {\n        if (!callback) {\n            callback = name;\n            return this.walk(function(child, i2) {\n                if (child.type === \"atrule\") {\n                    return callback(child, i2);\n                }\n            });\n        }\n        if (_instanceof(name, RegExp)) {\n            return this.walk(function(child, i2) {\n                if (child.type === \"atrule\" && name.test(child.name)) {\n                    return callback(child, i2);\n                }\n            });\n        }\n        return this.walk(function(child, i2) {\n            if (child.type === \"atrule\" && child.name === name) {\n                return callback(child, i2);\n            }\n        });\n    };\n    _proto.walkComments = function walkComments(callback) {\n        return this.walk(function(child, i2) {\n            if (child.type === \"comment\") {\n                return callback(child, i2);\n            }\n        });\n    };\n    _proto.walkDecls = function walkDecls(prop, callback) {\n        if (!callback) {\n            callback = prop;\n            return this.walk(function(child, i2) {\n                if (child.type === \"decl\") {\n                    return callback(child, i2);\n                }\n            });\n        }\n        if (_instanceof(prop, RegExp)) {\n            return this.walk(function(child, i2) {\n                if (child.type === \"decl\" && prop.test(child.prop)) {\n                    return callback(child, i2);\n                }\n            });\n        }\n        return this.walk(function(child, i2) {\n            if (child.type === \"decl\" && child.prop === prop) {\n                return callback(child, i2);\n            }\n        });\n    };\n    _proto.walkRules = function walkRules(selector, callback) {\n        if (!callback) {\n            callback = selector;\n            return this.walk(function(child, i2) {\n                if (child.type === \"rule\") {\n                    return callback(child, i2);\n                }\n            });\n        }\n        if (_instanceof(selector, RegExp)) {\n            return this.walk(function(child, i2) {\n                if (child.type === \"rule\" && selector.test(child.selector)) {\n                    return callback(child, i2);\n                }\n            });\n        }\n        return this.walk(function(child, i2) {\n            if (child.type === \"rule\" && child.selector === selector) {\n                return callback(child, i2);\n            }\n        });\n    };\n    _create_class(Container2, [\n        {\n            key: \"first\",\n            get: function get() {\n                if (!this.proxyOf.nodes) return void 0;\n                return this.proxyOf.nodes[0];\n            }\n        },\n        {\n            key: \"last\",\n            get: function get() {\n                if (!this.proxyOf.nodes) return void 0;\n                return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];\n            }\n        }\n    ]);\n    return Container2;\n}(Node$1);\nContainer$7.registerParse = function(dependant) {\n    parse$4 = dependant;\n};\nContainer$7.registerRule = function(dependant) {\n    Rule$4 = dependant;\n};\nContainer$7.registerAtRule = function(dependant) {\n    AtRule$4 = dependant;\n};\nContainer$7.registerRoot = function(dependant) {\n    Root$6 = dependant;\n};\nvar container = Container$7;\nContainer$7.default = Container$7;\nContainer$7.rebuild = function(node2) {\n    if (node2.type === \"atrule\") {\n        Object.setPrototypeOf(node2, AtRule$4.prototype);\n    } else if (node2.type === \"rule\") {\n        Object.setPrototypeOf(node2, Rule$4.prototype);\n    } else if (node2.type === \"decl\") {\n        Object.setPrototypeOf(node2, Declaration$3.prototype);\n    } else if (node2.type === \"comment\") {\n        Object.setPrototypeOf(node2, Comment$3.prototype);\n    } else if (node2.type === \"root\") {\n        Object.setPrototypeOf(node2, Root$6.prototype);\n    }\n    node2[my$1] = true;\n    if (node2.nodes) {\n        node2.nodes.forEach(function(child) {\n            Container$7.rebuild(child);\n        });\n    }\n};\nvar Container$6 = container;\nvar LazyResult$4, Processor$3;\nvar Document$3 = /*#__PURE__*/ function(Container$6) {\n    _inherits(Document23, Container$6);\n    function Document23(defaults) {\n        var _this;\n        _this = Container$6.call(this, _extends({\n            type: \"document\"\n        }, defaults)) || this;\n        if (!_this.nodes) {\n            _this.nodes = [];\n        }\n        return _this;\n    }\n    var _proto = Document23.prototype;\n    _proto.toResult = function toResult(opts) {\n        if (opts === void 0) opts = {};\n        var lazy = new LazyResult$4(new Processor$3(), this, opts);\n        return lazy.stringify();\n    };\n    return Document23;\n}(Container$6);\nDocument$3.registerLazyResult = function(dependant) {\n    LazyResult$4 = dependant;\n};\nDocument$3.registerProcessor = function(dependant) {\n    Processor$3 = dependant;\n};\nvar document$1$2 = Document$3;\nDocument$3.default = Document$3;\nvar printed = {};\nvar warnOnce$2 = function warnOnce2(message) {\n    if (printed[message]) return;\n    printed[message] = true;\n    if (typeof console !== \"undefined\" && console.warn) {\n        console.warn(message);\n    }\n};\nvar Warning$2 = /*#__PURE__*/ function() {\n    function Warning2(text, opts) {\n        if (opts === void 0) opts = {};\n        this.type = \"warning\";\n        this.text = text;\n        if (opts.node && opts.node.source) {\n            var range = opts.node.rangeBy(opts);\n            this.line = range.start.line;\n            this.column = range.start.column;\n            this.endLine = range.end.line;\n            this.endColumn = range.end.column;\n        }\n        for(var opt in opts)this[opt] = opts[opt];\n    }\n    var _proto = Warning2.prototype;\n    _proto.toString = function toString() {\n        if (this.node) {\n            return this.node.error(this.text, {\n                index: this.index,\n                plugin: this.plugin,\n                word: this.word\n            }).message;\n        }\n        if (this.plugin) {\n            return this.plugin + \": \" + this.text;\n        }\n        return this.text;\n    };\n    return Warning2;\n}();\nvar warning = Warning$2;\nWarning$2.default = Warning$2;\nvar Warning$1 = warning;\nvar Result$3 = /*#__PURE__*/ function() {\n    function Result2(processor2, root2, opts) {\n        this.processor = processor2;\n        this.messages = [];\n        this.root = root2;\n        this.opts = opts;\n        this.css = void 0;\n        this.map = void 0;\n    }\n    var _proto = Result2.prototype;\n    _proto.toString = function toString() {\n        return this.css;\n    };\n    _proto.warn = function warn(text, opts) {\n        if (opts === void 0) opts = {};\n        if (!opts.plugin) {\n            if (this.lastPlugin && this.lastPlugin.postcssPlugin) {\n                opts.plugin = this.lastPlugin.postcssPlugin;\n            }\n        }\n        var warning2 = new Warning$1(text, opts);\n        this.messages.push(warning2);\n        return warning2;\n    };\n    _proto.warnings = function warnings() {\n        return this.messages.filter(function(i2) {\n            return i2.type === \"warning\";\n        });\n    };\n    _create_class(Result2, [\n        {\n            key: \"content\",\n            get: function get() {\n                return this.css;\n            }\n        }\n    ]);\n    return Result2;\n}();\nvar result = Result$3;\nResult$3.default = Result$3;\nvar SINGLE_QUOTE = \"'\".charCodeAt(0);\nvar DOUBLE_QUOTE = '\"'.charCodeAt(0);\nvar BACKSLASH = \"\\\\\".charCodeAt(0);\nvar SLASH = \"/\".charCodeAt(0);\nvar NEWLINE = \"\\n\".charCodeAt(0);\nvar SPACE = \" \".charCodeAt(0);\nvar FEED = \"\\f\".charCodeAt(0);\nvar TAB = \"\t\".charCodeAt(0);\nvar CR = \"\\r\".charCodeAt(0);\nvar OPEN_SQUARE = \"[\".charCodeAt(0);\nvar CLOSE_SQUARE = \"]\".charCodeAt(0);\nvar OPEN_PARENTHESES = \"(\".charCodeAt(0);\nvar CLOSE_PARENTHESES = \")\".charCodeAt(0);\nvar OPEN_CURLY = \"{\".charCodeAt(0);\nvar CLOSE_CURLY = \"}\".charCodeAt(0);\nvar SEMICOLON = \";\".charCodeAt(0);\nvar ASTERISK = \"*\".charCodeAt(0);\nvar COLON = \":\".charCodeAt(0);\nvar AT = \"@\".charCodeAt(0);\nvar RE_AT_END = /[\\t\\n\\f\\r \"#'()/;[\\\\\\]{}]/g;\nvar RE_WORD_END = /[\\t\\n\\f\\r !\"#'():;@[\\\\\\]{}]|\\/(?=\\*)/g;\nvar RE_BAD_BRACKET = /.[\\r\\n\"'(/\\\\]/;\nvar RE_HEX_ESCAPE = /[\\da-f]/i;\nvar tokenize = function tokenizer2(input2, options) {\n    if (options === void 0) options = {};\n    var css = input2.css.valueOf();\n    var ignore = options.ignoreErrors;\n    var code, next, quote, content, escape;\n    var escaped, escapePos, prev, n2, currentToken;\n    var length = css.length;\n    var pos = 0;\n    var buffer = [];\n    var returned = [];\n    function position() {\n        return pos;\n    }\n    function unclosed(what) {\n        throw input2.error(\"Unclosed \" + what, pos);\n    }\n    function endOfFile() {\n        return returned.length === 0 && pos >= length;\n    }\n    function nextToken(opts) {\n        if (returned.length) return returned.pop();\n        if (pos >= length) return;\n        var ignoreUnclosed = opts ? opts.ignoreUnclosed : false;\n        code = css.charCodeAt(pos);\n        switch(code){\n            case NEWLINE:\n            case SPACE:\n            case TAB:\n            case CR:\n            case FEED:\n                {\n                    next = pos;\n                    do {\n                        next += 1;\n                        code = css.charCodeAt(next);\n                    }while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);\n                    currentToken = [\n                        \"space\",\n                        css.slice(pos, next)\n                    ];\n                    pos = next - 1;\n                    break;\n                }\n            case OPEN_SQUARE:\n            case CLOSE_SQUARE:\n            case OPEN_CURLY:\n            case CLOSE_CURLY:\n            case COLON:\n            case SEMICOLON:\n            case CLOSE_PARENTHESES:\n                {\n                    var controlChar = String.fromCharCode(code);\n                    currentToken = [\n                        controlChar,\n                        controlChar,\n                        pos\n                    ];\n                    break;\n                }\n            case OPEN_PARENTHESES:\n                {\n                    prev = buffer.length ? buffer.pop()[1] : \"\";\n                    n2 = css.charCodeAt(pos + 1);\n                    if (prev === \"url\" && n2 !== SINGLE_QUOTE && n2 !== DOUBLE_QUOTE && n2 !== SPACE && n2 !== NEWLINE && n2 !== TAB && n2 !== FEED && n2 !== CR) {\n                        next = pos;\n                        do {\n                            escaped = false;\n                            next = css.indexOf(\")\", next + 1);\n                            if (next === -1) {\n                                if (ignore || ignoreUnclosed) {\n                                    next = pos;\n                                    break;\n                                } else {\n                                    unclosed(\"bracket\");\n                                }\n                            }\n                            escapePos = next;\n                            while(css.charCodeAt(escapePos - 1) === BACKSLASH){\n                                escapePos -= 1;\n                                escaped = !escaped;\n                            }\n                        }while (escaped);\n                        currentToken = [\n                            \"brackets\",\n                            css.slice(pos, next + 1),\n                            pos,\n                            next\n                        ];\n                        pos = next;\n                    } else {\n                        next = css.indexOf(\")\", pos + 1);\n                        content = css.slice(pos, next + 1);\n                        if (next === -1 || RE_BAD_BRACKET.test(content)) {\n                            currentToken = [\n                                \"(\",\n                                \"(\",\n                                pos\n                            ];\n                        } else {\n                            currentToken = [\n                                \"brackets\",\n                                content,\n                                pos,\n                                next\n                            ];\n                            pos = next;\n                        }\n                    }\n                    break;\n                }\n            case SINGLE_QUOTE:\n            case DOUBLE_QUOTE:\n                {\n                    quote = code === SINGLE_QUOTE ? \"'\" : '\"';\n                    next = pos;\n                    do {\n                        escaped = false;\n                        next = css.indexOf(quote, next + 1);\n                        if (next === -1) {\n                            if (ignore || ignoreUnclosed) {\n                                next = pos + 1;\n                                break;\n                            } else {\n                                unclosed(\"string\");\n                            }\n                        }\n                        escapePos = next;\n                        while(css.charCodeAt(escapePos - 1) === BACKSLASH){\n                            escapePos -= 1;\n                            escaped = !escaped;\n                        }\n                    }while (escaped);\n                    currentToken = [\n                        \"string\",\n                        css.slice(pos, next + 1),\n                        pos,\n                        next\n                    ];\n                    pos = next;\n                    break;\n                }\n            case AT:\n                {\n                    RE_AT_END.lastIndex = pos + 1;\n                    RE_AT_END.test(css);\n                    if (RE_AT_END.lastIndex === 0) {\n                        next = css.length - 1;\n                    } else {\n                        next = RE_AT_END.lastIndex - 2;\n                    }\n                    currentToken = [\n                        \"at-word\",\n                        css.slice(pos, next + 1),\n                        pos,\n                        next\n                    ];\n                    pos = next;\n                    break;\n                }\n            case BACKSLASH:\n                {\n                    next = pos;\n                    escape = true;\n                    while(css.charCodeAt(next + 1) === BACKSLASH){\n                        next += 1;\n                        escape = !escape;\n                    }\n                    code = css.charCodeAt(next + 1);\n                    if (escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {\n                        next += 1;\n                        if (RE_HEX_ESCAPE.test(css.charAt(next))) {\n                            while(RE_HEX_ESCAPE.test(css.charAt(next + 1))){\n                                next += 1;\n                            }\n                            if (css.charCodeAt(next + 1) === SPACE) {\n                                next += 1;\n                            }\n                        }\n                    }\n                    currentToken = [\n                        \"word\",\n                        css.slice(pos, next + 1),\n                        pos,\n                        next\n                    ];\n                    pos = next;\n                    break;\n                }\n            default:\n                {\n                    if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {\n                        next = css.indexOf(\"*/\", pos + 2) + 1;\n                        if (next === 0) {\n                            if (ignore || ignoreUnclosed) {\n                                next = css.length;\n                            } else {\n                                unclosed(\"comment\");\n                            }\n                        }\n                        currentToken = [\n                            \"comment\",\n                            css.slice(pos, next + 1),\n                            pos,\n                            next\n                        ];\n                        pos = next;\n                    } else {\n                        RE_WORD_END.lastIndex = pos + 1;\n                        RE_WORD_END.test(css);\n                        if (RE_WORD_END.lastIndex === 0) {\n                            next = css.length - 1;\n                        } else {\n                            next = RE_WORD_END.lastIndex - 2;\n                        }\n                        currentToken = [\n                            \"word\",\n                            css.slice(pos, next + 1),\n                            pos,\n                            next\n                        ];\n                        buffer.push(currentToken);\n                        pos = next;\n                    }\n                    break;\n                }\n        }\n        pos++;\n        return currentToken;\n    }\n    function back(token) {\n        returned.push(token);\n    }\n    return {\n        back: back,\n        endOfFile: endOfFile,\n        nextToken: nextToken,\n        position: position\n    };\n};\nvar Container$5 = container;\nvar AtRule$3 = /*#__PURE__*/ function(Container$5) {\n    _inherits(AtRule2, Container$5);\n    function AtRule2(defaults) {\n        var _this;\n        _this = Container$5.call(this, defaults) || this;\n        _this.type = \"atrule\";\n        return _this;\n    }\n    var _proto = AtRule2.prototype;\n    _proto.append = function append() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        var _Container$5_prototype_append;\n        if (!this.proxyOf.nodes) this.nodes = [];\n        return (_Container$5_prototype_append = Container$5.prototype.append).call.apply(_Container$5_prototype_append, [].concat([\n            this\n        ], children));\n    };\n    _proto.prepend = function prepend() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        var _Container$5_prototype_prepend;\n        if (!this.proxyOf.nodes) this.nodes = [];\n        return (_Container$5_prototype_prepend = Container$5.prototype.prepend).call.apply(_Container$5_prototype_prepend, [].concat([\n            this\n        ], children));\n    };\n    return AtRule2;\n}(Container$5);\nvar atRule = AtRule$3;\nAtRule$3.default = AtRule$3;\nContainer$5.registerAtRule(AtRule$3);\nvar Container$4 = container;\nvar LazyResult$3, Processor$2;\nvar Root$5 = /*#__PURE__*/ function(Container$4) {\n    _inherits(Root2, Container$4);\n    function Root2(defaults) {\n        var _this;\n        _this = Container$4.call(this, defaults) || this;\n        _this.type = \"root\";\n        if (!_this.nodes) _this.nodes = [];\n        return _this;\n    }\n    var _proto = Root2.prototype;\n    _proto.normalize = function normalize(child, sample, type) {\n        var nodes = Container$4.prototype.normalize.call(this, child);\n        if (sample) {\n            if (type === \"prepend\") {\n                if (this.nodes.length > 1) {\n                    sample.raws.before = this.nodes[1].raws.before;\n                } else {\n                    delete sample.raws.before;\n                }\n            } else if (this.first !== sample) {\n                for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n                    var node2 = _step.value;\n                    node2.raws.before = sample.raws.before;\n                }\n            }\n        }\n        return nodes;\n    };\n    _proto.removeChild = function removeChild(child, ignore) {\n        var index2 = this.index(child);\n        if (!ignore && index2 === 0 && this.nodes.length > 1) {\n            this.nodes[1].raws.before = this.nodes[index2].raws.before;\n        }\n        return Container$4.prototype.removeChild.call(this, child);\n    };\n    _proto.toResult = function toResult(opts) {\n        if (opts === void 0) opts = {};\n        var lazy = new LazyResult$3(new Processor$2(), this, opts);\n        return lazy.stringify();\n    };\n    return Root2;\n}(Container$4);\nRoot$5.registerLazyResult = function(dependant) {\n    LazyResult$3 = dependant;\n};\nRoot$5.registerProcessor = function(dependant) {\n    Processor$2 = dependant;\n};\nvar root = Root$5;\nRoot$5.default = Root$5;\nContainer$4.registerRoot(Root$5);\nvar list$2 = {\n    comma: function comma(string) {\n        return list$2.split(string, [\n            \",\"\n        ], true);\n    },\n    space: function space(string) {\n        var spaces = [\n            \" \",\n            \"\\n\",\n            \"\t\"\n        ];\n        return list$2.split(string, spaces);\n    },\n    split: function split(string, separators, last) {\n        var array = [];\n        var current = \"\";\n        var split = false;\n        var func = 0;\n        var inQuote = false;\n        var prevQuote = \"\";\n        var escape = false;\n        for(var _iterator = _create_for_of_iterator_helper_loose(string), _step; !(_step = _iterator()).done;){\n            var letter = _step.value;\n            if (escape) {\n                escape = false;\n            } else if (letter === \"\\\\\") {\n                escape = true;\n            } else if (inQuote) {\n                if (letter === prevQuote) {\n                    inQuote = false;\n                }\n            } else if (letter === '\"' || letter === \"'\") {\n                inQuote = true;\n                prevQuote = letter;\n            } else if (letter === \"(\") {\n                func += 1;\n            } else if (letter === \")\") {\n                if (func > 0) func -= 1;\n            } else if (func === 0) {\n                if (separators.includes(letter)) split = true;\n            }\n            if (split) {\n                if (current !== \"\") array.push(current.trim());\n                current = \"\";\n                split = false;\n            } else {\n                current += letter;\n            }\n        }\n        if (last || current !== \"\") array.push(current.trim());\n        return array;\n    }\n};\nvar list_1 = list$2;\nlist$2.default = list$2;\nvar Container$3 = container;\nvar list$1 = list_1;\nvar Rule$3 = /*#__PURE__*/ function(Container$3) {\n    _inherits(Rule2, Container$3);\n    function Rule2(defaults) {\n        var _this;\n        _this = Container$3.call(this, defaults) || this;\n        _this.type = \"rule\";\n        if (!_this.nodes) _this.nodes = [];\n        return _this;\n    }\n    _create_class(Rule2, [\n        {\n            key: \"selectors\",\n            get: function get() {\n                return list$1.comma(this.selector);\n            },\n            set: function set(values) {\n                var match = this.selector ? this.selector.match(/,\\s*/) : null;\n                var sep2 = match ? match[0] : \",\" + this.raw(\"between\", \"beforeOpen\");\n                this.selector = values.join(sep2);\n            }\n        }\n    ]);\n    return Rule2;\n}(Container$3);\nvar rule = Rule$3;\nRule$3.default = Rule$3;\nContainer$3.registerRule(Rule$3);\nvar Declaration$2 = declaration;\nvar tokenizer22 = tokenize;\nvar Comment$2 = comment;\nvar AtRule$2 = atRule;\nvar Root$4 = root;\nvar Rule$2 = rule;\nvar SAFE_COMMENT_NEIGHBOR = {\n    empty: true,\n    space: true\n};\nfunction findLastWithPosition(tokens) {\n    for(var i2 = tokens.length - 1; i2 >= 0; i2--){\n        var token = tokens[i2];\n        var pos = token[3] || token[2];\n        if (pos) return pos;\n    }\n}\nvar Parser$1 = /*#__PURE__*/ function() {\n    function Parser2(input2) {\n        this.input = input2;\n        this.root = new Root$4();\n        this.current = this.root;\n        this.spaces = \"\";\n        this.semicolon = false;\n        this.createTokenizer();\n        this.root.source = {\n            input: input2,\n            start: {\n                column: 1,\n                line: 1,\n                offset: 0\n            }\n        };\n    }\n    var _proto = Parser2.prototype;\n    _proto.atrule = function atrule(token) {\n        var node2 = new AtRule$2();\n        node2.name = token[1].slice(1);\n        if (node2.name === \"\") {\n            this.unnamedAtrule(node2, token);\n        }\n        this.init(node2, token[2]);\n        var type;\n        var prev;\n        var shift;\n        var last = false;\n        var open = false;\n        var params = [];\n        var brackets = [];\n        while(!this.tokenizer.endOfFile()){\n            token = this.tokenizer.nextToken();\n            type = token[0];\n            if (type === \"(\" || type === \"[\") {\n                brackets.push(type === \"(\" ? \")\" : \"]\");\n            } else if (type === \"{\" && brackets.length > 0) {\n                brackets.push(\"}\");\n            } else if (type === brackets[brackets.length - 1]) {\n                brackets.pop();\n            }\n            if (brackets.length === 0) {\n                if (type === \";\") {\n                    node2.source.end = this.getPosition(token[2]);\n                    node2.source.end.offset++;\n                    this.semicolon = true;\n                    break;\n                } else if (type === \"{\") {\n                    open = true;\n                    break;\n                } else if (type === \"}\") {\n                    if (params.length > 0) {\n                        shift = params.length - 1;\n                        prev = params[shift];\n                        while(prev && prev[0] === \"space\"){\n                            prev = params[--shift];\n                        }\n                        if (prev) {\n                            node2.source.end = this.getPosition(prev[3] || prev[2]);\n                            node2.source.end.offset++;\n                        }\n                    }\n                    this.end(token);\n                    break;\n                } else {\n                    params.push(token);\n                }\n            } else {\n                params.push(token);\n            }\n            if (this.tokenizer.endOfFile()) {\n                last = true;\n                break;\n            }\n        }\n        node2.raws.between = this.spacesAndCommentsFromEnd(params);\n        if (params.length) {\n            node2.raws.afterName = this.spacesAndCommentsFromStart(params);\n            this.raw(node2, \"params\", params);\n            if (last) {\n                token = params[params.length - 1];\n                node2.source.end = this.getPosition(token[3] || token[2]);\n                node2.source.end.offset++;\n                this.spaces = node2.raws.between;\n                node2.raws.between = \"\";\n            }\n        } else {\n            node2.raws.afterName = \"\";\n            node2.params = \"\";\n        }\n        if (open) {\n            node2.nodes = [];\n            this.current = node2;\n        }\n    };\n    _proto.checkMissedSemicolon = function checkMissedSemicolon(tokens) {\n        var colon = this.colon(tokens);\n        if (colon === false) return;\n        var founded = 0;\n        var token;\n        for(var j = colon - 1; j >= 0; j--){\n            token = tokens[j];\n            if (token[0] !== \"space\") {\n                founded += 1;\n                if (founded === 2) break;\n            }\n        }\n        throw this.input.error(\"Missed semicolon\", token[0] === \"word\" ? token[3] + 1 : token[2]);\n    };\n    _proto.colon = function colon(tokens) {\n        var brackets = 0;\n        var token, type, prev;\n        for(var _iterator = _create_for_of_iterator_helper_loose(tokens.entries()), _step; !(_step = _iterator()).done;){\n            var _step_value = _step.value, i2 = _step_value[0], element = _step_value[1];\n            token = element;\n            type = token[0];\n            if (type === \"(\") {\n                brackets += 1;\n            }\n            if (type === \")\") {\n                brackets -= 1;\n            }\n            if (brackets === 0 && type === \":\") {\n                if (!prev) {\n                    this.doubleColon(token);\n                } else if (prev[0] === \"word\" && prev[1] === \"progid\") {\n                    continue;\n                } else {\n                    return i2;\n                }\n            }\n            prev = token;\n        }\n        return false;\n    };\n    _proto.comment = function comment(token) {\n        var node2 = new Comment$2();\n        this.init(node2, token[2]);\n        node2.source.end = this.getPosition(token[3] || token[2]);\n        node2.source.end.offset++;\n        var text = token[1].slice(2, -2);\n        if (/^\\s*$/.test(text)) {\n            node2.text = \"\";\n            node2.raws.left = text;\n            node2.raws.right = \"\";\n        } else {\n            var match = text.match(/^(\\s*)([^]*\\S)(\\s*)$/);\n            node2.text = match[2];\n            node2.raws.left = match[1];\n            node2.raws.right = match[3];\n        }\n    };\n    _proto.createTokenizer = function createTokenizer() {\n        this.tokenizer = tokenizer22(this.input);\n    };\n    _proto.decl = function decl(tokens, customProperty) {\n        var node2 = new Declaration$2();\n        this.init(node2, tokens[0][2]);\n        var last = tokens[tokens.length - 1];\n        if (last[0] === \";\") {\n            this.semicolon = true;\n            tokens.pop();\n        }\n        node2.source.end = this.getPosition(last[3] || last[2] || findLastWithPosition(tokens));\n        node2.source.end.offset++;\n        while(tokens[0][0] !== \"word\"){\n            if (tokens.length === 1) this.unknownWord(tokens);\n            node2.raws.before += tokens.shift()[1];\n        }\n        node2.source.start = this.getPosition(tokens[0][2]);\n        node2.prop = \"\";\n        while(tokens.length){\n            var type = tokens[0][0];\n            if (type === \":\" || type === \"space\" || type === \"comment\") {\n                break;\n            }\n            node2.prop += tokens.shift()[1];\n        }\n        node2.raws.between = \"\";\n        var token;\n        while(tokens.length){\n            token = tokens.shift();\n            if (token[0] === \":\") {\n                node2.raws.between += token[1];\n                break;\n            } else {\n                if (token[0] === \"word\" && /\\w/.test(token[1])) {\n                    this.unknownWord([\n                        token\n                    ]);\n                }\n                node2.raws.between += token[1];\n            }\n        }\n        if (node2.prop[0] === \"_\" || node2.prop[0] === \"*\") {\n            node2.raws.before += node2.prop[0];\n            node2.prop = node2.prop.slice(1);\n        }\n        var firstSpaces = [];\n        var next;\n        while(tokens.length){\n            next = tokens[0][0];\n            if (next !== \"space\" && next !== \"comment\") break;\n            firstSpaces.push(tokens.shift());\n        }\n        this.precheckMissedSemicolon(tokens);\n        for(var i2 = tokens.length - 1; i2 >= 0; i2--){\n            token = tokens[i2];\n            if (token[1].toLowerCase() === \"!important\") {\n                node2.important = true;\n                var string = this.stringFrom(tokens, i2);\n                string = this.spacesFromEnd(tokens) + string;\n                if (string !== \" !important\") node2.raws.important = string;\n                break;\n            } else if (token[1].toLowerCase() === \"important\") {\n                var cache = tokens.slice(0);\n                var str = \"\";\n                for(var j = i2; j > 0; j--){\n                    var type1 = cache[j][0];\n                    if (str.trim().indexOf(\"!\") === 0 && type1 !== \"space\") {\n                        break;\n                    }\n                    str = cache.pop()[1] + str;\n                }\n                if (str.trim().indexOf(\"!\") === 0) {\n                    node2.important = true;\n                    node2.raws.important = str;\n                    tokens = cache;\n                }\n            }\n            if (token[0] !== \"space\" && token[0] !== \"comment\") {\n                break;\n            }\n        }\n        var hasWord = tokens.some(function(i2) {\n            return i2[0] !== \"space\" && i2[0] !== \"comment\";\n        });\n        if (hasWord) {\n            node2.raws.between += firstSpaces.map(function(i2) {\n                return i2[1];\n            }).join(\"\");\n            firstSpaces = [];\n        }\n        this.raw(node2, \"value\", firstSpaces.concat(tokens), customProperty);\n        if (node2.value.includes(\":\") && !customProperty) {\n            this.checkMissedSemicolon(tokens);\n        }\n    };\n    _proto.doubleColon = function doubleColon(token) {\n        throw this.input.error(\"Double colon\", {\n            offset: token[2]\n        }, {\n            offset: token[2] + token[1].length\n        });\n    };\n    _proto.emptyRule = function emptyRule(token) {\n        var node2 = new Rule$2();\n        this.init(node2, token[2]);\n        node2.selector = \"\";\n        node2.raws.between = \"\";\n        this.current = node2;\n    };\n    _proto.end = function end(token) {\n        if (this.current.nodes && this.current.nodes.length) {\n            this.current.raws.semicolon = this.semicolon;\n        }\n        this.semicolon = false;\n        this.current.raws.after = (this.current.raws.after || \"\") + this.spaces;\n        this.spaces = \"\";\n        if (this.current.parent) {\n            this.current.source.end = this.getPosition(token[2]);\n            this.current.source.end.offset++;\n            this.current = this.current.parent;\n        } else {\n            this.unexpectedClose(token);\n        }\n    };\n    _proto.endFile = function endFile() {\n        if (this.current.parent) this.unclosedBlock();\n        if (this.current.nodes && this.current.nodes.length) {\n            this.current.raws.semicolon = this.semicolon;\n        }\n        this.current.raws.after = (this.current.raws.after || \"\") + this.spaces;\n        this.root.source.end = this.getPosition(this.tokenizer.position());\n    };\n    _proto.freeSemicolon = function freeSemicolon(token) {\n        this.spaces += token[1];\n        if (this.current.nodes) {\n            var prev = this.current.nodes[this.current.nodes.length - 1];\n            if (prev && prev.type === \"rule\" && !prev.raws.ownSemicolon) {\n                prev.raws.ownSemicolon = this.spaces;\n                this.spaces = \"\";\n            }\n        }\n    };\n    // Helpers\n    _proto.getPosition = function getPosition(offset) {\n        var pos = this.input.fromOffset(offset);\n        return {\n            column: pos.col,\n            line: pos.line,\n            offset: offset\n        };\n    };\n    _proto.init = function init(node2, offset) {\n        this.current.push(node2);\n        node2.source = {\n            input: this.input,\n            start: this.getPosition(offset)\n        };\n        node2.raws.before = this.spaces;\n        this.spaces = \"\";\n        if (node2.type !== \"comment\") this.semicolon = false;\n    };\n    _proto.other = function other(start) {\n        var end = false;\n        var type = null;\n        var colon = false;\n        var bracket = null;\n        var brackets = [];\n        var customProperty = start[1].startsWith(\"--\");\n        var tokens = [];\n        var token = start;\n        while(token){\n            type = token[0];\n            tokens.push(token);\n            if (type === \"(\" || type === \"[\") {\n                if (!bracket) bracket = token;\n                brackets.push(type === \"(\" ? \")\" : \"]\");\n            } else if (customProperty && colon && type === \"{\") {\n                if (!bracket) bracket = token;\n                brackets.push(\"}\");\n            } else if (brackets.length === 0) {\n                if (type === \";\") {\n                    if (colon) {\n                        this.decl(tokens, customProperty);\n                        return;\n                    } else {\n                        break;\n                    }\n                } else if (type === \"{\") {\n                    this.rule(tokens);\n                    return;\n                } else if (type === \"}\") {\n                    this.tokenizer.back(tokens.pop());\n                    end = true;\n                    break;\n                } else if (type === \":\") {\n                    colon = true;\n                }\n            } else if (type === brackets[brackets.length - 1]) {\n                brackets.pop();\n                if (brackets.length === 0) bracket = null;\n            }\n            token = this.tokenizer.nextToken();\n        }\n        if (this.tokenizer.endOfFile()) end = true;\n        if (brackets.length > 0) this.unclosedBracket(bracket);\n        if (end && colon) {\n            if (!customProperty) {\n                while(tokens.length){\n                    token = tokens[tokens.length - 1][0];\n                    if (token !== \"space\" && token !== \"comment\") break;\n                    this.tokenizer.back(tokens.pop());\n                }\n            }\n            this.decl(tokens, customProperty);\n        } else {\n            this.unknownWord(tokens);\n        }\n    };\n    _proto.parse = function parse() {\n        var token;\n        while(!this.tokenizer.endOfFile()){\n            token = this.tokenizer.nextToken();\n            switch(token[0]){\n                case \"space\":\n                    this.spaces += token[1];\n                    break;\n                case \";\":\n                    this.freeSemicolon(token);\n                    break;\n                case \"}\":\n                    this.end(token);\n                    break;\n                case \"comment\":\n                    this.comment(token);\n                    break;\n                case \"at-word\":\n                    this.atrule(token);\n                    break;\n                case \"{\":\n                    this.emptyRule(token);\n                    break;\n                default:\n                    this.other(token);\n                    break;\n            }\n        }\n        this.endFile();\n    };\n    _proto.precheckMissedSemicolon = function precheckMissedSemicolon() {};\n    _proto.raw = function raw(node2, prop, tokens, customProperty) {\n        var token, type;\n        var length = tokens.length;\n        var value = \"\";\n        var clean = true;\n        var next, prev;\n        for(var i2 = 0; i2 < length; i2 += 1){\n            token = tokens[i2];\n            type = token[0];\n            if (type === \"space\" && i2 === length - 1 && !customProperty) {\n                clean = false;\n            } else if (type === \"comment\") {\n                prev = tokens[i2 - 1] ? tokens[i2 - 1][0] : \"empty\";\n                next = tokens[i2 + 1] ? tokens[i2 + 1][0] : \"empty\";\n                if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {\n                    if (value.slice(-1) === \",\") {\n                        clean = false;\n                    } else {\n                        value += token[1];\n                    }\n                } else {\n                    clean = false;\n                }\n            } else {\n                value += token[1];\n            }\n        }\n        if (!clean) {\n            var raw = tokens.reduce(function(all, i2) {\n                return all + i2[1];\n            }, \"\");\n            node2.raws[prop] = {\n                raw: raw,\n                value: value\n            };\n        }\n        node2[prop] = value;\n    };\n    _proto.rule = function rule(tokens) {\n        tokens.pop();\n        var node2 = new Rule$2();\n        this.init(node2, tokens[0][2]);\n        node2.raws.between = this.spacesAndCommentsFromEnd(tokens);\n        this.raw(node2, \"selector\", tokens);\n        this.current = node2;\n    };\n    _proto.spacesAndCommentsFromEnd = function spacesAndCommentsFromEnd(tokens) {\n        var lastTokenType;\n        var spaces = \"\";\n        while(tokens.length){\n            lastTokenType = tokens[tokens.length - 1][0];\n            if (lastTokenType !== \"space\" && lastTokenType !== \"comment\") break;\n            spaces = tokens.pop()[1] + spaces;\n        }\n        return spaces;\n    };\n    // Errors\n    _proto.spacesAndCommentsFromStart = function spacesAndCommentsFromStart(tokens) {\n        var next;\n        var spaces = \"\";\n        while(tokens.length){\n            next = tokens[0][0];\n            if (next !== \"space\" && next !== \"comment\") break;\n            spaces += tokens.shift()[1];\n        }\n        return spaces;\n    };\n    _proto.spacesFromEnd = function spacesFromEnd(tokens) {\n        var lastTokenType;\n        var spaces = \"\";\n        while(tokens.length){\n            lastTokenType = tokens[tokens.length - 1][0];\n            if (lastTokenType !== \"space\") break;\n            spaces = tokens.pop()[1] + spaces;\n        }\n        return spaces;\n    };\n    _proto.stringFrom = function stringFrom(tokens, from) {\n        var result2 = \"\";\n        for(var i2 = from; i2 < tokens.length; i2++){\n            result2 += tokens[i2][1];\n        }\n        tokens.splice(from, tokens.length - from);\n        return result2;\n    };\n    _proto.unclosedBlock = function unclosedBlock() {\n        var pos = this.current.source.start;\n        throw this.input.error(\"Unclosed block\", pos.line, pos.column);\n    };\n    _proto.unclosedBracket = function unclosedBracket(bracket) {\n        throw this.input.error(\"Unclosed bracket\", {\n            offset: bracket[2]\n        }, {\n            offset: bracket[2] + 1\n        });\n    };\n    _proto.unexpectedClose = function unexpectedClose(token) {\n        throw this.input.error(\"Unexpected }\", {\n            offset: token[2]\n        }, {\n            offset: token[2] + 1\n        });\n    };\n    _proto.unknownWord = function unknownWord(tokens) {\n        throw this.input.error(\"Unknown word\", {\n            offset: tokens[0][2]\n        }, {\n            offset: tokens[0][2] + tokens[0][1].length\n        });\n    };\n    _proto.unnamedAtrule = function unnamedAtrule(node2, token) {\n        throw this.input.error(\"At-rule without name\", {\n            offset: token[2]\n        }, {\n            offset: token[2] + token[1].length\n        });\n    };\n    return Parser2;\n}();\nvar parser = Parser$1;\nvar Container$2 = container;\nvar Parser22 = parser;\nvar Input$2 = input;\nfunction parse$3(css, opts) {\n    var input2 = new Input$2(css, opts);\n    var parser2 = new Parser22(input2);\n    try {\n        parser2.parse();\n    } catch (e2) {\n        if (true) {\n            if (e2.name === \"CssSyntaxError\" && opts && opts.from) {\n                if (/\\.scss$/i.test(opts.from)) {\n                    e2.message += \"\\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser\";\n                } else if (/\\.sass/i.test(opts.from)) {\n                    e2.message += \"\\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser\";\n                } else if (/\\.less$/i.test(opts.from)) {\n                    e2.message += \"\\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser\";\n                }\n            }\n        }\n        throw e2;\n    }\n    return parser2.root;\n}\nvar parse_1 = parse$3;\nparse$3.default = parse$3;\nContainer$2.registerParse(parse$3);\nvar isClean = symbols.isClean, my = symbols.my;\nvar MapGenerator$1 = mapGenerator;\nvar stringify$2 = stringify_1;\nvar Container$1 = container;\nvar Document$2 = document$1$2;\nvar warnOnce$1 = warnOnce$2;\nvar Result$2 = result;\nvar parse$2 = parse_1;\nvar Root$3 = root;\nvar TYPE_TO_CLASS_NAME = {\n    atrule: \"AtRule\",\n    comment: \"Comment\",\n    decl: \"Declaration\",\n    document: \"Document\",\n    root: \"Root\",\n    rule: \"Rule\"\n};\nvar PLUGIN_PROPS = {\n    AtRule: true,\n    AtRuleExit: true,\n    Comment: true,\n    CommentExit: true,\n    Declaration: true,\n    DeclarationExit: true,\n    Document: true,\n    DocumentExit: true,\n    Once: true,\n    OnceExit: true,\n    postcssPlugin: true,\n    prepare: true,\n    Root: true,\n    RootExit: true,\n    Rule: true,\n    RuleExit: true\n};\nvar NOT_VISITORS = {\n    Once: true,\n    postcssPlugin: true,\n    prepare: true\n};\nvar CHILDREN = 0;\nfunction isPromise(obj) {\n    return (typeof obj === \"undefined\" ? \"undefined\" : _type_of(obj)) === \"object\" && typeof obj.then === \"function\";\n}\nfunction getEvents(node2) {\n    var key = false;\n    var type = TYPE_TO_CLASS_NAME[node2.type];\n    if (node2.type === \"decl\") {\n        key = node2.prop.toLowerCase();\n    } else if (node2.type === \"atrule\") {\n        key = node2.name.toLowerCase();\n    }\n    if (key && node2.append) {\n        return [\n            type,\n            type + \"-\" + key,\n            CHILDREN,\n            type + \"Exit\",\n            type + \"Exit-\" + key\n        ];\n    } else if (key) {\n        return [\n            type,\n            type + \"-\" + key,\n            type + \"Exit\",\n            type + \"Exit-\" + key\n        ];\n    } else if (node2.append) {\n        return [\n            type,\n            CHILDREN,\n            type + \"Exit\"\n        ];\n    } else {\n        return [\n            type,\n            type + \"Exit\"\n        ];\n    }\n}\nfunction toStack(node2) {\n    var events;\n    if (node2.type === \"document\") {\n        events = [\n            \"Document\",\n            CHILDREN,\n            \"DocumentExit\"\n        ];\n    } else if (node2.type === \"root\") {\n        events = [\n            \"Root\",\n            CHILDREN,\n            \"RootExit\"\n        ];\n    } else {\n        events = getEvents(node2);\n    }\n    return {\n        eventIndex: 0,\n        events: events,\n        iterator: 0,\n        node: node2,\n        visitorIndex: 0,\n        visitors: []\n    };\n}\nfunction cleanMarks(node2) {\n    node2[isClean] = false;\n    if (node2.nodes) node2.nodes.forEach(function(i2) {\n        return cleanMarks(i2);\n    });\n    return node2;\n}\nvar postcss$2 = {};\nvar LazyResult$2 = /*#__PURE__*/ function() {\n    function LazyResult2(processor2, css, opts) {\n        var _this = this;\n        this.stringified = false;\n        this.processed = false;\n        var root2;\n        if ((typeof css === \"undefined\" ? \"undefined\" : _type_of(css)) === \"object\" && css !== null && (css.type === \"root\" || css.type === \"document\")) {\n            root2 = cleanMarks(css);\n        } else if (_instanceof(css, LazyResult2) || _instanceof(css, Result$2)) {\n            root2 = cleanMarks(css.root);\n            if (css.map) {\n                if (typeof opts.map === \"undefined\") opts.map = {};\n                if (!opts.map.inline) opts.map.inline = false;\n                opts.map.prev = css.map;\n            }\n        } else {\n            var parser2 = parse$2;\n            if (opts.syntax) parser2 = opts.syntax.parse;\n            if (opts.parser) parser2 = opts.parser;\n            if (parser2.parse) parser2 = parser2.parse;\n            try {\n                root2 = parser2(css, opts);\n            } catch (error) {\n                this.processed = true;\n                this.error = error;\n            }\n            if (root2 && !root2[my]) {\n                Container$1.rebuild(root2);\n            }\n        }\n        this.result = new Result$2(processor2, root2, opts);\n        this.helpers = _extends({}, postcss$2, {\n            postcss: postcss$2,\n            result: this.result\n        });\n        this.plugins = this.processor.plugins.map(function(plugin22) {\n            if ((typeof plugin22 === \"undefined\" ? \"undefined\" : _type_of(plugin22)) === \"object\" && plugin22.prepare) {\n                return _extends({}, plugin22, plugin22.prepare(_this.result));\n            } else {\n                return plugin22;\n            }\n        });\n    }\n    var _proto = LazyResult2.prototype;\n    _proto.async = function async() {\n        if (this.error) return Promise.reject(this.error);\n        if (this.processed) return Promise.resolve(this.result);\n        if (!this.processing) {\n            this.processing = this.runAsync();\n        }\n        return this.processing;\n    };\n    _proto.catch = function _catch(onRejected) {\n        return this.async().catch(onRejected);\n    };\n    _proto.finally = function _finally(onFinally) {\n        return this.async().then(onFinally, onFinally);\n    };\n    _proto.getAsyncError = function getAsyncError() {\n        throw new Error(\"Use process(css).then(cb) to work with async plugins\");\n    };\n    _proto.handleError = function handleError(error, node2) {\n        var plugin22 = this.result.lastPlugin;\n        try {\n            if (node2) node2.addToError(error);\n            this.error = error;\n            if (error.name === \"CssSyntaxError\" && !error.plugin) {\n                error.plugin = plugin22.postcssPlugin;\n                error.setMessage();\n            } else if (plugin22.postcssVersion) {\n                if (true) {\n                    var pluginName = plugin22.postcssPlugin;\n                    var pluginVer = plugin22.postcssVersion;\n                    var runtimeVer = this.result.processor.version;\n                    var a2 = pluginVer.split(\".\");\n                    var b = runtimeVer.split(\".\");\n                    if (a2[0] !== b[0] || parseInt(a2[1]) > parseInt(b[1])) {\n                        console.error(\"Unknown error from PostCSS plugin. Your current PostCSS version is \" + runtimeVer + \", but \" + pluginName + \" uses \" + pluginVer + \". Perhaps this is the source of the error below.\");\n                    }\n                }\n            }\n        } catch (err) {\n            if (console && console.error) console.error(err);\n        }\n        return error;\n    };\n    _proto.prepareVisitors = function prepareVisitors() {\n        var _this = this;\n        this.listeners = {};\n        var add = function(plugin22, type, cb) {\n            if (!_this.listeners[type]) _this.listeners[type] = [];\n            _this.listeners[type].push([\n                plugin22,\n                cb\n            ]);\n        };\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.plugins), _step; !(_step = _iterator()).done;){\n            var plugin22 = _step.value;\n            if ((typeof plugin22 === \"undefined\" ? \"undefined\" : _type_of(plugin22)) === \"object\") {\n                for(var event in plugin22){\n                    if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {\n                        throw new Error(\"Unknown event \" + event + \" in \" + plugin22.postcssPlugin + \". Try to update PostCSS (\" + this.processor.version + \" now).\");\n                    }\n                    if (!NOT_VISITORS[event]) {\n                        if (_type_of(plugin22[event]) === \"object\") {\n                            for(var filter in plugin22[event]){\n                                if (filter === \"*\") {\n                                    add(plugin22, event, plugin22[event][filter]);\n                                } else {\n                                    add(plugin22, event + \"-\" + filter.toLowerCase(), plugin22[event][filter]);\n                                }\n                            }\n                        } else if (typeof plugin22[event] === \"function\") {\n                            add(plugin22, event, plugin22[event]);\n                        }\n                    }\n                }\n            }\n        }\n        this.hasListener = Object.keys(this.listeners).length > 0;\n    };\n    _proto.runAsync = function runAsync() {\n        var _this = this;\n        return _async_to_generator(function() {\n            var i2, plugin22, promise, error, root2, stack, promise1, e2, node2, _loop, _iterator, _step;\n            return _ts_generator(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        _this.plugin = 0;\n                        i2 = 0;\n                        _state.label = 1;\n                    case 1:\n                        if (!(i2 < _this.plugins.length)) return [\n                            3,\n                            6\n                        ];\n                        plugin22 = _this.plugins[i2];\n                        promise = _this.runOnRoot(plugin22);\n                        if (!isPromise(promise)) return [\n                            3,\n                            5\n                        ];\n                        _state.label = 2;\n                    case 2:\n                        _state.trys.push([\n                            2,\n                            4,\n                            ,\n                            5\n                        ]);\n                        return [\n                            4,\n                            promise\n                        ];\n                    case 3:\n                        _state.sent();\n                        return [\n                            3,\n                            5\n                        ];\n                    case 4:\n                        error = _state.sent();\n                        throw _this.handleError(error);\n                    case 5:\n                        i2++;\n                        return [\n                            3,\n                            1\n                        ];\n                    case 6:\n                        _this.prepareVisitors();\n                        if (!_this.hasListener) return [\n                            3,\n                            18\n                        ];\n                        root2 = _this.result.root;\n                        _state.label = 7;\n                    case 7:\n                        if (!!root2[isClean]) return [\n                            3,\n                            14\n                        ];\n                        root2[isClean] = true;\n                        stack = [\n                            toStack(root2)\n                        ];\n                        _state.label = 8;\n                    case 8:\n                        if (!(stack.length > 0)) return [\n                            3,\n                            13\n                        ];\n                        promise1 = _this.visitTick(stack);\n                        if (!isPromise(promise1)) return [\n                            3,\n                            12\n                        ];\n                        _state.label = 9;\n                    case 9:\n                        _state.trys.push([\n                            9,\n                            11,\n                            ,\n                            12\n                        ]);\n                        return [\n                            4,\n                            promise1\n                        ];\n                    case 10:\n                        _state.sent();\n                        return [\n                            3,\n                            12\n                        ];\n                    case 11:\n                        e2 = _state.sent();\n                        node2 = stack[stack.length - 1].node;\n                        throw _this.handleError(e2, node2);\n                    case 12:\n                        return [\n                            3,\n                            8\n                        ];\n                    case 13:\n                        return [\n                            3,\n                            7\n                        ];\n                    case 14:\n                        if (!_this.listeners.OnceExit) return [\n                            3,\n                            18\n                        ];\n                        _loop = function() {\n                            var _step_value, plugin22, visitor, roots, e2;\n                            return _ts_generator(this, function(_state) {\n                                switch(_state.label){\n                                    case 0:\n                                        _step_value = _step.value, plugin22 = _step_value[0], visitor = _step_value[1];\n                                        _this.result.lastPlugin = plugin22;\n                                        _state.label = 1;\n                                    case 1:\n                                        _state.trys.push([\n                                            1,\n                                            6,\n                                            ,\n                                            7\n                                        ]);\n                                        if (!(root2.type === \"document\")) return [\n                                            3,\n                                            3\n                                        ];\n                                        roots = root2.nodes.map(function(subRoot) {\n                                            return visitor(subRoot, _this.helpers);\n                                        });\n                                        return [\n                                            4,\n                                            Promise.all(roots)\n                                        ];\n                                    case 2:\n                                        _state.sent();\n                                        return [\n                                            3,\n                                            5\n                                        ];\n                                    case 3:\n                                        return [\n                                            4,\n                                            visitor(root2, _this.helpers)\n                                        ];\n                                    case 4:\n                                        _state.sent();\n                                        _state.label = 5;\n                                    case 5:\n                                        return [\n                                            3,\n                                            7\n                                        ];\n                                    case 6:\n                                        e2 = _state.sent();\n                                        throw _this.handleError(e2);\n                                    case 7:\n                                        return [\n                                            2\n                                        ];\n                                }\n                            });\n                        };\n                        _iterator = _create_for_of_iterator_helper_loose(_this.listeners.OnceExit);\n                        _state.label = 15;\n                    case 15:\n                        if (!!(_step = _iterator()).done) return [\n                            3,\n                            18\n                        ];\n                        return [\n                            5,\n                            _ts_values(_loop())\n                        ];\n                    case 16:\n                        _state.sent();\n                        _state.label = 17;\n                    case 17:\n                        return [\n                            3,\n                            15\n                        ];\n                    case 18:\n                        _this.processed = true;\n                        return [\n                            2,\n                            _this.stringify()\n                        ];\n                }\n            });\n        })();\n    };\n    _proto.runOnRoot = function runOnRoot(plugin22) {\n        var _this = this;\n        this.result.lastPlugin = plugin22;\n        try {\n            if ((typeof plugin22 === \"undefined\" ? \"undefined\" : _type_of(plugin22)) === \"object\" && plugin22.Once) {\n                if (this.result.root.type === \"document\") {\n                    var roots = this.result.root.nodes.map(function(root2) {\n                        return plugin22.Once(root2, _this.helpers);\n                    });\n                    if (isPromise(roots[0])) {\n                        return Promise.all(roots);\n                    }\n                    return roots;\n                }\n                return plugin22.Once(this.result.root, this.helpers);\n            } else if (typeof plugin22 === \"function\") {\n                return plugin22(this.result.root, this.result);\n            }\n        } catch (error) {\n            throw this.handleError(error);\n        }\n    };\n    _proto.stringify = function stringify() {\n        if (this.error) throw this.error;\n        if (this.stringified) return this.result;\n        this.stringified = true;\n        this.sync();\n        var opts = this.result.opts;\n        var str = stringify$2;\n        if (opts.syntax) str = opts.syntax.stringify;\n        if (opts.stringifier) str = opts.stringifier;\n        if (str.stringify) str = str.stringify;\n        var map = new MapGenerator$1(str, this.result.root, this.result.opts);\n        var data = map.generate();\n        this.result.css = data[0];\n        this.result.map = data[1];\n        return this.result;\n    };\n    _proto.sync = function sync() {\n        if (this.error) throw this.error;\n        if (this.processed) return this.result;\n        this.processed = true;\n        if (this.processing) {\n            throw this.getAsyncError();\n        }\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.plugins), _step; !(_step = _iterator()).done;){\n            var plugin22 = _step.value;\n            var promise = this.runOnRoot(plugin22);\n            if (isPromise(promise)) {\n                throw this.getAsyncError();\n            }\n        }\n        this.prepareVisitors();\n        if (this.hasListener) {\n            var root2 = this.result.root;\n            while(!root2[isClean]){\n                root2[isClean] = true;\n                this.walkSync(root2);\n            }\n            if (this.listeners.OnceExit) {\n                if (root2.type === \"document\") {\n                    for(var _iterator1 = _create_for_of_iterator_helper_loose(root2.nodes), _step1; !(_step1 = _iterator1()).done;){\n                        var subRoot = _step1.value;\n                        this.visitSync(this.listeners.OnceExit, subRoot);\n                    }\n                } else {\n                    this.visitSync(this.listeners.OnceExit, root2);\n                }\n            }\n        }\n        return this.result;\n    };\n    _proto.then = function then(onFulfilled, onRejected) {\n        if (true) {\n            if (!(\"from\" in this.opts)) {\n                warnOnce$1(\"Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.\");\n            }\n        }\n        return this.async().then(onFulfilled, onRejected);\n    };\n    _proto.toString = function toString() {\n        return this.css;\n    };\n    _proto.visitSync = function visitSync(visitors, node2) {\n        for(var _iterator = _create_for_of_iterator_helper_loose(visitors), _step; !(_step = _iterator()).done;){\n            var _step_value = _step.value, plugin22 = _step_value[0], visitor = _step_value[1];\n            this.result.lastPlugin = plugin22;\n            var promise = void 0;\n            try {\n                promise = visitor(node2, this.helpers);\n            } catch (e2) {\n                throw this.handleError(e2, node2.proxyOf);\n            }\n            if (node2.type !== \"root\" && node2.type !== \"document\" && !node2.parent) {\n                return true;\n            }\n            if (isPromise(promise)) {\n                throw this.getAsyncError();\n            }\n        }\n    };\n    _proto.visitTick = function visitTick(stack) {\n        var visit2 = stack[stack.length - 1];\n        var node2 = visit2.node, visitors = visit2.visitors;\n        if (node2.type !== \"root\" && node2.type !== \"document\" && !node2.parent) {\n            stack.pop();\n            return;\n        }\n        if (visitors.length > 0 && visit2.visitorIndex < visitors.length) {\n            var _visitors_visit2_visitorIndex = visitors[visit2.visitorIndex], plugin22 = _visitors_visit2_visitorIndex[0], visitor = _visitors_visit2_visitorIndex[1];\n            visit2.visitorIndex += 1;\n            if (visit2.visitorIndex === visitors.length) {\n                visit2.visitors = [];\n                visit2.visitorIndex = 0;\n            }\n            this.result.lastPlugin = plugin22;\n            try {\n                return visitor(node2.toProxy(), this.helpers);\n            } catch (e2) {\n                throw this.handleError(e2, node2);\n            }\n        }\n        if (visit2.iterator !== 0) {\n            var iterator = visit2.iterator;\n            var child;\n            while(child = node2.nodes[node2.indexes[iterator]]){\n                node2.indexes[iterator] += 1;\n                if (!child[isClean]) {\n                    child[isClean] = true;\n                    stack.push(toStack(child));\n                    return;\n                }\n            }\n            visit2.iterator = 0;\n            delete node2.indexes[iterator];\n        }\n        var events = visit2.events;\n        while(visit2.eventIndex < events.length){\n            var event = events[visit2.eventIndex];\n            visit2.eventIndex += 1;\n            if (event === CHILDREN) {\n                if (node2.nodes && node2.nodes.length) {\n                    node2[isClean] = true;\n                    visit2.iterator = node2.getIterator();\n                }\n                return;\n            } else if (this.listeners[event]) {\n                visit2.visitors = this.listeners[event];\n                return;\n            }\n        }\n        stack.pop();\n    };\n    _proto.walkSync = function walkSync(node2) {\n        var _this = this;\n        node2[isClean] = true;\n        var events = getEvents(node2);\n        for(var _iterator = _create_for_of_iterator_helper_loose(events), _step; !(_step = _iterator()).done;){\n            var event = _step.value;\n            if (event === CHILDREN) {\n                if (node2.nodes) {\n                    node2.each(function(child) {\n                        if (!child[isClean]) _this.walkSync(child);\n                    });\n                }\n            } else {\n                var visitors = this.listeners[event];\n                if (visitors) {\n                    if (this.visitSync(visitors, node2.toProxy())) return;\n                }\n            }\n        }\n    };\n    _proto.warnings = function warnings() {\n        return this.sync().warnings();\n    };\n    _create_class(LazyResult2, [\n        {\n            key: \"content\",\n            get: function get() {\n                return this.stringify().content;\n            }\n        },\n        {\n            key: \"css\",\n            get: function get() {\n                return this.stringify().css;\n            }\n        },\n        {\n            key: \"map\",\n            get: function get() {\n                return this.stringify().map;\n            }\n        },\n        {\n            key: \"messages\",\n            get: function get() {\n                return this.sync().messages;\n            }\n        },\n        {\n            key: \"opts\",\n            get: function get() {\n                return this.result.opts;\n            }\n        },\n        {\n            key: \"processor\",\n            get: function get() {\n                return this.result.processor;\n            }\n        },\n        {\n            key: \"root\",\n            get: function get() {\n                return this.sync().root;\n            }\n        },\n        {\n            key: Symbol.toStringTag,\n            get: function get() {\n                return \"LazyResult\";\n            }\n        }\n    ]);\n    return LazyResult2;\n}();\nLazyResult$2.registerPostcss = function(dependant) {\n    postcss$2 = dependant;\n};\nvar lazyResult = LazyResult$2;\nLazyResult$2.default = LazyResult$2;\nRoot$3.registerLazyResult(LazyResult$2);\nDocument$2.registerLazyResult(LazyResult$2);\nvar MapGenerator22 = mapGenerator;\nvar stringify$1 = stringify_1;\nvar warnOnce22 = warnOnce$2;\nvar parse$1 = parse_1;\nvar Result$1 = result;\nvar NoWorkResult$1 = /*#__PURE__*/ function() {\n    function NoWorkResult2(processor2, css, opts) {\n        css = css.toString();\n        this.stringified = false;\n        this._processor = processor2;\n        this._css = css;\n        this._opts = opts;\n        this._map = void 0;\n        var root2;\n        var str = stringify$1;\n        this.result = new Result$1(this._processor, root2, this._opts);\n        this.result.css = css;\n        var self = this;\n        Object.defineProperty(this.result, \"root\", {\n            get: function get() {\n                return self.root;\n            }\n        });\n        var map = new MapGenerator22(str, root2, this._opts, css);\n        if (map.isMap()) {\n            var _map_generate = map.generate(), generatedCSS = _map_generate[0], generatedMap = _map_generate[1];\n            if (generatedCSS) {\n                this.result.css = generatedCSS;\n            }\n            if (generatedMap) {\n                this.result.map = generatedMap;\n            }\n        } else {\n            map.clearAnnotation();\n            this.result.css = map.css;\n        }\n    }\n    var _proto = NoWorkResult2.prototype;\n    _proto.async = function async() {\n        if (this.error) return Promise.reject(this.error);\n        return Promise.resolve(this.result);\n    };\n    _proto.catch = function _catch(onRejected) {\n        return this.async().catch(onRejected);\n    };\n    _proto.finally = function _finally(onFinally) {\n        return this.async().then(onFinally, onFinally);\n    };\n    _proto.sync = function sync() {\n        if (this.error) throw this.error;\n        return this.result;\n    };\n    _proto.then = function then(onFulfilled, onRejected) {\n        if (true) {\n            if (!(\"from\" in this._opts)) {\n                warnOnce22(\"Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.\");\n            }\n        }\n        return this.async().then(onFulfilled, onRejected);\n    };\n    _proto.toString = function toString() {\n        return this._css;\n    };\n    _proto.warnings = function warnings() {\n        return [];\n    };\n    _create_class(NoWorkResult2, [\n        {\n            key: \"content\",\n            get: function get() {\n                return this.result.css;\n            }\n        },\n        {\n            key: \"css\",\n            get: function get() {\n                return this.result.css;\n            }\n        },\n        {\n            key: \"map\",\n            get: function get() {\n                return this.result.map;\n            }\n        },\n        {\n            key: \"messages\",\n            get: function get() {\n                return [];\n            }\n        },\n        {\n            key: \"opts\",\n            get: function get() {\n                return this.result.opts;\n            }\n        },\n        {\n            key: \"processor\",\n            get: function get() {\n                return this.result.processor;\n            }\n        },\n        {\n            key: \"root\",\n            get: function get() {\n                if (this._root) {\n                    return this._root;\n                }\n                var root2;\n                var parser2 = parse$1;\n                try {\n                    root2 = parser2(this._css, this._opts);\n                } catch (error) {\n                    this.error = error;\n                }\n                if (this.error) {\n                    throw this.error;\n                } else {\n                    this._root = root2;\n                    return root2;\n                }\n            }\n        },\n        {\n            key: Symbol.toStringTag,\n            get: function get() {\n                return \"NoWorkResult\";\n            }\n        }\n    ]);\n    return NoWorkResult2;\n}();\nvar noWorkResult = NoWorkResult$1;\nNoWorkResult$1.default = NoWorkResult$1;\nvar NoWorkResult22 = noWorkResult;\nvar LazyResult$1 = lazyResult;\nvar Document$1 = document$1$2;\nvar Root$2 = root;\nvar Processor$1 = /*#__PURE__*/ function() {\n    function Processor2(plugins) {\n        if (plugins === void 0) plugins = [];\n        this.version = \"8.4.38\";\n        this.plugins = this.normalize(plugins);\n    }\n    var _proto = Processor2.prototype;\n    _proto.normalize = function normalize(plugins) {\n        var normalized = [];\n        for(var _iterator = _create_for_of_iterator_helper_loose(plugins), _step; !(_step = _iterator()).done;){\n            var i2 = _step.value;\n            if (i2.postcss === true) {\n                i2 = i2();\n            } else if (i2.postcss) {\n                i2 = i2.postcss;\n            }\n            if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && Array.isArray(i2.plugins)) {\n                normalized = normalized.concat(i2.plugins);\n            } else if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && i2.postcssPlugin) {\n                normalized.push(i2);\n            } else if (typeof i2 === \"function\") {\n                normalized.push(i2);\n            } else if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && (i2.parse || i2.stringify)) {\n                if (true) {\n                    throw new Error(\"PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation.\");\n                }\n            } else {\n                throw new Error(i2 + \" is not a PostCSS plugin\");\n            }\n        }\n        return normalized;\n    };\n    _proto.process = function process1(css, opts) {\n        if (opts === void 0) opts = {};\n        if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) {\n            return new NoWorkResult22(this, css, opts);\n        } else {\n            return new LazyResult$1(this, css, opts);\n        }\n    };\n    _proto.use = function use(plugin22) {\n        this.plugins = this.plugins.concat(this.normalize([\n            plugin22\n        ]));\n        return this;\n    };\n    return Processor2;\n}();\nvar processor = Processor$1;\nProcessor$1.default = Processor$1;\nRoot$2.registerProcessor(Processor$1);\nDocument$1.registerProcessor(Processor$1);\nvar Declaration$1 = declaration;\nvar PreviousMap22 = previousMap;\nvar Comment$1 = comment;\nvar AtRule$1 = atRule;\nvar Input$1 = input;\nvar Root$1 = root;\nvar Rule$1 = rule;\nfunction fromJSON$1(json, inputs) {\n    if (Array.isArray(json)) return json.map(function(n2) {\n        return fromJSON$1(n2);\n    });\n    var ownInputs = json.inputs, defaults = _object_without_properties_loose(json, [\n        \"inputs\"\n    ]);\n    if (ownInputs) {\n        inputs = [];\n        for(var _iterator = _create_for_of_iterator_helper_loose(ownInputs), _step; !(_step = _iterator()).done;){\n            var input2 = _step.value;\n            var inputHydrated = _extends({}, input2, {\n                __proto__: Input$1.prototype\n            });\n            if (inputHydrated.map) {\n                inputHydrated.map = _extends({}, inputHydrated.map, {\n                    __proto__: PreviousMap22.prototype\n                });\n            }\n            inputs.push(inputHydrated);\n        }\n    }\n    if (defaults.nodes) {\n        defaults.nodes = json.nodes.map(function(n2) {\n            return fromJSON$1(n2, inputs);\n        });\n    }\n    if (defaults.source) {\n        var _defaults_source = defaults.source, inputId = _defaults_source.inputId, source = _object_without_properties_loose(_defaults_source, [\n            \"inputId\"\n        ]);\n        defaults.source = source;\n        if (inputId != null) {\n            defaults.source.input = inputs[inputId];\n        }\n    }\n    if (defaults.type === \"root\") {\n        return new Root$1(defaults);\n    } else if (defaults.type === \"decl\") {\n        return new Declaration$1(defaults);\n    } else if (defaults.type === \"rule\") {\n        return new Rule$1(defaults);\n    } else if (defaults.type === \"comment\") {\n        return new Comment$1(defaults);\n    } else if (defaults.type === \"atrule\") {\n        return new AtRule$1(defaults);\n    } else {\n        throw new Error(\"Unknown node type: \" + json.type);\n    }\n}\nvar fromJSON_1 = fromJSON$1;\nfromJSON$1.default = fromJSON$1;\nvar CssSyntaxError22 = cssSyntaxError;\nvar Declaration22 = declaration;\nvar LazyResult22 = lazyResult;\nvar Container22 = container;\nvar Processor22 = processor;\nvar stringify$6 = stringify_1;\nvar fromJSON = fromJSON_1;\nvar Document222 = document$1$2;\nvar Warning22 = warning;\nvar Comment22 = comment;\nvar AtRule22 = atRule;\nvar Result22 = result;\nvar Input22 = input;\nvar parse = parse_1;\nvar list = list_1;\nvar Rule22 = rule;\nvar Root22 = root;\nvar Node22 = node;\nfunction postcss() {\n    for(var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++){\n        plugins[_key] = arguments[_key];\n    }\n    if (plugins.length === 1 && Array.isArray(plugins[0])) {\n        plugins = plugins[0];\n    }\n    return new Processor22(plugins);\n}\npostcss.plugin = function plugin2(name, initializer) {\n    var warningPrinted = false;\n    function creator() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (console && console.warn && !warningPrinted) {\n            warningPrinted = true;\n            console.warn(name + \": postcss.plugin was deprecated. Migration guide:\\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration\");\n            if (process.env.LANG && process.env.LANG.startsWith(\"cn\")) {\n                console.warn(name + \":  postcss.plugin . :\\nhttps://www.w3ctech.com/topic/2226\");\n            }\n        }\n        var transformer = initializer.apply(void 0, [].concat(args));\n        transformer.postcssPlugin = name;\n        transformer.postcssVersion = new Processor22().version;\n        return transformer;\n    }\n    var cache;\n    Object.defineProperty(creator, \"postcss\", {\n        get: function get() {\n            if (!cache) cache = creator();\n            return cache;\n        }\n    });\n    creator.process = function(css, processOpts, pluginOpts) {\n        return postcss([\n            creator(pluginOpts)\n        ]).process(css, processOpts);\n    };\n    return creator;\n};\npostcss.stringify = stringify$6;\npostcss.parse = parse;\npostcss.fromJSON = fromJSON;\npostcss.list = list;\npostcss.comment = function(defaults) {\n    return new Comment22(defaults);\n};\npostcss.atRule = function(defaults) {\n    return new AtRule22(defaults);\n};\npostcss.decl = function(defaults) {\n    return new Declaration22(defaults);\n};\npostcss.rule = function(defaults) {\n    return new Rule22(defaults);\n};\npostcss.root = function(defaults) {\n    return new Root22(defaults);\n};\npostcss.document = function(defaults) {\n    return new Document222(defaults);\n};\npostcss.CssSyntaxError = CssSyntaxError22;\npostcss.Declaration = Declaration22;\npostcss.Container = Container22;\npostcss.Processor = Processor22;\npostcss.Document = Document222;\npostcss.Comment = Comment22;\npostcss.Warning = Warning22;\npostcss.AtRule = AtRule22;\npostcss.Result = Result22;\npostcss.Input = Input22;\npostcss.Rule = Rule22;\npostcss.Root = Root22;\npostcss.Node = Node22;\nLazyResult22.registerPostcss(postcss);\nvar postcss_1 = postcss;\npostcss.default = postcss;\nvar postcss$1 = /* @__PURE__ */ getDefaultExportFromCjs(postcss_1);\npostcss$1.stringify;\npostcss$1.fromJSON;\npostcss$1.plugin;\npostcss$1.parse;\npostcss$1.list;\npostcss$1.document;\npostcss$1.comment;\npostcss$1.atRule;\npostcss$1.rule;\npostcss$1.decl;\npostcss$1.root;\npostcss$1.CssSyntaxError;\npostcss$1.Declaration;\npostcss$1.Container;\npostcss$1.Processor;\npostcss$1.Document;\npostcss$1.Comment;\npostcss$1.Warning;\npostcss$1.AtRule;\npostcss$1.Result;\npostcss$1.Input;\npostcss$1.Rule;\npostcss$1.Root;\npostcss$1.Node;\nvar BaseRRNode = /*#__PURE__*/ function() {\n    function BaseRRNode() {\n        for(var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++){\n            _args[_key] = arguments[_key];\n        }\n        __publicField2(this, \"parentElement\", null);\n        __publicField2(this, \"parentNode\", null);\n        __publicField2(this, \"ownerDocument\");\n        __publicField2(this, \"firstChild\", null);\n        __publicField2(this, \"lastChild\", null);\n        __publicField2(this, \"previousSibling\", null);\n        __publicField2(this, \"nextSibling\", null);\n        __publicField2(this, \"ELEMENT_NODE\", 1);\n        __publicField2(this, \"TEXT_NODE\", 3);\n        __publicField2(this, \"nodeType\");\n        __publicField2(this, \"nodeName\");\n        __publicField2(this, \"RRNodeType\");\n    }\n    var _proto = BaseRRNode.prototype;\n    _proto.contains = function contains(node2) {\n        if (!_instanceof(node2, BaseRRNode)) return false;\n        else if (node2.ownerDocument !== this.ownerDocument) return false;\n        else if (node2 === this) return true;\n        while(node2.parentNode){\n            if (node2.parentNode === this) return true;\n            node2 = node2.parentNode;\n        }\n        return false;\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _proto.appendChild = function appendChild(_newChild) {\n        throw new Error(\"RRDomException: Failed to execute 'appendChild' on 'RRNode': This RRNode type does not support this method.\");\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _proto.insertBefore = function insertBefore(_newChild, _refChild) {\n        throw new Error(\"RRDomException: Failed to execute 'insertBefore' on 'RRNode': This RRNode type does not support this method.\");\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _proto.removeChild = function removeChild(_node) {\n        throw new Error(\"RRDomException: Failed to execute 'removeChild' on 'RRNode': This RRNode type does not support this method.\");\n    };\n    _proto.toString = function toString() {\n        return \"RRNode\";\n    };\n    _create_class(BaseRRNode, [\n        {\n            key: \"childNodes\",\n            get: function get() {\n                var childNodes2 = [];\n                var childIterator = this.firstChild;\n                while(childIterator){\n                    childNodes2.push(childIterator);\n                    childIterator = childIterator.nextSibling;\n                }\n                return childNodes2;\n            }\n        }\n    ]);\n    return BaseRRNode;\n}();\nvar testableAccessors = {\n    Node: [\n        \"childNodes\",\n        \"parentNode\",\n        \"parentElement\",\n        \"textContent\"\n    ],\n    ShadowRoot: [\n        \"host\",\n        \"styleSheets\"\n    ],\n    Element: [\n        \"shadowRoot\",\n        \"querySelector\",\n        \"querySelectorAll\"\n    ],\n    MutationObserver: []\n};\nvar testableMethods = {\n    Node: [\n        \"contains\",\n        \"getRootNode\"\n    ],\n    ShadowRoot: [\n        \"getSelection\"\n    ],\n    Element: [],\n    MutationObserver: [\n        \"constructor\"\n    ]\n};\nvar untaintedBasePrototype = {};\nvar isAngularZonePresent = function() {\n    return !!globalThis.Zone;\n};\nfunction getUntaintedPrototype(key) {\n    if (untaintedBasePrototype[key]) return untaintedBasePrototype[key];\n    var defaultObj = globalThis[key];\n    var defaultPrototype = defaultObj.prototype;\n    var accessorNames = key in testableAccessors ? testableAccessors[key] : void 0;\n    var isUntaintedAccessors = Boolean(accessorNames && // @ts-expect-error 2345\n    accessorNames.every(function(accessor) {\n        var _a2, _b;\n        return Boolean((_b = (_a2 = Object.getOwnPropertyDescriptor(defaultPrototype, accessor)) == null ? void 0 : _a2.get) == null ? void 0 : _b.toString().includes(\"[native code]\"));\n    }));\n    var methodNames = key in testableMethods ? testableMethods[key] : void 0;\n    var isUntaintedMethods = Boolean(methodNames && methodNames.every(// @ts-expect-error 2345\n    function(method) {\n        var _a2;\n        return typeof defaultPrototype[method] === \"function\" && ((_a2 = defaultPrototype[method]) == null ? void 0 : _a2.toString().includes(\"[native code]\"));\n    }));\n    if (isUntaintedAccessors && isUntaintedMethods && !isAngularZonePresent()) {\n        untaintedBasePrototype[key] = defaultObj.prototype;\n        return defaultObj.prototype;\n    }\n    try {\n        var iframeEl = document.createElement(\"iframe\");\n        document.body.appendChild(iframeEl);\n        var win = iframeEl.contentWindow;\n        if (!win) return defaultObj.prototype;\n        var untaintedObject = win[key].prototype;\n        document.body.removeChild(iframeEl);\n        if (!untaintedObject) return defaultPrototype;\n        return untaintedBasePrototype[key] = untaintedObject;\n    } catch (e) {\n        return defaultPrototype;\n    }\n}\nvar untaintedAccessorCache = {};\nfunction getUntaintedAccessor(key, instance, accessor) {\n    var _a2;\n    var cacheKey = key + \".\" + String(accessor);\n    if (untaintedAccessorCache[cacheKey]) return untaintedAccessorCache[cacheKey].call(instance);\n    var untaintedPrototype = getUntaintedPrototype(key);\n    var untaintedAccessor = (_a2 = Object.getOwnPropertyDescriptor(untaintedPrototype, accessor)) == null ? void 0 : _a2.get;\n    if (!untaintedAccessor) return instance[accessor];\n    untaintedAccessorCache[cacheKey] = untaintedAccessor;\n    return untaintedAccessor.call(instance);\n}\nvar untaintedMethodCache = {};\nfunction getUntaintedMethod(key, instance, method) {\n    var cacheKey = key + \".\" + String(method);\n    if (untaintedMethodCache[cacheKey]) return untaintedMethodCache[cacheKey].bind(instance);\n    var untaintedPrototype = getUntaintedPrototype(key);\n    var untaintedMethod = untaintedPrototype[method];\n    if (typeof untaintedMethod !== \"function\") return instance[method];\n    untaintedMethodCache[cacheKey] = untaintedMethod;\n    return untaintedMethod.bind(instance);\n}\nfunction childNodes(n2) {\n    return getUntaintedAccessor(\"Node\", n2, \"childNodes\");\n}\nfunction parentNode(n2) {\n    return getUntaintedAccessor(\"Node\", n2, \"parentNode\");\n}\nfunction parentElement(n2) {\n    return getUntaintedAccessor(\"Node\", n2, \"parentElement\");\n}\nfunction textContent(n2) {\n    return getUntaintedAccessor(\"Node\", n2, \"textContent\");\n}\nfunction contains(n2, other) {\n    return getUntaintedMethod(\"Node\", n2, \"contains\")(other);\n}\nfunction getRootNode(n2) {\n    return getUntaintedMethod(\"Node\", n2, \"getRootNode\")();\n}\nfunction host(n2) {\n    if (!n2 || !(\"host\" in n2)) return null;\n    return getUntaintedAccessor(\"ShadowRoot\", n2, \"host\");\n}\nfunction styleSheets(n2) {\n    return n2.styleSheets;\n}\nfunction shadowRoot(n2) {\n    if (!n2 || !(\"shadowRoot\" in n2)) return null;\n    return getUntaintedAccessor(\"Element\", n2, \"shadowRoot\");\n}\nfunction querySelector(n2, selectors) {\n    return getUntaintedAccessor(\"Element\", n2, \"querySelector\")(selectors);\n}\nfunction querySelectorAll(n2, selectors) {\n    return getUntaintedAccessor(\"Element\", n2, \"querySelectorAll\")(selectors);\n}\nfunction mutationObserverCtor() {\n    return getUntaintedPrototype(\"MutationObserver\").constructor;\n}\nfunction patch$2(source, name, replacement) {\n    try {\n        if (!(name in source)) {\n            return function() {};\n        }\n        var original = source[name];\n        var wrapped = replacement(original);\n        if (typeof wrapped === \"function\") {\n            wrapped.prototype = wrapped.prototype || {};\n            Object.defineProperties(wrapped, {\n                __rrweb_original__: {\n                    enumerable: false,\n                    value: original\n                }\n            });\n        }\n        source[name] = wrapped;\n        return function() {\n            source[name] = original;\n        };\n    } catch (e) {\n        return function() {};\n    }\n}\nvar index = {\n    childNodes: childNodes,\n    parentNode: parentNode,\n    parentElement: parentElement,\n    textContent: textContent,\n    contains: contains,\n    getRootNode: getRootNode,\n    host: host,\n    styleSheets: styleSheets,\n    shadowRoot: shadowRoot,\n    querySelector: querySelector,\n    querySelectorAll: querySelectorAll,\n    mutationObserver: mutationObserverCtor,\n    patch: patch$2\n};\nfunction on(type, fn, target) {\n    if (target === void 0) target = document;\n    var options = {\n        capture: true,\n        passive: true\n    };\n    target.addEventListener(type, fn, options);\n    return function() {\n        return target.removeEventListener(type, fn, options);\n    };\n}\nvar DEPARTED_MIRROR_ACCESS_WARNING = \"Please stop import mirror directly. Instead of that,\\r\\nnow you can use replayer.getMirror() to access the mirror instance of a replayer,\\r\\nor you can use record.mirror to access the mirror instance during recording.\";\nvar _mirror = {\n    map: {},\n    getId: function getId() {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n        return -1;\n    },\n    getNode: function getNode() {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n        return null;\n    },\n    removeNodeFromMap: function removeNodeFromMap() {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    },\n    has: function has() {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n        return false;\n    },\n    reset: function reset() {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    }\n};\nif (typeof window !== \"undefined\" && window.Proxy && window.Reflect) {\n    _mirror = new Proxy(_mirror, {\n        get: function get(target, prop, receiver) {\n            if (prop === \"map\") {\n                console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n            }\n            return Reflect.get(target, prop, receiver);\n        }\n    });\n}\nfunction throttle(func, wait, options) {\n    if (options === void 0) options = {};\n    var timeout = null;\n    var previous = 0;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        var now = Date.now();\n        if (!previous && options.leading === false) {\n            previous = now;\n        }\n        var remaining = wait - (now - previous);\n        var context = this;\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            func.apply(context, args);\n        } else if (!timeout && options.trailing !== false) {\n            timeout = setTimeout(function() {\n                previous = options.leading === false ? 0 : Date.now();\n                timeout = null;\n                func.apply(context, args);\n            }, remaining);\n        }\n    };\n}\nfunction hookSetter(target, key, d, isRevoked, win) {\n    if (win === void 0) win = window;\n    var original = win.Object.getOwnPropertyDescriptor(target, key);\n    win.Object.defineProperty(target, key, isRevoked ? d : {\n        set: function set(value) {\n            var _this = this;\n            setTimeout(function() {\n                d.set.call(_this, value);\n            }, 0);\n            if (original && original.set) {\n                original.set.call(this, value);\n            }\n        }\n    });\n    return function() {\n        return hookSetter(target, key, original || {}, true);\n    };\n}\nvar nowTimestamp = Date.now;\nif (!/* @__PURE__ */ /[1-9][0-9]{12}/.test(Date.now().toString())) {\n    nowTimestamp = function() {\n        return /* @__PURE__ */ new Date().getTime();\n    };\n}\nfunction getWindowScroll(win) {\n    var _a2, _b, _c, _d;\n    var doc = win.document;\n    return {\n        left: doc.scrollingElement ? doc.scrollingElement.scrollLeft : win.pageXOffset !== void 0 ? win.pageXOffset : doc.documentElement.scrollLeft || (doc == null ? void 0 : doc.body) && ((_a2 = index.parentElement(doc.body)) == null ? void 0 : _a2.scrollLeft) || ((_b = doc == null ? void 0 : doc.body) == null ? void 0 : _b.scrollLeft) || 0,\n        top: doc.scrollingElement ? doc.scrollingElement.scrollTop : win.pageYOffset !== void 0 ? win.pageYOffset : (doc == null ? void 0 : doc.documentElement.scrollTop) || (doc == null ? void 0 : doc.body) && ((_c = index.parentElement(doc.body)) == null ? void 0 : _c.scrollTop) || ((_d = doc == null ? void 0 : doc.body) == null ? void 0 : _d.scrollTop) || 0\n    };\n}\nfunction getWindowHeight() {\n    return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight;\n}\nfunction getWindowWidth() {\n    return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth;\n}\nfunction closestElementOfNode(node2) {\n    if (!node2) {\n        return null;\n    }\n    var el = node2.nodeType === node2.ELEMENT_NODE ? node2 : index.parentElement(node2);\n    return el;\n}\nfunction isBlocked(node2, blockClass, blockSelector, checkAncestors) {\n    if (!node2) {\n        return false;\n    }\n    var el = closestElementOfNode(node2);\n    if (!el) {\n        return false;\n    }\n    try {\n        if (typeof blockClass === \"string\") {\n            if (el.classList.contains(blockClass)) return true;\n            if (checkAncestors && el.closest(\".\" + blockClass) !== null) return true;\n        } else {\n            if (classMatchesRegex(el, blockClass, checkAncestors)) return true;\n        }\n    } catch (e2) {}\n    if (blockSelector) {\n        if (el.matches(blockSelector)) return true;\n        if (checkAncestors && el.closest(blockSelector) !== null) return true;\n    }\n    return false;\n}\nfunction isSerialized(n2, mirror2) {\n    return mirror2.getId(n2) !== -1;\n}\nfunction isIgnored(n2, mirror2, slimDOMOptions) {\n    if (n2.tagName === \"TITLE\" && slimDOMOptions.headTitleMutations) {\n        return true;\n    }\n    return mirror2.getId(n2) === IGNORED_NODE;\n}\nfunction isAncestorRemoved(target, mirror2) {\n    if (isShadowRoot(target)) {\n        return false;\n    }\n    var id = mirror2.getId(target);\n    if (!mirror2.has(id)) {\n        return true;\n    }\n    var parent = index.parentNode(target);\n    if (parent && parent.nodeType === target.DOCUMENT_NODE) {\n        return false;\n    }\n    if (!parent) {\n        return true;\n    }\n    return isAncestorRemoved(parent, mirror2);\n}\nfunction legacy_isTouchEvent(event) {\n    return Boolean(event.changedTouches);\n}\nfunction polyfill$1(win) {\n    if (win === void 0) win = window;\n    if (\"NodeList\" in win && !win.NodeList.prototype.forEach) {\n        win.NodeList.prototype.forEach = Array.prototype.forEach;\n    }\n    if (\"DOMTokenList\" in win && !win.DOMTokenList.prototype.forEach) {\n        win.DOMTokenList.prototype.forEach = Array.prototype.forEach;\n    }\n}\nfunction isSerializedIframe(n2, mirror2) {\n    return Boolean(n2.nodeName === \"IFRAME\" && mirror2.getMeta(n2));\n}\nfunction isSerializedStylesheet(n2, mirror2) {\n    return Boolean(n2.nodeName === \"LINK\" && n2.nodeType === n2.ELEMENT_NODE && n2.getAttribute && n2.getAttribute(\"rel\") === \"stylesheet\" && mirror2.getMeta(n2));\n}\nfunction hasShadowRoot(n2) {\n    if (!n2) return false;\n    if (_instanceof(n2, BaseRRNode) && \"shadowRoot\" in n2) {\n        return Boolean(n2.shadowRoot);\n    }\n    return Boolean(index.shadowRoot(n2));\n}\nvar StyleSheetMirror = /*#__PURE__*/ function() {\n    function StyleSheetMirror() {\n        __publicField$1(this, \"id\", 1);\n        __publicField$1(this, \"styleIDMap\", /* @__PURE__ */ new WeakMap());\n        __publicField$1(this, \"idStyleMap\", /* @__PURE__ */ new Map());\n    }\n    var _proto = StyleSheetMirror.prototype;\n    _proto.getId = function getId(stylesheet) {\n        var _this_styleIDMap_get;\n        return (_this_styleIDMap_get = this.styleIDMap.get(stylesheet)) != null ? _this_styleIDMap_get : -1;\n    };\n    _proto.has = function has(stylesheet) {\n        return this.styleIDMap.has(stylesheet);\n    };\n    /**\n   * @returns If the stylesheet is in the mirror, returns the id of the stylesheet. If not, return the new assigned id.\n   */ _proto.add = function add(stylesheet, id) {\n        if (this.has(stylesheet)) return this.getId(stylesheet);\n        var newId;\n        if (id === void 0) {\n            newId = this.id++;\n        } else newId = id;\n        this.styleIDMap.set(stylesheet, newId);\n        this.idStyleMap.set(newId, stylesheet);\n        return newId;\n    };\n    _proto.getStyle = function getStyle(id) {\n        return this.idStyleMap.get(id) || null;\n    };\n    _proto.reset = function reset() {\n        this.styleIDMap = /* @__PURE__ */ new WeakMap();\n        this.idStyleMap = /* @__PURE__ */ new Map();\n        this.id = 1;\n    };\n    _proto.generateId = function generateId() {\n        return this.id++;\n    };\n    return StyleSheetMirror;\n}();\nfunction getShadowHost(n2) {\n    var _a2;\n    var shadowHost = null;\n    if (\"getRootNode\" in n2 && ((_a2 = index.getRootNode(n2)) == null ? void 0 : _a2.nodeType) === Node.DOCUMENT_FRAGMENT_NODE && index.host(index.getRootNode(n2))) shadowHost = index.host(index.getRootNode(n2));\n    return shadowHost;\n}\nfunction getRootShadowHost(n2) {\n    var rootShadowHost = n2;\n    var shadowHost;\n    while(shadowHost = getShadowHost(rootShadowHost))rootShadowHost = shadowHost;\n    return rootShadowHost;\n}\nfunction shadowHostInDom(n2) {\n    var doc = n2.ownerDocument;\n    if (!doc) return false;\n    var shadowHost = getRootShadowHost(n2);\n    return index.contains(doc, shadowHost);\n}\nfunction inDom(n2) {\n    var doc = n2.ownerDocument;\n    if (!doc) return false;\n    return index.contains(doc, n2) || shadowHostInDom(n2);\n}\nvar EventType = /* @__PURE__ */ function(EventType2) {\n    EventType2[EventType2[\"DomContentLoaded\"] = 0] = \"DomContentLoaded\";\n    EventType2[EventType2[\"Load\"] = 1] = \"Load\";\n    EventType2[EventType2[\"FullSnapshot\"] = 2] = \"FullSnapshot\";\n    EventType2[EventType2[\"IncrementalSnapshot\"] = 3] = \"IncrementalSnapshot\";\n    EventType2[EventType2[\"Meta\"] = 4] = \"Meta\";\n    EventType2[EventType2[\"Custom\"] = 5] = \"Custom\";\n    EventType2[EventType2[\"Plugin\"] = 6] = \"Plugin\";\n    return EventType2;\n}(EventType || {});\nvar IncrementalSource = /* @__PURE__ */ function(IncrementalSource2) {\n    IncrementalSource2[IncrementalSource2[\"Mutation\"] = 0] = \"Mutation\";\n    IncrementalSource2[IncrementalSource2[\"MouseMove\"] = 1] = \"MouseMove\";\n    IncrementalSource2[IncrementalSource2[\"MouseInteraction\"] = 2] = \"MouseInteraction\";\n    IncrementalSource2[IncrementalSource2[\"Scroll\"] = 3] = \"Scroll\";\n    IncrementalSource2[IncrementalSource2[\"ViewportResize\"] = 4] = \"ViewportResize\";\n    IncrementalSource2[IncrementalSource2[\"Input\"] = 5] = \"Input\";\n    IncrementalSource2[IncrementalSource2[\"TouchMove\"] = 6] = \"TouchMove\";\n    IncrementalSource2[IncrementalSource2[\"MediaInteraction\"] = 7] = \"MediaInteraction\";\n    IncrementalSource2[IncrementalSource2[\"StyleSheetRule\"] = 8] = \"StyleSheetRule\";\n    IncrementalSource2[IncrementalSource2[\"CanvasMutation\"] = 9] = \"CanvasMutation\";\n    IncrementalSource2[IncrementalSource2[\"Font\"] = 10] = \"Font\";\n    IncrementalSource2[IncrementalSource2[\"Log\"] = 11] = \"Log\";\n    IncrementalSource2[IncrementalSource2[\"Drag\"] = 12] = \"Drag\";\n    IncrementalSource2[IncrementalSource2[\"StyleDeclaration\"] = 13] = \"StyleDeclaration\";\n    IncrementalSource2[IncrementalSource2[\"Selection\"] = 14] = \"Selection\";\n    IncrementalSource2[IncrementalSource2[\"AdoptedStyleSheet\"] = 15] = \"AdoptedStyleSheet\";\n    IncrementalSource2[IncrementalSource2[\"CustomElement\"] = 16] = \"CustomElement\";\n    return IncrementalSource2;\n}(IncrementalSource || {});\nvar MouseInteractions = /* @__PURE__ */ function(MouseInteractions2) {\n    MouseInteractions2[MouseInteractions2[\"MouseUp\"] = 0] = \"MouseUp\";\n    MouseInteractions2[MouseInteractions2[\"MouseDown\"] = 1] = \"MouseDown\";\n    MouseInteractions2[MouseInteractions2[\"Click\"] = 2] = \"Click\";\n    MouseInteractions2[MouseInteractions2[\"ContextMenu\"] = 3] = \"ContextMenu\";\n    MouseInteractions2[MouseInteractions2[\"DblClick\"] = 4] = \"DblClick\";\n    MouseInteractions2[MouseInteractions2[\"Focus\"] = 5] = \"Focus\";\n    MouseInteractions2[MouseInteractions2[\"Blur\"] = 6] = \"Blur\";\n    MouseInteractions2[MouseInteractions2[\"TouchStart\"] = 7] = \"TouchStart\";\n    MouseInteractions2[MouseInteractions2[\"TouchMove_Departed\"] = 8] = \"TouchMove_Departed\";\n    MouseInteractions2[MouseInteractions2[\"TouchEnd\"] = 9] = \"TouchEnd\";\n    MouseInteractions2[MouseInteractions2[\"TouchCancel\"] = 10] = \"TouchCancel\";\n    return MouseInteractions2;\n}(MouseInteractions || {});\nvar PointerTypes = /* @__PURE__ */ function(PointerTypes2) {\n    PointerTypes2[PointerTypes2[\"Mouse\"] = 0] = \"Mouse\";\n    PointerTypes2[PointerTypes2[\"Pen\"] = 1] = \"Pen\";\n    PointerTypes2[PointerTypes2[\"Touch\"] = 2] = \"Touch\";\n    return PointerTypes2;\n}(PointerTypes || {});\nvar CanvasContext = /* @__PURE__ */ function(CanvasContext2) {\n    CanvasContext2[CanvasContext2[\"2D\"] = 0] = \"2D\";\n    CanvasContext2[CanvasContext2[\"WebGL\"] = 1] = \"WebGL\";\n    CanvasContext2[CanvasContext2[\"WebGL2\"] = 2] = \"WebGL2\";\n    return CanvasContext2;\n}(CanvasContext || {});\nvar MediaInteractions = /* @__PURE__ */ function(MediaInteractions2) {\n    MediaInteractions2[MediaInteractions2[\"Play\"] = 0] = \"Play\";\n    MediaInteractions2[MediaInteractions2[\"Pause\"] = 1] = \"Pause\";\n    MediaInteractions2[MediaInteractions2[\"Seeked\"] = 2] = \"Seeked\";\n    MediaInteractions2[MediaInteractions2[\"VolumeChange\"] = 3] = \"VolumeChange\";\n    MediaInteractions2[MediaInteractions2[\"RateChange\"] = 4] = \"RateChange\";\n    return MediaInteractions2;\n}(MediaInteractions || {});\nvar NodeType = /* @__PURE__ */ function(NodeType2) {\n    NodeType2[NodeType2[\"Document\"] = 0] = \"Document\";\n    NodeType2[NodeType2[\"DocumentType\"] = 1] = \"DocumentType\";\n    NodeType2[NodeType2[\"Element\"] = 2] = \"Element\";\n    NodeType2[NodeType2[\"Text\"] = 3] = \"Text\";\n    NodeType2[NodeType2[\"CDATA\"] = 4] = \"CDATA\";\n    NodeType2[NodeType2[\"Comment\"] = 5] = \"Comment\";\n    return NodeType2;\n}(NodeType || {});\nfunction isNodeInLinkedList(n2) {\n    return \"__ln\" in n2;\n}\nvar DoubleLinkedList = /*#__PURE__*/ function() {\n    function DoubleLinkedList() {\n        __publicField$1(this, \"length\", 0);\n        __publicField$1(this, \"head\", null);\n        __publicField$1(this, \"tail\", null);\n    }\n    var _proto = DoubleLinkedList.prototype;\n    _proto.get = function get(position) {\n        if (position >= this.length) {\n            throw new Error(\"Position outside of list range\");\n        }\n        var current = this.head;\n        for(var index2 = 0; index2 < position; index2++){\n            current = (current == null ? void 0 : current.next) || null;\n        }\n        return current;\n    };\n    _proto.addNode = function addNode(n2) {\n        var node2 = {\n            value: n2,\n            previous: null,\n            next: null\n        };\n        n2.__ln = node2;\n        if (n2.previousSibling && isNodeInLinkedList(n2.previousSibling)) {\n            var current = n2.previousSibling.__ln.next;\n            node2.next = current;\n            node2.previous = n2.previousSibling.__ln;\n            n2.previousSibling.__ln.next = node2;\n            if (current) {\n                current.previous = node2;\n            }\n        } else if (n2.nextSibling && isNodeInLinkedList(n2.nextSibling) && n2.nextSibling.__ln.previous) {\n            var current1 = n2.nextSibling.__ln.previous;\n            node2.previous = current1;\n            node2.next = n2.nextSibling.__ln;\n            n2.nextSibling.__ln.previous = node2;\n            if (current1) {\n                current1.next = node2;\n            }\n        } else {\n            if (this.head) {\n                this.head.previous = node2;\n            }\n            node2.next = this.head;\n            this.head = node2;\n        }\n        if (node2.next === null) {\n            this.tail = node2;\n        }\n        this.length++;\n    };\n    _proto.removeNode = function removeNode(n2) {\n        var current = n2.__ln;\n        if (!this.head) {\n            return;\n        }\n        if (!current.previous) {\n            this.head = current.next;\n            if (this.head) {\n                this.head.previous = null;\n            } else {\n                this.tail = null;\n            }\n        } else {\n            current.previous.next = current.next;\n            if (current.next) {\n                current.next.previous = current.previous;\n            } else {\n                this.tail = current.previous;\n            }\n        }\n        if (n2.__ln) {\n            delete n2.__ln;\n        }\n        this.length--;\n    };\n    return DoubleLinkedList;\n}();\nvar moveKey = function(id, parentId) {\n    return id + \"@\" + parentId;\n};\nvar MutationBuffer = /*#__PURE__*/ function() {\n    function MutationBuffer() {\n        var _this = this;\n        __publicField$1(this, \"frozen\", false);\n        __publicField$1(this, \"locked\", false);\n        __publicField$1(this, \"texts\", []);\n        __publicField$1(this, \"attributes\", []);\n        __publicField$1(this, \"attributeMap\", /* @__PURE__ */ new WeakMap());\n        __publicField$1(this, \"removes\", []);\n        __publicField$1(this, \"mapRemoves\", []);\n        __publicField$1(this, \"movedMap\", {});\n        /**\n     * the browser MutationObserver emits multiple mutations after\n     * a delay for performance reasons, making tracing added nodes hard\n     * in our `processMutations` callback function.\n     * For example, if we append an element el_1 into body, and then append\n     * another element el_2 into el_1, these two mutations may be passed to the\n     * callback function together when the two operations were done.\n     * Generally we need to trace child nodes of newly added nodes, but in this\n     * case if we count el_2 as el_1's child node in the first mutation record,\n     * then we will count el_2 again in the second mutation record which was\n     * duplicated.\n     * To avoid of duplicate counting added nodes, we use a Set to store\n     * added nodes and its child nodes during iterate mutation records. Then\n     * collect added nodes from the Set which have no duplicate copy. But\n     * this also causes newly added nodes will not be serialized with id ASAP,\n     * which means all the id related calculation should be lazy too.\n     */ __publicField$1(this, \"addedSet\", /* @__PURE__ */ new Set());\n        __publicField$1(this, \"movedSet\", /* @__PURE__ */ new Set());\n        __publicField$1(this, \"droppedSet\", /* @__PURE__ */ new Set());\n        __publicField$1(this, \"removesSubTreeCache\", /* @__PURE__ */ new Set());\n        __publicField$1(this, \"mutationCb\");\n        __publicField$1(this, \"blockClass\");\n        __publicField$1(this, \"blockSelector\");\n        __publicField$1(this, \"maskTextClass\");\n        __publicField$1(this, \"maskTextSelector\");\n        __publicField$1(this, \"inlineStylesheet\");\n        __publicField$1(this, \"maskInputOptions\");\n        __publicField$1(this, \"maskTextFn\");\n        __publicField$1(this, \"maskInputFn\");\n        __publicField$1(this, \"keepIframeSrcFn\");\n        __publicField$1(this, \"recordCanvas\");\n        __publicField$1(this, \"inlineImages\");\n        __publicField$1(this, \"slimDOMOptions\");\n        __publicField$1(this, \"dataURLOptions\");\n        __publicField$1(this, \"doc\");\n        __publicField$1(this, \"mirror\");\n        __publicField$1(this, \"iframeManager\");\n        __publicField$1(this, \"stylesheetManager\");\n        __publicField$1(this, \"shadowDomManager\");\n        __publicField$1(this, \"canvasManager\");\n        __publicField$1(this, \"processedNodeManager\");\n        __publicField$1(this, \"unattachedDoc\");\n        __publicField$1(this, \"processMutations\", function(mutations) {\n            mutations.forEach(_this.processMutation);\n            _this.emit();\n        });\n        __publicField$1(this, \"emit\", function() {\n            if (_this.frozen || _this.locked) {\n                return;\n            }\n            var adds = [];\n            var addedIds = /* @__PURE__ */ new Set();\n            var addList = new DoubleLinkedList();\n            var getNextId = function(n2) {\n                var ns = n2;\n                var nextId = IGNORED_NODE;\n                while(nextId === IGNORED_NODE){\n                    ns = ns && ns.nextSibling;\n                    nextId = ns && _this.mirror.getId(ns);\n                }\n                return nextId;\n            };\n            var pushAdd = function(n2) {\n                var parent = index.parentNode(n2);\n                if (!parent || !inDom(n2)) {\n                    return;\n                }\n                var cssCaptured = false;\n                if (n2.nodeType === Node.TEXT_NODE) {\n                    var parentTag = parent.tagName;\n                    if (parentTag === \"TEXTAREA\") {\n                        return;\n                    } else if (parentTag === \"STYLE\" && _this.addedSet.has(parent)) {\n                        cssCaptured = true;\n                    }\n                }\n                var parentId = isShadowRoot(parent) ? _this.mirror.getId(getShadowHost(n2)) : _this.mirror.getId(parent);\n                var nextId = getNextId(n2);\n                if (parentId === -1 || nextId === -1) {\n                    return addList.addNode(n2);\n                }\n                var sn = serializeNodeWithId(n2, {\n                    doc: _this.doc,\n                    mirror: _this.mirror,\n                    blockClass: _this.blockClass,\n                    blockSelector: _this.blockSelector,\n                    maskTextClass: _this.maskTextClass,\n                    maskTextSelector: _this.maskTextSelector,\n                    skipChild: true,\n                    newlyAddedElement: true,\n                    inlineStylesheet: _this.inlineStylesheet,\n                    maskInputOptions: _this.maskInputOptions,\n                    maskTextFn: _this.maskTextFn,\n                    maskInputFn: _this.maskInputFn,\n                    slimDOMOptions: _this.slimDOMOptions,\n                    dataURLOptions: _this.dataURLOptions,\n                    recordCanvas: _this.recordCanvas,\n                    inlineImages: _this.inlineImages,\n                    onSerialize: function(currentN) {\n                        if (isSerializedIframe(currentN, _this.mirror)) {\n                            _this.iframeManager.addIframe(currentN);\n                        }\n                        if (isSerializedStylesheet(currentN, _this.mirror)) {\n                            _this.stylesheetManager.trackLinkElement(currentN);\n                        }\n                        if (hasShadowRoot(n2)) {\n                            _this.shadowDomManager.addShadowRoot(index.shadowRoot(n2), _this.doc);\n                        }\n                    },\n                    onIframeLoad: function(iframe, childSn) {\n                        _this.iframeManager.attachIframe(iframe, childSn);\n                        _this.shadowDomManager.observeAttachShadow(iframe);\n                    },\n                    onStylesheetLoad: function(link, childSn) {\n                        _this.stylesheetManager.attachLinkElement(link, childSn);\n                    },\n                    cssCaptured: cssCaptured\n                });\n                if (sn) {\n                    adds.push({\n                        parentId: parentId,\n                        nextId: nextId,\n                        node: sn\n                    });\n                    addedIds.add(sn.id);\n                }\n            };\n            while(_this.mapRemoves.length){\n                _this.mirror.removeNodeFromMap(_this.mapRemoves.shift());\n            }\n            for(var _iterator = _create_for_of_iterator_helper_loose(_this.movedSet), _step; !(_step = _iterator()).done;){\n                var n2 = _step.value;\n                if (isParentRemoved(_this.removesSubTreeCache, n2, _this.mirror) && !_this.movedSet.has(index.parentNode(n2))) {\n                    continue;\n                }\n                pushAdd(n2);\n            }\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(_this.addedSet), _step1; !(_step1 = _iterator1()).done;){\n                var n21 = _step1.value;\n                if (!isAncestorInSet(_this.droppedSet, n21) && !isParentRemoved(_this.removesSubTreeCache, n21, _this.mirror)) {\n                    pushAdd(n21);\n                } else if (isAncestorInSet(_this.movedSet, n21)) {\n                    pushAdd(n21);\n                } else {\n                    _this.droppedSet.add(n21);\n                }\n            }\n            var candidate = null;\n            while(addList.length){\n                var node2 = null;\n                if (candidate) {\n                    var parentId = _this.mirror.getId(index.parentNode(candidate.value));\n                    var nextId = getNextId(candidate.value);\n                    if (parentId !== -1 && nextId !== -1) {\n                        node2 = candidate;\n                    }\n                }\n                if (!node2) {\n                    var tailNode = addList.tail;\n                    while(tailNode){\n                        var _node = tailNode;\n                        tailNode = tailNode.previous;\n                        if (_node) {\n                            var parentId1 = _this.mirror.getId(index.parentNode(_node.value));\n                            var nextId1 = getNextId(_node.value);\n                            if (nextId1 === -1) continue;\n                            else if (parentId1 !== -1) {\n                                node2 = _node;\n                                break;\n                            } else {\n                                var unhandledNode = _node.value;\n                                var parent = index.parentNode(unhandledNode);\n                                if (parent && parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n                                    var shadowHost = index.host(parent);\n                                    var parentId2 = _this.mirror.getId(shadowHost);\n                                    if (parentId2 !== -1) {\n                                        node2 = _node;\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!node2) {\n                    while(addList.head){\n                        addList.removeNode(addList.head.value);\n                    }\n                    break;\n                }\n                candidate = node2.previous;\n                addList.removeNode(node2.value);\n                pushAdd(node2.value);\n            }\n            var payload = {\n                texts: _this.texts.map(function(text) {\n                    var n2 = text.node;\n                    var parent = index.parentNode(n2);\n                    if (parent && parent.tagName === \"TEXTAREA\") {\n                        _this.genTextAreaValueMutation(parent);\n                    }\n                    return {\n                        id: _this.mirror.getId(n2),\n                        value: text.value\n                    };\n                }).filter(function(text) {\n                    return !addedIds.has(text.id);\n                }).filter(function(text) {\n                    return _this.mirror.has(text.id);\n                }),\n                attributes: _this.attributes.map(function(attribute) {\n                    var attributes = attribute.attributes;\n                    if (typeof attributes.style === \"string\") {\n                        var diffAsStr = JSON.stringify(attribute.styleDiff);\n                        var unchangedAsStr = JSON.stringify(attribute._unchangedStyles);\n                        if (diffAsStr.length < attributes.style.length) {\n                            if ((diffAsStr + unchangedAsStr).split(\"var(\").length === attributes.style.split(\"var(\").length) {\n                                attributes.style = attribute.styleDiff;\n                            }\n                        }\n                    }\n                    return {\n                        id: _this.mirror.getId(attribute.node),\n                        attributes: attributes\n                    };\n                }).filter(function(attribute) {\n                    return !addedIds.has(attribute.id);\n                }).filter(function(attribute) {\n                    return _this.mirror.has(attribute.id);\n                }),\n                removes: _this.removes,\n                adds: adds\n            };\n            if (!payload.texts.length && !payload.attributes.length && !payload.removes.length && !payload.adds.length) {\n                return;\n            }\n            _this.texts = [];\n            _this.attributes = [];\n            _this.attributeMap = /* @__PURE__ */ new WeakMap();\n            _this.removes = [];\n            _this.addedSet = /* @__PURE__ */ new Set();\n            _this.movedSet = /* @__PURE__ */ new Set();\n            _this.droppedSet = /* @__PURE__ */ new Set();\n            _this.removesSubTreeCache = /* @__PURE__ */ new Set();\n            _this.movedMap = {};\n            _this.mutationCb(payload);\n        });\n        __publicField$1(this, \"genTextAreaValueMutation\", function(textarea) {\n            var item = _this.attributeMap.get(textarea);\n            if (!item) {\n                item = {\n                    node: textarea,\n                    attributes: {},\n                    styleDiff: {},\n                    _unchangedStyles: {}\n                };\n                _this.attributes.push(item);\n                _this.attributeMap.set(textarea, item);\n            }\n            var value = Array.from(index.childNodes(textarea), function(cn) {\n                return index.textContent(cn) || \"\";\n            }).join(\"\");\n            item.attributes.value = maskInputValue({\n                element: textarea,\n                maskInputOptions: _this.maskInputOptions,\n                tagName: textarea.tagName,\n                type: getInputType(textarea),\n                value: value,\n                maskInputFn: _this.maskInputFn\n            });\n        });\n        __publicField$1(this, \"processMutation\", function(m) {\n            if (isIgnored(m.target, _this.mirror, _this.slimDOMOptions)) {\n                return;\n            }\n            switch(m.type){\n                case \"characterData\":\n                    {\n                        var value = index.textContent(m.target);\n                        if (!isBlocked(m.target, _this.blockClass, _this.blockSelector, false) && value !== m.oldValue) {\n                            _this.texts.push({\n                                value: needMaskingText(m.target, _this.maskTextClass, _this.maskTextSelector, true) && value ? _this.maskTextFn ? _this.maskTextFn(value, closestElementOfNode(m.target)) : value.replace(/[\\S]/g, \"*\") : value,\n                                node: m.target\n                            });\n                        }\n                        break;\n                    }\n                case \"attributes\":\n                    {\n                        var target = m.target;\n                        var attributeName = m.attributeName;\n                        var value1 = m.target.getAttribute(attributeName);\n                        if (attributeName === \"value\") {\n                            var type = getInputType(target);\n                            value1 = maskInputValue({\n                                element: target,\n                                maskInputOptions: _this.maskInputOptions,\n                                tagName: target.tagName,\n                                type: type,\n                                value: value1,\n                                maskInputFn: _this.maskInputFn\n                            });\n                        }\n                        if (isBlocked(m.target, _this.blockClass, _this.blockSelector, false) || value1 === m.oldValue) {\n                            return;\n                        }\n                        var item = _this.attributeMap.get(m.target);\n                        if (target.tagName === \"IFRAME\" && attributeName === \"src\" && !_this.keepIframeSrcFn(value1)) {\n                            if (!target.contentDocument) {\n                                attributeName = \"rr_src\";\n                            } else {\n                                return;\n                            }\n                        }\n                        if (!item) {\n                            item = {\n                                node: m.target,\n                                attributes: {},\n                                styleDiff: {},\n                                _unchangedStyles: {}\n                            };\n                            _this.attributes.push(item);\n                            _this.attributeMap.set(m.target, item);\n                        }\n                        if (attributeName === \"type\" && target.tagName === \"INPUT\" && (m.oldValue || \"\").toLowerCase() === \"password\") {\n                            target.setAttribute(\"data-rr-is-password\", \"true\");\n                        }\n                        if (!ignoreAttribute(target.tagName, attributeName)) {\n                            item.attributes[attributeName] = transformAttribute(_this.doc, toLowerCase(target.tagName), toLowerCase(attributeName), value1);\n                            if (attributeName === \"style\") {\n                                if (!_this.unattachedDoc) {\n                                    try {\n                                        _this.unattachedDoc = document.implementation.createHTMLDocument();\n                                    } catch (e2) {\n                                        _this.unattachedDoc = _this.doc;\n                                    }\n                                }\n                                var old = _this.unattachedDoc.createElement(\"span\");\n                                if (m.oldValue) {\n                                    old.setAttribute(\"style\", m.oldValue);\n                                }\n                                for(var _iterator = _create_for_of_iterator_helper_loose(Array.from(target.style)), _step; !(_step = _iterator()).done;){\n                                    var pname = _step.value;\n                                    var newValue = target.style.getPropertyValue(pname);\n                                    var newPriority = target.style.getPropertyPriority(pname);\n                                    if (newValue !== old.style.getPropertyValue(pname) || newPriority !== old.style.getPropertyPriority(pname)) {\n                                        if (newPriority === \"\") {\n                                            item.styleDiff[pname] = newValue;\n                                        } else {\n                                            item.styleDiff[pname] = [\n                                                newValue,\n                                                newPriority\n                                            ];\n                                        }\n                                    } else {\n                                        item._unchangedStyles[pname] = [\n                                            newValue,\n                                            newPriority\n                                        ];\n                                    }\n                                }\n                                for(var _iterator1 = _create_for_of_iterator_helper_loose(Array.from(old.style)), _step1; !(_step1 = _iterator1()).done;){\n                                    var pname1 = _step1.value;\n                                    if (target.style.getPropertyValue(pname1) === \"\") {\n                                        item.styleDiff[pname1] = false;\n                                    }\n                                }\n                            } else if (attributeName === \"open\" && target.tagName === \"DIALOG\") {\n                                if (target.matches(\"dialog:modal\")) {\n                                    item.attributes[\"rr_open_mode\"] = \"modal\";\n                                } else {\n                                    item.attributes[\"rr_open_mode\"] = \"non-modal\";\n                                }\n                            }\n                        }\n                        break;\n                    }\n                case \"childList\":\n                    {\n                        if (isBlocked(m.target, _this.blockClass, _this.blockSelector, true)) return;\n                        if (m.target.tagName === \"TEXTAREA\") {\n                            _this.genTextAreaValueMutation(m.target);\n                            return;\n                        }\n                        m.addedNodes.forEach(function(n2) {\n                            return _this.genAdds(n2, m.target);\n                        });\n                        m.removedNodes.forEach(function(n2) {\n                            var nodeId = _this.mirror.getId(n2);\n                            var parentId = isShadowRoot(m.target) ? _this.mirror.getId(index.host(m.target)) : _this.mirror.getId(m.target);\n                            if (isBlocked(m.target, _this.blockClass, _this.blockSelector, false) || isIgnored(n2, _this.mirror, _this.slimDOMOptions) || !isSerialized(n2, _this.mirror)) {\n                                return;\n                            }\n                            if (_this.addedSet.has(n2)) {\n                                deepDelete(_this.addedSet, n2);\n                                _this.droppedSet.add(n2);\n                            } else if (_this.addedSet.has(m.target) && nodeId === -1) ;\n                            else if (isAncestorRemoved(m.target, _this.mirror)) ;\n                            else if (_this.movedSet.has(n2) && _this.movedMap[moveKey(nodeId, parentId)]) {\n                                deepDelete(_this.movedSet, n2);\n                            } else {\n                                _this.removes.push({\n                                    parentId: parentId,\n                                    id: nodeId,\n                                    isShadow: isShadowRoot(m.target) && isNativeShadowDom(m.target) ? true : void 0\n                                });\n                                processRemoves(n2, _this.removesSubTreeCache);\n                            }\n                            _this.mapRemoves.push(n2);\n                        });\n                        break;\n                    }\n            }\n        });\n        /**\n     * Make sure you check if `n`'s parent is blocked before calling this function\n     * */ __publicField$1(this, \"genAdds\", function(n2, target) {\n            if (_this.processedNodeManager.inOtherBuffer(n2, _this)) return;\n            if (_this.addedSet.has(n2) || _this.movedSet.has(n2)) return;\n            if (_this.mirror.hasNode(n2)) {\n                if (isIgnored(n2, _this.mirror, _this.slimDOMOptions)) {\n                    return;\n                }\n                _this.movedSet.add(n2);\n                var targetId = null;\n                if (target && _this.mirror.hasNode(target)) {\n                    targetId = _this.mirror.getId(target);\n                }\n                if (targetId && targetId !== -1) {\n                    _this.movedMap[moveKey(_this.mirror.getId(n2), targetId)] = true;\n                }\n            } else {\n                _this.addedSet.add(n2);\n                _this.droppedSet.delete(n2);\n            }\n            if (!isBlocked(n2, _this.blockClass, _this.blockSelector, false)) {\n                index.childNodes(n2).forEach(function(childN) {\n                    return _this.genAdds(childN);\n                });\n                if (hasShadowRoot(n2)) {\n                    index.childNodes(index.shadowRoot(n2)).forEach(function(childN) {\n                        _this.processedNodeManager.add(childN, _this);\n                        _this.genAdds(childN, n2);\n                    });\n                }\n            }\n        });\n    }\n    var _proto = MutationBuffer.prototype;\n    _proto.init = function init(options) {\n        var _this = this;\n        [\n            \"mutationCb\",\n            \"blockClass\",\n            \"blockSelector\",\n            \"maskTextClass\",\n            \"maskTextSelector\",\n            \"inlineStylesheet\",\n            \"maskInputOptions\",\n            \"maskTextFn\",\n            \"maskInputFn\",\n            \"keepIframeSrcFn\",\n            \"recordCanvas\",\n            \"inlineImages\",\n            \"slimDOMOptions\",\n            \"dataURLOptions\",\n            \"doc\",\n            \"mirror\",\n            \"iframeManager\",\n            \"stylesheetManager\",\n            \"shadowDomManager\",\n            \"canvasManager\",\n            \"processedNodeManager\"\n        ].forEach(function(key) {\n            _this[key] = options[key];\n        });\n    };\n    _proto.freeze = function freeze() {\n        this.frozen = true;\n        this.canvasManager.freeze();\n    };\n    _proto.unfreeze = function unfreeze() {\n        this.frozen = false;\n        this.canvasManager.unfreeze();\n        this.emit();\n    };\n    _proto.isFrozen = function isFrozen() {\n        return this.frozen;\n    };\n    _proto.lock = function lock() {\n        this.locked = true;\n        this.canvasManager.lock();\n    };\n    _proto.unlock = function unlock() {\n        this.locked = false;\n        this.canvasManager.unlock();\n        this.emit();\n    };\n    _proto.reset = function reset() {\n        this.shadowDomManager.reset();\n        this.canvasManager.reset();\n    };\n    return MutationBuffer;\n}();\nfunction deepDelete(addsSet, n2) {\n    addsSet.delete(n2);\n    index.childNodes(n2).forEach(function(childN) {\n        return deepDelete(addsSet, childN);\n    });\n}\nfunction processRemoves(n2, cache) {\n    var queue = [\n        n2\n    ];\n    while(queue.length){\n        var next = queue.pop();\n        if (cache.has(next)) continue;\n        cache.add(next);\n        index.childNodes(next).forEach(function(n22) {\n            return queue.push(n22);\n        });\n    }\n    return;\n}\nfunction isParentRemoved(removes, n2, mirror2) {\n    if (removes.size === 0) return false;\n    return _isParentRemoved(removes, n2);\n}\nfunction _isParentRemoved(removes, n2, _mirror2) {\n    var node2 = index.parentNode(n2);\n    if (!node2) return false;\n    return removes.has(node2);\n}\nfunction isAncestorInSet(set, n2) {\n    if (set.size === 0) return false;\n    return _isAncestorInSet(set, n2);\n}\nfunction _isAncestorInSet(set, n2) {\n    var parent = index.parentNode(n2);\n    if (!parent) {\n        return false;\n    }\n    if (set.has(parent)) {\n        return true;\n    }\n    return _isAncestorInSet(set, parent);\n}\nvar errorHandler;\nfunction registerErrorHandler(handler) {\n    errorHandler = handler;\n}\nfunction unregisterErrorHandler() {\n    errorHandler = void 0;\n}\nvar callbackWrapper = function(cb) {\n    if (!errorHandler) {\n        return cb;\n    }\n    var rrwebWrapped = function() {\n        for(var _len = arguments.length, rest = new Array(_len), _key = 0; _key < _len; _key++){\n            rest[_key] = arguments[_key];\n        }\n        try {\n            return cb.apply(void 0, [].concat(rest));\n        } catch (error) {\n            if (errorHandler && errorHandler(error) === true) {\n                return;\n            }\n            throw error;\n        }\n    };\n    return rrwebWrapped;\n};\nvar mutationBuffers = [];\nfunction getEventTarget(event) {\n    try {\n        if (\"composedPath\" in event) {\n            var path = event.composedPath();\n            if (path.length) {\n                return path[0];\n            }\n        } else if (\"path\" in event && event.path.length) {\n            return event.path[0];\n        }\n    } catch (e) {}\n    return event && event.target;\n}\nfunction initMutationObserver(options, rootEl) {\n    var mutationBuffer = new MutationBuffer();\n    mutationBuffers.push(mutationBuffer);\n    mutationBuffer.init(options);\n    var observer = new (mutationObserverCtor())(callbackWrapper(mutationBuffer.processMutations.bind(mutationBuffer)));\n    observer.observe(rootEl, {\n        attributes: true,\n        attributeOldValue: true,\n        characterData: true,\n        characterDataOldValue: true,\n        childList: true,\n        subtree: true\n    });\n    return observer;\n}\nfunction initMoveObserver(param) {\n    var mousemoveCb = param.mousemoveCb, sampling = param.sampling, doc = param.doc, mirror2 = param.mirror;\n    if (sampling.mousemove === false) {\n        return function() {};\n    }\n    var threshold = typeof sampling.mousemove === \"number\" ? sampling.mousemove : 50;\n    var callbackThreshold = typeof sampling.mousemoveCallback === \"number\" ? sampling.mousemoveCallback : 500;\n    var positions = [];\n    var timeBaseline;\n    var wrappedCb = throttle(callbackWrapper(function(source) {\n        var totalOffset = Date.now() - timeBaseline;\n        mousemoveCb(positions.map(function(p) {\n            p.timeOffset -= totalOffset;\n            return p;\n        }), source);\n        positions = [];\n        timeBaseline = null;\n    }), callbackThreshold);\n    var updatePosition = callbackWrapper(throttle(callbackWrapper(function(evt) {\n        var target = getEventTarget(evt);\n        var _ref = legacy_isTouchEvent(evt) ? evt.changedTouches[0] : evt, clientX = _ref.clientX, clientY = _ref.clientY;\n        if (!timeBaseline) {\n            timeBaseline = nowTimestamp();\n        }\n        positions.push({\n            x: clientX,\n            y: clientY,\n            id: mirror2.getId(target),\n            timeOffset: nowTimestamp() - timeBaseline\n        });\n        wrappedCb(typeof DragEvent !== \"undefined\" && _instanceof(evt, DragEvent) ? IncrementalSource.Drag : _instanceof(evt, MouseEvent) ? IncrementalSource.MouseMove : IncrementalSource.TouchMove);\n    }), threshold, {\n        trailing: false\n    }));\n    var handlers = [\n        on(\"mousemove\", updatePosition, doc),\n        on(\"touchmove\", updatePosition, doc),\n        on(\"drag\", updatePosition, doc)\n    ];\n    return callbackWrapper(function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    });\n}\nfunction initMouseInteractionObserver(param) {\n    var mouseInteractionCb = param.mouseInteractionCb, doc = param.doc, mirror2 = param.mirror, blockClass = param.blockClass, blockSelector = param.blockSelector, sampling = param.sampling;\n    if (sampling.mouseInteraction === false) {\n        return function() {};\n    }\n    var disableMap = sampling.mouseInteraction === true || sampling.mouseInteraction === void 0 ? {} : sampling.mouseInteraction;\n    var handlers = [];\n    var currentPointerType = null;\n    var getHandler = function(eventKey) {\n        return function(event) {\n            var target = getEventTarget(event);\n            if (isBlocked(target, blockClass, blockSelector, true)) {\n                return;\n            }\n            var pointerType = null;\n            var thisEventKey = eventKey;\n            if (\"pointerType\" in event) {\n                switch(event.pointerType){\n                    case \"mouse\":\n                        pointerType = PointerTypes.Mouse;\n                        break;\n                    case \"touch\":\n                        pointerType = PointerTypes.Touch;\n                        break;\n                    case \"pen\":\n                        pointerType = PointerTypes.Pen;\n                        break;\n                }\n                if (pointerType === PointerTypes.Touch) {\n                    if (MouseInteractions[eventKey] === MouseInteractions.MouseDown) {\n                        thisEventKey = \"TouchStart\";\n                    } else if (MouseInteractions[eventKey] === MouseInteractions.MouseUp) {\n                        thisEventKey = \"TouchEnd\";\n                    }\n                } else if (pointerType === PointerTypes.Pen) ;\n            } else if (legacy_isTouchEvent(event)) {\n                pointerType = PointerTypes.Touch;\n            }\n            if (pointerType !== null) {\n                currentPointerType = pointerType;\n                if (thisEventKey.startsWith(\"Touch\") && pointerType === PointerTypes.Touch || thisEventKey.startsWith(\"Mouse\") && pointerType === PointerTypes.Mouse) {\n                    pointerType = null;\n                }\n            } else if (MouseInteractions[eventKey] === MouseInteractions.Click) {\n                pointerType = currentPointerType;\n                currentPointerType = null;\n            }\n            var e2 = legacy_isTouchEvent(event) ? event.changedTouches[0] : event;\n            if (!e2) {\n                return;\n            }\n            var id = mirror2.getId(target);\n            var clientX = e2.clientX, clientY = e2.clientY;\n            callbackWrapper(mouseInteractionCb)(_extends({\n                type: MouseInteractions[thisEventKey],\n                id: id,\n                x: clientX,\n                y: clientY\n            }, pointerType !== null && {\n                pointerType: pointerType\n            }));\n        };\n    };\n    Object.keys(MouseInteractions).filter(function(key) {\n        return Number.isNaN(Number(key)) && !key.endsWith(\"_Departed\") && disableMap[key] !== false;\n    }).forEach(function(eventKey) {\n        var eventName = toLowerCase(eventKey);\n        var handler = getHandler(eventKey);\n        if (window.PointerEvent) {\n            switch(MouseInteractions[eventKey]){\n                case MouseInteractions.MouseDown:\n                case MouseInteractions.MouseUp:\n                    eventName = eventName.replace(\"mouse\", \"pointer\");\n                    break;\n                case MouseInteractions.TouchStart:\n                case MouseInteractions.TouchEnd:\n                    return;\n            }\n        }\n        handlers.push(on(eventName, handler, doc));\n    });\n    return callbackWrapper(function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    });\n}\nfunction initScrollObserver(param) {\n    var scrollCb = param.scrollCb, doc = param.doc, mirror2 = param.mirror, blockClass = param.blockClass, blockSelector = param.blockSelector, sampling = param.sampling;\n    var updatePosition = callbackWrapper(throttle(callbackWrapper(function(evt) {\n        var target = getEventTarget(evt);\n        if (!target || isBlocked(target, blockClass, blockSelector, true)) {\n            return;\n        }\n        var id = mirror2.getId(target);\n        if (target === doc && doc.defaultView) {\n            var scrollLeftTop = getWindowScroll(doc.defaultView);\n            scrollCb({\n                id: id,\n                x: scrollLeftTop.left,\n                y: scrollLeftTop.top\n            });\n        } else {\n            scrollCb({\n                id: id,\n                x: target.scrollLeft,\n                y: target.scrollTop\n            });\n        }\n    }), sampling.scroll || 100));\n    return on(\"scroll\", updatePosition, doc);\n}\nfunction initViewportResizeObserver(param, param1) {\n    var viewportResizeCb = param.viewportResizeCb;\n    var win = param1.win;\n    var lastH = -1;\n    var lastW = -1;\n    var updateDimension = callbackWrapper(throttle(callbackWrapper(function() {\n        var height = getWindowHeight();\n        var width = getWindowWidth();\n        if (lastH !== height || lastW !== width) {\n            viewportResizeCb({\n                width: Number(width),\n                height: Number(height)\n            });\n            lastH = height;\n            lastW = width;\n        }\n    }), 200));\n    return on(\"resize\", updateDimension, win);\n}\nvar INPUT_TAGS = [\n    \"INPUT\",\n    \"TEXTAREA\",\n    \"SELECT\"\n];\nvar lastInputValueMap = /* @__PURE__ */ new WeakMap();\nfunction initInputObserver(param) {\n    var inputCb = param.inputCb, doc = param.doc, mirror2 = param.mirror, blockClass = param.blockClass, blockSelector = param.blockSelector, ignoreClass = param.ignoreClass, ignoreSelector = param.ignoreSelector, maskInputOptions = param.maskInputOptions, maskInputFn = param.maskInputFn, sampling = param.sampling, userTriggeredOnInput = param.userTriggeredOnInput;\n    function eventHandler(event) {\n        var target = getEventTarget(event);\n        var userTriggered = event.isTrusted;\n        var tagName = target && target.tagName;\n        if (target && tagName === \"OPTION\") {\n            target = index.parentElement(target);\n        }\n        if (!target || !tagName || INPUT_TAGS.indexOf(tagName) < 0 || isBlocked(target, blockClass, blockSelector, true)) {\n            return;\n        }\n        if (target.classList.contains(ignoreClass) || ignoreSelector && target.matches(ignoreSelector)) {\n            return;\n        }\n        var text = target.value;\n        var isChecked = false;\n        var type = getInputType(target) || \"\";\n        if (type === \"radio\" || type === \"checkbox\") {\n            isChecked = target.checked;\n        } else if (maskInputOptions[tagName.toLowerCase()] || maskInputOptions[type]) {\n            text = maskInputValue({\n                element: target,\n                maskInputOptions: maskInputOptions,\n                tagName: tagName,\n                type: type,\n                value: text,\n                maskInputFn: maskInputFn\n            });\n        }\n        cbWithDedup(target, userTriggeredOnInput ? {\n            text: text,\n            isChecked: isChecked,\n            userTriggered: userTriggered\n        } : {\n            text: text,\n            isChecked: isChecked\n        });\n        var name = target.name;\n        if (type === \"radio\" && name && isChecked) {\n            doc.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]').forEach(function(el) {\n                if (el !== target) {\n                    var text2 = el.value;\n                    cbWithDedup(el, userTriggeredOnInput ? {\n                        text: text2,\n                        isChecked: !isChecked,\n                        userTriggered: false\n                    } : {\n                        text: text2,\n                        isChecked: !isChecked\n                    });\n                }\n            });\n        }\n    }\n    function cbWithDedup(target, v2) {\n        var lastInputValue = lastInputValueMap.get(target);\n        if (!lastInputValue || lastInputValue.text !== v2.text || lastInputValue.isChecked !== v2.isChecked) {\n            lastInputValueMap.set(target, v2);\n            var id = mirror2.getId(target);\n            callbackWrapper(inputCb)(_extends({}, v2, {\n                id: id\n            }));\n        }\n    }\n    var events = sampling.input === \"last\" ? [\n        \"change\"\n    ] : [\n        \"input\",\n        \"change\"\n    ];\n    var handlers = events.map(function(eventName) {\n        return on(eventName, callbackWrapper(eventHandler), doc);\n    });\n    var currentWindow = doc.defaultView;\n    if (!currentWindow) {\n        return function() {\n            handlers.forEach(function(h) {\n                return h();\n            });\n        };\n    }\n    var propertyDescriptor = currentWindow.Object.getOwnPropertyDescriptor(currentWindow.HTMLInputElement.prototype, \"value\");\n    var hookProperties = [\n        [\n            currentWindow.HTMLInputElement.prototype,\n            \"value\"\n        ],\n        [\n            currentWindow.HTMLInputElement.prototype,\n            \"checked\"\n        ],\n        [\n            currentWindow.HTMLSelectElement.prototype,\n            \"value\"\n        ],\n        [\n            currentWindow.HTMLTextAreaElement.prototype,\n            \"value\"\n        ],\n        // Some UI library use selectedIndex to set select value\n        [\n            currentWindow.HTMLSelectElement.prototype,\n            \"selectedIndex\"\n        ],\n        [\n            currentWindow.HTMLOptionElement.prototype,\n            \"selected\"\n        ]\n    ];\n    if (propertyDescriptor && propertyDescriptor.set) {\n        var _handlers;\n        (_handlers = handlers).push.apply(_handlers, [].concat(hookProperties.map(function(p) {\n            return hookSetter(p[0], p[1], {\n                set: function set() {\n                    callbackWrapper(eventHandler)({\n                        target: this,\n                        isTrusted: false\n                    });\n                }\n            }, false, currentWindow);\n        })));\n    }\n    return callbackWrapper(function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    });\n}\nfunction getNestedCSSRulePositions(rule2) {\n    var positions = [];\n    function recurse(childRule, pos) {\n        if (hasNestedCSSRule(\"CSSGroupingRule\") && _instanceof(childRule.parentRule, CSSGroupingRule) || hasNestedCSSRule(\"CSSMediaRule\") && _instanceof(childRule.parentRule, CSSMediaRule) || hasNestedCSSRule(\"CSSSupportsRule\") && _instanceof(childRule.parentRule, CSSSupportsRule) || hasNestedCSSRule(\"CSSConditionRule\") && _instanceof(childRule.parentRule, CSSConditionRule)) {\n            var rules2 = Array.from(childRule.parentRule.cssRules);\n            var index2 = rules2.indexOf(childRule);\n            pos.unshift(index2);\n        } else if (childRule.parentStyleSheet) {\n            var rules21 = Array.from(childRule.parentStyleSheet.cssRules);\n            var index21 = rules21.indexOf(childRule);\n            pos.unshift(index21);\n        }\n        return pos;\n    }\n    return recurse(rule2, positions);\n}\nfunction getIdAndStyleId(sheet, mirror2, styleMirror) {\n    var id, styleId;\n    if (!sheet) return {};\n    if (sheet.ownerNode) id = mirror2.getId(sheet.ownerNode);\n    else styleId = styleMirror.getId(sheet);\n    return {\n        styleId: styleId,\n        id: id\n    };\n}\nfunction initStyleSheetObserver(param, param1) {\n    var styleSheetRuleCb = param.styleSheetRuleCb, mirror2 = param.mirror, stylesheetManager = param.stylesheetManager;\n    var win = param1.win;\n    if (!win.CSSStyleSheet || !win.CSSStyleSheet.prototype) {\n        return function() {};\n    }\n    var insertRule = win.CSSStyleSheet.prototype.insertRule;\n    win.CSSStyleSheet.prototype.insertRule = new Proxy(insertRule, {\n        apply: callbackWrapper(function(target, thisArg, argumentsList) {\n            var rule2 = argumentsList[0], index2 = argumentsList[1];\n            var _getIdAndStyleId = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n            if (id && id !== -1 || styleId && styleId !== -1) {\n                styleSheetRuleCb({\n                    id: id,\n                    styleId: styleId,\n                    adds: [\n                        {\n                            rule: rule2,\n                            index: index2\n                        }\n                    ]\n                });\n            }\n            return target.apply(thisArg, argumentsList);\n        })\n    });\n    win.CSSStyleSheet.prototype.addRule = function(selector, styleBlock, index2) {\n        if (index2 === void 0) index2 = this.cssRules.length;\n        var rule2 = selector + \" { \" + styleBlock + \" }\";\n        return win.CSSStyleSheet.prototype.insertRule.apply(this, [\n            rule2,\n            index2\n        ]);\n    };\n    var deleteRule = win.CSSStyleSheet.prototype.deleteRule;\n    win.CSSStyleSheet.prototype.deleteRule = new Proxy(deleteRule, {\n        apply: callbackWrapper(function(target, thisArg, argumentsList) {\n            var index2 = argumentsList[0];\n            var _getIdAndStyleId = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n            if (id && id !== -1 || styleId && styleId !== -1) {\n                styleSheetRuleCb({\n                    id: id,\n                    styleId: styleId,\n                    removes: [\n                        {\n                            index: index2\n                        }\n                    ]\n                });\n            }\n            return target.apply(thisArg, argumentsList);\n        })\n    });\n    win.CSSStyleSheet.prototype.removeRule = function(index2) {\n        return win.CSSStyleSheet.prototype.deleteRule.apply(this, [\n            index2\n        ]);\n    };\n    var replace;\n    if (win.CSSStyleSheet.prototype.replace) {\n        replace = win.CSSStyleSheet.prototype.replace;\n        win.CSSStyleSheet.prototype.replace = new Proxy(replace, {\n            apply: callbackWrapper(function(target, thisArg, argumentsList) {\n                var text = argumentsList[0];\n                var _getIdAndStyleId = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n                if (id && id !== -1 || styleId && styleId !== -1) {\n                    styleSheetRuleCb({\n                        id: id,\n                        styleId: styleId,\n                        replace: text\n                    });\n                }\n                return target.apply(thisArg, argumentsList);\n            })\n        });\n    }\n    var replaceSync;\n    if (win.CSSStyleSheet.prototype.replaceSync) {\n        replaceSync = win.CSSStyleSheet.prototype.replaceSync;\n        win.CSSStyleSheet.prototype.replaceSync = new Proxy(replaceSync, {\n            apply: callbackWrapper(function(target, thisArg, argumentsList) {\n                var text = argumentsList[0];\n                var _getIdAndStyleId = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n                if (id && id !== -1 || styleId && styleId !== -1) {\n                    styleSheetRuleCb({\n                        id: id,\n                        styleId: styleId,\n                        replaceSync: text\n                    });\n                }\n                return target.apply(thisArg, argumentsList);\n            })\n        });\n    }\n    var supportedNestedCSSRuleTypes = {};\n    if (canMonkeyPatchNestedCSSRule(\"CSSGroupingRule\")) {\n        supportedNestedCSSRuleTypes.CSSGroupingRule = win.CSSGroupingRule;\n    } else {\n        if (canMonkeyPatchNestedCSSRule(\"CSSMediaRule\")) {\n            supportedNestedCSSRuleTypes.CSSMediaRule = win.CSSMediaRule;\n        }\n        if (canMonkeyPatchNestedCSSRule(\"CSSConditionRule\")) {\n            supportedNestedCSSRuleTypes.CSSConditionRule = win.CSSConditionRule;\n        }\n        if (canMonkeyPatchNestedCSSRule(\"CSSSupportsRule\")) {\n            supportedNestedCSSRuleTypes.CSSSupportsRule = win.CSSSupportsRule;\n        }\n    }\n    var unmodifiedFunctions = {};\n    Object.entries(supportedNestedCSSRuleTypes).forEach(function(param) {\n        var typeKey = param[0], type = param[1];\n        unmodifiedFunctions[typeKey] = {\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            insertRule: type.prototype.insertRule,\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            deleteRule: type.prototype.deleteRule\n        };\n        type.prototype.insertRule = new Proxy(unmodifiedFunctions[typeKey].insertRule, {\n            apply: callbackWrapper(function(target, thisArg, argumentsList) {\n                var rule2 = argumentsList[0], index2 = argumentsList[1];\n                var _getIdAndStyleId = getIdAndStyleId(thisArg.parentStyleSheet, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n                if (id && id !== -1 || styleId && styleId !== -1) {\n                    styleSheetRuleCb({\n                        id: id,\n                        styleId: styleId,\n                        adds: [\n                            {\n                                rule: rule2,\n                                index: [].concat(getNestedCSSRulePositions(thisArg), [\n                                    index2 || 0\n                                ])\n                            }\n                        ]\n                    });\n                }\n                return target.apply(thisArg, argumentsList);\n            })\n        });\n        type.prototype.deleteRule = new Proxy(unmodifiedFunctions[typeKey].deleteRule, {\n            apply: callbackWrapper(function(target, thisArg, argumentsList) {\n                var index2 = argumentsList[0];\n                var _getIdAndStyleId = getIdAndStyleId(thisArg.parentStyleSheet, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n                if (id && id !== -1 || styleId && styleId !== -1) {\n                    styleSheetRuleCb({\n                        id: id,\n                        styleId: styleId,\n                        removes: [\n                            {\n                                index: [].concat(getNestedCSSRulePositions(thisArg), [\n                                    index2\n                                ])\n                            }\n                        ]\n                    });\n                }\n                return target.apply(thisArg, argumentsList);\n            })\n        });\n    });\n    return callbackWrapper(function() {\n        win.CSSStyleSheet.prototype.insertRule = insertRule;\n        win.CSSStyleSheet.prototype.deleteRule = deleteRule;\n        replace && (win.CSSStyleSheet.prototype.replace = replace);\n        replaceSync && (win.CSSStyleSheet.prototype.replaceSync = replaceSync);\n        Object.entries(supportedNestedCSSRuleTypes).forEach(function(param) {\n            var typeKey = param[0], type = param[1];\n            type.prototype.insertRule = unmodifiedFunctions[typeKey].insertRule;\n            type.prototype.deleteRule = unmodifiedFunctions[typeKey].deleteRule;\n        });\n    });\n}\nfunction initAdoptedStyleSheetObserver(param, host2) {\n    var mirror2 = param.mirror, stylesheetManager = param.stylesheetManager;\n    var _a2, _b, _c;\n    var hostId = null;\n    if (host2.nodeName === \"#document\") hostId = mirror2.getId(host2);\n    else hostId = mirror2.getId(index.host(host2));\n    var patchTarget = host2.nodeName === \"#document\" ? (_a2 = host2.defaultView) == null ? void 0 : _a2.Document : (_c = (_b = host2.ownerDocument) == null ? void 0 : _b.defaultView) == null ? void 0 : _c.ShadowRoot;\n    var originalPropertyDescriptor = (patchTarget == null ? void 0 : patchTarget.prototype) ? Object.getOwnPropertyDescriptor(patchTarget == null ? void 0 : patchTarget.prototype, \"adoptedStyleSheets\") : void 0;\n    if (hostId === null || hostId === -1 || !patchTarget || !originalPropertyDescriptor) return function() {};\n    Object.defineProperty(host2, \"adoptedStyleSheets\", {\n        configurable: originalPropertyDescriptor.configurable,\n        enumerable: originalPropertyDescriptor.enumerable,\n        get: function get() {\n            var _a3;\n            return (_a3 = originalPropertyDescriptor.get) == null ? void 0 : _a3.call(this);\n        },\n        set: function set(sheets) {\n            var _a3;\n            var result2 = (_a3 = originalPropertyDescriptor.set) == null ? void 0 : _a3.call(this, sheets);\n            if (hostId !== null && hostId !== -1) {\n                try {\n                    stylesheetManager.adoptStyleSheets(sheets, hostId);\n                } catch (e2) {}\n            }\n            return result2;\n        }\n    });\n    return callbackWrapper(function() {\n        Object.defineProperty(host2, \"adoptedStyleSheets\", {\n            configurable: originalPropertyDescriptor.configurable,\n            enumerable: originalPropertyDescriptor.enumerable,\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            get: originalPropertyDescriptor.get,\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            set: originalPropertyDescriptor.set\n        });\n    });\n}\nfunction initStyleDeclarationObserver(param, param1) {\n    var styleDeclarationCb = param.styleDeclarationCb, mirror2 = param.mirror, ignoreCSSAttributes = param.ignoreCSSAttributes, stylesheetManager = param.stylesheetManager;\n    var win = param1.win;\n    var setProperty = win.CSSStyleDeclaration.prototype.setProperty;\n    win.CSSStyleDeclaration.prototype.setProperty = new Proxy(setProperty, {\n        apply: callbackWrapper(function(target, thisArg, argumentsList) {\n            var _a2;\n            var property = argumentsList[0], value = argumentsList[1], priority = argumentsList[2];\n            if (ignoreCSSAttributes.has(property)) {\n                return setProperty.apply(thisArg, [\n                    property,\n                    value,\n                    priority\n                ]);\n            }\n            var _getIdAndStyleId = getIdAndStyleId((_a2 = thisArg.parentRule) == null ? void 0 : _a2.parentStyleSheet, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n            if (id && id !== -1 || styleId && styleId !== -1) {\n                styleDeclarationCb({\n                    id: id,\n                    styleId: styleId,\n                    set: {\n                        property: property,\n                        value: value,\n                        priority: priority\n                    },\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    index: getNestedCSSRulePositions(thisArg.parentRule)\n                });\n            }\n            return target.apply(thisArg, argumentsList);\n        })\n    });\n    var removeProperty = win.CSSStyleDeclaration.prototype.removeProperty;\n    win.CSSStyleDeclaration.prototype.removeProperty = new Proxy(removeProperty, {\n        apply: callbackWrapper(function(target, thisArg, argumentsList) {\n            var _a2;\n            var property = argumentsList[0];\n            if (ignoreCSSAttributes.has(property)) {\n                return removeProperty.apply(thisArg, [\n                    property\n                ]);\n            }\n            var _getIdAndStyleId = getIdAndStyleId((_a2 = thisArg.parentRule) == null ? void 0 : _a2.parentStyleSheet, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n            if (id && id !== -1 || styleId && styleId !== -1) {\n                styleDeclarationCb({\n                    id: id,\n                    styleId: styleId,\n                    remove: {\n                        property: property\n                    },\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    index: getNestedCSSRulePositions(thisArg.parentRule)\n                });\n            }\n            return target.apply(thisArg, argumentsList);\n        })\n    });\n    return callbackWrapper(function() {\n        win.CSSStyleDeclaration.prototype.setProperty = setProperty;\n        win.CSSStyleDeclaration.prototype.removeProperty = removeProperty;\n    });\n}\nfunction initMediaInteractionObserver(param) {\n    var mediaInteractionCb = param.mediaInteractionCb, blockClass = param.blockClass, blockSelector = param.blockSelector, mirror2 = param.mirror, sampling = param.sampling, doc = param.doc;\n    var handler = callbackWrapper(function(type) {\n        return throttle(callbackWrapper(function(event) {\n            var target = getEventTarget(event);\n            if (!target || isBlocked(target, blockClass, blockSelector, true)) {\n                return;\n            }\n            var currentTime = target.currentTime, volume = target.volume, muted = target.muted, playbackRate = target.playbackRate, loop = target.loop;\n            mediaInteractionCb({\n                type: type,\n                id: mirror2.getId(target),\n                currentTime: currentTime,\n                volume: volume,\n                muted: muted,\n                playbackRate: playbackRate,\n                loop: loop\n            });\n        }), sampling.media || 500);\n    });\n    var handlers = [\n        on(\"play\", handler(MediaInteractions.Play), doc),\n        on(\"pause\", handler(MediaInteractions.Pause), doc),\n        on(\"seeked\", handler(MediaInteractions.Seeked), doc),\n        on(\"volumechange\", handler(MediaInteractions.VolumeChange), doc),\n        on(\"ratechange\", handler(MediaInteractions.RateChange), doc)\n    ];\n    return callbackWrapper(function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    });\n}\nfunction initFontObserver(param) {\n    var fontCb = param.fontCb, doc = param.doc;\n    var win = doc.defaultView;\n    if (!win) {\n        return function() {};\n    }\n    var handlers = [];\n    var fontMap = /* @__PURE__ */ new WeakMap();\n    var originalFontFace = win.FontFace;\n    win.FontFace = function FontFace2(family, source, descriptors) {\n        var fontFace = new originalFontFace(family, source, descriptors);\n        fontMap.set(fontFace, {\n            family: family,\n            buffer: typeof source !== \"string\",\n            descriptors: descriptors,\n            fontSource: typeof source === \"string\" ? source : JSON.stringify(Array.from(new Uint8Array(source)))\n        });\n        return fontFace;\n    };\n    var restoreHandler = patch$2(doc.fonts, \"add\", function(original) {\n        return function(fontFace) {\n            setTimeout(callbackWrapper(function() {\n                var p = fontMap.get(fontFace);\n                if (p) {\n                    fontCb(p);\n                    fontMap.delete(fontFace);\n                }\n            }), 0);\n            return original.apply(this, [\n                fontFace\n            ]);\n        };\n    });\n    handlers.push(function() {\n        win.FontFace = originalFontFace;\n    });\n    handlers.push(restoreHandler);\n    return callbackWrapper(function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    });\n}\nfunction initSelectionObserver(param) {\n    var doc = param.doc, mirror2 = param.mirror, blockClass = param.blockClass, blockSelector = param.blockSelector, selectionCb = param.selectionCb;\n    var collapsed = true;\n    var updateSelection = callbackWrapper(function() {\n        var selection = doc.getSelection();\n        if (!selection || collapsed && (selection == null ? void 0 : selection.isCollapsed)) return;\n        collapsed = selection.isCollapsed || false;\n        var ranges = [];\n        var count = selection.rangeCount || 0;\n        for(var i2 = 0; i2 < count; i2++){\n            var range = selection.getRangeAt(i2);\n            var startContainer = range.startContainer, startOffset = range.startOffset, endContainer = range.endContainer, endOffset = range.endOffset;\n            var blocked = isBlocked(startContainer, blockClass, blockSelector, true) || isBlocked(endContainer, blockClass, blockSelector, true);\n            if (blocked) continue;\n            ranges.push({\n                start: mirror2.getId(startContainer),\n                startOffset: startOffset,\n                end: mirror2.getId(endContainer),\n                endOffset: endOffset\n            });\n        }\n        selectionCb({\n            ranges: ranges\n        });\n    });\n    updateSelection();\n    return on(\"selectionchange\", updateSelection);\n}\nfunction initCustomElementObserver(param) {\n    var doc = param.doc, customElementCb = param.customElementCb;\n    var win = doc.defaultView;\n    if (!win || !win.customElements) return function() {};\n    var restoreHandler = patch$2(win.customElements, \"define\", function(original) {\n        return function(name, constructor, options) {\n            try {\n                customElementCb({\n                    define: {\n                        name: name\n                    }\n                });\n            } catch (e2) {\n                console.warn(\"Custom element callback failed for \" + name);\n            }\n            return original.apply(this, [\n                name,\n                constructor,\n                options\n            ]);\n        };\n    });\n    return restoreHandler;\n}\nfunction mergeHooks(o2, hooks) {\n    var mutationCb = o2.mutationCb, mousemoveCb = o2.mousemoveCb, mouseInteractionCb = o2.mouseInteractionCb, scrollCb = o2.scrollCb, viewportResizeCb = o2.viewportResizeCb, inputCb = o2.inputCb, mediaInteractionCb = o2.mediaInteractionCb, styleSheetRuleCb = o2.styleSheetRuleCb, styleDeclarationCb = o2.styleDeclarationCb, canvasMutationCb = o2.canvasMutationCb, fontCb = o2.fontCb, selectionCb = o2.selectionCb, customElementCb = o2.customElementCb;\n    o2.mutationCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.mutation) {\n            var _hooks;\n            (_hooks = hooks).mutation.apply(_hooks, [].concat(p));\n        }\n        mutationCb.apply(void 0, [].concat(p));\n    };\n    o2.mousemoveCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.mousemove) {\n            var _hooks;\n            (_hooks = hooks).mousemove.apply(_hooks, [].concat(p));\n        }\n        mousemoveCb.apply(void 0, [].concat(p));\n    };\n    o2.mouseInteractionCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.mouseInteraction) {\n            var _hooks;\n            (_hooks = hooks).mouseInteraction.apply(_hooks, [].concat(p));\n        }\n        mouseInteractionCb.apply(void 0, [].concat(p));\n    };\n    o2.scrollCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.scroll) {\n            var _hooks;\n            (_hooks = hooks).scroll.apply(_hooks, [].concat(p));\n        }\n        scrollCb.apply(void 0, [].concat(p));\n    };\n    o2.viewportResizeCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.viewportResize) {\n            var _hooks;\n            (_hooks = hooks).viewportResize.apply(_hooks, [].concat(p));\n        }\n        viewportResizeCb.apply(void 0, [].concat(p));\n    };\n    o2.inputCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.input) {\n            var _hooks;\n            (_hooks = hooks).input.apply(_hooks, [].concat(p));\n        }\n        inputCb.apply(void 0, [].concat(p));\n    };\n    o2.mediaInteractionCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.mediaInteaction) {\n            var _hooks;\n            (_hooks = hooks).mediaInteaction.apply(_hooks, [].concat(p));\n        }\n        mediaInteractionCb.apply(void 0, [].concat(p));\n    };\n    o2.styleSheetRuleCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.styleSheetRule) {\n            var _hooks;\n            (_hooks = hooks).styleSheetRule.apply(_hooks, [].concat(p));\n        }\n        styleSheetRuleCb.apply(void 0, [].concat(p));\n    };\n    o2.styleDeclarationCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.styleDeclaration) {\n            var _hooks;\n            (_hooks = hooks).styleDeclaration.apply(_hooks, [].concat(p));\n        }\n        styleDeclarationCb.apply(void 0, [].concat(p));\n    };\n    o2.canvasMutationCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.canvasMutation) {\n            var _hooks;\n            (_hooks = hooks).canvasMutation.apply(_hooks, [].concat(p));\n        }\n        canvasMutationCb.apply(void 0, [].concat(p));\n    };\n    o2.fontCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.font) {\n            var _hooks;\n            (_hooks = hooks).font.apply(_hooks, [].concat(p));\n        }\n        fontCb.apply(void 0, [].concat(p));\n    };\n    o2.selectionCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.selection) {\n            var _hooks;\n            (_hooks = hooks).selection.apply(_hooks, [].concat(p));\n        }\n        selectionCb.apply(void 0, [].concat(p));\n    };\n    o2.customElementCb = function() {\n        for(var _len = arguments.length, c2 = new Array(_len), _key = 0; _key < _len; _key++){\n            c2[_key] = arguments[_key];\n        }\n        if (hooks.customElement) {\n            var _hooks;\n            (_hooks = hooks).customElement.apply(_hooks, [].concat(c2));\n        }\n        customElementCb.apply(void 0, [].concat(c2));\n    };\n}\nfunction initObservers(o2, hooks) {\n    if (hooks === void 0) hooks = {};\n    var currentWindow = o2.doc.defaultView;\n    if (!currentWindow) {\n        return function() {};\n    }\n    mergeHooks(o2, hooks);\n    var mutationObserver;\n    if (o2.recordDOM) {\n        mutationObserver = initMutationObserver(o2, o2.doc);\n    }\n    var mousemoveHandler = initMoveObserver(o2);\n    var mouseInteractionHandler = initMouseInteractionObserver(o2);\n    var scrollHandler = initScrollObserver(o2);\n    var viewportResizeHandler = initViewportResizeObserver(o2, {\n        win: currentWindow\n    });\n    var inputHandler = initInputObserver(o2);\n    var mediaInteractionHandler = initMediaInteractionObserver(o2);\n    var styleSheetObserver = function() {};\n    var adoptedStyleSheetObserver = function() {};\n    var styleDeclarationObserver = function() {};\n    var fontObserver = function() {};\n    if (o2.recordDOM) {\n        styleSheetObserver = initStyleSheetObserver(o2, {\n            win: currentWindow\n        });\n        adoptedStyleSheetObserver = initAdoptedStyleSheetObserver(o2, o2.doc);\n        styleDeclarationObserver = initStyleDeclarationObserver(o2, {\n            win: currentWindow\n        });\n        if (o2.collectFonts) {\n            fontObserver = initFontObserver(o2);\n        }\n    }\n    var selectionObserver = initSelectionObserver(o2);\n    var customElementObserver = initCustomElementObserver(o2);\n    var pluginHandlers = [];\n    for(var _iterator = _create_for_of_iterator_helper_loose(o2.plugins), _step; !(_step = _iterator()).done;){\n        var plugin3 = _step.value;\n        pluginHandlers.push(plugin3.observer(plugin3.callback, currentWindow, plugin3.options));\n    }\n    return callbackWrapper(function() {\n        mutationBuffers.forEach(function(b) {\n            return b.reset();\n        });\n        mutationObserver == null ? void 0 : mutationObserver.disconnect();\n        mousemoveHandler();\n        mouseInteractionHandler();\n        scrollHandler();\n        viewportResizeHandler();\n        inputHandler();\n        mediaInteractionHandler();\n        styleSheetObserver();\n        adoptedStyleSheetObserver();\n        styleDeclarationObserver();\n        fontObserver();\n        selectionObserver();\n        customElementObserver();\n        pluginHandlers.forEach(function(h) {\n            return h();\n        });\n    });\n}\nfunction hasNestedCSSRule(prop) {\n    return typeof window[prop] !== \"undefined\";\n}\nfunction canMonkeyPatchNestedCSSRule(prop) {\n    return Boolean(typeof window[prop] !== \"undefined\" && // Note: Generally, this check _shouldn't_ be necessary\n    // However, in some scenarios (e.g. jsdom) this can sometimes fail, so we check for it here\n    window[prop].prototype && \"insertRule\" in window[prop].prototype && \"deleteRule\" in window[prop].prototype);\n}\nvar CrossOriginIframeMirror = /*#__PURE__*/ function() {\n    function CrossOriginIframeMirror(generateIdFn) {\n        __publicField$1(this, \"iframeIdToRemoteIdMap\", /* @__PURE__ */ new WeakMap());\n        __publicField$1(this, \"iframeRemoteIdToIdMap\", /* @__PURE__ */ new WeakMap());\n        this.generateIdFn = generateIdFn;\n    }\n    var _proto = CrossOriginIframeMirror.prototype;\n    _proto.getId = function getId(iframe, remoteId, idToRemoteMap, remoteToIdMap) {\n        var idToRemoteIdMap = idToRemoteMap || this.getIdToRemoteIdMap(iframe);\n        var remoteIdToIdMap = remoteToIdMap || this.getRemoteIdToIdMap(iframe);\n        var id = idToRemoteIdMap.get(remoteId);\n        if (!id) {\n            id = this.generateIdFn();\n            idToRemoteIdMap.set(remoteId, id);\n            remoteIdToIdMap.set(id, remoteId);\n        }\n        return id;\n    };\n    _proto.getIds = function getIds(iframe, remoteId) {\n        var _this = this;\n        var idToRemoteIdMap = this.getIdToRemoteIdMap(iframe);\n        var remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\n        return remoteId.map(function(id) {\n            return _this.getId(iframe, id, idToRemoteIdMap, remoteIdToIdMap);\n        });\n    };\n    _proto.getRemoteId = function getRemoteId(iframe, id, map) {\n        var remoteIdToIdMap = map || this.getRemoteIdToIdMap(iframe);\n        if (typeof id !== \"number\") return id;\n        var remoteId = remoteIdToIdMap.get(id);\n        if (!remoteId) return -1;\n        return remoteId;\n    };\n    _proto.getRemoteIds = function getRemoteIds(iframe, ids) {\n        var _this = this;\n        var remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\n        return ids.map(function(id) {\n            return _this.getRemoteId(iframe, id, remoteIdToIdMap);\n        });\n    };\n    _proto.reset = function reset(iframe) {\n        if (!iframe) {\n            this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap();\n            this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();\n            return;\n        }\n        this.iframeIdToRemoteIdMap.delete(iframe);\n        this.iframeRemoteIdToIdMap.delete(iframe);\n    };\n    _proto.getIdToRemoteIdMap = function getIdToRemoteIdMap(iframe) {\n        var idToRemoteIdMap = this.iframeIdToRemoteIdMap.get(iframe);\n        if (!idToRemoteIdMap) {\n            idToRemoteIdMap = /* @__PURE__ */ new Map();\n            this.iframeIdToRemoteIdMap.set(iframe, idToRemoteIdMap);\n        }\n        return idToRemoteIdMap;\n    };\n    _proto.getRemoteIdToIdMap = function getRemoteIdToIdMap(iframe) {\n        var remoteIdToIdMap = this.iframeRemoteIdToIdMap.get(iframe);\n        if (!remoteIdToIdMap) {\n            remoteIdToIdMap = /* @__PURE__ */ new Map();\n            this.iframeRemoteIdToIdMap.set(iframe, remoteIdToIdMap);\n        }\n        return remoteIdToIdMap;\n    };\n    return CrossOriginIframeMirror;\n}();\nvar IframeManager = /*#__PURE__*/ function() {\n    function IframeManager(options) {\n        __publicField$1(this, \"iframes\", /* @__PURE__ */ new WeakMap());\n        __publicField$1(this, \"crossOriginIframeMap\", /* @__PURE__ */ new WeakMap());\n        __publicField$1(this, \"crossOriginIframeMirror\", new CrossOriginIframeMirror(genId));\n        __publicField$1(this, \"crossOriginIframeStyleMirror\");\n        __publicField$1(this, \"crossOriginIframeRootIdMap\", /* @__PURE__ */ new WeakMap());\n        __publicField$1(this, \"mirror\");\n        __publicField$1(this, \"mutationCb\");\n        __publicField$1(this, \"wrappedEmit\");\n        __publicField$1(this, \"loadListener\");\n        __publicField$1(this, \"stylesheetManager\");\n        __publicField$1(this, \"recordCrossOriginIframes\");\n        this.mutationCb = options.mutationCb;\n        this.wrappedEmit = options.wrappedEmit;\n        this.stylesheetManager = options.stylesheetManager;\n        this.recordCrossOriginIframes = options.recordCrossOriginIframes;\n        this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(this.stylesheetManager.styleMirror.generateId.bind(this.stylesheetManager.styleMirror));\n        this.mirror = options.mirror;\n        if (this.recordCrossOriginIframes) {\n            window.addEventListener(\"message\", this.handleMessage.bind(this));\n        }\n    }\n    var _proto = IframeManager.prototype;\n    _proto.addIframe = function addIframe(iframeEl) {\n        this.iframes.set(iframeEl, true);\n        if (iframeEl.contentWindow) this.crossOriginIframeMap.set(iframeEl.contentWindow, iframeEl);\n    };\n    _proto.addLoadListener = function addLoadListener(cb) {\n        this.loadListener = cb;\n    };\n    _proto.attachIframe = function attachIframe(iframeEl, childSn) {\n        var _a2, _b;\n        this.mutationCb({\n            adds: [\n                {\n                    parentId: this.mirror.getId(iframeEl),\n                    nextId: null,\n                    node: childSn\n                }\n            ],\n            removes: [],\n            texts: [],\n            attributes: [],\n            isAttachIframe: true\n        });\n        if (this.recordCrossOriginIframes) (_a2 = iframeEl.contentWindow) == null ? void 0 : _a2.addEventListener(\"message\", this.handleMessage.bind(this));\n        (_b = this.loadListener) == null ? void 0 : _b.call(this, iframeEl);\n        if (iframeEl.contentDocument && iframeEl.contentDocument.adoptedStyleSheets && iframeEl.contentDocument.adoptedStyleSheets.length > 0) this.stylesheetManager.adoptStyleSheets(iframeEl.contentDocument.adoptedStyleSheets, this.mirror.getId(iframeEl.contentDocument));\n    };\n    _proto.handleMessage = function handleMessage(message) {\n        var crossOriginMessageEvent = message;\n        if (crossOriginMessageEvent.data.type !== \"rrweb\" || // To filter out the rrweb messages which are forwarded by some sites.\n        crossOriginMessageEvent.origin !== crossOriginMessageEvent.data.origin) return;\n        var iframeSourceWindow = message.source;\n        if (!iframeSourceWindow) return;\n        var iframeEl = this.crossOriginIframeMap.get(message.source);\n        if (!iframeEl) return;\n        var transformedEvent = this.transformCrossOriginEvent(iframeEl, crossOriginMessageEvent.data.event);\n        if (transformedEvent) this.wrappedEmit(transformedEvent, crossOriginMessageEvent.data.isCheckout);\n    };\n    _proto.transformCrossOriginEvent = function transformCrossOriginEvent(iframeEl, e2) {\n        var _this = this;\n        var _a2;\n        switch(e2.type){\n            case EventType.FullSnapshot:\n                {\n                    this.crossOriginIframeMirror.reset(iframeEl);\n                    this.crossOriginIframeStyleMirror.reset(iframeEl);\n                    this.replaceIdOnNode(e2.data.node, iframeEl);\n                    var rootId = e2.data.node.id;\n                    this.crossOriginIframeRootIdMap.set(iframeEl, rootId);\n                    this.patchRootIdOnNode(e2.data.node, rootId);\n                    return {\n                        timestamp: e2.timestamp,\n                        type: EventType.IncrementalSnapshot,\n                        data: {\n                            source: IncrementalSource.Mutation,\n                            adds: [\n                                {\n                                    parentId: this.mirror.getId(iframeEl),\n                                    nextId: null,\n                                    node: e2.data.node\n                                }\n                            ],\n                            removes: [],\n                            texts: [],\n                            attributes: [],\n                            isAttachIframe: true\n                        }\n                    };\n                }\n            case EventType.Meta:\n            case EventType.Load:\n            case EventType.DomContentLoaded:\n                {\n                    return false;\n                }\n            case EventType.Plugin:\n                {\n                    return e2;\n                }\n            case EventType.Custom:\n                {\n                    this.replaceIds(e2.data.payload, iframeEl, [\n                        \"id\",\n                        \"parentId\",\n                        \"previousId\",\n                        \"nextId\"\n                    ]);\n                    return e2;\n                }\n            case EventType.IncrementalSnapshot:\n                {\n                    switch(e2.data.source){\n                        case IncrementalSource.Mutation:\n                            {\n                                e2.data.adds.forEach(function(n2) {\n                                    _this.replaceIds(n2, iframeEl, [\n                                        \"parentId\",\n                                        \"nextId\",\n                                        \"previousId\"\n                                    ]);\n                                    _this.replaceIdOnNode(n2.node, iframeEl);\n                                    var rootId = _this.crossOriginIframeRootIdMap.get(iframeEl);\n                                    rootId && _this.patchRootIdOnNode(n2.node, rootId);\n                                });\n                                e2.data.removes.forEach(function(n2) {\n                                    _this.replaceIds(n2, iframeEl, [\n                                        \"parentId\",\n                                        \"id\"\n                                    ]);\n                                });\n                                e2.data.attributes.forEach(function(n2) {\n                                    _this.replaceIds(n2, iframeEl, [\n                                        \"id\"\n                                    ]);\n                                });\n                                e2.data.texts.forEach(function(n2) {\n                                    _this.replaceIds(n2, iframeEl, [\n                                        \"id\"\n                                    ]);\n                                });\n                                return e2;\n                            }\n                        case IncrementalSource.Drag:\n                        case IncrementalSource.TouchMove:\n                        case IncrementalSource.MouseMove:\n                            {\n                                e2.data.positions.forEach(function(p) {\n                                    _this.replaceIds(p, iframeEl, [\n                                        \"id\"\n                                    ]);\n                                });\n                                return e2;\n                            }\n                        case IncrementalSource.ViewportResize:\n                            {\n                                return false;\n                            }\n                        case IncrementalSource.MediaInteraction:\n                        case IncrementalSource.MouseInteraction:\n                        case IncrementalSource.Scroll:\n                        case IncrementalSource.CanvasMutation:\n                        case IncrementalSource.Input:\n                            {\n                                this.replaceIds(e2.data, iframeEl, [\n                                    \"id\"\n                                ]);\n                                return e2;\n                            }\n                        case IncrementalSource.StyleSheetRule:\n                        case IncrementalSource.StyleDeclaration:\n                            {\n                                this.replaceIds(e2.data, iframeEl, [\n                                    \"id\"\n                                ]);\n                                this.replaceStyleIds(e2.data, iframeEl, [\n                                    \"styleId\"\n                                ]);\n                                return e2;\n                            }\n                        case IncrementalSource.Font:\n                            {\n                                return e2;\n                            }\n                        case IncrementalSource.Selection:\n                            {\n                                e2.data.ranges.forEach(function(range) {\n                                    _this.replaceIds(range, iframeEl, [\n                                        \"start\",\n                                        \"end\"\n                                    ]);\n                                });\n                                return e2;\n                            }\n                        case IncrementalSource.AdoptedStyleSheet:\n                            {\n                                this.replaceIds(e2.data, iframeEl, [\n                                    \"id\"\n                                ]);\n                                this.replaceStyleIds(e2.data, iframeEl, [\n                                    \"styleIds\"\n                                ]);\n                                (_a2 = e2.data.styles) == null ? void 0 : _a2.forEach(function(style) {\n                                    _this.replaceStyleIds(style, iframeEl, [\n                                        \"styleId\"\n                                    ]);\n                                });\n                                return e2;\n                            }\n                    }\n                }\n        }\n        return false;\n    };\n    _proto.replace = function replace(iframeMirror, obj, iframeEl, keys) {\n        for(var _iterator = _create_for_of_iterator_helper_loose(keys), _step; !(_step = _iterator()).done;){\n            var key = _step.value;\n            if (!Array.isArray(obj[key]) && typeof obj[key] !== \"number\") continue;\n            if (Array.isArray(obj[key])) {\n                obj[key] = iframeMirror.getIds(iframeEl, obj[key]);\n            } else {\n                obj[key] = iframeMirror.getId(iframeEl, obj[key]);\n            }\n        }\n        return obj;\n    };\n    _proto.replaceIds = function replaceIds(obj, iframeEl, keys) {\n        return this.replace(this.crossOriginIframeMirror, obj, iframeEl, keys);\n    };\n    _proto.replaceStyleIds = function replaceStyleIds(obj, iframeEl, keys) {\n        return this.replace(this.crossOriginIframeStyleMirror, obj, iframeEl, keys);\n    };\n    _proto.replaceIdOnNode = function replaceIdOnNode(node2, iframeEl) {\n        var _this = this;\n        this.replaceIds(node2, iframeEl, [\n            \"id\",\n            \"rootId\"\n        ]);\n        if (\"childNodes\" in node2) {\n            node2.childNodes.forEach(function(child) {\n                _this.replaceIdOnNode(child, iframeEl);\n            });\n        }\n    };\n    _proto.patchRootIdOnNode = function patchRootIdOnNode(node2, rootId) {\n        var _this = this;\n        if (node2.type !== NodeType.Document && !node2.rootId) node2.rootId = rootId;\n        if (\"childNodes\" in node2) {\n            node2.childNodes.forEach(function(child) {\n                _this.patchRootIdOnNode(child, rootId);\n            });\n        }\n    };\n    return IframeManager;\n}();\nvar ShadowDomManager = /*#__PURE__*/ function() {\n    function ShadowDomManager(options) {\n        __publicField$1(this, \"shadowDoms\", /* @__PURE__ */ new WeakSet());\n        __publicField$1(this, \"mutationCb\");\n        __publicField$1(this, \"scrollCb\");\n        __publicField$1(this, \"bypassOptions\");\n        __publicField$1(this, \"mirror\");\n        __publicField$1(this, \"restoreHandlers\", []);\n        this.mutationCb = options.mutationCb;\n        this.scrollCb = options.scrollCb;\n        this.bypassOptions = options.bypassOptions;\n        this.mirror = options.mirror;\n        this.init();\n    }\n    var _proto = ShadowDomManager.prototype;\n    _proto.init = function init() {\n        this.reset();\n        this.patchAttachShadow(Element, document);\n    };\n    _proto.addShadowRoot = function addShadowRoot(shadowRoot2, doc) {\n        var _this = this;\n        if (!isNativeShadowDom(shadowRoot2)) return;\n        if (this.shadowDoms.has(shadowRoot2)) return;\n        this.shadowDoms.add(shadowRoot2);\n        var observer = initMutationObserver(_extends({}, this.bypassOptions, {\n            doc: doc,\n            mutationCb: this.mutationCb,\n            mirror: this.mirror,\n            shadowDomManager: this\n        }), shadowRoot2);\n        this.restoreHandlers.push(function() {\n            return observer.disconnect();\n        });\n        this.restoreHandlers.push(initScrollObserver(_extends({}, this.bypassOptions, {\n            scrollCb: this.scrollCb,\n            // https://gist.github.com/praveenpuglia/0832da687ed5a5d7a0907046c9ef1813\n            // scroll is not allowed to pass the boundary, so we need to listen the shadow document\n            doc: shadowRoot2,\n            mirror: this.mirror\n        })));\n        setTimeout(function() {\n            if (shadowRoot2.adoptedStyleSheets && shadowRoot2.adoptedStyleSheets.length > 0) _this.bypassOptions.stylesheetManager.adoptStyleSheets(shadowRoot2.adoptedStyleSheets, _this.mirror.getId(index.host(shadowRoot2)));\n            _this.restoreHandlers.push(initAdoptedStyleSheetObserver({\n                mirror: _this.mirror,\n                stylesheetManager: _this.bypassOptions.stylesheetManager\n            }, shadowRoot2));\n        }, 0);\n    };\n    /**\n   * Monkey patch 'attachShadow' of an IFrameElement to observe newly added shadow doms.\n   */ _proto.observeAttachShadow = function observeAttachShadow(iframeElement) {\n        if (!iframeElement.contentWindow || !iframeElement.contentDocument) return;\n        this.patchAttachShadow(iframeElement.contentWindow.Element, iframeElement.contentDocument);\n    };\n    /**\n   * Patch 'attachShadow' to observe newly added shadow doms.\n   */ _proto.patchAttachShadow = function patchAttachShadow(element, doc) {\n        var manager = this;\n        this.restoreHandlers.push(patch$2(element.prototype, \"attachShadow\", function(original) {\n            return function(option) {\n                var sRoot = original.call(this, option);\n                var shadowRootEl = index.shadowRoot(this);\n                if (shadowRootEl && inDom(this)) manager.addShadowRoot(shadowRootEl, doc);\n                return sRoot;\n            };\n        }));\n    };\n    _proto.reset = function reset() {\n        this.restoreHandlers.forEach(function(handler) {\n            try {\n                handler();\n            } catch (e2) {}\n        });\n        this.restoreHandlers = [];\n        this.shadowDoms = /* @__PURE__ */ new WeakSet();\n    };\n    return ShadowDomManager;\n}();\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar lookup = typeof Uint8Array === \"undefined\" ? [] : new Uint8Array(256);\nfor(var i$1 = 0; i$1 < chars.length; i$1++){\n    lookup[chars.charCodeAt(i$1)] = i$1;\n}\nvar encode = function encode(arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer), i2, len = bytes.length, base64 = \"\";\n    for(i2 = 0; i2 < len; i2 += 3){\n        base64 += chars[bytes[i2] >> 2];\n        base64 += chars[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];\n        base64 += chars[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];\n        base64 += chars[bytes[i2 + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + \"=\";\n    } else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + \"==\";\n    }\n    return base64;\n};\nvar canvasVarMap = /* @__PURE__ */ new Map();\nfunction variableListFor$1(ctx, ctor) {\n    var contextMap = canvasVarMap.get(ctx);\n    if (!contextMap) {\n        contextMap = /* @__PURE__ */ new Map();\n        canvasVarMap.set(ctx, contextMap);\n    }\n    if (!contextMap.has(ctor)) {\n        contextMap.set(ctor, []);\n    }\n    return contextMap.get(ctor);\n}\nvar saveWebGLVar = function(value, win, ctx) {\n    if (!value || !(isInstanceOfWebGLObject(value, win) || (typeof value === \"undefined\" ? \"undefined\" : _type_of(value)) === \"object\")) return;\n    var name = value.constructor.name;\n    var list2 = variableListFor$1(ctx, name);\n    var index2 = list2.indexOf(value);\n    if (index2 === -1) {\n        index2 = list2.length;\n        list2.push(value);\n    }\n    return index2;\n};\nfunction serializeArg(value, win, ctx) {\n    if (_instanceof(value, Array)) {\n        return value.map(function(arg) {\n            return serializeArg(arg, win, ctx);\n        });\n    } else if (value === null) {\n        return value;\n    } else if (_instanceof(value, Float32Array) || _instanceof(value, Float64Array) || _instanceof(value, Int32Array) || _instanceof(value, Uint32Array) || _instanceof(value, Uint8Array) || _instanceof(value, Uint16Array) || _instanceof(value, Int16Array) || _instanceof(value, Int8Array) || _instanceof(value, Uint8ClampedArray)) {\n        var name = value.constructor.name;\n        return {\n            rr_type: name,\n            args: [\n                Object.values(value)\n            ]\n        };\n    } else if (// SharedArrayBuffer disabled on most browsers due to spectre.\n    // More info: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer/SharedArrayBuffer\n    // value instanceof SharedArrayBuffer ||\n    _instanceof(value, ArrayBuffer)) {\n        var name1 = value.constructor.name;\n        var base64 = encode(value);\n        return {\n            rr_type: name1,\n            base64: base64\n        };\n    } else if (_instanceof(value, DataView)) {\n        var name2 = value.constructor.name;\n        return {\n            rr_type: name2,\n            args: [\n                serializeArg(value.buffer, win, ctx),\n                value.byteOffset,\n                value.byteLength\n            ]\n        };\n    } else if (_instanceof(value, HTMLImageElement)) {\n        var name3 = value.constructor.name;\n        var src = value.src;\n        return {\n            rr_type: name3,\n            src: src\n        };\n    } else if (_instanceof(value, HTMLCanvasElement)) {\n        var name4 = \"HTMLImageElement\";\n        var src1 = value.toDataURL();\n        return {\n            rr_type: name4,\n            src: src1\n        };\n    } else if (_instanceof(value, ImageData)) {\n        var name5 = value.constructor.name;\n        return {\n            rr_type: name5,\n            args: [\n                serializeArg(value.data, win, ctx),\n                value.width,\n                value.height\n            ]\n        };\n    } else if (isInstanceOfWebGLObject(value, win) || (typeof value === \"undefined\" ? \"undefined\" : _type_of(value)) === \"object\") {\n        var name6 = value.constructor.name;\n        var index2 = saveWebGLVar(value, win, ctx);\n        return {\n            rr_type: name6,\n            index: index2\n        };\n    }\n    return value;\n}\nvar serializeArgs = function(args, win, ctx) {\n    return args.map(function(arg) {\n        return serializeArg(arg, win, ctx);\n    });\n};\nvar isInstanceOfWebGLObject = function(value, win) {\n    var webGLConstructorNames = [\n        \"WebGLActiveInfo\",\n        \"WebGLBuffer\",\n        \"WebGLFramebuffer\",\n        \"WebGLProgram\",\n        \"WebGLRenderbuffer\",\n        \"WebGLShader\",\n        \"WebGLShaderPrecisionFormat\",\n        \"WebGLTexture\",\n        \"WebGLUniformLocation\",\n        \"WebGLVertexArrayObject\",\n        // In old Chrome versions, value won't be an instanceof WebGLVertexArrayObject.\n        \"WebGLVertexArrayObjectOES\"\n    ];\n    var supportedWebGLConstructorNames = webGLConstructorNames.filter(function(name) {\n        return typeof win[name] === \"function\";\n    });\n    return Boolean(supportedWebGLConstructorNames.find(function(name) {\n        return _instanceof(value, win[name]);\n    }));\n};\nfunction initCanvas2DMutationObserver(cb, win, blockClass, blockSelector) {\n    var _loop = function() {\n        var prop = _step.value;\n        try {\n            if (typeof win.CanvasRenderingContext2D.prototype[prop] !== \"function\") {\n                return \"continue\";\n            }\n            var restoreHandler = patch$2(win.CanvasRenderingContext2D.prototype, prop, function(original) {\n                return function() {\n                    var _this = this;\n                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                        args[_key] = arguments[_key];\n                    }\n                    if (!isBlocked(this.canvas, blockClass, blockSelector, true)) {\n                        setTimeout(function() {\n                            var recordArgs = serializeArgs(args, win, _this);\n                            cb(_this.canvas, {\n                                type: CanvasContext[\"2D\"],\n                                property: prop,\n                                args: recordArgs\n                            });\n                        }, 0);\n                    }\n                    return original.apply(this, args);\n                };\n            });\n            handlers.push(restoreHandler);\n        } catch (e) {\n            var hookHandler = hookSetter(win.CanvasRenderingContext2D.prototype, prop, {\n                set: function set(v2) {\n                    cb(this.canvas, {\n                        type: CanvasContext[\"2D\"],\n                        property: prop,\n                        args: [\n                            v2\n                        ],\n                        setter: true\n                    });\n                }\n            });\n            handlers.push(hookHandler);\n        }\n    };\n    var handlers = [];\n    var props2D = Object.getOwnPropertyNames(win.CanvasRenderingContext2D.prototype);\n    for(var _iterator = _create_for_of_iterator_helper_loose(props2D), _step; !(_step = _iterator()).done;)_loop();\n    return function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    };\n}\nfunction getNormalizedContextName(contextType) {\n    return contextType === \"experimental-webgl\" ? \"webgl\" : contextType;\n}\nfunction initCanvasContextObserver(win, blockClass, blockSelector, setPreserveDrawingBufferToTrue) {\n    var handlers = [];\n    try {\n        var restoreHandler = patch$2(win.HTMLCanvasElement.prototype, \"getContext\", function(original) {\n            return function(contextType) {\n                for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    args[_key - 1] = arguments[_key];\n                }\n                if (!isBlocked(this, blockClass, blockSelector, true)) {\n                    var ctxName = getNormalizedContextName(contextType);\n                    if (!(\"__context\" in this)) this.__context = ctxName;\n                    if (setPreserveDrawingBufferToTrue && [\n                        \"webgl\",\n                        \"webgl2\"\n                    ].includes(ctxName)) {\n                        if (args[0] && _type_of(args[0]) === \"object\") {\n                            var contextAttributes = args[0];\n                            if (!contextAttributes.preserveDrawingBuffer) {\n                                contextAttributes.preserveDrawingBuffer = true;\n                            }\n                        } else {\n                            args.splice(0, 1, {\n                                preserveDrawingBuffer: true\n                            });\n                        }\n                    }\n                }\n                return original.apply(this, [].concat([\n                    contextType\n                ], args));\n            };\n        });\n        handlers.push(restoreHandler);\n    } catch (e) {\n        console.error(\"failed to patch HTMLCanvasElement.prototype.getContext\");\n    }\n    return function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    };\n}\nfunction patchGLPrototype(prototype, type, cb, blockClass, blockSelector, win) {\n    var _loop = function() {\n        var prop = _step.value;\n        if (//prop.startsWith('get') ||  // e.g. getProgramParameter, but too risky\n        [\n            \"isContextLost\",\n            \"canvas\",\n            \"drawingBufferWidth\",\n            \"drawingBufferHeight\"\n        ].includes(prop)) {\n            return \"continue\";\n        }\n        try {\n            if (typeof prototype[prop] !== \"function\") {\n                return \"continue\";\n            }\n            var restoreHandler = patch$2(prototype, prop, function(original) {\n                return function() {\n                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                        args[_key] = arguments[_key];\n                    }\n                    var result2 = original.apply(this, args);\n                    saveWebGLVar(result2, win, this);\n                    if (\"tagName\" in this.canvas && !isBlocked(this.canvas, blockClass, blockSelector, true)) {\n                        var recordArgs = serializeArgs(args, win, this);\n                        var mutation = {\n                            type: type,\n                            property: prop,\n                            args: recordArgs\n                        };\n                        cb(this.canvas, mutation);\n                    }\n                    return result2;\n                };\n            });\n            handlers.push(restoreHandler);\n        } catch (e) {\n            var hookHandler = hookSetter(prototype, prop, {\n                set: function set(v2) {\n                    cb(this.canvas, {\n                        type: type,\n                        property: prop,\n                        args: [\n                            v2\n                        ],\n                        setter: true\n                    });\n                }\n            });\n            handlers.push(hookHandler);\n        }\n    };\n    var handlers = [];\n    var props = Object.getOwnPropertyNames(prototype);\n    for(var _iterator = _create_for_of_iterator_helper_loose(props), _step; !(_step = _iterator()).done;)_loop();\n    return handlers;\n}\nfunction initCanvasWebGLMutationObserver(cb, win, blockClass, blockSelector) {\n    var _handlers;\n    var handlers = [];\n    (_handlers = handlers).push.apply(_handlers, [].concat(patchGLPrototype(win.WebGLRenderingContext.prototype, CanvasContext.WebGL, cb, blockClass, blockSelector, win)));\n    if (typeof win.WebGL2RenderingContext !== \"undefined\") {\n        var _handlers1;\n        (_handlers1 = handlers).push.apply(_handlers1, [].concat(patchGLPrototype(win.WebGL2RenderingContext.prototype, CanvasContext.WebGL2, cb, blockClass, blockSelector, win)));\n    }\n    return function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    };\n}\nvar encodedJs = \"KGZ1bmN0aW9uKCkgewogICJ1c2Ugc3RyaWN0IjsKICB2YXIgY2hhcnMgPSAiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyI7CiAgdmFyIGxvb2t1cCA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAidW5kZWZpbmVkIiA/IFtdIDogbmV3IFVpbnQ4QXJyYXkoMjU2KTsKICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7CiAgICBsb29rdXBbY2hhcnMuY2hhckNvZGVBdChpKV0gPSBpOwogIH0KICB2YXIgZW5jb2RlID0gZnVuY3Rpb24oYXJyYXlidWZmZXIpIHsKICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSwgaTIsIGxlbiA9IGJ5dGVzLmxlbmd0aCwgYmFzZTY0ID0gIiI7CiAgICBmb3IgKGkyID0gMDsgaTIgPCBsZW47IGkyICs9IDMpIHsKICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kyXSA+PiAyXTsKICAgICAgYmFzZTY0ICs9IGNoYXJzWyhieXRlc1tpMl0gJiAzKSA8PCA0IHwgYnl0ZXNbaTIgKyAxXSA+PiA0XTsKICAgICAgYmFzZTY0ICs9IGNoYXJzWyhieXRlc1tpMiArIDFdICYgMTUpIDw8IDIgfCBieXRlc1tpMiArIDJdID4+IDZdOwogICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaTIgKyAyXSAmIDYzXTsKICAgIH0KICAgIGlmIChsZW4gJSAzID09PSAyKSB7CiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgIj0iOwogICAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7CiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgIj09IjsKICAgIH0KICAgIHJldHVybiBiYXNlNjQ7CiAgfTsKICBjb25zdCBsYXN0QmxvYk1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7CiAgY29uc3QgdHJhbnNwYXJlbnRCbG9iTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTsKICBhc3luYyBmdW5jdGlvbiBnZXRUcmFuc3BhcmVudEJsb2JGb3Iod2lkdGgsIGhlaWdodCwgZGF0YVVSTE9wdGlvbnMpIHsKICAgIGNvbnN0IGlkID0gYCR7d2lkdGh9LSR7aGVpZ2h0fWA7CiAgICBpZiAoIk9mZnNjcmVlbkNhbnZhcyIgaW4gZ2xvYmFsVGhpcykgewogICAgICBpZiAodHJhbnNwYXJlbnRCbG9iTWFwLmhhcyhpZCkpIHJldHVybiB0cmFuc3BhcmVudEJsb2JNYXAuZ2V0KGlkKTsKICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTsKICAgICAgb2Zmc2NyZWVuLmdldENvbnRleHQoIjJkIik7CiAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCBvZmZzY3JlZW4uY29udmVydFRvQmxvYihkYXRhVVJMT3B0aW9ucyk7CiAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgYmxvYi5hcnJheUJ1ZmZlcigpOwogICAgICBjb25zdCBiYXNlNjQgPSBlbmNvZGUoYXJyYXlCdWZmZXIpOwogICAgICB0cmFuc3BhcmVudEJsb2JNYXAuc2V0KGlkLCBiYXNlNjQpOwogICAgICByZXR1cm4gYmFzZTY0OwogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuICIiOwogICAgfQogIH0KICBjb25zdCB3b3JrZXIgPSBzZWxmOwogIHdvcmtlci5vbm1lc3NhZ2UgPSBhc3luYyBmdW5jdGlvbihlKSB7CiAgICBpZiAoIk9mZnNjcmVlbkNhbnZhcyIgaW4gZ2xvYmFsVGhpcykgewogICAgICBjb25zdCB7IGlkLCBiaXRtYXAsIHdpZHRoLCBoZWlnaHQsIGRhdGFVUkxPcHRpb25zIH0gPSBlLmRhdGE7CiAgICAgIGNvbnN0IHRyYW5zcGFyZW50QmFzZTY0ID0gZ2V0VHJhbnNwYXJlbnRCbG9iRm9yKAogICAgICAgIHdpZHRoLAogICAgICAgIGhlaWdodCwKICAgICAgICBkYXRhVVJMT3B0aW9ucwogICAgICApOwogICAgICBjb25zdCBvZmZzY3JlZW4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoLCBoZWlnaHQpOwogICAgICBjb25zdCBjdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dCgiMmQiKTsKICAgICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDApOwogICAgICBiaXRtYXAuY2xvc2UoKTsKICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IG9mZnNjcmVlbi5jb252ZXJ0VG9CbG9iKGRhdGFVUkxPcHRpb25zKTsKICAgICAgY29uc3QgdHlwZSA9IGJsb2IudHlwZTsKICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCBibG9iLmFycmF5QnVmZmVyKCk7CiAgICAgIGNvbnN0IGJhc2U2NCA9IGVuY29kZShhcnJheUJ1ZmZlcik7CiAgICAgIGlmICghbGFzdEJsb2JNYXAuaGFzKGlkKSAmJiBhd2FpdCB0cmFuc3BhcmVudEJhc2U2NCA9PT0gYmFzZTY0KSB7CiAgICAgICAgbGFzdEJsb2JNYXAuc2V0KGlkLCBiYXNlNjQpOwogICAgICAgIHJldHVybiB3b3JrZXIucG9zdE1lc3NhZ2UoeyBpZCB9KTsKICAgICAgfQogICAgICBpZiAobGFzdEJsb2JNYXAuZ2V0KGlkKSA9PT0gYmFzZTY0KSByZXR1cm4gd29ya2VyLnBvc3RNZXNzYWdlKHsgaWQgfSk7CiAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7CiAgICAgICAgaWQsCiAgICAgICAgdHlwZSwKICAgICAgICBiYXNlNjQsCiAgICAgICAgd2lkdGgsCiAgICAgICAgaGVpZ2h0CiAgICAgIH0pOwogICAgICBsYXN0QmxvYk1hcC5zZXQoaWQsIGJhc2U2NCk7CiAgICB9IGVsc2UgewogICAgICByZXR1cm4gd29ya2VyLnBvc3RNZXNzYWdlKHsgaWQ6IGUuZGF0YS5pZCB9KTsKICAgIH0KICB9Owp9KSgpOwovLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZS1iaXRtYXAtZGF0YS11cmwtd29ya2VyLUlKcEM3Z19iLmpzLm1hcAo=\";\nvar decodeBase64 = function(base64) {\n    return Uint8Array.from(atob(base64), function(c2) {\n        return c2.charCodeAt(0);\n    });\n};\nvar blob = typeof window !== \"undefined\" && window.Blob && new Blob([\n    decodeBase64(encodedJs)\n], {\n    type: \"text/javascript;charset=utf-8\"\n});\nfunction WorkerWrapper(options) {\n    var objURL;\n    try {\n        objURL = blob && (window.URL || window.webkitURL).createObjectURL(blob);\n        if (!objURL) throw \"\";\n        var worker = new Worker(objURL, {\n            name: options == null ? void 0 : options.name\n        });\n        worker.addEventListener(\"error\", function() {\n            (window.URL || window.webkitURL).revokeObjectURL(objURL);\n        });\n        return worker;\n    } catch (e2) {\n        return new Worker(\"data:text/javascript;base64,\" + encodedJs, {\n            name: options == null ? void 0 : options.name\n        });\n    } finally{\n        objURL && (window.URL || window.webkitURL).revokeObjectURL(objURL);\n    }\n}\nvar CanvasManager = /*#__PURE__*/ function() {\n    function CanvasManager(options) {\n        var _this = this;\n        __publicField$1(this, \"pendingCanvasMutations\", /* @__PURE__ */ new Map());\n        __publicField$1(this, \"rafStamps\", {\n            latestId: 0,\n            invokeId: null\n        });\n        __publicField$1(this, \"mirror\");\n        __publicField$1(this, \"mutationCb\");\n        __publicField$1(this, \"resetObservers\");\n        __publicField$1(this, \"frozen\", false);\n        __publicField$1(this, \"locked\", false);\n        __publicField$1(this, \"processMutation\", function(target, mutation) {\n            var newFrame = _this.rafStamps.invokeId && _this.rafStamps.latestId !== _this.rafStamps.invokeId;\n            if (newFrame || !_this.rafStamps.invokeId) _this.rafStamps.invokeId = _this.rafStamps.latestId;\n            if (!_this.pendingCanvasMutations.has(target)) {\n                _this.pendingCanvasMutations.set(target, []);\n            }\n            _this.pendingCanvasMutations.get(target).push(mutation);\n        });\n        var _options_sampling = options.sampling, sampling = _options_sampling === void 0 ? \"all\" : _options_sampling, win = options.win, blockClass = options.blockClass, blockSelector = options.blockSelector, recordCanvas = options.recordCanvas, dataURLOptions = options.dataURLOptions;\n        this.mutationCb = options.mutationCb;\n        this.mirror = options.mirror;\n        if (recordCanvas && sampling === \"all\") this.initCanvasMutationObserver(win, blockClass, blockSelector);\n        if (recordCanvas && typeof sampling === \"number\") this.initCanvasFPSObserver(sampling, win, blockClass, blockSelector, {\n            dataURLOptions: dataURLOptions\n        });\n    }\n    var _proto = CanvasManager.prototype;\n    _proto.reset = function reset() {\n        this.pendingCanvasMutations.clear();\n        this.resetObservers && this.resetObservers();\n    };\n    _proto.freeze = function freeze() {\n        this.frozen = true;\n    };\n    _proto.unfreeze = function unfreeze() {\n        this.frozen = false;\n    };\n    _proto.lock = function lock() {\n        this.locked = true;\n    };\n    _proto.unlock = function unlock() {\n        this.locked = false;\n    };\n    _proto.initCanvasFPSObserver = function initCanvasFPSObserver(fps, win, blockClass, blockSelector, options) {\n        var _this = this;\n        var canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector, true);\n        var snapshotInProgressMap = /* @__PURE__ */ new Map();\n        var worker = new WorkerWrapper();\n        worker.onmessage = function(e2) {\n            var id = e2.data.id;\n            snapshotInProgressMap.set(id, false);\n            if (!(\"base64\" in e2.data)) return;\n            var _e2_data = e2.data, base64 = _e2_data.base64, type = _e2_data.type, width = _e2_data.width, height = _e2_data.height;\n            _this.mutationCb({\n                id: id,\n                type: CanvasContext[\"2D\"],\n                commands: [\n                    {\n                        property: \"clearRect\",\n                        // wipe canvas\n                        args: [\n                            0,\n                            0,\n                            width,\n                            height\n                        ]\n                    },\n                    {\n                        property: \"drawImage\",\n                        // draws (semi-transparent) image\n                        args: [\n                            {\n                                rr_type: \"ImageBitmap\",\n                                args: [\n                                    {\n                                        rr_type: \"Blob\",\n                                        data: [\n                                            {\n                                                rr_type: \"ArrayBuffer\",\n                                                base64: base64\n                                            }\n                                        ],\n                                        type: type\n                                    }\n                                ]\n                            },\n                            0,\n                            0\n                        ]\n                    }\n                ]\n            });\n        };\n        var timeBetweenSnapshots = 1e3 / fps;\n        var lastSnapshotTime = 0;\n        var rafId;\n        var getCanvas = function() {\n            var matchedCanvas = [];\n            win.document.querySelectorAll(\"canvas\").forEach(function(canvas) {\n                if (!isBlocked(canvas, blockClass, blockSelector, true)) {\n                    matchedCanvas.push(canvas);\n                }\n            });\n            return matchedCanvas;\n        };\n        var takeCanvasSnapshots = function(timestamp) {\n            if (lastSnapshotTime && timestamp - lastSnapshotTime < timeBetweenSnapshots) {\n                rafId = requestAnimationFrame(takeCanvasSnapshots);\n                return;\n            }\n            lastSnapshotTime = timestamp;\n            var _this1 = _this;\n            getCanvas().forEach(/*#__PURE__*/ _async_to_generator(function(canvas) {\n                var _a2, id, context, bitmap;\n                return _ts_generator(this, function(_state) {\n                    switch(_state.label){\n                        case 0:\n                            id = _this1.mirror.getId(canvas);\n                            if (snapshotInProgressMap.get(id)) return [\n                                2\n                            ];\n                            if (canvas.width === 0 || canvas.height === 0) return [\n                                2\n                            ];\n                            snapshotInProgressMap.set(id, true);\n                            if ([\n                                \"webgl\",\n                                \"webgl2\"\n                            ].includes(canvas.__context)) {\n                                context = canvas.getContext(canvas.__context);\n                                if (((_a2 = context == null ? void 0 : context.getContextAttributes()) == null ? void 0 : _a2.preserveDrawingBuffer) === false) {\n                                    context.clear(context.COLOR_BUFFER_BIT);\n                                }\n                            }\n                            return [\n                                4,\n                                createImageBitmap(canvas)\n                            ];\n                        case 1:\n                            bitmap = _state.sent();\n                            worker.postMessage({\n                                id: id,\n                                bitmap: bitmap,\n                                width: canvas.width,\n                                height: canvas.height,\n                                dataURLOptions: options.dataURLOptions\n                            }, [\n                                bitmap\n                            ]);\n                            return [\n                                2\n                            ];\n                    }\n                });\n            }));\n            rafId = requestAnimationFrame(takeCanvasSnapshots);\n        };\n        rafId = requestAnimationFrame(takeCanvasSnapshots);\n        this.resetObservers = function() {\n            canvasContextReset();\n            cancelAnimationFrame(rafId);\n        };\n    };\n    _proto.initCanvasMutationObserver = function initCanvasMutationObserver(win, blockClass, blockSelector) {\n        this.startRAFTimestamping();\n        this.startPendingCanvasMutationFlusher();\n        var canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector, false);\n        var canvas2DReset = initCanvas2DMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector);\n        var canvasWebGL1and2Reset = initCanvasWebGLMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector);\n        this.resetObservers = function() {\n            canvasContextReset();\n            canvas2DReset();\n            canvasWebGL1and2Reset();\n        };\n    };\n    _proto.startPendingCanvasMutationFlusher = function startPendingCanvasMutationFlusher() {\n        var _this = this;\n        requestAnimationFrame(function() {\n            return _this.flushPendingCanvasMutations();\n        });\n    };\n    _proto.startRAFTimestamping = function startRAFTimestamping() {\n        var _this = this;\n        var setLatestRAFTimestamp = function(timestamp) {\n            _this.rafStamps.latestId = timestamp;\n            requestAnimationFrame(setLatestRAFTimestamp);\n        };\n        requestAnimationFrame(setLatestRAFTimestamp);\n    };\n    _proto.flushPendingCanvasMutations = function flushPendingCanvasMutations() {\n        var _this = this;\n        this.pendingCanvasMutations.forEach(function(_values, canvas) {\n            var id = _this.mirror.getId(canvas);\n            _this.flushPendingCanvasMutationFor(canvas, id);\n        });\n        requestAnimationFrame(function() {\n            return _this.flushPendingCanvasMutations();\n        });\n    };\n    _proto.flushPendingCanvasMutationFor = function flushPendingCanvasMutationFor(canvas, id) {\n        if (this.frozen || this.locked) {\n            return;\n        }\n        var valuesWithType = this.pendingCanvasMutations.get(canvas);\n        if (!valuesWithType || id === -1) return;\n        var values = valuesWithType.map(function(value) {\n            value.type; var rest = _object_without_properties_loose(value, [\n                \"type\"\n            ]);\n            return rest;\n        });\n        var type = valuesWithType[0].type;\n        this.mutationCb({\n            id: id,\n            type: type,\n            commands: values\n        });\n        this.pendingCanvasMutations.delete(canvas);\n    };\n    return CanvasManager;\n}();\nvar StylesheetManager = /*#__PURE__*/ function() {\n    function StylesheetManager(options) {\n        __publicField$1(this, \"trackedLinkElements\", /* @__PURE__ */ new WeakSet());\n        __publicField$1(this, \"mutationCb\");\n        __publicField$1(this, \"adoptedStyleSheetCb\");\n        __publicField$1(this, \"styleMirror\", new StyleSheetMirror());\n        this.mutationCb = options.mutationCb;\n        this.adoptedStyleSheetCb = options.adoptedStyleSheetCb;\n    }\n    var _proto = StylesheetManager.prototype;\n    _proto.attachLinkElement = function attachLinkElement(linkEl, childSn) {\n        if (\"_cssText\" in childSn.attributes) this.mutationCb({\n            adds: [],\n            removes: [],\n            texts: [],\n            attributes: [\n                {\n                    id: childSn.id,\n                    attributes: childSn.attributes\n                }\n            ]\n        });\n        this.trackLinkElement(linkEl);\n    };\n    _proto.trackLinkElement = function trackLinkElement(linkEl) {\n        if (this.trackedLinkElements.has(linkEl)) return;\n        this.trackedLinkElements.add(linkEl);\n        this.trackStylesheetInLinkElement(linkEl);\n    };\n    _proto.adoptStyleSheets = function adoptStyleSheets(sheets, hostId) {\n        var _this, _loop = function() {\n            var sheet = _step.value;\n            var styleId = void 0;\n            if (!_this.styleMirror.has(sheet)) {\n                styleId = _this.styleMirror.add(sheet);\n                styles.push({\n                    styleId: styleId,\n                    rules: Array.from(sheet.rules || CSSRule, function(r2, index2) {\n                        return {\n                            rule: stringifyRule(r2, sheet.href),\n                            index: index2\n                        };\n                    })\n                });\n            } else styleId = _this.styleMirror.getId(sheet);\n            adoptedStyleSheetData.styleIds.push(styleId);\n        };\n        if (sheets.length === 0) return;\n        var adoptedStyleSheetData = {\n            id: hostId,\n            styleIds: []\n        };\n        var styles = [];\n        for(var _iterator = _create_for_of_iterator_helper_loose(sheets), _step; !(_step = _iterator()).done;)_this = this, _loop();\n        if (styles.length > 0) adoptedStyleSheetData.styles = styles;\n        this.adoptedStyleSheetCb(adoptedStyleSheetData);\n    };\n    _proto.reset = function reset() {\n        this.styleMirror.reset();\n        this.trackedLinkElements = /* @__PURE__ */ new WeakSet();\n    };\n    // TODO: take snapshot on stylesheet reload by applying event listener\n    _proto.trackStylesheetInLinkElement = function trackStylesheetInLinkElement(_linkEl) {};\n    return StylesheetManager;\n}();\nvar ProcessedNodeManager = /*#__PURE__*/ function() {\n    function ProcessedNodeManager() {\n        __publicField$1(this, \"nodeMap\", /* @__PURE__ */ new WeakMap());\n        __publicField$1(this, \"active\", false);\n    }\n    var _proto = ProcessedNodeManager.prototype;\n    _proto.inOtherBuffer = function inOtherBuffer(node2, thisBuffer) {\n        var buffers = this.nodeMap.get(node2);\n        return buffers && Array.from(buffers).some(function(buffer) {\n            return buffer !== thisBuffer;\n        });\n    };\n    _proto.add = function add(node2, buffer) {\n        var _this = this;\n        if (!this.active) {\n            this.active = true;\n            requestAnimationFrame(function() {\n                _this.nodeMap = /* @__PURE__ */ new WeakMap();\n                _this.active = false;\n            });\n        }\n        this.nodeMap.set(node2, (this.nodeMap.get(node2) || /* @__PURE__ */ new Set()).add(buffer));\n    };\n    _proto.destroy = function destroy() {};\n    return ProcessedNodeManager;\n}();\nvar wrappedEmit;\nvar takeFullSnapshot$1;\nvar canvasManager;\nvar recording = false;\ntry {\n    if (Array.from([\n        1\n    ], function(x2) {\n        return x2 * 2;\n    })[0] !== 2) {\n        var cleanFrame = document.createElement(\"iframe\");\n        document.body.appendChild(cleanFrame);\n        Array.from = ((_a = cleanFrame.contentWindow) == null ? void 0 : _a.Array.from) || Array.from;\n        document.body.removeChild(cleanFrame);\n    }\n} catch (err) {\n    console.debug(\"Unable to override Array.from\", err);\n}\nvar mirror = createMirror$2();\nfunction record(options) {\n    if (options === void 0) options = {};\n    var emit = options.emit, checkoutEveryNms = options.checkoutEveryNms, checkoutEveryNth = options.checkoutEveryNth, _options_blockClass = options.blockClass, blockClass = _options_blockClass === void 0 ? \"rr-block\" : _options_blockClass, _options_blockSelector = options.blockSelector, blockSelector = _options_blockSelector === void 0 ? null : _options_blockSelector, _options_ignoreClass = options.ignoreClass, ignoreClass = _options_ignoreClass === void 0 ? \"rr-ignore\" : _options_ignoreClass, _options_ignoreSelector = options.ignoreSelector, ignoreSelector = _options_ignoreSelector === void 0 ? null : _options_ignoreSelector, _options_maskTextClass = options.maskTextClass, maskTextClass = _options_maskTextClass === void 0 ? \"rr-mask\" : _options_maskTextClass, _options_maskTextSelector = options.maskTextSelector, maskTextSelector = _options_maskTextSelector === void 0 ? null : _options_maskTextSelector, _options_inlineStylesheet = options.inlineStylesheet, inlineStylesheet = _options_inlineStylesheet === void 0 ? true : _options_inlineStylesheet, maskAllInputs = options.maskAllInputs, _maskInputOptions = options.maskInputOptions, _slimDOMOptions = options.slimDOMOptions, maskInputFn = options.maskInputFn, maskTextFn = options.maskTextFn, hooks = options.hooks, packFn = options.packFn, _options_sampling = options.sampling, sampling = _options_sampling === void 0 ? {} : _options_sampling, _options_dataURLOptions = options.dataURLOptions, dataURLOptions = _options_dataURLOptions === void 0 ? {} : _options_dataURLOptions, mousemoveWait = options.mousemoveWait, _options_recordDOM = options.recordDOM, recordDOM = _options_recordDOM === void 0 ? true : _options_recordDOM, _options_recordCanvas = options.recordCanvas, recordCanvas = _options_recordCanvas === void 0 ? false : _options_recordCanvas, _options_recordCrossOriginIframes = options.recordCrossOriginIframes, recordCrossOriginIframes = _options_recordCrossOriginIframes === void 0 ? false : _options_recordCrossOriginIframes, _options_recordAfter = options.recordAfter, recordAfter = _options_recordAfter === void 0 ? options.recordAfter === \"DOMContentLoaded\" ? options.recordAfter : \"load\" : _options_recordAfter, _options_userTriggeredOnInput = options.userTriggeredOnInput, userTriggeredOnInput = _options_userTriggeredOnInput === void 0 ? false : _options_userTriggeredOnInput, _options_collectFonts = options.collectFonts, collectFonts = _options_collectFonts === void 0 ? false : _options_collectFonts, _options_inlineImages = options.inlineImages, inlineImages = _options_inlineImages === void 0 ? false : _options_inlineImages, plugins = options.plugins, _options_keepIframeSrcFn = options.keepIframeSrcFn, keepIframeSrcFn = _options_keepIframeSrcFn === void 0 ? function() {\n        return false;\n    } : _options_keepIframeSrcFn, _options_ignoreCSSAttributes = options.ignoreCSSAttributes, ignoreCSSAttributes = _options_ignoreCSSAttributes === void 0 ? /* @__PURE__ */ new Set([]) : _options_ignoreCSSAttributes, errorHandler2 = options.errorHandler;\n    registerErrorHandler(errorHandler2);\n    var inEmittingFrame = recordCrossOriginIframes ? window.parent === window : true;\n    var passEmitsToParent = false;\n    if (!inEmittingFrame) {\n        try {\n            if (window.parent.document) {\n                passEmitsToParent = false;\n            }\n        } catch (e2) {\n            passEmitsToParent = true;\n        }\n    }\n    if (inEmittingFrame && !emit) {\n        throw new Error(\"emit function is required\");\n    }\n    if (!inEmittingFrame && !passEmitsToParent) {\n        return function() {};\n    }\n    if (mousemoveWait !== void 0 && sampling.mousemove === void 0) {\n        sampling.mousemove = mousemoveWait;\n    }\n    mirror.reset();\n    var maskInputOptions = maskAllInputs === true ? {\n        color: true,\n        date: true,\n        \"datetime-local\": true,\n        email: true,\n        month: true,\n        number: true,\n        range: true,\n        search: true,\n        tel: true,\n        text: true,\n        time: true,\n        url: true,\n        week: true,\n        textarea: true,\n        select: true,\n        password: true,\n        hidden: true\n    } : _maskInputOptions !== void 0 ? _maskInputOptions : {\n        password: true\n    };\n    var slimDOMOptions = _slimDOMOptions === true || _slimDOMOptions === \"all\" ? {\n        script: true,\n        comment: true,\n        headFavicon: true,\n        headWhitespace: true,\n        headMetaSocial: true,\n        headMetaRobots: true,\n        headMetaHttpEquiv: true,\n        headMetaVerification: true,\n        // the following are off for slimDOMOptions === true,\n        // as they destroy some (hidden) info:\n        headMetaAuthorship: _slimDOMOptions === \"all\",\n        headMetaDescKeywords: _slimDOMOptions === \"all\",\n        headTitleMutations: _slimDOMOptions === \"all\"\n    } : _slimDOMOptions ? _slimDOMOptions : {};\n    polyfill$1();\n    var lastFullSnapshotEvent;\n    var incrementalSnapshotCount = 0;\n    var eventProcessor = function(e2) {\n        for(var _iterator = _create_for_of_iterator_helper_loose(plugins || []), _step; !(_step = _iterator()).done;){\n            var plugin3 = _step.value;\n            if (plugin3.eventProcessor) {\n                e2 = plugin3.eventProcessor(e2);\n            }\n        }\n        if (packFn && // Disable packing events which will be emitted to parent frames.\n        !passEmitsToParent) {\n            e2 = packFn(e2);\n        }\n        return e2;\n    };\n    wrappedEmit = function(r2, isCheckout) {\n        var _a2;\n        var e2 = r2;\n        e2.timestamp = nowTimestamp();\n        if (((_a2 = mutationBuffers[0]) == null ? void 0 : _a2.isFrozen()) && e2.type !== EventType.FullSnapshot && !(e2.type === EventType.IncrementalSnapshot && e2.data.source === IncrementalSource.Mutation)) {\n            mutationBuffers.forEach(function(buf) {\n                return buf.unfreeze();\n            });\n        }\n        if (inEmittingFrame) {\n            emit == null ? void 0 : emit(eventProcessor(e2), isCheckout);\n        } else if (passEmitsToParent) {\n            var message = {\n                type: \"rrweb\",\n                event: eventProcessor(e2),\n                origin: window.location.origin,\n                isCheckout: isCheckout\n            };\n            window.parent.postMessage(message, \"*\");\n        }\n        if (e2.type === EventType.FullSnapshot) {\n            lastFullSnapshotEvent = e2;\n            incrementalSnapshotCount = 0;\n        } else if (e2.type === EventType.IncrementalSnapshot) {\n            if (e2.data.source === IncrementalSource.Mutation && e2.data.isAttachIframe) {\n                return;\n            }\n            incrementalSnapshotCount++;\n            var exceedCount = checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;\n            var exceedTime = checkoutEveryNms && e2.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;\n            if (exceedCount || exceedTime) {\n                takeFullSnapshot$1(true);\n            }\n        }\n    };\n    var wrappedMutationEmit = function(m) {\n        wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: _extends({\n                source: IncrementalSource.Mutation\n            }, m)\n        });\n    };\n    var wrappedScrollEmit = function(p) {\n        return wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: _extends({\n                source: IncrementalSource.Scroll\n            }, p)\n        });\n    };\n    var wrappedCanvasMutationEmit = function(p) {\n        return wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: _extends({\n                source: IncrementalSource.CanvasMutation\n            }, p)\n        });\n    };\n    var wrappedAdoptedStyleSheetEmit = function(a2) {\n        return wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: _extends({\n                source: IncrementalSource.AdoptedStyleSheet\n            }, a2)\n        });\n    };\n    var stylesheetManager = new StylesheetManager({\n        mutationCb: wrappedMutationEmit,\n        adoptedStyleSheetCb: wrappedAdoptedStyleSheetEmit\n    });\n    var iframeManager = new IframeManager({\n        mirror: mirror,\n        mutationCb: wrappedMutationEmit,\n        stylesheetManager: stylesheetManager,\n        recordCrossOriginIframes: recordCrossOriginIframes,\n        wrappedEmit: wrappedEmit\n    });\n    for(var _iterator = _create_for_of_iterator_helper_loose(plugins || []), _step; !(_step = _iterator()).done;){\n        var plugin3 = _step.value;\n        if (plugin3.getMirror) plugin3.getMirror({\n            nodeMirror: mirror,\n            crossOriginIframeMirror: iframeManager.crossOriginIframeMirror,\n            crossOriginIframeStyleMirror: iframeManager.crossOriginIframeStyleMirror\n        });\n    }\n    var processedNodeManager = new ProcessedNodeManager();\n    canvasManager = new CanvasManager({\n        recordCanvas: recordCanvas,\n        mutationCb: wrappedCanvasMutationEmit,\n        win: window,\n        blockClass: blockClass,\n        blockSelector: blockSelector,\n        mirror: mirror,\n        sampling: sampling.canvas,\n        dataURLOptions: dataURLOptions\n    });\n    var shadowDomManager = new ShadowDomManager({\n        mutationCb: wrappedMutationEmit,\n        scrollCb: wrappedScrollEmit,\n        bypassOptions: {\n            blockClass: blockClass,\n            blockSelector: blockSelector,\n            maskTextClass: maskTextClass,\n            maskTextSelector: maskTextSelector,\n            inlineStylesheet: inlineStylesheet,\n            maskInputOptions: maskInputOptions,\n            dataURLOptions: dataURLOptions,\n            maskTextFn: maskTextFn,\n            maskInputFn: maskInputFn,\n            recordCanvas: recordCanvas,\n            inlineImages: inlineImages,\n            sampling: sampling,\n            slimDOMOptions: slimDOMOptions,\n            iframeManager: iframeManager,\n            stylesheetManager: stylesheetManager,\n            canvasManager: canvasManager,\n            keepIframeSrcFn: keepIframeSrcFn,\n            processedNodeManager: processedNodeManager\n        },\n        mirror: mirror\n    });\n    takeFullSnapshot$1 = function(isCheckout) {\n        if (isCheckout === void 0) isCheckout = false;\n        if (!recordDOM) {\n            return;\n        }\n        wrappedEmit({\n            type: EventType.Meta,\n            data: {\n                href: window.location.href,\n                width: getWindowWidth(),\n                height: getWindowHeight()\n            }\n        }, isCheckout);\n        stylesheetManager.reset();\n        shadowDomManager.init();\n        mutationBuffers.forEach(function(buf) {\n            return buf.lock();\n        });\n        var node2 = snapshot(document, {\n            mirror: mirror,\n            blockClass: blockClass,\n            blockSelector: blockSelector,\n            maskTextClass: maskTextClass,\n            maskTextSelector: maskTextSelector,\n            inlineStylesheet: inlineStylesheet,\n            maskAllInputs: maskInputOptions,\n            maskTextFn: maskTextFn,\n            maskInputFn: maskInputFn,\n            slimDOM: slimDOMOptions,\n            dataURLOptions: dataURLOptions,\n            recordCanvas: recordCanvas,\n            inlineImages: inlineImages,\n            onSerialize: function(n2) {\n                if (isSerializedIframe(n2, mirror)) {\n                    iframeManager.addIframe(n2);\n                }\n                if (isSerializedStylesheet(n2, mirror)) {\n                    stylesheetManager.trackLinkElement(n2);\n                }\n                if (hasShadowRoot(n2)) {\n                    shadowDomManager.addShadowRoot(index.shadowRoot(n2), document);\n                }\n            },\n            onIframeLoad: function(iframe, childSn) {\n                iframeManager.attachIframe(iframe, childSn);\n                shadowDomManager.observeAttachShadow(iframe);\n            },\n            onStylesheetLoad: function(linkEl, childSn) {\n                stylesheetManager.attachLinkElement(linkEl, childSn);\n            },\n            keepIframeSrcFn: keepIframeSrcFn\n        });\n        if (!node2) {\n            return console.warn(\"Failed to snapshot the document\");\n        }\n        wrappedEmit({\n            type: EventType.FullSnapshot,\n            data: {\n                node: node2,\n                initialOffset: getWindowScroll(window)\n            }\n        }, isCheckout);\n        mutationBuffers.forEach(function(buf) {\n            return buf.unlock();\n        });\n        if (document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0) stylesheetManager.adoptStyleSheets(document.adoptedStyleSheets, mirror.getId(document));\n    };\n    try {\n        var handlers = [];\n        var observe = function(doc) {\n            var _a2;\n            return callbackWrapper(initObservers)({\n                mutationCb: wrappedMutationEmit,\n                mousemoveCb: function(positions, source) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: {\n                            source: source,\n                            positions: positions\n                        }\n                    });\n                },\n                mouseInteractionCb: function(d) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.MouseInteraction\n                        }, d)\n                    });\n                },\n                scrollCb: wrappedScrollEmit,\n                viewportResizeCb: function(d) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.ViewportResize\n                        }, d)\n                    });\n                },\n                inputCb: function(v2) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.Input\n                        }, v2)\n                    });\n                },\n                mediaInteractionCb: function(p) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.MediaInteraction\n                        }, p)\n                    });\n                },\n                styleSheetRuleCb: function(r2) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.StyleSheetRule\n                        }, r2)\n                    });\n                },\n                styleDeclarationCb: function(r2) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.StyleDeclaration\n                        }, r2)\n                    });\n                },\n                canvasMutationCb: wrappedCanvasMutationEmit,\n                fontCb: function(p) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.Font\n                        }, p)\n                    });\n                },\n                selectionCb: function(p) {\n                    wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.Selection\n                        }, p)\n                    });\n                },\n                customElementCb: function(c2) {\n                    wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.CustomElement\n                        }, c2)\n                    });\n                },\n                blockClass: blockClass,\n                ignoreClass: ignoreClass,\n                ignoreSelector: ignoreSelector,\n                maskTextClass: maskTextClass,\n                maskTextSelector: maskTextSelector,\n                maskInputOptions: maskInputOptions,\n                inlineStylesheet: inlineStylesheet,\n                sampling: sampling,\n                recordDOM: recordDOM,\n                recordCanvas: recordCanvas,\n                inlineImages: inlineImages,\n                userTriggeredOnInput: userTriggeredOnInput,\n                collectFonts: collectFonts,\n                doc: doc,\n                maskInputFn: maskInputFn,\n                maskTextFn: maskTextFn,\n                keepIframeSrcFn: keepIframeSrcFn,\n                blockSelector: blockSelector,\n                slimDOMOptions: slimDOMOptions,\n                dataURLOptions: dataURLOptions,\n                mirror: mirror,\n                iframeManager: iframeManager,\n                stylesheetManager: stylesheetManager,\n                shadowDomManager: shadowDomManager,\n                processedNodeManager: processedNodeManager,\n                canvasManager: canvasManager,\n                ignoreCSSAttributes: ignoreCSSAttributes,\n                plugins: ((_a2 = plugins == null ? void 0 : plugins.filter(function(p) {\n                    return p.observer;\n                })) == null ? void 0 : _a2.map(function(p) {\n                    return {\n                        observer: p.observer,\n                        options: p.options,\n                        callback: function(payload) {\n                            return wrappedEmit({\n                                type: EventType.Plugin,\n                                data: {\n                                    plugin: p.name,\n                                    payload: payload\n                                }\n                            });\n                        }\n                    };\n                })) || []\n            }, hooks);\n        };\n        iframeManager.addLoadListener(function(iframeEl) {\n            try {\n                handlers.push(observe(iframeEl.contentDocument));\n            } catch (error) {\n                console.warn(error);\n            }\n        });\n        var init = function() {\n            takeFullSnapshot$1();\n            handlers.push(observe(document));\n            recording = true;\n        };\n        if (document.readyState === \"interactive\" || document.readyState === \"complete\") {\n            init();\n        } else {\n            handlers.push(on(\"DOMContentLoaded\", function() {\n                wrappedEmit({\n                    type: EventType.DomContentLoaded,\n                    data: {}\n                });\n                if (recordAfter === \"DOMContentLoaded\") init();\n            }));\n            handlers.push(on(\"load\", function() {\n                wrappedEmit({\n                    type: EventType.Load,\n                    data: {}\n                });\n                if (recordAfter === \"load\") init();\n            }, window));\n        }\n        return function() {\n            handlers.forEach(function(handler) {\n                try {\n                    handler();\n                } catch (error) {\n                    var msg = String(error).toLowerCase();\n                    if (!msg.includes(\"cross-origin\")) {\n                        console.warn(error);\n                    }\n                }\n            });\n            processedNodeManager.destroy();\n            recording = false;\n            unregisterErrorHandler();\n        };\n    } catch (error) {\n        console.warn(error);\n    }\n}\nrecord.addCustomEvent = function(tag, payload) {\n    if (!recording) {\n        throw new Error(\"please add custom event after start recording\");\n    }\n    wrappedEmit({\n        type: EventType.Custom,\n        data: {\n            tag: tag,\n            payload: payload\n        }\n    });\n};\nrecord.freezePage = function() {\n    mutationBuffers.forEach(function(buf) {\n        return buf.freeze();\n    });\n};\nrecord.takeFullSnapshot = function(isCheckout) {\n    if (!recording) {\n        throw new Error(\"please take full snapshot after start recording\");\n    }\n    takeFullSnapshot$1(isCheckout);\n};\nrecord.mirror = mirror;\nvar n;\n!function(t2) {\n    t2[t2.NotStarted = 0] = \"NotStarted\", t2[t2.Running = 1] = \"Running\", t2[t2.Stopped = 2] = \"Stopped\";\n}(n || (n = {}));\nrecord.addCustomEvent;\nrecord.freezePage;\nrecord.takeFullSnapshot;\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function(obj, key, value) {\n    return key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: value\n    }) : obj[key] = value;\n};\nvar __publicField = function(obj, key, value) {\n    return __defNormalProp(obj, (typeof key === \"undefined\" ? \"undefined\" : _type_of(key)) !== \"symbol\" ? key + \"\" : key, value);\n};\nfunction patch(source, name, replacement) {\n    try {\n        if (!(name in source)) {\n            return function() {};\n        }\n        var original = source[name];\n        var wrapped = replacement(original);\n        if (typeof wrapped === \"function\") {\n            wrapped.prototype = wrapped.prototype || {};\n            Object.defineProperties(wrapped, {\n                __rrweb_original__: {\n                    enumerable: false,\n                    value: original\n                }\n            });\n        }\n        source[name] = wrapped;\n        return function() {\n            source[name] = original;\n        };\n    } catch (e) {\n        return function() {};\n    }\n}\nvar StackFrame = /*#__PURE__*/ function() {\n    function StackFrame(obj) {\n        __publicField(this, \"fileName\");\n        __publicField(this, \"functionName\");\n        __publicField(this, \"lineNumber\");\n        __publicField(this, \"columnNumber\");\n        this.fileName = obj.fileName || \"\";\n        this.functionName = obj.functionName || \"\";\n        this.lineNumber = obj.lineNumber;\n        this.columnNumber = obj.columnNumber;\n    }\n    var _proto = StackFrame.prototype;\n    _proto.toString = function toString() {\n        var lineNumber = this.lineNumber || \"\";\n        var columnNumber = this.columnNumber || \"\";\n        if (this.functionName) return this.functionName + \" (\" + this.fileName + \":\" + lineNumber + \":\" + columnNumber + \")\";\n        return this.fileName + \":\" + lineNumber + \":\" + columnNumber;\n    };\n    return StackFrame;\n}();\nvar FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+:\\d+/;\nvar CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m;\nvar SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code])?$/;\nvar ErrorStackParser = {\n    /**\n   * Given an Error object, extract the most information from it.\n   */ parse: function parse(error) {\n        if (!error) {\n            return [];\n        }\n        if (// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        typeof error.stacktrace !== \"undefined\" || // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        typeof error[\"opera#sourceloc\"] !== \"undefined\") {\n            return this.parseOpera(error);\n        } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n            return this.parseV8OrIE(error);\n        } else if (error.stack) {\n            return this.parseFFOrSafari(error);\n        } else {\n            console.warn(\"[console-record-plugin]: Failed to parse error object:\", error);\n            return [];\n        }\n    },\n    // Separate line and column numbers from a string of the form: (URI:Line:Column)\n    extractLocation: function extractLocation(urlLike) {\n        if (urlLike.indexOf(\":\") === -1) {\n            return [\n                urlLike\n            ];\n        }\n        var regExp = /(.+?)(?::(\\d+))?(?::(\\d+))?$/;\n        var parts = regExp.exec(urlLike.replace(/[()]/g, \"\"));\n        if (!parts) throw new Error(\"Cannot parse given url: \" + urlLike);\n        return [\n            parts[1],\n            parts[2] || void 0,\n            parts[3] || void 0\n        ];\n    },\n    parseV8OrIE: function parseV8OrIE(error) {\n        var filtered = error.stack.split(\"\\n\").filter(function(line) {\n            return !!line.match(CHROME_IE_STACK_REGEXP);\n        }, this);\n        return filtered.map(function(line) {\n            if (line.indexOf(\"(eval \") > -1) {\n                line = line.replace(/eval code/g, \"eval\").replace(/(\\(eval at [^()]*)|(\\),.*$)/g, \"\");\n            }\n            var sanitizedLine = line.replace(/^\\s+/, \"\").replace(/\\(eval code/g, \"(\");\n            var location = sanitizedLine.match(/ (\\((.+):(\\d+):(\\d+)\\)$)/);\n            sanitizedLine = location ? sanitizedLine.replace(location[0], \"\") : sanitizedLine;\n            var tokens = sanitizedLine.split(/\\s+/).slice(1);\n            var locationParts = this.extractLocation(location ? location[1] : tokens.pop());\n            var functionName = tokens.join(\" \") || void 0;\n            var fileName = [\n                \"eval\",\n                \"<anonymous>\"\n            ].indexOf(locationParts[0]) > -1 ? void 0 : locationParts[0];\n            return new StackFrame({\n                functionName: functionName,\n                fileName: fileName,\n                lineNumber: locationParts[1],\n                columnNumber: locationParts[2]\n            });\n        }, this);\n    },\n    parseFFOrSafari: function parseFFOrSafari(error) {\n        var filtered = error.stack.split(\"\\n\").filter(function(line) {\n            return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n        }, this);\n        return filtered.map(function(line) {\n            if (line.indexOf(\" > eval\") > -1) {\n                line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g, \":$1\");\n            }\n            if (line.indexOf(\"@\") === -1 && line.indexOf(\":\") === -1) {\n                return new StackFrame({\n                    functionName: line\n                });\n            } else {\n                var functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(?:@)/;\n                var matches = line.match(functionNameRegex);\n                var functionName = matches && matches[1] ? matches[1] : void 0;\n                var locationParts = this.extractLocation(line.replace(functionNameRegex, \"\"));\n                return new StackFrame({\n                    functionName: functionName,\n                    fileName: locationParts[0],\n                    lineNumber: locationParts[1],\n                    columnNumber: locationParts[2]\n                });\n            }\n        }, this);\n    },\n    parseOpera: function parseOpera(e) {\n        if (!e.stacktrace || e.message.indexOf(\"\\n\") > -1 && e.message.split(\"\\n\").length > e.stacktrace.split(\"\\n\").length) {\n            return this.parseOpera9(e);\n        } else if (!e.stack) {\n            return this.parseOpera10(e);\n        } else {\n            return this.parseOpera11(e);\n        }\n    },\n    parseOpera9: function parseOpera9(e) {\n        var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n        var lines = e.message.split(\"\\n\");\n        var result = [];\n        for(var i = 2, len = lines.length; i < len; i += 2){\n            var match = lineRE.exec(lines[i]);\n            if (match) {\n                result.push(new StackFrame({\n                    fileName: match[2],\n                    lineNumber: parseFloat(match[1])\n                }));\n            }\n        }\n        return result;\n    },\n    parseOpera10: function parseOpera10(e) {\n        var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n        var lines = e.stacktrace.split(\"\\n\");\n        var result = [];\n        for(var i = 0, len = lines.length; i < len; i += 2){\n            var match = lineRE.exec(lines[i]);\n            if (match) {\n                result.push(new StackFrame({\n                    functionName: match[3] || void 0,\n                    fileName: match[2],\n                    lineNumber: parseFloat(match[1])\n                }));\n            }\n        }\n        return result;\n    },\n    // Opera 10.65+ Error.stack very similar to FF/Safari\n    parseOpera11: function parseOpera11(error) {\n        var filtered = error.stack.split(\"\\n\").filter(function(line) {\n            return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n        }, this);\n        return filtered.map(function(line) {\n            var tokens = line.split(\"@\");\n            var locationParts = this.extractLocation(tokens.pop());\n            var functionCall = tokens.shift() || \"\";\n            var functionName = functionCall.replace(/<anonymous function(: (\\w+))?>/, \"$2\").replace(/\\([^)]*\\)/g, \"\") || void 0;\n            return new StackFrame({\n                functionName: functionName,\n                fileName: locationParts[0],\n                lineNumber: locationParts[1],\n                columnNumber: locationParts[2]\n            });\n        }, this);\n    }\n};\nfunction pathToSelector(node) {\n    if (!node || !node.outerHTML) {\n        return \"\";\n    }\n    var path = \"\";\n    while(node.parentElement){\n        var name = node.localName;\n        if (!name) {\n            break;\n        }\n        name = name.toLowerCase();\n        var parent = node.parentElement;\n        var domSiblings = [];\n        if (parent.children && parent.children.length > 0) {\n            for(var i = 0; i < parent.children.length; i++){\n                var sibling = parent.children[i];\n                if (sibling.localName && sibling.localName.toLowerCase) {\n                    if (sibling.localName.toLowerCase() === name) {\n                        domSiblings.push(sibling);\n                    }\n                }\n            }\n        }\n        if (domSiblings.length > 1) {\n            name += \":eq(\" + domSiblings.indexOf(node) + \")\";\n        }\n        path = name + (path ? \">\" + path : \"\");\n        node = parent;\n    }\n    return path;\n}\nfunction isObject(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Object]\";\n}\nfunction isObjTooDeep(obj, limit) {\n    if (limit === 0) {\n        return true;\n    }\n    var keys = Object.keys(obj);\n    for(var _iterator = _create_for_of_iterator_helper_loose(keys), _step; !(_step = _iterator()).done;){\n        var key = _step.value;\n        if (isObject(obj[key]) && isObjTooDeep(obj[key], limit - 1)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction stringify(obj, stringifyOptions) {\n    var options = {\n        numOfKeysLimit: 50,\n        depthOfLimit: 4\n    };\n    Object.assign(options, stringifyOptions);\n    var stack = [];\n    var keys = [];\n    return JSON.stringify(obj, function(key, value) {\n        if (stack.length > 0) {\n            var thisPos = stack.indexOf(this);\n            ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n            ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n            if (~stack.indexOf(value)) {\n                if (stack[0] === value) {\n                    value = \"[Circular ~]\";\n                } else {\n                    value = \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\";\n                }\n            }\n        } else {\n            stack.push(value);\n        }\n        if (value === null) return value;\n        if (value === void 0) return \"undefined\";\n        if (shouldIgnore(value)) {\n            return toString(value);\n        }\n        if ((typeof value === \"undefined\" ? \"undefined\" : _type_of(value)) === \"bigint\") {\n            return value.toString() + \"n\";\n        }\n        if (_instanceof(value, Event)) {\n            var eventResult = {};\n            for(var eventKey in value){\n                var eventValue = value[eventKey];\n                if (Array.isArray(eventValue)) {\n                    eventResult[eventKey] = pathToSelector(eventValue.length ? eventValue[0] : null);\n                } else {\n                    eventResult[eventKey] = eventValue;\n                }\n            }\n            return eventResult;\n        } else if (_instanceof(value, Node)) {\n            if (_instanceof(value, HTMLElement)) {\n                return value ? value.outerHTML : \"\";\n            }\n            return value.nodeName;\n        } else if (_instanceof(value, Error)) {\n            return value.stack ? value.stack + \"\\nEnd of stack for Error object\" : value.name + \": \" + value.message;\n        }\n        return value;\n    });\n    function shouldIgnore(_obj) {\n        if (isObject(_obj) && Object.keys(_obj).length > options.numOfKeysLimit) {\n            return true;\n        }\n        if (typeof _obj === \"function\") {\n            return true;\n        }\n        if (isObject(_obj) && isObjTooDeep(_obj, options.depthOfLimit)) {\n            return true;\n        }\n        return false;\n    }\n    function toString(_obj) {\n        var str = _obj.toString();\n        if (options.stringLengthLimit && str.length > options.stringLengthLimit) {\n            str = \"\" + str.slice(0, options.stringLengthLimit) + \"...\";\n        }\n        return str;\n    }\n}\nvar defaultLogOptions = {\n    level: [\n        \"assert\",\n        \"clear\",\n        \"count\",\n        \"countReset\",\n        \"debug\",\n        \"dir\",\n        \"dirxml\",\n        \"error\",\n        \"group\",\n        \"groupCollapsed\",\n        \"groupEnd\",\n        \"info\",\n        \"log\",\n        \"table\",\n        \"time\",\n        \"timeEnd\",\n        \"timeLog\",\n        \"trace\",\n        \"warn\"\n    ],\n    lengthThreshold: 1e3,\n    logger: \"console\"\n};\nfunction initLogObserver(cb, win, options) {\n    var logOptions = options ? Object.assign({}, defaultLogOptions, options) : defaultLogOptions;\n    var loggerType = logOptions.logger;\n    if (!loggerType) {\n        return function() {};\n    }\n    var logger;\n    if (typeof loggerType === \"string\") {\n        logger = win[loggerType];\n    } else {\n        logger = loggerType;\n    }\n    var logCount = 0;\n    var inStack = false;\n    var cancelHandlers = [];\n    if (logOptions.level.includes(\"error\")) {\n        var errorHandler = function(event) {\n            var message = event.message, error = event.error;\n            var trace = ErrorStackParser.parse(error).map(function(stackFrame) {\n                return stackFrame.toString();\n            });\n            var payload = [\n                stringify(message, logOptions.stringifyOptions)\n            ];\n            cb({\n                level: \"error\",\n                trace: trace,\n                payload: payload\n            });\n        };\n        win.addEventListener(\"error\", errorHandler);\n        cancelHandlers.push(function() {\n            win.removeEventListener(\"error\", errorHandler);\n        });\n        var unhandledrejectionHandler = function(event) {\n            var error;\n            var payload;\n            if (_instanceof(event.reason, Error)) {\n                error = event.reason;\n                payload = [\n                    stringify(\"Uncaught (in promise) \" + error.name + \": \" + error.message, logOptions.stringifyOptions)\n                ];\n            } else {\n                error = new Error();\n                payload = [\n                    stringify(\"Uncaught (in promise)\", logOptions.stringifyOptions),\n                    stringify(event.reason, logOptions.stringifyOptions)\n                ];\n            }\n            var trace = ErrorStackParser.parse(error).map(function(stackFrame) {\n                return stackFrame.toString();\n            });\n            cb({\n                level: \"error\",\n                trace: trace,\n                payload: payload\n            });\n        };\n        win.addEventListener(\"unhandledrejection\", unhandledrejectionHandler);\n        cancelHandlers.push(function() {\n            win.removeEventListener(\"unhandledrejection\", unhandledrejectionHandler);\n        });\n    }\n    for(var _iterator = _create_for_of_iterator_helper_loose(logOptions.level), _step; !(_step = _iterator()).done;){\n        var levelType = _step.value;\n        cancelHandlers.push(replace(logger, levelType));\n    }\n    return function() {\n        cancelHandlers.forEach(function(h) {\n            return h();\n        });\n    };\n    function replace(_logger, level) {\n        var _this = this;\n        if (!_logger[level]) {\n            return function() {};\n        }\n        return patch(_logger, level, function(original) {\n            var _this1 = _this;\n            return function() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                original.apply(_this1, args);\n                if (level === \"assert\" && !!args[0]) {\n                    return;\n                }\n                if (inStack) {\n                    return;\n                }\n                inStack = true;\n                try {\n                    var trace = ErrorStackParser.parse(new Error()).map(function(stackFrame) {\n                        return stackFrame.toString();\n                    }).splice(1);\n                    var argsForPayload = level === \"assert\" ? args.slice(1) : args;\n                    var payload = argsForPayload.map(function(s) {\n                        return stringify(s, logOptions.stringifyOptions);\n                    });\n                    logCount++;\n                    if (logCount < logOptions.lengthThreshold) {\n                        cb({\n                            level: level,\n                            trace: trace,\n                            payload: payload\n                        });\n                    } else if (logCount === logOptions.lengthThreshold) {\n                        cb({\n                            level: \"warn\",\n                            trace: [],\n                            payload: [\n                                stringify(\"The number of log records reached the threshold.\")\n                            ]\n                        });\n                    }\n                } catch (error) {\n                    original.apply(void 0, [].concat([\n                        \"rrweb logger error:\",\n                        error\n                    ], args));\n                } finally{\n                    inStack = false;\n                }\n            };\n        });\n    }\n}\nvar PLUGIN_NAME = \"rrweb/console@1\";\nvar getRecordConsolePlugin = function(options) {\n    return {\n        name: PLUGIN_NAME,\n        observer: initLogObserver,\n        options: options\n    };\n};\n\nvar setImmediate = win['setImmediate'];\nvar builtInProp, cycle, schedulingQueue,\n    ToString = Object.prototype.toString,\n    timer = (typeof setImmediate !== 'undefined') ?\n        function timer(fn) { return setImmediate(fn); } :\n        setTimeout;\n\n// dammit, IE8.\ntry {\n    Object.defineProperty({},'x',{});\n    builtInProp = function builtInProp(obj,name,val,config) {\n        return Object.defineProperty(obj,name,{\n            value: val,\n            writable: true,\n            configurable: config !== false\n        });\n    };\n}\ncatch (err) {\n    builtInProp = function builtInProp(obj,name,val) {\n        obj[name] = val;\n        return obj;\n    };\n}\n\n// Note: using a queue instead of array for efficiency\nschedulingQueue = (function Queue() {\n    var first, last, item;\n\n    function Item(fn,self) {\n        this.fn = fn;\n        this.self = self;\n        this.next = void 0;\n    }\n\n    return {\n        add: function add(fn,self) {\n            item = new Item(fn,self);\n            if (last) {\n                last.next = item;\n            }\n            else {\n                first = item;\n            }\n            last = item;\n            item = void 0;\n        },\n        drain: function drain() {\n            var f = first;\n            first = last = cycle = void 0;\n\n            while (f) {\n                f.fn.call(f.self);\n                f = f.next;\n            }\n        }\n    };\n})();\n\nfunction schedule(fn,self) {\n    schedulingQueue.add(fn,self);\n    if (!cycle) {\n        cycle = timer(schedulingQueue.drain);\n    }\n}\n\n// promise duck typing\nfunction isThenable(o) {\n    var _then, oType = typeof o;\n\n    if (o !== null && (oType === 'object' || oType === 'function')) {\n        _then = o.then;\n    }\n    return typeof _then === 'function' ? _then : false;\n}\n\nfunction notify() {\n    for (var i=0; i<this.chain.length; i++) {\n        notifyIsolated(\n            this,\n            (this.state === 1) ? this.chain[i].success : this.chain[i].failure,\n            this.chain[i]\n        );\n    }\n    this.chain.length = 0;\n}\n\n// NOTE: This is a separate function to isolate\n// the `try..catch` so that other code can be\n// optimized better\nfunction notifyIsolated(self,cb,chain) {\n    var ret, _then;\n    try {\n        if (cb === false) {\n            chain.reject(self.msg);\n        }\n        else {\n            if (cb === true) {\n                ret = self.msg;\n            }\n            else {\n                ret = cb.call(void 0,self.msg);\n            }\n\n            if (ret === chain.promise) {\n                chain.reject(TypeError('Promise-chain cycle'));\n            }\n            // eslint-disable-next-line no-cond-assign\n            else if (_then = isThenable(ret)) {\n                _then.call(ret,chain.resolve,chain.reject);\n            }\n            else {\n                chain.resolve(ret);\n            }\n        }\n    }\n    catch (err) {\n        chain.reject(err);\n    }\n}\n\nfunction resolve(msg) {\n    var _then, self = this;\n\n    // already triggered?\n    if (self.triggered) { return; }\n\n    self.triggered = true;\n\n    // unwrap\n    if (self.def) {\n        self = self.def;\n    }\n\n    try {\n        // eslint-disable-next-line no-cond-assign\n        if (_then = isThenable(msg)) {\n            schedule(function(){\n                var defWrapper = new MakeDefWrapper(self);\n                try {\n                    _then.call(msg,\n                        function $resolve$(){ resolve.apply(defWrapper,arguments); },\n                        function $reject$(){ reject.apply(defWrapper,arguments); }\n                    );\n                }\n                catch (err) {\n                    reject.call(defWrapper,err);\n                }\n            });\n        }\n        else {\n            self.msg = msg;\n            self.state = 1;\n            if (self.chain.length > 0) {\n                schedule(notify,self);\n            }\n        }\n    }\n    catch (err) {\n        reject.call(new MakeDefWrapper(self),err);\n    }\n}\n\nfunction reject(msg) {\n    var self = this;\n\n    // already triggered?\n    if (self.triggered) { return; }\n\n    self.triggered = true;\n\n    // unwrap\n    if (self.def) {\n        self = self.def;\n    }\n\n    self.msg = msg;\n    self.state = 2;\n    if (self.chain.length > 0) {\n        schedule(notify,self);\n    }\n}\n\nfunction iteratePromises(Constructor,arr,resolver,rejecter) {\n    for (var idx=0; idx<arr.length; idx++) {\n        (function IIFE(idx){\n            Constructor.resolve(arr[idx])\n                .then(\n                    function $resolver$(msg){\n                        resolver(idx,msg);\n                    },\n                    rejecter\n                );\n        })(idx);\n    }\n}\n\nfunction MakeDefWrapper(self) {\n    this.def = self;\n    this.triggered = false;\n}\n\nfunction MakeDef(self) {\n    this.promise = self;\n    this.state = 0;\n    this.triggered = false;\n    this.chain = [];\n    this.msg = void 0;\n}\n\nfunction NpoPromise(executor) {\n    if (typeof executor !== 'function') {\n        throw TypeError('Not a function');\n    }\n\n    if (this['__NPO__'] !== 0) {\n        throw TypeError('Not a promise');\n    }\n\n    // instance shadowing the inherited \"brand\"\n    // to signal an already \"initialized\" promise\n    this['__NPO__'] = 1;\n\n    var def = new MakeDef(this);\n\n    this['then'] = function then(success,failure) {\n        var o = {\n            success: typeof success === 'function' ? success : true,\n            failure: typeof failure === 'function' ? failure : false\n        };\n            // Note: `then(..)` itself can be borrowed to be used against\n            // a different promise constructor for making the chained promise,\n            // by substituting a different `this` binding.\n        o.promise = new this.constructor(function extractChain(resolve,reject) {\n            if (typeof resolve !== 'function' || typeof reject !== 'function') {\n                throw TypeError('Not a function');\n            }\n\n            o.resolve = resolve;\n            o.reject = reject;\n        });\n        def.chain.push(o);\n\n        if (def.state !== 0) {\n            schedule(notify,def);\n        }\n\n        return o.promise;\n    };\n    this['catch'] = function $catch$(failure) {\n        return this.then(void 0,failure);\n    };\n\n    try {\n        executor.call(\n            void 0,\n            function publicResolve(msg){\n                resolve.call(def,msg);\n            },\n            function publicReject(msg) {\n                reject.call(def,msg);\n            }\n        );\n    }\n    catch (err) {\n        reject.call(def,err);\n    }\n}\n\nvar PromisePrototype = builtInProp({},'constructor',NpoPromise,\n    /*configurable=*/false\n);\n\n    // Note: Android 4 cannot use `Object.defineProperty(..)` here\nNpoPromise.prototype = PromisePrototype;\n\n// built-in \"brand\" to signal an \"uninitialized\" promise\nbuiltInProp(PromisePrototype,'__NPO__',0,\n    /*configurable=*/false\n);\n\nbuiltInProp(NpoPromise,'resolve',function Promise$resolve(msg) {\n    var Constructor = this;\n\n    // spec mandated checks\n    // note: best \"isPromise\" check that's practical for now\n    if (msg && typeof msg === 'object' && msg['__NPO__'] === 1) {\n        return msg;\n    }\n\n    return new Constructor(function executor(resolve,reject){\n        if (typeof resolve !== 'function' || typeof reject !== 'function') {\n            throw TypeError('Not a function');\n        }\n\n        resolve(msg);\n    });\n});\n\nbuiltInProp(NpoPromise,'reject',function Promise$reject(msg) {\n    return new this(function executor(resolve,reject){\n        if (typeof resolve !== 'function' || typeof reject !== 'function') {\n            throw TypeError('Not a function');\n        }\n\n        reject(msg);\n    });\n});\n\nbuiltInProp(NpoPromise,'all',function Promise$all(arr) {\n    var Constructor = this;\n\n    // spec mandated checks\n    if (ToString.call(arr) !== '[object Array]') {\n        return Constructor.reject(TypeError('Not an array'));\n    }\n    if (arr.length === 0) {\n        return Constructor.resolve([]);\n    }\n\n    return new Constructor(function executor(resolve,reject){\n        if (typeof resolve !== 'function' || typeof reject !== 'function') {\n            throw TypeError('Not a function');\n        }\n\n        var len = arr.length, msgs = Array(len), count = 0;\n\n        iteratePromises(Constructor,arr,function resolver(idx,msg) {\n            msgs[idx] = msg;\n            if (++count === len) {\n                resolve(msgs);\n            }\n        },reject);\n    });\n});\n\nbuiltInProp(NpoPromise,'race',function Promise$race(arr) {\n    var Constructor = this;\n\n    // spec mandated checks\n    if (ToString.call(arr) !== '[object Array]') {\n        return Constructor.reject(TypeError('Not an array'));\n    }\n\n    return new Constructor(function executor(resolve,reject){\n        if (typeof resolve !== 'function' || typeof reject !== 'function') {\n            throw TypeError('Not a function');\n        }\n\n        iteratePromises(Constructor,arr,function resolver(idx,msg){\n            resolve(msg);\n        },reject);\n    });\n});\n\nvar PromisePolyfill;\nif (typeof Promise !== 'undefined' && Promise.toString().indexOf('[native code]') !== -1) {\n    PromisePolyfill = Promise;\n} else {\n    PromisePolyfill = NpoPromise;\n}\n\nvar Config = {\n    DEBUG: false,\n    LIB_VERSION: '2.72.0'\n};\n\n/* eslint camelcase: \"off\", eqeqeq: \"off\" */\n\n// Maximum allowed session recording length\nvar MAX_RECORDING_MS = 24 * 60 * 60 * 1000; // 24 hours\n// Maximum allowed value for minimum session recording length\nvar MAX_VALUE_FOR_MIN_RECORDING_MS = 8 * 1000; // 8 seconds\n\n/*\n * Saved references to long variable names, so that closure compiler can\n * minimize file size.\n */\n\nvar ArrayProto = Array.prototype,\n    FuncProto = Function.prototype,\n    ObjProto = Object.prototype,\n    slice = ArrayProto.slice,\n    toString = ObjProto.toString,\n    hasOwnProperty = ObjProto.hasOwnProperty,\n    windowConsole = win.console,\n    navigator = win.navigator,\n    document$1 = win.document,\n    windowOpera = win.opera,\n    screen = win.screen,\n    userAgent = navigator.userAgent;\n\nvar nativeBind = FuncProto.bind,\n    nativeForEach = ArrayProto.forEach,\n    nativeIndexOf = ArrayProto.indexOf,\n    nativeMap = ArrayProto.map,\n    nativeIsArray = Array.isArray,\n    breaker = {};\n\nvar _ = {\n    trim: function(str) {\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill\n        return str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n    }\n};\n\n// Console override\nvar console$1 = {\n    /** @type {function(...*)} */\n    log: function() {\n        if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {\n            try {\n                windowConsole.log.apply(windowConsole, arguments);\n            } catch (err) {\n                _.each(arguments, function(arg) {\n                    windowConsole.log(arg);\n                });\n            }\n        }\n    },\n    /** @type {function(...*)} */\n    warn: function() {\n        if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {\n            var args = ['Mixpanel warning:'].concat(_.toArray(arguments));\n            try {\n                windowConsole.warn.apply(windowConsole, args);\n            } catch (err) {\n                _.each(args, function(arg) {\n                    windowConsole.warn(arg);\n                });\n            }\n        }\n    },\n    /** @type {function(...*)} */\n    error: function() {\n        if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {\n            var args = ['Mixpanel error:'].concat(_.toArray(arguments));\n            try {\n                windowConsole.error.apply(windowConsole, args);\n            } catch (err) {\n                _.each(args, function(arg) {\n                    windowConsole.error(arg);\n                });\n            }\n        }\n    },\n    /** @type {function(...*)} */\n    critical: function() {\n        if (!_.isUndefined(windowConsole) && windowConsole) {\n            var args = ['Mixpanel error:'].concat(_.toArray(arguments));\n            try {\n                windowConsole.error.apply(windowConsole, args);\n            } catch (err) {\n                _.each(args, function(arg) {\n                    windowConsole.error(arg);\n                });\n            }\n        }\n    }\n};\n\nvar log_func_with_prefix = function(func, prefix) {\n    return function() {\n        arguments[0] = '[' + prefix + '] ' + arguments[0];\n        return func.apply(console$1, arguments);\n    };\n};\nvar console_with_prefix = function(prefix) {\n    return {\n        log: log_func_with_prefix(console$1.log, prefix),\n        error: log_func_with_prefix(console$1.error, prefix),\n        critical: log_func_with_prefix(console$1.critical, prefix)\n    };\n};\n\n\nvar safewrap = function(f) {\n    return function() {\n        try {\n            return f.apply(this, arguments);\n        } catch (e) {\n            console$1.critical('Implementation error. Please turn on debug and contact support@mixpanel.com.');\n            if (Config.DEBUG){\n                console$1.critical(e);\n            }\n        }\n    };\n};\n\nvar safewrapClass = function(klass) {\n    var proto = klass.prototype;\n    for (var func in proto) {\n        if (typeof(proto[func]) === 'function') {\n            proto[func] = safewrap(proto[func]);\n        }\n    }\n};\n\n\n// UNDERSCORE\n// Embed part of the Underscore Library\n_.bind = function(func, context) {\n    var args, bound;\n    if (nativeBind && func.bind === nativeBind) {\n        return nativeBind.apply(func, slice.call(arguments, 1));\n    }\n    if (!_.isFunction(func)) {\n        throw new TypeError();\n    }\n    args = slice.call(arguments, 2);\n    bound = function() {\n        if (!(this instanceof bound)) {\n            return func.apply(context, args.concat(slice.call(arguments)));\n        }\n        var ctor = {};\n        ctor.prototype = func.prototype;\n        var self = new ctor();\n        ctor.prototype = null;\n        var result = func.apply(self, args.concat(slice.call(arguments)));\n        if (Object(result) === result) {\n            return result;\n        }\n        return self;\n    };\n    return bound;\n};\n\n/**\n * @param {*=} obj\n * @param {function(...*)=} iterator\n * @param {Object=} context\n */\n_.each = function(obj, iterator, context) {\n    if (obj === null || obj === undefined) {\n        return;\n    }\n    if (nativeForEach && obj.forEach === nativeForEach) {\n        obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n        for (var i = 0, l = obj.length; i < l; i++) {\n            if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) {\n                return;\n            }\n        }\n    } else {\n        for (var key in obj) {\n            if (hasOwnProperty.call(obj, key)) {\n                if (iterator.call(context, obj[key], key, obj) === breaker) {\n                    return;\n                }\n            }\n        }\n    }\n};\n\n_.extend = function(obj) {\n    _.each(slice.call(arguments, 1), function(source) {\n        for (var prop in source) {\n            if (source[prop] !== void 0) {\n                obj[prop] = source[prop];\n            }\n        }\n    });\n    return obj;\n};\n\n_.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === '[object Array]';\n};\n\n// from a comment on http://dbj.org/dbj/?p=286\n// fails on only one very rare and deliberate custom object:\n// var bomb = { toString : undefined, valueOf: function(o) { return \"function BOMBA!\"; }};\n_.isFunction = function(f) {\n    try {\n        return /^\\s*\\bfunction\\b/.test(f);\n    } catch (x) {\n        return false;\n    }\n};\n\n_.isArguments = function(obj) {\n    return !!(obj && hasOwnProperty.call(obj, 'callee'));\n};\n\n_.toArray = function(iterable) {\n    if (!iterable) {\n        return [];\n    }\n    if (iterable.toArray) {\n        return iterable.toArray();\n    }\n    if (_.isArray(iterable)) {\n        return slice.call(iterable);\n    }\n    if (_.isArguments(iterable)) {\n        return slice.call(iterable);\n    }\n    return _.values(iterable);\n};\n\n_.map = function(arr, callback, context) {\n    if (nativeMap && arr.map === nativeMap) {\n        return arr.map(callback, context);\n    } else {\n        var results = [];\n        _.each(arr, function(item) {\n            results.push(callback.call(context, item));\n        });\n        return results;\n    }\n};\n\n_.keys = function(obj) {\n    var results = [];\n    if (obj === null) {\n        return results;\n    }\n    _.each(obj, function(value, key) {\n        results[results.length] = key;\n    });\n    return results;\n};\n\n_.values = function(obj) {\n    var results = [];\n    if (obj === null) {\n        return results;\n    }\n    _.each(obj, function(value) {\n        results[results.length] = value;\n    });\n    return results;\n};\n\n_.include = function(obj, target) {\n    var found = false;\n    if (obj === null) {\n        return found;\n    }\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) {\n        return obj.indexOf(target) != -1;\n    }\n    _.each(obj, function(value) {\n        if (found || (found = (value === target))) {\n            return breaker;\n        }\n    });\n    return found;\n};\n\n_.includes = function(str, needle) {\n    return str.indexOf(needle) !== -1;\n};\n\n// Underscore Addons\n_.inherit = function(subclass, superclass) {\n    subclass.prototype = new superclass();\n    subclass.prototype.constructor = subclass;\n    subclass.superclass = superclass.prototype;\n    return subclass;\n};\n\n_.isObject = function(obj) {\n    return (obj === Object(obj) && !_.isArray(obj));\n};\n\n_.isEmptyObject = function(obj) {\n    if (_.isObject(obj)) {\n        for (var key in obj) {\n            if (hasOwnProperty.call(obj, key)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n};\n\n_.isUndefined = function(obj) {\n    return obj === void 0;\n};\n\n_.isString = function(obj) {\n    return toString.call(obj) == '[object String]';\n};\n\n_.isDate = function(obj) {\n    return toString.call(obj) == '[object Date]';\n};\n\n_.isNumber = function(obj) {\n    return toString.call(obj) == '[object Number]';\n};\n\n_.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n};\n\n_.encodeDates = function(obj) {\n    _.each(obj, function(v, k) {\n        if (_.isDate(v)) {\n            obj[k] = _.formatDate(v);\n        } else if (_.isObject(v)) {\n            obj[k] = _.encodeDates(v); // recurse\n        }\n    });\n    return obj;\n};\n\n_.timestamp = function() {\n    Date.now = Date.now || function() {\n        return +new Date;\n    };\n    return Date.now();\n};\n\n_.formatDate = function(d) {\n    // YYYY-MM-DDTHH:MM:SS in UTC\n    function pad(n) {\n        return n < 10 ? '0' + n : n;\n    }\n    return d.getUTCFullYear() + '-' +\n        pad(d.getUTCMonth() + 1) + '-' +\n        pad(d.getUTCDate()) + 'T' +\n        pad(d.getUTCHours()) + ':' +\n        pad(d.getUTCMinutes()) + ':' +\n        pad(d.getUTCSeconds());\n};\n\n_.strip_empty_properties = function(p) {\n    var ret = {};\n    _.each(p, function(v, k) {\n        if (_.isString(v) && v.length > 0) {\n            ret[k] = v;\n        }\n    });\n    return ret;\n};\n\n/*\n * this function returns a copy of object after truncating it.  If\n * passed an Array or Object it will iterate through obj and\n * truncate all the values recursively.\n */\n_.truncate = function(obj, length) {\n    var ret;\n\n    if (typeof(obj) === 'string') {\n        ret = obj.slice(0, length);\n    } else if (_.isArray(obj)) {\n        ret = [];\n        _.each(obj, function(val) {\n            ret.push(_.truncate(val, length));\n        });\n    } else if (_.isObject(obj)) {\n        ret = {};\n        _.each(obj, function(val, key) {\n            ret[key] = _.truncate(val, length);\n        });\n    } else {\n        ret = obj;\n    }\n\n    return ret;\n};\n\n_.JSONEncode = (function() {\n    return function(mixed_val) {\n        var value = mixed_val;\n        var quote = function(string) {\n            var escapable = /[\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g; // eslint-disable-line no-control-regex\n            var meta = { // table of character substitutions\n                '\\b': '\\\\b',\n                '\\t': '\\\\t',\n                '\\n': '\\\\n',\n                '\\f': '\\\\f',\n                '\\r': '\\\\r',\n                '\"': '\\\\\"',\n                '\\\\': '\\\\\\\\'\n            };\n\n            escapable.lastIndex = 0;\n            return escapable.test(string) ?\n                '\"' + string.replace(escapable, function(a) {\n                    var c = meta[a];\n                    return typeof c === 'string' ? c :\n                        '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n                }) + '\"' :\n                '\"' + string + '\"';\n        };\n\n        var str = function(key, holder) {\n            var gap = '';\n            var indent = '    ';\n            var i = 0; // The loop counter.\n            var k = ''; // The member key.\n            var v = ''; // The member value.\n            var length = 0;\n            var mind = gap;\n            var partial = [];\n            var value = holder[key];\n\n            // If the value has a toJSON method, call it to obtain a replacement value.\n            if (value && typeof value === 'object' &&\n                typeof value.toJSON === 'function') {\n                value = value.toJSON(key);\n            }\n\n            // What happens next depends on the value's type.\n            switch (typeof value) {\n                case 'string':\n                    return quote(value);\n\n                case 'number':\n                    // JSON numbers must be finite. Encode non-finite numbers as null.\n                    return isFinite(value) ? String(value) : 'null';\n\n                case 'boolean':\n                case 'null':\n                    // If the value is a boolean or null, convert it to a string. Note:\n                    // typeof null does not produce 'null'. The case is included here in\n                    // the remote chance that this gets fixed someday.\n\n                    return String(value);\n\n                case 'object':\n                    // If the type is 'object', we might be dealing with an object or an array or\n                    // null.\n                    // Due to a specification blunder in ECMAScript, typeof null is 'object',\n                    // so watch out for that case.\n                    if (!value) {\n                        return 'null';\n                    }\n\n                    // Make an array to hold the partial results of stringifying this object value.\n                    gap += indent;\n                    partial = [];\n\n                    // Is the value an array?\n                    if (toString.apply(value) === '[object Array]') {\n                        // The value is an array. Stringify every element. Use null as a placeholder\n                        // for non-JSON values.\n\n                        length = value.length;\n                        for (i = 0; i < length; i += 1) {\n                            partial[i] = str(i, value) || 'null';\n                        }\n\n                        // Join all of the elements together, separated with commas, and wrap them in\n                        // brackets.\n                        v = partial.length === 0 ? '[]' :\n                            gap ? '[\\n' + gap +\n                            partial.join(',\\n' + gap) + '\\n' +\n                            mind + ']' :\n                                '[' + partial.join(',') + ']';\n                        gap = mind;\n                        return v;\n                    }\n\n                    // Iterate through all of the keys in the object.\n                    for (k in value) {\n                        if (hasOwnProperty.call(value, k)) {\n                            v = str(k, value);\n                            if (v) {\n                                partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                            }\n                        }\n                    }\n\n                    // Join all of the member texts together, separated with commas,\n                    // and wrap them in braces.\n                    v = partial.length === 0 ? '{}' :\n                        gap ? '{' + partial.join(',') + '' +\n                        mind + '}' : '{' + partial.join(',') + '}';\n                    gap = mind;\n                    return v;\n            }\n        };\n\n        // Make a fake root object containing our value under the key of ''.\n        // Return the result of stringifying the value.\n        return str('', {\n            '': value\n        });\n    };\n})();\n\n/**\n * From https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js\n * Slightly modified to throw a real Error rather than a POJO\n */\n_.JSONDecode = (function() {\n    var at, // The index of the current character\n        ch, // The current character\n        escapee = {\n            '\"': '\"',\n            '\\\\': '\\\\',\n            '/': '/',\n            'b': '\\b',\n            'f': '\\f',\n            'n': '\\n',\n            'r': '\\r',\n            't': '\\t'\n        },\n        text,\n        error = function(m) {\n            var e = new SyntaxError(m);\n            e.at = at;\n            e.text = text;\n            throw e;\n        },\n        next = function(c) {\n            // If a c parameter is provided, verify that it matches the current character.\n            if (c && c !== ch) {\n                error('Expected \\'' + c + '\\' instead of \\'' + ch + '\\'');\n            }\n            // Get the next character. When there are no more characters,\n            // return the empty string.\n            ch = text.charAt(at);\n            at += 1;\n            return ch;\n        },\n        number = function() {\n            // Parse a number value.\n            var number,\n                string = '';\n\n            if (ch === '-') {\n                string = '-';\n                next('-');\n            }\n            while (ch >= '0' && ch <= '9') {\n                string += ch;\n                next();\n            }\n            if (ch === '.') {\n                string += '.';\n                while (next() && ch >= '0' && ch <= '9') {\n                    string += ch;\n                }\n            }\n            if (ch === 'e' || ch === 'E') {\n                string += ch;\n                next();\n                if (ch === '-' || ch === '+') {\n                    string += ch;\n                    next();\n                }\n                while (ch >= '0' && ch <= '9') {\n                    string += ch;\n                    next();\n                }\n            }\n            number = +string;\n            if (!isFinite(number)) {\n                error('Bad number');\n            } else {\n                return number;\n            }\n        },\n\n        string = function() {\n            // Parse a string value.\n            var hex,\n                i,\n                string = '',\n                uffff;\n            // When parsing for string values, we must look for \" and \\ characters.\n            if (ch === '\"') {\n                while (next()) {\n                    if (ch === '\"') {\n                        next();\n                        return string;\n                    }\n                    if (ch === '\\\\') {\n                        next();\n                        if (ch === 'u') {\n                            uffff = 0;\n                            for (i = 0; i < 4; i += 1) {\n                                hex = parseInt(next(), 16);\n                                if (!isFinite(hex)) {\n                                    break;\n                                }\n                                uffff = uffff * 16 + hex;\n                            }\n                            string += String.fromCharCode(uffff);\n                        } else if (typeof escapee[ch] === 'string') {\n                            string += escapee[ch];\n                        } else {\n                            break;\n                        }\n                    } else {\n                        string += ch;\n                    }\n                }\n            }\n            error('Bad string');\n        },\n        white = function() {\n            // Skip whitespace.\n            while (ch && ch <= ' ') {\n                next();\n            }\n        },\n        word = function() {\n            // true, false, or null.\n            switch (ch) {\n                case 't':\n                    next('t');\n                    next('r');\n                    next('u');\n                    next('e');\n                    return true;\n                case 'f':\n                    next('f');\n                    next('a');\n                    next('l');\n                    next('s');\n                    next('e');\n                    return false;\n                case 'n':\n                    next('n');\n                    next('u');\n                    next('l');\n                    next('l');\n                    return null;\n            }\n            error('Unexpected \"' + ch + '\"');\n        },\n        value, // Placeholder for the value function.\n        array = function() {\n            // Parse an array value.\n            var array = [];\n\n            if (ch === '[') {\n                next('[');\n                white();\n                if (ch === ']') {\n                    next(']');\n                    return array; // empty array\n                }\n                while (ch) {\n                    array.push(value());\n                    white();\n                    if (ch === ']') {\n                        next(']');\n                        return array;\n                    }\n                    next(',');\n                    white();\n                }\n            }\n            error('Bad array');\n        },\n        object = function() {\n            // Parse an object value.\n            var key,\n                object = {};\n\n            if (ch === '{') {\n                next('{');\n                white();\n                if (ch === '}') {\n                    next('}');\n                    return object; // empty object\n                }\n                while (ch) {\n                    key = string();\n                    white();\n                    next(':');\n                    if (Object.hasOwnProperty.call(object, key)) {\n                        error('Duplicate key \"' + key + '\"');\n                    }\n                    object[key] = value();\n                    white();\n                    if (ch === '}') {\n                        next('}');\n                        return object;\n                    }\n                    next(',');\n                    white();\n                }\n            }\n            error('Bad object');\n        };\n\n    value = function() {\n        // Parse a JSON value. It could be an object, an array, a string,\n        // a number, or a word.\n        white();\n        switch (ch) {\n            case '{':\n                return object();\n            case '[':\n                return array();\n            case '\"':\n                return string();\n            case '-':\n                return number();\n            default:\n                return ch >= '0' && ch <= '9' ? number() : word();\n        }\n    };\n\n    // Return the json_parse function. It will have access to all of the\n    // above functions and variables.\n    return function(source) {\n        var result;\n\n        text = source;\n        at = 0;\n        ch = ' ';\n        result = value();\n        white();\n        if (ch) {\n            error('Syntax error');\n        }\n\n        return result;\n    };\n})();\n\n_.base64Encode = function(data) {\n    var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,\n        ac = 0,\n        enc = '',\n        tmp_arr = [];\n\n    if (!data) {\n        return data;\n    }\n\n    data = _.utf8Encode(data);\n\n    do { // pack three octets into four hexets\n        o1 = data.charCodeAt(i++);\n        o2 = data.charCodeAt(i++);\n        o3 = data.charCodeAt(i++);\n\n        bits = o1 << 16 | o2 << 8 | o3;\n\n        h1 = bits >> 18 & 0x3f;\n        h2 = bits >> 12 & 0x3f;\n        h3 = bits >> 6 & 0x3f;\n        h4 = bits & 0x3f;\n\n        // use hexets to index into b64, and append result to encoded string\n        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n    } while (i < data.length);\n\n    enc = tmp_arr.join('');\n\n    switch (data.length % 3) {\n        case 1:\n            enc = enc.slice(0, -2) + '==';\n            break;\n        case 2:\n            enc = enc.slice(0, -1) + '=';\n            break;\n    }\n\n    return enc;\n};\n\n_.utf8Encode = function(string) {\n    string = (string + '').replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n\n    var utftext = '',\n        start,\n        end;\n    var stringl = 0,\n        n;\n\n    start = end = 0;\n    stringl = string.length;\n\n    for (n = 0; n < stringl; n++) {\n        var c1 = string.charCodeAt(n);\n        var enc = null;\n\n        if (c1 < 128) {\n            end++;\n        } else if ((c1 > 127) && (c1 < 2048)) {\n            enc = String.fromCharCode((c1 >> 6) | 192, (c1 & 63) | 128);\n        } else {\n            enc = String.fromCharCode((c1 >> 12) | 224, ((c1 >> 6) & 63) | 128, (c1 & 63) | 128);\n        }\n        if (enc !== null) {\n            if (end > start) {\n                utftext += string.substring(start, end);\n            }\n            utftext += enc;\n            start = end = n + 1;\n        }\n    }\n\n    if (end > start) {\n        utftext += string.substring(start, string.length);\n    }\n\n    return utftext;\n};\n\n_.UUID = function() {\n    try {\n        // use native Crypto API when available\n        return win['crypto']['randomUUID']();\n    } catch (err) {\n        // fall back to generating our own UUID\n        // based on https://gist.github.com/scwood/3bff42cc005cc20ab7ec98f0d8e1d59d\n        var uuid = new Array(36);\n        for (var i = 0; i < 36; i++) {\n            uuid[i] = Math.floor(Math.random() * 16);\n        }\n        uuid[14] = 4; // set bits 12-15 of time-high-and-version to 0100\n        uuid[19] = uuid[19] &= -5; // set bit 6 of clock-seq-and-reserved to zero\n        uuid[19] = uuid[19] |= (1 << 3); // set bit 7 of clock-seq-and-reserved to one\n        uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';\n\n        return _.map(uuid, function(x) {\n            return x.toString(16);\n        }).join('');\n    }\n};\n\n// _.isBlockedUA()\n// This is to block various web spiders from executing our JS and\n// sending false tracking data\nvar BLOCKED_UA_STRS = [\n    'ahrefsbot',\n    'ahrefssiteaudit',\n    'amazonbot',\n    'baiduspider',\n    'bingbot',\n    'bingpreview',\n    'chrome-lighthouse',\n    'facebookexternal',\n    'petalbot',\n    'pinterest',\n    'screaming frog',\n    'yahoo! slurp',\n    'yandex',\n\n    // a whole bunch of goog-specific crawlers\n    // https://developers.google.com/search/docs/advanced/crawling/overview-google-crawlers\n    'adsbot-google',\n    'apis-google',\n    'duplexweb-google',\n    'feedfetcher-google',\n    'google favicon',\n    'google web preview',\n    'google-read-aloud',\n    'googlebot',\n    'googleweblight',\n    'mediapartners-google',\n    'storebot-google'\n];\n_.isBlockedUA = function(ua) {\n    var i;\n    ua = ua.toLowerCase();\n    for (i = 0; i < BLOCKED_UA_STRS.length; i++) {\n        if (ua.indexOf(BLOCKED_UA_STRS[i]) !== -1) {\n            return true;\n        }\n    }\n    return false;\n};\n\n/**\n * @param {Object=} formdata\n * @param {string=} arg_separator\n */\n_.HTTPBuildQuery = function(formdata, arg_separator) {\n    var use_val, use_key, tmp_arr = [];\n\n    if (_.isUndefined(arg_separator)) {\n        arg_separator = '&';\n    }\n\n    _.each(formdata, function(val, key) {\n        use_val = encodeURIComponent(val.toString());\n        use_key = encodeURIComponent(key);\n        tmp_arr[tmp_arr.length] = use_key + '=' + use_val;\n    });\n\n    return tmp_arr.join(arg_separator);\n};\n\n_.getQueryParam = function(url, param) {\n    // Expects a raw URL\n\n    param = param.replace(/[[]/g, '\\\\[').replace(/[\\]]/g, '\\\\]');\n    var regexS = '[\\\\?&]' + param + '=([^&#]*)',\n        regex = new RegExp(regexS),\n        results = regex.exec(url);\n    if (results === null || (results && typeof(results[1]) !== 'string' && results[1].length)) {\n        return '';\n    } else {\n        var result = results[1];\n        try {\n            result = decodeURIComponent(result);\n        } catch(err) {\n            console$1.error('Skipping decoding for malformed query param: ' + result);\n        }\n        return result.replace(/\\+/g, ' ');\n    }\n};\n\n\n// _.cookie\n// Methods partially borrowed from quirksmode.org/js/cookies.html\n_.cookie = {\n    get: function(name) {\n        var nameEQ = name + '=';\n        var ca = document$1.cookie.split(';');\n        for (var i = 0; i < ca.length; i++) {\n            var c = ca[i];\n            while (c.charAt(0) == ' ') {\n                c = c.substring(1, c.length);\n            }\n            if (c.indexOf(nameEQ) === 0) {\n                return decodeURIComponent(c.substring(nameEQ.length, c.length));\n            }\n        }\n        return null;\n    },\n\n    parse: function(name) {\n        var cookie;\n        try {\n            cookie = _.JSONDecode(_.cookie.get(name)) || {};\n        } catch (err) {\n            // noop\n        }\n        return cookie;\n    },\n\n    set_seconds: function(name, value, seconds, is_cross_subdomain, is_secure, is_cross_site, domain_override) {\n        var cdomain = '',\n            expires = '',\n            secure = '';\n\n        if (domain_override) {\n            cdomain = '; domain=' + domain_override;\n        } else if (is_cross_subdomain) {\n            var domain = extract_domain(document$1.location.hostname);\n            cdomain = domain ? '; domain=.' + domain : '';\n        }\n\n        if (seconds) {\n            var date = new Date();\n            date.setTime(date.getTime() + (seconds * 1000));\n            expires = '; expires=' + date.toGMTString();\n        }\n\n        if (is_cross_site) {\n            is_secure = true;\n            secure = '; SameSite=None';\n        }\n        if (is_secure) {\n            secure += '; secure';\n        }\n\n        document$1.cookie = name + '=' + encodeURIComponent(value) + expires + '; path=/' + cdomain + secure;\n    },\n\n    set: function(name, value, days, is_cross_subdomain, is_secure, is_cross_site, domain_override) {\n        var cdomain = '', expires = '', secure = '';\n\n        if (domain_override) {\n            cdomain = '; domain=' + domain_override;\n        } else if (is_cross_subdomain) {\n            var domain = extract_domain(document$1.location.hostname);\n            cdomain = domain ? '; domain=.' + domain : '';\n        }\n\n        if (days) {\n            var date = new Date();\n            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));\n            expires = '; expires=' + date.toGMTString();\n        }\n\n        if (is_cross_site) {\n            is_secure = true;\n            secure = '; SameSite=None';\n        }\n        if (is_secure) {\n            secure += '; secure';\n        }\n\n        var new_cookie_val = name + '=' + encodeURIComponent(value) + expires + '; path=/' + cdomain + secure;\n        document$1.cookie = new_cookie_val;\n        return new_cookie_val;\n    },\n\n    remove: function(name, is_cross_subdomain, domain_override) {\n        _.cookie.set(name, '', -1, is_cross_subdomain, false, false, domain_override);\n    }\n};\n\nvar _testStorageSupported = function (storage) {\n    var supported = true;\n    try {\n        var key = '__mplss_' + cheap_guid(8),\n            val = 'xyz';\n        storage.setItem(key, val);\n        if (storage.getItem(key) !== val) {\n            supported = false;\n        }\n        storage.removeItem(key);\n    } catch (err) {\n        supported = false;\n    }\n    return supported;\n};\n\nvar _localStorageSupported = null;\nvar localStorageSupported = function(storage, forceCheck) {\n    if (_localStorageSupported !== null && !forceCheck) {\n        return _localStorageSupported;\n    }\n    return _localStorageSupported = _testStorageSupported(storage || win.localStorage);\n};\n\nvar _sessionStorageSupported = null;\nvar sessionStorageSupported = function(storage, forceCheck) {\n    if (_sessionStorageSupported !== null && !forceCheck) {\n        return _sessionStorageSupported;\n    }\n    return _sessionStorageSupported = _testStorageSupported(storage || win.sessionStorage);\n};\n\nfunction _storageWrapper(storage, name, is_supported_fn) {\n    var log_error = function(msg) {\n        console$1.error(name + ' error: ' + msg);\n    };\n\n    return {\n        is_supported: function(forceCheck) {\n            var supported = is_supported_fn(storage, forceCheck);\n            if (!supported) {\n                console$1.error(name + ' unsupported');\n            }\n            return supported;\n        },\n        error: log_error,\n        get: function(key) {\n            try {\n                return storage.getItem(key);\n            } catch (err) {\n                log_error(err);\n            }\n            return null;\n        },\n        parse: function(key) {\n            try {\n                return _.JSONDecode(storage.getItem(key)) || {};\n            } catch (err) {\n                // noop\n            }\n            return null;\n        },\n        set: function(key, value) {\n            try {\n                storage.setItem(key, value);\n            } catch (err) {\n                log_error(err);\n            }\n        },\n        remove: function(key) {\n            try {\n                storage.removeItem(key);\n            } catch (err) {\n                log_error(err);\n            }\n        }\n    };\n}\n\n_.localStorage = _storageWrapper(win.localStorage, 'localStorage', localStorageSupported);\n_.sessionStorage = _storageWrapper(win.sessionStorage, 'sessionStorage', sessionStorageSupported);\n\n_.register_event = (function() {\n    // written by Dean Edwards, 2005\n    // with input from Tino Zijdel - crisp@xs4all.nl\n    // with input from Carl Sverre - mail@carlsverre.com\n    // with input from Mixpanel\n    // http://dean.edwards.name/weblog/2005/10/add-event/\n    // https://gist.github.com/1930440\n\n    /**\n     * @param {Object} element\n     * @param {string} type\n     * @param {function(...*)} handler\n     * @param {boolean=} oldSchool\n     * @param {boolean=} useCapture\n     */\n    var register_event = function(element, type, handler, oldSchool, useCapture) {\n        if (!element) {\n            console$1.error('No valid element provided to register_event');\n            return;\n        }\n\n        if (element.addEventListener && !oldSchool) {\n            element.addEventListener(type, handler, !!useCapture);\n        } else {\n            var ontype = 'on' + type;\n            var old_handler = element[ontype]; // can be undefined\n            element[ontype] = makeHandler(element, handler, old_handler);\n        }\n    };\n\n    function makeHandler(element, new_handler, old_handlers) {\n        var handler = function(event) {\n            event = event || fixEvent(win.event);\n\n            // this basically happens in firefox whenever another script\n            // overwrites the onload callback and doesn't pass the event\n            // object to previously defined callbacks.  All the browsers\n            // that don't define window.event implement addEventListener\n            // so the dom_loaded handler will still be fired as usual.\n            if (!event) {\n                return undefined;\n            }\n\n            var ret = true;\n            var old_result, new_result;\n\n            if (_.isFunction(old_handlers)) {\n                old_result = old_handlers(event);\n            }\n            new_result = new_handler.call(element, event);\n\n            if ((false === old_result) || (false === new_result)) {\n                ret = false;\n            }\n\n            return ret;\n        };\n\n        return handler;\n    }\n\n    function fixEvent(event) {\n        if (event) {\n            event.preventDefault = fixEvent.preventDefault;\n            event.stopPropagation = fixEvent.stopPropagation;\n        }\n        return event;\n    }\n    fixEvent.preventDefault = function() {\n        this.returnValue = false;\n    };\n    fixEvent.stopPropagation = function() {\n        this.cancelBubble = true;\n    };\n\n    return register_event;\n})();\n\n\nvar TOKEN_MATCH_REGEX = new RegExp('^(\\\\w*)\\\\[(\\\\w+)([=~\\\\|\\\\^\\\\$\\\\*]?)=?\"?([^\\\\]\"]*)\"?\\\\]$');\n\n_.dom_query = (function() {\n    /* document.getElementsBySelector(selector)\n    - returns an array of element objects from the current document\n    matching the CSS selector. Selectors can contain element names,\n    class names and ids and can be nested. For example:\n\n    elements = document.getElementsBySelector('div#main p a.external')\n\n    Will return an array of all 'a' elements with 'external' in their\n    class attribute that are contained inside 'p' elements that are\n    contained inside the 'div' element which has id=\"main\"\n\n    New in version 0.4: Support for CSS2 and CSS3 attribute selectors:\n    See http://www.w3.org/TR/css3-selectors/#attribute-selectors\n\n    Version 0.4 - Simon Willison, March 25th 2003\n    -- Works in Phoenix 0.5, Mozilla 1.3, Opera 7, Internet Explorer 6, Internet Explorer 5 on Windows\n    -- Opera 7 fails\n\n    Version 0.5 - Carl Sverre, Jan 7th 2013\n    -- Now uses jQuery-esque `hasClass` for testing class name\n    equality.  This fixes a bug related to '-' characters being\n    considered not part of a 'word' in regex.\n    */\n\n    function getAllChildren(e) {\n        // Returns all children of element. Workaround required for IE5/Windows. Ugh.\n        return e.all ? e.all : e.getElementsByTagName('*');\n    }\n\n    var bad_whitespace = /[\\t\\r\\n]/g;\n\n    function hasClass(elem, selector) {\n        var className = ' ' + selector + ' ';\n        return ((' ' + elem.className + ' ').replace(bad_whitespace, ' ').indexOf(className) >= 0);\n    }\n\n    function getElementsBySelector(selector) {\n        // Attempt to fail gracefully in lesser browsers\n        if (!document$1.getElementsByTagName) {\n            return [];\n        }\n        // Split selector in to tokens\n        var tokens = selector.split(' ');\n        var token, bits, tagName, found, foundCount, i, j, k, elements, currentContextIndex;\n        var currentContext = [document$1];\n        for (i = 0; i < tokens.length; i++) {\n            token = tokens[i].replace(/^\\s+/, '').replace(/\\s+$/, '');\n            if (token.indexOf('#') > -1) {\n                // Token is an ID selector\n                bits = token.split('#');\n                tagName = bits[0];\n                var id = bits[1];\n                var element = document$1.getElementById(id);\n                if (!element || (tagName && element.nodeName.toLowerCase() != tagName)) {\n                    // element not found or tag with that ID not found, return false\n                    return [];\n                }\n                // Set currentContext to contain just this element\n                currentContext = [element];\n                continue; // Skip to next token\n            }\n            if (token.indexOf('.') > -1) {\n                // Token contains a class selector\n                bits = token.split('.');\n                tagName = bits[0];\n                var className = bits[1];\n                if (!tagName) {\n                    tagName = '*';\n                }\n                // Get elements matching tag, filter them for class selector\n                found = [];\n                foundCount = 0;\n                for (j = 0; j < currentContext.length; j++) {\n                    if (tagName == '*') {\n                        elements = getAllChildren(currentContext[j]);\n                    } else {\n                        elements = currentContext[j].getElementsByTagName(tagName);\n                    }\n                    for (k = 0; k < elements.length; k++) {\n                        found[foundCount++] = elements[k];\n                    }\n                }\n                currentContext = [];\n                currentContextIndex = 0;\n                for (j = 0; j < found.length; j++) {\n                    if (found[j].className &&\n                        _.isString(found[j].className) && // some SVG elements have classNames which are not strings\n                        hasClass(found[j], className)\n                    ) {\n                        currentContext[currentContextIndex++] = found[j];\n                    }\n                }\n                continue; // Skip to next token\n            }\n            // Code to deal with attribute selectors\n            var token_match = token.match(TOKEN_MATCH_REGEX);\n            if (token_match) {\n                tagName = token_match[1];\n                var attrName = token_match[2];\n                var attrOperator = token_match[3];\n                var attrValue = token_match[4];\n                if (!tagName) {\n                    tagName = '*';\n                }\n                // Grab all of the tagName elements within current context\n                found = [];\n                foundCount = 0;\n                for (j = 0; j < currentContext.length; j++) {\n                    if (tagName == '*') {\n                        elements = getAllChildren(currentContext[j]);\n                    } else {\n                        elements = currentContext[j].getElementsByTagName(tagName);\n                    }\n                    for (k = 0; k < elements.length; k++) {\n                        found[foundCount++] = elements[k];\n                    }\n                }\n                currentContext = [];\n                currentContextIndex = 0;\n                var checkFunction; // This function will be used to filter the elements\n                switch (attrOperator) {\n                    case '=': // Equality\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName) == attrValue);\n                        };\n                        break;\n                    case '~': // Match one of space seperated words\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).match(new RegExp('\\\\b' + attrValue + '\\\\b')));\n                        };\n                        break;\n                    case '|': // Match start with value followed by optional hyphen\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).match(new RegExp('^' + attrValue + '-?')));\n                        };\n                        break;\n                    case '^': // Match starts with value\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).indexOf(attrValue) === 0);\n                        };\n                        break;\n                    case '$': // Match ends with value - fails with \"Warning\" in Opera 7\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).lastIndexOf(attrValue) == e.getAttribute(attrName).length - attrValue.length);\n                        };\n                        break;\n                    case '*': // Match ends with value\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).indexOf(attrValue) > -1);\n                        };\n                        break;\n                    default:\n                        // Just test for existence of attribute\n                        checkFunction = function(e) {\n                            return e.getAttribute(attrName);\n                        };\n                }\n                currentContext = [];\n                currentContextIndex = 0;\n                for (j = 0; j < found.length; j++) {\n                    if (checkFunction(found[j])) {\n                        currentContext[currentContextIndex++] = found[j];\n                    }\n                }\n                // alert('Attribute Selector: '+tagName+' '+attrName+' '+attrOperator+' '+attrValue);\n                continue; // Skip to next token\n            }\n            // If we get here, token is JUST an element (not a class or ID selector)\n            tagName = token;\n            found = [];\n            foundCount = 0;\n            for (j = 0; j < currentContext.length; j++) {\n                elements = currentContext[j].getElementsByTagName(tagName);\n                for (k = 0; k < elements.length; k++) {\n                    found[foundCount++] = elements[k];\n                }\n            }\n            currentContext = found;\n        }\n        return currentContext;\n    }\n\n    return function(query) {\n        if (_.isElement(query)) {\n            return [query];\n        } else if (_.isObject(query) && !_.isUndefined(query.length)) {\n            return query;\n        } else {\n            return getElementsBySelector.call(this, query);\n        }\n    };\n})();\n\nvar CAMPAIGN_KEYWORDS = ['utm_source', 'utm_medium', 'utm_campaign', 'utm_content', 'utm_term', 'utm_id', 'utm_source_platform','utm_campaign_id', 'utm_creative_format', 'utm_marketing_tactic'];\nvar CLICK_IDS = ['dclid', 'fbclid', 'gclid', 'ko_click_id', 'li_fat_id', 'msclkid', 'sccid', 'ttclid', 'twclid', 'wbraid'];\n\n_.info = {\n    campaignParams: function(default_value) {\n        var kw = '',\n            params = {};\n        _.each(CAMPAIGN_KEYWORDS, function(kwkey) {\n            kw = _.getQueryParam(document$1.URL, kwkey);\n            if (kw.length) {\n                params[kwkey] = kw;\n            } else if (default_value !== undefined) {\n                params[kwkey] = default_value;\n            }\n        });\n\n        return params;\n    },\n\n    clickParams: function() {\n        var id = '',\n            params = {};\n        _.each(CLICK_IDS, function(idkey) {\n            id = _.getQueryParam(document$1.URL, idkey);\n            if (id.length) {\n                params[idkey] = id;\n            }\n        });\n\n        return params;\n    },\n\n    marketingParams: function() {\n        return _.extend(_.info.campaignParams(), _.info.clickParams());\n    },\n\n    searchEngine: function(referrer) {\n        if (referrer.search('https?://(.*)google.([^/?]*)') === 0) {\n            return 'google';\n        } else if (referrer.search('https?://(.*)bing.com') === 0) {\n            return 'bing';\n        } else if (referrer.search('https?://(.*)yahoo.com') === 0) {\n            return 'yahoo';\n        } else if (referrer.search('https?://(.*)duckduckgo.com') === 0) {\n            return 'duckduckgo';\n        } else {\n            return null;\n        }\n    },\n\n    searchInfo: function(referrer) {\n        var search = _.info.searchEngine(referrer),\n            param = (search != 'yahoo') ? 'q' : 'p',\n            ret = {};\n\n        if (search !== null) {\n            ret['$search_engine'] = search;\n\n            var keyword = _.getQueryParam(referrer, param);\n            if (keyword.length) {\n                ret['mp_keyword'] = keyword;\n            }\n        }\n\n        return ret;\n    },\n\n    /**\n     * This function detects which browser is running this script.\n     * The order of the checks are important since many user agents\n     * include key words used in later checks.\n     */\n    browser: function(user_agent, vendor, opera) {\n        vendor = vendor || ''; // vendor is undefined for at least IE9\n        if (opera || _.includes(user_agent, ' OPR/')) {\n            if (_.includes(user_agent, 'Mini')) {\n                return 'Opera Mini';\n            }\n            return 'Opera';\n        } else if (/(BlackBerry|PlayBook|BB10)/i.test(user_agent)) {\n            return 'BlackBerry';\n        } else if (_.includes(user_agent, 'IEMobile') || _.includes(user_agent, 'WPDesktop')) {\n            return 'Internet Explorer Mobile';\n        } else if (_.includes(user_agent, 'SamsungBrowser/')) {\n            // https://developer.samsung.com/internet/user-agent-string-format\n            return 'Samsung Internet';\n        } else if (_.includes(user_agent, 'Edge') || _.includes(user_agent, 'Edg/')) {\n            return 'Microsoft Edge';\n        } else if (_.includes(user_agent, 'FBIOS')) {\n            return 'Facebook Mobile';\n        } else if (_.includes(user_agent, 'Whale/')) {\n            // https://user-agents.net/browsers/whale-browser\n            return 'Whale Browser';\n        } else if (_.includes(user_agent, 'Chrome')) {\n            return 'Chrome';\n        } else if (_.includes(user_agent, 'CriOS')) {\n            return 'Chrome iOS';\n        } else if (_.includes(user_agent, 'UCWEB') || _.includes(user_agent, 'UCBrowser')) {\n            return 'UC Browser';\n        } else if (_.includes(user_agent, 'FxiOS')) {\n            return 'Firefox iOS';\n        } else if (_.includes(vendor, 'Apple')) {\n            if (_.includes(user_agent, 'Mobile')) {\n                return 'Mobile Safari';\n            }\n            return 'Safari';\n        } else if (_.includes(user_agent, 'Android')) {\n            return 'Android Mobile';\n        } else if (_.includes(user_agent, 'Konqueror')) {\n            return 'Konqueror';\n        } else if (_.includes(user_agent, 'Firefox')) {\n            return 'Firefox';\n        } else if (_.includes(user_agent, 'MSIE') || _.includes(user_agent, 'Trident/')) {\n            return 'Internet Explorer';\n        } else if (_.includes(user_agent, 'Gecko')) {\n            return 'Mozilla';\n        } else {\n            return '';\n        }\n    },\n\n    /**\n     * This function detects which browser version is running this script,\n     * parsing major and minor version (e.g., 42.1). User agent strings from:\n     * http://www.useragentstring.com/pages/useragentstring.php\n     */\n    browserVersion: function(userAgent, vendor, opera) {\n        var browser = _.info.browser(userAgent, vendor, opera);\n        var versionRegexs = {\n            'Internet Explorer Mobile': /rv:(\\d+(\\.\\d+)?)/,\n            'Microsoft Edge': /Edge?\\/(\\d+(\\.\\d+)?)/,\n            'Chrome': /Chrome\\/(\\d+(\\.\\d+)?)/,\n            'Chrome iOS': /CriOS\\/(\\d+(\\.\\d+)?)/,\n            'UC Browser' : /(UCBrowser|UCWEB)\\/(\\d+(\\.\\d+)?)/,\n            'Safari': /Version\\/(\\d+(\\.\\d+)?)/,\n            'Mobile Safari': /Version\\/(\\d+(\\.\\d+)?)/,\n            'Opera': /(Opera|OPR)\\/(\\d+(\\.\\d+)?)/,\n            'Firefox': /Firefox\\/(\\d+(\\.\\d+)?)/,\n            'Firefox iOS': /FxiOS\\/(\\d+(\\.\\d+)?)/,\n            'Konqueror': /Konqueror:(\\d+(\\.\\d+)?)/,\n            'BlackBerry': /BlackBerry (\\d+(\\.\\d+)?)/,\n            'Android Mobile': /android\\s(\\d+(\\.\\d+)?)/,\n            'Samsung Internet': /SamsungBrowser\\/(\\d+(\\.\\d+)?)/,\n            'Internet Explorer': /(rv:|MSIE )(\\d+(\\.\\d+)?)/,\n            'Mozilla': /rv:(\\d+(\\.\\d+)?)/,\n            'Whale Browser': /Whale\\/(\\d+(\\.\\d+)?)/\n        };\n        var regex = versionRegexs[browser];\n        if (regex === undefined) {\n            return null;\n        }\n        var matches = userAgent.match(regex);\n        if (!matches) {\n            return null;\n        }\n        return parseFloat(matches[matches.length - 2]);\n    },\n\n    os: function() {\n        var a = userAgent;\n        if (/Windows/i.test(a)) {\n            if (/Phone/.test(a) || /WPDesktop/.test(a)) {\n                return 'Windows Phone';\n            }\n            return 'Windows';\n        } else if (/(iPhone|iPad|iPod)/.test(a)) {\n            return 'iOS';\n        } else if (/Android/.test(a)) {\n            return 'Android';\n        } else if (/(BlackBerry|PlayBook|BB10)/i.test(a)) {\n            return 'BlackBerry';\n        } else if (/Mac/i.test(a)) {\n            return 'Mac OS X';\n        } else if (/Linux/.test(a)) {\n            return 'Linux';\n        } else if (/CrOS/.test(a)) {\n            return 'Chrome OS';\n        } else {\n            return '';\n        }\n    },\n\n    device: function(user_agent) {\n        if (/Windows Phone/i.test(user_agent) || /WPDesktop/.test(user_agent)) {\n            return 'Windows Phone';\n        } else if (/iPad/.test(user_agent)) {\n            return 'iPad';\n        } else if (/iPod/.test(user_agent)) {\n            return 'iPod Touch';\n        } else if (/iPhone/.test(user_agent)) {\n            return 'iPhone';\n        } else if (/(BlackBerry|PlayBook|BB10)/i.test(user_agent)) {\n            return 'BlackBerry';\n        } else if (/Android/.test(user_agent)) {\n            return 'Android';\n        } else {\n            return '';\n        }\n    },\n\n    referringDomain: function(referrer) {\n        var split = referrer.split('/');\n        if (split.length >= 3) {\n            return split[2];\n        }\n        return '';\n    },\n\n    currentUrl: function() {\n        return win.location.href;\n    },\n\n    properties: function(extra_props) {\n        if (typeof extra_props !== 'object') {\n            extra_props = {};\n        }\n        return _.extend(_.strip_empty_properties({\n            '$os': _.info.os(),\n            '$browser': _.info.browser(userAgent, navigator.vendor, windowOpera),\n            '$referrer': document$1.referrer,\n            '$referring_domain': _.info.referringDomain(document$1.referrer),\n            '$device': _.info.device(userAgent)\n        }), {\n            '$current_url': _.info.currentUrl(),\n            '$browser_version': _.info.browserVersion(userAgent, navigator.vendor, windowOpera),\n            '$screen_height': screen.height,\n            '$screen_width': screen.width,\n            'mp_lib': 'web',\n            '$lib_version': Config.LIB_VERSION,\n            '$insert_id': cheap_guid(),\n            'time': _.timestamp() / 1000 // epoch time in seconds\n        }, _.strip_empty_properties(extra_props));\n    },\n\n    people_properties: function() {\n        return _.extend(_.strip_empty_properties({\n            '$os': _.info.os(),\n            '$browser': _.info.browser(userAgent, navigator.vendor, windowOpera)\n        }), {\n            '$browser_version': _.info.browserVersion(userAgent, navigator.vendor, windowOpera)\n        });\n    },\n\n    mpPageViewProperties: function() {\n        return _.strip_empty_properties({\n            'current_page_title': document$1.title,\n            'current_domain': win.location.hostname,\n            'current_url_path': win.location.pathname,\n            'current_url_protocol': win.location.protocol,\n            'current_url_search': win.location.search\n        });\n    }\n};\n\n/**\n * Returns a throttled function that will only run at most every `waitMs` and returns a promise that resolves with the next invocation.\n * Throttled calls will build up a batch of args and invoke the callback with all args since the last invocation.\n */\nvar batchedThrottle = function (fn, waitMs) {\n    var timeoutPromise = null;\n    var throttledItems = [];\n    return function (item) {\n        var self = this;\n        throttledItems.push(item);\n\n        if (!timeoutPromise) {\n            timeoutPromise = new PromisePolyfill(function (resolve) {\n                setTimeout(function () {\n                    var returnValue = fn.apply(self, [throttledItems]);\n                    timeoutPromise = null;\n                    throttledItems = [];\n                    resolve(returnValue);\n                }, waitMs);\n            });\n        }\n        return timeoutPromise;\n    };\n};\n\nvar cheap_guid = function(maxlen) {\n    var guid = Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10);\n    return maxlen ? guid.substring(0, maxlen) : guid;\n};\n\n/**\n * Generates a W3C traceparent header for easy interop with distributed tracing systems i.e Open Telemetry\n * https://www.w3.org/TR/trace-context/#traceparent-header\n*/\nvar generateTraceparent = function() {\n    var traceID = _.UUID().replace(/-/g, '');\n    var parentID = _.UUID().replace(/-/g, '').substring(0, 16);\n\n    // Sampled trace\n    var traceFlags = '01';\n\n    return '00-' + traceID + '-' + parentID + '-' + traceFlags;\n};\n\n// naive way to extract domain name (example.com) from full hostname (my.sub.example.com)\nvar SIMPLE_DOMAIN_MATCH_REGEX = /[a-z0-9][a-z0-9-]*\\.[a-z]+$/i;\n// this next one attempts to account for some ccSLDs, e.g. extracting oxford.ac.uk from www.oxford.ac.uk\nvar DOMAIN_MATCH_REGEX = /[a-z0-9][a-z0-9-]+\\.[a-z.]{2,6}$/i;\n/**\n * Attempts to extract main domain name from full hostname, using a few blunt heuristics. For\n * common TLDs like .com/.org that always have a simple SLD.TLD structure (example.com), we\n * simply extract the last two .-separated parts of the hostname (SIMPLE_DOMAIN_MATCH_REGEX).\n * For others, we attempt to account for short ccSLD+TLD combos (.ac.uk) with the legacy\n * DOMAIN_MATCH_REGEX (kept to maintain backwards compatibility with existing Mixpanel\n * integrations). The only _reliable_ way to extract domain from hostname is with an up-to-date\n * list like at https://publicsuffix.org/ so for cases that this helper fails at, the SDK\n * offers the 'cookie_domain' config option to set it explicitly.\n * @example\n * extract_domain('my.sub.example.com')\n * // 'example.com'\n */\nvar extract_domain = function(hostname) {\n    var domain_regex = DOMAIN_MATCH_REGEX;\n    var parts = hostname.split('.');\n    var tld = parts[parts.length - 1];\n    if (tld.length > 4 || tld === 'com' || tld === 'org') {\n        domain_regex = SIMPLE_DOMAIN_MATCH_REGEX;\n    }\n    var matches = hostname.match(domain_regex);\n    return matches ? matches[0] : '';\n};\n\n/**\n * Check whether we have network connection. default to true for browsers that don't support navigator.onLine (IE)\n * @returns {boolean}\n */\nvar isOnline = function() {\n    var onLine = win.navigator['onLine'];\n    return _.isUndefined(onLine) || onLine;\n};\n\nvar NOOP_FUNC = function () {};\n\nvar JSONStringify = null, JSONParse = null;\nif (typeof JSON !== 'undefined') {\n    JSONStringify = JSON.stringify;\n    JSONParse = JSON.parse;\n}\nJSONStringify = JSONStringify || _.JSONEncode;\nJSONParse = JSONParse || _.JSONDecode;\n\n/**\n * Determines if CompressionStream API should be used.\n * Returns false for Safari 16.4 and 16.5 which have breaking CompressionStream bugs.\n * https://bugs.webkit.org/show_bug.cgi?id=254021\n * fixed in 16.6 https://developer.apple.com/documentation/safari-release-notes/safari-16_6-release-notes\n */\nvar canUseCompressionStream = function(userAgent, vendor, opera) {\n    if (!win.CompressionStream) {\n        return false;\n    }\n\n    var browser = _.info.browser(userAgent, vendor, opera);\n    var version = _.info.browserVersion(userAgent, vendor, opera);\n    if (browser === 'Safari' || browser === 'Mobile Safari') {\n        if (version >= 16.4 && version < 16.6) {\n            return false;\n        }\n    }\n\n    return true;\n};\n\n// UNMINIFIED EXPORTS (for closure compiler)\n_['info']                   = _.info;\n_['info']['browser']        = _.info.browser;\n_['info']['browserVersion'] = _.info.browserVersion;\n_['info']['device']         = _.info.device;\n_['info']['properties']     = _.info.properties;\n_['isBlockedUA']            = _.isBlockedUA;\n_['isEmptyObject']          = _.isEmptyObject;\n_['isObject']               = _.isObject;\n_['JSONDecode']             = _.JSONDecode;\n_['JSONEncode']             = _.JSONEncode;\n_['toArray']                = _.toArray;\n_['NPO']                    = NpoPromise;\n\nvar MIXPANEL_DB_NAME = 'mixpanelBrowserDb';\n\nvar RECORDING_EVENTS_STORE_NAME = 'mixpanelRecordingEvents';\nvar RECORDING_REGISTRY_STORE_NAME = 'mixpanelRecordingRegistry';\n\n// note: increment the version number when adding new object stores\nvar DB_VERSION = 1;\nvar OBJECT_STORES = [RECORDING_EVENTS_STORE_NAME, RECORDING_REGISTRY_STORE_NAME];\n\n/**\n * @type {import('./wrapper').StorageWrapper}\n */\nvar IDBStorageWrapper = function (storeName) {\n    /**\n     * @type {Promise<IDBDatabase>|null}\n     */\n    this.dbPromise = null;\n    this.storeName = storeName;\n};\n\nIDBStorageWrapper.prototype._openDb = function () {\n    return new PromisePolyfill(function (resolve, reject) {\n        var openRequest = win.indexedDB.open(MIXPANEL_DB_NAME, DB_VERSION);\n        openRequest['onerror'] = function () {\n            reject(openRequest.error);\n        };\n\n        openRequest['onsuccess'] = function () {\n            resolve(openRequest.result);\n        };\n\n        openRequest['onupgradeneeded'] = function (ev) {\n            var db = ev.target.result;\n\n            OBJECT_STORES.forEach(function (storeName) {\n                db.createObjectStore(storeName);\n            });\n        };\n    });\n};\n\nIDBStorageWrapper.prototype.init = function () {\n    if (!win.indexedDB) {\n        return PromisePolyfill.reject('indexedDB is not supported in this browser');\n    }\n\n    if (!this.dbPromise) {\n        this.dbPromise = this._openDb();\n    }\n\n    return this.dbPromise\n        .then(function (dbOrError) {\n            if (dbOrError instanceof win['IDBDatabase']) {\n                return PromisePolyfill.resolve();\n            } else {\n                return PromisePolyfill.reject(dbOrError);\n            }\n        });\n};\n\nIDBStorageWrapper.prototype.isInitialized = function () {\n    return !!this.dbPromise;\n};\n\n/**\n * @param {IDBTransactionMode} mode\n * @param {function(IDBObjectStore): void} storeCb\n */\nIDBStorageWrapper.prototype.makeTransaction = function (mode, storeCb) {\n    var storeName = this.storeName;\n    var doTransaction = function (db) {\n        return new PromisePolyfill(function (resolve, reject) {\n            var transaction = db.transaction(storeName, mode);\n            transaction.oncomplete = function () {\n                resolve(transaction);\n            };\n            transaction.onabort = transaction.onerror = function () {\n                reject(transaction.error);\n            };\n\n            storeCb(transaction.objectStore(storeName));\n        });\n    };\n\n    return this.dbPromise\n        .then(doTransaction)\n        .catch(function (err) {\n            if (err && err['name'] === 'InvalidStateError') {\n                // try reopening the DB if the connection is closed\n                this.dbPromise = this._openDb();\n                return this.dbPromise.then(doTransaction);\n            } else {\n                return PromisePolyfill.reject(err);\n            }\n        }.bind(this));\n};\n\nIDBStorageWrapper.prototype.setItem = function (key, value) {\n    return this.makeTransaction('readwrite', function (objectStore) {\n        objectStore.put(value, key);\n    });\n};\n\nIDBStorageWrapper.prototype.getItem = function (key) {\n    var req;\n    return this.makeTransaction('readonly', function (objectStore) {\n        req = objectStore.get(key);\n    }).then(function () {\n        return req.result;\n    });\n};\n\nIDBStorageWrapper.prototype.removeItem = function (key) {\n    return this.makeTransaction('readwrite', function (objectStore) {\n        objectStore.delete(key);\n    });\n};\n\nIDBStorageWrapper.prototype.getAll = function () {\n    var req;\n    return this.makeTransaction('readonly', function (objectStore) {\n        req = objectStore.getAll();\n    }).then(function () {\n        return req.result;\n    });\n};\n\n/**\n * GDPR utils\n *\n * The General Data Protection Regulation (GDPR) is a regulation in EU law on data protection\n * and privacy for all individuals within the European Union. It addresses the export of personal\n * data outside the EU. The GDPR aims primarily to give control back to citizens and residents\n * over their personal data and to simplify the regulatory environment for international business\n * by unifying the regulation within the EU.\n *\n * This set of utilities is intended to enable opt in/out functionality in the Mixpanel JS SDK.\n * These functions are used internally by the SDK and are not intended to be publicly exposed.\n */\n\n\n/**\n * A function used to track a Mixpanel event (e.g. MixpanelLib.track)\n * @callback trackFunction\n * @param {String} event_name The name of the event. This can be anything the user does - 'Button Click', 'Sign Up', 'Item Purchased', etc.\n * @param {Object} [properties] A set of properties to include with the event you're sending. These describe the user who did the event or details about the event itself.\n * @param {Function} [callback] If provided, the callback function will be called after tracking the event.\n */\n\n/** Public **/\n\nvar GDPR_DEFAULT_PERSISTENCE_PREFIX = '__mp_opt_in_out_';\n\n/**\n * Opt the user in to data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {trackFunction} [options.track] - function used for tracking a Mixpanel event to record the opt-in action\n * @param {string} [options.trackEventName] - event name to be used for tracking the opt-in action\n * @param {Object} [options.trackProperties] - set of properties to be tracked along with the opt-in action\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-in cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-in cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-in cookie is set as secure or not\n */\nfunction optIn(token, options) {\n    _optInOut(true, token, options);\n}\n\n/**\n * Opt the user out of data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-out cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-out cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-out cookie is set as secure or not\n */\nfunction optOut(token, options) {\n    _optInOut(false, token, options);\n}\n\n/**\n * Check whether the user has opted in to data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @returns {boolean} whether the user has opted in to the given opt type\n */\nfunction hasOptedIn(token, options) {\n    return _getStorageValue(token, options) === '1';\n}\n\n/**\n * Check whether the user has opted out of data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {boolean} [options.ignoreDnt] - flag to ignore browser DNT settings and always return false\n * @returns {boolean} whether the user has opted out of the given opt type\n */\nfunction hasOptedOut(token, options) {\n    if (_hasDoNotTrackFlagOn(options)) {\n        console$1.warn('This browser has \"Do Not Track\" enabled. This will prevent the Mixpanel SDK from sending any data. To ignore the \"Do Not Track\" browser setting, initialize the Mixpanel instance with the config \"ignore_dnt: true\"');\n        return true;\n    }\n    var optedOut = _getStorageValue(token, options) === '0';\n    if (optedOut) {\n        console$1.warn('You are opted out of Mixpanel tracking. This will prevent the Mixpanel SDK from sending any data.');\n    }\n    return optedOut;\n}\n\n/**\n * Wrap a MixpanelLib method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */\nfunction addOptOutCheckMixpanelLib(method) {\n    return _addOptOutCheck(method, function(name) {\n        return this.get_config(name);\n    });\n}\n\n/**\n * Wrap a MixpanelPeople method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */\nfunction addOptOutCheckMixpanelPeople(method) {\n    return _addOptOutCheck(method, function(name) {\n        return this._get_config(name);\n    });\n}\n\n/**\n * Wrap a MixpanelGroup method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */\nfunction addOptOutCheckMixpanelGroup(method) {\n    return _addOptOutCheck(method, function(name) {\n        return this._get_config(name);\n    });\n}\n\n/**\n * Clear the user's opt in/out status of data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-in cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-in cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-in cookie is set as secure or not\n */\nfunction clearOptInOut(token, options) {\n    options = options || {};\n    _getStorage(options).remove(\n        _getStorageKey(token, options), !!options.crossSubdomainCookie, options.cookieDomain\n    );\n}\n\n/** Private **/\n\n/**\n * Get storage util\n * @param {Object} [options]\n * @param {string} [options.persistenceType]\n * @returns {object} either _.cookie or _.localstorage\n */\nfunction _getStorage(options) {\n    options = options || {};\n    return options.persistenceType === 'localStorage' ? _.localStorage : _.cookie;\n}\n\n/**\n * Get the name of the cookie that is used for the given opt type (tracking, cookie, etc.)\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @returns {string} the name of the cookie for the given opt type\n */\nfunction _getStorageKey(token, options) {\n    options = options || {};\n    return (options.persistencePrefix || GDPR_DEFAULT_PERSISTENCE_PREFIX) + token;\n}\n\n/**\n * Get the value of the cookie that is used for the given opt type (tracking, cookie, etc.)\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @returns {string} the value of the cookie for the given opt type\n */\nfunction _getStorageValue(token, options) {\n    return _getStorage(options).get(_getStorageKey(token, options));\n}\n\n/**\n * Check whether the user has set the DNT/doNotTrack setting to true in their browser\n * @param {Object} [options]\n * @param {string} [options.window] - alternate window object to check; used to force various DNT settings in browser tests\n * @param {boolean} [options.ignoreDnt] - flag to ignore browser DNT settings and always return false\n * @returns {boolean} whether the DNT setting is true\n */\nfunction _hasDoNotTrackFlagOn(options) {\n    if (options && options.ignoreDnt) {\n        return false;\n    }\n    var win$1 = (options && options.window) || win;\n    var nav = win$1['navigator'] || {};\n    var hasDntOn = false;\n\n    _.each([\n        nav['doNotTrack'], // standard\n        nav['msDoNotTrack'],\n        win$1['doNotTrack']\n    ], function(dntValue) {\n        if (_.includes([true, 1, '1', 'yes'], dntValue)) {\n            hasDntOn = true;\n        }\n    });\n\n    return hasDntOn;\n}\n\n/**\n * Set cookie/localstorage for the user indicating that they are opted in or out for the given opt type\n * @param {boolean} optValue - whether to opt the user in or out for the given opt type\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {trackFunction} [options.track] - function used for tracking a Mixpanel event to record the opt-in action\n * @param {string} [options.trackEventName] - event name to be used for tracking the opt-in action\n * @param {Object} [options.trackProperties] - set of properties to be tracked along with the opt-in action\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-in cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-in cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-in cookie is set as secure or not\n */\nfunction _optInOut(optValue, token, options) {\n    if (!_.isString(token) || !token.length) {\n        console$1.error('gdpr.' + (optValue ? 'optIn' : 'optOut') + ' called with an invalid token');\n        return;\n    }\n\n    options = options || {};\n\n    _getStorage(options).set(\n        _getStorageKey(token, options),\n        optValue ? 1 : 0,\n        _.isNumber(options.cookieExpiration) ? options.cookieExpiration : null,\n        !!options.crossSubdomainCookie,\n        !!options.secureCookie,\n        !!options.crossSiteCookie,\n        options.cookieDomain\n    );\n\n    if (options.track && optValue) { // only track event if opting in (optValue=true)\n        options.track(options.trackEventName || '$opt_in', options.trackProperties, {\n            'send_immediately': true\n        });\n    }\n}\n\n/**\n * Wrap a method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @param {function} getConfigValue - getter function for the Mixpanel API token and other options to be used with opt-out check\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */\nfunction _addOptOutCheck(method, getConfigValue) {\n    return function() {\n        var optedOut = false;\n\n        try {\n            var token = getConfigValue.call(this, 'token');\n            var ignoreDnt = getConfigValue.call(this, 'ignore_dnt');\n            var persistenceType = getConfigValue.call(this, 'opt_out_tracking_persistence_type');\n            var persistencePrefix = getConfigValue.call(this, 'opt_out_tracking_cookie_prefix');\n            var win = getConfigValue.call(this, 'window'); // used to override window during browser tests\n\n            if (token) { // if there was an issue getting the token, continue method execution as normal\n                optedOut = hasOptedOut(token, {\n                    ignoreDnt: ignoreDnt,\n                    persistenceType: persistenceType,\n                    persistencePrefix: persistencePrefix,\n                    window: win\n                });\n            }\n        } catch(err) {\n            console$1.error('Unexpected error when checking tracking opt-out status: ' + err);\n        }\n\n        if (!optedOut) {\n            return method.apply(this, arguments);\n        }\n\n        var callback = arguments[arguments.length - 1];\n        if (typeof(callback) === 'function') {\n            callback(0);\n        }\n\n        return;\n    };\n}\n\nvar logger$6 = console_with_prefix('lock');\n\n/**\n * SharedLock: a mutex built on HTML5 localStorage, to ensure that only one browser\n * window/tab at a time will be able to access shared resources.\n *\n * Based on the Alur and Taubenfeld fast lock\n * (http://www.cs.rochester.edu/research/synchronization/pseudocode/fastlock.html)\n * with an added timeout to ensure there will be eventual progress in the event\n * that a window is closed in the middle of the callback.\n *\n * Implementation based on the original version by David Wolever (https://github.com/wolever)\n * at https://gist.github.com/wolever/5fd7573d1ef6166e8f8c4af286a69432.\n *\n * @example\n * const myLock = new SharedLock('some-key');\n * myLock.withLock(function() {\n *   console.log('I hold the mutex!');\n * });\n *\n * @constructor\n */\nvar SharedLock = function(key, options) {\n    options = options || {};\n\n    this.storageKey = key;\n    this.storage = options.storage || win.localStorage;\n    this.pollIntervalMS = options.pollIntervalMS || 100;\n    this.timeoutMS = options.timeoutMS || 2000;\n\n    // dependency-inject promise implementation for testing purposes\n    this.promiseImpl = options.promiseImpl || PromisePolyfill;\n};\n\n// pass in a specific pid to test contention scenarios; otherwise\n// it is chosen randomly for each acquisition attempt\nSharedLock.prototype.withLock = function(lockedCB, pid) {\n    var Promise = this.promiseImpl;\n    return new Promise(_.bind(function (resolve, reject) {\n        var i = pid || (new Date().getTime() + '|' + Math.random());\n        var startTime = new Date().getTime();\n        var key = this.storageKey;\n        var pollIntervalMS = this.pollIntervalMS;\n        var timeoutMS = this.timeoutMS;\n        var storage = this.storage;\n\n        var keyX = key + ':X';\n        var keyY = key + ':Y';\n        var keyZ = key + ':Z';\n\n        var delay = function(cb) {\n            if (new Date().getTime() - startTime > timeoutMS) {\n                logger$6.error('Timeout waiting for mutex on ' + key + '; clearing lock. [' + i + ']');\n                storage.removeItem(keyZ);\n                storage.removeItem(keyY);\n                loop();\n                return;\n            }\n            setTimeout(function() {\n                try {\n                    cb();\n                } catch(err) {\n                    reject(err);\n                }\n            }, pollIntervalMS * (Math.random() + 0.1));\n        };\n\n        var waitFor = function(predicate, cb) {\n            if (predicate()) {\n                cb();\n            } else {\n                delay(function() {\n                    waitFor(predicate, cb);\n                });\n            }\n        };\n\n        var getSetY = function() {\n            var valY = storage.getItem(keyY);\n            if (valY && valY !== i) { // if Y == i then this process already has the lock (useful for test cases)\n                return false;\n            } else {\n                storage.setItem(keyY, i);\n                if (storage.getItem(keyY) === i) {\n                    return true;\n                } else {\n                    if (!localStorageSupported(storage, true)) {\n                        reject(new Error('localStorage support dropped while acquiring lock'));\n                    }\n                    return false;\n                }\n            }\n        };\n\n        var loop = function() {\n            storage.setItem(keyX, i);\n\n            waitFor(getSetY, function() {\n                if (storage.getItem(keyX) === i) {\n                    criticalSection();\n                    return;\n                }\n\n                delay(function() {\n                    if (storage.getItem(keyY) !== i) {\n                        loop();\n                        return;\n                    }\n                    waitFor(function() {\n                        return !storage.getItem(keyZ);\n                    }, criticalSection);\n                });\n            });\n        };\n\n        var criticalSection = function() {\n            storage.setItem(keyZ, '1');\n            var removeLock = function () {\n                storage.removeItem(keyZ);\n                if (storage.getItem(keyY) === i) {\n                    storage.removeItem(keyY);\n                }\n                if (storage.getItem(keyX) === i) {\n                    storage.removeItem(keyX);\n                }\n            };\n\n            lockedCB()\n                .then(function (ret) {\n                    removeLock();\n                    resolve(ret);\n                })\n                .catch(function (err) {\n                    removeLock();\n                    reject(err);\n                });\n        };\n\n        try {\n            if (localStorageSupported(storage, true)) {\n                loop();\n            } else {\n                throw new Error('localStorage support check failed');\n            }\n        } catch(err) {\n            reject(err);\n        }\n    }, this));\n};\n\n/**\n * @type {import('./wrapper').StorageWrapper}\n */\nvar LocalStorageWrapper = function (storageOverride) {\n    this.storage = storageOverride || win.localStorage;\n};\n\nLocalStorageWrapper.prototype.init = function () {\n    return PromisePolyfill.resolve();\n};\n\nLocalStorageWrapper.prototype.isInitialized = function () {\n    return true;\n};\n\nLocalStorageWrapper.prototype.setItem = function (key, value) {\n    return new PromisePolyfill(_.bind(function (resolve, reject) {\n        try {\n            this.storage.setItem(key, JSONStringify(value));\n        } catch (e) {\n            reject(e);\n        }\n        resolve();\n    }, this));\n};\n\nLocalStorageWrapper.prototype.getItem = function (key) {\n    return new PromisePolyfill(_.bind(function (resolve, reject) {\n        var item;\n        try {\n            item = JSONParse(this.storage.getItem(key));\n        } catch (e) {\n            reject(e);\n        }\n        resolve(item);\n    }, this));\n};\n\nLocalStorageWrapper.prototype.removeItem = function (key) {\n    return new PromisePolyfill(_.bind(function (resolve, reject) {\n        try {\n            this.storage.removeItem(key);\n        } catch (e) {\n            reject(e);\n        }\n        resolve();\n    }, this));\n};\n\nvar logger$5 = console_with_prefix('batch');\n\n/**\n * RequestQueue: queue for batching API requests with localStorage backup for retries.\n * Maintains an in-memory queue which represents the source of truth for the current\n * page, but also writes all items out to a copy in the browser's localStorage, which\n * can be read on subsequent pageloads and retried. For batchability, all the request\n * items in the queue should be of the same type (events, people updates, group updates)\n * so they can be sent in a single request to the same API endpoint.\n *\n * LocalStorage keying and locking: In order for reloads and subsequent pageloads of\n * the same site to access the same persisted data, they must share the same localStorage\n * key (for instance based on project token and queue type). Therefore access to the\n * localStorage entry is guarded by an asynchronous mutex (SharedLock) to prevent\n * simultaneously open windows/tabs from overwriting each other's data (which would lead\n * to data loss in some situations).\n * @constructor\n */\nvar RequestQueue = function (storageKey, options) {\n    options = options || {};\n    this.storageKey = storageKey;\n    this.usePersistence = options.usePersistence;\n    if (this.usePersistence) {\n        this.queueStorage = options.queueStorage || new LocalStorageWrapper();\n        this.lock = new SharedLock(storageKey, {\n            storage: options.sharedLockStorage || win.localStorage,\n            timeoutMS: options.sharedLockTimeoutMS,\n        });\n    }\n    this.reportError = options.errorReporter || _.bind(logger$5.error, logger$5);\n\n    this.pid = options.pid || null; // pass pid to test out storage lock contention scenarios\n\n    this.memQueue = [];\n    this.initialized = false;\n\n    if (options.enqueueThrottleMs) {\n        this.enqueuePersisted = batchedThrottle(_.bind(this._enqueuePersisted, this), options.enqueueThrottleMs);\n    } else {\n        this.enqueuePersisted = _.bind(function (queueEntry) {\n            return this._enqueuePersisted([queueEntry]);\n        }, this);\n    }\n};\n\nRequestQueue.prototype.ensureInit = function () {\n    if (this.initialized || !this.usePersistence) {\n        return PromisePolyfill.resolve();\n    }\n\n    return this.queueStorage\n        .init()\n        .then(_.bind(function () {\n            this.initialized = true;\n        }, this))\n        .catch(_.bind(function (err) {\n            this.reportError('Error initializing queue persistence. Disabling persistence', err);\n            this.initialized = true;\n            this.usePersistence = false;\n        }, this));\n};\n\n/**\n * Add one item to queues (memory and localStorage). The queued entry includes\n * the given item along with an auto-generated ID and a \"flush-after\" timestamp.\n * It is expected that the item will be sent over the network and dequeued\n * before the flush-after time; if this doesn't happen it is considered orphaned\n * (e.g., the original tab where it was enqueued got closed before it could be\n * sent) and the item can be sent by any tab that finds it in localStorage.\n *\n * The final callback param is called with a param indicating success or\n * failure of the enqueue operation; it is asynchronous because the localStorage\n * lock is asynchronous.\n */\nRequestQueue.prototype.enqueue = function (item, flushInterval) {\n    var queueEntry = {\n        'id': cheap_guid(),\n        'flushAfter': new Date().getTime() + flushInterval * 2,\n        'payload': item\n    };\n\n    if (!this.usePersistence) {\n        this.memQueue.push(queueEntry);\n        return PromisePolyfill.resolve(true);\n    } else {\n        return this.enqueuePersisted(queueEntry);\n    }\n};\n\nRequestQueue.prototype._enqueuePersisted = function (queueEntries) {\n    var enqueueItem = _.bind(function () {\n        return this.ensureInit()\n            .then(_.bind(function () {\n                return this.readFromStorage();\n            }, this))\n            .then(_.bind(function (storedQueue) {\n                return this.saveToStorage(storedQueue.concat(queueEntries));\n            }, this))\n            .then(_.bind(function (succeeded) {\n                // only add to in-memory queue when storage succeeds\n                if (succeeded) {\n                    this.memQueue = this.memQueue.concat(queueEntries);\n                }\n\n                return succeeded;\n            }, this))\n            .catch(_.bind(function (err) {\n                this.reportError('Error enqueueing items', err, queueEntries);\n                return false;\n            }, this));\n    }, this);\n\n    return this.lock\n        .withLock(enqueueItem, this.pid)\n        .catch(_.bind(function (err) {\n            this.reportError('Error acquiring storage lock', err);\n            return false;\n        }, this));\n};\n\n/**\n * Read out the given number of queue entries. If this.memQueue\n * has fewer than batchSize items, then look for \"orphaned\" items\n * in the persisted queue (items where the 'flushAfter' time has\n * already passed).\n */\nRequestQueue.prototype.fillBatch = function (batchSize) {\n    var batch = this.memQueue.slice(0, batchSize);\n    if (this.usePersistence && batch.length < batchSize) {\n        // don't need lock just to read events; localStorage is thread-safe\n        // and the worst that could happen is a duplicate send of some\n        // orphaned events, which will be deduplicated on the server side\n        return this.ensureInit()\n            .then(_.bind(function () {\n                return this.readFromStorage();\n            }, this))\n            .then(_.bind(function (storedQueue) {\n                if (storedQueue.length) {\n                    // item IDs already in batch; don't duplicate out of storage\n                    var idsInBatch = {}; // poor man's Set\n                    _.each(batch, function (item) {\n                        idsInBatch[item['id']] = true;\n                    });\n\n                    for (var i = 0; i < storedQueue.length; i++) {\n                        var item = storedQueue[i];\n                        if (new Date().getTime() > item['flushAfter'] && !idsInBatch[item['id']]) {\n                            item.orphaned = true;\n                            batch.push(item);\n                            if (batch.length >= batchSize) {\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                return batch;\n            }, this));\n    } else {\n        return PromisePolyfill.resolve(batch);\n    }\n};\n\n/**\n * Remove items with matching 'id' from array (immutably)\n * also remove any item without a valid id (e.g., malformed\n * storage entries).\n */\nvar filterOutIDsAndInvalid = function (items, idSet) {\n    var filteredItems = [];\n    _.each(items, function (item) {\n        if (item['id'] && !idSet[item['id']]) {\n            filteredItems.push(item);\n        }\n    });\n    return filteredItems;\n};\n\n/**\n * Remove items with matching IDs from both in-memory queue\n * and persisted queue\n */\nRequestQueue.prototype.removeItemsByID = function (ids) {\n    var idSet = {}; // poor man's Set\n    _.each(ids, function (id) {\n        idSet[id] = true;\n    });\n\n    this.memQueue = filterOutIDsAndInvalid(this.memQueue, idSet);\n    if (!this.usePersistence) {\n        return PromisePolyfill.resolve(true);\n    } else {\n        var removeFromStorage = _.bind(function () {\n            return this.ensureInit()\n                .then(_.bind(function () {\n                    return this.readFromStorage();\n                }, this))\n                .then(_.bind(function (storedQueue) {\n                    storedQueue = filterOutIDsAndInvalid(storedQueue, idSet);\n                    return this.saveToStorage(storedQueue);\n                }, this))\n                .then(_.bind(function () {\n                    return this.readFromStorage();\n                }, this))\n                .then(_.bind(function (storedQueue) {\n                    // an extra check: did storage report success but somehow\n                    // the items are still there?\n                    for (var i = 0; i < storedQueue.length; i++) {\n                        var item = storedQueue[i];\n                        if (item['id'] && !!idSet[item['id']]) {\n                            throw new Error('Item not removed from storage');\n                        }\n                    }\n                    return true;\n                }, this))\n                .catch(_.bind(function (err) {\n                    this.reportError('Error removing items', err, ids);\n                    return false;\n                }, this));\n        }, this);\n\n        return this.lock\n            .withLock(removeFromStorage, this.pid)\n            .catch(_.bind(function (err) {\n                this.reportError('Error acquiring storage lock', err);\n                if (!localStorageSupported(this.lock.storage, true)) {\n                    // Looks like localStorage writes have stopped working sometime after\n                    // initialization (probably full), and so nobody can acquire locks\n                    // anymore. Consider it temporarily safe to remove items without the\n                    // lock, since nobody's writing successfully anyway.\n                    return removeFromStorage()\n                        .then(_.bind(function (success) {\n                            if (!success) {\n                                // OK, we couldn't even write out the smaller queue. Try clearing it\n                                // entirely.\n                                return this.queueStorage.removeItem(this.storageKey).then(function () {\n                                    return success;\n                                });\n                            }\n                            return success;\n                        }, this))\n                        .catch(_.bind(function (err) {\n                            this.reportError('Error clearing queue', err);\n                            return false;\n                        }, this));\n                } else {\n                    return false;\n                }\n            }, this));\n    }\n};\n\n// internal helper for RequestQueue.updatePayloads\nvar updatePayloads = function (existingItems, itemsToUpdate) {\n    var newItems = [];\n    _.each(existingItems, function (item) {\n        var id = item['id'];\n        if (id in itemsToUpdate) {\n            var newPayload = itemsToUpdate[id];\n            if (newPayload !== null) {\n                item['payload'] = newPayload;\n                newItems.push(item);\n            }\n        } else {\n            // no update\n            newItems.push(item);\n        }\n    });\n    return newItems;\n};\n\n/**\n * Update payloads of given items in both in-memory queue and\n * persisted queue. Items set to null are removed from queues.\n */\nRequestQueue.prototype.updatePayloads = function (itemsToUpdate) {\n    this.memQueue = updatePayloads(this.memQueue, itemsToUpdate);\n    if (!this.usePersistence) {\n        return PromisePolyfill.resolve(true);\n    } else {\n        return this.lock\n            .withLock(_.bind(function lockAcquired() {\n                return this.ensureInit()\n                    .then(_.bind(function () {\n                        return this.readFromStorage();\n                    }, this))\n                    .then(_.bind(function (storedQueue) {\n                        storedQueue = updatePayloads(storedQueue, itemsToUpdate);\n                        return this.saveToStorage(storedQueue);\n                    }, this))\n                    .catch(_.bind(function (err) {\n                        this.reportError('Error updating items', itemsToUpdate, err);\n                        return false;\n                    }, this));\n            }, this), this.pid)\n            .catch(_.bind(function (err) {\n                this.reportError('Error acquiring storage lock', err);\n                return false;\n            }, this));\n    }\n};\n\n/**\n * Read and parse items array from localStorage entry, handling\n * malformed/missing data if necessary.\n */\nRequestQueue.prototype.readFromStorage = function () {\n    return this.ensureInit()\n        .then(_.bind(function () {\n            return this.queueStorage.getItem(this.storageKey);\n        }, this))\n        .then(_.bind(function (storageEntry) {\n            if (storageEntry) {\n                if (!_.isArray(storageEntry)) {\n                    this.reportError('Invalid storage entry:', storageEntry);\n                    storageEntry = null;\n                }\n            }\n            return storageEntry || [];\n        }, this))\n        .catch(_.bind(function (err) {\n            this.reportError('Error retrieving queue', err);\n            return [];\n        }, this));\n};\n\n/**\n * Serialize the given items array to localStorage.\n */\nRequestQueue.prototype.saveToStorage = function (queue) {\n    return this.ensureInit()\n        .then(_.bind(function () {\n            return this.queueStorage.setItem(this.storageKey, queue);\n        }, this))\n        .then(function () {\n            return true;\n        })\n        .catch(_.bind(function (err) {\n            this.reportError('Error saving queue', err);\n            return false;\n        }, this));\n};\n\n/**\n * Clear out queues (memory and localStorage).\n */\nRequestQueue.prototype.clear = function () {\n    this.memQueue = [];\n\n    if (this.usePersistence) {\n        return this.ensureInit()\n            .then(_.bind(function () {\n                return this.queueStorage.removeItem(this.storageKey);\n            }, this));\n    } else {\n        return PromisePolyfill.resolve();\n    }\n};\n\n// maximum interval between request retries after exponential backoff\nvar MAX_RETRY_INTERVAL_MS = 10 * 60 * 1000; // 10 minutes\n\nvar logger$4 = console_with_prefix('batch');\n\n/**\n * RequestBatcher: manages the queueing, flushing, retry etc of requests of one\n * type (events, people, groups).\n * Uses RequestQueue to manage the backing store.\n * @constructor\n */\nvar RequestBatcher = function(storageKey, options) {\n    this.errorReporter = options.errorReporter;\n    this.queue = new RequestQueue(storageKey, {\n        errorReporter: _.bind(this.reportError, this),\n        queueStorage: options.queueStorage,\n        sharedLockStorage: options.sharedLockStorage,\n        sharedLockTimeoutMS: options.sharedLockTimeoutMS,\n        usePersistence: options.usePersistence,\n        enqueueThrottleMs: options.enqueueThrottleMs\n    });\n\n    this.libConfig = options.libConfig;\n    this.sendRequest = options.sendRequestFunc;\n    this.beforeSendHook = options.beforeSendHook;\n    this.stopAllBatching = options.stopAllBatchingFunc;\n\n    // seed variable batch size + flush interval with configured values\n    this.batchSize = this.libConfig['batch_size'];\n    this.flushInterval = this.libConfig['batch_flush_interval_ms'];\n\n    this.stopped = !this.libConfig['batch_autostart'];\n    this.consecutiveRemovalFailures = 0;\n\n    // extra client-side dedupe\n    this.itemIdsSentSuccessfully = {};\n\n    // Make the flush occur at the interval specified by flushIntervalMs, default behavior will attempt consecutive flushes\n    // as long as the queue is not empty. This is useful for high-frequency events like Session Replay where we might end up\n    // in a request loop and get ratelimited by the server.\n    this.flushOnlyOnInterval = options.flushOnlyOnInterval || false;\n\n    this._flushPromise = null;\n};\n\n/**\n * Add one item to queue.\n */\nRequestBatcher.prototype.enqueue = function(item) {\n    return this.queue.enqueue(item, this.flushInterval);\n};\n\n/**\n * Start flushing batches at the configured time interval. Must call\n * this method upon SDK init in order to send anything over the network.\n */\nRequestBatcher.prototype.start = function() {\n    this.stopped = false;\n    this.consecutiveRemovalFailures = 0;\n    return this.flush();\n};\n\n/**\n * Stop flushing batches. Can be restarted by calling start().\n */\nRequestBatcher.prototype.stop = function() {\n    this.stopped = true;\n    if (this.timeoutID) {\n        clearTimeout(this.timeoutID);\n        this.timeoutID = null;\n    }\n};\n\n/**\n * Clear out queue.\n */\nRequestBatcher.prototype.clear = function() {\n    return this.queue.clear();\n};\n\n/**\n * Restore batch size configuration to whatever is set in the main SDK.\n */\nRequestBatcher.prototype.resetBatchSize = function() {\n    this.batchSize = this.libConfig['batch_size'];\n};\n\n/**\n * Restore flush interval time configuration to whatever is set in the main SDK.\n */\nRequestBatcher.prototype.resetFlush = function() {\n    this.scheduleFlush(this.libConfig['batch_flush_interval_ms']);\n};\n\n/**\n * Schedule the next flush in the given number of milliseconds.\n */\nRequestBatcher.prototype.scheduleFlush = function(flushMS) {\n    this.flushInterval = flushMS;\n    if (!this.stopped) { // don't schedule anymore if batching has been stopped\n        this.timeoutID = setTimeout(_.bind(function() {\n            if (!this.stopped) {\n                this._flushPromise = this.flush();\n            }\n        }, this), this.flushInterval);\n    }\n};\n\n/**\n * Send a request using the sendRequest callback, but promisified.\n * TODO: sendRequest should be promisified in the first place.\n */\nRequestBatcher.prototype.sendRequestPromise = function(data, options) {\n    return new PromisePolyfill(_.bind(function(resolve) {\n        this.sendRequest(data, options, resolve);\n    }, this));\n};\n\n\n/**\n * Flush one batch to network. Depending on success/failure modes, it will either\n * remove the batch from the queue or leave it in for retry, and schedule the next\n * flush. In cases of most network or API failures, it will back off exponentially\n * when retrying.\n * @param {Object} [options]\n * @param {boolean} [options.sendBeacon] - whether to send batch with\n * navigator.sendBeacon (only useful for sending batches before page unloads, as\n * sendBeacon offers no callbacks or status indications)\n */\nRequestBatcher.prototype.flush = function(options) {\n    if (this.requestInProgress) {\n        logger$4.log('Flush: Request already in progress');\n        return PromisePolyfill.resolve();\n    }\n\n    this.requestInProgress = true;\n\n    options = options || {};\n    var timeoutMS = this.libConfig['batch_request_timeout_ms'];\n    var startTime = new Date().getTime();\n    var currentBatchSize = this.batchSize;\n\n    return this.queue.fillBatch(currentBatchSize)\n        .then(_.bind(function(batch) {\n\n            // if there's more items in the queue than the batch size, attempt\n            // to flush again after the current batch is done.\n            var attemptSecondaryFlush = batch.length === currentBatchSize;\n            var dataForRequest = [];\n            var transformedItems = {};\n            _.each(batch, function(item) {\n                var payload = item['payload'];\n                if (this.beforeSendHook && !item.orphaned) {\n                    payload = this.beforeSendHook(payload);\n                }\n                if (payload) {\n                    // mp_sent_by_lib_version prop captures which lib version actually\n                    // sends each event (regardless of which version originally queued\n                    // it for sending)\n                    if (payload['event'] && payload['properties']) {\n                        payload['properties'] = _.extend(\n                            {},\n                            payload['properties'],\n                            {'mp_sent_by_lib_version': Config.LIB_VERSION}\n                        );\n                    }\n                    var addPayload = true;\n                    var itemId = item['id'];\n                    if (itemId) {\n                        if ((this.itemIdsSentSuccessfully[itemId] || 0) > 5) {\n                            this.reportError('[dupe] item ID sent too many times, not sending', {\n                                item: item,\n                                batchSize: batch.length,\n                                timesSent: this.itemIdsSentSuccessfully[itemId]\n                            });\n                            addPayload = false;\n                        }\n                    } else {\n                        this.reportError('[dupe] found item with no ID', {item: item});\n                    }\n\n                    if (addPayload) {\n                        dataForRequest.push(payload);\n                    }\n                }\n                transformedItems[item['id']] = payload;\n            }, this);\n\n            if (dataForRequest.length < 1) {\n                this.requestInProgress = false;\n                this.resetFlush();\n                return PromisePolyfill.resolve(); // nothing to do\n            }\n\n            var removeItemsFromQueue = _.bind(function () {\n                return this.queue\n                    .removeItemsByID(\n                        _.map(batch, function (item) {\n                            return item['id'];\n                        })\n                    )\n                    .then(_.bind(function (succeeded) {\n                        // client-side dedupe\n                        _.each(batch, _.bind(function(item) {\n                            var itemId = item['id'];\n                            if (itemId) {\n                                this.itemIdsSentSuccessfully[itemId] = this.itemIdsSentSuccessfully[itemId] || 0;\n                                this.itemIdsSentSuccessfully[itemId]++;\n                                if (this.itemIdsSentSuccessfully[itemId] > 5) {\n                                    this.reportError('[dupe] item ID sent too many times', {\n                                        item: item,\n                                        batchSize: batch.length,\n                                        timesSent: this.itemIdsSentSuccessfully[itemId]\n                                    });\n                                }\n                            } else {\n                                this.reportError('[dupe] found item with no ID while removing', {item: item});\n                            }\n                        }, this));\n\n                        if (succeeded) {\n                            this.consecutiveRemovalFailures = 0;\n                            if (this.flushOnlyOnInterval && !attemptSecondaryFlush) {\n                                this.resetFlush(); // schedule next batch with a delay\n                                return PromisePolyfill.resolve();\n                            } else {\n                                return this.flush(); // handle next batch if the queue isn't empty\n                            }\n                        } else {\n                            if (++this.consecutiveRemovalFailures > 5) {\n                                this.reportError('Too many queue failures; disabling batching system.');\n                                this.stopAllBatching();\n                            } else {\n                                this.resetFlush();\n                            }\n                            return PromisePolyfill.resolve();\n                        }\n                    }, this));\n            }, this);\n\n            var batchSendCallback = _.bind(function(res) {\n                this.requestInProgress = false;\n\n                try {\n\n                    // handle API response in a try-catch to make sure we can reset the\n                    // flush operation if something goes wrong\n\n                    if (options.unloading) {\n                        // update persisted data to include hook transformations\n                        return this.queue.updatePayloads(transformedItems);\n                    } else if (\n                        _.isObject(res) &&\n                            res.error === 'timeout' &&\n                            new Date().getTime() - startTime >= timeoutMS\n                    ) {\n                        this.reportError('Network timeout; retrying');\n                        return this.flush();\n                    } else if (\n                        _.isObject(res) &&\n                            (\n                                res.httpStatusCode >= 500\n                                || res.httpStatusCode === 429\n                                || (res.httpStatusCode <= 0 && !isOnline())\n                                || res.error === 'timeout'\n                            )\n                    ) {\n                        // network or API error, or 429 Too Many Requests, retry\n                        var retryMS = this.flushInterval * 2;\n                        if (res.retryAfter) {\n                            retryMS = (parseInt(res.retryAfter, 10) * 1000) || retryMS;\n                        }\n                        retryMS = Math.min(MAX_RETRY_INTERVAL_MS, retryMS);\n                        this.reportError('Error; retry in ' + retryMS + ' ms');\n                        this.scheduleFlush(retryMS);\n                        return PromisePolyfill.resolve();\n                    } else if (_.isObject(res) && res.httpStatusCode === 413) {\n                        // 413 Payload Too Large\n                        if (batch.length > 1) {\n                            var halvedBatchSize = Math.max(1, Math.floor(currentBatchSize / 2));\n                            this.batchSize = Math.min(this.batchSize, halvedBatchSize, batch.length - 1);\n                            this.reportError('413 response; reducing batch size to ' + this.batchSize);\n                            this.resetFlush();\n                            return PromisePolyfill.resolve();\n                        } else {\n                            this.reportError('Single-event request too large; dropping', batch);\n                            this.resetBatchSize();\n                            return removeItemsFromQueue();\n                        }\n                    } else {\n                        // successful network request+response; remove each item in batch from queue\n                        // (even if it was e.g. a 400, in which case retrying won't help)\n                        return removeItemsFromQueue();\n                    }\n                } catch(err) {\n                    this.reportError('Error handling API response', err);\n                    this.resetFlush();\n                }\n            }, this);\n            var requestOptions = {\n                method: 'POST',\n                verbose: true,\n                ignore_json_errors: true, // eslint-disable-line camelcase\n                timeout_ms: timeoutMS // eslint-disable-line camelcase\n            };\n            if (options.unloading) {\n                requestOptions.transport = 'sendBeacon';\n            }\n            logger$4.log('MIXPANEL REQUEST:', dataForRequest);\n            return this.sendRequestPromise(dataForRequest, requestOptions).then(batchSendCallback);\n        }, this))\n        .catch(_.bind(function(err) {\n            this.reportError('Error flushing request queue', err);\n            this.resetFlush();\n        }, this));\n};\n\n/**\n * Log error to global logger and optional user-defined logger.\n */\nRequestBatcher.prototype.reportError = function(msg, err) {\n    logger$4.error.apply(logger$4.error, arguments);\n    if (this.errorReporter) {\n        try {\n            if (!(err instanceof Error)) {\n                err = new Error(msg);\n            }\n            this.errorReporter(msg, err);\n        } catch(err) {\n            logger$4.error(err);\n        }\n    }\n};\n\n/**\n * @param {import('./session-recording').SerializedRecording} serializedRecording\n * @returns {boolean}\n */\nvar isRecordingExpired = function(serializedRecording) {\n    var now = Date.now();\n    return !serializedRecording || now > serializedRecording['maxExpires'] || now > serializedRecording['idleExpires'];\n};\n\nvar RECORD_ENQUEUE_THROTTLE_MS = 250;\n\nvar logger$3 = console_with_prefix('recorder');\nvar CompressionStream = win['CompressionStream'];\n\nvar RECORDER_BATCHER_LIB_CONFIG = {\n    'batch_size': 1000,\n    'batch_flush_interval_ms': 10 * 1000,\n    'batch_request_timeout_ms': 90 * 1000,\n    'batch_autostart': true\n};\n\nvar ACTIVE_SOURCES = new Set([\n    IncrementalSource.MouseMove,\n    IncrementalSource.MouseInteraction,\n    IncrementalSource.Scroll,\n    IncrementalSource.ViewportResize,\n    IncrementalSource.Input,\n    IncrementalSource.TouchMove,\n    IncrementalSource.MediaInteraction,\n    IncrementalSource.Drag,\n    IncrementalSource.Selection,\n]);\n\nfunction isUserEvent(ev) {\n    return ev.type === EventType.IncrementalSnapshot && ACTIVE_SOURCES.has(ev.data.source);\n}\n\n/**\n * @typedef {Object} SerializedRecording\n * @property {number} idleExpires\n * @property {number} maxExpires\n * @property {number} replayStartTime\n * @property {number} lastEventTimestamp\n * @property {number} seqNo\n * @property {string} batchStartUrl\n * @property {string} replayId\n * @property {string} tabId\n * @property {string} replayStartUrl\n */\n\n/**\n * @typedef {Object} SessionRecordingOptions\n * @property {Object} [options.mixpanelInstance] - reference to the core MixpanelLib\n * @property {String} [options.replayId] - unique uuid for a single replay\n * @property {Function} [options.onIdleTimeout] - callback when a recording reaches idle timeout\n * @property {Function} [options.onMaxLengthReached] - callback when a recording reaches its maximum length\n * @property {Function} [options.rrwebRecord] - rrweb's `record` function\n * @property {Function} [options.onBatchSent] - callback when a batch of events is sent to the server\n * @property {Storage} [options.sharedLockStorage] - optional storage for shared lock, used for test dependency injection\n * optional properties for deserialization:\n * @property {number} idleExpires\n * @property {number} maxExpires\n * @property {number} replayStartTime\n * @property {number} lastEventTimestamp - the unix timestamp of the last recorded event from rrweb\n * @property {number} seqNo\n * @property {string} batchStartUrl\n * @property {string} replayStartUrl\n */\n\n/**\n * @typedef {Object} UserIdInfo\n * @property {string} distinct_id\n * @property {string} user_id\n * @property {string} device_id\n */\n\n\n/**\n * This class encapsulates a single session recording and its lifecycle.\n * @param {SessionRecordingOptions} options\n */\nvar SessionRecording = function(options) {\n    this._mixpanel = options.mixpanelInstance;\n    this._onIdleTimeout = options.onIdleTimeout || NOOP_FUNC;\n    this._onMaxLengthReached = options.onMaxLengthReached || NOOP_FUNC;\n    this._onBatchSent = options.onBatchSent || NOOP_FUNC;\n    this._rrwebRecord = options.rrwebRecord || null;\n\n    // internal rrweb stopRecording function\n    this._stopRecording = null;\n    this.replayId = options.replayId;\n\n    this.batchStartUrl = options.batchStartUrl || null;\n    this.replayStartUrl = options.replayStartUrl || null;\n    this.idleExpires = options.idleExpires || null;\n    this.maxExpires = options.maxExpires || null;\n    this.replayStartTime = options.replayStartTime || null;\n    this.lastEventTimestamp = options.lastEventTimestamp || null;\n    this.seqNo = options.seqNo || 0;\n\n    this.idleTimeoutId = null;\n    this.maxTimeoutId = null;\n\n    this.recordMaxMs = MAX_RECORDING_MS;\n    this.recordMinMs = 0;\n\n    // disable persistence if localStorage is not supported\n    // request-queue will automatically disable persistence if indexedDB fails to initialize\n    var usePersistence = localStorageSupported(options.sharedLockStorage, true) && !this.getConfig('disable_persistence');\n\n    // each replay has its own batcher key to avoid conflicts between rrweb events of different recordings\n    this.batcherKey = '__mprec_' + this.getConfig('name') + '_' + this.getConfig('token') + '_' + this.replayId;\n    this.queueStorage = new IDBStorageWrapper(RECORDING_EVENTS_STORE_NAME);\n    this.batcher = new RequestBatcher(this.batcherKey, {\n        errorReporter: this.reportError.bind(this),\n        flushOnlyOnInterval: true,\n        libConfig: RECORDER_BATCHER_LIB_CONFIG,\n        sendRequestFunc: this.flushEventsWithOptOut.bind(this),\n        queueStorage: this.queueStorage,\n        sharedLockStorage: options.sharedLockStorage,\n        usePersistence: usePersistence,\n        stopAllBatchingFunc: this.stopRecording.bind(this),\n\n        // increased throttle and shared lock timeout because recording events are very high frequency.\n        // this will minimize the amount of lock contention between enqueued events.\n        // for session recordings there is a lock for each tab anyway, so there's no risk of deadlock between tabs.\n        enqueueThrottleMs: RECORD_ENQUEUE_THROTTLE_MS,\n        sharedLockTimeoutMS: 10 * 1000,\n    });\n};\n\n/**\n * @returns {UserIdInfo}\n */\nSessionRecording.prototype.getUserIdInfo = function () {\n    if (this.finalFlushUserIdInfo) {\n        return this.finalFlushUserIdInfo;\n    }\n\n    var userIdInfo = {\n        'distinct_id': String(this._mixpanel.get_distinct_id()),\n    };\n\n    // send ID management props if they exist\n    var deviceId = this._mixpanel.get_property('$device_id');\n    if (deviceId) {\n        userIdInfo['$device_id'] = deviceId;\n    }\n    var userId = this._mixpanel.get_property('$user_id');\n    if (userId) {\n        userIdInfo['$user_id'] = userId;\n    }\n    return userIdInfo;\n};\n\nSessionRecording.prototype.unloadPersistedData = function () {\n    this.batcher.stop();\n\n    return this.queueStorage.init().catch(function () {\n        this.reportError('Error initializing IndexedDB storage for unloading persisted data.');\n    }.bind(this)).then(function () {\n        // if the recording is too short, just delete any stored events without flushing\n        if (this.getDurationMs() < this._getRecordMinMs()) {\n            return this.queueStorage.removeItem(this.batcherKey);\n        }\n\n        return this.batcher.flush()\n            .then(function () {\n                return this.queueStorage.removeItem(this.batcherKey);\n            }.bind(this));\n    }.bind(this));\n};\n\nSessionRecording.prototype.getConfig = function(configVar) {\n    return this._mixpanel.get_config(configVar);\n};\n\n// Alias for getConfig, used by the common addOptOutCheckMixpanelLib function which\n// reaches into this class instance and expects the snake case version of the function.\n// eslint-disable-next-line camelcase\nSessionRecording.prototype.get_config = function(configVar) {\n    return this.getConfig(configVar);\n};\n\nSessionRecording.prototype.startRecording = function (shouldStopBatcher) {\n    if (this._rrwebRecord === null) {\n        this.reportError('rrweb record function not provided. ');\n        return;\n    }\n\n    if (this._stopRecording !== null) {\n        logger$3.log('Recording already in progress, skipping startRecording.');\n        return;\n    }\n\n    this.recordMaxMs = this.getConfig('record_max_ms');\n    if (this.recordMaxMs > MAX_RECORDING_MS) {\n        this.recordMaxMs = MAX_RECORDING_MS;\n        logger$3.critical('record_max_ms cannot be greater than ' + MAX_RECORDING_MS + 'ms. Capping value.');\n    }\n\n    if (!this.maxExpires) {\n        this.maxExpires = new Date().getTime() + this.recordMaxMs;\n    }\n\n    this.recordMinMs = this._getRecordMinMs();\n\n    if (!this.replayStartTime) {\n        this.replayStartTime = new Date().getTime();\n        this.batchStartUrl = _.info.currentUrl();\n        this.replayStartUrl = _.info.currentUrl();\n    }\n\n    if (shouldStopBatcher || this.recordMinMs > 0) {\n        // the primary case for shouldStopBatcher is when we're starting recording after a reset\n        // and don't want to send anything over the network until there's\n        // actual user activity\n        // this also applies if the minimum recording length has not been hit yet\n        // so that we don't send data until we know the recording will be long enough\n        this.batcher.stop();\n    } else {\n        this.batcher.start();\n    }\n\n    var resetIdleTimeout = function () {\n        clearTimeout(this.idleTimeoutId);\n        var idleTimeoutMs = this.getConfig('record_idle_timeout_ms');\n        this.idleTimeoutId = setTimeout(this._onIdleTimeout, idleTimeoutMs);\n        this.idleExpires = new Date().getTime() + idleTimeoutMs;\n    }.bind(this);\n    resetIdleTimeout();\n\n    var blockSelector = this.getConfig('record_block_selector');\n    if (blockSelector === '' || blockSelector === null) {\n        blockSelector = undefined;\n    }\n\n    try {\n        this._stopRecording = this._rrwebRecord({\n            'emit': function (ev) {\n                if (this.idleExpires && this.idleExpires < ev.timestamp) {\n                    this._onIdleTimeout();\n                    return;\n                }\n                if (isUserEvent(ev)) {\n                    if (this.batcher.stopped && new Date().getTime() - this.replayStartTime >= this.recordMinMs) {\n                        // start flushing again after user activity\n                        this.batcher.start();\n                    }\n                    resetIdleTimeout();\n                }\n                // promise only used to await during tests\n                this.__enqueuePromise = this.batcher.enqueue(ev);\n\n                // Capture the timestamp of the last event for duration calculation.\n                if (this.lastEventTimestamp === null || ev.timestamp > this.lastEventTimestamp) {\n                    this.lastEventTimestamp = ev.timestamp;\n                }\n            }.bind(this),\n            'blockClass': this.getConfig('record_block_class'),\n            'blockSelector': blockSelector,\n            'collectFonts': this.getConfig('record_collect_fonts'),\n            'dataURLOptions': { // canvas image options (https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL)\n                'type': 'image/webp',\n                'quality': 0.6\n            },\n            'maskAllInputs': true,\n            'maskTextClass': this.getConfig('record_mask_text_class'),\n            'maskTextSelector': this.getConfig('record_mask_text_selector'),\n            'recordCanvas': this.getConfig('record_canvas'),\n            'sampling': {\n                'canvas': 15\n            },\n            'plugins': this.getConfig('record_console') ? [\n                getRecordConsolePlugin({\n                    stringifyOptions: {\n                        stringLengthLimit: 1000,\n                        numOfKeysLimit: 50,\n                        depthOfLimit: 2\n                    }\n                })\n            ] : []\n        });\n    } catch (err) {\n        this.reportError('Unexpected error when starting rrweb recording.', err);\n    }\n\n    if (typeof this._stopRecording !== 'function') {\n        this.reportError('rrweb failed to start, skipping this recording.');\n        this._stopRecording = null;\n        this.stopRecording(); // stop batcher looping and any timeouts\n        return;\n    }\n\n    var maxTimeoutMs = this.maxExpires - new Date().getTime();\n    this.maxTimeoutId = setTimeout(this._onMaxLengthReached.bind(this), maxTimeoutMs);\n};\n\nSessionRecording.prototype.stopRecording = function (skipFlush) {\n    // store the user ID info in case this is getting called in mixpanel.reset()\n    this.finalFlushUserIdInfo = this.getUserIdInfo();\n\n    if (!this.isRrwebStopped()) {\n        try {\n            this._stopRecording();\n        } catch (err) {\n            this.reportError('Error with rrweb stopRecording', err);\n        }\n        this._stopRecording = null;\n    }\n\n    var flushPromise;\n    if (this.batcher.stopped) {\n        // never got user activity to flush after reset, so just clear the batcher\n        flushPromise = this.batcher.clear();\n    } else if (!skipFlush) {\n        // flush any remaining events from running batcher\n        flushPromise = this.batcher.flush();\n    }\n    this.batcher.stop();\n\n    clearTimeout(this.idleTimeoutId);\n    clearTimeout(this.maxTimeoutId);\n    return flushPromise;\n};\n\nSessionRecording.prototype.isRrwebStopped = function () {\n    return this._stopRecording === null;\n};\n\n\n/**\n * Flushes the current batch of events to the server, but passes an opt-out callback to make sure\n * we stop recording and dump any queued events if the user has opted out.\n */\nSessionRecording.prototype.flushEventsWithOptOut = function (data, options, cb) {\n    var onOptOut = function (code) {\n        // addOptOutCheckMixpanelLib invokes this function with code=0 when the user has opted out\n        if (code === 0) {\n            this.stopRecording();\n            cb({error: 'Tracking has been opted out, stopping recording.'});\n        }\n    }.bind(this);\n\n    this._flushEvents(data, options, cb, onOptOut);\n};\n\n/**\n * @returns {SerializedRecording}\n */\nSessionRecording.prototype.serialize = function () {\n    // don't break if mixpanel instance was destroyed at some point\n    var tabId;\n    try {\n        tabId = this._mixpanel.get_tab_id();\n    } catch (e) {\n        this.reportError('Error getting tab ID for serialization ', e);\n        tabId = null;\n    }\n\n    return {\n        'replayId': this.replayId,\n        'seqNo': this.seqNo,\n        'replayStartTime': this.replayStartTime,\n        'batchStartUrl': this.batchStartUrl,\n        'replayStartUrl': this.replayStartUrl,\n        'lastEventTimestamp': this.lastEventTimestamp,\n        'idleExpires': this.idleExpires,\n        'maxExpires': this.maxExpires,\n        'tabId': tabId,\n    };\n};\n\n\n/**\n * @static\n * @param {SerializedRecording} serializedRecording\n * @param {SessionRecordingOptions} options\n * @returns {SessionRecording}\n */\nSessionRecording.deserialize = function (serializedRecording, options) {\n    var recording = new SessionRecording(_.extend({}, options, {\n        replayId: serializedRecording['replayId'],\n        batchStartUrl: serializedRecording['batchStartUrl'],\n        replayStartUrl: serializedRecording['replayStartUrl'],\n        idleExpires: serializedRecording['idleExpires'],\n        maxExpires: serializedRecording['maxExpires'],\n        replayStartTime: serializedRecording['replayStartTime'],\n        lastEventTimestamp: serializedRecording['lastEventTimestamp'],\n        seqNo: serializedRecording['seqNo'],\n        sharedLockStorage: options.sharedLockStorage,\n    }));\n\n    return recording;\n};\n\nSessionRecording.prototype._sendRequest = function(currentReplayId, reqParams, reqBody, callback) {\n    var onSuccess = function (response, responseBody) {\n        // Update batch specific props only if the request was successful to guarantee ordering.\n        // RequestBatcher will always flush the next batch after the previous one succeeds.\n        // extra check to see if the replay ID has changed so that we don't increment the seqNo on the wrong replay\n        if (response.status === 200 && this.replayId === currentReplayId) {\n            this.seqNo++;\n            this.batchStartUrl = _.info.currentUrl();\n        }\n\n        this._onBatchSent();\n        callback({\n            status: 0,\n            httpStatusCode: response.status,\n            responseBody: responseBody,\n            retryAfter: response.headers.get('Retry-After')\n        });\n    }.bind(this);\n    var apiHost = (this._mixpanel.get_api_host && this._mixpanel.get_api_host('record')) || this.getConfig('api_host');\n    win['fetch'](apiHost + '/' + this.getConfig('api_routes')['record'] + '?' + new URLSearchParams(reqParams), {\n        'method': 'POST',\n        'headers': {\n            'Authorization': 'Basic ' + btoa(this.getConfig('token') + ':'),\n            'Content-Type': 'application/octet-stream'\n        },\n        'body': reqBody,\n    }).then(function (response) {\n        response.json().then(function (responseBody) {\n            onSuccess(response, responseBody);\n        }).catch(function (error) {\n            callback({error: error});\n        });\n    }).catch(function (error) {\n        callback({error: error, httpStatusCode: 0});\n    });\n};\n\nSessionRecording.prototype._flushEvents = addOptOutCheckMixpanelLib(function (data, options, callback) {\n    var numEvents = data.length;\n\n    if (numEvents > 0) {\n        var replayId = this.replayId;\n\n        // each rrweb event has a timestamp - leverage those to get time properties\n        var batchStartTime = Infinity;\n        var batchEndTime = -Infinity;\n        var hasFullSnapshot = false;\n        for (var i = 0; i < numEvents; i++) {\n            batchStartTime = Math.min(batchStartTime, data[i].timestamp);\n            batchEndTime = Math.max(batchEndTime, data[i].timestamp);\n            if (data[i].type === EventType.FullSnapshot) {\n                hasFullSnapshot = true;\n            }\n        }\n\n        if (this.seqNo === 0) {\n            if (!hasFullSnapshot) {\n                callback({error: 'First batch does not contain a full snapshot. Aborting recording.'});\n                this.stopRecording(true);\n                return;\n            }\n            this.replayStartTime = batchStartTime;\n        } else if (!this.replayStartTime) {\n            this.reportError('Replay start time not set but seqNo is not 0. Using current batch start time as a fallback.');\n            this.replayStartTime = batchStartTime;\n        }\n\n        var replayLengthMs = batchEndTime - this.replayStartTime;\n\n        var reqParams = {\n            '$current_url': this.batchStartUrl,\n            '$lib_version': Config.LIB_VERSION,\n            'batch_start_time': batchStartTime / 1000,\n            'mp_lib': 'web',\n            'replay_id': replayId,\n            'replay_length_ms': replayLengthMs,\n            'replay_start_time': this.replayStartTime / 1000,\n            'replay_start_url': this.replayStartUrl,\n            'seq': this.seqNo\n        };\n        var eventsJson = JSON.stringify(data);\n        Object.assign(reqParams, this.getUserIdInfo());\n\n        if (canUseCompressionStream(userAgent, navigator.vendor, windowOpera)) {\n            var jsonStream = new Blob([eventsJson], {type: 'application/json'}).stream();\n            var gzipStream = jsonStream.pipeThrough(new CompressionStream('gzip'));\n            new Response(gzipStream)\n                .blob()\n                .then(function(compressedBlob) {\n                    reqParams['format'] = 'gzip';\n                    this._sendRequest(replayId, reqParams, compressedBlob, callback);\n                }.bind(this));\n        } else {\n            reqParams['format'] = 'body';\n            this._sendRequest(replayId, reqParams, eventsJson, callback);\n        }\n    }\n});\n\n\nSessionRecording.prototype.reportError = function(msg, err) {\n    logger$3.error.apply(logger$3.error, arguments);\n    try {\n        if (!err && !(msg instanceof Error)) {\n            msg = new Error(msg);\n        }\n        this.getConfig('error_reporter')(msg, err);\n    } catch(err) {\n        logger$3.error(err);\n    }\n};\n\n/**\n * Calculates the duration of the recording in milliseconds, based on the start time and time of last recorded event.\n * @returns {number} The duration of the recording in milliseconds. Returns 0 if recording hasn't started.\n */\nSessionRecording.prototype.getDurationMs = function() {\n    if (this.replayStartTime === null) {\n        return 0;\n    }\n\n    // If the recording has no events, assume it is in progress and use the current time as the end time.\n    if (this.lastEventTimestamp === null) {\n        return new Date().getTime() - this.replayStartTime;\n    }\n\n    return this.lastEventTimestamp - this.replayStartTime;\n};\n\n/**\n * Lazily loads the minimum recording length config in milliseconds, respecting the maximum limit.\n * @returns {number} The minimum recording length in milliseconds.\n */\nSessionRecording.prototype._getRecordMinMs = function() {\n    var configValue = this.getConfig('record_min_ms');\n\n    if (configValue > MAX_VALUE_FOR_MIN_RECORDING_MS) {\n        logger$3.critical('record_min_ms cannot be greater than ' + MAX_VALUE_FOR_MIN_RECORDING_MS + 'ms. Capping value.');\n        return MAX_VALUE_FOR_MIN_RECORDING_MS;\n    }\n\n    return configValue;\n};\n\n/**\n * Module for handling the storage and retrieval of recording metadata as well as any active recordings.\n * Makes sure that only one tab can be recording at a time.\n */\nvar RecordingRegistry = function (options) {\n    /** @type {IDBStorageWrapper} */\n    this.idb = new IDBStorageWrapper(RECORDING_REGISTRY_STORE_NAME);\n    this.errorReporter = options.errorReporter;\n    this.mixpanelInstance = options.mixpanelInstance;\n    this.sharedLockStorage = options.sharedLockStorage;\n};\n\nRecordingRegistry.prototype.isPersistenceEnabled = function() {\n    return !this.mixpanelInstance.get_config('disable_persistence');\n};\n\nRecordingRegistry.prototype.handleError = function (err) {\n    this.errorReporter('IndexedDB error: ', err);\n};\n\n/**\n * @param {import('./session-recording').SerializedRecording} serializedRecording\n */\nRecordingRegistry.prototype.setActiveRecording = function (serializedRecording) {\n    if (!this.isPersistenceEnabled()) {\n        return PromisePolyfill.resolve();\n    }\n\n    var tabId = serializedRecording['tabId'];\n    if (!tabId) {\n        console.warn('No tab ID is set, cannot persist recording metadata.');\n        return PromisePolyfill.resolve();\n    }\n\n    return this.idb.init()\n        .then(function () {\n            return this.idb.setItem(tabId, serializedRecording);\n        }.bind(this))\n        .catch(this.handleError.bind(this));\n};\n\n/**\n * @returns {Promise<import('./session-recording').SerializedRecording>}\n */\nRecordingRegistry.prototype.getActiveRecording = function () {\n    if (!this.isPersistenceEnabled()) {\n        return PromisePolyfill.resolve(null);\n    }\n\n    return this.idb.init()\n        .then(function () {\n            return this.idb.getItem(this.mixpanelInstance.get_tab_id());\n        }.bind(this))\n        .then(function (serializedRecording) {\n            return isRecordingExpired(serializedRecording) ? null : serializedRecording;\n        }.bind(this))\n        .catch(this.handleError.bind(this));\n};\n\nRecordingRegistry.prototype.clearActiveRecording = function () {\n    if (this.isPersistenceEnabled()) {\n        // mark recording as expired instead of deleting it in case the page unloads mid-flush and doesn't make it to ingestion.\n        // this will ensure the next pageload will flush the remaining events, but not try to continue the recording.\n        return this.markActiveRecordingExpired();\n    } else {\n        return this.deleteActiveRecording();\n    }\n};\n\nRecordingRegistry.prototype.markActiveRecordingExpired = function () {\n    return this.getActiveRecording()\n        .then(function (serializedRecording) {\n            if (serializedRecording) {\n                serializedRecording['maxExpires'] = 0;\n                return this.setActiveRecording(serializedRecording);\n            }\n        }.bind(this))\n        .catch(this.handleError.bind(this));\n};\n\nRecordingRegistry.prototype.deleteActiveRecording = function () {\n    // avoid initializing IDB if this registry instance hasn't already written a recording\n    if (this.idb.isInitialized()) {\n        return this.idb.removeItem(this.mixpanelInstance.get_tab_id())\n            .catch(this.handleError.bind(this));\n    } else {\n        return PromisePolyfill.resolve();\n    }\n};\n\n/**\n * Flush any inactive recordings from the registry to minimize data loss.\n * The main idea here is that we can flush remaining rrweb events on the next page load if a tab is closed mid-batch.\n */\nRecordingRegistry.prototype.flushInactiveRecordings = function () {\n    if (!this.isPersistenceEnabled()) {\n        return PromisePolyfill.resolve([]);\n    }\n\n    return this.idb.init()\n        .then(function() {\n            return this.idb.getAll();\n        }.bind(this))\n        .then(function (serializedRecordings) {\n            // clean up any expired recordings from the registry, non-expired ones may be active in other tabs\n            var unloadPromises = serializedRecordings\n                .filter(function (serializedRecording) {\n                    return isRecordingExpired(serializedRecording);\n                })\n                .map(function (serializedRecording) {\n                    var sessionRecording = SessionRecording.deserialize(serializedRecording, {\n                        mixpanelInstance: this.mixpanelInstance,\n                        sharedLockStorage: this.sharedLockStorage\n                    });\n                    return sessionRecording.unloadPersistedData()\n                        .then(function () {\n                            // expired recording was successfully flushed, we can clean it up from the registry\n                            return this.idb.removeItem(serializedRecording['tabId']);\n                        }.bind(this))\n                        .catch(this.handleError.bind(this));\n                }.bind(this));\n\n            return PromisePolyfill.all(unloadPromises);\n        }.bind(this))\n        .catch(this.handleError.bind(this));\n};\n\nvar logger$2 = console_with_prefix('recorder');\n\n/**\n * Recorder API: bundles rrweb and and exposes methods to start and stop recordings.\n * @param {Object} [options.mixpanelInstance] - reference to the core MixpanelLib\n*/\nvar MixpanelRecorder = function(mixpanelInstance, rrwebRecord, sharedLockStorage) {\n    this.mixpanelInstance = mixpanelInstance;\n    this.rrwebRecord = rrwebRecord || record;\n    this.sharedLockStorage = sharedLockStorage;\n\n    /**\n     * @member {import('./registry').RecordingRegistry}\n     */\n    this.recordingRegistry = new RecordingRegistry({\n        mixpanelInstance: this.mixpanelInstance,\n        errorReporter: logger$2.error,\n        sharedLockStorage: sharedLockStorage\n    });\n    this._flushInactivePromise = this.recordingRegistry.flushInactiveRecordings();\n\n    this.activeRecording = null;\n    this.stopRecordingInProgress = false;\n};\n\nMixpanelRecorder.prototype.startRecording = function(options) {\n    options = options || {};\n    if (this.activeRecording && !this.activeRecording.isRrwebStopped()) {\n        logger$2.log('Recording already in progress, skipping startRecording.');\n        return;\n    }\n\n    var onIdleTimeout = function () {\n        logger$2.log('Idle timeout reached, restarting recording.');\n        this.resetRecording();\n    }.bind(this);\n\n    var onMaxLengthReached = function () {\n        logger$2.log('Max recording length reached, stopping recording.');\n        this.resetRecording();\n    }.bind(this);\n\n    var onBatchSent = function () {\n        this.recordingRegistry.setActiveRecording(this.activeRecording.serialize());\n        this['__flushPromise'] = this.activeRecording.batcher._flushPromise;\n    }.bind(this);\n\n    /**\n     * @type {import('./session-recording').SessionRecordingOptions}\n     */\n    var sessionRecordingOptions = {\n        mixpanelInstance: this.mixpanelInstance,\n        onBatchSent: onBatchSent,\n        onIdleTimeout: onIdleTimeout,\n        onMaxLengthReached: onMaxLengthReached,\n        replayId: _.UUID(),\n        rrwebRecord: this.rrwebRecord,\n        sharedLockStorage: this.sharedLockStorage\n    };\n\n    if (options.activeSerializedRecording) {\n        this.activeRecording = SessionRecording.deserialize(options.activeSerializedRecording, sessionRecordingOptions);\n    } else {\n        this.activeRecording = new SessionRecording(sessionRecordingOptions);\n    }\n\n    this.activeRecording.startRecording(options.shouldStopBatcher);\n    return this.recordingRegistry.setActiveRecording(this.activeRecording.serialize());\n};\n\nMixpanelRecorder.prototype.stopRecording = function() {\n    // Prevents activeSerializedRecording from being reused when stopping the recording.\n    this.stopRecordingInProgress = true;\n    return this._stopCurrentRecording(false, true).then(function() {\n        return this.recordingRegistry.clearActiveRecording();\n    }.bind(this)).then(function() {\n        this.stopRecordingInProgress = false;\n    }.bind(this));\n};\n\nMixpanelRecorder.prototype.pauseRecording = function() {\n    return this._stopCurrentRecording(false);\n};\n\nMixpanelRecorder.prototype._stopCurrentRecording = function(skipFlush, disableActiveRecording) {\n    if (this.activeRecording) {\n        var stopRecordingPromise = this.activeRecording.stopRecording(skipFlush);\n        if (disableActiveRecording) {\n            this.activeRecording = null;\n        }\n        return stopRecordingPromise;\n    }\n    return PromisePolyfill.resolve();\n};\n\nMixpanelRecorder.prototype.resumeRecording = function (startNewIfInactive) {\n    if (this.activeRecording && this.activeRecording.isRrwebStopped()) {\n        this.activeRecording.startRecording(false);\n        return PromisePolyfill.resolve(null);\n    }\n\n    return this.recordingRegistry.getActiveRecording()\n        .then(function (activeSerializedRecording) {\n            if (activeSerializedRecording && !this.stopRecordingInProgress) {\n                return this.startRecording({activeSerializedRecording: activeSerializedRecording});\n            } else if (startNewIfInactive) {\n                return this.startRecording({shouldStopBatcher: false});\n            } else {\n                logger$2.log('No resumable recording found.');\n                return null;\n            }\n        }.bind(this));\n};\n\n\nMixpanelRecorder.prototype.resetRecording = function () {\n    this.stopRecording();\n    this.startRecording({shouldStopBatcher: true});\n};\n\nMixpanelRecorder.prototype.getActiveReplayId = function () {\n    if (this.activeRecording && !this.activeRecording.isRrwebStopped()) {\n        return this.activeRecording.replayId;\n    } else {\n        return null;\n    }\n};\n\n// getter so that older mixpanel-core versions can still retrieve the replay ID\n// when pulling the latest recorder bundle from the CDN\nObject.defineProperty(MixpanelRecorder.prototype, 'replayId', {\n    get: function () {\n        return this.getActiveReplayId();\n    }\n});\n\nwin['__mp_recorder'] = MixpanelRecorder;\n\n// stateless utils\n// mostly from https://github.com/mixpanel/mixpanel-js/blob/989ada50f518edab47b9c4fd9535f9fbd5ec5fc0/src/autotrack-utils.js\n\n\nvar EV_CHANGE = 'change';\nvar EV_CLICK = 'click';\nvar EV_HASHCHANGE = 'hashchange';\nvar EV_INPUT = 'input';\nvar EV_LOAD = 'load';\nvar EV_MP_LOCATION_CHANGE = 'mp_locationchange';\nvar EV_POPSTATE = 'popstate';\n// TODO scrollend isn't available in Safari: document or polyfill?\nvar EV_SCROLLEND = 'scrollend';\nvar EV_SCROLL = 'scroll';\nvar EV_SELECT = 'select';\nvar EV_SUBMIT = 'submit';\nvar EV_TOGGLE = 'toggle';\nvar EV_VISIBILITYCHANGE = 'visibilitychange';\n\nvar CLICK_EVENT_PROPS = [\n    'clientX', 'clientY',\n    'offsetX', 'offsetY',\n    'pageX', 'pageY',\n    'screenX', 'screenY',\n    'x', 'y'\n];\nvar OPT_IN_CLASSES = ['mp-include'];\nvar OPT_OUT_CLASSES = ['mp-no-track'];\nvar SENSITIVE_DATA_CLASSES = OPT_OUT_CLASSES.concat(['mp-sensitive']);\nvar TRACKED_ATTRS = [\n    'aria-label', 'aria-labelledby', 'aria-describedby',\n    'href', 'name', 'role', 'title', 'type'\n];\n\nvar INTERACTIVE_ARIA_ROLES = {\n    'button': true,\n    'checkbox': true,\n    'combobox': true,\n    'grid': true,\n    'link': true,\n    'listbox': true,\n    'menu': true,\n    'menubar': true,\n    'menuitem': true,\n    'menuitemcheckbox': true,\n    'menuitemradio': true,\n    'navigation': true,\n    'option': true,\n    'radio': true,\n    'radiogroup': true,\n    'searchbox': true,\n    'slider': true,\n    'spinbutton': true,\n    'switch': true,\n    'tab': true,\n    'tablist': true,\n    'textbox': true,\n    'tree': true,\n    'treegrid': true,\n    'treeitem': true\n};\n\nvar ALWAYS_NON_INTERACTIVE_TAGS = {\n    // Document metadata\n    'base': true,\n    'head': true,\n    'html': true,\n    'link': true,\n    'meta': true,\n    'script': true,\n    'style': true,\n    'title': true,\n    // Text formatting\n    'br': true,\n    'hr': true,\n    'wbr': true,\n    // Other\n    'noscript': true,\n    'picture': true,\n    'source': true,\n    'template': true,\n    'track': true\n};\n\n// Common container tags that need additional checks\nvar TEXT_CONTAINER_TAGS = {\n    'article': true,\n    'div': true,\n    'h1': true,\n    'h2': true,\n    'h3': true,\n    'h4': true,\n    'h5': true,\n    'h6': true,\n    'p': true,\n    'section': true,\n    'span': true\n};\n\nvar EVENT_HANDLER_ATTRIBUTES = [\n    'onclick', 'onmousedown', 'onmouseup', 'onpointerdown', 'onpointerup', 'ontouchend', 'ontouchstart'\n];\n\nvar MAX_DEPTH = 5;\n\nvar logger$1 = console_with_prefix('autocapture');\n\n\nfunction getClasses(el) {\n    var classes = {};\n    var classList = getClassName(el).split(' ');\n    for (var i = 0; i < classList.length; i++) {\n        var cls = classList[i];\n        if (cls) {\n            classes[cls] = true;\n        }\n    }\n    return classes;\n}\n\n/*\n * Get the className of an element, accounting for edge cases where element.className is an object\n * @param {Element} el - element to get the className of\n * @returns {string} the element's class\n */\nfunction getClassName(el) {\n    switch(typeof el.className) {\n        case 'string':\n            return el.className;\n        case 'object': // handle cases where className might be SVGAnimatedString or some other type\n            return el.className.baseVal || el.getAttribute('class') || '';\n        default: // future proof\n            return '';\n    }\n}\n\nfunction getPreviousElementSibling(el) {\n    if (el.previousElementSibling) {\n        return el.previousElementSibling;\n    } else {\n        do {\n            el = el.previousSibling;\n        } while (el && !isElementNode(el));\n        return el;\n    }\n}\n\nfunction getPropertiesFromElement(el, ev, blockAttrsSet, extraAttrs, allowElementCallback, allowSelectors) {\n    var props = {\n        '$classes': getClassName(el).split(' '),\n        '$tag_name': el.tagName.toLowerCase()\n    };\n    var elId = el.id;\n    if (elId) {\n        props['$id'] = elId;\n    }\n\n    if (shouldTrackElementDetails(el, ev, allowElementCallback, allowSelectors)) {\n        _.each(TRACKED_ATTRS.concat(extraAttrs), function(attr) {\n            if (el.hasAttribute(attr) && !blockAttrsSet[attr]) {\n                var attrVal = el.getAttribute(attr);\n                if (shouldTrackValue(attrVal)) {\n                    props['$attr-' + attr] = attrVal;\n                }\n            }\n        });\n    }\n\n    var nthChild = 1;\n    var nthOfType = 1;\n    var currentElem = el;\n    while (currentElem = getPreviousElementSibling(currentElem)) { // eslint-disable-line no-cond-assign\n        nthChild++;\n        if (currentElem.tagName === el.tagName) {\n            nthOfType++;\n        }\n    }\n    props['$nth_child'] = nthChild;\n    props['$nth_of_type'] = nthOfType;\n\n    return props;\n}\n\nfunction getPropsForDOMEvent(ev, config) {\n    var allowElementCallback = config.allowElementCallback;\n    var allowSelectors = config.allowSelectors || [];\n    var blockAttrs = config.blockAttrs || [];\n    var blockElementCallback = config.blockElementCallback;\n    var blockSelectors = config.blockSelectors || [];\n    var captureTextContent = config.captureTextContent || false;\n    var captureExtraAttrs = config.captureExtraAttrs || [];\n    var capturedForHeatMap = config.capturedForHeatMap || false;\n\n    // convert array to set every time, as the config may have changed\n    var blockAttrsSet = {};\n    _.each(blockAttrs, function(attr) {\n        blockAttrsSet[attr] = true;\n    });\n\n    var props = null;\n\n    var target = typeof ev.target === 'undefined' ? ev.srcElement : ev.target;\n    if (isTextNode(target)) { // defeat Safari bug (see: http://www.quirksmode.org/js/events_properties.html)\n        target = target.parentNode;\n    }\n\n    if (\n        shouldTrackDomEvent(target, ev) &&\n        isElementAllowed(target, ev, allowElementCallback, allowSelectors) &&\n        !isElementBlocked(target, ev, blockElementCallback, blockSelectors)\n    ) {\n        var targetElementList = [target];\n        var curEl = target;\n        while (curEl.parentNode && !isTag(curEl, 'body')) {\n            targetElementList.push(curEl.parentNode);\n            curEl = curEl.parentNode;\n        }\n\n        var elementsJson = [];\n        var href, explicitNoTrack = false;\n        _.each(targetElementList, function(el) {\n            var shouldTrackDetails = shouldTrackElementDetails(el, ev, allowElementCallback, allowSelectors);\n\n            // if the element or a parent element is an anchor tag\n            // include the href as a property\n            if (!blockAttrsSet['href'] && el.tagName.toLowerCase() === 'a') {\n                href = el.getAttribute('href');\n                href = shouldTrackDetails && shouldTrackValue(href) && href;\n            }\n\n            if (isElementBlocked(el, ev, blockElementCallback, blockSelectors)) {\n                explicitNoTrack = true;\n            }\n\n            elementsJson.push(getPropertiesFromElement(el, ev, blockAttrsSet, captureExtraAttrs, allowElementCallback, allowSelectors));\n        }, this);\n\n        if (!explicitNoTrack) {\n            var docElement = document$1['documentElement'];\n            props = {\n                '$event_type': ev.type,\n                '$host': win.location.host,\n                '$pathname': win.location.pathname,\n                '$elements':  elementsJson,\n                '$el_attr__href': href,\n                '$viewportHeight': Math.max(docElement['clientHeight'], win['innerHeight'] || 0),\n                '$viewportWidth': Math.max(docElement['clientWidth'], win['innerWidth'] || 0),\n                '$pageHeight': document$1['body']['offsetHeight'] || 0,\n                '$pageWidth': document$1['body']['offsetWidth'] || 0,\n            };\n            _.each(captureExtraAttrs, function(attr) {\n                if (!blockAttrsSet[attr] && target.hasAttribute(attr)) {\n                    var attrVal = target.getAttribute(attr);\n                    if (shouldTrackValue(attrVal)) {\n                        props['$el_attr__' + attr] = attrVal;\n                    }\n                }\n            });\n\n            if (captureTextContent) {\n                elementText = getSafeText(target, ev, allowElementCallback, allowSelectors);\n                if (elementText && elementText.length) {\n                    props['$el_text'] = elementText;\n                }\n            }\n\n            if (ev.type === EV_CLICK) {\n                _.each(CLICK_EVENT_PROPS, function(prop) {\n                    if (prop in ev) {\n                        props['$' + prop] = ev[prop];\n                    }\n                });\n                if (capturedForHeatMap) {\n                    props['$captured_for_heatmap'] = true;\n                }\n                target = guessRealClickTarget(ev);\n            }\n            // prioritize text content from \"real\" click target if different from original target\n            if (captureTextContent) {\n                var elementText = getSafeText(target, ev, allowElementCallback, allowSelectors);\n                if (elementText && elementText.length) {\n                    props['$el_text'] = elementText;\n                }\n            }\n\n            if (target) {\n                // target may have been recalculated; check allowlists and blocklists again\n                if (\n                    !isElementAllowed(target, ev, allowElementCallback, allowSelectors) ||\n                    isElementBlocked(target, ev, blockElementCallback, blockSelectors)\n                ) {\n                    return null;\n                }\n\n                var targetProps = getPropertiesFromElement(target, ev, blockAttrsSet, captureExtraAttrs, allowElementCallback, allowSelectors);\n                props['$target'] = targetProps;\n                // pull up more props onto main event props\n                props['$el_classes'] = targetProps['$classes'];\n                _.extend(props, _.strip_empty_properties({\n                    '$el_id': targetProps['$id'],\n                    '$el_tag_name': targetProps['$tag_name']\n                }));\n            }\n        }\n    }\n\n    return props;\n}\n\n\n/**\n * Get the direct text content of an element, protecting against sensitive data collection.\n * Concats textContent of each of the element's text node children; this avoids potential\n * collection of sensitive data that could happen if we used element.textContent and the\n * element had sensitive child elements, since element.textContent includes child content.\n * Scrubs values that look like they could be sensitive (i.e. cc or ssn number).\n * @param {Element} el - element to get the text of\n * @param {Array<string>} allowSelectors - CSS selectors for elements that should be included\n * @returns {string} the element's direct text content\n */\nfunction getSafeText(el, ev, allowElementCallback, allowSelectors) {\n    var elText = '';\n\n    if (shouldTrackElementDetails(el, ev, allowElementCallback, allowSelectors) && el.childNodes && el.childNodes.length) {\n        _.each(el.childNodes, function(child) {\n            if (isTextNode(child) && child.textContent) {\n                elText += _.trim(child.textContent)\n                    // scrub potentially sensitive values\n                    .split(/(\\s+)/).filter(shouldTrackValue).join('')\n                    // normalize whitespace\n                    .replace(/[\\r\\n]/g, ' ').replace(/[ ]+/g, ' ')\n                    // truncate\n                    .substring(0, 255);\n            }\n        });\n    }\n\n    return _.trim(elText);\n}\n\nfunction guessRealClickTarget(ev) {\n    var target = ev.target;\n    var composedPath = ev['composedPath']();\n    for (var i = 0; i < composedPath.length; i++) {\n        var node = composedPath[i];\n        if (\n            isTag(node, 'a') ||\n            isTag(node, 'button') ||\n            isTag(node, 'input') ||\n            isTag(node, 'select') ||\n            (node.getAttribute && node.getAttribute('role') === 'button')\n        ) {\n            target = node;\n            break;\n        }\n        if (node === target) {\n            break;\n        }\n    }\n    return target;\n}\n\nfunction isElementAllowed(el, ev, allowElementCallback, allowSelectors) {\n    if (allowElementCallback) {\n        try {\n            if (!allowElementCallback(el, ev)) {\n                return false;\n            }\n        } catch (err) {\n            logger$1.critical('Error while checking element in allowElementCallback', err);\n            return false;\n        }\n    }\n\n    if (!allowSelectors.length) {\n        // no allowlist; all elements are fair game\n        return true;\n    }\n\n    for (var i = 0; i < allowSelectors.length; i++) {\n        var sel = allowSelectors[i];\n        try {\n            if (el['matches'](sel)) {\n                return true;\n            }\n        } catch (err) {\n            logger$1.critical('Error while checking selector: ' + sel, err);\n        }\n    }\n    return false;\n}\n\nfunction isElementBlocked(el, ev, blockElementCallback, blockSelectors) {\n    var i;\n\n    if (blockElementCallback) {\n        try {\n            if (blockElementCallback(el, ev)) {\n                return true;\n            }\n        } catch (err) {\n            logger$1.critical('Error while checking element in blockElementCallback', err);\n            return true;\n        }\n    }\n\n    if (blockSelectors && blockSelectors.length) {\n        // programmatically prevent tracking of elements that match CSS selectors\n        for (i = 0; i < blockSelectors.length; i++) {\n            var sel = blockSelectors[i];\n            try {\n                if (el['matches'](sel)) {\n                    return true;\n                }\n            } catch (err) {\n                logger$1.critical('Error while checking selector: ' + sel, err);\n            }\n        }\n    }\n\n    // allow users to programmatically prevent tracking of elements by adding default classes such as 'mp-no-track'\n    var classes = getClasses(el);\n    for (i = 0; i < OPT_OUT_CLASSES.length; i++) {\n        if (classes[OPT_OUT_CLASSES[i]]) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/*\n * Check whether a DOM node has nodeType Node.ELEMENT_NODE\n * @param {Node} node - node to check\n * @returns {boolean} whether node is of the correct nodeType\n */\nfunction isElementNode(node) {\n    return node && node.nodeType === 1; // Node.ELEMENT_NODE - use integer constant for browser portability\n}\n\n/*\n * Check whether an element is of a given tag type.\n * Due to potential reference discrepancies (such as the webcomponents.js polyfill),\n * we want to match tagNames instead of specific references because something like\n * element === document.body won't always work because element might not be a native\n * element.\n * @param {Element} el - element to check\n * @param {string} tag - tag name (e.g., \"div\")\n * @returns {boolean} whether el is of the given tag type\n */\nfunction isTag(el, tag) {\n    return el && el.tagName && el.tagName.toLowerCase() === tag.toLowerCase();\n}\n\n/*\n * Check whether a DOM node is a TEXT_NODE\n * @param {Node} node - node to check\n * @returns {boolean} whether node is of type Node.TEXT_NODE\n */\nfunction isTextNode(node) {\n    return node && node.nodeType === 3; // Node.TEXT_NODE - use integer constant for browser portability\n}\n\nfunction minDOMApisSupported() {\n    try {\n        var testEl = document$1.createElement('div');\n        return !!testEl['matches'];\n    } catch (err) {\n        return false;\n    }\n}\n\nfunction weakSetSupported() {\n    return typeof WeakSet !== 'undefined';\n}\n\n/*\n * Check whether a DOM event should be \"tracked\" or if it may contain sensitive data\n * using a variety of heuristics.\n * @param {Element} el - element to check\n * @param {Event} ev - event to check\n * @returns {boolean} whether the event should be tracked\n */\nfunction shouldTrackDomEvent(el, ev) {\n    if (!el || isTag(el, 'html') || !isElementNode(el)) {\n        return false;\n    }\n    var tag = el.tagName.toLowerCase();\n    switch (tag) {\n        case 'form':\n            return ev.type === EV_SUBMIT;\n        case 'input':\n            if (['button', 'submit'].indexOf(el.getAttribute('type')) === -1) {\n                return ev.type === EV_CHANGE;\n            } else {\n                return ev.type === EV_CLICK;\n            }\n        case 'select':\n        case 'textarea':\n            return ev.type === EV_CHANGE;\n        default:\n            return ev.type === EV_CLICK;\n    }\n}\n\n/*\n * Check whether a DOM element should be \"tracked\" or if it may contain sensitive data\n * using a variety of heuristics.\n * @param {Element} el - element to check\n * @param {Array<string>} allowSelectors - CSS selectors for elements that should be included\n * @returns {boolean} whether the element should be tracked\n */\nfunction shouldTrackElementDetails(el, ev, allowElementCallback, allowSelectors) {\n    var i;\n\n    if (!isElementAllowed(el, ev, allowElementCallback, allowSelectors)) {\n        return false;\n    }\n\n    for (var curEl = el; curEl.parentNode && !isTag(curEl, 'body'); curEl = curEl.parentNode) {\n        var classes = getClasses(curEl);\n        for (i = 0; i < SENSITIVE_DATA_CLASSES.length; i++) {\n            if (classes[SENSITIVE_DATA_CLASSES[i]]) {\n                return false;\n            }\n        }\n    }\n\n    var elClasses = getClasses(el);\n    for (i = 0; i < OPT_IN_CLASSES.length; i++) {\n        if (elClasses[OPT_IN_CLASSES[i]]) {\n            return true;\n        }\n    }\n\n    // don't send data from inputs or similar elements since there will always be\n    // a risk of clientside javascript placing sensitive data in attributes\n    if (\n        isTag(el, 'input') ||\n        isTag(el, 'select') ||\n        isTag(el, 'textarea') ||\n        el.getAttribute('contenteditable') === 'true'\n    ) {\n        return false;\n    }\n\n    // don't include hidden or password fields\n    var type = el.type || '';\n    if (typeof type === 'string') { // it's possible for el.type to be a DOM element if el is a form with a child input[name=\"type\"]\n        switch(type.toLowerCase()) {\n            case 'hidden':\n                return false;\n            case 'password':\n                return false;\n        }\n    }\n\n    // filter out data from fields that look like sensitive fields\n    var name = el.name || el.id || '';\n    if (typeof name === 'string') { // it's possible for el.name or el.id to be a DOM element if el is a form with a child input[name=\"name\"]\n        var sensitiveNameRegex = /^cc|cardnum|ccnum|creditcard|csc|cvc|cvv|exp|pass|pwd|routing|seccode|securitycode|securitynum|socialsec|socsec|ssn/i;\n        if (sensitiveNameRegex.test(name.replace(/[^a-zA-Z0-9]/g, ''))) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n\n/*\n * Check whether a string value should be \"tracked\" or if it may contain sensitive data\n * using a variety of heuristics.\n * @param {string} value - string value to check\n * @returns {boolean} whether the element should be tracked\n */\nfunction shouldTrackValue(value) {\n    if (value === null || _.isUndefined(value)) {\n        return false;\n    }\n\n    if (typeof value === 'string') {\n        value = _.trim(value);\n\n        // check to see if input value looks like a credit card number\n        // see: https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9781449327453/ch04s20.html\n        var ccRegex = /^(?:(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11}))$/;\n        if (ccRegex.test((value || '').replace(/[- ]/g, ''))) {\n            return false;\n        }\n\n        // check to see if input value looks like a social security number\n        var ssnRegex = /(^\\d{3}-?\\d{2}-?\\d{4}$)/;\n        if (ssnRegex.test(value)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Creates a cross-browser compatible scroll end function with appropriate event listener.\n * For browsers that support scrollend, returns the original function with scrollend event.\n * For browsers without scrollend support, returns a debounced function that triggers\n * 100ms after the last scroll event to simulate scrollend behavior.\n * @param {Function} originalFunction - The function to call when scrolling ends\n * @returns {Object} Object containing listener function and eventType string\n * @returns {Function} returns.listener - The wrapped function to use as event listener\n * @returns {string} returns.eventType - The event type to listen for ('scrollend' or 'scroll')\n */\nfunction getPolyfillScrollEndFunction(originalFunction) {\n    var supportsScrollEnd = 'onscrollend' in win;\n    var polyfillFunction = safewrap(originalFunction);\n    var polyfillEvent = EV_SCROLLEND;\n    if (!supportsScrollEnd) {\n        // Polyfill for browsers without scrollend support: wait 100ms after the last scroll event\n        // https://developer.chrome.com/blog/scrollend-a-new-javascript-event\n        var scrollTimer = null;\n        var scrollDelayMs = 100;\n\n        polyfillFunction = safewrap(function() {\n            clearTimeout(scrollTimer);\n            scrollTimer = setTimeout(originalFunction, scrollDelayMs);\n        });\n\n        polyfillEvent = EV_SCROLL;\n    }\n\n    return {\n        listener: polyfillFunction,\n        eventType: polyfillEvent\n    };\n}\n\nfunction hasInlineEventHandlers(element) {\n    for (var i = 0; i < EVENT_HANDLER_ATTRIBUTES.length; i++) {\n        if (element.hasAttribute(EVENT_HANDLER_ATTRIBUTES[i])) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction hasInteractiveAriaRole(element) {\n    var role = element.getAttribute('role');\n    if (!role) return false;\n\n    // Handle invalid markup where multiple roles might be specified\n    // Only the first token is recognized per ARIA spec\n    var primaryRole = role.trim().split(/\\s+/)[0].toLowerCase();\n\n    return INTERACTIVE_ARIA_ROLES[primaryRole];\n}\n\nfunction hasAnyInteractivityIndicators(element) {\n    var tagName = element.tagName.toLowerCase();\n\n    // Check for interactive HTML elements\n    if (tagName === 'button' ||\n        tagName === 'input' ||\n        tagName === 'select' ||\n        tagName === 'textarea' ||\n        tagName === 'details' ||\n        tagName === 'dialog') {\n        return true;\n    }\n\n    if (element.isContentEditable) {\n        return true;\n    }\n\n    if (element.onclick || element.onmousedown || element.onmouseup || element.ontouchstart || element.ontouchend) {\n        return true;\n    }\n\n    if (hasInlineEventHandlers(element)) {\n        return true;\n    }\n\n    if (hasInteractiveAriaRole(element)) {\n        return true;\n    }\n\n    if (tagName === 'a' && element.hasAttribute('href')) {\n        return true;\n    }\n\n    if (element.hasAttribute('tabindex')) {\n        return true;\n    }\n\n    return false;\n}\n\n\nfunction isDefinitelyNonInteractive(element) {\n    if (!element || !element.tagName) {\n        return true;\n    }\n\n    var tagName = element.tagName.toLowerCase();\n\n    // These tags are definitely non-interactive\n    if (ALWAYS_NON_INTERACTIVE_TAGS[tagName]) {\n        return true;\n    }\n\n    // For all other elements, we can only be certain they're non-interactive if they lack ALL indicators of interactivity\n    // Check for any signs of interactivity\n    if (hasAnyInteractivityIndicators(element)) {\n        return false;\n    }\n\n    // Check parent chain for interactive context\n    var parent = element.parentElement;\n    var depth = 0;\n\n    while (parent && depth < MAX_DEPTH) {\n        if (hasAnyInteractivityIndicators(parent)) {\n            return false; // Element is inside an interactive parent\n        }\n\n        if (parent.getRootNode && parent.getRootNode() !== document$1) {\n            var root = parent.getRootNode();\n            if (root.host && hasAnyInteractivityIndicators(root.host)) {\n                return false; // Inside an interactive shadow host\n            }\n        }\n\n        parent = parent.parentElement;\n        depth++;\n    }\n\n    // Pure text containers without any interactive context\n    if (TEXT_CONTAINER_TAGS[tagName]) {\n        // These are non-interactive ONLY if they have no interactive indicators (already checked as part of hasAnyInteractivityIndicators)\n        return true;\n    }\n\n    // Default: we can't be certain it's non-interactive\n    return false;\n}\n\n/**\n * Get the composed path of a click event for elements embedded in shadow DOM.\n * @param {Event} event - event to get the composed path from\n * @returns {Array} the composed path of the click event\n*/\nfunction getClickEventComposedPath(event) {\n    if ('composedPath' in event) {\n        return event['composedPath']();\n    }\n\n    return [];\n}\n\n/**\n * Get the element from a click event, accounting for elements embedded in shadow DOM.\n * @param {Event} event - event to get the target from\n * @returns {Element | null} the element that was the target of the click event\n */\nfunction getClickEventTargetElement(event) {\n    var path = getClickEventComposedPath(event);\n\n    if (path && path.length > 0) {\n        return path[0];\n    }\n\n    return event['target'] || event['srcElement'];\n}\n\n/** @const */ var DEFAULT_RAGE_CLICK_THRESHOLD_PX = 30;\n/** @const */ var DEFAULT_RAGE_CLICK_TIMEOUT_MS = 1000;\n/** @const */ var DEFAULT_RAGE_CLICK_CLICK_COUNT = 4;\n/** @const */ var DEFAULT_RAGE_CLICK_INTERACTIVE_ELEMENTS_ONLY = false;\n\nfunction RageClickTracker() {\n    this.clicks = [];\n}\n\n/**\n * Determines if a click event is part of a rage click sequence.\n * @param {Event} event - the original click event.\n * @param {import('../index.d.ts').RageClickConfig} options - configuration options for rage click detection.\n * @returns {boolean} - true if the click is considered a rage click, false otherwise.\n */\nRageClickTracker.prototype.isRageClick = function(event, options) {\n    options = options || {};\n    var thresholdPx = options['threshold_px'] || DEFAULT_RAGE_CLICK_THRESHOLD_PX;\n    var timeoutMs = options['timeout_ms'] || DEFAULT_RAGE_CLICK_TIMEOUT_MS;\n    var clickCount = options['click_count'] || DEFAULT_RAGE_CLICK_CLICK_COUNT;\n    var interactiveElementsOnly = options['interactive_elements_only'] || DEFAULT_RAGE_CLICK_INTERACTIVE_ELEMENTS_ONLY;\n\n    if (interactiveElementsOnly) {\n        var target = getClickEventTargetElement(event);\n        if (!target || isDefinitelyNonInteractive(target)) {\n            return false;\n        }\n    }\n\n    var timestamp = Date.now();\n    var x = event['pageX'], y = event['pageY'];\n\n    var lastClick = this.clicks[this.clicks.length - 1];\n    if (\n        lastClick &&\n        timestamp - lastClick.timestamp < timeoutMs &&\n        Math.sqrt(Math.pow(x - lastClick.x, 2) + Math.pow(y - lastClick.y, 2)) < thresholdPx\n    ) {\n        this.clicks.push({ x: x, y: y, timestamp: timestamp });\n        if (this.clicks.length >= clickCount) {\n            this.clicks = [];\n            return true;\n        }\n    } else {\n        this.clicks = [{ x: x, y: y, timestamp: timestamp }];\n    }\n    return false;\n};\n\nfunction ShadowDOMObserver(changeCallback, observerConfig) {\n    this.changeCallback = changeCallback || function() {};\n    this.observerConfig = observerConfig;\n\n    this.observedShadowRoots = null;\n    this.shadowObservers = [];\n}\n\nShadowDOMObserver.prototype.getEventTarget = function(event) {\n    if (!this.observedShadowRoots) {\n        return;\n    }\n\n    return getClickEventTargetElement(event);\n};\n\nShadowDOMObserver.prototype.observeFromEvent = function(event) {\n    if (!this.observedShadowRoots) {\n        return;\n    }\n\n    var path = getClickEventComposedPath(event);\n\n    // Check each element in path for shadow roots\n    for (var i = 0; i < path.length; i++) {\n        var element = path[i];\n\n        if (element && element.shadowRoot) {\n            this.observeShadowRoot(element.shadowRoot);\n        }\n    }\n};\n\n\nShadowDOMObserver.prototype.observeShadowRoot = function(shadowRoot) {\n    if (!this.observedShadowRoots || this.observedShadowRoots.has(shadowRoot)) {\n        return;\n    }\n\n    var self = this;\n\n    try {\n        this.observedShadowRoots.add(shadowRoot);\n\n        var observer = new window.MutationObserver(function() {\n            self.changeCallback();\n        });\n\n        observer.observe(shadowRoot, this.observerConfig);\n        this.shadowObservers.push(observer);\n    } catch (e) {\n        logger$1.critical('Error while observing shadow root', e);\n    }\n};\n\n\nShadowDOMObserver.prototype.start = function() {\n    if (this.observedShadowRoots) {\n        return;\n    }\n\n    if (!weakSetSupported()) {\n        logger$1.critical('Shadow DOM observation unavailable: WeakSet not supported');\n        return;\n    }\n\n    this.observedShadowRoots = new WeakSet();\n};\n\nShadowDOMObserver.prototype.stop = function() {\n    if (!this.observedShadowRoots) {\n        return;\n    }\n\n    for (var i = 0; i < this.shadowObservers.length; i++) {\n        try {\n            this.shadowObservers[i].disconnect();\n        } catch (e) {\n            logger$1.critical('Error while disconnecting shadow DOM observer', e);\n        }\n    }\n    this.shadowObservers = [];\n    this.observedShadowRoots = null;\n};\n\n/** @const */ var DEFAULT_DEAD_CLICK_TIMEOUT_MS = 500;\n/** @const */ var INTERACTION_EVENTS = [EV_CHANGE, EV_INPUT, EV_SUBMIT, EV_SELECT, EV_TOGGLE];\n/** @const */ var LAYOUT_EVENTS = [EV_SCROLLEND];\n/** @const */ var NAVIGATION_EVENTS = [EV_HASHCHANGE];\n/** @const */ var MUTATION_OBSERVER_CONFIG = {\n    characterData: true,\n    childList: true,\n    subtree: true,\n    attributes: true,\n    attributeFilter: ['style', 'class', 'hidden', 'checked', 'selected', 'value', 'display', 'visibility']\n};\n\n\nfunction DeadClickTracker(onDeadClickCallback) {\n    this.eventListeners = [];\n    this.mutationObserver = null;\n    this.shadowDOMObserver = null;\n\n    this.isTracking = false;\n    this.lastChangeEventTimestamp = 0;\n    this.pendingClicks = [];\n    this.onDeadClickCallback = onDeadClickCallback;\n    this.processingActive = false;\n    this.processingTimeout = null;\n}\n\n\nDeadClickTracker.prototype.addClick = function(event) {\n    var element = this.shadowDOMObserver && this.shadowDOMObserver.getEventTarget(event);\n\n    if (!element) {\n        element = event['target'] || event['srcElement'];\n    }\n\n    if (!element || isDefinitelyNonInteractive(element)) {\n        return false;\n    }\n\n    if (this.shadowDOMObserver) {\n        this.shadowDOMObserver.observeFromEvent(event);\n    }\n    this.pendingClicks.push({\n        element: element,\n        event: event,\n        timestamp: Date.now()\n    });\n    return true;\n};\n\nDeadClickTracker.prototype.trackClick = function(event, config) {\n    if (!this.isTracking) {\n        return false;\n    }\n\n    var added = this.addClick(event);\n    if (added) {\n        this.triggerProcessing(config);\n    }\n    return added;\n};\n\nDeadClickTracker.prototype.getDeadClicks = function(config) {\n    if (this.pendingClicks.length === 0) {\n        return [];\n    }\n\n    var timeoutMs = config['timeout_ms'];\n    var now = Date.now();\n    var clicksToEvaluate = this.pendingClicks.slice(); // Copy array\n    this.pendingClicks = []; // Clear original\n\n    var deadClicks = [];\n\n    for (var i = 0; i < clicksToEvaluate.length; i++) {\n        var click = clicksToEvaluate[i];\n\n        if (now - click.timestamp >= timeoutMs) {\n            // Click has exceeded timeout, check if it's dead by looking for changes after this specific click\n            if (!this.hasChangesAfter(click.timestamp)) {\n                deadClicks.push(click);\n            }\n        } else {\n            // Still pending - add back\n            this.pendingClicks.push(click);\n        }\n    }\n\n    return deadClicks;\n};\n\nDeadClickTracker.prototype.hasChangesAfter = function(timestamp) {\n    // 100ms tolerance for race condition between when we record the click and the change event\n    return this.lastChangeEventTimestamp >= (timestamp - 100);\n};\n\nDeadClickTracker.prototype.recordChangeEvent = function() {\n    this.lastChangeEventTimestamp = Date.now();\n};\n\nDeadClickTracker.prototype.triggerProcessing = function(config) {\n    // Prevent multiple concurrent processing chains\n    if (this.processingActive) {\n        return;\n    }\n    this.processingActive = true;\n    this.processRecursively(config);\n};\n\nDeadClickTracker.prototype.processRecursively = function(config) {\n    if (!this.isTracking || !this.onDeadClickCallback) {\n        this.processingActive = false;\n        return;\n    }\n\n    var timeoutMs = config['timeout_ms'];\n    var self = this;\n\n    this.processingTimeout = setTimeout(function() {\n        if (!self.processingActive) {\n            return;\n        }\n\n        var deadClicks = self.getDeadClicks(config);\n\n        for (var i = 0; i < deadClicks.length; i++) {\n            self.onDeadClickCallback(deadClicks[i].event);\n        }\n\n        if (self.pendingClicks.length > 0) {\n            self.processRecursively(config);\n        } else {\n            self.processingActive = false;\n        }\n    }, timeoutMs);\n};\n\nDeadClickTracker.prototype.startTracking = function() {\n    if (this.isTracking) {\n        return;\n    }\n\n    this.isTracking = true;\n\n    var self = this;\n\n    INTERACTION_EVENTS.forEach(function(event) {\n        var handler = function() {\n            self.recordChangeEvent();\n        };\n        document.addEventListener(event, handler, { capture: true, passive: true });\n        self.eventListeners.push({ target: document, event: event, handler: handler, options: { capture: true, passive: true } });\n    });\n    NAVIGATION_EVENTS.forEach(function(event) {\n        var handler = function() {\n            self.recordChangeEvent();\n        };\n        window.addEventListener(event, handler);\n        self.eventListeners.push({ target: window, event: event, handler: handler });\n    });\n    LAYOUT_EVENTS.forEach(function(event) {\n        var handler = function() {\n            self.recordChangeEvent();\n        };\n        window.addEventListener(event, handler, { passive: true });\n        self.eventListeners.push({ target: window, event: event, handler: handler, options: { passive: true } });\n    });\n    var selectionHandler = function() {\n        self.recordChangeEvent();\n    };\n    document.addEventListener('selectionchange', selectionHandler);\n    self.eventListeners.push({ target: document, event: 'selectionchange', handler: selectionHandler });\n\n    // Set up MutationObserver\n    if (window.MutationObserver) {\n        try {\n            this.mutationObserver = new window.MutationObserver(function() {\n                self.recordChangeEvent();\n            });\n\n            this.mutationObserver.observe(document.body || document.documentElement, MUTATION_OBSERVER_CONFIG);\n        } catch (e) {\n            logger$1.critical('Error while setting up mutation observer', e);\n        }\n    }\n\n    // Set up Shadow DOM observer\n    if (window.customElements) {\n        try {\n            this.shadowDOMObserver = new ShadowDOMObserver(\n                function() {\n                    self.recordChangeEvent();\n                },\n                MUTATION_OBSERVER_CONFIG\n            );\n            this.shadowDOMObserver.start();\n        } catch (e) {\n            logger$1.critical('Error while setting up shadow DOM observer', e);\n            this.shadowDOMObserver = null;\n        }\n    }\n};\n\nDeadClickTracker.prototype.stopTracking = function() {\n    if (!this.isTracking) {\n        return;\n    }\n\n    this.isTracking = false;\n    this.pendingClicks = [];\n    this.lastChangeEventTimestamp = 0;\n    this.processingActive = false;\n\n    if (this.processingTimeout) {\n        clearTimeout(this.processingTimeout);\n        this.processingTimeout = null;\n    }\n\n    // Remove all event listeners\n    for (var i = 0; i < this.eventListeners.length; i++) {\n        var listener = this.eventListeners[i];\n        try {\n            listener.target.removeEventListener(listener.event, listener.handler, listener.options);\n        } catch (e) {\n            logger$1.critical('Error while removing event listener', e);\n        }\n    }\n    this.eventListeners = [];\n\n    if (this.mutationObserver) {\n        try {\n            this.mutationObserver.disconnect();\n        } catch (e) {\n            logger$1.critical('Error while disconnecting mutation observer', e);\n        }\n        this.mutationObserver = null;\n    }\n\n    if (this.shadowDOMObserver) {\n        try {\n            this.shadowDOMObserver.stop();\n        } catch (e) {\n            logger$1.critical('Error while stopping shadow DOM observer', e);\n        }\n        this.shadowDOMObserver = null;\n    }\n};\n\nvar AUTOCAPTURE_CONFIG_KEY = 'autocapture';\nvar LEGACY_PAGEVIEW_CONFIG_KEY = 'track_pageview';\n\nvar PAGEVIEW_OPTION_FULL_URL = 'full-url';\nvar PAGEVIEW_OPTION_URL_WITH_PATH_AND_QUERY_STRING = 'url-with-path-and-query-string';\nvar PAGEVIEW_OPTION_URL_WITH_PATH = 'url-with-path';\n\nvar CONFIG_ALLOW_ELEMENT_CALLBACK = 'allow_element_callback';\nvar CONFIG_ALLOW_SELECTORS = 'allow_selectors';\nvar CONFIG_ALLOW_URL_REGEXES = 'allow_url_regexes';\nvar CONFIG_BLOCK_ATTRS = 'block_attrs';\nvar CONFIG_BLOCK_ELEMENT_CALLBACK = 'block_element_callback';\nvar CONFIG_BLOCK_SELECTORS = 'block_selectors';\nvar CONFIG_BLOCK_URL_REGEXES = 'block_url_regexes';\nvar CONFIG_CAPTURE_EXTRA_ATTRS = 'capture_extra_attrs';\nvar CONFIG_CAPTURE_TEXT_CONTENT = 'capture_text_content';\nvar CONFIG_SCROLL_CAPTURE_ALL = 'scroll_capture_all';\nvar CONFIG_SCROLL_CHECKPOINTS = 'scroll_depth_percent_checkpoints';\nvar CONFIG_TRACK_CLICK = 'click';\nvar CONFIG_TRACK_DEAD_CLICK = 'dead_click';\nvar CONFIG_TRACK_INPUT = 'input';\nvar CONFIG_TRACK_PAGEVIEW = 'pageview';\nvar CONFIG_TRACK_RAGE_CLICK = 'rage_click';\nvar CONFIG_TRACK_SCROLL = 'scroll';\nvar CONFIG_TRACK_PAGE_LEAVE = 'page_leave';\nvar CONFIG_TRACK_SUBMIT = 'submit';\n\nvar CONFIG_DEFAULTS$1 = {};\nCONFIG_DEFAULTS$1[CONFIG_ALLOW_SELECTORS] = [];\nCONFIG_DEFAULTS$1[CONFIG_ALLOW_URL_REGEXES] = [];\nCONFIG_DEFAULTS$1[CONFIG_BLOCK_ATTRS] = [];\nCONFIG_DEFAULTS$1[CONFIG_BLOCK_ELEMENT_CALLBACK] = null;\nCONFIG_DEFAULTS$1[CONFIG_BLOCK_SELECTORS] = [];\nCONFIG_DEFAULTS$1[CONFIG_BLOCK_URL_REGEXES] = [];\nCONFIG_DEFAULTS$1[CONFIG_CAPTURE_EXTRA_ATTRS] = [];\nCONFIG_DEFAULTS$1[CONFIG_CAPTURE_TEXT_CONTENT] = false;\nCONFIG_DEFAULTS$1[CONFIG_SCROLL_CAPTURE_ALL] = false;\nCONFIG_DEFAULTS$1[CONFIG_SCROLL_CHECKPOINTS] = [25, 50, 75, 100];\nCONFIG_DEFAULTS$1[CONFIG_TRACK_CLICK] = true;\nCONFIG_DEFAULTS$1[CONFIG_TRACK_DEAD_CLICK] = true;\nCONFIG_DEFAULTS$1[CONFIG_TRACK_INPUT] = true;\nCONFIG_DEFAULTS$1[CONFIG_TRACK_PAGEVIEW] = PAGEVIEW_OPTION_FULL_URL;\nCONFIG_DEFAULTS$1[CONFIG_TRACK_RAGE_CLICK] = true;\nCONFIG_DEFAULTS$1[CONFIG_TRACK_SCROLL] = true;\nCONFIG_DEFAULTS$1[CONFIG_TRACK_PAGE_LEAVE] = false;\nCONFIG_DEFAULTS$1[CONFIG_TRACK_SUBMIT] = true;\n\nvar DEFAULT_PROPS = {\n    '$mp_autocapture': true\n};\n\nvar MP_EV_CLICK = '$mp_click';\nvar MP_EV_DEAD_CLICK = '$mp_dead_click';\nvar MP_EV_INPUT = '$mp_input_change';\nvar MP_EV_RAGE_CLICK = '$mp_rage_click';\nvar MP_EV_SCROLL = '$mp_scroll';\nvar MP_EV_SUBMIT = '$mp_submit';\nvar MP_EV_PAGE_LEAVE = '$mp_page_leave';\n\n/**\n * Autocapture: manages automatic event tracking\n * @constructor\n */\nvar Autocapture = function(mp) {\n    this.mp = mp;\n    this.maxScrollViewDepth = 0;\n    this.hasTrackedScrollSession = false;\n    this.previousScrollHeight = 0;\n};\n\nAutocapture.prototype.init = function() {\n    if (!minDOMApisSupported()) {\n        logger$1.critical('Autocapture unavailable: missing required DOM APIs');\n        return;\n    }\n    this.initPageListeners();\n    this.initPageviewTracking();\n    this.initClickTracking();\n    this.initDeadClickTracking();\n    this.initInputTracking();\n    this.initScrollTracking();\n    this.initSubmitTracking();\n    this.initRageClickTracking();\n    this.initPageLeaveTracking();\n};\n\nAutocapture.prototype.getFullConfig = function() {\n    var autocaptureConfig = this.mp.get_config(AUTOCAPTURE_CONFIG_KEY);\n    if (!autocaptureConfig) {\n        // Autocapture is completely off\n        return {};\n    } else if (_.isObject(autocaptureConfig)) {\n        return _.extend({}, CONFIG_DEFAULTS$1, autocaptureConfig);\n    } else {\n        // Autocapture config is non-object truthy value, return default\n        return CONFIG_DEFAULTS$1;\n    }\n};\n\nAutocapture.prototype.getConfig = function(key) {\n    return this.getFullConfig()[key];\n};\n\nAutocapture.prototype.currentUrlBlocked = function() {\n    var i;\n    var currentUrl = _.info.currentUrl();\n\n    var allowUrlRegexes = this.getConfig(CONFIG_ALLOW_URL_REGEXES) || [];\n    if (allowUrlRegexes.length) {\n        // we're using an allowlist, only track if current URL matches\n        var allowed = false;\n        for (i = 0; i < allowUrlRegexes.length; i++) {\n            var allowRegex = allowUrlRegexes[i];\n            try {\n                if (currentUrl.match(allowRegex)) {\n                    allowed = true;\n                    break;\n                }\n            } catch (err) {\n                logger$1.critical('Error while checking block URL regex: ' + allowRegex, err);\n                return true;\n            }\n        }\n        if (!allowed) {\n            // wasn't allowed by any regex\n            return true;\n        }\n    }\n\n    var blockUrlRegexes = this.getConfig(CONFIG_BLOCK_URL_REGEXES) || [];\n    if (!blockUrlRegexes || !blockUrlRegexes.length) {\n        return false;\n    }\n\n    for (i = 0; i < blockUrlRegexes.length; i++) {\n        try {\n            if (currentUrl.match(blockUrlRegexes[i])) {\n                return true;\n            }\n        } catch (err) {\n            logger$1.critical('Error while checking block URL regex: ' + blockUrlRegexes[i], err);\n            return true;\n        }\n    }\n    return false;\n};\n\nAutocapture.prototype.pageviewTrackingConfig = function() {\n    // supports both autocapture config and old track_pageview config\n    if (this.mp.get_config(AUTOCAPTURE_CONFIG_KEY)) {\n        return this.getConfig(CONFIG_TRACK_PAGEVIEW);\n    } else {\n        return this.mp.get_config(LEGACY_PAGEVIEW_CONFIG_KEY);\n    }\n};\n\n// helper for event handlers\nAutocapture.prototype.trackDomEvent = function(ev, mpEventName) {\n    if (this.currentUrlBlocked()) {\n        return;\n    }\n\n    var isCapturedForHeatMap = this.mp.is_recording_heatmap_data() && (\n        (mpEventName === MP_EV_CLICK && !this.getConfig(CONFIG_TRACK_CLICK)) ||\n        (mpEventName === MP_EV_RAGE_CLICK && !this._getClickTrackingConfig(CONFIG_TRACK_RAGE_CLICK)) ||\n        (mpEventName === MP_EV_DEAD_CLICK && !this._getClickTrackingConfig(CONFIG_TRACK_DEAD_CLICK))\n    );\n\n    var props = getPropsForDOMEvent(ev, {\n        allowElementCallback: this.getConfig(CONFIG_ALLOW_ELEMENT_CALLBACK),\n        allowSelectors: this.getConfig(CONFIG_ALLOW_SELECTORS),\n        blockAttrs: this.getConfig(CONFIG_BLOCK_ATTRS),\n        blockElementCallback: this.getConfig(CONFIG_BLOCK_ELEMENT_CALLBACK),\n        blockSelectors: this.getConfig(CONFIG_BLOCK_SELECTORS),\n        captureExtraAttrs: this.getConfig(CONFIG_CAPTURE_EXTRA_ATTRS),\n        captureTextContent: this.getConfig(CONFIG_CAPTURE_TEXT_CONTENT),\n        capturedForHeatMap: isCapturedForHeatMap,\n    });\n    if (props) {\n        _.extend(props, DEFAULT_PROPS);\n        this.mp.track(mpEventName, props);\n    }\n};\n\nAutocapture.prototype.initPageListeners = function() {\n    win.removeEventListener(EV_POPSTATE, this.listenerPopstate);\n    win.removeEventListener(EV_HASHCHANGE, this.listenerHashchange);\n\n    if (!this.pageviewTrackingConfig() && !this.getConfig(CONFIG_TRACK_PAGE_LEAVE) && !this.mp.get_config('record_heatmap_data')) {\n        // These are all the configs that use these listeners\n        return;\n    }\n\n    this.listenerPopstate = function() {\n        win.dispatchEvent(new Event(EV_MP_LOCATION_CHANGE));\n    };\n    this.listenerHashchange = function() {\n        win.dispatchEvent(new Event(EV_MP_LOCATION_CHANGE));\n    };\n\n    win.addEventListener(EV_POPSTATE, this.listenerPopstate);\n    win.addEventListener(EV_HASHCHANGE, this.listenerHashchange);\n    var nativePushState = win.history.pushState;\n    if (typeof nativePushState === 'function') {\n        win.history.pushState = function(state, unused, url) {\n            nativePushState.call(win.history, state, unused, url);\n            win.dispatchEvent(new Event(EV_MP_LOCATION_CHANGE));\n        };\n    }\n    var nativeReplaceState = win.history.replaceState;\n    if (typeof nativeReplaceState === 'function') {\n        win.history.replaceState = function(state, unused, url) {\n            nativeReplaceState.call(win.history, state, unused, url);\n            win.dispatchEvent(new Event(EV_MP_LOCATION_CHANGE));\n        };\n    }\n};\n\nAutocapture.prototype._getClickTrackingConfig = function(configKey) {\n    var config = this.getConfig(configKey);\n\n    if (!config) {\n        return null; // click tracking disabled\n    }\n\n    if (config === true) {\n        return {}; // use defaults\n    }\n\n    if (typeof config === 'object') {\n        return config; // use custom configuration\n    }\n\n    return {}; // fallback to defaults for any other truthy value\n};\n\nAutocapture.prototype._trackPageLeave = function(ev, currentUrl, currentScrollHeight) {\n    if (this.hasTrackedScrollSession) {\n        // User has navigated away already ending their impression.\n        return;\n    }\n\n    if (!this.getConfig(CONFIG_TRACK_PAGE_LEAVE) && !this.mp.is_recording_heatmap_data()) {\n        return;\n    }\n\n    this.hasTrackedScrollSession = true;\n    var viewportHeight = Math.max(document$1.documentElement.clientHeight, win.innerHeight || 0);\n    var scrollPercentage = Math.round(Math.max(this.maxScrollViewDepth - viewportHeight, 0) / (currentScrollHeight - viewportHeight) * 100);\n    var foldLinePercentage = Math.round((viewportHeight / currentScrollHeight) * 100);\n    if (currentScrollHeight <= viewportHeight) {\n        // If the content fits within the viewport, consider it fully scrolled\n        scrollPercentage = 100;\n        foldLinePercentage = 100;\n    }\n\n    var props = _.extend({\n        '$max_scroll_view_depth': this.maxScrollViewDepth,\n        '$max_scroll_percentage': scrollPercentage,\n        '$fold_line_percentage': foldLinePercentage,\n        '$scroll_height':  currentScrollHeight,\n        '$event_type': ev.type,\n        '$current_url': currentUrl || _.info.currentUrl(),\n        '$viewportHeight': viewportHeight, // This is the fold line\n        '$viewportWidth':  Math.max(document$1.documentElement.clientWidth, win.innerWidth || 0),\n        '$captured_for_heatmap': this.mp.is_recording_heatmap_data()\n    }, DEFAULT_PROPS);\n\n    // Send with beacon transport to ensure event is sent before unload\n    this.mp.track(MP_EV_PAGE_LEAVE, props, {transport: 'sendBeacon'});\n};\n\nAutocapture.prototype._initScrollDepthTracking = function() {\n    win.removeEventListener(EV_SCROLL, this.listenerScrollDepth);\n    win.removeEventListener(EV_SCROLLEND, this.listenerScrollDepth);\n\n    if (!this.mp.get_config('record_heatmap_data')) {\n        return;\n    }\n\n    logger$1.log('Initializing scroll depth tracking');\n\n    this.maxScrollViewDepth = Math.max(document$1.documentElement.clientHeight, win.innerHeight || 0);\n\n    var updateScrollDepth = function() {\n        if (this.currentUrlBlocked()) {\n            return;\n        }\n        var scrollViewHeight = Math.max(document$1.documentElement.clientHeight, win.innerHeight || 0) + win.scrollY;\n        if (scrollViewHeight > this.maxScrollViewDepth) {\n            this.maxScrollViewDepth = scrollViewHeight;\n        }\n        this.previousScrollHeight = document$1.body.scrollHeight;\n    }.bind(this);\n\n    var scrollEndPolyfill = getPolyfillScrollEndFunction(updateScrollDepth);\n    this.listenerScrollDepth = scrollEndPolyfill.listener;\n    win.addEventListener(scrollEndPolyfill.eventType, this.listenerScrollDepth);\n};\n\nAutocapture.prototype.initClickTracking = function() {\n    win.removeEventListener(EV_CLICK, this.listenerClick);\n\n    if (!this.getConfig(CONFIG_TRACK_CLICK) && !this.mp.get_config('record_heatmap_data')) {\n        return;\n    }\n    logger$1.log('Initializing click tracking');\n\n    this.listenerClick = function(ev) {\n        if (!this.getConfig(CONFIG_TRACK_CLICK) && !this.mp.is_recording_heatmap_data()) {\n            return;\n        }\n        this.trackDomEvent(ev, MP_EV_CLICK);\n    }.bind(this);\n    win.addEventListener(EV_CLICK, this.listenerClick);\n};\n\nAutocapture.prototype.initDeadClickTracking = function() {\n    var deadClickConfig = this._getClickTrackingConfig(CONFIG_TRACK_DEAD_CLICK);\n\n    if (!deadClickConfig && !this.mp.get_config('record_heatmap_data')) {\n        this.stopDeadClickTracking();\n        return;\n    }\n\n    logger$1.log('Initializing dead click tracking');\n    if (!this._deadClickTracker) {\n        this._deadClickTracker = new DeadClickTracker(function(deadClickEvent) {\n            this.trackDomEvent(deadClickEvent, MP_EV_DEAD_CLICK);\n        }.bind(this));\n        this._deadClickTracker.startTracking();\n    }\n\n    if (!this.listenerDeadClick) {\n        this.listenerDeadClick = function(ev) {\n            var currentDeadClickConfig = this._getClickTrackingConfig(CONFIG_TRACK_DEAD_CLICK);\n            if (!currentDeadClickConfig && !this.mp.is_recording_heatmap_data()) {\n                return;\n            }\n            if (this.currentUrlBlocked()) {\n                return;\n            }\n            // Normalize config to ensure timeout_ms is always set\n            var normalizedConfig = currentDeadClickConfig || {};\n            if (!normalizedConfig['timeout_ms']) {\n                normalizedConfig['timeout_ms'] = DEFAULT_DEAD_CLICK_TIMEOUT_MS;\n            }\n            this._deadClickTracker.trackClick(ev, normalizedConfig);\n        }.bind(this);\n        win.addEventListener(EV_CLICK, this.listenerDeadClick);\n    }\n};\n\nAutocapture.prototype.initInputTracking = function() {\n    win.removeEventListener(EV_CHANGE, this.listenerChange);\n\n    if (!this.getConfig(CONFIG_TRACK_INPUT)) {\n        return;\n    }\n    logger$1.log('Initializing input tracking');\n\n    this.listenerChange = function(ev) {\n        if (!this.getConfig(CONFIG_TRACK_INPUT)) {\n            return;\n        }\n        this.trackDomEvent(ev, MP_EV_INPUT);\n    }.bind(this);\n    win.addEventListener(EV_CHANGE, this.listenerChange);\n};\n\nAutocapture.prototype.initPageviewTracking = function() {\n    win.removeEventListener(EV_MP_LOCATION_CHANGE, this.listenerLocationchange);\n\n    if (!this.pageviewTrackingConfig()) {\n        return;\n    }\n    logger$1.log('Initializing pageview tracking');\n\n    var previousTrackedUrl = '';\n    var tracked = false;\n    if (!this.currentUrlBlocked()) {\n        tracked = this.mp.track_pageview(DEFAULT_PROPS);\n    }\n    if (tracked) {\n        previousTrackedUrl = _.info.currentUrl();\n    }\n\n    this.listenerLocationchange = safewrap(function() {\n        if (this.currentUrlBlocked()) {\n            return;\n        }\n\n        var currentUrl = _.info.currentUrl();\n        var shouldTrack = false;\n        var didPathChange = currentUrl.split('#')[0].split('?')[0] !== previousTrackedUrl.split('#')[0].split('?')[0];\n        var trackPageviewOption = this.pageviewTrackingConfig();\n        if (trackPageviewOption === PAGEVIEW_OPTION_FULL_URL) {\n            shouldTrack = currentUrl !== previousTrackedUrl;\n        } else if (trackPageviewOption === PAGEVIEW_OPTION_URL_WITH_PATH_AND_QUERY_STRING) {\n            shouldTrack = currentUrl.split('#')[0] !== previousTrackedUrl.split('#')[0];\n        } else if (trackPageviewOption === PAGEVIEW_OPTION_URL_WITH_PATH) {\n            shouldTrack = didPathChange;\n        }\n\n        if (shouldTrack) {\n            var tracked = this.mp.track_pageview(DEFAULT_PROPS);\n            if (tracked) {\n                previousTrackedUrl = currentUrl;\n            }\n            if (didPathChange) {\n                this.lastScrollCheckpoint = 0;\n                logger$1.log('Path change: re-initializing scroll depth checkpoints');\n            }\n        }\n    }.bind(this));\n    win.addEventListener(EV_MP_LOCATION_CHANGE, this.listenerLocationchange);\n};\n\nAutocapture.prototype.initRageClickTracking = function() {\n    win.removeEventListener(EV_CLICK, this.listenerRageClick);\n\n    var rageClickConfig = this._getClickTrackingConfig(CONFIG_TRACK_RAGE_CLICK);\n    if (!rageClickConfig && !this.mp.get_config('record_heatmap_data')) {\n        return;\n    }\n\n    logger$1.log('Initializing rage click tracking');\n    if (!this._rageClickTracker) {\n        this._rageClickTracker = new RageClickTracker();\n    }\n\n    this.listenerRageClick = function(ev) {\n        var currentRageClickConfig = this._getClickTrackingConfig(CONFIG_TRACK_RAGE_CLICK);\n        if (!currentRageClickConfig && !this.mp.is_recording_heatmap_data()) {\n            return;\n        }\n\n        if (this.currentUrlBlocked()) {\n            return;\n        }\n\n        if (this._rageClickTracker.isRageClick(ev, currentRageClickConfig)) {\n            this.trackDomEvent(ev, MP_EV_RAGE_CLICK);\n        }\n    }.bind(this);\n    win.addEventListener(EV_CLICK, this.listenerRageClick);\n};\n\nAutocapture.prototype.initScrollTracking = function() {\n    win.removeEventListener(EV_SCROLLEND, this.listenerScroll);\n    win.removeEventListener(EV_SCROLL, this.listenerScroll);\n\n\n    if (!this.getConfig(CONFIG_TRACK_SCROLL)) {\n        return;\n    }\n    logger$1.log('Initializing scroll tracking');\n    this.lastScrollCheckpoint = 0;\n\n    var scrollTrackFunction = function() {\n        if (!this.getConfig(CONFIG_TRACK_SCROLL)) {\n            return;\n        }\n        if (this.currentUrlBlocked()) {\n            return;\n        }\n\n        var shouldTrack = this.getConfig(CONFIG_SCROLL_CAPTURE_ALL);\n        var scrollCheckpoints = (this.getConfig(CONFIG_SCROLL_CHECKPOINTS) || [])\n            .slice()\n            .sort(function(a, b) { return a - b; });\n\n        var scrollTop = win.scrollY;\n        var props = _.extend({'$scroll_top': scrollTop}, DEFAULT_PROPS);\n        try {\n            var scrollHeight = document$1.body.scrollHeight;\n            var scrollPercentage = Math.round((scrollTop / (scrollHeight - win.innerHeight)) * 100);\n            props['$scroll_height'] = scrollHeight;\n            props['$scroll_percentage'] = scrollPercentage;\n            if (scrollPercentage > this.lastScrollCheckpoint) {\n                for (var i = 0; i < scrollCheckpoints.length; i++) {\n                    var checkpoint = scrollCheckpoints[i];\n                    if (\n                        scrollPercentage >= checkpoint &&\n                        this.lastScrollCheckpoint < checkpoint\n                    ) {\n                        props['$scroll_checkpoint'] = checkpoint;\n                        this.lastScrollCheckpoint = checkpoint;\n                        shouldTrack = true;\n                    }\n                }\n            }\n        } catch (err) {\n            logger$1.critical('Error while calculating scroll percentage', err);\n        }\n        if (shouldTrack) {\n            this.mp.track(MP_EV_SCROLL, props);\n        }\n    }.bind(this);\n\n    var scrollEndPolyfill = getPolyfillScrollEndFunction(scrollTrackFunction);\n    this.listenerScroll = scrollEndPolyfill.listener;\n    win.addEventListener(scrollEndPolyfill.eventType, this.listenerScroll);\n};\n\nAutocapture.prototype.initSubmitTracking = function() {\n    win.removeEventListener(EV_SUBMIT, this.listenerSubmit);\n\n    if (!this.getConfig(CONFIG_TRACK_SUBMIT)) {\n        return;\n    }\n    logger$1.log('Initializing submit tracking');\n\n    this.listenerSubmit = function(ev) {\n        if (!this.getConfig(CONFIG_TRACK_SUBMIT)) {\n            return;\n        }\n        this.trackDomEvent(ev, MP_EV_SUBMIT);\n    }.bind(this);\n    win.addEventListener(EV_SUBMIT, this.listenerSubmit);\n};\n\nAutocapture.prototype.initPageLeaveTracking = function() {\n    // Capture page_leave both when the user navigates away from the page (visibilitychange) as well\n    // as when they navigate to a different page within the SPA (popstate/pushstate/hashchange).\n    document$1.removeEventListener(EV_VISIBILITYCHANGE, this.listenerPageLeaveVisibilitychange);\n    win.removeEventListener(EV_MP_LOCATION_CHANGE, this.listenerPageLeaveLocationchange);\n    win.removeEventListener(EV_LOAD, this.listenerPageLoad);\n\n    if (!this.getConfig(CONFIG_TRACK_PAGE_LEAVE) && !this.mp.get_config('record_heatmap_data')) {\n        return;\n    }\n\n    logger$1.log('Initializing page visibility tracking.');\n    this._initScrollDepthTracking();\n    var previousTrackedUrl = _.info.currentUrl();\n\n    // Initialize previousScrollHeight on `load` which handles async loading\n    // https://developer.mozilla.org/en-US/docs/Web/API/Window/load_event\n    this.listenerPageLoad = function() {\n        this.previousScrollHeight = document$1.body.scrollHeight;\n    }.bind(this);\n    win.addEventListener(EV_LOAD, this.listenerPageLoad);\n\n    // Track page navigation events similar to how initPageviewTracking does it\n    this.listenerPageLeaveLocationchange = safewrap(function(ev) {\n        if (this.currentUrlBlocked()) {\n            return;\n        }\n\n        var currentUrl = _.info.currentUrl();\n        // Track all URL changes including query string or fragment changes as separate scroll sessions\n        var shouldTrack = currentUrl !== previousTrackedUrl;\n\n        if (shouldTrack) {\n            this._trackPageLeave(ev, previousTrackedUrl, this.previousScrollHeight);\n            previousTrackedUrl = currentUrl;\n            // Fragment navigation should call scroll(end) and trigger listener, don't add window.scrollY here.\n            this.maxScrollViewDepth = Math.max(document$1.documentElement.clientHeight, win.innerHeight || 0);\n            this.previousScrollHeight = document$1.body.scrollHeight;\n            this.hasTrackedScrollSession = false;\n        }\n    }.bind(this));\n    win.addEventListener(EV_MP_LOCATION_CHANGE, this.listenerPageLeaveLocationchange);\n\n    this.listenerPageLeaveVisibilitychange = function(ev) {\n        if (document$1.hidden) {\n            this._trackPageLeave(ev, previousTrackedUrl, this.previousScrollHeight);\n        }\n    }.bind(this);\n    document$1.addEventListener(EV_VISIBILITYCHANGE, this.listenerPageLeaveVisibilitychange);\n};\n\nAutocapture.prototype.stopDeadClickTracking = function() {\n    if (this.listenerDeadClick) {\n        win.removeEventListener(EV_CLICK, this.listenerDeadClick);\n        this.listenerDeadClick = null;\n    }\n\n    if (this._deadClickTracker) {\n        this._deadClickTracker.stopTracking();\n        this._deadClickTracker = null;\n    }\n};\n\n// TODO integrate error_reporter from mixpanel instance\nsafewrapClass(Autocapture);\n\nvar logger = console_with_prefix('flags');\n\nvar FLAGS_CONFIG_KEY = 'flags';\n\nvar CONFIG_CONTEXT = 'context';\nvar CONFIG_DEFAULTS = {};\nCONFIG_DEFAULTS[CONFIG_CONTEXT] = {};\n\n/**\n * FeatureFlagManager: support for Mixpanel's feature flagging product\n * @constructor\n */\nvar FeatureFlagManager = function(initOptions) {\n    this.fetch = win['fetch'];\n    this.getFullApiRoute = initOptions.getFullApiRoute;\n    this.getMpConfig = initOptions.getConfigFunc;\n    this.setMpConfig = initOptions.setConfigFunc;\n    this.getMpProperty = initOptions.getPropertyFunc;\n    this.track = initOptions.trackingFunc;\n};\n\nFeatureFlagManager.prototype.init = function() {\n    if (!this.minApisSupported()) {\n        logger.critical('Feature Flags unavailable: missing minimum required APIs');\n        return;\n    }\n\n    this.flags = null;\n    this.fetchFlags();\n\n    this.trackedFeatures = new Set();\n};\n\nFeatureFlagManager.prototype.getFullConfig = function() {\n    var ffConfig = this.getMpConfig(FLAGS_CONFIG_KEY);\n    if (!ffConfig) {\n        // flags are completely off\n        return {};\n    } else if (_.isObject(ffConfig)) {\n        return _.extend({}, CONFIG_DEFAULTS, ffConfig);\n    } else {\n        // config is non-object truthy value, return default\n        return CONFIG_DEFAULTS;\n    }\n};\n\nFeatureFlagManager.prototype.getConfig = function(key) {\n    return this.getFullConfig()[key];\n};\n\nFeatureFlagManager.prototype.isSystemEnabled = function() {\n    return !!this.getMpConfig(FLAGS_CONFIG_KEY);\n};\n\nFeatureFlagManager.prototype.updateContext = function(newContext, options) {\n    if (!this.isSystemEnabled()) {\n        logger.critical('Feature Flags not enabled, cannot update context');\n        return Promise.resolve();\n    }\n\n    var ffConfig = this.getMpConfig(FLAGS_CONFIG_KEY);\n    if (!_.isObject(ffConfig)) {\n        ffConfig = {};\n    }\n    var oldContext = (options && options['replace']) ? {} : this.getConfig(CONFIG_CONTEXT);\n    ffConfig[CONFIG_CONTEXT] = _.extend({}, oldContext, newContext);\n\n    this.setMpConfig(FLAGS_CONFIG_KEY, ffConfig);\n    return this.fetchFlags();\n};\n\nFeatureFlagManager.prototype.areFlagsReady = function() {\n    if (!this.isSystemEnabled()) {\n        logger.error('Feature Flags not enabled');\n    }\n    return !!this.flags;\n};\n\nFeatureFlagManager.prototype.fetchFlags = function() {\n    if (!this.isSystemEnabled()) {\n        return Promise.resolve();\n    }\n\n    var distinctId = this.getMpProperty('distinct_id');\n    var deviceId = this.getMpProperty('$device_id');\n    var traceparent = generateTraceparent();\n    logger.log('Fetching flags for distinct ID: ' + distinctId);\n\n    var context = _.extend({'distinct_id': distinctId, 'device_id': deviceId}, this.getConfig(CONFIG_CONTEXT));\n    var searchParams = new URLSearchParams();\n    searchParams.set('context', JSON.stringify(context));\n    searchParams.set('token', this.getMpConfig('token'));\n    searchParams.set('mp_lib', 'web');\n    searchParams.set('$lib_version', Config.LIB_VERSION);\n    var url = this.getFullApiRoute() + '?' + searchParams.toString();\n\n    this._fetchInProgressStartTime = Date.now();\n    this.fetchPromise = this.fetch.call(win, url, {\n        'method': 'GET',\n        'headers': {\n            'Authorization': 'Basic ' + btoa(this.getMpConfig('token') + ':'),\n            'traceparent': traceparent\n        }\n    }).then(function(response) {\n        this.markFetchComplete();\n        return response.json().then(function(responseBody) {\n            var responseFlags = responseBody['flags'];\n            if (!responseFlags) {\n                throw new Error('No flags in API response');\n            }\n            var flags = new Map();\n            _.each(responseFlags, function(data, key) {\n                flags.set(key, {\n                    'key': data['variant_key'],\n                    'value': data['variant_value'],\n                    'experiment_id': data['experiment_id'],\n                    'is_experiment_active': data['is_experiment_active'],\n                    'is_qa_tester': data['is_qa_tester']\n                });\n            });\n            this.flags = flags;\n            this._traceparent = traceparent;\n        }.bind(this)).catch(function(error) {\n            this.markFetchComplete();\n            logger.error(error);\n        }.bind(this));\n    }.bind(this)).catch(function(error) {\n        this.markFetchComplete();\n        logger.error(error);\n    }.bind(this));\n\n    return this.fetchPromise;\n};\n\nFeatureFlagManager.prototype.markFetchComplete = function() {\n    if (!this._fetchInProgressStartTime) {\n        logger.error('Fetch in progress started time not set, cannot mark fetch complete');\n        return;\n    }\n    this._fetchStartTime = this._fetchInProgressStartTime;\n    this._fetchCompleteTime = Date.now();\n    this._fetchLatency = this._fetchCompleteTime - this._fetchStartTime;\n    this._fetchInProgressStartTime = null;\n};\n\nFeatureFlagManager.prototype.getVariant = function(featureName, fallback) {\n    if (!this.fetchPromise) {\n        return new Promise(function(resolve) {\n            logger.critical('Feature Flags not initialized');\n            resolve(fallback);\n        });\n    }\n\n    return this.fetchPromise.then(function() {\n        return this.getVariantSync(featureName, fallback);\n    }.bind(this)).catch(function(error) {\n        logger.error(error);\n        return fallback;\n    });\n};\n\nFeatureFlagManager.prototype.getVariantSync = function(featureName, fallback) {\n    if (!this.areFlagsReady()) {\n        logger.log('Flags not loaded yet');\n        return fallback;\n    }\n    var feature = this.flags.get(featureName);\n    if (!feature) {\n        logger.log('No flag found: \"' + featureName + '\"');\n        return fallback;\n    }\n    this.trackFeatureCheck(featureName, feature);\n    return feature;\n};\n\nFeatureFlagManager.prototype.getVariantValue = function(featureName, fallbackValue) {\n    return this.getVariant(featureName, {'value': fallbackValue}).then(function(feature) {\n        return feature['value'];\n    }).catch(function(error) {\n        logger.error(error);\n        return fallbackValue;\n    });\n};\n\n// TODO remove deprecated method\nFeatureFlagManager.prototype.getFeatureData = function(featureName, fallbackValue) {\n    logger.critical('mixpanel.flags.get_feature_data() is deprecated and will be removed in a future release. Use mixpanel.flags.get_variant_value() instead.');\n    return this.getVariantValue(featureName, fallbackValue);\n};\n\nFeatureFlagManager.prototype.getVariantValueSync = function(featureName, fallbackValue) {\n    return this.getVariantSync(featureName, {'value': fallbackValue})['value'];\n};\n\nFeatureFlagManager.prototype.isEnabled = function(featureName, fallbackValue) {\n    return this.getVariantValue(featureName).then(function() {\n        return this.isEnabledSync(featureName, fallbackValue);\n    }.bind(this)).catch(function(error) {\n        logger.error(error);\n        return fallbackValue;\n    });\n};\n\nFeatureFlagManager.prototype.isEnabledSync = function(featureName, fallbackValue) {\n    fallbackValue = fallbackValue || false;\n    var val = this.getVariantValueSync(featureName, fallbackValue);\n    if (val !== true && val !== false) {\n        logger.error('Feature flag \"' + featureName + '\" value: ' + val + ' is not a boolean; returning fallback value: ' + fallbackValue);\n        val = fallbackValue;\n    }\n    return val;\n};\n\nFeatureFlagManager.prototype.trackFeatureCheck = function(featureName, feature) {\n    if (this.trackedFeatures.has(featureName)) {\n        return;\n    }\n    this.trackedFeatures.add(featureName);\n\n    var trackingProperties = {\n        'Experiment name': featureName,\n        'Variant name': feature['key'],\n        '$experiment_type': 'feature_flag',\n        'Variant fetch start time': new Date(this._fetchStartTime).toISOString(),\n        'Variant fetch complete time': new Date(this._fetchCompleteTime).toISOString(),\n        'Variant fetch latency (ms)': this._fetchLatency,\n        'Variant fetch traceparent': this._traceparent,\n    };\n\n    if (feature['experiment_id'] !== 'undefined') {\n        trackingProperties['$experiment_id'] = feature['experiment_id'];\n    }\n    if (feature['is_experiment_active'] !== 'undefined') {\n        trackingProperties['$is_experiment_active'] = feature['is_experiment_active'];\n    }\n    if (feature['is_qa_tester'] !== 'undefined') {\n        trackingProperties['$is_qa_tester'] = feature['is_qa_tester'];\n    }\n\n    this.track('$experiment_started', trackingProperties);\n};\n\nFeatureFlagManager.prototype.minApisSupported = function() {\n    return !!this.fetch &&\n      typeof Promise !== 'undefined' &&\n      typeof Map !== 'undefined' &&\n      typeof Set !== 'undefined';\n};\n\nsafewrapClass(FeatureFlagManager);\n\nFeatureFlagManager.prototype['are_flags_ready'] = FeatureFlagManager.prototype.areFlagsReady;\nFeatureFlagManager.prototype['get_variant'] = FeatureFlagManager.prototype.getVariant;\nFeatureFlagManager.prototype['get_variant_sync'] = FeatureFlagManager.prototype.getVariantSync;\nFeatureFlagManager.prototype['get_variant_value'] = FeatureFlagManager.prototype.getVariantValue;\nFeatureFlagManager.prototype['get_variant_value_sync'] = FeatureFlagManager.prototype.getVariantValueSync;\nFeatureFlagManager.prototype['is_enabled'] = FeatureFlagManager.prototype.isEnabled;\nFeatureFlagManager.prototype['is_enabled_sync'] = FeatureFlagManager.prototype.isEnabledSync;\nFeatureFlagManager.prototype['update_context'] = FeatureFlagManager.prototype.updateContext;\n\n// Deprecated method\nFeatureFlagManager.prototype['get_feature_data'] = FeatureFlagManager.prototype.getFeatureData;\n\n/* eslint camelcase: \"off\" */\n\n\n/**\n * DomTracker Object\n * @constructor\n */\nvar DomTracker = function() {};\n\n\n// interface\nDomTracker.prototype.create_properties = function() {};\nDomTracker.prototype.event_handler = function() {};\nDomTracker.prototype.after_track_handler = function() {};\n\nDomTracker.prototype.init = function(mixpanel_instance) {\n    this.mp = mixpanel_instance;\n    return this;\n};\n\n/**\n * @param {Object|string} query\n * @param {string} event_name\n * @param {Object=} properties\n * @param {function=} user_callback\n */\nDomTracker.prototype.track = function(query, event_name, properties, user_callback) {\n    var that = this;\n    var elements = _.dom_query(query);\n\n    if (elements.length === 0) {\n        console$1.error('The DOM query (' + query + ') returned 0 elements');\n        return;\n    }\n\n    _.each(elements, function(element) {\n        _.register_event(element, this.override_event, function(e) {\n            var options = {};\n            var props = that.create_properties(properties, this);\n            var timeout = that.mp.get_config('track_links_timeout');\n\n            that.event_handler(e, this, options);\n\n            // in case the mixpanel servers don't get back to us in time\n            window.setTimeout(that.track_callback(user_callback, props, options, true), timeout);\n\n            // fire the tracking event\n            that.mp.track(event_name, props, that.track_callback(user_callback, props, options));\n        });\n    }, this);\n\n    return true;\n};\n\n/**\n * @param {function} user_callback\n * @param {Object} props\n * @param {boolean=} timeout_occured\n */\nDomTracker.prototype.track_callback = function(user_callback, props, options, timeout_occured) {\n    timeout_occured = timeout_occured || false;\n    var that = this;\n\n    return function() {\n        // options is referenced from both callbacks, so we can have\n        // a 'lock' of sorts to ensure only one fires\n        if (options.callback_fired) { return; }\n        options.callback_fired = true;\n\n        if (user_callback && user_callback(timeout_occured, props) === false) {\n            // user can prevent the default functionality by\n            // returning false from their callback\n            return;\n        }\n\n        that.after_track_handler(props, options, timeout_occured);\n    };\n};\n\nDomTracker.prototype.create_properties = function(properties, element) {\n    var props;\n\n    if (typeof(properties) === 'function') {\n        props = properties(element);\n    } else {\n        props = _.extend({}, properties);\n    }\n\n    return props;\n};\n\n/**\n * LinkTracker Object\n * @constructor\n * @extends DomTracker\n */\nvar LinkTracker = function() {\n    this.override_event = 'click';\n};\n_.inherit(LinkTracker, DomTracker);\n\nLinkTracker.prototype.create_properties = function(properties, element) {\n    var props = LinkTracker.superclass.create_properties.apply(this, arguments);\n\n    if (element.href) { props['url'] = element.href; }\n\n    return props;\n};\n\nLinkTracker.prototype.event_handler = function(evt, element, options) {\n    options.new_tab = (\n        evt.which === 2 ||\n        evt.metaKey ||\n        evt.ctrlKey ||\n        element.target === '_blank'\n    );\n    options.href = element.href;\n\n    if (!options.new_tab) {\n        evt.preventDefault();\n    }\n};\n\nLinkTracker.prototype.after_track_handler = function(props, options) {\n    if (options.new_tab) { return; }\n\n    setTimeout(function() {\n        window.location = options.href;\n    }, 0);\n};\n\n/**\n * FormTracker Object\n * @constructor\n * @extends DomTracker\n */\nvar FormTracker = function() {\n    this.override_event = 'submit';\n};\n_.inherit(FormTracker, DomTracker);\n\nFormTracker.prototype.event_handler = function(evt, element, options) {\n    options.element = element;\n    evt.preventDefault();\n};\n\nFormTracker.prototype.after_track_handler = function(props, options) {\n    setTimeout(function() {\n        options.element.submit();\n    }, 0);\n};\n\n/* eslint camelcase: \"off\" */\n\n\n/** @const */ var SET_ACTION      = '$set';\n/** @const */ var SET_ONCE_ACTION = '$set_once';\n/** @const */ var UNSET_ACTION    = '$unset';\n/** @const */ var ADD_ACTION      = '$add';\n/** @const */ var APPEND_ACTION   = '$append';\n/** @const */ var UNION_ACTION    = '$union';\n/** @const */ var REMOVE_ACTION   = '$remove';\n/** @const */ var DELETE_ACTION   = '$delete';\n\n// Common internal methods for mixpanel.people and mixpanel.group APIs.\n// These methods shouldn't involve network I/O.\nvar apiActions = {\n    set_action: function(prop, to) {\n        var data = {};\n        var $set = {};\n        if (_.isObject(prop)) {\n            _.each(prop, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $set[k] = v;\n                }\n            }, this);\n        } else {\n            $set[prop] = to;\n        }\n\n        data[SET_ACTION] = $set;\n        return data;\n    },\n\n    unset_action: function(prop) {\n        var data = {};\n        var $unset = [];\n        if (!_.isArray(prop)) {\n            prop = [prop];\n        }\n\n        _.each(prop, function(k) {\n            if (!this._is_reserved_property(k)) {\n                $unset.push(k);\n            }\n        }, this);\n\n        data[UNSET_ACTION] = $unset;\n        return data;\n    },\n\n    set_once_action: function(prop, to) {\n        var data = {};\n        var $set_once = {};\n        if (_.isObject(prop)) {\n            _.each(prop, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $set_once[k] = v;\n                }\n            }, this);\n        } else {\n            $set_once[prop] = to;\n        }\n        data[SET_ONCE_ACTION] = $set_once;\n        return data;\n    },\n\n    union_action: function(list_name, values) {\n        var data = {};\n        var $union = {};\n        if (_.isObject(list_name)) {\n            _.each(list_name, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $union[k] = _.isArray(v) ? v : [v];\n                }\n            }, this);\n        } else {\n            $union[list_name] = _.isArray(values) ? values : [values];\n        }\n        data[UNION_ACTION] = $union;\n        return data;\n    },\n\n    append_action: function(list_name, value) {\n        var data = {};\n        var $append = {};\n        if (_.isObject(list_name)) {\n            _.each(list_name, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $append[k] = v;\n                }\n            }, this);\n        } else {\n            $append[list_name] = value;\n        }\n        data[APPEND_ACTION] = $append;\n        return data;\n    },\n\n    remove_action: function(list_name, value) {\n        var data = {};\n        var $remove = {};\n        if (_.isObject(list_name)) {\n            _.each(list_name, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $remove[k] = v;\n                }\n            }, this);\n        } else {\n            $remove[list_name] = value;\n        }\n        data[REMOVE_ACTION] = $remove;\n        return data;\n    },\n\n    delete_action: function() {\n        var data = {};\n        data[DELETE_ACTION] = '';\n        return data;\n    }\n};\n\n/* eslint camelcase: \"off\" */\n\n/**\n * Mixpanel Group Object\n * @constructor\n */\nvar MixpanelGroup = function() {};\n\n_.extend(MixpanelGroup.prototype, apiActions);\n\nMixpanelGroup.prototype._init = function(mixpanel_instance, group_key, group_id) {\n    this._mixpanel = mixpanel_instance;\n    this._group_key = group_key;\n    this._group_id = group_id;\n};\n\n/**\n * Set properties on a group.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').set('Location', '405 Howard');\n *\n *     // or set multiple properties at once\n *     mixpanel.get_group('company', 'mixpanel').set({\n *          'Location': '405 Howard',\n *          'Founded' : 2009,\n *     });\n *     // properties can be strings, integers, dates, or lists\n *\n * @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n * @param {*} [to] A value to set on the given property name\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.set = addOptOutCheckMixpanelGroup(function(prop, to, callback) {\n    var data = this.set_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    return this._send_request(data, callback);\n});\n\n/**\n * Set properties on a group, only if they do not yet exist.\n * This will not overwrite previous group property values, unlike\n * group.set().\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').set_once('Location', '405 Howard');\n *\n *     // or set multiple properties at once\n *     mixpanel.get_group('company', 'mixpanel').set_once({\n *          'Location': '405 Howard',\n *          'Founded' : 2009,\n *     });\n *     // properties can be strings, integers, lists or dates\n *\n * @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n * @param {*} [to] A value to set on the given property name\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.set_once = addOptOutCheckMixpanelGroup(function(prop, to, callback) {\n    var data = this.set_once_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    return this._send_request(data, callback);\n});\n\n/**\n * Unset properties on a group permanently.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').unset('Founded');\n *\n * @param {String} prop The name of the property.\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.unset = addOptOutCheckMixpanelGroup(function(prop, callback) {\n    var data = this.unset_action(prop);\n    return this._send_request(data, callback);\n});\n\n/**\n * Merge a given list with a list-valued group property, excluding duplicate values.\n *\n * ### Usage:\n *\n *     // merge a value to a list, creating it if needed\n *     mixpanel.get_group('company', 'mixpanel').union('Location', ['San Francisco', 'London']);\n *\n * @param {String} list_name Name of the property.\n * @param {Array} values Values to merge with the given property\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.union = addOptOutCheckMixpanelGroup(function(list_name, values, callback) {\n    if (_.isObject(list_name)) {\n        callback = values;\n    }\n    var data = this.union_action(list_name, values);\n    return this._send_request(data, callback);\n});\n\n/**\n * Permanently delete a group.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').delete();\n *\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype['delete'] = addOptOutCheckMixpanelGroup(function(callback) {\n    // bracket notation above prevents a minification error related to reserved words\n    var data = this.delete_action();\n    return this._send_request(data, callback);\n});\n\n/**\n * Remove a property from a group. The value will be ignored if doesn't exist.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').remove('Location', 'London');\n *\n * @param {String} list_name Name of the property.\n * @param {Object} value Value to remove from the given group property\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.remove = addOptOutCheckMixpanelGroup(function(list_name, value, callback) {\n    var data = this.remove_action(list_name, value);\n    return this._send_request(data, callback);\n});\n\nMixpanelGroup.prototype._send_request = function(data, callback) {\n    data['$group_key'] = this._group_key;\n    data['$group_id'] = this._group_id;\n    data['$token'] = this._get_config('token');\n\n    var date_encoded_data = _.encodeDates(data);\n    return this._mixpanel._track_or_batch({\n        type: 'groups',\n        data: date_encoded_data,\n        endpoint: this._mixpanel.get_api_host('groups') + '/' +  this._get_config('api_routes')['groups'],\n        batcher: this._mixpanel.request_batchers.groups\n    }, callback);\n};\n\nMixpanelGroup.prototype._is_reserved_property = function(prop) {\n    return prop === '$group_key' || prop === '$group_id';\n};\n\nMixpanelGroup.prototype._get_config = function(conf) {\n    return this._mixpanel.get_config(conf);\n};\n\nMixpanelGroup.prototype.toString = function() {\n    return this._mixpanel.toString() + '.group.' + this._group_key + '.' + this._group_id;\n};\n\n// MixpanelGroup Exports\nMixpanelGroup.prototype['remove']   = MixpanelGroup.prototype.remove;\nMixpanelGroup.prototype['set']      = MixpanelGroup.prototype.set;\nMixpanelGroup.prototype['set_once'] = MixpanelGroup.prototype.set_once;\nMixpanelGroup.prototype['union']    = MixpanelGroup.prototype.union;\nMixpanelGroup.prototype['unset']    = MixpanelGroup.prototype.unset;\nMixpanelGroup.prototype['toString'] = MixpanelGroup.prototype.toString;\n\n/* eslint camelcase: \"off\" */\n\n/**\n * Mixpanel People Object\n * @constructor\n */\nvar MixpanelPeople = function() {};\n\n_.extend(MixpanelPeople.prototype, apiActions);\n\nMixpanelPeople.prototype._init = function(mixpanel_instance) {\n    this._mixpanel = mixpanel_instance;\n};\n\n/*\n* Set properties on a user record.\n*\n* ### Usage:\n*\n*     mixpanel.people.set('gender', 'm');\n*\n*     // or set multiple properties at once\n*     mixpanel.people.set({\n*         'Company': 'Acme',\n*         'Plan': 'Premium',\n*         'Upgrade date': new Date()\n*     });\n*     // properties can be strings, integers, dates, or lists\n*\n* @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [to] A value to set on the given property name\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.set = addOptOutCheckMixpanelPeople(function(prop, to, callback) {\n    var data = this.set_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    // make sure that the referrer info has been updated and saved\n    if (this._get_config('save_referrer')) {\n        this._mixpanel['persistence'].update_referrer_info(document.referrer);\n    }\n\n    // update $set object with default people properties\n    data[SET_ACTION] = _.extend(\n        {},\n        _.info.people_properties(),\n        data[SET_ACTION]\n    );\n    return this._send_request(data, callback);\n});\n\n/*\n* Set properties on a user record, only if they do not yet exist.\n* This will not overwrite previous people property values, unlike\n* people.set().\n*\n* ### Usage:\n*\n*     mixpanel.people.set_once('First Login Date', new Date());\n*\n*     // or set multiple properties at once\n*     mixpanel.people.set_once({\n*         'First Login Date': new Date(),\n*         'Starting Plan': 'Premium'\n*     });\n*\n*     // properties can be strings, integers or dates\n*\n* @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [to] A value to set on the given property name\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.set_once = addOptOutCheckMixpanelPeople(function(prop, to, callback) {\n    var data = this.set_once_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    return this._send_request(data, callback);\n});\n\n/*\n* Unset properties on a user record (permanently removes the properties and their values from a profile).\n*\n* ### Usage:\n*\n*     mixpanel.people.unset('gender');\n*\n*     // or unset multiple properties at once\n*     mixpanel.people.unset(['gender', 'Company']);\n*\n* @param {Array|String} prop If a string, this is the name of the property. If an array, this is a list of property names.\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.unset = addOptOutCheckMixpanelPeople(function(prop, callback) {\n    var data = this.unset_action(prop);\n    return this._send_request(data, callback);\n});\n\n/*\n* Increment/decrement numeric people analytics properties.\n*\n* ### Usage:\n*\n*     mixpanel.people.increment('page_views', 1);\n*\n*     // or, for convenience, if you're just incrementing a counter by\n*     // 1, you can simply do\n*     mixpanel.people.increment('page_views');\n*\n*     // to decrement a counter, pass a negative number\n*     mixpanel.people.increment('credits_left', -1);\n*\n*     // like mixpanel.people.set(), you can increment multiple\n*     // properties at once:\n*     mixpanel.people.increment({\n*         counter1: 1,\n*         counter2: 6\n*     });\n*\n* @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and numeric values.\n* @param {Number} [by] An amount to increment the given property\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.increment = addOptOutCheckMixpanelPeople(function(prop, by, callback) {\n    var data = {};\n    var $add = {};\n    if (_.isObject(prop)) {\n        _.each(prop, function(v, k) {\n            if (!this._is_reserved_property(k)) {\n                if (isNaN(parseFloat(v))) {\n                    console$1.error('Invalid increment value passed to mixpanel.people.increment - must be a number');\n                    return;\n                } else {\n                    $add[k] = v;\n                }\n            }\n        }, this);\n        callback = by;\n    } else {\n        // convenience: mixpanel.people.increment('property'); will\n        // increment 'property' by 1\n        if (_.isUndefined(by)) {\n            by = 1;\n        }\n        $add[prop] = by;\n    }\n    data[ADD_ACTION] = $add;\n\n    return this._send_request(data, callback);\n});\n\n/*\n* Append a value to a list-valued people analytics property.\n*\n* ### Usage:\n*\n*     // append a value to a list, creating it if needed\n*     mixpanel.people.append('pages_visited', 'homepage');\n*\n*     // like mixpanel.people.set(), you can append multiple\n*     // properties at once:\n*     mixpanel.people.append({\n*         list1: 'bob',\n*         list2: 123\n*     });\n*\n* @param {Object|String} list_name If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [value] value An item to append to the list\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.append = addOptOutCheckMixpanelPeople(function(list_name, value, callback) {\n    if (_.isObject(list_name)) {\n        callback = value;\n    }\n    var data = this.append_action(list_name, value);\n    return this._send_request(data, callback);\n});\n\n/*\n* Remove a value from a list-valued people analytics property.\n*\n* ### Usage:\n*\n*     mixpanel.people.remove('School', 'UCB');\n*\n* @param {Object|String} list_name If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [value] value Item to remove from the list\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.remove = addOptOutCheckMixpanelPeople(function(list_name, value, callback) {\n    if (_.isObject(list_name)) {\n        callback = value;\n    }\n    var data = this.remove_action(list_name, value);\n    return this._send_request(data, callback);\n});\n\n/*\n* Merge a given list with a list-valued people analytics property,\n* excluding duplicate values.\n*\n* ### Usage:\n*\n*     // merge a value to a list, creating it if needed\n*     mixpanel.people.union('pages_visited', 'homepage');\n*\n*     // like mixpanel.people.set(), you can append multiple\n*     // properties at once:\n*     mixpanel.people.union({\n*         list1: 'bob',\n*         list2: 123\n*     });\n*\n*     // like mixpanel.people.append(), you can append multiple\n*     // values to the same list:\n*     mixpanel.people.union({\n*         list1: ['bob', 'billy']\n*     });\n*\n* @param {Object|String} list_name If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [value] Value / values to merge with the given property\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.union = addOptOutCheckMixpanelPeople(function(list_name, values, callback) {\n    if (_.isObject(list_name)) {\n        callback = values;\n    }\n    var data = this.union_action(list_name, values);\n    return this._send_request(data, callback);\n});\n\n/*\n * Record that you have charged the current user a certain amount\n * of money. Charges recorded with track_charge() will appear in the\n * Mixpanel revenue report.\n *\n * ### Usage:\n *\n *     // charge a user $50\n *     mixpanel.people.track_charge(50);\n *\n *     // charge a user $30.50 on the 2nd of january\n *     mixpanel.people.track_charge(30.50, {\n *         '$time': new Date('jan 1 2012')\n *     });\n *\n * @param {Number} amount The amount of money charged to the current user\n * @param {Object} [properties] An associative array of properties associated with the charge\n * @param {Function} [callback] If provided, the callback will be called when the server responds\n * @deprecated\n */\nMixpanelPeople.prototype.track_charge = addOptOutCheckMixpanelPeople(function() {\n    console$1.error('mixpanel.people.track_charge() is deprecated and no longer has any effect.');\n});\n\n/*\n * Permanently clear all revenue report transactions from the\n * current user's people analytics profile.\n *\n * ### Usage:\n *\n *     mixpanel.people.clear_charges();\n *\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n * @deprecated\n */\nMixpanelPeople.prototype.clear_charges = function(callback) {\n    return this.set('$transactions', [], callback);\n};\n\n/*\n* Permanently deletes the current people analytics profile from\n* Mixpanel (using the current distinct_id).\n*\n* ### Usage:\n*\n*     // remove the all data you have stored about the current user\n*     mixpanel.people.delete_user();\n*\n*/\nMixpanelPeople.prototype.delete_user = function() {\n    if (!this._identify_called()) {\n        console$1.error('mixpanel.people.delete_user() requires you to call identify() first');\n        return;\n    }\n    var data = {'$delete': this._mixpanel.get_distinct_id()};\n    return this._send_request(data);\n};\n\nMixpanelPeople.prototype.toString = function() {\n    return this._mixpanel.toString() + '.people';\n};\n\nMixpanelPeople.prototype._send_request = function(data, callback) {\n    data['$token'] = this._get_config('token');\n    data['$distinct_id'] = this._mixpanel.get_distinct_id();\n    var device_id = this._mixpanel.get_property('$device_id');\n    var user_id = this._mixpanel.get_property('$user_id');\n    var had_persisted_distinct_id = this._mixpanel.get_property('$had_persisted_distinct_id');\n    if (device_id) {\n        data['$device_id'] = device_id;\n    }\n    if (user_id) {\n        data['$user_id'] = user_id;\n    }\n    if (had_persisted_distinct_id) {\n        data['$had_persisted_distinct_id'] = had_persisted_distinct_id;\n    }\n\n    var date_encoded_data = _.encodeDates(data);\n\n    if (!this._identify_called()) {\n        this._enqueue(data);\n        if (!_.isUndefined(callback)) {\n            if (this._get_config('verbose')) {\n                callback({status: -1, error: null});\n            } else {\n                callback(-1);\n            }\n        }\n        return _.truncate(date_encoded_data, 255);\n    }\n\n    return this._mixpanel._track_or_batch({\n        type: 'people',\n        data: date_encoded_data,\n        endpoint: this._mixpanel.get_api_host('people') + '/' +  this._get_config('api_routes')['engage'],\n        batcher: this._mixpanel.request_batchers.people\n    }, callback);\n};\n\nMixpanelPeople.prototype._get_config = function(conf_var) {\n    return this._mixpanel.get_config(conf_var);\n};\n\nMixpanelPeople.prototype._identify_called = function() {\n    return this._mixpanel._flags.identify_called === true;\n};\n\n// Queue up engage operations if identify hasn't been called yet.\nMixpanelPeople.prototype._enqueue = function(data) {\n    if (SET_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(SET_ACTION, data);\n    } else if (SET_ONCE_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(SET_ONCE_ACTION, data);\n    } else if (UNSET_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(UNSET_ACTION, data);\n    } else if (ADD_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(ADD_ACTION, data);\n    } else if (APPEND_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(APPEND_ACTION, data);\n    } else if (REMOVE_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(REMOVE_ACTION, data);\n    } else if (UNION_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(UNION_ACTION, data);\n    } else {\n        console$1.error('Invalid call to _enqueue():', data);\n    }\n};\n\nMixpanelPeople.prototype._flush_one_queue = function(action, action_method, callback, queue_to_params_fn) {\n    var _this = this;\n    var queued_data = _.extend({}, this._mixpanel['persistence'].load_queue(action));\n    var action_params = queued_data;\n\n    if (!_.isUndefined(queued_data) && _.isObject(queued_data) && !_.isEmptyObject(queued_data)) {\n        _this._mixpanel['persistence']._pop_from_people_queue(action, queued_data);\n        _this._mixpanel['persistence'].save();\n        if (queue_to_params_fn) {\n            action_params = queue_to_params_fn(queued_data);\n        }\n        action_method.call(_this, action_params, function(response, data) {\n            // on bad response, we want to add it back to the queue\n            if (response === 0) {\n                _this._mixpanel['persistence']._add_to_people_queue(action, queued_data);\n            }\n            if (!_.isUndefined(callback)) {\n                callback(response, data);\n            }\n        });\n    }\n};\n\n// Flush queued engage operations - order does not matter,\n// and there are network level race conditions anyway\nMixpanelPeople.prototype._flush = function(\n    _set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback\n) {\n    var _this = this;\n\n    this._flush_one_queue(SET_ACTION, this.set, _set_callback);\n    this._flush_one_queue(SET_ONCE_ACTION, this.set_once, _set_once_callback);\n    this._flush_one_queue(UNSET_ACTION, this.unset, _unset_callback, function(queue) { return _.keys(queue); });\n    this._flush_one_queue(ADD_ACTION, this.increment, _add_callback);\n    this._flush_one_queue(UNION_ACTION, this.union, _union_callback);\n\n    // we have to fire off each $append individually since there is\n    // no concat method server side\n    var $append_queue = this._mixpanel['persistence'].load_queue(APPEND_ACTION);\n    if (!_.isUndefined($append_queue) && _.isArray($append_queue) && $append_queue.length) {\n        var $append_item;\n        var append_callback = function(response, data) {\n            if (response === 0) {\n                _this._mixpanel['persistence']._add_to_people_queue(APPEND_ACTION, $append_item);\n            }\n            if (!_.isUndefined(_append_callback)) {\n                _append_callback(response, data);\n            }\n        };\n        for (var i = $append_queue.length - 1; i >= 0; i--) {\n            $append_queue = this._mixpanel['persistence'].load_queue(APPEND_ACTION);\n            $append_item = $append_queue.pop();\n            _this._mixpanel['persistence'].save();\n            if (!_.isEmptyObject($append_item)) {\n                _this.append($append_item, append_callback);\n            }\n        }\n    }\n\n    // same for $remove\n    var $remove_queue = this._mixpanel['persistence'].load_queue(REMOVE_ACTION);\n    if (!_.isUndefined($remove_queue) && _.isArray($remove_queue) && $remove_queue.length) {\n        var $remove_item;\n        var remove_callback = function(response, data) {\n            if (response === 0) {\n                _this._mixpanel['persistence']._add_to_people_queue(REMOVE_ACTION, $remove_item);\n            }\n            if (!_.isUndefined(_remove_callback)) {\n                _remove_callback(response, data);\n            }\n        };\n        for (var j = $remove_queue.length - 1; j >= 0; j--) {\n            $remove_queue = this._mixpanel['persistence'].load_queue(REMOVE_ACTION);\n            $remove_item = $remove_queue.pop();\n            _this._mixpanel['persistence'].save();\n            if (!_.isEmptyObject($remove_item)) {\n                _this.remove($remove_item, remove_callback);\n            }\n        }\n    }\n};\n\nMixpanelPeople.prototype._is_reserved_property = function(prop) {\n    return prop === '$distinct_id' || prop === '$token' || prop === '$device_id' || prop === '$user_id' || prop === '$had_persisted_distinct_id';\n};\n\n// MixpanelPeople Exports\nMixpanelPeople.prototype['set']           = MixpanelPeople.prototype.set;\nMixpanelPeople.prototype['set_once']      = MixpanelPeople.prototype.set_once;\nMixpanelPeople.prototype['unset']         = MixpanelPeople.prototype.unset;\nMixpanelPeople.prototype['increment']     = MixpanelPeople.prototype.increment;\nMixpanelPeople.prototype['append']        = MixpanelPeople.prototype.append;\nMixpanelPeople.prototype['remove']        = MixpanelPeople.prototype.remove;\nMixpanelPeople.prototype['union']         = MixpanelPeople.prototype.union;\nMixpanelPeople.prototype['track_charge']  = MixpanelPeople.prototype.track_charge;\nMixpanelPeople.prototype['clear_charges'] = MixpanelPeople.prototype.clear_charges;\nMixpanelPeople.prototype['delete_user']   = MixpanelPeople.prototype.delete_user;\nMixpanelPeople.prototype['toString']      = MixpanelPeople.prototype.toString;\n\n/* eslint camelcase: \"off\" */\n\n\n/*\n * Constants\n */\n/** @const */ var SET_QUEUE_KEY          = '__mps';\n/** @const */ var SET_ONCE_QUEUE_KEY     = '__mpso';\n/** @const */ var UNSET_QUEUE_KEY        = '__mpus';\n/** @const */ var ADD_QUEUE_KEY          = '__mpa';\n/** @const */ var APPEND_QUEUE_KEY       = '__mpap';\n/** @const */ var REMOVE_QUEUE_KEY       = '__mpr';\n/** @const */ var UNION_QUEUE_KEY        = '__mpu';\n// This key is deprecated, but we want to check for it to see whether aliasing is allowed.\n/** @const */ var PEOPLE_DISTINCT_ID_KEY = '$people_distinct_id';\n/** @const */ var ALIAS_ID_KEY           = '__alias';\n/** @const */ var EVENT_TIMERS_KEY       = '__timers';\n/** @const */ var RESERVED_PROPERTIES = [\n    SET_QUEUE_KEY,\n    SET_ONCE_QUEUE_KEY,\n    UNSET_QUEUE_KEY,\n    ADD_QUEUE_KEY,\n    APPEND_QUEUE_KEY,\n    REMOVE_QUEUE_KEY,\n    UNION_QUEUE_KEY,\n    PEOPLE_DISTINCT_ID_KEY,\n    ALIAS_ID_KEY,\n    EVENT_TIMERS_KEY\n];\n\n/**\n * Mixpanel Persistence Object\n * @constructor\n */\nvar MixpanelPersistence = function(config) {\n    this['props'] = {};\n    this.campaign_params_saved = false;\n\n    if (config['persistence_name']) {\n        this.name = 'mp_' + config['persistence_name'];\n    } else {\n        this.name = 'mp_' + config['token'] + '_mixpanel';\n    }\n\n    var storage_type = config['persistence'];\n    if (storage_type !== 'cookie' && storage_type !== 'localStorage') {\n        console$1.critical('Unknown persistence type ' + storage_type + '; falling back to cookie');\n        storage_type = config['persistence'] = 'cookie';\n    }\n\n    if (storage_type === 'localStorage' && _.localStorage.is_supported()) {\n        this.storage = _.localStorage;\n    } else {\n        this.storage = _.cookie;\n    }\n\n    this.load();\n    this.update_config(config);\n    this.upgrade();\n    this.save();\n};\n\nMixpanelPersistence.prototype.properties = function() {\n    var p = {};\n\n    this.load();\n\n    // Filter out reserved properties\n    _.each(this['props'], function(v, k) {\n        if (!_.include(RESERVED_PROPERTIES, k)) {\n            p[k] = v;\n        }\n    });\n    return p;\n};\n\nMixpanelPersistence.prototype.load = function() {\n    if (this.disabled) { return; }\n\n    var entry = this.storage.parse(this.name);\n\n    if (entry) {\n        this['props'] = _.extend({}, entry);\n    }\n};\n\nMixpanelPersistence.prototype.upgrade = function() {\n    var old_cookie,\n        old_localstorage;\n\n    // if transferring from cookie to localStorage or vice-versa, copy existing\n    // super properties over to new storage mode\n    if (this.storage === _.localStorage) {\n        old_cookie = _.cookie.parse(this.name);\n\n        _.cookie.remove(this.name);\n        _.cookie.remove(this.name, true);\n\n        if (old_cookie) {\n            this.register_once(old_cookie);\n        }\n    } else if (this.storage === _.cookie) {\n        old_localstorage = _.localStorage.parse(this.name);\n\n        _.localStorage.remove(this.name);\n\n        if (old_localstorage) {\n            this.register_once(old_localstorage);\n        }\n    }\n};\n\nMixpanelPersistence.prototype.save = function() {\n    if (this.disabled) { return; }\n\n    this.storage.set(\n        this.name,\n        JSONStringify(this['props']),\n        this.expire_days,\n        this.cross_subdomain,\n        this.secure,\n        this.cross_site,\n        this.cookie_domain\n    );\n};\n\nMixpanelPersistence.prototype.load_prop = function(key) {\n    this.load();\n    return this['props'][key];\n};\n\nMixpanelPersistence.prototype.remove = function() {\n    // remove both domain and subdomain cookies\n    this.storage.remove(this.name, false, this.cookie_domain);\n    this.storage.remove(this.name, true, this.cookie_domain);\n};\n\n// removes the storage entry and deletes all loaded data\n// forced name for tests\nMixpanelPersistence.prototype.clear = function() {\n    this.remove();\n    this['props'] = {};\n};\n\n/**\n* @param {Object} props\n* @param {*=} default_value\n* @param {number=} days\n*/\nMixpanelPersistence.prototype.register_once = function(props, default_value, days) {\n    if (_.isObject(props)) {\n        if (typeof(default_value) === 'undefined') { default_value = 'None'; }\n        this.expire_days = (typeof(days) === 'undefined') ? this.default_expiry : days;\n\n        this.load();\n\n        _.each(props, function(val, prop) {\n            if (!this['props'].hasOwnProperty(prop) || this['props'][prop] === default_value) {\n                this['props'][prop] = val;\n            }\n        }, this);\n\n        this.save();\n\n        return true;\n    }\n    return false;\n};\n\n/**\n* @param {Object} props\n* @param {number=} days\n*/\nMixpanelPersistence.prototype.register = function(props, days) {\n    if (_.isObject(props)) {\n        this.expire_days = (typeof(days) === 'undefined') ? this.default_expiry : days;\n\n        this.load();\n        _.extend(this['props'], props);\n        this.save();\n\n        return true;\n    }\n    return false;\n};\n\nMixpanelPersistence.prototype.unregister = function(prop) {\n    this.load();\n    if (prop in this['props']) {\n        delete this['props'][prop];\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.update_search_keyword = function(referrer) {\n    this.register(_.info.searchInfo(referrer));\n};\n\n// EXPORTED METHOD, we test this directly.\nMixpanelPersistence.prototype.update_referrer_info = function(referrer) {\n    // If referrer doesn't exist, we want to note the fact that it was type-in traffic.\n    this.register_once({\n        '$initial_referrer': referrer || '$direct',\n        '$initial_referring_domain': _.info.referringDomain(referrer) || '$direct'\n    }, '');\n};\n\nMixpanelPersistence.prototype.get_referrer_info = function() {\n    return _.strip_empty_properties({\n        '$initial_referrer': this['props']['$initial_referrer'],\n        '$initial_referring_domain': this['props']['$initial_referring_domain']\n    });\n};\n\nMixpanelPersistence.prototype.update_config = function(config) {\n    this.default_expiry = this.expire_days = config['cookie_expiration'];\n    this.set_disabled(config['disable_persistence']);\n    this.set_cookie_domain(config['cookie_domain']);\n    this.set_cross_site(config['cross_site_cookie']);\n    this.set_cross_subdomain(config['cross_subdomain_cookie']);\n    this.set_secure(config['secure_cookie']);\n};\n\nMixpanelPersistence.prototype.set_disabled = function(disabled) {\n    this.disabled = disabled;\n    if (this.disabled) {\n        this.remove();\n    } else {\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.set_cookie_domain = function(cookie_domain) {\n    if (cookie_domain !== this.cookie_domain) {\n        this.remove();\n        this.cookie_domain = cookie_domain;\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.set_cross_site = function(cross_site) {\n    if (cross_site !== this.cross_site) {\n        this.cross_site = cross_site;\n        this.remove();\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.set_cross_subdomain = function(cross_subdomain) {\n    if (cross_subdomain !== this.cross_subdomain) {\n        this.cross_subdomain = cross_subdomain;\n        this.remove();\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.get_cross_subdomain = function() {\n    return this.cross_subdomain;\n};\n\nMixpanelPersistence.prototype.set_secure = function(secure) {\n    if (secure !== this.secure) {\n        this.secure = secure ? true : false;\n        this.remove();\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype._add_to_people_queue = function(queue, data) {\n    var q_key = this._get_queue_key(queue),\n        q_data = data[queue],\n        set_q = this._get_or_create_queue(SET_ACTION),\n        set_once_q = this._get_or_create_queue(SET_ONCE_ACTION),\n        unset_q = this._get_or_create_queue(UNSET_ACTION),\n        add_q = this._get_or_create_queue(ADD_ACTION),\n        union_q = this._get_or_create_queue(UNION_ACTION),\n        remove_q = this._get_or_create_queue(REMOVE_ACTION, []),\n        append_q = this._get_or_create_queue(APPEND_ACTION, []);\n\n    if (q_key === SET_QUEUE_KEY) {\n        // Update the set queue - we can override any existing values\n        _.extend(set_q, q_data);\n        // if there was a pending increment, override it\n        // with the set.\n        this._pop_from_people_queue(ADD_ACTION, q_data);\n        // if there was a pending union, override it\n        // with the set.\n        this._pop_from_people_queue(UNION_ACTION, q_data);\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === SET_ONCE_QUEUE_KEY) {\n        // only queue the data if there is not already a set_once call for it.\n        _.each(q_data, function(v, k) {\n            if (!(k in set_once_q)) {\n                set_once_q[k] = v;\n            }\n        });\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === UNSET_QUEUE_KEY) {\n        _.each(q_data, function(prop) {\n\n            // undo previously-queued actions on this key\n            _.each([set_q, set_once_q, add_q, union_q], function(enqueued_obj) {\n                if (prop in enqueued_obj) {\n                    delete enqueued_obj[prop];\n                }\n            });\n            _.each(append_q, function(append_obj) {\n                if (prop in append_obj) {\n                    delete append_obj[prop];\n                }\n            });\n\n            unset_q[prop] = true;\n\n        });\n    } else if (q_key === ADD_QUEUE_KEY) {\n        _.each(q_data, function(v, k) {\n            // If it exists in the set queue, increment\n            // the value\n            if (k in set_q) {\n                set_q[k] += v;\n            } else {\n                // If it doesn't exist, update the add\n                // queue\n                if (!(k in add_q)) {\n                    add_q[k] = 0;\n                }\n                add_q[k] += v;\n            }\n        }, this);\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === UNION_QUEUE_KEY) {\n        _.each(q_data, function(v, k) {\n            if (_.isArray(v)) {\n                if (!(k in union_q)) {\n                    union_q[k] = [];\n                }\n                // Prevent duplicate values\n                _.each(v, function(item) {\n                    if (!_.include(union_q[k], item)) {\n                        union_q[k].push(item);\n                    }\n                });\n            }\n        });\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === REMOVE_QUEUE_KEY) {\n        remove_q.push(q_data);\n        this._pop_from_people_queue(APPEND_ACTION, q_data);\n    } else if (q_key === APPEND_QUEUE_KEY) {\n        append_q.push(q_data);\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    }\n\n    console$1.log('MIXPANEL PEOPLE REQUEST (QUEUED, PENDING IDENTIFY):');\n    console$1.log(data);\n\n    this.save();\n};\n\nMixpanelPersistence.prototype._pop_from_people_queue = function(queue, data) {\n    var q = this['props'][this._get_queue_key(queue)];\n    if (!_.isUndefined(q)) {\n        _.each(data, function(v, k) {\n            if (queue === APPEND_ACTION || queue === REMOVE_ACTION) {\n                // list actions: only remove if both k+v match\n                // e.g. remove should not override append in a case like\n                // append({foo: 'bar'}); remove({foo: 'qux'})\n                _.each(q, function(queued_action) {\n                    if (queued_action[k] === v) {\n                        delete queued_action[k];\n                    }\n                });\n            } else {\n                delete q[k];\n            }\n        }, this);\n    }\n};\n\nMixpanelPersistence.prototype.load_queue = function(queue) {\n    return this.load_prop(this._get_queue_key(queue));\n};\n\nMixpanelPersistence.prototype._get_queue_key = function(queue) {\n    if (queue === SET_ACTION) {\n        return SET_QUEUE_KEY;\n    } else if (queue === SET_ONCE_ACTION) {\n        return SET_ONCE_QUEUE_KEY;\n    } else if (queue === UNSET_ACTION) {\n        return UNSET_QUEUE_KEY;\n    } else if (queue === ADD_ACTION) {\n        return ADD_QUEUE_KEY;\n    } else if (queue === APPEND_ACTION) {\n        return APPEND_QUEUE_KEY;\n    } else if (queue === REMOVE_ACTION) {\n        return REMOVE_QUEUE_KEY;\n    } else if (queue === UNION_ACTION) {\n        return UNION_QUEUE_KEY;\n    } else {\n        console$1.error('Invalid queue:', queue);\n    }\n};\n\nMixpanelPersistence.prototype._get_or_create_queue = function(queue, default_val) {\n    var key = this._get_queue_key(queue);\n    default_val = _.isUndefined(default_val) ? {} : default_val;\n    return this['props'][key] || (this['props'][key] = default_val);\n};\n\nMixpanelPersistence.prototype.set_event_timer = function(event_name, timestamp) {\n    var timers = this.load_prop(EVENT_TIMERS_KEY) || {};\n    timers[event_name] = timestamp;\n    this['props'][EVENT_TIMERS_KEY] = timers;\n    this.save();\n};\n\nMixpanelPersistence.prototype.remove_event_timer = function(event_name) {\n    var timers = this.load_prop(EVENT_TIMERS_KEY) || {};\n    var timestamp = timers[event_name];\n    if (!_.isUndefined(timestamp)) {\n        delete this['props'][EVENT_TIMERS_KEY][event_name];\n        this.save();\n    }\n    return timestamp;\n};\n\n/* eslint camelcase: \"off\" */\n\n/*\n * Mixpanel JS Library\n *\n * Copyright 2012, Mixpanel, Inc. All Rights Reserved\n * http://mixpanel.com/\n *\n * Includes portions of Underscore.js\n * http://documentcloud.github.com/underscore/\n * (c) 2011 Jeremy Ashkenas, DocumentCloud Inc.\n * Released under the MIT License.\n */\n\n/*\nSIMPLE STYLE GUIDE:\n\nthis.x === public function\nthis._x === internal - only use within this file\nthis.__x === private - only use within the class\n\nGlobals should be all caps\n*/\n\nvar init_type;       // MODULE or SNIPPET loader\n// allow bundlers to specify how extra code (recorder bundle) should be loaded\n// eslint-disable-next-line no-unused-vars\nvar load_extra_bundle = function(src, _onload) {\n    throw new Error(src + ' not available in this build.');\n};\n\nvar mixpanel_master; // main mixpanel instance / object\nvar INIT_MODULE  = 0;\nvar INIT_SNIPPET = 1;\n\nvar IDENTITY_FUNC = function(x) {return x;};\n\n/** @const */ var PRIMARY_INSTANCE_NAME = 'mixpanel';\n/** @const */ var PAYLOAD_TYPE_BASE64   = 'base64';\n/** @const */ var PAYLOAD_TYPE_JSON     = 'json';\n/** @const */ var DEVICE_ID_PREFIX      = '$device:';\n\n\n/*\n * Dynamic... constants? Is that an oxymoron?\n */\n// http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/\n// https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#withCredentials\nvar USE_XHR = (win.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest());\n\n// IE<10 does not support cross-origin XHR's but script tags\n// with defer won't block window.onload; ENQUEUE_REQUESTS\n// should only be true for Opera<12\nvar ENQUEUE_REQUESTS = !USE_XHR && (userAgent.indexOf('MSIE') === -1) && (userAgent.indexOf('Mozilla') === -1);\n\n// save reference to navigator.sendBeacon so it can be minified\nvar sendBeacon = null;\nif (navigator['sendBeacon']) {\n    sendBeacon = function() {\n        // late reference to navigator.sendBeacon to allow patching/spying\n        return navigator['sendBeacon'].apply(navigator, arguments);\n    };\n}\n\nvar DEFAULT_API_ROUTES = {\n    'track':  'track/',\n    'engage': 'engage/',\n    'groups': 'groups/',\n    'record': 'record/',\n    'flags':  'flags/'\n};\n\n/*\n * Module-level globals\n */\nvar DEFAULT_CONFIG = {\n    'api_host':                          'https://api-js.mixpanel.com',\n    'api_hosts':                         {},\n    'api_routes':                        DEFAULT_API_ROUTES,\n    'api_extra_query_params':            {},\n    'api_method':                        'POST',\n    'api_transport':                     'XHR',\n    'api_payload_format':                PAYLOAD_TYPE_BASE64,\n    'app_host':                          'https://mixpanel.com',\n    'autocapture':                       false,\n    'cdn':                               'https://cdn.mxpnl.com',\n    'cross_site_cookie':                 false,\n    'cross_subdomain_cookie':            true,\n    'error_reporter':                    NOOP_FUNC,\n    'flags':                             false,\n    'persistence':                       'cookie',\n    'persistence_name':                  '',\n    'cookie_domain':                     '',\n    'cookie_name':                       '',\n    'loaded':                            NOOP_FUNC,\n    'mp_loader':                         null,\n    'track_marketing':                   true,\n    'track_pageview':                    false,\n    'skip_first_touch_marketing':        false,\n    'store_google':                      true,\n    'stop_utm_persistence':              false,\n    'save_referrer':                     true,\n    'test':                              false,\n    'verbose':                           false,\n    'img':                               false,\n    'debug':                             false,\n    'track_links_timeout':               300,\n    'cookie_expiration':                 365,\n    'upgrade':                           false,\n    'disable_persistence':               false,\n    'disable_cookie':                    false,\n    'secure_cookie':                     false,\n    'ip':                                true,\n    'opt_out_tracking_by_default':       false,\n    'opt_out_persistence_by_default':    false,\n    'opt_out_tracking_persistence_type': 'localStorage',\n    'opt_out_tracking_cookie_prefix':    null,\n    'property_blacklist':                [],\n    'xhr_headers':                       {}, // { header: value, header2: value }\n    'ignore_dnt':                        false,\n    'batch_requests':                    true,\n    'batch_size':                        50,\n    'batch_flush_interval_ms':           5000,\n    'batch_request_timeout_ms':          90000,\n    'batch_autostart':                   true,\n    'hooks':                             {},\n    'record_block_class':                new RegExp('^(mp-block|fs-exclude|amp-block|rr-block|ph-no-capture)$'),\n    'record_block_selector':             'img, video, audio',\n    'record_canvas':                     false,\n    'record_collect_fonts':              false,\n    'record_console':                    true,\n    'record_heatmap_data':               false,\n    'record_idle_timeout_ms':            30 * 60 * 1000, // 30 minutes\n    'record_mask_text_class':            new RegExp('^(mp-mask|fs-mask|amp-mask|rr-mask|ph-mask)$'),\n    'record_mask_text_selector':         '*',\n    'record_max_ms':                     MAX_RECORDING_MS,\n    'record_min_ms':                     0,\n    'record_sessions_percent':           0,\n    'recorder_src':                      'https://cdn.mxpnl.com/libs/mixpanel-recorder.min.js'\n};\n\nvar DOM_LOADED = false;\n\n/**\n * Mixpanel Library Object\n * @constructor\n */\nvar MixpanelLib = function() {};\n\n\n/**\n * create_mplib(token:string, config:object, name:string)\n *\n * This function is used by the init method of MixpanelLib objects\n * as well as the main initializer at the end of the JSLib (that\n * initializes document.mixpanel as well as any additional instances\n * declared before this file has loaded).\n */\nvar create_mplib = function(token, config, name) {\n    var instance,\n        target = (name === PRIMARY_INSTANCE_NAME) ? mixpanel_master : mixpanel_master[name];\n\n    if (target && init_type === INIT_MODULE) {\n        instance = target;\n    } else {\n        if (target && !_.isArray(target)) {\n            console$1.error('You have already initialized ' + name);\n            return;\n        }\n        instance = new MixpanelLib();\n    }\n\n    instance._cached_groups = {}; // cache groups in a pool\n\n    instance._init(token, config, name);\n\n    instance['people'] = new MixpanelPeople();\n    instance['people']._init(instance);\n\n    if (!instance.get_config('skip_first_touch_marketing')) {\n        // We need null UTM params in the object because\n        // UTM parameters act as a tuple. If any UTM param\n        // is present, then we set all UTM params including\n        // empty ones together\n        var utm_params = _.info.campaignParams(null);\n        var initial_utm_params = {};\n        var has_utm = false;\n        _.each(utm_params, function(utm_value, utm_key) {\n            initial_utm_params['initial_' + utm_key] = utm_value;\n            if (utm_value) {\n                has_utm = true;\n            }\n        });\n        if (has_utm) {\n            instance['people'].set_once(initial_utm_params);\n        }\n    }\n\n    // if any instance on the page has debug = true, we set the\n    // global debug to be true\n    Config.DEBUG = Config.DEBUG || instance.get_config('debug');\n\n    // if target is not defined, we called init after the lib already\n    // loaded, so there won't be an array of things to execute\n    if (!_.isUndefined(target) && _.isArray(target)) {\n        // Crunch through the people queue first - we queue this data up &\n        // flush on identify, so it's better to do all these operations first\n        instance._execute_array.call(instance['people'], target['people']);\n        instance._execute_array(target);\n    }\n\n    return instance;\n};\n\n// Initialization methods\n\n/**\n * This function initializes a new instance of the Mixpanel tracking object.\n * All new instances are added to the main mixpanel object as sub properties (such as\n * mixpanel.library_name) and also returned by this function. To define a\n * second instance on the page, you would call:\n *\n *     mixpanel.init('new token', { your: 'config' }, 'library_name');\n *\n * and use it like so:\n *\n *     mixpanel.library_name.track(...);\n *\n * @param {String} token   Your Mixpanel API token\n * @param {Object} [config]  A dictionary of config options to override. <a href=\"https://github.com/mixpanel/mixpanel-js/blob/v2.46.0/src/mixpanel-core.js#L88-L127\">See a list of default config options</a>.\n * @param {String} [name]    The name for the new mixpanel instance that you want created\n */\nMixpanelLib.prototype.init = function (token, config, name) {\n    if (_.isUndefined(name)) {\n        this.report_error('You must name your new library: init(token, config, name)');\n        return;\n    }\n    if (name === PRIMARY_INSTANCE_NAME) {\n        this.report_error('You must initialize the main mixpanel object right after you include the Mixpanel js snippet');\n        return;\n    }\n\n    var instance = create_mplib(token, config, name);\n    mixpanel_master[name] = instance;\n    instance._loaded();\n\n    return instance;\n};\n\n// mixpanel._init(token:string, config:object, name:string)\n//\n// This function sets up the current instance of the mixpanel\n// library.  The difference between this method and the init(...)\n// method is this one initializes the actual instance, whereas the\n// init(...) method sets up a new library and calls _init on it.\n//\nMixpanelLib.prototype._init = function(token, config, name) {\n    config = config || {};\n\n    this['__loaded'] = true;\n    this['config'] = {};\n\n    var variable_features = {};\n\n    // default to JSON payload for standard mixpanel.com API hosts\n    if (!('api_payload_format' in config)) {\n        var api_host = config['api_host'] || DEFAULT_CONFIG['api_host'];\n        if (api_host.match(/\\.mixpanel\\.com/)) {\n            variable_features['api_payload_format'] = PAYLOAD_TYPE_JSON;\n        }\n    }\n\n    this.set_config(_.extend({}, DEFAULT_CONFIG, variable_features, config, {\n        'name': name,\n        'token': token,\n        'callback_fn': ((name === PRIMARY_INSTANCE_NAME) ? name : PRIMARY_INSTANCE_NAME + '.' + name) + '._jsc'\n    }));\n\n    this['_jsc'] = NOOP_FUNC;\n\n    this.__dom_loaded_queue = [];\n    this.__request_queue = [];\n    this.__disabled_events = [];\n    this._flags = {\n        'disable_all_events': false,\n        'identify_called': false\n    };\n\n    // set up request queueing/batching\n    this.request_batchers = {};\n    this._batch_requests = this.get_config('batch_requests');\n    if (this._batch_requests) {\n        if (!_.localStorage.is_supported(true) || !USE_XHR) {\n            this._batch_requests = false;\n            console$1.log('Turning off Mixpanel request-queueing; needs XHR and localStorage support');\n            _.each(this.get_batcher_configs(), function(batcher_config) {\n                console$1.log('Clearing batch queue ' + batcher_config.queue_key);\n                _.localStorage.remove(batcher_config.queue_key);\n            });\n        } else {\n            this.init_batchers();\n            if (sendBeacon && win.addEventListener) {\n                // Before page closes or hides (user tabs away etc), attempt to flush any events\n                // queued up via navigator.sendBeacon. Since sendBeacon doesn't report success/failure,\n                // events will not be removed from the persistent store; if the site is loaded again,\n                // the events will be flushed again on startup and deduplicated on the Mixpanel server\n                // side.\n                // There is no reliable way to capture only page close events, so we lean on the\n                // visibilitychange and pagehide events as recommended at\n                // https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event#usage_notes.\n                // These events fire when the user clicks away from the current page/tab, so will occur\n                // more frequently than page unload, but are the only mechanism currently for capturing\n                // this scenario somewhat reliably.\n                var flush_on_unload = _.bind(function() {\n                    if (!this.request_batchers.events.stopped) {\n                        this.request_batchers.events.flush({unloading: true});\n                    }\n                }, this);\n                win.addEventListener('pagehide', function(ev) {\n                    if (ev['persisted']) {\n                        flush_on_unload();\n                    }\n                });\n                win.addEventListener('visibilitychange', function() {\n                    if (document$1['visibilityState'] === 'hidden') {\n                        flush_on_unload();\n                    }\n                });\n            }\n        }\n    }\n\n    this['persistence'] = this['cookie'] = new MixpanelPersistence(this['config']);\n    this.unpersisted_superprops = {};\n    this._gdpr_init();\n\n    var uuid = _.UUID();\n    if (!this.get_distinct_id()) {\n        // There is no need to set the distinct id\n        // or the device id if something was already stored\n        // in the persitence\n        this.register_once({\n            'distinct_id': DEVICE_ID_PREFIX + uuid,\n            '$device_id': uuid\n        }, '');\n    }\n\n    this.flags = new FeatureFlagManager({\n        getFullApiRoute: _.bind(function() {\n            return this.get_api_host('flags') + '/' + this.get_config('api_routes')['flags'];\n        }, this),\n        getConfigFunc: _.bind(this.get_config, this),\n        setConfigFunc: _.bind(this.set_config, this),\n        getPropertyFunc: _.bind(this.get_property, this),\n        trackingFunc: _.bind(this.track, this)\n    });\n    this.flags.init();\n    this['flags'] = this.flags;\n\n    this.autocapture = new Autocapture(this);\n    this.autocapture.init();\n\n    this._init_tab_id();\n    this._check_and_start_session_recording();\n};\n\n/**\n * Assigns a unique UUID to this tab / window by leveraging sessionStorage.\n * This is primarily used for session recording, where data must be isolated to the current tab.\n */\nMixpanelLib.prototype._init_tab_id = function() {\n    if (this.get_config('disable_persistence')) {\n        console$1.log('Tab ID initialization skipped due to disable_persistence config');\n    } else if (_.sessionStorage.is_supported()) {\n        try {\n            var key_suffix = this.get_config('name') + '_' + this.get_config('token');\n            var tab_id_key = 'mp_tab_id_' + key_suffix;\n\n            // A flag is used to determine if sessionStorage is copied over and we need to generate a new tab ID.\n            // This enforces a unique ID in the cases like duplicated tab, window.open(...)\n            var should_generate_new_tab_id_key = 'mp_gen_new_tab_id_' + key_suffix;\n            if (_.sessionStorage.get(should_generate_new_tab_id_key) || !_.sessionStorage.get(tab_id_key)) {\n                _.sessionStorage.set(tab_id_key, '$tab-' + _.UUID());\n            }\n\n            _.sessionStorage.set(should_generate_new_tab_id_key, '1');\n            this.tab_id = _.sessionStorage.get(tab_id_key);\n\n            // Remove the flag when the tab is unloaded to indicate the stored tab ID can be reused. This event is not reliable to detect all page unloads,\n            // but reliable in cases where the user remains in the tab e.g. a refresh or href navigation.\n            // If the flag is absent, this indicates to the next SDK instance that we can reuse the stored tab_id.\n            win.addEventListener('beforeunload', function () {\n                _.sessionStorage.remove(should_generate_new_tab_id_key);\n            });\n        } catch(err) {\n            this.report_error('Error initializing tab id', err);\n        }\n    } else {\n        this.report_error('Session storage is not supported, cannot keep track of unique tab ID.');\n    }\n};\n\nMixpanelLib.prototype.get_tab_id = function () {\n    return this.tab_id || null;\n};\n\nMixpanelLib.prototype._should_load_recorder = function () {\n    if (this.get_config('disable_persistence')) {\n        console$1.log('Load recorder check skipped due to disable_persistence config');\n        return Promise.resolve(false);\n    }\n\n    var recording_registry_idb = new IDBStorageWrapper(RECORDING_REGISTRY_STORE_NAME);\n    var tab_id = this.get_tab_id();\n    return recording_registry_idb.init()\n        .then(function () {\n            return recording_registry_idb.getAll();\n        })\n        .then(function (recordings) {\n            for (var i = 0; i < recordings.length; i++) {\n                // if there are expired recordings in the registry, we should load the recorder to flush them\n                // if there's a recording for this tab id, we should load the recorder to continue the recording\n                if (isRecordingExpired(recordings[i]) || recordings[i]['tabId'] === tab_id) {\n                    return true;\n                }\n            }\n            return false;\n        })\n        .catch(_.bind(function (err) {\n            this.report_error('Error checking recording registry', err);\n        }, this));\n};\n\nMixpanelLib.prototype._check_and_start_session_recording = addOptOutCheckMixpanelLib(function(force_start) {\n    if (!win['MutationObserver']) {\n        console$1.critical('Browser does not support MutationObserver; skipping session recording');\n        return;\n    }\n\n    var loadRecorder = _.bind(function(startNewIfInactive) {\n        var handleLoadedRecorder = _.bind(function() {\n            this._recorder = this._recorder || new win['__mp_recorder'](this);\n            this._recorder['resumeRecording'](startNewIfInactive);\n        }, this);\n\n        if (_.isUndefined(win['__mp_recorder'])) {\n            load_extra_bundle(this.get_config('recorder_src'), handleLoadedRecorder);\n        } else {\n            handleLoadedRecorder();\n        }\n    }, this);\n\n    /**\n     * If the user is sampled or start_session_recording is called, we always load the recorder since it's guaranteed a recording should start.\n     * Otherwise, if the recording registry has any records then it's likely there's a recording in progress or orphaned data that needs to be flushed.\n     */\n    var is_sampled = this.get_config('record_sessions_percent') > 0 && Math.random() * 100 <= this.get_config('record_sessions_percent');\n    if (force_start || is_sampled) {\n        loadRecorder(true);\n    } else {\n        this._should_load_recorder()\n            .then(function (shouldLoad) {\n                if (shouldLoad) {\n                    loadRecorder(false);\n                }\n            });\n    }\n});\n\nMixpanelLib.prototype.start_session_recording = function () {\n    this._check_and_start_session_recording(true);\n};\n\nMixpanelLib.prototype.stop_session_recording = function () {\n    if (this._recorder) {\n        return this._recorder['stopRecording']();\n    }\n    return Promise.resolve();\n};\n\nMixpanelLib.prototype.pause_session_recording = function () {\n    if (this._recorder) {\n        return this._recorder['pauseRecording']();\n    }\n    return Promise.resolve();\n};\n\nMixpanelLib.prototype.resume_session_recording = function () {\n    if (this._recorder) {\n        return this._recorder['resumeRecording']();\n    }\n    return Promise.resolve();\n};\n\nMixpanelLib.prototype.is_recording_heatmap_data = function () {\n    return this._get_session_replay_id() && this.get_config('record_heatmap_data');\n};\n\nMixpanelLib.prototype.get_session_recording_properties = function () {\n    var props = {};\n    var replay_id = this._get_session_replay_id();\n    if (replay_id) {\n        props['$mp_replay_id'] = replay_id;\n    }\n    return props;\n};\n\nMixpanelLib.prototype.get_session_replay_url = function () {\n    var replay_url = null;\n    var replay_id = this._get_session_replay_id();\n    if (replay_id) {\n        var query_params = _.HTTPBuildQuery({\n            'replay_id': replay_id,\n            'distinct_id': this.get_distinct_id(),\n            'token': this.get_config('token')\n        });\n        replay_url = 'https://mixpanel.com/projects/replay-redirect?' + query_params;\n    }\n    return replay_url;\n};\n\nMixpanelLib.prototype._get_session_replay_id = function () {\n    var replay_id = null;\n    if (this._recorder) {\n        replay_id = this._recorder['replayId'];\n    }\n    return replay_id || null;\n};\n\n// \"private\" public method to reach into the recorder in test cases\nMixpanelLib.prototype.__get_recorder = function () {\n    return this._recorder;\n};\n\n// Private methods\n\nMixpanelLib.prototype._loaded = function() {\n    this.get_config('loaded')(this);\n    this._set_default_superprops();\n    this['people'].set_once(this['persistence'].get_referrer_info());\n\n    // `store_google` is now deprecated and previously stored UTM parameters are cleared\n    // from persistence by default.\n    if (this.get_config('store_google') && this.get_config('stop_utm_persistence')) {\n        var utm_params = _.info.campaignParams(null);\n        _.each(utm_params, function(_utm_value, utm_key) {\n            // We need to unregister persisted UTM parameters so old values\n            // are not mixed with the new UTM parameters\n            this.unregister(utm_key);\n        }.bind(this));\n    }\n};\n\n// update persistence with info on referrer, UTM params, etc\nMixpanelLib.prototype._set_default_superprops = function() {\n    this['persistence'].update_search_keyword(document$1.referrer);\n    // Registering super properties for UTM persistence by 'store_google' is deprecated.\n    if (this.get_config('store_google') && !this.get_config('stop_utm_persistence')) {\n        this.register(_.info.campaignParams());\n    }\n    if (this.get_config('save_referrer')) {\n        this['persistence'].update_referrer_info(document$1.referrer);\n    }\n};\n\nMixpanelLib.prototype._dom_loaded = function() {\n    _.each(this.__dom_loaded_queue, function(item) {\n        this._track_dom.apply(this, item);\n    }, this);\n\n    if (!this.has_opted_out_tracking()) {\n        _.each(this.__request_queue, function(item) {\n            this._send_request.apply(this, item);\n        }, this);\n    }\n\n    delete this.__dom_loaded_queue;\n    delete this.__request_queue;\n};\n\nMixpanelLib.prototype._track_dom = function(DomClass, args) {\n    if (this.get_config('img')) {\n        this.report_error('You can\\'t use DOM tracking functions with img = true.');\n        return false;\n    }\n\n    if (!DOM_LOADED) {\n        this.__dom_loaded_queue.push([DomClass, args]);\n        return false;\n    }\n\n    var dt = new DomClass().init(this);\n    return dt.track.apply(dt, args);\n};\n\n/**\n * _prepare_callback() should be called by callers of _send_request for use\n * as the callback argument.\n *\n * If there is no callback, this returns null.\n * If we are going to make XHR/XDR requests, this returns a function.\n * If we are going to use script tags, this returns a string to use as the\n * callback GET param.\n */\nMixpanelLib.prototype._prepare_callback = function(callback, data) {\n    if (_.isUndefined(callback)) {\n        return null;\n    }\n\n    if (USE_XHR) {\n        var callback_function = function(response) {\n            callback(response, data);\n        };\n        return callback_function;\n    } else {\n        // if the user gives us a callback, we store as a random\n        // property on this instances jsc function and update our\n        // callback string to reflect that.\n        var jsc = this['_jsc'];\n        var randomized_cb = '' + Math.floor(Math.random() * 100000000);\n        var callback_string = this.get_config('callback_fn') + '[' + randomized_cb + ']';\n        jsc[randomized_cb] = function(response) {\n            delete jsc[randomized_cb];\n            callback(response, data);\n        };\n        return callback_string;\n    }\n};\n\nMixpanelLib.prototype._send_request = function(url, data, options, callback) {\n    var succeeded = true;\n\n    if (ENQUEUE_REQUESTS) {\n        this.__request_queue.push(arguments);\n        return succeeded;\n    }\n\n    var DEFAULT_OPTIONS = {\n        method: this.get_config('api_method'),\n        transport: this.get_config('api_transport'),\n        verbose: this.get_config('verbose')\n    };\n    var body_data = null;\n\n    if (!callback && (_.isFunction(options) || typeof options === 'string')) {\n        callback = options;\n        options = null;\n    }\n    options = _.extend(DEFAULT_OPTIONS, options || {});\n    if (!USE_XHR) {\n        options.method = 'GET';\n    }\n    var use_post = options.method === 'POST';\n    var use_sendBeacon = sendBeacon && use_post && options.transport.toLowerCase() === 'sendbeacon';\n\n    // needed to correctly format responses\n    var verbose_mode = options.verbose;\n    if (data['verbose']) { verbose_mode = true; }\n\n    if (this.get_config('test')) { data['test'] = 1; }\n    if (verbose_mode) { data['verbose'] = 1; }\n    if (this.get_config('img')) { data['img'] = 1; }\n    if (!USE_XHR) {\n        if (callback) {\n            data['callback'] = callback;\n        } else if (verbose_mode || this.get_config('test')) {\n            // Verbose output (from verbose mode, or an error in test mode) is a json blob,\n            // which by itself is not valid javascript. Without a callback, this verbose output will\n            // cause an error when returned via jsonp, so we force a no-op callback param.\n            // See the ECMA script spec: http://www.ecma-international.org/ecma-262/5.1/#sec-12.4\n            data['callback'] = '(function(){})';\n        }\n    }\n\n    data['ip'] = this.get_config('ip')?1:0;\n    data['_'] = new Date().getTime().toString();\n\n    if (use_post) {\n        body_data = 'data=' + encodeURIComponent(data['data']);\n        delete data['data'];\n    }\n\n    _.extend(data, this.get_config('api_extra_query_params'));\n\n    url += '?' + _.HTTPBuildQuery(data);\n\n    var lib = this;\n    if ('img' in data) {\n        var img = document$1.createElement('img');\n        img.src = url;\n        document$1.body.appendChild(img);\n    } else if (use_sendBeacon) {\n        try {\n            succeeded = sendBeacon(url, body_data);\n        } catch (e) {\n            lib.report_error(e);\n            succeeded = false;\n        }\n        try {\n            if (callback) {\n                callback(succeeded ? 1 : 0);\n            }\n        } catch (e) {\n            lib.report_error(e);\n        }\n    } else if (USE_XHR) {\n        try {\n            var req = new XMLHttpRequest();\n            req.open(options.method, url, true);\n\n            var headers = this.get_config('xhr_headers');\n            if (use_post) {\n                headers['Content-Type'] = 'application/x-www-form-urlencoded';\n            }\n            _.each(headers, function(headerValue, headerName) {\n                req.setRequestHeader(headerName, headerValue);\n            });\n\n            if (options.timeout_ms && typeof req.timeout !== 'undefined') {\n                req.timeout = options.timeout_ms;\n                var start_time = new Date().getTime();\n            }\n\n            // send the mp_optout cookie\n            // withCredentials cannot be modified until after calling .open on Android and Mobile Safari\n            req.withCredentials = true;\n            req.onreadystatechange = function () {\n                if (req.readyState === 4) { // XMLHttpRequest.DONE == 4, except in safari 4\n                    if (req.status === 200) {\n                        if (callback) {\n                            if (verbose_mode) {\n                                var response;\n                                try {\n                                    response = _.JSONDecode(req.responseText);\n                                } catch (e) {\n                                    lib.report_error(e);\n                                    if (options.ignore_json_errors) {\n                                        response = req.responseText;\n                                    } else {\n                                        return;\n                                    }\n                                }\n                                callback(response);\n                            } else {\n                                callback(Number(req.responseText));\n                            }\n                        }\n                    } else {\n                        var error;\n                        if (\n                            req.timeout &&\n                            !req.status &&\n                            new Date().getTime() - start_time >= req.timeout\n                        ) {\n                            error = 'timeout';\n                        } else {\n                            error = 'Bad HTTP status: ' + req.status + ' ' + req.statusText;\n                        }\n                        lib.report_error(error);\n                        if (callback) {\n                            if (verbose_mode) {\n                                var response_headers = req['responseHeaders'] || {};\n                                callback({status: 0, httpStatusCode: req['status'], error: error, retryAfter: response_headers['Retry-After']});\n                            } else {\n                                callback(0);\n                            }\n                        }\n                    }\n                }\n            };\n            req.send(body_data);\n        } catch (e) {\n            lib.report_error(e);\n            succeeded = false;\n        }\n    } else {\n        var script = document$1.createElement('script');\n        script.type = 'text/javascript';\n        script.async = true;\n        script.defer = true;\n        script.src = url;\n        var s = document$1.getElementsByTagName('script')[0];\n        s.parentNode.insertBefore(script, s);\n    }\n\n    return succeeded;\n};\n\n/**\n * _execute_array() deals with processing any mixpanel function\n * calls that were called before the Mixpanel library were loaded\n * (and are thus stored in an array so they can be called later)\n *\n * Note: we fire off all the mixpanel function calls && user defined\n * functions BEFORE we fire off mixpanel tracking calls. This is so\n * identify/register/set_config calls can properly modify early\n * tracking calls.\n *\n * @param {Array} array\n */\nMixpanelLib.prototype._execute_array = function(array) {\n    var fn_name, alias_calls = [], other_calls = [], tracking_calls = [];\n    _.each(array, function(item) {\n        if (item) {\n            fn_name = item[0];\n            if (_.isArray(fn_name)) {\n                tracking_calls.push(item); // chained call e.g. mixpanel.get_group().set()\n            } else if (typeof(item) === 'function') {\n                item.call(this);\n            } else if (_.isArray(item) && fn_name === 'alias') {\n                alias_calls.push(item);\n            } else if (_.isArray(item) && fn_name.indexOf('track') !== -1 && typeof(this[fn_name]) === 'function') {\n                tracking_calls.push(item);\n            } else {\n                other_calls.push(item);\n            }\n        }\n    }, this);\n\n    var execute = function(calls, context) {\n        _.each(calls, function(item) {\n            if (_.isArray(item[0])) {\n                // chained call\n                var caller = context;\n                _.each(item, function(call) {\n                    caller = caller[call[0]].apply(caller, call.slice(1));\n                });\n            } else {\n                this[item[0]].apply(this, item.slice(1));\n            }\n        }, context);\n    };\n\n    execute(alias_calls, this);\n    execute(other_calls, this);\n    execute(tracking_calls, this);\n};\n\n// request queueing utils\n\nMixpanelLib.prototype.are_batchers_initialized = function() {\n    return !!this.request_batchers.events;\n};\n\nMixpanelLib.prototype.get_batcher_configs = function() {\n    var queue_prefix = '__mpq_' + this.get_config('token');\n    this._batcher_configs = this._batcher_configs || {\n        events: {type: 'events', api_name: 'track', queue_key: queue_prefix + '_ev'},\n        people: {type: 'people', api_name: 'engage', queue_key: queue_prefix + '_pp'},\n        groups: {type: 'groups', api_name: 'groups', queue_key: queue_prefix + '_gr'}\n    };\n    return this._batcher_configs;\n};\n\nMixpanelLib.prototype.init_batchers = function() {\n    if (!this.are_batchers_initialized()) {\n        var batcher_for = _.bind(function(attrs) {\n            return new RequestBatcher(\n                attrs.queue_key,\n                {\n                    libConfig: this['config'],\n                    errorReporter: this.get_config('error_reporter'),\n                    sendRequestFunc: _.bind(function(data, options, cb) {\n                        var api_routes = this.get_config('api_routes');\n                        this._send_request(\n                            this.get_api_host(attrs.api_name) + '/' + api_routes[attrs.api_name],\n                            this._encode_data_for_request(data),\n                            options,\n                            this._prepare_callback(cb, data)\n                        );\n                    }, this),\n                    beforeSendHook: _.bind(function(item) {\n                        return this._run_hook('before_send_' + attrs.type, item);\n                    }, this),\n                    stopAllBatchingFunc: _.bind(this.stop_batch_senders, this),\n                    usePersistence: true,\n                }\n            );\n        }, this);\n        var batcher_configs = this.get_batcher_configs();\n        this.request_batchers = {\n            events: batcher_for(batcher_configs.events),\n            people: batcher_for(batcher_configs.people),\n            groups: batcher_for(batcher_configs.groups)\n        };\n    }\n    if (this.get_config('batch_autostart')) {\n        this.start_batch_senders();\n    }\n};\n\nMixpanelLib.prototype.start_batch_senders = function() {\n    this._batchers_were_started = true;\n    if (this.are_batchers_initialized()) {\n        this._batch_requests = true;\n        _.each(this.request_batchers, function(batcher) {\n            batcher.start();\n        });\n    }\n};\n\nMixpanelLib.prototype.stop_batch_senders = function() {\n    this._batch_requests = false;\n    _.each(this.request_batchers, function(batcher) {\n        batcher.stop();\n        batcher.clear();\n    });\n};\n\n/**\n * push() keeps the standard async-array-push\n * behavior around after the lib is loaded.\n * This is only useful for external integrations that\n * do not wish to rely on our convenience methods\n * (created in the snippet).\n *\n * ### Usage:\n *     mixpanel.push(['register', { a: 'b' }]);\n *\n * @param {Array} item A [function_name, args...] array to be executed\n */\nMixpanelLib.prototype.push = function(item) {\n    this._execute_array([item]);\n};\n\n/**\n * Disable events on the Mixpanel object. If passed no arguments,\n * this function disables tracking of any event. If passed an\n * array of event names, those events will be disabled, but other\n * events will continue to be tracked.\n *\n * Note: this function does not stop other mixpanel functions from\n * firing, such as register() or people.set().\n *\n * @param {Array} [events] An array of event names to disable\n */\nMixpanelLib.prototype.disable = function(events) {\n    if (typeof(events) === 'undefined') {\n        this._flags.disable_all_events = true;\n    } else {\n        this.__disabled_events = this.__disabled_events.concat(events);\n    }\n};\n\nMixpanelLib.prototype._encode_data_for_request = function(data) {\n    var encoded_data = JSONStringify(data);\n    if (this.get_config('api_payload_format') === PAYLOAD_TYPE_BASE64) {\n        encoded_data = _.base64Encode(encoded_data);\n    }\n    return {'data': encoded_data};\n};\n\n// internal method for handling track vs batch-enqueue logic\nMixpanelLib.prototype._track_or_batch = function(options, callback) {\n    var truncated_data = _.truncate(options.data, 255);\n    var endpoint = options.endpoint;\n    var batcher = options.batcher;\n    var should_send_immediately = options.should_send_immediately;\n    var send_request_options = options.send_request_options || {};\n    callback = callback || NOOP_FUNC;\n\n    var request_enqueued_or_initiated = true;\n    var send_request_immediately = _.bind(function() {\n        if (!send_request_options.skip_hooks) {\n            truncated_data = this._run_hook('before_send_' + options.type, truncated_data);\n        }\n        if (truncated_data) {\n            console$1.log('MIXPANEL REQUEST:');\n            console$1.log(truncated_data);\n            return this._send_request(\n                endpoint,\n                this._encode_data_for_request(truncated_data),\n                send_request_options,\n                this._prepare_callback(callback, truncated_data)\n            );\n        } else {\n            return null;\n        }\n    }, this);\n\n    if (this._batch_requests && !should_send_immediately) {\n        batcher.enqueue(truncated_data).then(function(succeeded) {\n            if (succeeded) {\n                callback(1, truncated_data);\n            } else {\n                send_request_immediately();\n            }\n        });\n    } else {\n        request_enqueued_or_initiated = send_request_immediately();\n    }\n\n    return request_enqueued_or_initiated && truncated_data;\n};\n\n/**\n * Track an event. This is the most important and\n * frequently used Mixpanel function.\n *\n * ### Usage:\n *\n *     // track an event named 'Registered'\n *     mixpanel.track('Registered', {'Gender': 'Male', 'Age': 21});\n *\n *     // track an event using navigator.sendBeacon\n *     mixpanel.track('Left page', {'duration_seconds': 35}, {transport: 'sendBeacon'});\n *\n * To track link clicks or form submissions, see track_links() or track_forms().\n *\n * @param {String} event_name The name of the event. This can be anything the user does - 'Button Click', 'Sign Up', 'Item Purchased', etc.\n * @param {Object} [properties] A set of properties to include with the event you're sending. These describe the user who did the event or details about the event itself.\n * @param {Object} [options] Optional configuration for this track request.\n * @param {String} [options.transport] Transport method for network request ('xhr' or 'sendBeacon').\n * @param {Boolean} [options.send_immediately] Whether to bypass batching/queueing and send track request immediately.\n * @param {Function} [callback] If provided, the callback function will be called after tracking the event.\n * @returns {Boolean|Object} If the tracking request was successfully initiated/queued, an object\n * with the tracking payload sent to the API server is returned; otherwise false.\n */\nMixpanelLib.prototype.track = addOptOutCheckMixpanelLib(function(event_name, properties, options, callback) {\n    if (!callback && typeof options === 'function') {\n        callback = options;\n        options = null;\n    }\n    options = options || {};\n    var transport = options['transport']; // external API, don't minify 'transport' prop\n    if (transport) {\n        options.transport = transport; // 'transport' prop name can be minified internally\n    }\n    var should_send_immediately = options['send_immediately'];\n    if (typeof callback !== 'function') {\n        callback = NOOP_FUNC;\n    }\n\n    if (_.isUndefined(event_name)) {\n        this.report_error('No event name provided to mixpanel.track');\n        return;\n    }\n\n    if (this._event_is_disabled(event_name)) {\n        callback(0);\n        return;\n    }\n\n    // set defaults\n    properties = _.extend({}, properties);\n    properties['token'] = this.get_config('token');\n\n    // set $duration if time_event was previously called for this event\n    var start_timestamp = this['persistence'].remove_event_timer(event_name);\n    if (!_.isUndefined(start_timestamp)) {\n        var duration_in_ms = new Date().getTime() - start_timestamp;\n        properties['$duration'] = parseFloat((duration_in_ms / 1000).toFixed(3));\n    }\n\n    this._set_default_superprops();\n\n    var marketing_properties = this.get_config('track_marketing')\n        ? _.info.marketingParams()\n        : {};\n\n    // note: extend writes to the first object, so lets make sure we\n    // don't write to the persistence properties object and info\n    // properties object by passing in a new object\n\n    // update properties with pageview info and super-properties\n    properties = _.extend(\n        {},\n        _.info.properties({'mp_loader': this.get_config('mp_loader')}),\n        marketing_properties,\n        this['persistence'].properties(),\n        this.unpersisted_superprops,\n        this.get_session_recording_properties(),\n        properties\n    );\n\n    var property_blacklist = this.get_config('property_blacklist');\n    if (_.isArray(property_blacklist)) {\n        _.each(property_blacklist, function(blacklisted_prop) {\n            delete properties[blacklisted_prop];\n        });\n    } else {\n        this.report_error('Invalid value for property_blacklist config: ' + property_blacklist);\n    }\n\n    var data = {\n        'event': event_name,\n        'properties': properties\n    };\n    var ret = this._track_or_batch({\n        type: 'events',\n        data: data,\n        endpoint: this.get_api_host('events') + '/' + this.get_config('api_routes')['track'],\n        batcher: this.request_batchers.events,\n        should_send_immediately: should_send_immediately,\n        send_request_options: options\n    }, callback);\n\n    return ret;\n});\n\n/**\n * Register the current user into one/many groups.\n *\n * ### Usage:\n *\n *      mixpanel.set_group('company', ['mixpanel', 'google']) // an array of IDs\n *      mixpanel.set_group('company', 'mixpanel')\n *      mixpanel.set_group('company', 128746312)\n *\n * @param {String} group_key Group key\n * @param {Array|String|Number} group_ids An array of group IDs, or a singular group ID\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n *\n */\nMixpanelLib.prototype.set_group = addOptOutCheckMixpanelLib(function(group_key, group_ids, callback) {\n    if (!_.isArray(group_ids)) {\n        group_ids = [group_ids];\n    }\n    var prop = {};\n    prop[group_key] = group_ids;\n    this.register(prop);\n    return this['people'].set(group_key, group_ids, callback);\n});\n\n/**\n * Add a new group for this user.\n *\n * ### Usage:\n *\n *      mixpanel.add_group('company', 'mixpanel')\n *\n * @param {String} group_key Group key\n * @param {*} group_id A valid Mixpanel property type\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n */\nMixpanelLib.prototype.add_group = addOptOutCheckMixpanelLib(function(group_key, group_id, callback) {\n    var old_values = this.get_property(group_key);\n    var prop = {};\n    if (old_values === undefined) {\n        prop[group_key] = [group_id];\n        this.register(prop);\n    } else {\n        if (old_values.indexOf(group_id) === -1) {\n            old_values.push(group_id);\n            prop[group_key] = old_values;\n            this.register(prop);\n        }\n    }\n    return this['people'].union(group_key, group_id, callback);\n});\n\n/**\n * Remove a group from this user.\n *\n * ### Usage:\n *\n *      mixpanel.remove_group('company', 'mixpanel')\n *\n * @param {String} group_key Group key\n * @param {*} group_id A valid Mixpanel property type\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n */\nMixpanelLib.prototype.remove_group = addOptOutCheckMixpanelLib(function(group_key, group_id, callback) {\n    var old_value = this.get_property(group_key);\n    // if the value doesn't exist, the persistent store is unchanged\n    if (old_value !== undefined) {\n        var idx = old_value.indexOf(group_id);\n        if (idx > -1) {\n            old_value.splice(idx, 1);\n            this.register({group_key: old_value});\n        }\n        if (old_value.length === 0) {\n            this.unregister(group_key);\n        }\n    }\n    return this['people'].remove(group_key, group_id, callback);\n});\n\n/**\n * Track an event with specific groups.\n *\n * ### Usage:\n *\n *      mixpanel.track_with_groups('purchase', {'product': 'iphone'}, {'University': ['UCB', 'UCLA']})\n *\n * @param {String} event_name The name of the event (see `mixpanel.track()`)\n * @param {Object=} properties A set of properties to include with the event you're sending (see `mixpanel.track()`)\n * @param {Object=} groups An object mapping group name keys to one or more values\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n */\nMixpanelLib.prototype.track_with_groups = addOptOutCheckMixpanelLib(function(event_name, properties, groups, callback) {\n    var tracking_props = _.extend({}, properties || {});\n    _.each(groups, function(v, k) {\n        if (v !== null && v !== undefined) {\n            tracking_props[k] = v;\n        }\n    });\n    return this.track(event_name, tracking_props, callback);\n});\n\nMixpanelLib.prototype._create_map_key = function (group_key, group_id) {\n    return group_key + '_' + JSON.stringify(group_id);\n};\n\nMixpanelLib.prototype._remove_group_from_cache = function (group_key, group_id) {\n    delete this._cached_groups[this._create_map_key(group_key, group_id)];\n};\n\n/**\n * Look up reference to a Mixpanel group\n *\n * ### Usage:\n *\n *       mixpanel.get_group(group_key, group_id)\n *\n * @param {String} group_key Group key\n * @param {Object} group_id A valid Mixpanel property type\n * @returns {Object} A MixpanelGroup identifier\n */\nMixpanelLib.prototype.get_group = function (group_key, group_id) {\n    var map_key = this._create_map_key(group_key, group_id);\n    var group = this._cached_groups[map_key];\n    if (group === undefined || group._group_key !== group_key || group._group_id !== group_id) {\n        group = new MixpanelGroup();\n        group._init(this, group_key, group_id);\n        this._cached_groups[map_key] = group;\n    }\n    return group;\n};\n\n/**\n * Track a default Mixpanel page view event, which includes extra default event properties to\n * improve page view data.\n *\n * ### Usage:\n *\n *     // track a default $mp_web_page_view event\n *     mixpanel.track_pageview();\n *\n *     // track a page view event with additional event properties\n *     mixpanel.track_pageview({'ab_test_variant': 'card-layout-b'});\n *\n *     // example approach to track page views on different page types as event properties\n *     mixpanel.track_pageview({'page': 'pricing'});\n *     mixpanel.track_pageview({'page': 'homepage'});\n *\n *     // UNCOMMON: Tracking a page view event with a custom event_name option. NOT expected to be used for\n *     // individual pages on the same site or product. Use cases for custom event_name may be page\n *     // views on different products or internal applications that are considered completely separate\n *     mixpanel.track_pageview({'page': 'customer-search'}, {'event_name': '[internal] Admin Page View'});\n *\n * ### Notes:\n *\n * The `config.track_pageview` option for <a href=\"#mixpanelinit\">mixpanel.init()</a>\n * may be turned on for tracking page loads automatically.\n *\n *     // track only page loads\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: true});\n *\n *     // track when the URL changes in any manner\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: 'full-url'});\n *\n *     // track when the URL changes, ignoring any changes in the hash part\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: 'url-with-path-and-query-string'});\n *\n *     // track when the path changes, ignoring any query parameter or hash changes\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: 'url-with-path'});\n *\n * @param {Object} [properties] An optional set of additional properties to send with the page view event\n * @param {Object} [options] Page view tracking options\n * @param {String} [options.event_name] - Alternate name for the tracking event\n * @returns {Boolean|Object} If the tracking request was successfully initiated/queued, an object\n * with the tracking payload sent to the API server is returned; otherwise false.\n */\nMixpanelLib.prototype.track_pageview = addOptOutCheckMixpanelLib(function(properties, options) {\n    if (typeof properties !== 'object') {\n        properties = {};\n    }\n    options = options || {};\n    var event_name = options['event_name'] || '$mp_web_page_view';\n\n    var default_page_properties = _.extend(\n        _.info.mpPageViewProperties(),\n        _.info.campaignParams(),\n        _.info.clickParams()\n    );\n\n    var event_properties = _.extend(\n        {},\n        default_page_properties,\n        properties\n    );\n\n    return this.track(event_name, event_properties);\n});\n\n/**\n * Track clicks on a set of document elements. Selector must be a\n * valid query. Elements must exist on the page at the time track_links is called.\n *\n * ### Usage:\n *\n *     // track click for link id #nav\n *     mixpanel.track_links('#nav', 'Clicked Nav Link');\n *\n * ### Notes:\n *\n * This function will wait up to 300 ms for the Mixpanel\n * servers to respond. If they have not responded by that time\n * it will head to the link without ensuring that your event\n * has been tracked.  To configure this timeout please see the\n * set_config() documentation below.\n *\n * If you pass a function in as the properties argument, the\n * function will receive the DOMElement that triggered the\n * event as an argument.  You are expected to return an object\n * from the function; any properties defined on this object\n * will be sent to mixpanel as event properties.\n *\n * @type {Function}\n * @param {Object|String} query A valid DOM query, element or jQuery-esque list\n * @param {String} event_name The name of the event to track\n * @param {Object|Function} [properties] A properties object or function that returns a dictionary of properties when passed a DOMElement\n */\nMixpanelLib.prototype.track_links = function() {\n    return this._track_dom.call(this, LinkTracker, arguments);\n};\n\n/**\n * Track form submissions. Selector must be a valid query.\n *\n * ### Usage:\n *\n *     // track submission for form id 'register'\n *     mixpanel.track_forms('#register', 'Created Account');\n *\n * ### Notes:\n *\n * This function will wait up to 300 ms for the mixpanel\n * servers to respond, if they have not responded by that time\n * it will head to the link without ensuring that your event\n * has been tracked.  To configure this timeout please see the\n * set_config() documentation below.\n *\n * If you pass a function in as the properties argument, the\n * function will receive the DOMElement that triggered the\n * event as an argument.  You are expected to return an object\n * from the function; any properties defined on this object\n * will be sent to mixpanel as event properties.\n *\n * @type {Function}\n * @param {Object|String} query A valid DOM query, element or jQuery-esque list\n * @param {String} event_name The name of the event to track\n * @param {Object|Function} [properties] This can be a set of properties, or a function that returns a set of properties after being passed a DOMElement\n */\nMixpanelLib.prototype.track_forms = function() {\n    return this._track_dom.call(this, FormTracker, arguments);\n};\n\n/**\n * Time an event by including the time between this call and a\n * later 'track' call for the same event in the properties sent\n * with the event.\n *\n * ### Usage:\n *\n *     // time an event named 'Registered'\n *     mixpanel.time_event('Registered');\n *     mixpanel.track('Registered', {'Gender': 'Male', 'Age': 21});\n *\n * When called for a particular event name, the next track call for that event\n * name will include the elapsed time between the 'time_event' and 'track'\n * calls. This value is stored as seconds in the '$duration' property.\n *\n * @param {String} event_name The name of the event.\n */\nMixpanelLib.prototype.time_event = function(event_name) {\n    if (_.isUndefined(event_name)) {\n        this.report_error('No event name provided to mixpanel.time_event');\n        return;\n    }\n\n    if (this._event_is_disabled(event_name)) {\n        return;\n    }\n\n    this['persistence'].set_event_timer(event_name,  new Date().getTime());\n};\n\nvar REGISTER_DEFAULTS = {\n    'persistent': true\n};\n/**\n * Helper to parse options param for register methods, maintaining\n * legacy support for plain \"days\" param instead of options object\n * @param {Number|Object} [days_or_options] 'days' option (Number), or Options object for register methods\n * @returns {Object} options object\n */\nvar options_for_register = function(days_or_options) {\n    var options;\n    if (_.isObject(days_or_options)) {\n        options = days_or_options;\n    } else if (!_.isUndefined(days_or_options)) {\n        options = {'days': days_or_options};\n    } else {\n        options = {};\n    }\n    return _.extend({}, REGISTER_DEFAULTS, options);\n};\n\n/**\n * Register a set of super properties, which are included with all\n * events. This will overwrite previous super property values.\n *\n * ### Usage:\n *\n *     // register 'Gender' as a super property\n *     mixpanel.register({'Gender': 'Female'});\n *\n *     // register several super properties when a user signs up\n *     mixpanel.register({\n *         'Email': 'jdoe@example.com',\n *         'Account Type': 'Free'\n *     });\n *\n *     // register only for the current pageload\n *     mixpanel.register({'Name': 'Pat'}, {persistent: false});\n *\n * @param {Object} properties An associative array of properties to store about the user\n * @param {Number|Object} [days_or_options] Options object or number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.days] - number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.persistent=true] - whether to put in persistent storage (cookie/localStorage)\n */\nMixpanelLib.prototype.register = function(props, days_or_options) {\n    var options = options_for_register(days_or_options);\n    if (options['persistent']) {\n        this['persistence'].register(props, options['days']);\n    } else {\n        _.extend(this.unpersisted_superprops, props);\n    }\n};\n\n/**\n * Register a set of super properties only once. This will not\n * overwrite previous super property values, unlike register().\n *\n * ### Usage:\n *\n *     // register a super property for the first time only\n *     mixpanel.register_once({\n *         'First Login Date': new Date().toISOString()\n *     });\n *\n *     // register once, only for the current pageload\n *     mixpanel.register_once({\n *         'First interaction time': new Date().toISOString()\n *     }, 'None', {persistent: false});\n *\n * ### Notes:\n *\n * If default_value is specified, current super properties\n * with that value will be overwritten.\n *\n * @param {Object} properties An associative array of properties to store about the user\n * @param {*} [default_value] Value to override if already set in super properties (ex: 'False') Default: 'None'\n * @param {Number|Object} [days_or_options] Options object or number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.days] - number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.persistent=true] - whether to put in persistent storage (cookie/localStorage)\n */\nMixpanelLib.prototype.register_once = function(props, default_value, days_or_options) {\n    var options = options_for_register(days_or_options);\n    if (options['persistent']) {\n        this['persistence'].register_once(props, default_value, options['days']);\n    } else {\n        if (typeof(default_value) === 'undefined') {\n            default_value = 'None';\n        }\n        _.each(props, function(val, prop) {\n            if (!this.unpersisted_superprops.hasOwnProperty(prop) || this.unpersisted_superprops[prop] === default_value) {\n                this.unpersisted_superprops[prop] = val;\n            }\n        }, this);\n    }\n};\n\n/**\n * Delete a super property stored with the current user.\n *\n * @param {String} property The name of the super property to remove\n * @param {Object} [options]\n * @param {boolean} [options.persistent=true] - whether to look in persistent storage (cookie/localStorage)\n */\nMixpanelLib.prototype.unregister = function(property, options) {\n    options = options_for_register(options);\n    if (options['persistent']) {\n        this['persistence'].unregister(property);\n    } else {\n        delete this.unpersisted_superprops[property];\n    }\n};\n\nMixpanelLib.prototype._register_single = function(prop, value) {\n    var props = {};\n    props[prop] = value;\n    this.register(props);\n};\n\n/**\n * Identify a user with a unique ID to track user activity across\n * devices, tie a user to their events, and create a user profile.\n * If you never call this method, unique visitors are tracked using\n * a UUID generated the first time they visit the site.\n *\n * Call identify when you know the identity of the current user,\n * typically after login or signup. We recommend against using\n * identify for anonymous visitors to your site.\n *\n * ### Notes:\n * If your project has\n * <a href=\"https://help.mixpanel.com/hc/en-us/articles/360039133851\">ID Merge</a>\n * enabled, the identify method will connect pre- and\n * post-authentication events when appropriate.\n *\n * If your project does not have ID Merge enabled, identify will\n * change the user's local distinct_id to the unique ID you pass.\n * Events tracked prior to authentication will not be connected\n * to the same user identity. If ID Merge is disabled, alias can\n * be used to connect pre- and post-registration events.\n *\n * @param {String} [unique_id] A string that uniquely identifies a user. If not provided, the distinct_id currently in the persistent store (cookie or localStorage) will be used.\n */\nMixpanelLib.prototype.identify = function(\n    new_distinct_id, _set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback\n) {\n    // Optional Parameters\n    //  _set_callback:function  A callback to be run if and when the People set queue is flushed\n    //  _add_callback:function  A callback to be run if and when the People add queue is flushed\n    //  _append_callback:function  A callback to be run if and when the People append queue is flushed\n    //  _set_once_callback:function  A callback to be run if and when the People set_once queue is flushed\n    //  _union_callback:function  A callback to be run if and when the People union queue is flushed\n    //  _unset_callback:function  A callback to be run if and when the People unset queue is flushed\n\n    var previous_distinct_id = this.get_distinct_id();\n    if (new_distinct_id && previous_distinct_id !== new_distinct_id) {\n        // we allow the following condition if previous distinct_id is same as new_distinct_id\n        // so that you can force flush people updates for anonymous profiles.\n        if (typeof new_distinct_id === 'string' && new_distinct_id.indexOf(DEVICE_ID_PREFIX) === 0) {\n            this.report_error('distinct_id cannot have $device: prefix');\n            return -1;\n        }\n        this.register({'$user_id': new_distinct_id});\n    }\n\n    if (!this.get_property('$device_id')) {\n        // The persisted distinct id might not actually be a device id at all\n        // it might be a distinct id of the user from before\n        var device_id = previous_distinct_id;\n        this.register_once({\n            '$had_persisted_distinct_id': true,\n            '$device_id': device_id\n        }, '');\n    }\n\n    // identify only changes the distinct id if it doesn't match either the existing or the alias;\n    // if it's new, blow away the alias as well.\n    if (new_distinct_id !== previous_distinct_id && new_distinct_id !== this.get_property(ALIAS_ID_KEY)) {\n        this.unregister(ALIAS_ID_KEY);\n        this.register({'distinct_id': new_distinct_id});\n    }\n    this._flags.identify_called = true;\n    // Flush any queued up people requests\n    this['people']._flush(_set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback);\n\n    // send an $identify event any time the distinct_id is changing - logic on the server\n    // will determine whether or not to do anything with it.\n    if (new_distinct_id !== previous_distinct_id) {\n        this.track('$identify', {\n            'distinct_id': new_distinct_id,\n            '$anon_distinct_id': previous_distinct_id\n        }, {skip_hooks: true});\n    }\n\n    // check feature flags again if distinct id has changed\n    if (new_distinct_id !== previous_distinct_id) {\n        this.flags.fetchFlags();\n    }\n};\n\n/**\n * Clears super properties and generates a new random distinct_id for this instance.\n * Useful for clearing data when a user logs out.\n */\nMixpanelLib.prototype.reset = function() {\n    this.stop_session_recording();\n    this['persistence'].clear();\n    this._flags.identify_called = false;\n    var uuid = _.UUID();\n    this.register_once({\n        'distinct_id': DEVICE_ID_PREFIX + uuid,\n        '$device_id': uuid\n    }, '');\n    this._check_and_start_session_recording();\n};\n\n/**\n * Returns the current distinct id of the user. This is either the id automatically\n * generated by the library or the id that has been passed by a call to identify().\n *\n * ### Notes:\n *\n * get_distinct_id() can only be called after the Mixpanel library has finished loading.\n * init() has a loaded function available to handle this automatically. For example:\n *\n *     // set distinct_id after the mixpanel library has loaded\n *     mixpanel.init('YOUR PROJECT TOKEN', {\n *         loaded: function(mixpanel) {\n *             distinct_id = mixpanel.get_distinct_id();\n *         }\n *     });\n */\nMixpanelLib.prototype.get_distinct_id = function() {\n    return this.get_property('distinct_id');\n};\n\n/**\n * The alias method creates an alias which Mixpanel will use to\n * remap one id to another. Multiple aliases can point to the\n * same identifier.\n *\n * The following is a valid use of alias:\n *\n *     mixpanel.alias('new_id', 'existing_id');\n *     // You can add multiple id aliases to the existing ID\n *     mixpanel.alias('newer_id', 'existing_id');\n *\n * Aliases can also be chained - the following is a valid example:\n *\n *     mixpanel.alias('new_id', 'existing_id');\n *     // chain newer_id - new_id - existing_id\n *     mixpanel.alias('newer_id', 'new_id');\n *\n * Aliases cannot point to multiple identifiers - the following\n * example will not work:\n *\n *     mixpanel.alias('new_id', 'existing_id');\n *     // this is invalid as 'new_id' already points to 'existing_id'\n *     mixpanel.alias('new_id', 'newer_id');\n *\n * ### Notes:\n *\n * If your project does not have\n * <a href=\"https://help.mixpanel.com/hc/en-us/articles/360039133851\">ID Merge</a>\n * enabled, the best practice is to call alias once when a unique\n * ID is first created for a user (e.g., when a user first registers\n * for an account). Do not use alias multiple times for a single\n * user without ID Merge enabled.\n *\n * @param {String} alias A unique identifier that you want to use for this user in the future.\n * @param {String} [original] The current identifier being used for this user.\n */\nMixpanelLib.prototype.alias = function(alias, original) {\n    // If the $people_distinct_id key exists in persistence, there has been a previous\n    // mixpanel.people.identify() call made for this user. It is VERY BAD to make an alias with\n    // this ID, as it will duplicate users.\n    if (alias === this.get_property(PEOPLE_DISTINCT_ID_KEY)) {\n        this.report_error('Attempting to create alias for existing People user - aborting.');\n        return -2;\n    }\n\n    var _this = this;\n    if (_.isUndefined(original)) {\n        original = this.get_distinct_id();\n    }\n    if (alias !== original) {\n        this._register_single(ALIAS_ID_KEY, alias);\n        return this.track('$create_alias', {\n            'alias': alias,\n            'distinct_id': original\n        }, {\n            skip_hooks: true\n        }, function() {\n            // Flush the people queue\n            _this.identify(alias);\n        });\n    } else {\n        this.report_error('alias matches current distinct_id - skipping api call.');\n        this.identify(alias);\n        return -1;\n    }\n};\n\n/**\n * Provide a string to recognize the user by. The string passed to\n * this method will appear in the Mixpanel Streams product rather\n * than an automatically generated name. Name tags do not have to\n * be unique.\n *\n * This value will only be included in Streams data.\n *\n * @param {String} name_tag A human readable name for the user\n * @deprecated\n */\nMixpanelLib.prototype.name_tag = function(name_tag) {\n    this._register_single('mp_name_tag', name_tag);\n};\n\n/**\n * Update the configuration of a mixpanel library instance.\n *\n * The default config is:\n *\n *     {\n *       // host for requests (customizable for e.g. a local proxy)\n *       api_host: 'https://api-js.mixpanel.com',\n *\n *       // endpoints for different types of requests\n *       api_routes: {\n *         track: 'track/',\n *         engage: 'engage/',\n *         groups: 'groups/',\n *       }\n *\n *       // HTTP method for tracking requests\n *       api_method: 'POST'\n *\n *       // transport for sending requests ('XHR' or 'sendBeacon')\n *       // NB: sendBeacon should only be used for scenarios such as\n *       // page unload where a \"best-effort\" attempt to send is\n *       // acceptable; the sendBeacon API does not support callbacks\n *       // or any way to know the result of the request. Mixpanel\n *       // tracking via sendBeacon will not support any event-\n *       // batching or retry mechanisms.\n *       api_transport: 'XHR'\n *\n *       // request-batching/queueing/retry\n *       batch_requests: true,\n *\n *       // maximum number of events/updates to send in a single\n *       // network request\n *       batch_size: 50,\n *\n *       // milliseconds to wait between sending batch requests\n *       batch_flush_interval_ms: 5000,\n *\n *       // milliseconds to wait for network responses to batch requests\n *       // before they are considered timed-out and retried\n *       batch_request_timeout_ms: 90000,\n *\n *       // override value for cookie domain, only useful for ensuring\n *       // correct cross-subdomain cookies on unusual domains like\n *       // subdomain.mainsite.avocat.fr; NB this cannot be used to\n *       // set cookies on a different domain than the current origin\n *       cookie_domain: ''\n *\n *       // super properties cookie expiration (in days)\n *       cookie_expiration: 365\n *\n *       // if true, cookie will be set with SameSite=None; Secure\n *       // this is only useful in special situations, like embedded\n *       // 3rd-party iframes that set up a Mixpanel instance\n *       cross_site_cookie: false\n *\n *       // super properties span subdomains\n *       cross_subdomain_cookie: true\n *\n *       // debug mode\n *       debug: false\n *\n *       // if this is true, the mixpanel cookie or localStorage entry\n *       // will be deleted, and no user persistence will take place\n *       disable_persistence: false\n *\n *       // if this is true, Mixpanel will automatically determine\n *       // City, Region and Country data using the IP address of\n *       //the client\n *       ip: true\n *\n *       // opt users out of tracking by this Mixpanel instance by default\n *       opt_out_tracking_by_default: false\n *\n *       // opt users out of browser data storage by this Mixpanel instance by default\n *       opt_out_persistence_by_default: false\n *\n *       // persistence mechanism used by opt-in/opt-out methods - cookie\n *       // or localStorage - falls back to cookie if localStorage is unavailable\n *       opt_out_tracking_persistence_type: 'localStorage'\n *\n *       // customize the name of cookie/localStorage set by opt-in/opt-out methods\n *       opt_out_tracking_cookie_prefix: null\n *\n *       // type of persistent store for super properties (cookie/\n *       // localStorage) if set to 'localStorage', any existing\n *       // mixpanel cookie value with the same persistence_name\n *       // will be transferred to localStorage and deleted\n *       persistence: 'cookie'\n *\n *       // name for super properties persistent store\n *       persistence_name: ''\n *\n *       // names of properties/superproperties which should never\n *       // be sent with track() calls\n *       property_blacklist: []\n *\n *       // if this is true, mixpanel cookies will be marked as\n *       // secure, meaning they will only be transmitted over https\n *       secure_cookie: false\n *\n *       // disables enriching user profiles with first touch marketing data\n *       skip_first_touch_marketing: false\n *\n *       // the amount of time track_links will\n *       // wait for Mixpanel's servers to respond\n *       track_links_timeout: 300\n *\n *       // adds any UTM parameters and click IDs present on the page to any events fired\n *       track_marketing: true\n *\n *       // enables automatic page view tracking using default page view events through\n *       // the track_pageview() method\n *       track_pageview: false\n *\n *       // if you set upgrade to be true, the library will check for\n *       // a cookie from our old js library and import super\n *       // properties from it, then the old cookie is deleted\n *       // The upgrade config option only works in the initialization,\n *       // so make sure you set it when you create the library.\n *       upgrade: false\n *\n *       // extra HTTP request headers to set for each API request, in\n *       // the format {'Header-Name': value}\n *       xhr_headers: {}\n *\n *       // whether to ignore or respect the web browser's Do Not Track setting\n *       ignore_dnt: false\n *     }\n *\n *\n * @param {Object} config A dictionary of new configuration values to update\n */\nMixpanelLib.prototype.set_config = function(config) {\n    if (_.isObject(config)) {\n        _.extend(this['config'], config);\n\n        var new_batch_size = config['batch_size'];\n        if (new_batch_size) {\n            _.each(this.request_batchers, function(batcher) {\n                batcher.resetBatchSize();\n            });\n        }\n\n        if (!this.get_config('persistence_name')) {\n            this['config']['persistence_name'] = this['config']['cookie_name'];\n        }\n        if (!this.get_config('disable_persistence')) {\n            this['config']['disable_persistence'] = this['config']['disable_cookie'];\n        }\n\n        if (this['persistence']) {\n            this['persistence'].update_config(this['config']);\n        }\n        Config.DEBUG = Config.DEBUG || this.get_config('debug');\n\n        if (('autocapture' in config || 'record_heatmap_data' in config) && this.autocapture) {\n            this.autocapture.init();\n        }\n    }\n};\n\n/**\n * returns the current config object for the library.\n */\nMixpanelLib.prototype.get_config = function(prop_name) {\n    return this['config'][prop_name];\n};\n\n/**\n * Fetch a hook function from config, with safe default, and run it\n * against the given arguments\n * @param {string} hook_name which hook to retrieve\n * @returns {any|null} return value of user-provided hook, or null if nothing was returned\n */\nMixpanelLib.prototype._run_hook = function(hook_name) {\n    var ret = (this['config']['hooks'][hook_name] || IDENTITY_FUNC).apply(this, slice.call(arguments, 1));\n    if (typeof ret === 'undefined') {\n        this.report_error(hook_name + ' hook did not return a value');\n        ret = null;\n    }\n    return ret;\n};\n\n/**\n * Returns the value of the super property named property_name. If no such\n * property is set, get_property() will return the undefined value.\n *\n * ### Notes:\n *\n * get_property() can only be called after the Mixpanel library has finished loading.\n * init() has a loaded function available to handle this automatically. For example:\n *\n *     // grab value for 'user_id' after the mixpanel library has loaded\n *     mixpanel.init('YOUR PROJECT TOKEN', {\n *         loaded: function(mixpanel) {\n *             user_id = mixpanel.get_property('user_id');\n *         }\n *     });\n *\n * @param {String} property_name The name of the super property you want to retrieve\n */\nMixpanelLib.prototype.get_property = function(property_name) {\n    return this['persistence'].load_prop([property_name]);\n};\n\n/**\n * Get the API host for a specific endpoint type, falling back to the default api_host if not specified\n *\n * @param {String} endpoint_type The type of endpoint (e.g., \"events\", \"people\", \"groups\")\n * @returns {String} The API host to use for this endpoint\n */\nMixpanelLib.prototype.get_api_host = function(endpoint_type) {\n    return this.get_config('api_hosts')[endpoint_type] || this.get_config('api_host');\n};\n\nMixpanelLib.prototype.toString = function() {\n    var name = this.get_config('name');\n    if (name !== PRIMARY_INSTANCE_NAME) {\n        name = PRIMARY_INSTANCE_NAME + '.' + name;\n    }\n    return name;\n};\n\nMixpanelLib.prototype._event_is_disabled = function(event_name) {\n    return _.isBlockedUA(userAgent) ||\n        this._flags.disable_all_events ||\n        _.include(this.__disabled_events, event_name);\n};\n\n// perform some housekeeping around GDPR opt-in/out state\nMixpanelLib.prototype._gdpr_init = function() {\n    var is_localStorage_requested = this.get_config('opt_out_tracking_persistence_type') === 'localStorage';\n\n    // try to convert opt-in/out cookies to localStorage if possible\n    if (is_localStorage_requested && _.localStorage.is_supported()) {\n        if (!this.has_opted_in_tracking() && this.has_opted_in_tracking({'persistence_type': 'cookie'})) {\n            this.opt_in_tracking({'enable_persistence': false});\n        }\n        if (!this.has_opted_out_tracking() && this.has_opted_out_tracking({'persistence_type': 'cookie'})) {\n            this.opt_out_tracking({'clear_persistence': false});\n        }\n        this.clear_opt_in_out_tracking({\n            'persistence_type': 'cookie',\n            'enable_persistence': false\n        });\n    }\n\n    // check whether the user has already opted out - if so, clear & disable persistence\n    if (this.has_opted_out_tracking()) {\n        this._gdpr_update_persistence({'clear_persistence': true});\n\n    // check whether we should opt out by default\n    // note: we don't clear persistence here by default since opt-out default state is often\n    //       used as an initial state while GDPR information is being collected\n    } else if (!this.has_opted_in_tracking() && (\n        this.get_config('opt_out_tracking_by_default') || _.cookie.get('mp_optout')\n    )) {\n        _.cookie.remove('mp_optout');\n        this.opt_out_tracking({\n            'clear_persistence': this.get_config('opt_out_persistence_by_default')\n        });\n    }\n};\n\n/**\n * Enable or disable persistence based on options\n * only enable/disable if persistence is not already in this state\n * @param {boolean} [options.clear_persistence] If true, will delete all data stored by the sdk in persistence and disable it\n * @param {boolean} [options.enable_persistence] If true, will re-enable sdk persistence\n */\nMixpanelLib.prototype._gdpr_update_persistence = function(options) {\n    var disabled;\n    if (options && options['clear_persistence']) {\n        disabled = true;\n    } else if (options && options['enable_persistence']) {\n        disabled = false;\n    } else {\n        return;\n    }\n\n    if (!this.get_config('disable_persistence') && this['persistence'].disabled !== disabled) {\n        this['persistence'].set_disabled(disabled);\n    }\n\n    if (disabled) {\n        this.stop_batch_senders();\n        this.stop_session_recording();\n    } else {\n        // only start batchers after opt-in if they have previously been started\n        // in order to avoid unintentionally starting up batching for the first time\n        if (this._batchers_were_started) {\n            this.start_batch_senders();\n        }\n    }\n};\n\n// call a base gdpr function after constructing the appropriate token and options args\nMixpanelLib.prototype._gdpr_call_func = function(func, options) {\n    options = _.extend({\n        'track': _.bind(this.track, this),\n        'persistence_type': this.get_config('opt_out_tracking_persistence_type'),\n        'cookie_prefix': this.get_config('opt_out_tracking_cookie_prefix'),\n        'cookie_expiration': this.get_config('cookie_expiration'),\n        'cross_site_cookie': this.get_config('cross_site_cookie'),\n        'cross_subdomain_cookie': this.get_config('cross_subdomain_cookie'),\n        'cookie_domain': this.get_config('cookie_domain'),\n        'secure_cookie': this.get_config('secure_cookie'),\n        'ignore_dnt': this.get_config('ignore_dnt')\n    }, options);\n\n    // check if localStorage can be used for recording opt out status, fall back to cookie if not\n    if (!_.localStorage.is_supported()) {\n        options['persistence_type'] = 'cookie';\n    }\n\n    return func(this.get_config('token'), {\n        track: options['track'],\n        trackEventName: options['track_event_name'],\n        trackProperties: options['track_properties'],\n        persistenceType: options['persistence_type'],\n        persistencePrefix: options['cookie_prefix'],\n        cookieDomain: options['cookie_domain'],\n        cookieExpiration: options['cookie_expiration'],\n        crossSiteCookie: options['cross_site_cookie'],\n        crossSubdomainCookie: options['cross_subdomain_cookie'],\n        secureCookie: options['secure_cookie'],\n        ignoreDnt: options['ignore_dnt']\n    });\n};\n\n/**\n * Opt the user in to data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     // opt user in\n *     mixpanel.opt_in_tracking();\n *\n *     // opt user in with specific event name, properties, cookie configuration\n *     mixpanel.opt_in_tracking({\n *         track_event_name: 'User opted in',\n *         track_event_properties: {\n *             'Email': 'jdoe@example.com'\n *         },\n *         cookie_expiration: 30,\n *         secure_cookie: true\n *     });\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {function} [options.track] Function used for tracking a Mixpanel event to record the opt-in action (default is this Mixpanel instance's track method)\n * @param {string} [options.track_event_name=$opt_in] Event name to be used for tracking the opt-in action\n * @param {Object} [options.track_properties] Set of properties to be tracked along with the opt-in action\n * @param {boolean} [options.enable_persistence=true] If true, will re-enable sdk persistence\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookie_expiration] Number of days until the opt-in cookie expires (overrides value specified in this Mixpanel instance's config)\n * @param {string} [options.cookie_domain] Custom cookie domain (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_site_cookie] Whether the opt-in cookie is set as cross-site-enabled (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_subdomain_cookie] Whether the opt-in cookie is set as cross-subdomain or not (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.secure_cookie] Whether the opt-in cookie is set as secure or not (overrides value specified in this Mixpanel instance's config)\n */\nMixpanelLib.prototype.opt_in_tracking = function(options) {\n    options = _.extend({\n        'enable_persistence': true\n    }, options);\n\n    this._gdpr_call_func(optIn, options);\n    this._gdpr_update_persistence(options);\n};\n\n/**\n * Opt the user out of data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     // opt user out\n *     mixpanel.opt_out_tracking();\n *\n *     // opt user out with different cookie configuration from Mixpanel instance\n *     mixpanel.opt_out_tracking({\n *         cookie_expiration: 30,\n *         secure_cookie: true\n *     });\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {boolean} [options.delete_user=true] If true, will delete the currently identified user's profile and clear all charges after opting the user out\n * @param {boolean} [options.clear_persistence=true] If true, will delete all data stored by the sdk in persistence\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookie_expiration] Number of days until the opt-in cookie expires (overrides value specified in this Mixpanel instance's config)\n * @param {string} [options.cookie_domain] Custom cookie domain (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_site_cookie] Whether the opt-in cookie is set as cross-site-enabled (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_subdomain_cookie] Whether the opt-in cookie is set as cross-subdomain or not (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.secure_cookie] Whether the opt-in cookie is set as secure or not (overrides value specified in this Mixpanel instance's config)\n */\nMixpanelLib.prototype.opt_out_tracking = function(options) {\n    options = _.extend({\n        'clear_persistence': true,\n        'delete_user': true\n    }, options);\n\n    // delete user and clear charges since these methods may be disabled by opt-out\n    if (options['delete_user'] && this['people'] && this['people']._identify_called()) {\n        this['people'].delete_user();\n        this['people'].clear_charges();\n    }\n\n    this._gdpr_call_func(optOut, options);\n    this._gdpr_update_persistence(options);\n};\n\n/**\n * Check whether the user has opted in to data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     var has_opted_in = mixpanel.has_opted_in_tracking();\n *     // use has_opted_in value\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @returns {boolean} current opt-in status\n */\nMixpanelLib.prototype.has_opted_in_tracking = function(options) {\n    return this._gdpr_call_func(hasOptedIn, options);\n};\n\n/**\n * Check whether the user has opted out of data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     var has_opted_out = mixpanel.has_opted_out_tracking();\n *     // use has_opted_out value\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @returns {boolean} current opt-out status\n */\nMixpanelLib.prototype.has_opted_out_tracking = function(options) {\n    return this._gdpr_call_func(hasOptedOut, options);\n};\n\n/**\n * Clear the user's opt in/out status of data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     // clear user's opt-in/out status\n *     mixpanel.clear_opt_in_out_tracking();\n *\n *     // clear user's opt-in/out status with specific cookie configuration - should match\n *     // configuration used when opt_in_tracking/opt_out_tracking methods were called.\n *     mixpanel.clear_opt_in_out_tracking({\n *         cookie_expiration: 30,\n *         secure_cookie: true\n *     });\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {boolean} [options.enable_persistence=true] If true, will re-enable sdk persistence\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookie_expiration] Number of days until the opt-in cookie expires (overrides value specified in this Mixpanel instance's config)\n * @param {string} [options.cookie_domain] Custom cookie domain (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_site_cookie] Whether the opt-in cookie is set as cross-site-enabled (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_subdomain_cookie] Whether the opt-in cookie is set as cross-subdomain or not (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.secure_cookie] Whether the opt-in cookie is set as secure or not (overrides value specified in this Mixpanel instance's config)\n */\nMixpanelLib.prototype.clear_opt_in_out_tracking = function(options) {\n    options = _.extend({\n        'enable_persistence': true\n    }, options);\n\n    this._gdpr_call_func(clearOptInOut, options);\n    this._gdpr_update_persistence(options);\n};\n\nMixpanelLib.prototype.report_error = function(msg, err) {\n    console$1.error.apply(console$1.error, arguments);\n    try {\n        if (!err && !(msg instanceof Error)) {\n            msg = new Error(msg);\n        }\n        this.get_config('error_reporter')(msg, err);\n    } catch(err) {\n        console$1.error(err);\n    }\n};\n\n// EXPORTS (for closure compiler)\n\n// MixpanelLib Exports\nMixpanelLib.prototype['init']                               = MixpanelLib.prototype.init;\nMixpanelLib.prototype['reset']                              = MixpanelLib.prototype.reset;\nMixpanelLib.prototype['disable']                            = MixpanelLib.prototype.disable;\nMixpanelLib.prototype['time_event']                         = MixpanelLib.prototype.time_event;\nMixpanelLib.prototype['track']                              = MixpanelLib.prototype.track;\nMixpanelLib.prototype['track_links']                        = MixpanelLib.prototype.track_links;\nMixpanelLib.prototype['track_forms']                        = MixpanelLib.prototype.track_forms;\nMixpanelLib.prototype['track_pageview']                     = MixpanelLib.prototype.track_pageview;\nMixpanelLib.prototype['register']                           = MixpanelLib.prototype.register;\nMixpanelLib.prototype['register_once']                      = MixpanelLib.prototype.register_once;\nMixpanelLib.prototype['unregister']                         = MixpanelLib.prototype.unregister;\nMixpanelLib.prototype['identify']                           = MixpanelLib.prototype.identify;\nMixpanelLib.prototype['alias']                              = MixpanelLib.prototype.alias;\nMixpanelLib.prototype['name_tag']                           = MixpanelLib.prototype.name_tag;\nMixpanelLib.prototype['set_config']                         = MixpanelLib.prototype.set_config;\nMixpanelLib.prototype['get_config']                         = MixpanelLib.prototype.get_config;\nMixpanelLib.prototype['get_api_host']                       = MixpanelLib.prototype.get_api_host;\nMixpanelLib.prototype['get_property']                       = MixpanelLib.prototype.get_property;\nMixpanelLib.prototype['get_distinct_id']                    = MixpanelLib.prototype.get_distinct_id;\nMixpanelLib.prototype['toString']                           = MixpanelLib.prototype.toString;\nMixpanelLib.prototype['opt_out_tracking']                   = MixpanelLib.prototype.opt_out_tracking;\nMixpanelLib.prototype['opt_in_tracking']                    = MixpanelLib.prototype.opt_in_tracking;\nMixpanelLib.prototype['has_opted_out_tracking']             = MixpanelLib.prototype.has_opted_out_tracking;\nMixpanelLib.prototype['has_opted_in_tracking']              = MixpanelLib.prototype.has_opted_in_tracking;\nMixpanelLib.prototype['clear_opt_in_out_tracking']          = MixpanelLib.prototype.clear_opt_in_out_tracking;\nMixpanelLib.prototype['get_group']                          = MixpanelLib.prototype.get_group;\nMixpanelLib.prototype['set_group']                          = MixpanelLib.prototype.set_group;\nMixpanelLib.prototype['add_group']                          = MixpanelLib.prototype.add_group;\nMixpanelLib.prototype['remove_group']                       = MixpanelLib.prototype.remove_group;\nMixpanelLib.prototype['track_with_groups']                  = MixpanelLib.prototype.track_with_groups;\nMixpanelLib.prototype['start_batch_senders']                = MixpanelLib.prototype.start_batch_senders;\nMixpanelLib.prototype['stop_batch_senders']                 = MixpanelLib.prototype.stop_batch_senders;\nMixpanelLib.prototype['start_session_recording']            = MixpanelLib.prototype.start_session_recording;\nMixpanelLib.prototype['stop_session_recording']             = MixpanelLib.prototype.stop_session_recording;\nMixpanelLib.prototype['pause_session_recording']            = MixpanelLib.prototype.pause_session_recording;\nMixpanelLib.prototype['resume_session_recording']           = MixpanelLib.prototype.resume_session_recording;\nMixpanelLib.prototype['get_session_recording_properties']   = MixpanelLib.prototype.get_session_recording_properties;\nMixpanelLib.prototype['get_session_replay_url']             = MixpanelLib.prototype.get_session_replay_url;\nMixpanelLib.prototype['get_tab_id']                         = MixpanelLib.prototype.get_tab_id;\nMixpanelLib.prototype['DEFAULT_API_ROUTES']                 = DEFAULT_API_ROUTES;\n\n// Exports intended only for testing\nMixpanelLib.prototype['__get_recorder']                     = MixpanelLib.prototype.__get_recorder;\n\n// MixpanelPersistence Exports\nMixpanelPersistence.prototype['properties']            = MixpanelPersistence.prototype.properties;\nMixpanelPersistence.prototype['update_search_keyword'] = MixpanelPersistence.prototype.update_search_keyword;\nMixpanelPersistence.prototype['update_referrer_info']  = MixpanelPersistence.prototype.update_referrer_info;\nMixpanelPersistence.prototype['get_cross_subdomain']   = MixpanelPersistence.prototype.get_cross_subdomain;\nMixpanelPersistence.prototype['clear']                 = MixpanelPersistence.prototype.clear;\n\n\nvar instances = {};\nvar extend_mp = function() {\n    // add all the sub mixpanel instances\n    _.each(instances, function(instance, name) {\n        if (name !== PRIMARY_INSTANCE_NAME) { mixpanel_master[name] = instance; }\n    });\n\n    // add private functions as _\n    mixpanel_master['_'] = _;\n};\n\nvar override_mp_init_func = function() {\n    // we override the snippets init function to handle the case where a\n    // user initializes the mixpanel library after the script loads & runs\n    mixpanel_master['init'] = function(token, config, name) {\n        if (name) {\n            // initialize a sub library\n            if (!mixpanel_master[name]) {\n                mixpanel_master[name] = instances[name] = create_mplib(token, config, name);\n                mixpanel_master[name]._loaded();\n            }\n            return mixpanel_master[name];\n        } else {\n            var instance = mixpanel_master;\n\n            if (instances[PRIMARY_INSTANCE_NAME]) {\n                // main mixpanel lib already initialized\n                instance = instances[PRIMARY_INSTANCE_NAME];\n            } else if (token) {\n                // intialize the main mixpanel lib\n                instance = create_mplib(token, config, PRIMARY_INSTANCE_NAME);\n                instance._loaded();\n                instances[PRIMARY_INSTANCE_NAME] = instance;\n            }\n\n            mixpanel_master = instance;\n            if (init_type === INIT_SNIPPET) {\n                win[PRIMARY_INSTANCE_NAME] = mixpanel_master;\n            }\n            extend_mp();\n        }\n    };\n};\n\nvar add_dom_loaded_handler = function() {\n    // Cross browser DOM Loaded support\n    function dom_loaded_handler() {\n        // function flag since we only want to execute this once\n        if (dom_loaded_handler.done) { return; }\n        dom_loaded_handler.done = true;\n\n        DOM_LOADED = true;\n        ENQUEUE_REQUESTS = false;\n\n        _.each(instances, function(inst) {\n            inst._dom_loaded();\n        });\n    }\n\n    function do_scroll_check() {\n        try {\n            document$1.documentElement.doScroll('left');\n        } catch(e) {\n            setTimeout(do_scroll_check, 1);\n            return;\n        }\n\n        dom_loaded_handler();\n    }\n\n    if (document$1.addEventListener) {\n        if (document$1.readyState === 'complete') {\n            // safari 4 can fire the DOMContentLoaded event before loading all\n            // external JS (including this file). you will see some copypasta\n            // on the internet that checks for 'complete' and 'loaded', but\n            // 'loaded' is an IE thing\n            dom_loaded_handler();\n        } else {\n            document$1.addEventListener('DOMContentLoaded', dom_loaded_handler, false);\n        }\n    } else if (document$1.attachEvent) {\n        // IE\n        document$1.attachEvent('onreadystatechange', dom_loaded_handler);\n\n        // check to make sure we arn't in a frame\n        var toplevel = false;\n        try {\n            toplevel = win.frameElement === null;\n        } catch(e) {\n            // noop\n        }\n\n        if (document$1.documentElement.doScroll && toplevel) {\n            do_scroll_check();\n        }\n    }\n\n    // fallback handler, always will work\n    _.register_event(win, 'load', dom_loaded_handler, true);\n};\n\nfunction init_as_module(bundle_loader) {\n    load_extra_bundle = bundle_loader;\n    init_type = INIT_MODULE;\n    mixpanel_master = new MixpanelLib();\n\n    override_mp_init_func();\n    mixpanel_master['init']();\n    add_dom_loaded_handler();\n\n    return mixpanel_master;\n}\n\n// For loading separate bundles asynchronously via script tag\n// so that we don't load them until they are needed at runtime.\n\n// For builds that have everything in one bundle, no extra work.\nfunction loadNoop (_src, onload) {\n    onload();\n}\n\n/* eslint camelcase: \"off\" */\n\nvar mixpanel = init_as_module(loadNoop);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvbWl4cGFuZWwtYnJvd3Nlci9kaXN0L21peHBhbmVsLm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3QkFBd0IsNkJBQTZCO0FBQ3RFLHFCQUFxQiw2QkFBNkI7QUFDbEQ7QUFDQSx3Q0FBd0MsWUFBWTtBQUNwRDtBQUNBO0FBQ0EsU0FBUztBQUNULGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRztBQUNqRyxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxpQkFBaUI7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsd0RBQXdEO0FBQ3pHLDZEQUE2RCxxQ0FBcUMsc0JBQXNCO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsNEJBQTRCO0FBQzVHO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCxNQUFNO0FBQ04sb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw0QkFBNEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVix1REFBdUQsU0FBUztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw0VEFBNFQsNE1BQTRNO0FBQ3hnQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtUUFBbVEsMktBQTJLO0FBQzlhO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNrQkFBc2tCLHFQQUFxUDtBQUMzekI7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSEFBaUgsNEJBQTRCO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhIQUE4SCw4QkFBOEI7QUFDNUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHlCQUF5QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxjQUFjO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyw0QkFBNEI7QUFDN0g7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxFQUFFO0FBQ2xEO0FBQ0Esb0RBQW9ELEVBQUU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxhQUFhO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsNEJBQTRCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxNQUFNO0FBQ2QsZUFBZSxNQUFNO0FBQ3JCLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsZUFBZTtBQUNyRSwrQ0FBK0M7QUFDL0Msa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QyxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsNEJBQTRCO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsU0FBUztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixtQkFBbUIsTUFBTTtBQUN6QixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4Riw0QkFBNEI7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGFBQWE7QUFDNUY7QUFDQTtBQUNBLG1GQUFtRiw0QkFBNEI7QUFDL0c7QUFDQTtBQUNBLHNGQUFzRiw4QkFBOEI7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsNEJBQTRCO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsMkZBQTJGLGFBQWE7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxtSEFBbUgsYUFBYTtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLDRCQUE0QjtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsNEJBQTRCO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxvRkFBb0YsNEJBQTRCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHNGQUFzRiw4QkFBOEI7QUFDcEg7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsYUFBYTtBQUM1RjtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsNEJBQTRCO0FBQy9HO0FBQ0E7QUFDQSxzRkFBc0YsOEJBQThCO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLDRCQUE0QjtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLHNCQUFzQjtBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0MsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxhQUFhO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxhQUFhO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGNBQWM7QUFDZCx3RkFBd0YsNEJBQTRCO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLDRCQUE0QjtBQUM3RztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDLGdDQUFnQztBQUNoQyxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsNEJBQTRCO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0NBQStDO0FBQzdEO0FBQ0EsZ0NBQWdDO0FBQ2hDLGNBQWM7QUFDZCwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sWUFBWSxJQUFxQztBQUNqRDtBQUNBO0FBQ0EsMkZBQTJGO0FBQzNGLGtCQUFrQjtBQUNsQiwyRkFBMkY7QUFDM0Ysa0JBQWtCO0FBQ2xCLDJGQUEyRjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxvQkFBb0IsSUFBcUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1Riw0QkFBNEI7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1Riw0QkFBNEI7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HLDhCQUE4QjtBQUNsSTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLDRCQUE0QjtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsNEJBQTRCO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLDRCQUE0QjtBQUM5RztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Qsb0JBQW9CLElBQXFDO0FBQ3pEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRiw0QkFBNEI7QUFDaEg7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxhQUFhO0FBQ2I7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxhQUFhO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGFBQWE7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPLGFBQWEsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxjQUFjO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyw0QkFBNEI7QUFDN0g7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxFQUFFO0FBQ2xEO0FBQ0Esb0RBQW9ELEVBQUU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxhQUFhO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsNEJBQTRCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxNQUFNO0FBQ2QsZUFBZSxNQUFNO0FBQ3JCLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsZUFBZTtBQUNyRSwrQ0FBK0M7QUFDL0Msa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QyxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsNEJBQTRCO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsU0FBUztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixtQkFBbUIsTUFBTTtBQUN6QixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4Riw0QkFBNEI7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGFBQWE7QUFDNUY7QUFDQTtBQUNBLG1GQUFtRiw0QkFBNEI7QUFDL0c7QUFDQTtBQUNBLHNGQUFzRiw4QkFBOEI7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsNEJBQTRCO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsMkZBQTJGLGFBQWE7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxtSEFBbUgsYUFBYTtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLDRCQUE0QjtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsNEJBQTRCO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxvRkFBb0YsNEJBQTRCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHNGQUFzRiw4QkFBOEI7QUFDcEg7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsYUFBYTtBQUM1RjtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsNEJBQTRCO0FBQy9HO0FBQ0E7QUFDQSxzRkFBc0YsOEJBQThCO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLDRCQUE0QjtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekMscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxhQUFhO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxhQUFhO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGNBQWM7QUFDZCx3RkFBd0YsNEJBQTRCO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLDRCQUE0QjtBQUM3RztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDLGdDQUFnQztBQUNoQyxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsNEJBQTRCO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0NBQStDO0FBQzdEO0FBQ0EsZ0NBQWdDO0FBQ2hDLGNBQWM7QUFDZCwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sWUFBWSxJQUFxQztBQUNqRDtBQUNBO0FBQ0EsMkZBQTJGO0FBQzNGLGtCQUFrQjtBQUNsQiwyRkFBMkY7QUFDM0Ysa0JBQWtCO0FBQ2xCLDJGQUEyRjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxvQkFBb0IsSUFBcUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1Riw0QkFBNEI7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1Riw0QkFBNEI7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HLDhCQUE4QjtBQUNsSTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLDRCQUE0QjtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsNEJBQTRCO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLDRCQUE0QjtBQUM5RztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Qsb0JBQW9CLElBQXFDO0FBQ3pEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRiw0QkFBNEI7QUFDaEg7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxhQUFhO0FBQ2I7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxhQUFhO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGFBQWE7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPLGFBQWEsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxhQUFhO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGFBQWE7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEdBQUc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0JBQWdCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxtQkFBbUI7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0JBQW9CO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZUFBZTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsNEJBQTRCO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRiw4QkFBOEI7QUFDN0g7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qyw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJIQUEySCw0QkFBNEI7QUFDdko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEhBQTBILDhCQUE4QjtBQUN4SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsYUFBYTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUNBQW1DLG9CQUFvQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGFBQWE7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGFBQWE7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGFBQWE7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGFBQWE7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGFBQWE7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGFBQWE7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGFBQWE7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGFBQWE7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGFBQWE7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGFBQWE7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGFBQWE7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGFBQWE7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGFBQWE7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRiw0QkFBNEI7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsNEJBQTRCO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsYUFBYTtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw0QkFBNEI7QUFDMUc7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHLGFBQWE7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixhQUFhO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSw0QkFBNEI7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOLGdEQUFnRDtBQUNoRDtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsNEJBQTRCO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsODJDQUE4MkMsZ0lBQWdJO0FBQzkrQztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLDRCQUE0QjtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvRkFBb0YsNEJBQTRCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsYUFBYTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0QkFBNEI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLDRCQUE0QjtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsdUZBQXVGLDRCQUE0QjtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLGFBQWE7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyQkFBMkI7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCOztBQUUxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxzQ0FBc0M7QUFDcEYsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjs7QUFFMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQztBQUNyQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLElBQUk7QUFDZixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsNkNBQTZDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsdUNBQXVDO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SkFBdUo7QUFDdkoseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxZQUFZO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQsZ0NBQWdDO0FBQ2hDLGlDQUFpQyxNQUFNLDBCQUEwQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6Qix1QkFBdUI7QUFDdkI7QUFDQSw2QkFBNkI7QUFDN0IsMkJBQTJCO0FBQzNCLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLG1DQUFtQztBQUNuQyx5Q0FBeUM7QUFDekM7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0QkFBNEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6QixVQUFVO0FBQ1Y7QUFDQSxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQSxrRkFBa0Y7QUFDbEYsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCLFVBQVU7QUFDVjtBQUNBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCOztBQUVBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLGdCQUFnQjtBQUMvQixlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCO0FBQ3ZEO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFELElBQUk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsV0FBVyxnQ0FBZ0M7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixhQUFhLEdBQUc7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsYUFBYSxHQUFHO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVEscURBQXFEO0FBQ3hFLFdBQVcsU0FBUztBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEOztBQUUzRCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsb0NBQW9DOztBQUVwQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCLG9DQUFvQyx3QkFBd0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2IsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHdCQUF3QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0Qzs7QUFFNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLDBFQUEwRSxXQUFXO0FBQ3JGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EsOEJBQThCO0FBQzlCLGlHQUFpRyxXQUFXO0FBQzVHO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSw4QkFBOEI7QUFDOUIscURBQXFEO0FBQ3JEO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLG1EQUFtRDtBQUM5RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsVUFBVTtBQUN4QixjQUFjLFVBQVU7QUFDeEIsY0FBYyxVQUFVO0FBQ3hCLGNBQWMsVUFBVTtBQUN4QixjQUFjLFNBQVM7QUFDdkI7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMERBQTBEO0FBQzFFO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyx5QkFBeUI7QUFDcEMsYUFBYTtBQUNiO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsU0FBUztBQUNULHNCQUFzQixhQUFhO0FBQ25DLFNBQVM7QUFDVCxLQUFLO0FBQ0wsa0JBQWtCLGdDQUFnQztBQUNsRCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsMkVBQTJFO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRCx5QkFBeUI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLG1EQUFtRDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMscURBQXFEO0FBQ2pHLGNBQWM7QUFDZCw0Q0FBNEMseUJBQXlCO0FBQ3JFLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7OztBQUdBO0FBQ0E7QUFDQSx5QkFBeUIsd0JBQXdCO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLGVBQWU7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsNEJBQTRCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxlQUFlO0FBQzFCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlCQUF5QiwyQ0FBMkM7QUFDcEU7QUFDQSxvQkFBb0IsbUNBQW1DO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsMkJBQTJCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsR0FBRyxTQUFTLEVBQUUsaUJBQWlCLEdBQUcsa0JBQWtCLEVBQUUsT0FBTyxHQUFHLGNBQWMsR0FBRyw4QkFBOEIsR0FBRyx3QkFBd0IsRUFBRSxPQUFPLEdBQUc7QUFDekw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRTtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IscUNBQXFDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcseUNBQXlDO0FBQ3BELGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0NBQWtDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHlCQUF5QixrQ0FBa0M7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsaUNBQWlDO0FBQ3JEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RCw2QkFBNkI7O0FBRTdCOztBQUVBLG9CQUFvQiw2QkFBNkI7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDhCQUE4QjtBQUNsRixtQ0FBbUMsNkRBQTZELGdDQUFnQztBQUNoSSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnREFBZ0Q7QUFDbkYsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGVBQWU7QUFDakUsbUNBQW1DLDJEQUEyRCxpQkFBaUI7QUFDL0csS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHVFQUF1RTs7QUFFdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMEJBQTBCO0FBQzFCLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQiw0QkFBNEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7O0FBRUEsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw0Q0FBNEMsd0JBQXdCO0FBQ3BFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZUFBZTs7QUFFbEQ7QUFDQSw4QkFBOEIseUJBQXlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw4QkFBOEI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDBCQUEwQjtBQUMxQixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFELDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsaURBQWlEO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsdUJBQXVCO0FBQ2hFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2Qyx1QkFBdUI7QUFDcEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEY7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTiwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0I7O0FBRXhCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsR0FBRztBQUNkLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFVBQVUsZUFBZTtBQUN6QixVQUFVLEdBQUc7QUFDYixVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCLFVBQVUsR0FBRztBQUNiLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEIsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLFVBQVUsZUFBZTtBQUN6QixVQUFVLFFBQVE7QUFDbEIsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTiwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCLFVBQVUsR0FBRztBQUNiLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGVBQWU7QUFDekIsVUFBVSxHQUFHO0FBQ2IsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxVQUFVLGVBQWU7QUFDekIsVUFBVSxHQUFHO0FBQ2IsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3QkFBd0I7QUFDbEQsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVGQUF1Rix1QkFBdUI7QUFDOUc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qjs7QUFFekI7O0FBRUE7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxJQUFJO0FBQ2QsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViOztBQUVBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVyxHQUFHLFFBQVEsV0FBVztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDOztBQUVsQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdCQUFnQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsZ0JBQWdCO0FBQzVFO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQixtQ0FBbUM7QUFDbkMsd0JBQXdCO0FBQ3hCLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxvR0FBb0c7QUFDOUksOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtRUFBbUU7QUFDcEYsaUJBQWlCLG9FQUFvRTtBQUNyRixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw0QkFBNEI7QUFDakU7QUFDQTtBQUNBLG9DQUFvQyx1QkFBdUIsR0FBRyx3QkFBd0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFVBQVU7QUFDckIsYUFBYSxnQkFBZ0I7QUFDN0IsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDViwyQkFBMkIsMENBQTBDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEdBQUc7QUFDZCxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELG9CQUFvQixHQUFHLDhCQUE4QjtBQUNyRztBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0Esb0NBQW9DLGtCQUFrQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsbUNBQW1DO0FBQ25FO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCO0FBQ2xELGdDQUFnQyxtQkFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMEJBQTBCLEdBQUcsMkNBQTJDO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHFCQUFxQjtBQUMxRDtBQUNBO0FBQ0EscUNBQXFDLDJCQUEyQjtBQUNoRTtBQUNBO0FBQ0EscUNBQXFDLGlEQUFpRDtBQUN0RjtBQUNBO0FBQ0EscUNBQXFDLGdDQUFnQztBQUNyRTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsZ0JBQWdCO0FBQzdCLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsVUFBVTtBQUNWLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLFVBQVU7QUFDVixXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw0QkFBNEI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1CQUFtQjtBQUNuQixNQUFNO0FBQ047QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQkFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsMEJBQTBCLGNBQWMsR0FBRyxrQkFBa0I7QUFDN0Q7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxlQUFlO0FBQzFCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQkFBK0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHLGlCQUFpQjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5RUFBeUUsNkJBQTZCO0FBQ3RHLGtDQUFrQyw0QkFBNEI7QUFDOUQ7QUFDQSwyRUFBMkUsNkJBQTZCO0FBQ3hHLG1DQUFtQywyQkFBMkI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QywwQkFBMEI7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvbWl4cGFuZWwtYnJvd3Nlci9kaXN0L21peHBhbmVsLm1vZHVsZS5qcz80YzNlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNpbmNlIGVzNiBpbXBvcnRzIGFyZSBzdGF0aWMgYW5kIHdlIHJ1biB1bml0IHRlc3RzIGZyb20gdGhlIGNvbnNvbGUsIHdpbmRvdyB3b24ndCBiZSBkZWZpbmVkIHdoZW4gaW1wb3J0aW5nIHRoaXMgZmlsZVxudmFyIHdpbjtcbmlmICh0eXBlb2Yod2luZG93KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgbG9jID0ge1xuICAgICAgICBob3N0bmFtZTogJydcbiAgICB9O1xuICAgIHdpbiA9IHtcbiAgICAgICAgY3J5cHRvOiB7cmFuZG9tVVVJRDogZnVuY3Rpb24oKSB7dGhyb3cgRXJyb3IoJ3Vuc3VwcG9ydGVkJyk7fX0sXG4gICAgICAgIG5hdmlnYXRvcjogeyB1c2VyQWdlbnQ6ICcnLCBvbkxpbmU6IHRydWUgfSxcbiAgICAgICAgZG9jdW1lbnQ6IHtcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4ge307IH0sXG4gICAgICAgICAgICBsb2NhdGlvbjogbG9jLFxuICAgICAgICAgICAgcmVmZXJyZXI6ICcnXG4gICAgICAgIH0sXG4gICAgICAgIHNjcmVlbjogeyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0sXG4gICAgICAgIGxvY2F0aW9uOiBsb2MsXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKCkge30sXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKCkge31cbiAgICB9O1xufSBlbHNlIHtcbiAgICB3aW4gPSB3aW5kb3c7XG59XG5cbmZ1bmN0aW9uIF9hcnJheV9saWtlX3RvX2FycmF5KGFyciwgbGVuKSB7XG4gICAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgZm9yKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspYXJyMltpXSA9IGFycltpXTtcbiAgICByZXR1cm4gYXJyMjtcbn1cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgICB9XG59XG5mdW5jdGlvbiBfYXN5bmNfdG9fZ2VuZXJhdG9yKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgIGlmIChfaXNfbmF0aXZlX3JlZmxlY3RfY29uc3RydWN0KCkpIHtcbiAgICAgICAgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBjb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgICAgICAgdmFyIGEgPSBbXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGEucHVzaC5hcHBseShhLCBhcmdzKTtcbiAgICAgICAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgICAgICAgaWYgKENsYXNzKSBfc2V0X3Byb3RvdHlwZV9vZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVfY2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gICAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IodmFyIGtleSBpbiBzb3VyY2Upe1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcbiAgICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9nZXRfcHJvdG90eXBlX29mKG8pIHtcbiAgICBfZ2V0X3Byb3RvdHlwZV9vZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0X3Byb3RvdHlwZV9vZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldF9wcm90b3R5cGVfb2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2luc3RhbmNlb2YobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAocmlnaHQgIT0gbnVsbCAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIHJpZ2h0W1N5bWJvbC5oYXNJbnN0YW5jZV0pIHtcbiAgICAgICAgcmV0dXJuICEhcmlnaHRbU3ltYm9sLmhhc0luc3RhbmNlXShsZWZ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbGVmdCBpbnN0YW5jZW9mIHJpZ2h0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9pc19uYXRpdmVfZnVuY3Rpb24oZm4pIHtcbiAgICByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xO1xufVxuZnVuY3Rpb24gX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICAgIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICAgIHZhciB0YXJnZXQgPSB7fTtcbiAgICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgdmFyIGtleSwgaTtcbiAgICBmb3IoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIF9zZXRfcHJvdG90eXBlX29mKG8sIHApIHtcbiAgICBfc2V0X3Byb3RvdHlwZV9vZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldF9wcm90b3R5cGVfb2YobywgcCk7XG59XG5mdW5jdGlvbiBfdHlwZV9vZihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkX2l0ZXJhYmxlX3RvX2FycmF5KG8sIG1pbkxlbikge1xuICAgIGlmICghbykgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheV9saWtlX3RvX2FycmF5KG8sIG1pbkxlbik7XG4gICAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICAgIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obik7XG4gICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlfbGlrZV90b19hcnJheShvLCBtaW5MZW4pO1xufVxuZnVuY3Rpb24gX3dyYXBfbmF0aXZlX3N1cGVyKENsYXNzKSB7XG4gICAgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDtcbiAgICBfd3JhcF9uYXRpdmVfc3VwZXIgPSBmdW5jdGlvbiB3cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgICAgICAgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNfbmF0aXZlX2Z1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzO1xuICAgICAgICBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7XG4gICAgICAgICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBXcmFwcGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldF9wcm90b3R5cGVfb2YodGhpcykuY29uc3RydWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFdyYXBwZXIsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3NldF9wcm90b3R5cGVfb2YoV3JhcHBlciwgQ2xhc3MpO1xuICAgIH07XG4gICAgcmV0dXJuIF93cmFwX25hdGl2ZV9zdXBlcihDbGFzcyk7XG59XG5mdW5jdGlvbiBfaXNfbmF0aXZlX3JlZmxlY3RfY29uc3RydWN0KCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgfSBjYXRjaCAoXykge31cbiAgICByZXR1cm4gKF9pc19uYXRpdmVfcmVmbGVjdF9jb25zdHJ1Y3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgIH0pKCk7XG59XG5mdW5jdGlvbiBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgICB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTtcbiAgICBpZiAoaXQpIHJldHVybiAoaXQgPSBpdC5jYWxsKG8pKS5uZXh0LmJpbmQoaXQpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZF9pdGVyYWJsZV90b19hcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UpIHtcbiAgICAgICAgaWYgKGl0KSBvID0gaXQ7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGkgPj0gby5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG9baSsrXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXFxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5mdW5jdGlvbiBfdHNfZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgZiwgeSwgdCwgZywgXyA9IHtcbiAgICAgICAgbGFiZWw6IDAsXG4gICAgICAgIHNlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdO1xuICAgICAgICAgICAgcmV0dXJuIHRbMV07XG4gICAgICAgIH0sXG4gICAgICAgIHRyeXM6IFtdLFxuICAgICAgICBvcHM6IFtdXG4gICAgfTtcbiAgICByZXR1cm4gZyA9IHtcbiAgICAgICAgbmV4dDogdmVyYigwKSxcbiAgICAgICAgXCJ0aHJvd1wiOiB2ZXJiKDEpLFxuICAgICAgICBcInJldHVyblwiOiB2ZXJiKDIpXG4gICAgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcChbXG4gICAgICAgICAgICAgICAgbixcbiAgICAgICAgICAgICAgICB2XG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlKF8pdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbXG4gICAgICAgICAgICAgICAgb3BbMF0gJiAyLFxuICAgICAgICAgICAgICAgIHQudmFsdWVcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBzd2l0Y2gob3BbMF0pe1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3BbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgICAgICAgICB5ID0gb3BbMV07XG4gICAgICAgICAgICAgICAgICAgIG9wID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIG9wID0gXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCBvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IG9wWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gdFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gdFsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ub3BzLnB1c2gob3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9wID0gW1xuICAgICAgICAgICAgICAgIDYsXG4gICAgICAgICAgICAgICAgZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHkgPSAwO1xuICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICBmID0gdCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCxcbiAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBfdHNfdmFsdWVzKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbyAmJiBvW2krK10sXG4gICAgICAgICAgICAgICAgZG9uZTogIW9cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn1cbnZhciBfX2RlZlByb3AkMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AkMSA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDEob2JqLCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xufTtcbnZhciBfX3B1YmxpY0ZpZWxkJDEgPSBmdW5jdGlvbihvYmosIGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gX19kZWZOb3JtYWxQcm9wJDEob2JqLCAodHlwZW9mIGtleSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihrZXkpKSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbn07XG52YXIgX2E7XG52YXIgX19kZWZQcm9wJDEkMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AkMSQxID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIGtleSBpbiBvYmogPyBfX2RlZlByb3AkMSQxKG9iaiwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbn07XG52YXIgX19wdWJsaWNGaWVsZCQxJDEgPSBmdW5jdGlvbihvYmosIGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gX19kZWZOb3JtYWxQcm9wJDEkMShvYmosICh0eXBlb2Yga2V5ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKGtleSkpICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xufTtcbnZhciBOb2RlVHlwZSQzID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKE5vZGVUeXBlMikge1xuICAgIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJEb2N1bWVudFwiXSA9IDBdID0gXCJEb2N1bWVudFwiO1xuICAgIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJEb2N1bWVudFR5cGVcIl0gPSAxXSA9IFwiRG9jdW1lbnRUeXBlXCI7XG4gICAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkVsZW1lbnRcIl0gPSAyXSA9IFwiRWxlbWVudFwiO1xuICAgIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJUZXh0XCJdID0gM10gPSBcIlRleHRcIjtcbiAgICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiQ0RBVEFcIl0gPSA0XSA9IFwiQ0RBVEFcIjtcbiAgICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiQ29tbWVudFwiXSA9IDVdID0gXCJDb21tZW50XCI7XG4gICAgcmV0dXJuIE5vZGVUeXBlMjtcbn0oTm9kZVR5cGUkMyB8fCB7fSk7XG52YXIgdGVzdGFibGVBY2Nlc3NvcnMkMSA9IHtcbiAgICBOb2RlOiBbXG4gICAgICAgIFwiY2hpbGROb2Rlc1wiLFxuICAgICAgICBcInBhcmVudE5vZGVcIixcbiAgICAgICAgXCJwYXJlbnRFbGVtZW50XCIsXG4gICAgICAgIFwidGV4dENvbnRlbnRcIlxuICAgIF0sXG4gICAgU2hhZG93Um9vdDogW1xuICAgICAgICBcImhvc3RcIixcbiAgICAgICAgXCJzdHlsZVNoZWV0c1wiXG4gICAgXSxcbiAgICBFbGVtZW50OiBbXG4gICAgICAgIFwic2hhZG93Um9vdFwiLFxuICAgICAgICBcInF1ZXJ5U2VsZWN0b3JcIixcbiAgICAgICAgXCJxdWVyeVNlbGVjdG9yQWxsXCJcbiAgICBdLFxuICAgIE11dGF0aW9uT2JzZXJ2ZXI6IFtdXG59O1xudmFyIHRlc3RhYmxlTWV0aG9kcyQxID0ge1xuICAgIE5vZGU6IFtcbiAgICAgICAgXCJjb250YWluc1wiLFxuICAgICAgICBcImdldFJvb3ROb2RlXCJcbiAgICBdLFxuICAgIFNoYWRvd1Jvb3Q6IFtcbiAgICAgICAgXCJnZXRTZWxlY3Rpb25cIlxuICAgIF0sXG4gICAgRWxlbWVudDogW10sXG4gICAgTXV0YXRpb25PYnNlcnZlcjogW1xuICAgICAgICBcImNvbnN0cnVjdG9yXCJcbiAgICBdXG59O1xudmFyIHVudGFpbnRlZEJhc2VQcm90b3R5cGUkMSA9IHt9O1xudmFyIGlzQW5ndWxhclpvbmVQcmVzZW50JDEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gISFnbG9iYWxUaGlzLlpvbmU7XG59O1xuZnVuY3Rpb24gZ2V0VW50YWludGVkUHJvdG90eXBlJDEoa2V5KSB7XG4gICAgaWYgKHVudGFpbnRlZEJhc2VQcm90b3R5cGUkMVtrZXldKSByZXR1cm4gdW50YWludGVkQmFzZVByb3RvdHlwZSQxW2tleV07XG4gICAgdmFyIGRlZmF1bHRPYmogPSBnbG9iYWxUaGlzW2tleV07XG4gICAgdmFyIGRlZmF1bHRQcm90b3R5cGUgPSBkZWZhdWx0T2JqLnByb3RvdHlwZTtcbiAgICB2YXIgYWNjZXNzb3JOYW1lcyA9IGtleSBpbiB0ZXN0YWJsZUFjY2Vzc29ycyQxID8gdGVzdGFibGVBY2Nlc3NvcnMkMVtrZXldIDogdm9pZCAwO1xuICAgIHZhciBpc1VudGFpbnRlZEFjY2Vzc29ycyA9IEJvb2xlYW4oYWNjZXNzb3JOYW1lcyAmJiAvLyBAdHMtZXhwZWN0LWVycm9yIDIzNDVcbiAgICBhY2Nlc3Nvck5hbWVzLmV2ZXJ5KGZ1bmN0aW9uKGFjY2Vzc29yKSB7XG4gICAgICAgIHZhciBfYTIsIF9iO1xuICAgICAgICByZXR1cm4gQm9vbGVhbigoX2IgPSAoX2EyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihkZWZhdWx0UHJvdG90eXBlLCBhY2Nlc3NvcikpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX2IudG9TdHJpbmcoKS5pbmNsdWRlcyhcIltuYXRpdmUgY29kZV1cIikpO1xuICAgIH0pKTtcbiAgICB2YXIgbWV0aG9kTmFtZXMgPSBrZXkgaW4gdGVzdGFibGVNZXRob2RzJDEgPyB0ZXN0YWJsZU1ldGhvZHMkMVtrZXldIDogdm9pZCAwO1xuICAgIHZhciBpc1VudGFpbnRlZE1ldGhvZHMgPSBCb29sZWFuKG1ldGhvZE5hbWVzICYmIG1ldGhvZE5hbWVzLmV2ZXJ5KC8vIEB0cy1leHBlY3QtZXJyb3IgMjM0NVxuICAgIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGRlZmF1bHRQcm90b3R5cGVbbWV0aG9kXSA9PT0gXCJmdW5jdGlvblwiICYmICgoX2EyID0gZGVmYXVsdFByb3RvdHlwZVttZXRob2RdKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnRvU3RyaW5nKCkuaW5jbHVkZXMoXCJbbmF0aXZlIGNvZGVdXCIpKTtcbiAgICB9KSk7XG4gICAgaWYgKGlzVW50YWludGVkQWNjZXNzb3JzICYmIGlzVW50YWludGVkTWV0aG9kcyAmJiAhaXNBbmd1bGFyWm9uZVByZXNlbnQkMSgpKSB7XG4gICAgICAgIHVudGFpbnRlZEJhc2VQcm90b3R5cGUkMVtrZXldID0gZGVmYXVsdE9iai5wcm90b3R5cGU7XG4gICAgICAgIHJldHVybiBkZWZhdWx0T2JqLnByb3RvdHlwZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIGlmcmFtZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWVFbCk7XG4gICAgICAgIHZhciB3aW4gPSBpZnJhbWVFbC5jb250ZW50V2luZG93O1xuICAgICAgICBpZiAoIXdpbikgcmV0dXJuIGRlZmF1bHRPYmoucHJvdG90eXBlO1xuICAgICAgICB2YXIgdW50YWludGVkT2JqZWN0ID0gd2luW2tleV0ucHJvdG90eXBlO1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZUVsKTtcbiAgICAgICAgaWYgKCF1bnRhaW50ZWRPYmplY3QpIHJldHVybiBkZWZhdWx0UHJvdG90eXBlO1xuICAgICAgICByZXR1cm4gdW50YWludGVkQmFzZVByb3RvdHlwZSQxW2tleV0gPSB1bnRhaW50ZWRPYmplY3Q7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFByb3RvdHlwZTtcbiAgICB9XG59XG52YXIgdW50YWludGVkQWNjZXNzb3JDYWNoZSQxID0ge307XG5mdW5jdGlvbiBnZXRVbnRhaW50ZWRBY2Nlc3NvciQxKGtleSwgaW5zdGFuY2UsIGFjY2Vzc29yKSB7XG4gICAgdmFyIF9hMjtcbiAgICB2YXIgY2FjaGVLZXkgPSBrZXkgKyBcIi5cIiArIFN0cmluZyhhY2Nlc3Nvcik7XG4gICAgaWYgKHVudGFpbnRlZEFjY2Vzc29yQ2FjaGUkMVtjYWNoZUtleV0pIHJldHVybiB1bnRhaW50ZWRBY2Nlc3NvckNhY2hlJDFbY2FjaGVLZXldLmNhbGwoaW5zdGFuY2UpO1xuICAgIHZhciB1bnRhaW50ZWRQcm90b3R5cGUgPSBnZXRVbnRhaW50ZWRQcm90b3R5cGUkMShrZXkpO1xuICAgIHZhciB1bnRhaW50ZWRBY2Nlc3NvciA9IChfYTIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHVudGFpbnRlZFByb3RvdHlwZSwgYWNjZXNzb3IpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmdldDtcbiAgICBpZiAoIXVudGFpbnRlZEFjY2Vzc29yKSByZXR1cm4gaW5zdGFuY2VbYWNjZXNzb3JdO1xuICAgIHVudGFpbnRlZEFjY2Vzc29yQ2FjaGUkMVtjYWNoZUtleV0gPSB1bnRhaW50ZWRBY2Nlc3NvcjtcbiAgICByZXR1cm4gdW50YWludGVkQWNjZXNzb3IuY2FsbChpbnN0YW5jZSk7XG59XG52YXIgdW50YWludGVkTWV0aG9kQ2FjaGUkMSA9IHt9O1xuZnVuY3Rpb24gZ2V0VW50YWludGVkTWV0aG9kJDEoa2V5LCBpbnN0YW5jZSwgbWV0aG9kKSB7XG4gICAgdmFyIGNhY2hlS2V5ID0ga2V5ICsgXCIuXCIgKyBTdHJpbmcobWV0aG9kKTtcbiAgICBpZiAodW50YWludGVkTWV0aG9kQ2FjaGUkMVtjYWNoZUtleV0pIHJldHVybiB1bnRhaW50ZWRNZXRob2RDYWNoZSQxW2NhY2hlS2V5XS5iaW5kKGluc3RhbmNlKTtcbiAgICB2YXIgdW50YWludGVkUHJvdG90eXBlID0gZ2V0VW50YWludGVkUHJvdG90eXBlJDEoa2V5KTtcbiAgICB2YXIgdW50YWludGVkTWV0aG9kID0gdW50YWludGVkUHJvdG90eXBlW21ldGhvZF07XG4gICAgaWYgKHR5cGVvZiB1bnRhaW50ZWRNZXRob2QgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGluc3RhbmNlW21ldGhvZF07XG4gICAgdW50YWludGVkTWV0aG9kQ2FjaGUkMVtjYWNoZUtleV0gPSB1bnRhaW50ZWRNZXRob2Q7XG4gICAgcmV0dXJuIHVudGFpbnRlZE1ldGhvZC5iaW5kKGluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIGNoaWxkTm9kZXMkMShuMikge1xuICAgIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvciQxKFwiTm9kZVwiLCBuMiwgXCJjaGlsZE5vZGVzXCIpO1xufVxuZnVuY3Rpb24gcGFyZW50Tm9kZSQxKG4yKSB7XG4gICAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yJDEoXCJOb2RlXCIsIG4yLCBcInBhcmVudE5vZGVcIik7XG59XG5mdW5jdGlvbiBwYXJlbnRFbGVtZW50JDEobjIpIHtcbiAgICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IkMShcIk5vZGVcIiwgbjIsIFwicGFyZW50RWxlbWVudFwiKTtcbn1cbmZ1bmN0aW9uIHRleHRDb250ZW50JDEobjIpIHtcbiAgICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IkMShcIk5vZGVcIiwgbjIsIFwidGV4dENvbnRlbnRcIik7XG59XG5mdW5jdGlvbiBjb250YWlucyQxKG4yLCBvdGhlcikge1xuICAgIHJldHVybiBnZXRVbnRhaW50ZWRNZXRob2QkMShcIk5vZGVcIiwgbjIsIFwiY29udGFpbnNcIikob3RoZXIpO1xufVxuZnVuY3Rpb24gZ2V0Um9vdE5vZGUkMShuMikge1xuICAgIHJldHVybiBnZXRVbnRhaW50ZWRNZXRob2QkMShcIk5vZGVcIiwgbjIsIFwiZ2V0Um9vdE5vZGVcIikoKTtcbn1cbmZ1bmN0aW9uIGhvc3QkMShuMikge1xuICAgIGlmICghbjIgfHwgIShcImhvc3RcIiBpbiBuMikpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvciQxKFwiU2hhZG93Um9vdFwiLCBuMiwgXCJob3N0XCIpO1xufVxuZnVuY3Rpb24gc3R5bGVTaGVldHMkMShuMikge1xuICAgIHJldHVybiBuMi5zdHlsZVNoZWV0cztcbn1cbmZ1bmN0aW9uIHNoYWRvd1Jvb3QkMShuMikge1xuICAgIGlmICghbjIgfHwgIShcInNoYWRvd1Jvb3RcIiBpbiBuMikpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvciQxKFwiRWxlbWVudFwiLCBuMiwgXCJzaGFkb3dSb290XCIpO1xufVxuZnVuY3Rpb24gcXVlcnlTZWxlY3RvciQxKG4yLCBzZWxlY3RvcnMpIHtcbiAgICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IkMShcIkVsZW1lbnRcIiwgbjIsIFwicXVlcnlTZWxlY3RvclwiKShzZWxlY3RvcnMpO1xufVxuZnVuY3Rpb24gcXVlcnlTZWxlY3RvckFsbCQxKG4yLCBzZWxlY3RvcnMpIHtcbiAgICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IkMShcIkVsZW1lbnRcIiwgbjIsIFwicXVlcnlTZWxlY3RvckFsbFwiKShzZWxlY3RvcnMpO1xufVxuZnVuY3Rpb24gbXV0YXRpb25PYnNlcnZlckN0b3IkMSgpIHtcbiAgICByZXR1cm4gZ2V0VW50YWludGVkUHJvdG90eXBlJDEoXCJNdXRhdGlvbk9ic2VydmVyXCIpLmNvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gcGF0Y2gkMShzb3VyY2UsIG5hbWUsIHJlcGxhY2VtZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKCEobmFtZSBpbiBzb3VyY2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7fTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3JpZ2luYWwgPSBzb3VyY2VbbmFtZV07XG4gICAgICAgIHZhciB3cmFwcGVkID0gcmVwbGFjZW1lbnQob3JpZ2luYWwpO1xuICAgICAgICBpZiAodHlwZW9mIHdyYXBwZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgd3JhcHBlZC5wcm90b3R5cGUgPSB3cmFwcGVkLnByb3RvdHlwZSB8fCB7fTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHdyYXBwZWQsIHtcbiAgICAgICAgICAgICAgICBfX3Jyd2ViX29yaWdpbmFsX186IHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvcmlnaW5hbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZVtuYW1lXSA9IHdyYXBwZWQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNvdXJjZVtuYW1lXSA9IG9yaWdpbmFsO1xuICAgICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge307XG4gICAgfVxufVxudmFyIGluZGV4JDEgPSB7XG4gICAgY2hpbGROb2RlczogY2hpbGROb2RlcyQxLFxuICAgIHBhcmVudE5vZGU6IHBhcmVudE5vZGUkMSxcbiAgICBwYXJlbnRFbGVtZW50OiBwYXJlbnRFbGVtZW50JDEsXG4gICAgdGV4dENvbnRlbnQ6IHRleHRDb250ZW50JDEsXG4gICAgY29udGFpbnM6IGNvbnRhaW5zJDEsXG4gICAgZ2V0Um9vdE5vZGU6IGdldFJvb3ROb2RlJDEsXG4gICAgaG9zdDogaG9zdCQxLFxuICAgIHN0eWxlU2hlZXRzOiBzdHlsZVNoZWV0cyQxLFxuICAgIHNoYWRvd1Jvb3Q6IHNoYWRvd1Jvb3QkMSxcbiAgICBxdWVyeVNlbGVjdG9yOiBxdWVyeVNlbGVjdG9yJDEsXG4gICAgcXVlcnlTZWxlY3RvckFsbDogcXVlcnlTZWxlY3RvckFsbCQxLFxuICAgIG11dGF0aW9uT2JzZXJ2ZXI6IG11dGF0aW9uT2JzZXJ2ZXJDdG9yJDEsXG4gICAgcGF0Y2g6IHBhdGNoJDFcbn07XG5mdW5jdGlvbiBpc0VsZW1lbnQobjIpIHtcbiAgICByZXR1cm4gbjIubm9kZVR5cGUgPT09IG4yLkVMRU1FTlRfTk9ERTtcbn1cbmZ1bmN0aW9uIGlzU2hhZG93Um9vdChuMikge1xuICAgIHZhciBob3N0RWwgPSAvLyBhbmNob3IgYW5kIHRleHRhcmVhIGVsZW1lbnRzIGFsc28gaGF2ZSBhIGBob3N0YCBwcm9wZXJ0eVxuICAgIC8vIGJ1dCBvbmx5IHNoYWRvdyByb290cyBoYXZlIGEgYG1vZGVgIHByb3BlcnR5XG4gICAgbjIgJiYgXCJob3N0XCIgaW4gbjIgJiYgXCJtb2RlXCIgaW4gbjIgJiYgaW5kZXgkMS5ob3N0KG4yKSB8fCBudWxsO1xuICAgIHJldHVybiBCb29sZWFuKGhvc3RFbCAmJiBcInNoYWRvd1Jvb3RcIiBpbiBob3N0RWwgJiYgaW5kZXgkMS5zaGFkb3dSb290KGhvc3RFbCkgPT09IG4yKTtcbn1cbmZ1bmN0aW9uIGlzTmF0aXZlU2hhZG93RG9tKHNoYWRvd1Jvb3QyKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzaGFkb3dSb290MikgPT09IFwiW29iamVjdCBTaGFkb3dSb290XVwiO1xufVxuZnVuY3Rpb24gZml4QnJvd3NlckNvbXBhdGliaWxpdHlJc3N1ZXNJbkNTUyhjc3NUZXh0KSB7XG4gICAgaWYgKGNzc1RleHQuaW5jbHVkZXMoXCIgYmFja2dyb3VuZC1jbGlwOiB0ZXh0O1wiKSAmJiAhY3NzVGV4dC5pbmNsdWRlcyhcIiAtd2Via2l0LWJhY2tncm91bmQtY2xpcDogdGV4dDtcIikpIHtcbiAgICAgICAgY3NzVGV4dCA9IGNzc1RleHQucmVwbGFjZSgvXFxzYmFja2dyb3VuZC1jbGlwOlxccyp0ZXh0Oy9nLCBcIiAtd2Via2l0LWJhY2tncm91bmQtY2xpcDogdGV4dDsgYmFja2dyb3VuZC1jbGlwOiB0ZXh0O1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGNzc1RleHQ7XG59XG5mdW5jdGlvbiBlc2NhcGVJbXBvcnRTdGF0ZW1lbnQocnVsZTIpIHtcbiAgICB2YXIgY3NzVGV4dCA9IHJ1bGUyLmNzc1RleHQ7XG4gICAgaWYgKGNzc1RleHQuc3BsaXQoJ1wiJykubGVuZ3RoIDwgMykgcmV0dXJuIGNzc1RleHQ7XG4gICAgdmFyIHN0YXRlbWVudCA9IFtcbiAgICAgICAgXCJAaW1wb3J0XCIsXG4gICAgICAgIFwidXJsKFwiICsgSlNPTi5zdHJpbmdpZnkocnVsZTIuaHJlZikgKyBcIilcIlxuICAgIF07XG4gICAgaWYgKHJ1bGUyLmxheWVyTmFtZSA9PT0gXCJcIikge1xuICAgICAgICBzdGF0ZW1lbnQucHVzaChcImxheWVyXCIpO1xuICAgIH0gZWxzZSBpZiAocnVsZTIubGF5ZXJOYW1lKSB7XG4gICAgICAgIHN0YXRlbWVudC5wdXNoKFwibGF5ZXIoXCIgKyBydWxlMi5sYXllck5hbWUgKyBcIilcIik7XG4gICAgfVxuICAgIGlmIChydWxlMi5zdXBwb3J0c1RleHQpIHtcbiAgICAgICAgc3RhdGVtZW50LnB1c2goXCJzdXBwb3J0cyhcIiArIHJ1bGUyLnN1cHBvcnRzVGV4dCArIFwiKVwiKTtcbiAgICB9XG4gICAgaWYgKHJ1bGUyLm1lZGlhLmxlbmd0aCkge1xuICAgICAgICBzdGF0ZW1lbnQucHVzaChydWxlMi5tZWRpYS5tZWRpYVRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGVtZW50LmpvaW4oXCIgXCIpICsgXCI7XCI7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlTdHlsZXNoZWV0KHMyKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIHJ1bGVzMiA9IHMyLnJ1bGVzIHx8IHMyLmNzc1J1bGVzO1xuICAgICAgICBpZiAoIXJ1bGVzMikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNoZWV0SHJlZiA9IHMyLmhyZWY7XG4gICAgICAgIGlmICghc2hlZXRIcmVmICYmIHMyLm93bmVyTm9kZSAmJiBzMi5vd25lck5vZGUub3duZXJEb2N1bWVudCkge1xuICAgICAgICAgICAgc2hlZXRIcmVmID0gczIub3duZXJOb2RlLm93bmVyRG9jdW1lbnQubG9jYXRpb24uaHJlZjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyaW5naWZpZWRSdWxlcyA9IEFycmF5LmZyb20ocnVsZXMyLCBmdW5jdGlvbihydWxlMikge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeVJ1bGUocnVsZTIsIHNoZWV0SHJlZik7XG4gICAgICAgIH0pLmpvaW4oXCJcIik7XG4gICAgICAgIHJldHVybiBmaXhCcm93c2VyQ29tcGF0aWJpbGl0eUlzc3Vlc0luQ1NTKHN0cmluZ2lmaWVkUnVsZXMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVJ1bGUocnVsZTIsIHNoZWV0SHJlZikge1xuICAgIGlmIChpc0NTU0ltcG9ydFJ1bGUocnVsZTIpKSB7XG4gICAgICAgIHZhciBpbXBvcnRTdHJpbmdpZmllZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGltcG9ydFN0cmluZ2lmaWVkID0gLy8gd2UgY2FuIGFjY2VzcyB0aGUgaW1wb3J0ZWQgc3R5bGVzaGVldCBydWxlcyBkaXJlY3RseVxuICAgICAgICAgICAgc3RyaW5naWZ5U3R5bGVzaGVldChydWxlMi5zdHlsZVNoZWV0KSB8fCAvLyB3b3JrIGFyb3VuZCBicm93c2VyIGlzc3VlcyB3aXRoIHRoZSByYXcgc3RyaW5nIGBAaW1wb3J0IHVybCguLi4pYCBzdGF0ZW1lbnRcbiAgICAgICAgICAgIGVzY2FwZUltcG9ydFN0YXRlbWVudChydWxlMik7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpbXBvcnRTdHJpbmdpZmllZCA9IHJ1bGUyLmNzc1RleHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bGUyLnN0eWxlU2hlZXQuaHJlZikge1xuICAgICAgICAgICAgcmV0dXJuIGFic29sdXRpZnlVUkxzKGltcG9ydFN0cmluZ2lmaWVkLCBydWxlMi5zdHlsZVNoZWV0LmhyZWYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbXBvcnRTdHJpbmdpZmllZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcnVsZVN0cmluZ2lmaWVkID0gcnVsZTIuY3NzVGV4dDtcbiAgICAgICAgaWYgKGlzQ1NTU3R5bGVSdWxlKHJ1bGUyKSAmJiBydWxlMi5zZWxlY3RvclRleHQuaW5jbHVkZXMoXCI6XCIpKSB7XG4gICAgICAgICAgICBydWxlU3RyaW5naWZpZWQgPSBmaXhTYWZhcmlDb2xvbnMocnVsZVN0cmluZ2lmaWVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hlZXRIcmVmKSB7XG4gICAgICAgICAgICByZXR1cm4gYWJzb2x1dGlmeVVSTHMocnVsZVN0cmluZ2lmaWVkLCBzaGVldEhyZWYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydWxlU3RyaW5naWZpZWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gZml4U2FmYXJpQ29sb25zKGNzc1N0cmluZ2lmaWVkKSB7XG4gICAgdmFyIHJlZ2V4ID0gLyhcXFsoPzpbXFx3LV0rKVteXFxcXF0pKDooPzpbXFx3LV0rKVxcXSkvZ207XG4gICAgcmV0dXJuIGNzc1N0cmluZ2lmaWVkLnJlcGxhY2UocmVnZXgsIFwiJDFcXFxcJDJcIik7XG59XG5mdW5jdGlvbiBpc0NTU0ltcG9ydFJ1bGUocnVsZTIpIHtcbiAgICByZXR1cm4gXCJzdHlsZVNoZWV0XCIgaW4gcnVsZTI7XG59XG5mdW5jdGlvbiBpc0NTU1N0eWxlUnVsZShydWxlMikge1xuICAgIHJldHVybiBcInNlbGVjdG9yVGV4dFwiIGluIHJ1bGUyO1xufVxudmFyIE1pcnJvciA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gTWlycm9yKCkge1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEkMSh0aGlzLCBcImlkTm9kZU1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxJDEodGhpcywgXCJub2RlTWV0YU1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBNaXJyb3IucHJvdG90eXBlO1xuICAgIF9wcm90by5nZXRJZCA9IGZ1bmN0aW9uIGdldElkKG4yKSB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIGlmICghbjIpIHJldHVybiAtMTtcbiAgICAgICAgdmFyIGlkID0gKF9hMiA9IHRoaXMuZ2V0TWV0YShuMikpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuaWQ7XG4gICAgICAgIHJldHVybiBpZCAhPSBudWxsID8gaWQgOiAtMTtcbiAgICB9O1xuICAgIF9wcm90by5nZXROb2RlID0gZnVuY3Rpb24gZ2V0Tm9kZShpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZE5vZGVNYXAuZ2V0KGlkKSB8fCBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLmdldElkcyA9IGZ1bmN0aW9uIGdldElkcygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5pZE5vZGVNYXAua2V5cygpKTtcbiAgICB9O1xuICAgIF9wcm90by5nZXRNZXRhID0gZnVuY3Rpb24gZ2V0TWV0YShuMikge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlTWV0YU1hcC5nZXQobjIpIHx8IG51bGw7XG4gICAgfTtcbiAgICAvLyByZW1vdmVzIHRoZSBub2RlIGZyb20gaWROb2RlTWFwXG4gICAgLy8gZG9lc24ndCByZW1vdmUgdGhlIG5vZGUgZnJvbSBub2RlTWV0YU1hcFxuICAgIF9wcm90by5yZW1vdmVOb2RlRnJvbU1hcCA9IGZ1bmN0aW9uIHJlbW92ZU5vZGVGcm9tTWFwKG4yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBpZCA9IHRoaXMuZ2V0SWQobjIpO1xuICAgICAgICB0aGlzLmlkTm9kZU1hcC5kZWxldGUoaWQpO1xuICAgICAgICBpZiAobjIuY2hpbGROb2Rlcykge1xuICAgICAgICAgICAgbjIuY2hpbGROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZW1vdmVOb2RlRnJvbU1hcChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5oYXMgPSBmdW5jdGlvbiBoYXMoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWROb2RlTWFwLmhhcyhpZCk7XG4gICAgfTtcbiAgICBfcHJvdG8uaGFzTm9kZSA9IGZ1bmN0aW9uIGhhc05vZGUobm9kZTIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZU1ldGFNYXAuaGFzKG5vZGUyKTtcbiAgICB9O1xuICAgIF9wcm90by5hZGQgPSBmdW5jdGlvbiBhZGQobjIsIG1ldGEpIHtcbiAgICAgICAgdmFyIGlkID0gbWV0YS5pZDtcbiAgICAgICAgdGhpcy5pZE5vZGVNYXAuc2V0KGlkLCBuMik7XG4gICAgICAgIHRoaXMubm9kZU1ldGFNYXAuc2V0KG4yLCBtZXRhKTtcbiAgICB9O1xuICAgIF9wcm90by5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShpZCwgbjIpIHtcbiAgICAgICAgdmFyIG9sZE5vZGUgPSB0aGlzLmdldE5vZGUoaWQpO1xuICAgICAgICBpZiAob2xkTm9kZSkge1xuICAgICAgICAgICAgdmFyIG1ldGEgPSB0aGlzLm5vZGVNZXRhTWFwLmdldChvbGROb2RlKTtcbiAgICAgICAgICAgIGlmIChtZXRhKSB0aGlzLm5vZGVNZXRhTWFwLnNldChuMiwgbWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pZE5vZGVNYXAuc2V0KGlkLCBuMik7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgdGhpcy5pZE5vZGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm5vZGVNZXRhTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgfTtcbiAgICByZXR1cm4gTWlycm9yO1xufSgpO1xuZnVuY3Rpb24gY3JlYXRlTWlycm9yJDIoKSB7XG4gICAgcmV0dXJuIG5ldyBNaXJyb3IoKTtcbn1cbmZ1bmN0aW9uIG1hc2tJbnB1dFZhbHVlKHBhcmFtKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBwYXJhbS5lbGVtZW50LCBtYXNrSW5wdXRPcHRpb25zID0gcGFyYW0ubWFza0lucHV0T3B0aW9ucywgdGFnTmFtZSA9IHBhcmFtLnRhZ05hbWUsIHR5cGUgPSBwYXJhbS50eXBlLCB2YWx1ZSA9IHBhcmFtLnZhbHVlLCBtYXNrSW5wdXRGbiA9IHBhcmFtLm1hc2tJbnB1dEZuO1xuICAgIHZhciB0ZXh0ID0gdmFsdWUgfHwgXCJcIjtcbiAgICB2YXIgYWN0dWFsVHlwZSA9IHR5cGUgJiYgdG9Mb3dlckNhc2UodHlwZSk7XG4gICAgaWYgKG1hc2tJbnB1dE9wdGlvbnNbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXSB8fCBhY3R1YWxUeXBlICYmIG1hc2tJbnB1dE9wdGlvbnNbYWN0dWFsVHlwZV0pIHtcbiAgICAgICAgaWYgKG1hc2tJbnB1dEZuKSB7XG4gICAgICAgICAgICB0ZXh0ID0gbWFza0lucHV0Rm4odGV4dCwgZWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0ID0gXCIqXCIucmVwZWF0KHRleHQubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbn1cbmZ1bmN0aW9uIHRvTG93ZXJDYXNlKHN0cikge1xuICAgIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKTtcbn1cbnZhciBPUklHSU5BTF9BVFRSSUJVVEVfTkFNRSA9IFwiX19ycndlYl9vcmlnaW5hbF9fXCI7XG5mdW5jdGlvbiBpczJEQ2FudmFzQmxhbmsoY2FudmFzKSB7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgaWYgKCFjdHgpIHJldHVybiB0cnVlO1xuICAgIHZhciBjaHVua1NpemUgPSA1MDtcbiAgICBmb3IodmFyIHgyID0gMDsgeDIgPCBjYW52YXMud2lkdGg7IHgyICs9IGNodW5rU2l6ZSl7XG4gICAgICAgIGZvcih2YXIgeSA9IDA7IHkgPCBjYW52YXMuaGVpZ2h0OyB5ICs9IGNodW5rU2l6ZSl7XG4gICAgICAgICAgICB2YXIgZ2V0SW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YTtcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbEdldEltYWdlRGF0YSA9IE9SSUdJTkFMX0FUVFJJQlVURV9OQU1FIGluIGdldEltYWdlRGF0YSA/IGdldEltYWdlRGF0YVtPUklHSU5BTF9BVFRSSUJVVEVfTkFNRV0gOiBnZXRJbWFnZURhdGE7XG4gICAgICAgICAgICB2YXIgcGl4ZWxCdWZmZXIgPSBuZXcgVWludDMyQXJyYXkoLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgb3JpZ2luYWxHZXRJbWFnZURhdGEuY2FsbChjdHgsIHgyLCB5LCBNYXRoLm1pbihjaHVua1NpemUsIGNhbnZhcy53aWR0aCAtIHgyKSwgTWF0aC5taW4oY2h1bmtTaXplLCBjYW52YXMuaGVpZ2h0IC0geSkpLmRhdGEuYnVmZmVyKTtcbiAgICAgICAgICAgIGlmIChwaXhlbEJ1ZmZlci5zb21lKGZ1bmN0aW9uKHBpeGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBpeGVsICE9PSAwO1xuICAgICAgICAgICAgfSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldElucHV0VHlwZShlbGVtZW50KSB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gICAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlKFwiZGF0YS1yci1pcy1wYXNzd29yZFwiKSA/IFwicGFzc3dvcmRcIiA6IHR5cGUgPyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LXR5cGUtYXNzZXJ0aW9uXG4gICAgdG9Mb3dlckNhc2UodHlwZSkgOiBudWxsO1xufVxuZnVuY3Rpb24gZXh0cmFjdEZpbGVFeHRlbnNpb24ocGF0aCwgYmFzZVVSTCkge1xuICAgIHZhciB1cmw7XG4gICAgdHJ5IHtcbiAgICAgICAgdXJsID0gbmV3IFVSTChwYXRoLCBiYXNlVVJMICE9IG51bGwgPyBiYXNlVVJMIDogd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHJlZ2V4ID0gL1xcLihbMC05YS16XSspKD86JCkvaTtcbiAgICB2YXIgbWF0Y2ggPSB1cmwucGF0aG5hbWUubWF0Y2gocmVnZXgpO1xuICAgIHZhciBfcmVmO1xuICAgIHJldHVybiAoX3JlZiA9IG1hdGNoID09IG51bGwgPyB2b2lkIDAgOiBtYXRjaFsxXSkgIT0gbnVsbCA/IF9yZWYgOiBudWxsO1xufVxuZnVuY3Rpb24gZXh0cmFjdE9yaWdpbih1cmwpIHtcbiAgICB2YXIgb3JpZ2luID0gXCJcIjtcbiAgICBpZiAodXJsLmluZGV4T2YoXCIvL1wiKSA+IC0xKSB7XG4gICAgICAgIG9yaWdpbiA9IHVybC5zcGxpdChcIi9cIikuc2xpY2UoMCwgMykuam9pbihcIi9cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3JpZ2luID0gdXJsLnNwbGl0KFwiL1wiKVswXTtcbiAgICB9XG4gICAgb3JpZ2luID0gb3JpZ2luLnNwbGl0KFwiP1wiKVswXTtcbiAgICByZXR1cm4gb3JpZ2luO1xufVxudmFyIFVSTF9JTl9DU1NfUkVGID0gL3VybFxcKCg/OignKShbXiddKiknfChcIikoLio/KVwifChbXildKikpXFwpL2dtO1xudmFyIFVSTF9QUk9UT0NPTF9NQVRDSCA9IC9eKD86W2EteitdKzopP1xcL1xcLy9pO1xudmFyIFVSTF9XV1dfTUFUQ0ggPSAvXnd3d1xcLi4qL2k7XG52YXIgREFUQV9VUkkgPSAvXihkYXRhOikoW14sXSopLCguKikvaTtcbmZ1bmN0aW9uIGFic29sdXRpZnlVUkxzKGNzc1RleHQsIGhyZWYpIHtcbiAgICByZXR1cm4gKGNzc1RleHQgfHwgXCJcIikucmVwbGFjZShVUkxfSU5fQ1NTX1JFRiwgZnVuY3Rpb24ob3JpZ2luLCBxdW90ZTEsIHBhdGgxLCBxdW90ZTIsIHBhdGgyLCBwYXRoMykge1xuICAgICAgICB2YXIgZmlsZVBhdGggPSBwYXRoMSB8fCBwYXRoMiB8fCBwYXRoMztcbiAgICAgICAgdmFyIG1heWJlUXVvdGUgPSBxdW90ZTEgfHwgcXVvdGUyIHx8IFwiXCI7XG4gICAgICAgIGlmICghZmlsZVBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFVSTF9QUk9UT0NPTF9NQVRDSC50ZXN0KGZpbGVQYXRoKSB8fCBVUkxfV1dXX01BVENILnRlc3QoZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ1cmwoXCIgKyBtYXliZVF1b3RlICsgZmlsZVBhdGggKyBtYXliZVF1b3RlICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKERBVEFfVVJJLnRlc3QoZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ1cmwoXCIgKyBtYXliZVF1b3RlICsgZmlsZVBhdGggKyBtYXliZVF1b3RlICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbGVQYXRoWzBdID09PSBcIi9cIikge1xuICAgICAgICAgICAgcmV0dXJuIFwidXJsKFwiICsgbWF5YmVRdW90ZSArIChleHRyYWN0T3JpZ2luKGhyZWYpICsgZmlsZVBhdGgpICsgbWF5YmVRdW90ZSArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGFjayA9IGhyZWYuc3BsaXQoXCIvXCIpO1xuICAgICAgICB2YXIgcGFydHMgPSBmaWxlUGF0aC5zcGxpdChcIi9cIik7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShwYXJ0cyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICBpZiAocGFydCA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gXCIuLlwiKSB7XG4gICAgICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gocGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwidXJsKFwiICsgbWF5YmVRdW90ZSArIHN0YWNrLmpvaW4oXCIvXCIpICsgbWF5YmVRdW90ZSArIFwiKVwiO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQ3NzU3RyaW5nKGNzc1RleHQsIF90ZXN0Tm9QeE5vcm0pIHtcbiAgICBpZiAoX3Rlc3ROb1B4Tm9ybSA9PT0gdm9pZCAwKSBfdGVzdE5vUHhOb3JtID0gZmFsc2U7XG4gICAgaWYgKF90ZXN0Tm9QeE5vcm0pIHtcbiAgICAgICAgcmV0dXJuIGNzc1RleHQucmVwbGFjZSgvKFxcL1xcKlteKl0qXFwqXFwvKXxbXFxzO10vZywgXCJcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNzc1RleHQucmVwbGFjZSgvKFxcL1xcKlteKl0qXFwqXFwvKXxbXFxzO10vZywgXCJcIikucmVwbGFjZSgvMHB4L2csIFwiMFwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzcGxpdENzc1RleHQoY3NzVGV4dCwgc3R5bGUsIF90ZXN0Tm9QeE5vcm0pIHtcbiAgICBpZiAoX3Rlc3ROb1B4Tm9ybSA9PT0gdm9pZCAwKSBfdGVzdE5vUHhOb3JtID0gZmFsc2U7XG4gICAgdmFyIGNoaWxkTm9kZXMyID0gQXJyYXkuZnJvbShzdHlsZS5jaGlsZE5vZGVzKTtcbiAgICB2YXIgc3BsaXRzID0gW107XG4gICAgdmFyIGl0ZXJDb3VudCA9IDA7XG4gICAgaWYgKGNoaWxkTm9kZXMyLmxlbmd0aCA+IDEgJiYgY3NzVGV4dCAmJiB0eXBlb2YgY3NzVGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YXIgY3NzVGV4dE5vcm0gPSBub3JtYWxpemVDc3NTdHJpbmcoY3NzVGV4dCwgX3Rlc3ROb1B4Tm9ybSk7XG4gICAgICAgIHZhciBub3JtRmFjdG9yID0gY3NzVGV4dE5vcm0ubGVuZ3RoIC8gY3NzVGV4dC5sZW5ndGg7XG4gICAgICAgIGZvcih2YXIgaTIgPSAxOyBpMiA8IGNoaWxkTm9kZXMyLmxlbmd0aDsgaTIrKyl7XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlczJbaTJdLnRleHRDb250ZW50ICYmIHR5cGVvZiBjaGlsZE5vZGVzMltpMl0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dENvbnRlbnROb3JtID0gbm9ybWFsaXplQ3NzU3RyaW5nKGNoaWxkTm9kZXMyW2kyXS50ZXh0Q29udGVudCwgX3Rlc3ROb1B4Tm9ybSk7XG4gICAgICAgICAgICAgICAgdmFyIGpMaW1pdCA9IDEwMDtcbiAgICAgICAgICAgICAgICB2YXIgaiA9IDM7XG4gICAgICAgICAgICAgICAgZm9yKDsgaiA8IHRleHRDb250ZW50Tm9ybS5sZW5ndGg7IGorKyl7XG4gICAgICAgICAgICAgICAgICAgIGlmICgvLyBrZWVwIGNvbnN1bWluZyBjc3MgaWRlbnRpZmllcnMgKHRvIGdldCBhIGRlY2VudCBjaHVuayBtb3JlIHF1aWNrbHkpXG4gICAgICAgICAgICAgICAgICAgIHRleHRDb250ZW50Tm9ybVtqXS5tYXRjaCgvW2EtekEtWjAtOV0vKSB8fCAvLyBzdWJzdHJpbmcgbmVlZHMgdG8gYmUgdW5pcXVlIHRvIHRoaXMgc2VjdGlvblxuICAgICAgICAgICAgICAgICAgICB0ZXh0Q29udGVudE5vcm0uaW5kZXhPZih0ZXh0Q29udGVudE5vcm0uc3Vic3RyaW5nKDAsIGopLCAxKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IoOyBqIDwgdGV4dENvbnRlbnROb3JtLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0U3Vic3RyaW5nID0gdGV4dENvbnRlbnROb3JtLnN1YnN0cmluZygwLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNzc05vcm1TcGxpdHMgPSBjc3NUZXh0Tm9ybS5zcGxpdChzdGFydFN1YnN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGxpdE5vcm0gPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNzc05vcm1TcGxpdHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGxpdE5vcm0gPSBjc3NOb3JtU3BsaXRzWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjc3NOb3JtU3BsaXRzLmxlbmd0aCA+IDIgJiYgY3NzTm9ybVNwbGl0c1swXSA9PT0gXCJcIiAmJiBjaGlsZE5vZGVzMltpMiAtIDFdLnRleHRDb250ZW50ICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGxpdE5vcm0gPSBjc3NUZXh0Tm9ybS5pbmRleE9mKHN0YXJ0U3Vic3RyaW5nLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjc3NOb3JtU3BsaXRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRTdWJzdHJpbmcgPSBzdGFydFN1YnN0cmluZy5zdWJzdHJpbmcoMCwgc3RhcnRTdWJzdHJpbmcubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NOb3JtU3BsaXRzID0gY3NzVGV4dE5vcm0uc3BsaXQoc3RhcnRTdWJzdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNzc05vcm1TcGxpdHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGxpdHMucHVzaChjc3NUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3BsaXRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaiA9IGpMaW1pdCArIDE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaiA9PT0gdGV4dENvbnRlbnROb3JtLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0Tm9ybSA9IGNzc1RleHROb3JtLmluZGV4T2Yoc3RhcnRTdWJzdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjc3NOb3JtU3BsaXRzLmxlbmd0aCA+PSAyICYmIGogPiBqTGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2VGV4dENvbnRlbnQgPSBjaGlsZE5vZGVzMltpMiAtIDFdLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZUZXh0Q29udGVudCAmJiB0eXBlb2YgcHJldlRleHRDb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZNaW5MZW5ndGggPSBub3JtYWxpemVDc3NTdHJpbmcocHJldlRleHRDb250ZW50KS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXROb3JtID0gY3NzVGV4dE5vcm0uaW5kZXhPZihzdGFydFN1YnN0cmluZywgcHJldk1pbkxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BsaXROb3JtID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0Tm9ybSA9IGNzc05vcm1TcGxpdHNbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGxpdE5vcm0gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgayA9IE1hdGguZmxvb3Ioc3BsaXROb3JtIC8gbm9ybUZhY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IoOyBrID4gMCAmJiBrIDwgY3NzVGV4dC5sZW5ndGg7KXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVyQ291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlckNvdW50ID4gNTAgKiBjaGlsZE5vZGVzMi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXRzLnB1c2goY3NzVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzcGxpdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub3JtUGFydCA9IG5vcm1hbGl6ZUNzc1N0cmluZyhjc3NUZXh0LnN1YnN0cmluZygwLCBrKSwgX3Rlc3ROb1B4Tm9ybSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vcm1QYXJ0Lmxlbmd0aCA9PT0gc3BsaXROb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0cy5wdXNoKGNzc1RleHQuc3Vic3RyaW5nKDAsIGspKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzVGV4dCA9IGNzc1RleHQuc3Vic3RyaW5nKGspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3NUZXh0Tm9ybSA9IGNzc1RleHROb3JtLnN1YnN0cmluZyhzcGxpdE5vcm0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vcm1QYXJ0Lmxlbmd0aCA8IHNwbGl0Tm9ybSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrICs9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoKHNwbGl0Tm9ybSAtIG5vcm1QYXJ0Lmxlbmd0aCkgLyBub3JtRmFjdG9yKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgayAtPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKChub3JtUGFydC5sZW5ndGggLSBzcGxpdE5vcm0pICogbm9ybUZhY3RvcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNwbGl0cy5wdXNoKGNzc1RleHQpO1xuICAgIHJldHVybiBzcGxpdHM7XG59XG5mdW5jdGlvbiBtYXJrQ3NzU3BsaXRzKGNzc1RleHQsIHN0eWxlKSB7XG4gICAgcmV0dXJuIHNwbGl0Q3NzVGV4dChjc3NUZXh0LCBzdHlsZSkuam9pbihcIi8qIHJyX3NwbGl0ICovXCIpO1xufVxudmFyIF9pZCA9IDE7XG52YXIgdGFnTmFtZVJlZ2V4ID0gbmV3IFJlZ0V4cChcIlteYS16MC05LV86XVwiKTtcbnZhciBJR05PUkVEX05PREUgPSAtMjtcbmZ1bmN0aW9uIGdlbklkKCkge1xuICAgIHJldHVybiBfaWQrKztcbn1cbmZ1bmN0aW9uIGdldFZhbGlkVGFnTmFtZSQxKGVsZW1lbnQpIHtcbiAgICBpZiAoX2luc3RhbmNlb2YoZWxlbWVudCwgSFRNTEZvcm1FbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gXCJmb3JtXCI7XG4gICAgfVxuICAgIHZhciBwcm9jZXNzZWRUYWdOYW1lID0gdG9Mb3dlckNhc2UoZWxlbWVudC50YWdOYW1lKTtcbiAgICBpZiAodGFnTmFtZVJlZ2V4LnRlc3QocHJvY2Vzc2VkVGFnTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIFwiZGl2XCI7XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzZWRUYWdOYW1lO1xufVxudmFyIGNhbnZhc1NlcnZpY2U7XG52YXIgY2FudmFzQ3R4O1xudmFyIFNSQ1NFVF9OT1RfU1BBQ0VTID0gL15bXiBcXHRcXG5cXHJcXHUwMDBjXSsvO1xudmFyIFNSQ1NFVF9DT01NQVNfT1JfU1BBQ0VTID0gL15bLCBcXHRcXG5cXHJcXHUwMDBjXSsvO1xuZnVuY3Rpb24gZ2V0QWJzb2x1dGVTcmNzZXRTdHJpbmcoZG9jLCBhdHRyaWJ1dGVWYWx1ZSkge1xuICAgIGlmIChhdHRyaWJ1dGVWYWx1ZS50cmltKCkgPT09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZVZhbHVlO1xuICAgIH1cbiAgICB2YXIgcG9zID0gMDtcbiAgICBmdW5jdGlvbiBjb2xsZWN0Q2hhcmFjdGVycyhyZWdFeCkge1xuICAgICAgICB2YXIgY2hhcnMyO1xuICAgICAgICB2YXIgbWF0Y2ggPSByZWdFeC5leGVjKGF0dHJpYnV0ZVZhbHVlLnN1YnN0cmluZyhwb3MpKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjaGFyczIgPSBtYXRjaFswXTtcbiAgICAgICAgICAgIHBvcyArPSBjaGFyczIubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIGNoYXJzMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgdmFyIG91dHB1dCA9IFtdO1xuICAgIHdoaWxlKHRydWUpe1xuICAgICAgICBjb2xsZWN0Q2hhcmFjdGVycyhTUkNTRVRfQ09NTUFTX09SX1NQQUNFUyk7XG4gICAgICAgIGlmIChwb3MgPj0gYXR0cmlidXRlVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXJsID0gY29sbGVjdENoYXJhY3RlcnMoU1JDU0VUX05PVF9TUEFDRVMpO1xuICAgICAgICBpZiAodXJsLnNsaWNlKC0xKSA9PT0gXCIsXCIpIHtcbiAgICAgICAgICAgIHVybCA9IGFic29sdXRlVG9Eb2MoZG9jLCB1cmwuc3Vic3RyaW5nKDAsIHVybC5sZW5ndGggLSAxKSk7XG4gICAgICAgICAgICBvdXRwdXQucHVzaCh1cmwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3JzU3RyID0gXCJcIjtcbiAgICAgICAgICAgIHVybCA9IGFic29sdXRlVG9Eb2MoZG9jLCB1cmwpO1xuICAgICAgICAgICAgdmFyIGluUGFyZW5zID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSh0cnVlKXtcbiAgICAgICAgICAgICAgICB2YXIgYzIgPSBhdHRyaWJ1dGVWYWx1ZS5jaGFyQXQocG9zKTtcbiAgICAgICAgICAgICAgICBpZiAoYzIgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goKHVybCArIGRlc2NyaXB0b3JzU3RyKS50cmltKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpblBhcmVucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYzIgPT09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKCh1cmwgKyBkZXNjcmlwdG9yc1N0cikudHJpbSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGMyID09PSBcIihcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5QYXJlbnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMyID09PSBcIilcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5QYXJlbnMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yc1N0ciArPSBjMjtcbiAgICAgICAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0LmpvaW4oXCIsIFwiKTtcbn1cbnZhciBjYWNoZWREb2N1bWVudCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gYWJzb2x1dGVUb0RvYyhkb2MsIGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgaWYgKCFhdHRyaWJ1dGVWYWx1ZSB8fCBhdHRyaWJ1dGVWYWx1ZS50cmltKCkgPT09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZVZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0SHJlZihkb2MsIGF0dHJpYnV0ZVZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzU1ZHRWxlbWVudChlbCkge1xuICAgIHJldHVybiBCb29sZWFuKGVsLnRhZ05hbWUgPT09IFwic3ZnXCIgfHwgZWwub3duZXJTVkdFbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGdldEhyZWYoZG9jLCBjdXN0b21IcmVmKSB7XG4gICAgdmFyIGEyID0gY2FjaGVkRG9jdW1lbnQuZ2V0KGRvYyk7XG4gICAgaWYgKCFhMikge1xuICAgICAgICBhMiA9IGRvYy5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgICAgY2FjaGVkRG9jdW1lbnQuc2V0KGRvYywgYTIpO1xuICAgIH1cbiAgICBpZiAoIWN1c3RvbUhyZWYpIHtcbiAgICAgICAgY3VzdG9tSHJlZiA9IFwiXCI7XG4gICAgfSBlbHNlIGlmIChjdXN0b21IcmVmLnN0YXJ0c1dpdGgoXCJibG9iOlwiKSB8fCBjdXN0b21IcmVmLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSkge1xuICAgICAgICByZXR1cm4gY3VzdG9tSHJlZjtcbiAgICB9XG4gICAgYTIuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBjdXN0b21IcmVmKTtcbiAgICByZXR1cm4gYTIuaHJlZjtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUF0dHJpYnV0ZShkb2MsIHRhZ05hbWUsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmIChuYW1lID09PSBcInNyY1wiIHx8IG5hbWUgPT09IFwiaHJlZlwiICYmICEodGFnTmFtZSA9PT0gXCJ1c2VcIiAmJiB2YWx1ZVswXSA9PT0gXCIjXCIpKSB7XG4gICAgICAgIHJldHVybiBhYnNvbHV0ZVRvRG9jKGRvYywgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJ4bGluazpocmVmXCIgJiYgdmFsdWVbMF0gIT09IFwiI1wiKSB7XG4gICAgICAgIHJldHVybiBhYnNvbHV0ZVRvRG9jKGRvYywgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJiYWNrZ3JvdW5kXCIgJiYgKHRhZ05hbWUgPT09IFwidGFibGVcIiB8fCB0YWdOYW1lID09PSBcInRkXCIgfHwgdGFnTmFtZSA9PT0gXCJ0aFwiKSkge1xuICAgICAgICByZXR1cm4gYWJzb2x1dGVUb0RvYyhkb2MsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwic3Jjc2V0XCIpIHtcbiAgICAgICAgcmV0dXJuIGdldEFic29sdXRlU3Jjc2V0U3RyaW5nKGRvYywgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgICAgIHJldHVybiBhYnNvbHV0aWZ5VVJMcyh2YWx1ZSwgZ2V0SHJlZihkb2MpKTtcbiAgICB9IGVsc2UgaWYgKHRhZ05hbWUgPT09IFwib2JqZWN0XCIgJiYgbmFtZSA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgcmV0dXJuIGFic29sdXRlVG9Eb2MoZG9jLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGlnbm9yZUF0dHJpYnV0ZSh0YWdOYW1lLCBuYW1lLCBfdmFsdWUpIHtcbiAgICByZXR1cm4gKHRhZ05hbWUgPT09IFwidmlkZW9cIiB8fCB0YWdOYW1lID09PSBcImF1ZGlvXCIpICYmIG5hbWUgPT09IFwiYXV0b3BsYXlcIjtcbn1cbmZ1bmN0aW9uIF9pc0Jsb2NrZWRFbGVtZW50KGVsZW1lbnQsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGJsb2NrQ2xhc3MgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhibG9ja0NsYXNzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yKHZhciBlSW5kZXggPSBlbGVtZW50LmNsYXNzTGlzdC5sZW5ndGg7IGVJbmRleC0tOyl7XG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NMaXN0W2VJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrQ2xhc3MudGVzdChjbGFzc05hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmxvY2tTZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQubWF0Y2hlcyhibG9ja1NlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUyKSB7fVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNsYXNzTWF0Y2hlc1JlZ2V4KG5vZGUyLCByZWdleCwgY2hlY2tBbmNlc3RvcnMpIHtcbiAgICBpZiAoIW5vZGUyKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKG5vZGUyLm5vZGVUeXBlICE9PSBub2RlMi5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgaWYgKCFjaGVja0FuY2VzdG9ycykgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gY2xhc3NNYXRjaGVzUmVnZXgoaW5kZXgkMS5wYXJlbnROb2RlKG5vZGUyKSwgcmVnZXgsIGNoZWNrQW5jZXN0b3JzKTtcbiAgICB9XG4gICAgZm9yKHZhciBlSW5kZXggPSBub2RlMi5jbGFzc0xpc3QubGVuZ3RoOyBlSW5kZXgtLTspe1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gbm9kZTIuY2xhc3NMaXN0W2VJbmRleF07XG4gICAgICAgIGlmIChyZWdleC50ZXN0KGNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghY2hlY2tBbmNlc3RvcnMpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gY2xhc3NNYXRjaGVzUmVnZXgoaW5kZXgkMS5wYXJlbnROb2RlKG5vZGUyKSwgcmVnZXgsIGNoZWNrQW5jZXN0b3JzKTtcbn1cbmZ1bmN0aW9uIG5lZWRNYXNraW5nVGV4dChub2RlMiwgbWFza1RleHRDbGFzcywgbWFza1RleHRTZWxlY3RvciwgY2hlY2tBbmNlc3RvcnMpIHtcbiAgICB2YXIgZWw7XG4gICAgaWYgKGlzRWxlbWVudChub2RlMikpIHtcbiAgICAgICAgZWwgPSBub2RlMjtcbiAgICAgICAgaWYgKCFpbmRleCQxLmNoaWxkTm9kZXMoZWwpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChpbmRleCQxLnBhcmVudEVsZW1lbnQobm9kZTIpID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBlbCA9IGluZGV4JDEucGFyZW50RWxlbWVudChub2RlMik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWFza1RleHRDbGFzcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKGNoZWNrQW5jZXN0b3JzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsLmNsb3Nlc3QoXCIuXCIgKyBtYXNrVGV4dENsYXNzKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMobWFza1RleHRDbGFzcykpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNsYXNzTWF0Y2hlc1JlZ2V4KGVsLCBtYXNrVGV4dENsYXNzLCBjaGVja0FuY2VzdG9ycykpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXNrVGV4dFNlbGVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tBbmNlc3RvcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWwuY2xvc2VzdChtYXNrVGV4dFNlbGVjdG9yKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChlbC5tYXRjaGVzKG1hc2tUZXh0U2VsZWN0b3IpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUyKSB7fVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG9uY2VJZnJhbWVMb2FkZWQoaWZyYW1lRWwsIGxpc3RlbmVyLCBpZnJhbWVMb2FkVGltZW91dCkge1xuICAgIHZhciB3aW4gPSBpZnJhbWVFbC5jb250ZW50V2luZG93O1xuICAgIGlmICghd2luKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGZpcmVkID0gZmFsc2U7XG4gICAgdmFyIHJlYWR5U3RhdGU7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVhZHlTdGF0ZSA9IHdpbi5kb2N1bWVudC5yZWFkeVN0YXRlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlYWR5U3RhdGUgIT09IFwiY29tcGxldGVcIikge1xuICAgICAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCFmaXJlZCkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBpZnJhbWVMb2FkVGltZW91dCk7XG4gICAgICAgIGlmcmFtZUVsLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBibGFua1VybCA9IFwiYWJvdXQ6YmxhbmtcIjtcbiAgICBpZiAod2luLmxvY2F0aW9uLmhyZWYgIT09IGJsYW5rVXJsIHx8IGlmcmFtZUVsLnNyYyA9PT0gYmxhbmtVcmwgfHwgaWZyYW1lRWwuc3JjID09PSBcIlwiKSB7XG4gICAgICAgIHNldFRpbWVvdXQobGlzdGVuZXIsIDApO1xuICAgICAgICByZXR1cm4gaWZyYW1lRWwuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICBpZnJhbWVFbC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBsaXN0ZW5lcik7XG59XG5mdW5jdGlvbiBvbmNlU3R5bGVzaGVldExvYWRlZChsaW5rLCBsaXN0ZW5lciwgc3R5bGVTaGVldExvYWRUaW1lb3V0KSB7XG4gICAgdmFyIGZpcmVkID0gZmFsc2U7XG4gICAgdmFyIHN0eWxlU2hlZXRMb2FkZWQ7XG4gICAgdHJ5IHtcbiAgICAgICAgc3R5bGVTaGVldExvYWRlZCA9IGxpbmsuc2hlZXQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3R5bGVTaGVldExvYWRlZCkgcmV0dXJuO1xuICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghZmlyZWQpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICAgICAgICBmaXJlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LCBzdHlsZVNoZWV0TG9hZFRpbWVvdXQpO1xuICAgIGxpbmsuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgICAgbGlzdGVuZXIoKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZU5vZGUobjIsIG9wdGlvbnMpIHtcbiAgICB2YXIgZG9jID0gb3B0aW9ucy5kb2MsIG1pcnJvcjIgPSBvcHRpb25zLm1pcnJvciwgYmxvY2tDbGFzcyA9IG9wdGlvbnMuYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciA9IG9wdGlvbnMuYmxvY2tTZWxlY3RvciwgbmVlZHNNYXNrID0gb3B0aW9ucy5uZWVkc01hc2ssIGlubGluZVN0eWxlc2hlZXQgPSBvcHRpb25zLmlubGluZVN0eWxlc2hlZXQsIF9vcHRpb25zX21hc2tJbnB1dE9wdGlvbnMgPSBvcHRpb25zLm1hc2tJbnB1dE9wdGlvbnMsIG1hc2tJbnB1dE9wdGlvbnMgPSBfb3B0aW9uc19tYXNrSW5wdXRPcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9vcHRpb25zX21hc2tJbnB1dE9wdGlvbnMsIG1hc2tUZXh0Rm4gPSBvcHRpb25zLm1hc2tUZXh0Rm4sIG1hc2tJbnB1dEZuID0gb3B0aW9ucy5tYXNrSW5wdXRGbiwgX29wdGlvbnNfZGF0YVVSTE9wdGlvbnMgPSBvcHRpb25zLmRhdGFVUkxPcHRpb25zLCBkYXRhVVJMT3B0aW9ucyA9IF9vcHRpb25zX2RhdGFVUkxPcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9vcHRpb25zX2RhdGFVUkxPcHRpb25zLCBpbmxpbmVJbWFnZXMgPSBvcHRpb25zLmlubGluZUltYWdlcywgcmVjb3JkQ2FudmFzID0gb3B0aW9ucy5yZWNvcmRDYW52YXMsIGtlZXBJZnJhbWVTcmNGbiA9IG9wdGlvbnMua2VlcElmcmFtZVNyY0ZuLCBfb3B0aW9uc19uZXdseUFkZGVkRWxlbWVudCA9IG9wdGlvbnMubmV3bHlBZGRlZEVsZW1lbnQsIG5ld2x5QWRkZWRFbGVtZW50ID0gX29wdGlvbnNfbmV3bHlBZGRlZEVsZW1lbnQgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnNfbmV3bHlBZGRlZEVsZW1lbnQsIF9vcHRpb25zX2Nzc0NhcHR1cmVkID0gb3B0aW9ucy5jc3NDYXB0dXJlZCwgY3NzQ2FwdHVyZWQgPSBfb3B0aW9uc19jc3NDYXB0dXJlZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9uc19jc3NDYXB0dXJlZDtcbiAgICB2YXIgcm9vdElkID0gZ2V0Um9vdElkKGRvYywgbWlycm9yMik7XG4gICAgc3dpdGNoKG4yLm5vZGVUeXBlKXtcbiAgICAgICAgY2FzZSBuMi5ET0NVTUVOVF9OT0RFOlxuICAgICAgICAgICAgaWYgKG4yLmNvbXBhdE1vZGUgIT09IFwiQ1NTMUNvbXBhdFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogTm9kZVR5cGUkMy5Eb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlczogW10sXG4gICAgICAgICAgICAgICAgICAgIGNvbXBhdE1vZGU6IG4yLmNvbXBhdE1vZGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBOb2RlVHlwZSQzLkRvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzOiBbXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgbjIuRE9DVU1FTlRfVFlQRV9OT0RFOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBOb2RlVHlwZSQzLkRvY3VtZW50VHlwZSxcbiAgICAgICAgICAgICAgICBuYW1lOiBuMi5uYW1lLFxuICAgICAgICAgICAgICAgIHB1YmxpY0lkOiBuMi5wdWJsaWNJZCxcbiAgICAgICAgICAgICAgICBzeXN0ZW1JZDogbjIuc3lzdGVtSWQsXG4gICAgICAgICAgICAgICAgcm9vdElkOiByb290SWRcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgbjIuRUxFTUVOVF9OT0RFOlxuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZUVsZW1lbnROb2RlKG4yLCB7XG4gICAgICAgICAgICAgICAgZG9jOiBkb2MsXG4gICAgICAgICAgICAgICAgYmxvY2tDbGFzczogYmxvY2tDbGFzcyxcbiAgICAgICAgICAgICAgICBibG9ja1NlbGVjdG9yOiBibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQ6IGlubGluZVN0eWxlc2hlZXQsXG4gICAgICAgICAgICAgICAgbWFza0lucHV0T3B0aW9uczogbWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbjogbWFza0lucHV0Rm4sXG4gICAgICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnM6IGRhdGFVUkxPcHRpb25zLFxuICAgICAgICAgICAgICAgIGlubGluZUltYWdlczogaW5saW5lSW1hZ2VzLFxuICAgICAgICAgICAgICAgIHJlY29yZENhbnZhczogcmVjb3JkQ2FudmFzLFxuICAgICAgICAgICAgICAgIGtlZXBJZnJhbWVTcmNGbjoga2VlcElmcmFtZVNyY0ZuLFxuICAgICAgICAgICAgICAgIG5ld2x5QWRkZWRFbGVtZW50OiBuZXdseUFkZGVkRWxlbWVudCxcbiAgICAgICAgICAgICAgICByb290SWQ6IHJvb3RJZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgbjIuVEVYVF9OT0RFOlxuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVRleHROb2RlKG4yLCB7XG4gICAgICAgICAgICAgICAgZG9jOiBkb2MsXG4gICAgICAgICAgICAgICAgbmVlZHNNYXNrOiBuZWVkc01hc2ssXG4gICAgICAgICAgICAgICAgbWFza1RleHRGbjogbWFza1RleHRGbixcbiAgICAgICAgICAgICAgICByb290SWQ6IHJvb3RJZCxcbiAgICAgICAgICAgICAgICBjc3NDYXB0dXJlZDogY3NzQ2FwdHVyZWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlIG4yLkNEQVRBX1NFQ1RJT05fTk9ERTpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogTm9kZVR5cGUkMy5DREFUQSxcbiAgICAgICAgICAgICAgICB0ZXh0Q29udGVudDogXCJcIixcbiAgICAgICAgICAgICAgICByb290SWQ6IHJvb3RJZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBuMi5DT01NRU5UX05PREU6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IE5vZGVUeXBlJDMuQ29tbWVudCxcbiAgICAgICAgICAgICAgICB0ZXh0Q29udGVudDogaW5kZXgkMS50ZXh0Q29udGVudChuMikgfHwgXCJcIixcbiAgICAgICAgICAgICAgICByb290SWQ6IHJvb3RJZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRSb290SWQoZG9jLCBtaXJyb3IyKSB7XG4gICAgaWYgKCFtaXJyb3IyLmhhc05vZGUoZG9jKSkgcmV0dXJuIHZvaWQgMDtcbiAgICB2YXIgZG9jSWQgPSBtaXJyb3IyLmdldElkKGRvYyk7XG4gICAgcmV0dXJuIGRvY0lkID09PSAxID8gdm9pZCAwIDogZG9jSWQ7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVUZXh0Tm9kZShuMiwgb3B0aW9ucykge1xuICAgIHZhciBuZWVkc01hc2sgPSBvcHRpb25zLm5lZWRzTWFzaywgbWFza1RleHRGbiA9IG9wdGlvbnMubWFza1RleHRGbiwgcm9vdElkID0gb3B0aW9ucy5yb290SWQsIGNzc0NhcHR1cmVkID0gb3B0aW9ucy5jc3NDYXB0dXJlZDtcbiAgICB2YXIgcGFyZW50ID0gaW5kZXgkMS5wYXJlbnROb2RlKG4yKTtcbiAgICB2YXIgcGFyZW50VGFnTmFtZSA9IHBhcmVudCAmJiBwYXJlbnQudGFnTmFtZTtcbiAgICB2YXIgdGV4dENvbnRlbnQyID0gXCJcIjtcbiAgICB2YXIgaXNTdHlsZSA9IHBhcmVudFRhZ05hbWUgPT09IFwiU1RZTEVcIiA/IHRydWUgOiB2b2lkIDA7XG4gICAgdmFyIGlzU2NyaXB0ID0gcGFyZW50VGFnTmFtZSA9PT0gXCJTQ1JJUFRcIiA/IHRydWUgOiB2b2lkIDA7XG4gICAgaWYgKGlzU2NyaXB0KSB7XG4gICAgICAgIHRleHRDb250ZW50MiA9IFwiU0NSSVBUX1BMQUNFSE9MREVSXCI7XG4gICAgfSBlbHNlIGlmICghY3NzQ2FwdHVyZWQpIHtcbiAgICAgICAgdGV4dENvbnRlbnQyID0gaW5kZXgkMS50ZXh0Q29udGVudChuMik7XG4gICAgICAgIGlmIChpc1N0eWxlICYmIHRleHRDb250ZW50Mikge1xuICAgICAgICAgICAgdGV4dENvbnRlbnQyID0gYWJzb2x1dGlmeVVSTHModGV4dENvbnRlbnQyLCBnZXRIcmVmKG9wdGlvbnMuZG9jKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc1N0eWxlICYmICFpc1NjcmlwdCAmJiB0ZXh0Q29udGVudDIgJiYgbmVlZHNNYXNrKSB7XG4gICAgICAgIHRleHRDb250ZW50MiA9IG1hc2tUZXh0Rm4gPyBtYXNrVGV4dEZuKHRleHRDb250ZW50MiwgaW5kZXgkMS5wYXJlbnRFbGVtZW50KG4yKSkgOiB0ZXh0Q29udGVudDIucmVwbGFjZSgvW1xcU10vZywgXCIqXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBOb2RlVHlwZSQzLlRleHQsXG4gICAgICAgIHRleHRDb250ZW50OiB0ZXh0Q29udGVudDIgfHwgXCJcIixcbiAgICAgICAgcm9vdElkOiByb290SWRcbiAgICB9O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplRWxlbWVudE5vZGUobjIsIG9wdGlvbnMpIHtcbiAgICB2YXIgZG9jID0gb3B0aW9ucy5kb2MsIGJsb2NrQ2xhc3MgPSBvcHRpb25zLmJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IgPSBvcHRpb25zLmJsb2NrU2VsZWN0b3IsIGlubGluZVN0eWxlc2hlZXQgPSBvcHRpb25zLmlubGluZVN0eWxlc2hlZXQsIF9vcHRpb25zX21hc2tJbnB1dE9wdGlvbnMgPSBvcHRpb25zLm1hc2tJbnB1dE9wdGlvbnMsIG1hc2tJbnB1dE9wdGlvbnMgPSBfb3B0aW9uc19tYXNrSW5wdXRPcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9vcHRpb25zX21hc2tJbnB1dE9wdGlvbnMsIG1hc2tJbnB1dEZuID0gb3B0aW9ucy5tYXNrSW5wdXRGbiwgX29wdGlvbnNfZGF0YVVSTE9wdGlvbnMgPSBvcHRpb25zLmRhdGFVUkxPcHRpb25zLCBkYXRhVVJMT3B0aW9ucyA9IF9vcHRpb25zX2RhdGFVUkxPcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9vcHRpb25zX2RhdGFVUkxPcHRpb25zLCBpbmxpbmVJbWFnZXMgPSBvcHRpb25zLmlubGluZUltYWdlcywgcmVjb3JkQ2FudmFzID0gb3B0aW9ucy5yZWNvcmRDYW52YXMsIGtlZXBJZnJhbWVTcmNGbiA9IG9wdGlvbnMua2VlcElmcmFtZVNyY0ZuLCBfb3B0aW9uc19uZXdseUFkZGVkRWxlbWVudCA9IG9wdGlvbnMubmV3bHlBZGRlZEVsZW1lbnQsIG5ld2x5QWRkZWRFbGVtZW50ID0gX29wdGlvbnNfbmV3bHlBZGRlZEVsZW1lbnQgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnNfbmV3bHlBZGRlZEVsZW1lbnQsIHJvb3RJZCA9IG9wdGlvbnMucm9vdElkO1xuICAgIHZhciBuZWVkQmxvY2sgPSBfaXNCbG9ja2VkRWxlbWVudChuMiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvcik7XG4gICAgdmFyIHRhZ05hbWUgPSBnZXRWYWxpZFRhZ05hbWUkMShuMik7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICB2YXIgbGVuID0gbjIuYXR0cmlidXRlcy5sZW5ndGg7XG4gICAgZm9yKHZhciBpMiA9IDA7IGkyIDwgbGVuOyBpMisrKXtcbiAgICAgICAgdmFyIGF0dHIgPSBuMi5hdHRyaWJ1dGVzW2kyXTtcbiAgICAgICAgaWYgKCFpZ25vcmVBdHRyaWJ1dGUodGFnTmFtZSwgYXR0ci5uYW1lLCBhdHRyLnZhbHVlKSkge1xuICAgICAgICAgICAgYXR0cmlidXRlc1thdHRyLm5hbWVdID0gdHJhbnNmb3JtQXR0cmlidXRlKGRvYywgdGFnTmFtZSwgdG9Mb3dlckNhc2UoYXR0ci5uYW1lKSwgYXR0ci52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhZ05hbWUgPT09IFwibGlua1wiICYmIGlubGluZVN0eWxlc2hlZXQpIHtcbiAgICAgICAgdmFyIHN0eWxlc2hlZXQgPSBBcnJheS5mcm9tKGRvYy5zdHlsZVNoZWV0cykuZmluZChmdW5jdGlvbihzMikge1xuICAgICAgICAgICAgcmV0dXJuIHMyLmhyZWYgPT09IG4yLmhyZWY7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY3NzVGV4dCA9IG51bGw7XG4gICAgICAgIGlmIChzdHlsZXNoZWV0KSB7XG4gICAgICAgICAgICBjc3NUZXh0ID0gc3RyaW5naWZ5U3R5bGVzaGVldChzdHlsZXNoZWV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3NzVGV4dCkge1xuICAgICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXMucmVsO1xuICAgICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXMuaHJlZjtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMuX2Nzc1RleHQgPSBjc3NUZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0YWdOYW1lID09PSBcInN0eWxlXCIgJiYgbjIuc2hlZXQpIHtcbiAgICAgICAgdmFyIGNzc1RleHQxID0gc3RyaW5naWZ5U3R5bGVzaGVldChuMi5zaGVldCk7XG4gICAgICAgIGlmIChjc3NUZXh0MSkge1xuICAgICAgICAgICAgaWYgKG4yLmNoaWxkTm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGNzc1RleHQxID0gbWFya0Nzc1NwbGl0cyhjc3NUZXh0MSwgbjIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXR0cmlidXRlcy5fY3NzVGV4dCA9IGNzc1RleHQxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0YWdOYW1lID09PSBcImlucHV0XCIgfHwgdGFnTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiIHx8IHRhZ05hbWUgPT09IFwic2VsZWN0XCIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbjIudmFsdWU7XG4gICAgICAgIHZhciBjaGVja2VkID0gbjIuY2hlY2tlZDtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMudHlwZSAhPT0gXCJyYWRpb1wiICYmIGF0dHJpYnV0ZXMudHlwZSAhPT0gXCJjaGVja2JveFwiICYmIGF0dHJpYnV0ZXMudHlwZSAhPT0gXCJzdWJtaXRcIiAmJiBhdHRyaWJ1dGVzLnR5cGUgIT09IFwiYnV0dG9uXCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMudmFsdWUgPSBtYXNrSW5wdXRWYWx1ZSh7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogbjIsXG4gICAgICAgICAgICAgICAgdHlwZTogZ2V0SW5wdXRUeXBlKG4yKSxcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiB0YWdOYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiBtYXNrSW5wdXRPcHRpb25zLFxuICAgICAgICAgICAgICAgIG1hc2tJbnB1dEZuOiBtYXNrSW5wdXRGblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hlY2tlZCkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5jaGVja2VkID0gY2hlY2tlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGFnTmFtZSA9PT0gXCJvcHRpb25cIikge1xuICAgICAgICBpZiAobjIuc2VsZWN0ZWQgJiYgIW1hc2tJbnB1dE9wdGlvbnNbXCJzZWxlY3RcIl0pIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXMuc2VsZWN0ZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhZ05hbWUgPT09IFwiZGlhbG9nXCIgJiYgbjIub3Blbikge1xuICAgICAgICBhdHRyaWJ1dGVzLnJyX29wZW5fbW9kZSA9IG4yLm1hdGNoZXMoXCJkaWFsb2c6bW9kYWxcIikgPyBcIm1vZGFsXCIgOiBcIm5vbi1tb2RhbFwiO1xuICAgIH1cbiAgICBpZiAodGFnTmFtZSA9PT0gXCJjYW52YXNcIiAmJiByZWNvcmRDYW52YXMpIHtcbiAgICAgICAgaWYgKG4yLl9fY29udGV4dCA9PT0gXCIyZFwiKSB7XG4gICAgICAgICAgICBpZiAoIWlzMkRDYW52YXNCbGFuayhuMikpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnJyX2RhdGFVUkwgPSBuMi50b0RhdGFVUkwoZGF0YVVSTE9wdGlvbnMudHlwZSwgZGF0YVVSTE9wdGlvbnMucXVhbGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIShcIl9fY29udGV4dFwiIGluIG4yKSkge1xuICAgICAgICAgICAgdmFyIGNhbnZhc0RhdGFVUkwgPSBuMi50b0RhdGFVUkwoZGF0YVVSTE9wdGlvbnMudHlwZSwgZGF0YVVSTE9wdGlvbnMucXVhbGl0eSk7XG4gICAgICAgICAgICB2YXIgYmxhbmtDYW52YXMgPSBkb2MuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgICAgIGJsYW5rQ2FudmFzLndpZHRoID0gbjIud2lkdGg7XG4gICAgICAgICAgICBibGFua0NhbnZhcy5oZWlnaHQgPSBuMi5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgYmxhbmtDYW52YXNEYXRhVVJMID0gYmxhbmtDYW52YXMudG9EYXRhVVJMKGRhdGFVUkxPcHRpb25zLnR5cGUsIGRhdGFVUkxPcHRpb25zLnF1YWxpdHkpO1xuICAgICAgICAgICAgaWYgKGNhbnZhc0RhdGFVUkwgIT09IGJsYW5rQ2FudmFzRGF0YVVSTCkge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMucnJfZGF0YVVSTCA9IGNhbnZhc0RhdGFVUkw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhZ05hbWUgPT09IFwiaW1nXCIgJiYgaW5saW5lSW1hZ2VzKSB7XG4gICAgICAgIGlmICghY2FudmFzU2VydmljZSkge1xuICAgICAgICAgICAgY2FudmFzU2VydmljZSA9IGRvYy5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAgICAgY2FudmFzQ3R4ID0gY2FudmFzU2VydmljZS5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGltYWdlID0gbjI7XG4gICAgICAgIHZhciBpbWFnZVNyYyA9IGltYWdlLmN1cnJlbnRTcmMgfHwgaW1hZ2UuZ2V0QXR0cmlidXRlKFwic3JjXCIpIHx8IFwiPHVua25vd24tc3JjPlwiO1xuICAgICAgICB2YXIgcHJpb3JDcm9zc09yaWdpbiA9IGltYWdlLmNyb3NzT3JpZ2luO1xuICAgICAgICB2YXIgcmVjb3JkSW5saW5lSW1hZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHJlY29yZElubGluZUltYWdlKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2FudmFzU2VydmljZS53aWR0aCA9IGltYWdlLm5hdHVyYWxXaWR0aDtcbiAgICAgICAgICAgICAgICBjYW52YXNTZXJ2aWNlLmhlaWdodCA9IGltYWdlLm5hdHVyYWxIZWlnaHQ7XG4gICAgICAgICAgICAgICAgY2FudmFzQ3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5ycl9kYXRhVVJMID0gY2FudmFzU2VydmljZS50b0RhdGFVUkwoZGF0YVVSTE9wdGlvbnMudHlwZSwgZGF0YVVSTE9wdGlvbnMucXVhbGl0eSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW1hZ2UuY3Jvc3NPcmlnaW4gIT09IFwiYW5vbnltb3VzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2UuY29tcGxldGUgJiYgaW1hZ2UubmF0dXJhbFdpZHRoICE9PSAwKSByZWNvcmRJbmxpbmVJbWFnZSgpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHJlY29yZElubGluZUltYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNhbm5vdCBpbmxpbmUgaW1nIHNyYz1cIiArIGltYWdlU3JjICsgXCIhIEVycm9yOiBcIiArIGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGltYWdlLmNyb3NzT3JpZ2luID09PSBcImFub255bW91c1wiKSB7XG4gICAgICAgICAgICAgICAgcHJpb3JDcm9zc09yaWdpbiA/IGF0dHJpYnV0ZXMuY3Jvc3NPcmlnaW4gPSBwcmlvckNyb3NzT3JpZ2luIDogaW1hZ2UucmVtb3ZlQXR0cmlidXRlKFwiY3Jvc3NvcmlnaW5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChpbWFnZS5jb21wbGV0ZSAmJiBpbWFnZS5uYXR1cmFsV2lkdGggIT09IDApIHJlY29yZElubGluZUltYWdlKCk7XG4gICAgICAgIGVsc2UgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgcmVjb3JkSW5saW5lSW1hZ2UpO1xuICAgIH1cbiAgICBpZiAodGFnTmFtZSA9PT0gXCJhdWRpb1wiIHx8IHRhZ05hbWUgPT09IFwidmlkZW9cIikge1xuICAgICAgICB2YXIgbWVkaWFBdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICAgICAgbWVkaWFBdHRyaWJ1dGVzLnJyX21lZGlhU3RhdGUgPSBuMi5wYXVzZWQgPyBcInBhdXNlZFwiIDogXCJwbGF5ZWRcIjtcbiAgICAgICAgbWVkaWFBdHRyaWJ1dGVzLnJyX21lZGlhQ3VycmVudFRpbWUgPSBuMi5jdXJyZW50VGltZTtcbiAgICAgICAgbWVkaWFBdHRyaWJ1dGVzLnJyX21lZGlhUGxheWJhY2tSYXRlID0gbjIucGxheWJhY2tSYXRlO1xuICAgICAgICBtZWRpYUF0dHJpYnV0ZXMucnJfbWVkaWFNdXRlZCA9IG4yLm11dGVkO1xuICAgICAgICBtZWRpYUF0dHJpYnV0ZXMucnJfbWVkaWFMb29wID0gbjIubG9vcDtcbiAgICAgICAgbWVkaWFBdHRyaWJ1dGVzLnJyX21lZGlhVm9sdW1lID0gbjIudm9sdW1lO1xuICAgIH1cbiAgICBpZiAoIW5ld2x5QWRkZWRFbGVtZW50KSB7XG4gICAgICAgIGlmIChuMi5zY3JvbGxMZWZ0KSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnJyX3Njcm9sbExlZnQgPSBuMi5zY3JvbGxMZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuMi5zY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMucnJfc2Nyb2xsVG9wID0gbjIuc2Nyb2xsVG9wO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChuZWVkQmxvY2spIHtcbiAgICAgICAgdmFyIF9uMl9nZXRCb3VuZGluZ0NsaWVudFJlY3QgPSBuMi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgd2lkdGggPSBfbjJfZ2V0Qm91bmRpbmdDbGllbnRSZWN0LndpZHRoLCBoZWlnaHQgPSBfbjJfZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmhlaWdodDtcbiAgICAgICAgYXR0cmlidXRlcyA9IHtcbiAgICAgICAgICAgIGNsYXNzOiBhdHRyaWJ1dGVzLmNsYXNzLFxuICAgICAgICAgICAgcnJfd2lkdGg6IFwiXCIgKyB3aWR0aCArIFwicHhcIixcbiAgICAgICAgICAgIHJyX2hlaWdodDogXCJcIiArIGhlaWdodCArIFwicHhcIlxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodGFnTmFtZSA9PT0gXCJpZnJhbWVcIiAmJiAha2VlcElmcmFtZVNyY0ZuKGF0dHJpYnV0ZXMuc3JjKSkge1xuICAgICAgICBpZiAoIW4yLmNvbnRlbnREb2N1bWVudCkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5ycl9zcmMgPSBhdHRyaWJ1dGVzLnNyYztcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgYXR0cmlidXRlcy5zcmM7XG4gICAgfVxuICAgIHZhciBpc0N1c3RvbUVsZW1lbnQ7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKGN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSkgaXNDdXN0b21FbGVtZW50ID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlMikge31cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBOb2RlVHlwZSQzLkVsZW1lbnQsXG4gICAgICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXG4gICAgICAgIGNoaWxkTm9kZXM6IFtdLFxuICAgICAgICBpc1NWRzogaXNTVkdFbGVtZW50KG4yKSB8fCB2b2lkIDAsXG4gICAgICAgIG5lZWRCbG9jazogbmVlZEJsb2NrLFxuICAgICAgICByb290SWQ6IHJvb3RJZCxcbiAgICAgICAgaXNDdXN0b206IGlzQ3VzdG9tRWxlbWVudFxuICAgIH07XG59XG5mdW5jdGlvbiBsb3dlcklmRXhpc3RzKG1heWJlQXR0cikge1xuICAgIGlmIChtYXliZUF0dHIgPT09IHZvaWQgMCB8fCBtYXliZUF0dHIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1heWJlQXR0ci50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNsaW1ET01FeGNsdWRlZChzbiwgc2xpbURPTU9wdGlvbnMpIHtcbiAgICBpZiAoc2xpbURPTU9wdGlvbnMuY29tbWVudCAmJiBzbi50eXBlID09PSBOb2RlVHlwZSQzLkNvbW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChzbi50eXBlID09PSBOb2RlVHlwZSQzLkVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHNsaW1ET01PcHRpb25zLnNjcmlwdCAmJiAvLyBzY3JpcHQgdGFnXG4gICAgICAgIChzbi50YWdOYW1lID09PSBcInNjcmlwdFwiIHx8IC8vIChtb2R1bGUpcHJlbG9hZCBsaW5rXG4gICAgICAgIHNuLnRhZ05hbWUgPT09IFwibGlua1wiICYmIChzbi5hdHRyaWJ1dGVzLnJlbCA9PT0gXCJwcmVsb2FkXCIgJiYgc24uYXR0cmlidXRlcy5hcyA9PT0gXCJzY3JpcHRcIiB8fCBzbi5hdHRyaWJ1dGVzLnJlbCA9PT0gXCJtb2R1bGVwcmVsb2FkXCIpIHx8IC8vIHByZWZldGNoIGxpbmtcbiAgICAgICAgc24udGFnTmFtZSA9PT0gXCJsaW5rXCIgJiYgc24uYXR0cmlidXRlcy5yZWwgPT09IFwicHJlZmV0Y2hcIiAmJiB0eXBlb2Ygc24uYXR0cmlidXRlcy5ocmVmID09PSBcInN0cmluZ1wiICYmIGV4dHJhY3RGaWxlRXh0ZW5zaW9uKHNuLmF0dHJpYnV0ZXMuaHJlZikgPT09IFwianNcIikpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRGYXZpY29uICYmIChzbi50YWdOYW1lID09PSBcImxpbmtcIiAmJiBzbi5hdHRyaWJ1dGVzLnJlbCA9PT0gXCJzaG9ydGN1dCBpY29uXCIgfHwgc24udGFnTmFtZSA9PT0gXCJtZXRhXCIgJiYgKGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKS5tYXRjaCgvXm1zYXBwbGljYXRpb24tdGlsZShpbWFnZXxjb2xvcikkLykgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcImFwcGxpY2F0aW9uLW5hbWVcIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMucmVsKSA9PT0gXCJpY29uXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLnJlbCkgPT09IFwiYXBwbGUtdG91Y2gtaWNvblwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5yZWwpID09PSBcInNob3J0Y3V0IGljb25cIikpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChzbi50YWdOYW1lID09PSBcIm1ldGFcIikge1xuICAgICAgICAgICAgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRNZXRhRGVzY0tleXdvcmRzICYmIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKS5tYXRjaCgvXmRlc2NyaXB0aW9ufGtleXdvcmRzJC8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRNZXRhU29jaWFsICYmIChsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMucHJvcGVydHkpLm1hdGNoKC9eKG9nfHR3aXR0ZXJ8ZmIpOi8pIHx8IC8vIG9nID0gb3BlbmdyYXBoIChmYWNlYm9vaylcbiAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKS5tYXRjaCgvXihvZ3x0d2l0dGVyKTovKSB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwicGludGVyZXN0XCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRNZXRhUm9ib3RzICYmIChsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwicm9ib3RzXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcImdvb2dsZWJvdFwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJiaW5nYm90XCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRNZXRhSHR0cEVxdWl2ICYmIHNuLmF0dHJpYnV0ZXNbXCJodHRwLWVxdWl2XCJdICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZE1ldGFBdXRob3JzaGlwICYmIChsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwiYXV0aG9yXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcImdlbmVyYXRvclwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJmcmFtZXdvcmtcIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwicHVibGlzaGVyXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcInByb2dpZFwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5wcm9wZXJ0eSkubWF0Y2goL15hcnRpY2xlOi8pIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5wcm9wZXJ0eSkubWF0Y2goL15wcm9kdWN0Oi8pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkTWV0YVZlcmlmaWNhdGlvbiAmJiAobG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcImdvb2dsZS1zaXRlLXZlcmlmaWNhdGlvblwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJ5YW5kZXgtdmVyaWZpY2F0aW9uXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcImNzcmYtdG9rZW5cIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwicDpkb21haW5fdmVyaWZ5XCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcInZlcmlmeS12MVwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJ2ZXJpZmljYXRpb25cIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwic2hvcGlmeS1jaGVja291dC1hcGktdG9rZW5cIikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVOb2RlV2l0aElkKG4yLCBvcHRpb25zKSB7XG4gICAgdmFyIGRvYyA9IG9wdGlvbnMuZG9jLCBtaXJyb3IyID0gb3B0aW9ucy5taXJyb3IsIGJsb2NrQ2xhc3MgPSBvcHRpb25zLmJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IgPSBvcHRpb25zLmJsb2NrU2VsZWN0b3IsIG1hc2tUZXh0Q2xhc3MgPSBvcHRpb25zLm1hc2tUZXh0Q2xhc3MsIG1hc2tUZXh0U2VsZWN0b3IgPSBvcHRpb25zLm1hc2tUZXh0U2VsZWN0b3IsIF9vcHRpb25zX3NraXBDaGlsZCA9IG9wdGlvbnMuc2tpcENoaWxkLCBza2lwQ2hpbGQgPSBfb3B0aW9uc19za2lwQ2hpbGQgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnNfc2tpcENoaWxkLCBfb3B0aW9uc19pbmxpbmVTdHlsZXNoZWV0ID0gb3B0aW9ucy5pbmxpbmVTdHlsZXNoZWV0LCBpbmxpbmVTdHlsZXNoZWV0ID0gX29wdGlvbnNfaW5saW5lU3R5bGVzaGVldCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zX2lubGluZVN0eWxlc2hlZXQsIF9vcHRpb25zX21hc2tJbnB1dE9wdGlvbnMgPSBvcHRpb25zLm1hc2tJbnB1dE9wdGlvbnMsIG1hc2tJbnB1dE9wdGlvbnMgPSBfb3B0aW9uc19tYXNrSW5wdXRPcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9vcHRpb25zX21hc2tJbnB1dE9wdGlvbnMsIG1hc2tUZXh0Rm4gPSBvcHRpb25zLm1hc2tUZXh0Rm4sIG1hc2tJbnB1dEZuID0gb3B0aW9ucy5tYXNrSW5wdXRGbiwgc2xpbURPTU9wdGlvbnMgPSBvcHRpb25zLnNsaW1ET01PcHRpb25zLCBfb3B0aW9uc19kYXRhVVJMT3B0aW9ucyA9IG9wdGlvbnMuZGF0YVVSTE9wdGlvbnMsIGRhdGFVUkxPcHRpb25zID0gX29wdGlvbnNfZGF0YVVSTE9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX29wdGlvbnNfZGF0YVVSTE9wdGlvbnMsIF9vcHRpb25zX2lubGluZUltYWdlcyA9IG9wdGlvbnMuaW5saW5lSW1hZ2VzLCBpbmxpbmVJbWFnZXMgPSBfb3B0aW9uc19pbmxpbmVJbWFnZXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnNfaW5saW5lSW1hZ2VzLCBfb3B0aW9uc19yZWNvcmRDYW52YXMgPSBvcHRpb25zLnJlY29yZENhbnZhcywgcmVjb3JkQ2FudmFzID0gX29wdGlvbnNfcmVjb3JkQ2FudmFzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zX3JlY29yZENhbnZhcywgb25TZXJpYWxpemUgPSBvcHRpb25zLm9uU2VyaWFsaXplLCBvbklmcmFtZUxvYWQgPSBvcHRpb25zLm9uSWZyYW1lTG9hZCwgX29wdGlvbnNfaWZyYW1lTG9hZFRpbWVvdXQgPSBvcHRpb25zLmlmcmFtZUxvYWRUaW1lb3V0LCBpZnJhbWVMb2FkVGltZW91dCA9IF9vcHRpb25zX2lmcmFtZUxvYWRUaW1lb3V0ID09PSB2b2lkIDAgPyA1ZTMgOiBfb3B0aW9uc19pZnJhbWVMb2FkVGltZW91dCwgb25TdHlsZXNoZWV0TG9hZCA9IG9wdGlvbnMub25TdHlsZXNoZWV0TG9hZCwgX29wdGlvbnNfc3R5bGVzaGVldExvYWRUaW1lb3V0ID0gb3B0aW9ucy5zdHlsZXNoZWV0TG9hZFRpbWVvdXQsIHN0eWxlc2hlZXRMb2FkVGltZW91dCA9IF9vcHRpb25zX3N0eWxlc2hlZXRMb2FkVGltZW91dCA9PT0gdm9pZCAwID8gNWUzIDogX29wdGlvbnNfc3R5bGVzaGVldExvYWRUaW1lb3V0LCBfb3B0aW9uc19rZWVwSWZyYW1lU3JjRm4gPSBvcHRpb25zLmtlZXBJZnJhbWVTcmNGbiwga2VlcElmcmFtZVNyY0ZuID0gX29wdGlvbnNfa2VlcElmcmFtZVNyY0ZuID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gOiBfb3B0aW9uc19rZWVwSWZyYW1lU3JjRm4sIF9vcHRpb25zX25ld2x5QWRkZWRFbGVtZW50ID0gb3B0aW9ucy5uZXdseUFkZGVkRWxlbWVudCwgbmV3bHlBZGRlZEVsZW1lbnQgPSBfb3B0aW9uc19uZXdseUFkZGVkRWxlbWVudCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9uc19uZXdseUFkZGVkRWxlbWVudCwgX29wdGlvbnNfY3NzQ2FwdHVyZWQgPSBvcHRpb25zLmNzc0NhcHR1cmVkLCBjc3NDYXB0dXJlZCA9IF9vcHRpb25zX2Nzc0NhcHR1cmVkID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zX2Nzc0NhcHR1cmVkO1xuICAgIHZhciBuZWVkc01hc2sgPSBvcHRpb25zLm5lZWRzTWFzaztcbiAgICB2YXIgX29wdGlvbnNfcHJlc2VydmVXaGl0ZVNwYWNlID0gb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlU3BhY2UsIHByZXNlcnZlV2hpdGVTcGFjZSA9IF9vcHRpb25zX3ByZXNlcnZlV2hpdGVTcGFjZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zX3ByZXNlcnZlV2hpdGVTcGFjZTtcbiAgICBpZiAoIW5lZWRzTWFzaykge1xuICAgICAgICB2YXIgY2hlY2tBbmNlc3RvcnMgPSBuZWVkc01hc2sgPT09IHZvaWQgMDtcbiAgICAgICAgbmVlZHNNYXNrID0gbmVlZE1hc2tpbmdUZXh0KG4yLCBtYXNrVGV4dENsYXNzLCBtYXNrVGV4dFNlbGVjdG9yLCBjaGVja0FuY2VzdG9ycyk7XG4gICAgfVxuICAgIHZhciBfc2VyaWFsaXplZE5vZGUgPSBzZXJpYWxpemVOb2RlKG4yLCB7XG4gICAgICAgIGRvYzogZG9jLFxuICAgICAgICBtaXJyb3I6IG1pcnJvcjIsXG4gICAgICAgIGJsb2NrQ2xhc3M6IGJsb2NrQ2xhc3MsXG4gICAgICAgIGJsb2NrU2VsZWN0b3I6IGJsb2NrU2VsZWN0b3IsXG4gICAgICAgIG5lZWRzTWFzazogbmVlZHNNYXNrLFxuICAgICAgICBpbmxpbmVTdHlsZXNoZWV0OiBpbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiBtYXNrSW5wdXRPcHRpb25zLFxuICAgICAgICBtYXNrVGV4dEZuOiBtYXNrVGV4dEZuLFxuICAgICAgICBtYXNrSW5wdXRGbjogbWFza0lucHV0Rm4sXG4gICAgICAgIGRhdGFVUkxPcHRpb25zOiBkYXRhVVJMT3B0aW9ucyxcbiAgICAgICAgaW5saW5lSW1hZ2VzOiBpbmxpbmVJbWFnZXMsXG4gICAgICAgIHJlY29yZENhbnZhczogcmVjb3JkQ2FudmFzLFxuICAgICAgICBrZWVwSWZyYW1lU3JjRm46IGtlZXBJZnJhbWVTcmNGbixcbiAgICAgICAgbmV3bHlBZGRlZEVsZW1lbnQ6IG5ld2x5QWRkZWRFbGVtZW50LFxuICAgICAgICBjc3NDYXB0dXJlZDogY3NzQ2FwdHVyZWRcbiAgICB9KTtcbiAgICBpZiAoIV9zZXJpYWxpemVkTm9kZSkge1xuICAgICAgICBjb25zb2xlLndhcm4objIsIFwibm90IHNlcmlhbGl6ZWRcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgaWQ7XG4gICAgaWYgKG1pcnJvcjIuaGFzTm9kZShuMikpIHtcbiAgICAgICAgaWQgPSBtaXJyb3IyLmdldElkKG4yKTtcbiAgICB9IGVsc2UgaWYgKHNsaW1ET01FeGNsdWRlZChfc2VyaWFsaXplZE5vZGUsIHNsaW1ET01PcHRpb25zKSB8fCAhcHJlc2VydmVXaGl0ZVNwYWNlICYmIF9zZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZSQzLlRleHQgJiYgIV9zZXJpYWxpemVkTm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nbSwgXCJcIikubGVuZ3RoKSB7XG4gICAgICAgIGlkID0gSUdOT1JFRF9OT0RFO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlkID0gZ2VuSWQoKTtcbiAgICB9XG4gICAgdmFyIHNlcmlhbGl6ZWROb2RlID0gT2JqZWN0LmFzc2lnbihfc2VyaWFsaXplZE5vZGUsIHtcbiAgICAgICAgaWQ6IGlkXG4gICAgfSk7XG4gICAgbWlycm9yMi5hZGQobjIsIHNlcmlhbGl6ZWROb2RlKTtcbiAgICBpZiAoaWQgPT09IElHTk9SRURfTk9ERSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKG9uU2VyaWFsaXplKSB7XG4gICAgICAgIG9uU2VyaWFsaXplKG4yKTtcbiAgICB9XG4gICAgdmFyIHJlY29yZENoaWxkID0gIXNraXBDaGlsZDtcbiAgICBpZiAoc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUkMy5FbGVtZW50KSB7XG4gICAgICAgIHJlY29yZENoaWxkID0gcmVjb3JkQ2hpbGQgJiYgIXNlcmlhbGl6ZWROb2RlLm5lZWRCbG9jaztcbiAgICAgICAgZGVsZXRlIHNlcmlhbGl6ZWROb2RlLm5lZWRCbG9jaztcbiAgICAgICAgdmFyIHNoYWRvd1Jvb3RFbCA9IGluZGV4JDEuc2hhZG93Um9vdChuMik7XG4gICAgICAgIGlmIChzaGFkb3dSb290RWwgJiYgaXNOYXRpdmVTaGFkb3dEb20oc2hhZG93Um9vdEVsKSkgc2VyaWFsaXplZE5vZGUuaXNTaGFkb3dIb3N0ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKChzZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZSQzLkRvY3VtZW50IHx8IHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlJDMuRWxlbWVudCkgJiYgcmVjb3JkQ2hpbGQpIHtcbiAgICAgICAgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRXaGl0ZXNwYWNlICYmIHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlJDMuRWxlbWVudCAmJiBzZXJpYWxpemVkTm9kZS50YWdOYW1lID09PSBcImhlYWRcIikge1xuICAgICAgICAgICAgcHJlc2VydmVXaGl0ZVNwYWNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ5cGFzc09wdGlvbnMgPSB7XG4gICAgICAgICAgICBkb2M6IGRvYyxcbiAgICAgICAgICAgIG1pcnJvcjogbWlycm9yMixcbiAgICAgICAgICAgIGJsb2NrQ2xhc3M6IGJsb2NrQ2xhc3MsXG4gICAgICAgICAgICBibG9ja1NlbGVjdG9yOiBibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgbmVlZHNNYXNrOiBuZWVkc01hc2ssXG4gICAgICAgICAgICBtYXNrVGV4dENsYXNzOiBtYXNrVGV4dENsYXNzLFxuICAgICAgICAgICAgbWFza1RleHRTZWxlY3RvcjogbWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgICAgIHNraXBDaGlsZDogc2tpcENoaWxkLFxuICAgICAgICAgICAgaW5saW5lU3R5bGVzaGVldDogaW5saW5lU3R5bGVzaGVldCxcbiAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnM6IG1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICAgICAgICBtYXNrVGV4dEZuOiBtYXNrVGV4dEZuLFxuICAgICAgICAgICAgbWFza0lucHV0Rm46IG1hc2tJbnB1dEZuLFxuICAgICAgICAgICAgc2xpbURPTU9wdGlvbnM6IHNsaW1ET01PcHRpb25zLFxuICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnM6IGRhdGFVUkxPcHRpb25zLFxuICAgICAgICAgICAgaW5saW5lSW1hZ2VzOiBpbmxpbmVJbWFnZXMsXG4gICAgICAgICAgICByZWNvcmRDYW52YXM6IHJlY29yZENhbnZhcyxcbiAgICAgICAgICAgIHByZXNlcnZlV2hpdGVTcGFjZTogcHJlc2VydmVXaGl0ZVNwYWNlLFxuICAgICAgICAgICAgb25TZXJpYWxpemU6IG9uU2VyaWFsaXplLFxuICAgICAgICAgICAgb25JZnJhbWVMb2FkOiBvbklmcmFtZUxvYWQsXG4gICAgICAgICAgICBpZnJhbWVMb2FkVGltZW91dDogaWZyYW1lTG9hZFRpbWVvdXQsXG4gICAgICAgICAgICBvblN0eWxlc2hlZXRMb2FkOiBvblN0eWxlc2hlZXRMb2FkLFxuICAgICAgICAgICAgc3R5bGVzaGVldExvYWRUaW1lb3V0OiBzdHlsZXNoZWV0TG9hZFRpbWVvdXQsXG4gICAgICAgICAgICBrZWVwSWZyYW1lU3JjRm46IGtlZXBJZnJhbWVTcmNGbixcbiAgICAgICAgICAgIGNzc0NhcHR1cmVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUkMy5FbGVtZW50ICYmIHNlcmlhbGl6ZWROb2RlLnRhZ05hbWUgPT09IFwidGV4dGFyZWFcIiAmJiBzZXJpYWxpemVkTm9kZS5hdHRyaWJ1dGVzLnZhbHVlICE9PSB2b2lkIDApIDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUkMy5FbGVtZW50ICYmIHNlcmlhbGl6ZWROb2RlLmF0dHJpYnV0ZXMuX2Nzc1RleHQgIT09IHZvaWQgMCAmJiB0eXBlb2Ygc2VyaWFsaXplZE5vZGUuYXR0cmlidXRlcy5fY3NzVGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGJ5cGFzc09wdGlvbnMuY3NzQ2FwdHVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UoQXJyYXkuZnJvbShpbmRleCQxLmNoaWxkTm9kZXMobjIpKSksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGROID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZWRDaGlsZE5vZGUgPSBzZXJpYWxpemVOb2RlV2l0aElkKGNoaWxkTiwgYnlwYXNzT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZWRDaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplZE5vZGUuY2hpbGROb2Rlcy5wdXNoKHNlcmlhbGl6ZWRDaGlsZE5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgc2hhZG93Um9vdEVsMSA9IG51bGw7XG4gICAgICAgIGlmIChpc0VsZW1lbnQobjIpICYmIChzaGFkb3dSb290RWwxID0gaW5kZXgkMS5zaGFkb3dSb290KG4yKSkpIHtcbiAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yMSA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShBcnJheS5mcm9tKGluZGV4JDEuY2hpbGROb2RlcyhzaGFkb3dSb290RWwxKSkpLCBfc3RlcDE7ICEoX3N0ZXAxID0gX2l0ZXJhdG9yMSgpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkTjEgPSBfc3RlcDEudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZWRDaGlsZE5vZGUxID0gc2VyaWFsaXplTm9kZVdpdGhJZChjaGlsZE4xLCBieXBhc3NPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VyaWFsaXplZENoaWxkTm9kZTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNOYXRpdmVTaGFkb3dEb20oc2hhZG93Um9vdEVsMSkgJiYgKHNlcmlhbGl6ZWRDaGlsZE5vZGUxLmlzU2hhZG93ID0gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROb2RlLmNoaWxkTm9kZXMucHVzaChzZXJpYWxpemVkQ2hpbGROb2RlMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBwYXJlbnQgPSBpbmRleCQxLnBhcmVudE5vZGUobjIpO1xuICAgIGlmIChwYXJlbnQgJiYgaXNTaGFkb3dSb290KHBhcmVudCkgJiYgaXNOYXRpdmVTaGFkb3dEb20ocGFyZW50KSkge1xuICAgICAgICBzZXJpYWxpemVkTm9kZS5pc1NoYWRvdyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChzZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZSQzLkVsZW1lbnQgJiYgc2VyaWFsaXplZE5vZGUudGFnTmFtZSA9PT0gXCJpZnJhbWVcIikge1xuICAgICAgICBvbmNlSWZyYW1lTG9hZGVkKG4yLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpZnJhbWVEb2MgPSBuMi5jb250ZW50RG9jdW1lbnQ7XG4gICAgICAgICAgICBpZiAoaWZyYW1lRG9jICYmIG9uSWZyYW1lTG9hZCkge1xuICAgICAgICAgICAgICAgIHZhciBzZXJpYWxpemVkSWZyYW1lTm9kZSA9IHNlcmlhbGl6ZU5vZGVXaXRoSWQoaWZyYW1lRG9jLCB7XG4gICAgICAgICAgICAgICAgICAgIGRvYzogaWZyYW1lRG9jLFxuICAgICAgICAgICAgICAgICAgICBtaXJyb3I6IG1pcnJvcjIsXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrQ2xhc3M6IGJsb2NrQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrU2VsZWN0b3I6IGJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgICAgIG5lZWRzTWFzazogbmVlZHNNYXNrLFxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dENsYXNzOiBtYXNrVGV4dENsYXNzLFxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yOiBtYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgICBza2lwQ2hpbGQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0OiBpbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiBtYXNrSW5wdXRPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dEZuOiBtYXNrVGV4dEZuLFxuICAgICAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbjogbWFza0lucHV0Rm4sXG4gICAgICAgICAgICAgICAgICAgIHNsaW1ET01PcHRpb25zOiBzbGltRE9NT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnM6IGRhdGFVUkxPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBpbmxpbmVJbWFnZXM6IGlubGluZUltYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkQ2FudmFzOiByZWNvcmRDYW52YXMsXG4gICAgICAgICAgICAgICAgICAgIHByZXNlcnZlV2hpdGVTcGFjZTogcHJlc2VydmVXaGl0ZVNwYWNlLFxuICAgICAgICAgICAgICAgICAgICBvblNlcmlhbGl6ZTogb25TZXJpYWxpemUsXG4gICAgICAgICAgICAgICAgICAgIG9uSWZyYW1lTG9hZDogb25JZnJhbWVMb2FkLFxuICAgICAgICAgICAgICAgICAgICBpZnJhbWVMb2FkVGltZW91dDogaWZyYW1lTG9hZFRpbWVvdXQsXG4gICAgICAgICAgICAgICAgICAgIG9uU3R5bGVzaGVldExvYWQ6IG9uU3R5bGVzaGVldExvYWQsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc2hlZXRMb2FkVGltZW91dDogc3R5bGVzaGVldExvYWRUaW1lb3V0LFxuICAgICAgICAgICAgICAgICAgICBrZWVwSWZyYW1lU3JjRm46IGtlZXBJZnJhbWVTcmNGblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzZXJpYWxpemVkSWZyYW1lTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBvbklmcmFtZUxvYWQobjIsIHNlcmlhbGl6ZWRJZnJhbWVOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGlmcmFtZUxvYWRUaW1lb3V0KTtcbiAgICB9XG4gICAgaWYgKHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlJDMuRWxlbWVudCAmJiBzZXJpYWxpemVkTm9kZS50YWdOYW1lID09PSBcImxpbmtcIiAmJiB0eXBlb2Ygc2VyaWFsaXplZE5vZGUuYXR0cmlidXRlcy5yZWwgPT09IFwic3RyaW5nXCIgJiYgKHNlcmlhbGl6ZWROb2RlLmF0dHJpYnV0ZXMucmVsID09PSBcInN0eWxlc2hlZXRcIiB8fCBzZXJpYWxpemVkTm9kZS5hdHRyaWJ1dGVzLnJlbCA9PT0gXCJwcmVsb2FkXCIgJiYgdHlwZW9mIHNlcmlhbGl6ZWROb2RlLmF0dHJpYnV0ZXMuaHJlZiA9PT0gXCJzdHJpbmdcIiAmJiBleHRyYWN0RmlsZUV4dGVuc2lvbihzZXJpYWxpemVkTm9kZS5hdHRyaWJ1dGVzLmhyZWYpID09PSBcImNzc1wiKSkge1xuICAgICAgICBvbmNlU3R5bGVzaGVldExvYWRlZChuMiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAob25TdHlsZXNoZWV0TG9hZCkge1xuICAgICAgICAgICAgICAgIHZhciBzZXJpYWxpemVkTGlua05vZGUgPSBzZXJpYWxpemVOb2RlV2l0aElkKG4yLCB7XG4gICAgICAgICAgICAgICAgICAgIGRvYzogZG9jLFxuICAgICAgICAgICAgICAgICAgICBtaXJyb3I6IG1pcnJvcjIsXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrQ2xhc3M6IGJsb2NrQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrU2VsZWN0b3I6IGJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgICAgIG5lZWRzTWFzazogbmVlZHNNYXNrLFxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dENsYXNzOiBtYXNrVGV4dENsYXNzLFxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yOiBtYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgICBza2lwQ2hpbGQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0OiBpbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiBtYXNrSW5wdXRPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dEZuOiBtYXNrVGV4dEZuLFxuICAgICAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbjogbWFza0lucHV0Rm4sXG4gICAgICAgICAgICAgICAgICAgIHNsaW1ET01PcHRpb25zOiBzbGltRE9NT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnM6IGRhdGFVUkxPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBpbmxpbmVJbWFnZXM6IGlubGluZUltYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkQ2FudmFzOiByZWNvcmRDYW52YXMsXG4gICAgICAgICAgICAgICAgICAgIHByZXNlcnZlV2hpdGVTcGFjZTogcHJlc2VydmVXaGl0ZVNwYWNlLFxuICAgICAgICAgICAgICAgICAgICBvblNlcmlhbGl6ZTogb25TZXJpYWxpemUsXG4gICAgICAgICAgICAgICAgICAgIG9uSWZyYW1lTG9hZDogb25JZnJhbWVMb2FkLFxuICAgICAgICAgICAgICAgICAgICBpZnJhbWVMb2FkVGltZW91dDogaWZyYW1lTG9hZFRpbWVvdXQsXG4gICAgICAgICAgICAgICAgICAgIG9uU3R5bGVzaGVldExvYWQ6IG9uU3R5bGVzaGVldExvYWQsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc2hlZXRMb2FkVGltZW91dDogc3R5bGVzaGVldExvYWRUaW1lb3V0LFxuICAgICAgICAgICAgICAgICAgICBrZWVwSWZyYW1lU3JjRm46IGtlZXBJZnJhbWVTcmNGblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzZXJpYWxpemVkTGlua05vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgb25TdHlsZXNoZWV0TG9hZChuMiwgc2VyaWFsaXplZExpbmtOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHN0eWxlc2hlZXRMb2FkVGltZW91dCk7XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkTm9kZTtcbn1cbmZ1bmN0aW9uIHNuYXBzaG90KG4yLCBvcHRpb25zKSB7XG4gICAgdmFyIF9yZWYgPSBvcHRpb25zIHx8IHt9LCB0bXAgPSBfcmVmLm1pcnJvciwgbWlycm9yMiA9IHRtcCA9PT0gdm9pZCAwID8gbmV3IE1pcnJvcigpIDogdG1wLCBfcmVmX2Jsb2NrQ2xhc3MgPSBfcmVmLmJsb2NrQ2xhc3MsIGJsb2NrQ2xhc3MgPSBfcmVmX2Jsb2NrQ2xhc3MgPT09IHZvaWQgMCA/IFwicnItYmxvY2tcIiA6IF9yZWZfYmxvY2tDbGFzcywgX3JlZl9ibG9ja1NlbGVjdG9yID0gX3JlZi5ibG9ja1NlbGVjdG9yLCBibG9ja1NlbGVjdG9yID0gX3JlZl9ibG9ja1NlbGVjdG9yID09PSB2b2lkIDAgPyBudWxsIDogX3JlZl9ibG9ja1NlbGVjdG9yLCBfcmVmX21hc2tUZXh0Q2xhc3MgPSBfcmVmLm1hc2tUZXh0Q2xhc3MsIG1hc2tUZXh0Q2xhc3MgPSBfcmVmX21hc2tUZXh0Q2xhc3MgPT09IHZvaWQgMCA/IFwicnItbWFza1wiIDogX3JlZl9tYXNrVGV4dENsYXNzLCBfcmVmX21hc2tUZXh0U2VsZWN0b3IgPSBfcmVmLm1hc2tUZXh0U2VsZWN0b3IsIG1hc2tUZXh0U2VsZWN0b3IgPSBfcmVmX21hc2tUZXh0U2VsZWN0b3IgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmX21hc2tUZXh0U2VsZWN0b3IsIF9yZWZfaW5saW5lU3R5bGVzaGVldCA9IF9yZWYuaW5saW5lU3R5bGVzaGVldCwgaW5saW5lU3R5bGVzaGVldCA9IF9yZWZfaW5saW5lU3R5bGVzaGVldCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWZfaW5saW5lU3R5bGVzaGVldCwgX3JlZl9pbmxpbmVJbWFnZXMgPSBfcmVmLmlubGluZUltYWdlcywgaW5saW5lSW1hZ2VzID0gX3JlZl9pbmxpbmVJbWFnZXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZl9pbmxpbmVJbWFnZXMsIF9yZWZfcmVjb3JkQ2FudmFzID0gX3JlZi5yZWNvcmRDYW52YXMsIHJlY29yZENhbnZhcyA9IF9yZWZfcmVjb3JkQ2FudmFzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWZfcmVjb3JkQ2FudmFzLCBfcmVmX21hc2tBbGxJbnB1dHMgPSBfcmVmLm1hc2tBbGxJbnB1dHMsIG1hc2tBbGxJbnB1dHMgPSBfcmVmX21hc2tBbGxJbnB1dHMgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZl9tYXNrQWxsSW5wdXRzLCBtYXNrVGV4dEZuID0gX3JlZi5tYXNrVGV4dEZuLCBtYXNrSW5wdXRGbiA9IF9yZWYubWFza0lucHV0Rm4sIF9yZWZfc2xpbURPTSA9IF9yZWYuc2xpbURPTSwgc2xpbURPTSA9IF9yZWZfc2xpbURPTSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmX3NsaW1ET00sIGRhdGFVUkxPcHRpb25zID0gX3JlZi5kYXRhVVJMT3B0aW9ucywgcHJlc2VydmVXaGl0ZVNwYWNlID0gX3JlZi5wcmVzZXJ2ZVdoaXRlU3BhY2UsIG9uU2VyaWFsaXplID0gX3JlZi5vblNlcmlhbGl6ZSwgb25JZnJhbWVMb2FkID0gX3JlZi5vbklmcmFtZUxvYWQsIGlmcmFtZUxvYWRUaW1lb3V0ID0gX3JlZi5pZnJhbWVMb2FkVGltZW91dCwgb25TdHlsZXNoZWV0TG9hZCA9IF9yZWYub25TdHlsZXNoZWV0TG9hZCwgc3R5bGVzaGVldExvYWRUaW1lb3V0ID0gX3JlZi5zdHlsZXNoZWV0TG9hZFRpbWVvdXQsIF9yZWZfa2VlcElmcmFtZVNyY0ZuID0gX3JlZi5rZWVwSWZyYW1lU3JjRm4sIGtlZXBJZnJhbWVTcmNGbiA9IF9yZWZfa2VlcElmcmFtZVNyY0ZuID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gOiBfcmVmX2tlZXBJZnJhbWVTcmNGbjtcbiAgICB2YXIgbWFza0lucHV0T3B0aW9ucyA9IG1hc2tBbGxJbnB1dHMgPT09IHRydWUgPyB7XG4gICAgICAgIGNvbG9yOiB0cnVlLFxuICAgICAgICBkYXRlOiB0cnVlLFxuICAgICAgICBcImRhdGV0aW1lLWxvY2FsXCI6IHRydWUsXG4gICAgICAgIGVtYWlsOiB0cnVlLFxuICAgICAgICBtb250aDogdHJ1ZSxcbiAgICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgICByYW5nZTogdHJ1ZSxcbiAgICAgICAgc2VhcmNoOiB0cnVlLFxuICAgICAgICB0ZWw6IHRydWUsXG4gICAgICAgIHRleHQ6IHRydWUsXG4gICAgICAgIHRpbWU6IHRydWUsXG4gICAgICAgIHVybDogdHJ1ZSxcbiAgICAgICAgd2VlazogdHJ1ZSxcbiAgICAgICAgdGV4dGFyZWE6IHRydWUsXG4gICAgICAgIHNlbGVjdDogdHJ1ZSxcbiAgICAgICAgcGFzc3dvcmQ6IHRydWUsXG4gICAgICAgIGhpZGRlbjogdHJ1ZVxuICAgIH0gOiBtYXNrQWxsSW5wdXRzID09PSBmYWxzZSA/IHtcbiAgICAgICAgcGFzc3dvcmQ6IHRydWVcbiAgICB9IDogbWFza0FsbElucHV0cztcbiAgICB2YXIgc2xpbURPTU9wdGlvbnMgPSBzbGltRE9NID09PSB0cnVlIHx8IHNsaW1ET00gPT09IFwiYWxsXCIgPyAvLyBpZiB0cnVlOiBzZXQgb2Ygc2Vuc2libGUgb3B0aW9ucyB0aGF0IHNob3VsZCBub3QgdGhyb3cgYXdheSBhbnkgaW5mb3JtYXRpb25cbiAgICB7XG4gICAgICAgIHNjcmlwdDogdHJ1ZSxcbiAgICAgICAgY29tbWVudDogdHJ1ZSxcbiAgICAgICAgaGVhZEZhdmljb246IHRydWUsXG4gICAgICAgIGhlYWRXaGl0ZXNwYWNlOiB0cnVlLFxuICAgICAgICBoZWFkTWV0YURlc2NLZXl3b3Jkczogc2xpbURPTSA9PT0gXCJhbGxcIixcbiAgICAgICAgLy8gZGVzdHJ1Y3RpdmVcbiAgICAgICAgaGVhZE1ldGFTb2NpYWw6IHRydWUsXG4gICAgICAgIGhlYWRNZXRhUm9ib3RzOiB0cnVlLFxuICAgICAgICBoZWFkTWV0YUh0dHBFcXVpdjogdHJ1ZSxcbiAgICAgICAgaGVhZE1ldGFBdXRob3JzaGlwOiB0cnVlLFxuICAgICAgICBoZWFkTWV0YVZlcmlmaWNhdGlvbjogdHJ1ZVxuICAgIH0gOiBzbGltRE9NID09PSBmYWxzZSA/IHt9IDogc2xpbURPTTtcbiAgICByZXR1cm4gc2VyaWFsaXplTm9kZVdpdGhJZChuMiwge1xuICAgICAgICBkb2M6IG4yLFxuICAgICAgICBtaXJyb3I6IG1pcnJvcjIsXG4gICAgICAgIGJsb2NrQ2xhc3M6IGJsb2NrQ2xhc3MsXG4gICAgICAgIGJsb2NrU2VsZWN0b3I6IGJsb2NrU2VsZWN0b3IsXG4gICAgICAgIG1hc2tUZXh0Q2xhc3M6IG1hc2tUZXh0Q2xhc3MsXG4gICAgICAgIG1hc2tUZXh0U2VsZWN0b3I6IG1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICAgIHNraXBDaGlsZDogZmFsc2UsXG4gICAgICAgIGlubGluZVN0eWxlc2hlZXQ6IGlubGluZVN0eWxlc2hlZXQsXG4gICAgICAgIG1hc2tJbnB1dE9wdGlvbnM6IG1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICAgIG1hc2tUZXh0Rm46IG1hc2tUZXh0Rm4sXG4gICAgICAgIG1hc2tJbnB1dEZuOiBtYXNrSW5wdXRGbixcbiAgICAgICAgc2xpbURPTU9wdGlvbnM6IHNsaW1ET01PcHRpb25zLFxuICAgICAgICBkYXRhVVJMT3B0aW9uczogZGF0YVVSTE9wdGlvbnMsXG4gICAgICAgIGlubGluZUltYWdlczogaW5saW5lSW1hZ2VzLFxuICAgICAgICByZWNvcmRDYW52YXM6IHJlY29yZENhbnZhcyxcbiAgICAgICAgcHJlc2VydmVXaGl0ZVNwYWNlOiBwcmVzZXJ2ZVdoaXRlU3BhY2UsXG4gICAgICAgIG9uU2VyaWFsaXplOiBvblNlcmlhbGl6ZSxcbiAgICAgICAgb25JZnJhbWVMb2FkOiBvbklmcmFtZUxvYWQsXG4gICAgICAgIGlmcmFtZUxvYWRUaW1lb3V0OiBpZnJhbWVMb2FkVGltZW91dCxcbiAgICAgICAgb25TdHlsZXNoZWV0TG9hZDogb25TdHlsZXNoZWV0TG9hZCxcbiAgICAgICAgc3R5bGVzaGVldExvYWRUaW1lb3V0OiBzdHlsZXNoZWV0TG9hZFRpbWVvdXQsXG4gICAgICAgIGtlZXBJZnJhbWVTcmNGbjoga2VlcElmcmFtZVNyY0ZuLFxuICAgICAgICBuZXdseUFkZGVkRWxlbWVudDogZmFsc2VcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzJDEoeDIpIHtcbiAgICByZXR1cm4geDIgJiYgeDIuX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeDIsIFwiZGVmYXVsdFwiKSA/IHgyW1wiZGVmYXVsdFwiXSA6IHgyO1xufVxuZnVuY3Rpb24gZ2V0QXVnbWVudGVkTmFtZXNwYWNlJDEobjIpIHtcbiAgICBpZiAobjIuX19lc01vZHVsZSkgcmV0dXJuIG4yO1xuICAgIHZhciBmMiA9IG4yLmRlZmF1bHQ7XG4gICAgaWYgKHR5cGVvZiBmMiA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFyIGEyID0gZnVuY3Rpb24gYTIyKCkge1xuICAgICAgICAgICAgaWYgKF9pbnN0YW5jZW9mKHRoaXMsIGEyMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5jb25zdHJ1Y3QoZjIsIGFyZ3VtZW50cywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgICAgYTIucHJvdG90eXBlID0gZjIucHJvdG90eXBlO1xuICAgIH0gZWxzZSBhMiA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhMiwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3Qua2V5cyhuMikuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuMiwgayk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhMiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuMltrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGEyO1xufVxudmFyIHBpY29jb2xvcnNfYnJvd3NlciQxID0ge1xuICAgIGV4cG9ydHM6IHt9XG59O1xudmFyIHgkMSA9IFN0cmluZztcbnZhciBjcmVhdGUkMSA9IGZ1bmN0aW9uIGNyZWF0ZSQxKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlzQ29sb3JTdXBwb3J0ZWQ6IGZhbHNlLFxuICAgICAgICByZXNldDogeCQxLFxuICAgICAgICBib2xkOiB4JDEsXG4gICAgICAgIGRpbTogeCQxLFxuICAgICAgICBpdGFsaWM6IHgkMSxcbiAgICAgICAgdW5kZXJsaW5lOiB4JDEsXG4gICAgICAgIGludmVyc2U6IHgkMSxcbiAgICAgICAgaGlkZGVuOiB4JDEsXG4gICAgICAgIHN0cmlrZXRocm91Z2g6IHgkMSxcbiAgICAgICAgYmxhY2s6IHgkMSxcbiAgICAgICAgcmVkOiB4JDEsXG4gICAgICAgIGdyZWVuOiB4JDEsXG4gICAgICAgIHllbGxvdzogeCQxLFxuICAgICAgICBibHVlOiB4JDEsXG4gICAgICAgIG1hZ2VudGE6IHgkMSxcbiAgICAgICAgY3lhbjogeCQxLFxuICAgICAgICB3aGl0ZTogeCQxLFxuICAgICAgICBncmF5OiB4JDEsXG4gICAgICAgIGJnQmxhY2s6IHgkMSxcbiAgICAgICAgYmdSZWQ6IHgkMSxcbiAgICAgICAgYmdHcmVlbjogeCQxLFxuICAgICAgICBiZ1llbGxvdzogeCQxLFxuICAgICAgICBiZ0JsdWU6IHgkMSxcbiAgICAgICAgYmdNYWdlbnRhOiB4JDEsXG4gICAgICAgIGJnQ3lhbjogeCQxLFxuICAgICAgICBiZ1doaXRlOiB4JDFcbiAgICB9O1xufTtcbnBpY29jb2xvcnNfYnJvd3NlciQxLmV4cG9ydHMgPSBjcmVhdGUkMSgpO1xucGljb2NvbG9yc19icm93c2VyJDEuZXhwb3J0cy5jcmVhdGVDb2xvcnMgPSBjcmVhdGUkMTtcbnZhciBwaWNvY29sb3JzX2Jyb3dzZXJFeHBvcnRzJDEgPSBwaWNvY29sb3JzX2Jyb3dzZXIkMS5leHBvcnRzO1xudmFyIF9fdml0ZUJyb3dzZXJFeHRlcm5hbCQyID0ge307XG52YXIgX192aXRlQnJvd3NlckV4dGVybmFsJDEkMSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBkZWZhdWx0OiBfX3ZpdGVCcm93c2VyRXh0ZXJuYWwkMlxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgdmFsdWU6IFwiTW9kdWxlXCJcbn0pKTtcbnZhciByZXF1aXJlJCQyJDEgPSAvKiBAX19QVVJFX18gKi8gZ2V0QXVnbWVudGVkTmFtZXNwYWNlJDEoX192aXRlQnJvd3NlckV4dGVybmFsJDEkMSk7XG52YXIgcGljbyQxID0gcGljb2NvbG9yc19icm93c2VyRXhwb3J0cyQxO1xudmFyIHRlcm1pbmFsSGlnaGxpZ2h0JDEkMSA9IHJlcXVpcmUkJDIkMTtcbnZhciBDc3NTeW50YXhFcnJvciQzJDEgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKEVycm9yMSkge1xuICAgIF9pbmhlcml0cyhDc3NTeW50YXhFcnJvciwgRXJyb3IxKTtcbiAgICBmdW5jdGlvbiBDc3NTeW50YXhFcnJvcihtZXNzYWdlLCBsaW5lLCBjb2x1bW4sIHNvdXJjZSwgZmlsZSwgcGx1Z2luMjIpIHtcbiAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICBfdGhpcyA9IEVycm9yMS5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSBcIkNzc1N5bnRheEVycm9yXCI7XG4gICAgICAgIF90aGlzLnJlYXNvbiA9IG1lc3NhZ2U7XG4gICAgICAgIGlmIChmaWxlKSB7XG4gICAgICAgICAgICBfdGhpcy5maWxlID0gZmlsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBfdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBsdWdpbjIyKSB7XG4gICAgICAgICAgICBfdGhpcy5wbHVnaW4gPSBwbHVnaW4yMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGxpbmUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGNvbHVtbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaW5lID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubGluZSA9IGxpbmU7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29sdW1uID0gY29sdW1uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5saW5lID0gbGluZS5saW5lO1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbHVtbiA9IGxpbmUuY29sdW1uO1xuICAgICAgICAgICAgICAgIF90aGlzLmVuZExpbmUgPSBjb2x1bW4ubGluZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbmRDb2x1bW4gPSBjb2x1bW4uY29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF90aGlzLnNldE1lc3NhZ2UoKTtcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfdGhpcywgQ3NzU3ludGF4RXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IENzc1N5bnRheEVycm9yLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uc2V0TWVzc2FnZSA9IGZ1bmN0aW9uIHNldE1lc3NhZ2UoKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHRoaXMucGx1Z2luID8gdGhpcy5wbHVnaW4gKyBcIjogXCIgOiBcIlwiO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgKz0gdGhpcy5maWxlID8gdGhpcy5maWxlIDogXCI8Y3NzIGlucHV0PlwiO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMubGluZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlICs9IFwiOlwiICsgdGhpcy5saW5lICsgXCI6XCIgKyB0aGlzLmNvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lc3NhZ2UgKz0gXCI6IFwiICsgdGhpcy5yZWFzb247XG4gICAgfTtcbiAgICBfcHJvdG8uc2hvd1NvdXJjZUNvZGUgPSBmdW5jdGlvbiBzaG93U291cmNlQ29kZShjb2xvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuc291cmNlKSByZXR1cm4gXCJcIjtcbiAgICAgICAgdmFyIGNzcyA9IHRoaXMuc291cmNlO1xuICAgICAgICBpZiAoY29sb3IgPT0gbnVsbCkgY29sb3IgPSBwaWNvJDEuaXNDb2xvclN1cHBvcnRlZDtcbiAgICAgICAgaWYgKHRlcm1pbmFsSGlnaGxpZ2h0JDEkMSkge1xuICAgICAgICAgICAgaWYgKGNvbG9yKSBjc3MgPSB0ZXJtaW5hbEhpZ2hsaWdodCQxJDEoY3NzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGluZXMgPSBjc3Muc3BsaXQoL1xccj9cXG4vKTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgodGhpcy5saW5lIC0gMywgMCk7XG4gICAgICAgIHZhciBlbmQgPSBNYXRoLm1pbih0aGlzLmxpbmUgKyAyLCBsaW5lcy5sZW5ndGgpO1xuICAgICAgICB2YXIgbWF4V2lkdGggPSBTdHJpbmcoZW5kKS5sZW5ndGg7XG4gICAgICAgIHZhciBtYXJrLCBhc2lkZTtcbiAgICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgICAgICB2YXIgX3BpY28kMV9jcmVhdGVDb2xvcnMgPSBwaWNvJDEuY3JlYXRlQ29sb3JzKHRydWUpLCBib2xkID0gX3BpY28kMV9jcmVhdGVDb2xvcnMuYm9sZCwgZ3JheSA9IF9waWNvJDFfY3JlYXRlQ29sb3JzLmdyYXksIHJlZCA9IF9waWNvJDFfY3JlYXRlQ29sb3JzLnJlZDtcbiAgICAgICAgICAgIG1hcmsgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJvbGQocmVkKHRleHQpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhc2lkZSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ3JheSh0ZXh0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXJrID0gYXNpZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZXMuc2xpY2Uoc3RhcnQsIGVuZCkubWFwKGZ1bmN0aW9uKGxpbmUsIGluZGV4Mikge1xuICAgICAgICAgICAgdmFyIG51bWJlciA9IHN0YXJ0ICsgMSArIGluZGV4MjtcbiAgICAgICAgICAgIHZhciBndXR0ZXIgPSBcIiBcIiArIChcIiBcIiArIG51bWJlcikuc2xpY2UoLW1heFdpZHRoKSArIFwiIHwgXCI7XG4gICAgICAgICAgICBpZiAobnVtYmVyID09PSBfdGhpcy5saW5lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNwYWNpbmcgPSBhc2lkZShndXR0ZXIucmVwbGFjZSgvXFxkL2csIFwiIFwiKSkgKyBsaW5lLnNsaWNlKDAsIF90aGlzLmNvbHVtbiAtIDEpLnJlcGxhY2UoL1teXFx0XS9nLCBcIiBcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcmsoXCI+XCIpICsgYXNpZGUoZ3V0dGVyKSArIGxpbmUgKyBcIlxcbiBcIiArIHNwYWNpbmcgKyBtYXJrKFwiXlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBcIiBcIiArIGFzaWRlKGd1dHRlcikgKyBsaW5lO1xuICAgICAgICB9KS5qb2luKFwiXFxuXCIpO1xuICAgIH07XG4gICAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHZhciBjb2RlID0gdGhpcy5zaG93U291cmNlQ29kZSgpO1xuICAgICAgICBpZiAoY29kZSkge1xuICAgICAgICAgICAgY29kZSA9IFwiXFxuXFxuXCIgKyBjb2RlICsgXCJcXG5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgXCI6IFwiICsgdGhpcy5tZXNzYWdlICsgY29kZTtcbiAgICB9O1xuICAgIHJldHVybiBDc3NTeW50YXhFcnJvcjtcbn0oX3dyYXBfbmF0aXZlX3N1cGVyKEVycm9yKSk7XG52YXIgY3NzU3ludGF4RXJyb3IkMSA9IENzc1N5bnRheEVycm9yJDMkMTtcbkNzc1N5bnRheEVycm9yJDMkMS5kZWZhdWx0ID0gQ3NzU3ludGF4RXJyb3IkMyQxO1xudmFyIHN5bWJvbHMkMSA9IHt9O1xuc3ltYm9scyQxLmlzQ2xlYW4gPSBTeW1ib2woXCJpc0NsZWFuXCIpO1xuc3ltYm9scyQxLm15ID0gU3ltYm9sKFwibXlcIik7XG52YXIgREVGQVVMVF9SQVckMSA9IHtcbiAgICBhZnRlcjogXCJcXG5cIixcbiAgICBiZWZvcmVDbG9zZTogXCJcXG5cIixcbiAgICBiZWZvcmVDb21tZW50OiBcIlxcblwiLFxuICAgIGJlZm9yZURlY2w6IFwiXFxuXCIsXG4gICAgYmVmb3JlT3BlbjogXCIgXCIsXG4gICAgYmVmb3JlUnVsZTogXCJcXG5cIixcbiAgICBjb2xvbjogXCI6IFwiLFxuICAgIGNvbW1lbnRMZWZ0OiBcIiBcIixcbiAgICBjb21tZW50UmlnaHQ6IFwiIFwiLFxuICAgIGVtcHR5Qm9keTogXCJcIixcbiAgICBpbmRlbnQ6IFwiICAgIFwiLFxuICAgIHNlbWljb2xvbjogZmFsc2Vcbn07XG5mdW5jdGlvbiBjYXBpdGFsaXplJDEoc3RyKSB7XG4gICAgcmV0dXJuIHN0clswXS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufVxudmFyIFN0cmluZ2lmaWVyJDIkMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gU3RyaW5naWZpZXIoYnVpbGRlcikge1xuICAgICAgICB0aGlzLmJ1aWxkZXIgPSBidWlsZGVyO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gU3RyaW5naWZpZXIucHJvdG90eXBlO1xuICAgIF9wcm90by5hdHJ1bGUgPSBmdW5jdGlvbiBhdHJ1bGUobm9kZTIsIHNlbWljb2xvbikge1xuICAgICAgICB2YXIgbmFtZSA9IFwiQFwiICsgbm9kZTIubmFtZTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IG5vZGUyLnBhcmFtcyA/IHRoaXMucmF3VmFsdWUobm9kZTIsIFwicGFyYW1zXCIpIDogXCJcIjtcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlMi5yYXdzLmFmdGVyTmFtZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbmFtZSArPSBub2RlMi5yYXdzLmFmdGVyTmFtZTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICAgIG5hbWUgKz0gXCIgXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUyLm5vZGVzKSB7XG4gICAgICAgICAgICB0aGlzLmJsb2NrKG5vZGUyLCBuYW1lICsgcGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBlbmQgPSAobm9kZTIucmF3cy5iZXR3ZWVuIHx8IFwiXCIpICsgKHNlbWljb2xvbiA/IFwiO1wiIDogXCJcIik7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkZXIobmFtZSArIHBhcmFtcyArIGVuZCwgbm9kZTIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uYmVmb3JlQWZ0ZXIgPSBmdW5jdGlvbiBiZWZvcmVBZnRlcihub2RlMiwgZGV0ZWN0KSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgaWYgKG5vZGUyLnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImJlZm9yZURlY2xcIik7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZTIudHlwZSA9PT0gXCJjb21tZW50XCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZTIsIG51bGwsIFwiYmVmb3JlQ29tbWVudFwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChkZXRlY3QgPT09IFwiYmVmb3JlXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZTIsIG51bGwsIFwiYmVmb3JlUnVsZVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZTIsIG51bGwsIFwiYmVmb3JlQ2xvc2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ1ZiA9IG5vZGUyLnBhcmVudDtcbiAgICAgICAgdmFyIGRlcHRoID0gMDtcbiAgICAgICAgd2hpbGUoYnVmICYmIGJ1Zi50eXBlICE9PSBcInJvb3RcIil7XG4gICAgICAgICAgICBkZXB0aCArPSAxO1xuICAgICAgICAgICAgYnVmID0gYnVmLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgICAgICAgIHZhciBpbmRlbnQgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJpbmRlbnRcIik7XG4gICAgICAgICAgICBpZiAoaW5kZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgc3RlcCA9IDA7IHN0ZXAgPCBkZXB0aDsgc3RlcCsrKXZhbHVlICs9IGluZGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8uYmxvY2sgPSBmdW5jdGlvbiBibG9jayhub2RlMiwgc3RhcnQpIHtcbiAgICAgICAgdmFyIGJldHdlZW4gPSB0aGlzLnJhdyhub2RlMiwgXCJiZXR3ZWVuXCIsIFwiYmVmb3JlT3BlblwiKTtcbiAgICAgICAgdGhpcy5idWlsZGVyKHN0YXJ0ICsgYmV0d2VlbiArIFwie1wiLCBub2RlMiwgXCJzdGFydFwiKTtcbiAgICAgICAgdmFyIGFmdGVyO1xuICAgICAgICBpZiAobm9kZTIubm9kZXMgJiYgbm9kZTIubm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmJvZHkobm9kZTIpO1xuICAgICAgICAgICAgYWZ0ZXIgPSB0aGlzLnJhdyhub2RlMiwgXCJhZnRlclwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFmdGVyID0gdGhpcy5yYXcobm9kZTIsIFwiYWZ0ZXJcIiwgXCJlbXB0eUJvZHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFmdGVyKSB0aGlzLmJ1aWxkZXIoYWZ0ZXIpO1xuICAgICAgICB0aGlzLmJ1aWxkZXIoXCJ9XCIsIG5vZGUyLCBcImVuZFwiKTtcbiAgICB9O1xuICAgIF9wcm90by5ib2R5ID0gZnVuY3Rpb24gYm9keShub2RlMikge1xuICAgICAgICB2YXIgbGFzdCA9IG5vZGUyLm5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlKGxhc3QgPiAwKXtcbiAgICAgICAgICAgIGlmIChub2RlMi5ub2Rlc1tsYXN0XS50eXBlICE9PSBcImNvbW1lbnRcIikgYnJlYWs7XG4gICAgICAgICAgICBsYXN0IC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbWljb2xvbiA9IHRoaXMucmF3KG5vZGUyLCBcInNlbWljb2xvblwiKTtcbiAgICAgICAgZm9yKHZhciBpMiA9IDA7IGkyIDwgbm9kZTIubm9kZXMubGVuZ3RoOyBpMisrKXtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGUyLm5vZGVzW2kyXTtcbiAgICAgICAgICAgIHZhciBiZWZvcmUgPSB0aGlzLnJhdyhjaGlsZCwgXCJiZWZvcmVcIik7XG4gICAgICAgICAgICBpZiAoYmVmb3JlKSB0aGlzLmJ1aWxkZXIoYmVmb3JlKTtcbiAgICAgICAgICAgIHRoaXMuc3RyaW5naWZ5KGNoaWxkLCBsYXN0ICE9PSBpMiB8fCBzZW1pY29sb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uY29tbWVudCA9IGZ1bmN0aW9uIGNvbW1lbnQobm9kZTIpIHtcbiAgICAgICAgdmFyIGxlZnQgPSB0aGlzLnJhdyhub2RlMiwgXCJsZWZ0XCIsIFwiY29tbWVudExlZnRcIik7XG4gICAgICAgIHZhciByaWdodCA9IHRoaXMucmF3KG5vZGUyLCBcInJpZ2h0XCIsIFwiY29tbWVudFJpZ2h0XCIpO1xuICAgICAgICB0aGlzLmJ1aWxkZXIoXCIvKlwiICsgbGVmdCArIG5vZGUyLnRleHQgKyByaWdodCArIFwiKi9cIiwgbm9kZTIpO1xuICAgIH07XG4gICAgX3Byb3RvLmRlY2wgPSBmdW5jdGlvbiBkZWNsKG5vZGUyLCBzZW1pY29sb24pIHtcbiAgICAgICAgdmFyIGJldHdlZW4gPSB0aGlzLnJhdyhub2RlMiwgXCJiZXR3ZWVuXCIsIFwiY29sb25cIik7XG4gICAgICAgIHZhciBzdHJpbmcgPSBub2RlMi5wcm9wICsgYmV0d2VlbiArIHRoaXMucmF3VmFsdWUobm9kZTIsIFwidmFsdWVcIik7XG4gICAgICAgIGlmIChub2RlMi5pbXBvcnRhbnQpIHtcbiAgICAgICAgICAgIHN0cmluZyArPSBub2RlMi5yYXdzLmltcG9ydGFudCB8fCBcIiAhaW1wb3J0YW50XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbWljb2xvbikgc3RyaW5nICs9IFwiO1wiO1xuICAgICAgICB0aGlzLmJ1aWxkZXIoc3RyaW5nLCBub2RlMik7XG4gICAgfTtcbiAgICBfcHJvdG8uZG9jdW1lbnQgPSBmdW5jdGlvbiBkb2N1bWVudDEobm9kZTIpIHtcbiAgICAgICAgdGhpcy5ib2R5KG5vZGUyKTtcbiAgICB9O1xuICAgIF9wcm90by5yYXcgPSBmdW5jdGlvbiByYXcobm9kZTIsIG93biwgZGV0ZWN0KSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgaWYgKCFkZXRlY3QpIGRldGVjdCA9IG93bjtcbiAgICAgICAgaWYgKG93bikge1xuICAgICAgICAgICAgdmFsdWUgPSBub2RlMi5yYXdzW293bl07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcmVudCA9IG5vZGUyLnBhcmVudDtcbiAgICAgICAgaWYgKGRldGVjdCA9PT0gXCJiZWZvcmVcIikge1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50LnR5cGUgPT09IFwicm9vdFwiICYmIHBhcmVudC5maXJzdCA9PT0gbm9kZTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LnR5cGUgPT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50KSByZXR1cm4gREVGQVVMVF9SQVckMVtkZXRlY3RdO1xuICAgICAgICB2YXIgcm9vdDIgPSBub2RlMi5yb290KCk7XG4gICAgICAgIGlmICghcm9vdDIucmF3Q2FjaGUpIHJvb3QyLnJhd0NhY2hlID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygcm9vdDIucmF3Q2FjaGVbZGV0ZWN0XSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHJvb3QyLnJhd0NhY2hlW2RldGVjdF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRldGVjdCA9PT0gXCJiZWZvcmVcIiB8fCBkZXRlY3QgPT09IFwiYWZ0ZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlQWZ0ZXIobm9kZTIsIGRldGVjdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gXCJyYXdcIiArIGNhcGl0YWxpemUkMShkZXRlY3QpO1xuICAgICAgICAgICAgaWYgKHRoaXNbbWV0aG9kXSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpc1ttZXRob2RdKHJvb3QyLCBub2RlMik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvb3QyLndhbGsoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpMi5yYXdzW293bl07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB2YWx1ZSA9IERFRkFVTFRfUkFXJDFbZGV0ZWN0XTtcbiAgICAgICAgcm9vdDIucmF3Q2FjaGVbZGV0ZWN0XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3QmVmb3JlQ2xvc2UgPSBmdW5jdGlvbiByYXdCZWZvcmVDbG9zZShyb290Mikge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHJvb3QyLndhbGsoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIGlmIChpMi5ub2RlcyAmJiBpMi5ub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpMi5yYXdzLmFmdGVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaTIucmF3cy5hZnRlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1teXFxuXSskLywgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh2YWx1ZSkgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFMvZywgXCJcIik7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5yYXdCZWZvcmVDb21tZW50ID0gZnVuY3Rpb24gcmF3QmVmb3JlQ29tbWVudChyb290Miwgbm9kZTIpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICByb290Mi53YWxrQ29tbWVudHMoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5iZWZvcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYmVmb3JlO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1teXFxuXSskLywgXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZTIsIG51bGwsIFwiYmVmb3JlRGVjbFwiKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFMvZywgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJhd0JlZm9yZURlY2wgPSBmdW5jdGlvbiByYXdCZWZvcmVEZWNsKHJvb3QyLCBub2RlMikge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHJvb3QyLndhbGtEZWNscyhmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpMi5yYXdzLmJlZm9yZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gaTIucmF3cy5iZWZvcmU7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW15cXG5dKyQvLCBcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJiZWZvcmVSdWxlXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcUy9nLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3QmVmb3JlT3BlbiA9IGZ1bmN0aW9uIHJhd0JlZm9yZU9wZW4ocm9vdDIpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICByb290Mi53YWxrKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICBpZiAoaTIudHlwZSAhPT0gXCJkZWNsXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYmV0d2VlbjtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3QmVmb3JlUnVsZSA9IGZ1bmN0aW9uIHJhd0JlZm9yZVJ1bGUocm9vdDIpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICByb290Mi53YWxrKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICBpZiAoaTIubm9kZXMgJiYgKGkyLnBhcmVudCAhPT0gcm9vdDIgfHwgcm9vdDIuZmlyc3QgIT09IGkyKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5iZWZvcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpMi5yYXdzLmJlZm9yZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1teXFxuXSskLywgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh2YWx1ZSkgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFMvZywgXCJcIik7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5yYXdDb2xvbiA9IGZ1bmN0aW9uIHJhd0NvbG9uKHJvb3QyKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgcm9vdDIud2Fsa0RlY2xzKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmV0d2VlbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gaTIucmF3cy5iZXR3ZWVuLnJlcGxhY2UoL1teXFxzOl0vZywgXCJcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJhd0VtcHR5Qm9keSA9IGZ1bmN0aW9uIHJhd0VtcHR5Qm9keShyb290Mikge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHJvb3QyLndhbGsoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIGlmIChpMi5ub2RlcyAmJiBpMi5ub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYWZ0ZXI7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJhd0luZGVudCA9IGZ1bmN0aW9uIHJhd0luZGVudChyb290Mikge1xuICAgICAgICBpZiAocm9vdDIucmF3cy5pbmRlbnQpIHJldHVybiByb290Mi5yYXdzLmluZGVudDtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICByb290Mi53YWxrKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICB2YXIgcCA9IGkyLnBhcmVudDtcbiAgICAgICAgICAgIGlmIChwICYmIHAgIT09IHJvb3QyICYmIHAucGFyZW50ICYmIHAucGFyZW50ID09PSByb290Mikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5iZWZvcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gaTIucmF3cy5iZWZvcmUuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxTL2csIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJhd1NlbWljb2xvbiA9IGZ1bmN0aW9uIHJhd1NlbWljb2xvbihyb290Mikge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHJvb3QyLndhbGsoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIGlmIChpMi5ub2RlcyAmJiBpMi5ub2Rlcy5sZW5ndGggJiYgaTIubGFzdC50eXBlID09PSBcImRlY2xcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gaTIucmF3cy5zZW1pY29sb247XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJhd1ZhbHVlID0gZnVuY3Rpb24gcmF3VmFsdWUobm9kZTIsIHByb3ApIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbm9kZTJbcHJvcF07XG4gICAgICAgIHZhciByYXcgPSBub2RlMi5yYXdzW3Byb3BdO1xuICAgICAgICBpZiAocmF3ICYmIHJhdy52YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiByYXcucmF3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5yb290ID0gZnVuY3Rpb24gcm9vdChub2RlMikge1xuICAgICAgICB0aGlzLmJvZHkobm9kZTIpO1xuICAgICAgICBpZiAobm9kZTIucmF3cy5hZnRlcikgdGhpcy5idWlsZGVyKG5vZGUyLnJhd3MuYWZ0ZXIpO1xuICAgIH07XG4gICAgX3Byb3RvLnJ1bGUgPSBmdW5jdGlvbiBydWxlKG5vZGUyKSB7XG4gICAgICAgIHRoaXMuYmxvY2sobm9kZTIsIHRoaXMucmF3VmFsdWUobm9kZTIsIFwic2VsZWN0b3JcIikpO1xuICAgICAgICBpZiAobm9kZTIucmF3cy5vd25TZW1pY29sb24pIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRlcihub2RlMi5yYXdzLm93blNlbWljb2xvbiwgbm9kZTIsIFwiZW5kXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uc3RyaW5naWZ5ID0gZnVuY3Rpb24gc3RyaW5naWZ5KG5vZGUyLCBzZW1pY29sb24pIHtcbiAgICAgICAgaWYgKCF0aGlzW25vZGUyLnR5cGVdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIEFTVCBub2RlIHR5cGUgXCIgKyBub2RlMi50eXBlICsgXCIuIE1heWJlIHlvdSBuZWVkIHRvIGNoYW5nZSBQb3N0Q1NTIHN0cmluZ2lmaWVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW25vZGUyLnR5cGVdKG5vZGUyLCBzZW1pY29sb24pO1xuICAgIH07XG4gICAgcmV0dXJuIFN0cmluZ2lmaWVyO1xufSgpO1xudmFyIHN0cmluZ2lmaWVyJDEgPSBTdHJpbmdpZmllciQyJDE7XG5TdHJpbmdpZmllciQyJDEuZGVmYXVsdCA9IFN0cmluZ2lmaWVyJDIkMTtcbnZhciBTdHJpbmdpZmllciQxJDEgPSBzdHJpbmdpZmllciQxO1xuZnVuY3Rpb24gc3RyaW5naWZ5JDQkMShub2RlMiwgYnVpbGRlcikge1xuICAgIHZhciBzdHIgPSBuZXcgU3RyaW5naWZpZXIkMSQxKGJ1aWxkZXIpO1xuICAgIHN0ci5zdHJpbmdpZnkobm9kZTIpO1xufVxudmFyIHN0cmluZ2lmeV8xJDEgPSBzdHJpbmdpZnkkNCQxO1xuc3RyaW5naWZ5JDQkMS5kZWZhdWx0ID0gc3RyaW5naWZ5JDQkMTtcbnZhciBpc0NsZWFuJDIkMSA9IHN5bWJvbHMkMS5pc0NsZWFuLCBteSQyJDEgPSBzeW1ib2xzJDEubXk7XG52YXIgQ3NzU3ludGF4RXJyb3IkMiQxID0gY3NzU3ludGF4RXJyb3IkMTtcbnZhciBTdHJpbmdpZmllcjIkMSA9IHN0cmluZ2lmaWVyJDE7XG52YXIgc3RyaW5naWZ5JDMkMSA9IHN0cmluZ2lmeV8xJDE7XG5mdW5jdGlvbiBjbG9uZU5vZGUkMShvYmosIHBhcmVudCkge1xuICAgIHZhciBjbG9uZWQgPSBuZXcgb2JqLmNvbnN0cnVjdG9yKCk7XG4gICAgZm9yKHZhciBpMiBpbiBvYmope1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkyKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkyID09PSBcInByb3h5Q2FjaGVcIikgY29udGludWU7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9ialtpMl07XG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKHZhbHVlKTtcbiAgICAgICAgaWYgKGkyID09PSBcInBhcmVudFwiICYmIHR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQpIGNsb25lZFtpMl0gPSBwYXJlbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaTIgPT09IFwic291cmNlXCIpIHtcbiAgICAgICAgICAgIGNsb25lZFtpMl0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgY2xvbmVkW2kyXSA9IHZhbHVlLm1hcChmdW5jdGlvbihqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lTm9kZSQxKGosIGNsb25lZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB2YWx1ZSA9IGNsb25lTm9kZSQxKHZhbHVlKTtcbiAgICAgICAgICAgIGNsb25lZFtpMl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xvbmVkO1xufVxudmFyIE5vZGUkNCQxID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBOb2RlMihkZWZhdWx0cykge1xuICAgICAgICBpZiAoZGVmYXVsdHMgPT09IHZvaWQgMCkgZGVmYXVsdHMgPSB7fTtcbiAgICAgICAgdGhpcy5yYXdzID0ge307XG4gICAgICAgIHRoaXNbaXNDbGVhbiQyJDFdID0gZmFsc2U7XG4gICAgICAgIHRoaXNbbXkkMiQxXSA9IHRydWU7XG4gICAgICAgIGZvcih2YXIgbmFtZSBpbiBkZWZhdWx0cyl7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJub2Rlc1wiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKGRlZmF1bHRzW25hbWVdKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZTIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlMi5jbG9uZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZChub2RlMi5jbG9uZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kKG5vZGUyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1tuYW1lXSA9IGRlZmF1bHRzW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBOb2RlMi5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmFkZFRvRXJyb3IgPSBmdW5jdGlvbiBhZGRUb0Vycm9yKGVycm9yKSB7XG4gICAgICAgIGVycm9yLnBvc3Rjc3NOb2RlID0gdGhpcztcbiAgICAgICAgaWYgKGVycm9yLnN0YWNrICYmIHRoaXMuc291cmNlICYmIC9cXG5cXHN7NH1hdCAvLnRlc3QoZXJyb3Iuc3RhY2spKSB7XG4gICAgICAgICAgICB2YXIgczIgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgICAgIGVycm9yLnN0YWNrID0gZXJyb3Iuc3RhY2sucmVwbGFjZSgvXFxuXFxzezR9YXQgLywgXCIkJlwiICsgczIuaW5wdXQuZnJvbSArIFwiOlwiICsgczIuc3RhcnQubGluZSArIFwiOlwiICsgczIuc3RhcnQuY29sdW1uICsgXCIkJlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfTtcbiAgICBfcHJvdG8uYWZ0ZXIgPSBmdW5jdGlvbiBhZnRlcihhZGQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QWZ0ZXIodGhpcywgYWRkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8uYXNzaWduID0gZnVuY3Rpb24gYXNzaWduKG92ZXJyaWRlcykge1xuICAgICAgICBpZiAob3ZlcnJpZGVzID09PSB2b2lkIDApIG92ZXJyaWRlcyA9IHt9O1xuICAgICAgICBmb3IodmFyIG5hbWUgaW4gb3ZlcnJpZGVzKXtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSBvdmVycmlkZXNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8uYmVmb3JlID0gZnVuY3Rpb24gYmVmb3JlKGFkZCkge1xuICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUodGhpcywgYWRkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8uY2xlYW5SYXdzID0gZnVuY3Rpb24gY2xlYW5SYXdzKGtlZXBCZXR3ZWVuKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnJhd3MuYmVmb3JlO1xuICAgICAgICBkZWxldGUgdGhpcy5yYXdzLmFmdGVyO1xuICAgICAgICBpZiAoIWtlZXBCZXR3ZWVuKSBkZWxldGUgdGhpcy5yYXdzLmJldHdlZW47XG4gICAgfTtcbiAgICBfcHJvdG8uY2xvbmUgPSBmdW5jdGlvbiBjbG9uZShvdmVycmlkZXMpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlcyA9PT0gdm9pZCAwKSBvdmVycmlkZXMgPSB7fTtcbiAgICAgICAgdmFyIGNsb25lZCA9IGNsb25lTm9kZSQxKHRoaXMpO1xuICAgICAgICBmb3IodmFyIG5hbWUgaW4gb3ZlcnJpZGVzKXtcbiAgICAgICAgICAgIGNsb25lZFtuYW1lXSA9IG92ZXJyaWRlc1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xvbmVkO1xuICAgIH07XG4gICAgX3Byb3RvLmNsb25lQWZ0ZXIgPSBmdW5jdGlvbiBjbG9uZUFmdGVyKG92ZXJyaWRlcykge1xuICAgICAgICBpZiAob3ZlcnJpZGVzID09PSB2b2lkIDApIG92ZXJyaWRlcyA9IHt9O1xuICAgICAgICB2YXIgY2xvbmVkID0gdGhpcy5jbG9uZShvdmVycmlkZXMpO1xuICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRBZnRlcih0aGlzLCBjbG9uZWQpO1xuICAgICAgICByZXR1cm4gY2xvbmVkO1xuICAgIH07XG4gICAgX3Byb3RvLmNsb25lQmVmb3JlID0gZnVuY3Rpb24gY2xvbmVCZWZvcmUob3ZlcnJpZGVzKSB7XG4gICAgICAgIGlmIChvdmVycmlkZXMgPT09IHZvaWQgMCkgb3ZlcnJpZGVzID0ge307XG4gICAgICAgIHZhciBjbG9uZWQgPSB0aGlzLmNsb25lKG92ZXJyaWRlcyk7XG4gICAgICAgIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLCBjbG9uZWQpO1xuICAgICAgICByZXR1cm4gY2xvbmVkO1xuICAgIH07XG4gICAgX3Byb3RvLmVycm9yID0gZnVuY3Rpb24gZXJyb3IobWVzc2FnZSwgb3B0cykge1xuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSBvcHRzID0ge307XG4gICAgICAgIGlmICh0aGlzLnNvdXJjZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzX3JhbmdlQnkgPSB0aGlzLnJhbmdlQnkob3B0cyksIGVuZCA9IF90aGlzX3JhbmdlQnkuZW5kLCBzdGFydCA9IF90aGlzX3JhbmdlQnkuc3RhcnQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2UuaW5wdXQuZXJyb3IobWVzc2FnZSwge1xuICAgICAgICAgICAgICAgIGNvbHVtbjogc3RhcnQuY29sdW1uLFxuICAgICAgICAgICAgICAgIGxpbmU6IHN0YXJ0LmxpbmVcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IGVuZC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgbGluZTogZW5kLmxpbmVcbiAgICAgICAgICAgIH0sIG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ3NzU3ludGF4RXJyb3IkMiQxKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgX3Byb3RvLmdldFByb3h5UHJvY2Vzc29yID0gZnVuY3Rpb24gZ2V0UHJveHlQcm9jZXNzb3IoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldChub2RlMiwgcHJvcCkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSBcInByb3h5T2ZcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBcInJvb3RcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTIucm9vdCgpLnRvUHJveHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTJbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KG5vZGUyLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlMltwcm9wXSA9PT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIG5vZGUyW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgPT09IFwicHJvcFwiIHx8IHByb3AgPT09IFwidmFsdWVcIiB8fCBwcm9wID09PSBcIm5hbWVcIiB8fCBwcm9wID09PSBcInBhcmFtc1wiIHx8IHByb3AgPT09IFwiaW1wb3J0YW50XCIgfHwgLyogYzggaWdub3JlIG5leHQgKi8gcHJvcCA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTIubWFya0RpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLm1hcmtEaXJ0eSA9IGZ1bmN0aW9uIG1hcmtEaXJ0eSgpIHtcbiAgICAgICAgaWYgKHRoaXNbaXNDbGVhbiQyJDFdKSB7XG4gICAgICAgICAgICB0aGlzW2lzQ2xlYW4kMiQxXSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIG5leHQgPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUobmV4dCA9IG5leHQucGFyZW50KXtcbiAgICAgICAgICAgICAgICBuZXh0W2lzQ2xlYW4kMiQxXSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ubmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHJldHVybiB2b2lkIDA7XG4gICAgICAgIHZhciBpbmRleDIgPSB0aGlzLnBhcmVudC5pbmRleCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm5vZGVzW2luZGV4MiArIDFdO1xuICAgIH07XG4gICAgX3Byb3RvLnBvc2l0aW9uQnkgPSBmdW5jdGlvbiBwb3NpdGlvbkJ5KG9wdHMsIHN0cmluZ1JlcHJlc2VudGF0aW9uKSB7XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnNvdXJjZS5zdGFydDtcbiAgICAgICAgaWYgKG9wdHMuaW5kZXgpIHtcbiAgICAgICAgICAgIHBvcyA9IHRoaXMucG9zaXRpb25JbnNpZGUob3B0cy5pbmRleCwgc3RyaW5nUmVwcmVzZW50YXRpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdHMud29yZCkge1xuICAgICAgICAgICAgc3RyaW5nUmVwcmVzZW50YXRpb24gPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB2YXIgaW5kZXgyID0gc3RyaW5nUmVwcmVzZW50YXRpb24uaW5kZXhPZihvcHRzLndvcmQpO1xuICAgICAgICAgICAgaWYgKGluZGV4MiAhPT0gLTEpIHBvcyA9IHRoaXMucG9zaXRpb25JbnNpZGUoaW5kZXgyLCBzdHJpbmdSZXByZXNlbnRhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9O1xuICAgIF9wcm90by5wb3NpdGlvbkluc2lkZSA9IGZ1bmN0aW9uIHBvc2l0aW9uSW5zaWRlKGluZGV4Miwgc3RyaW5nUmVwcmVzZW50YXRpb24pIHtcbiAgICAgICAgdmFyIHN0cmluZyA9IHN0cmluZ1JlcHJlc2VudGF0aW9uIHx8IHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuc291cmNlLnN0YXJ0LmNvbHVtbjtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLnNvdXJjZS5zdGFydC5saW5lO1xuICAgICAgICBmb3IodmFyIGkyID0gMDsgaTIgPCBpbmRleDI7IGkyKyspe1xuICAgICAgICAgICAgaWYgKHN0cmluZ1tpMl0gPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSAxO1xuICAgICAgICAgICAgICAgIGxpbmUgKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29sdW1uICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgICAgICAgbGluZTogbGluZVxuICAgICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLnByZXYgPSBmdW5jdGlvbiBwcmV2KCkge1xuICAgICAgICBpZiAoIXRoaXMucGFyZW50KSByZXR1cm4gdm9pZCAwO1xuICAgICAgICB2YXIgaW5kZXgyID0gdGhpcy5wYXJlbnQuaW5kZXgodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5ub2Rlc1tpbmRleDIgLSAxXTtcbiAgICB9O1xuICAgIF9wcm90by5yYW5nZUJ5ID0gZnVuY3Rpb24gcmFuZ2VCeShvcHRzKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHtcbiAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zb3VyY2Uuc3RhcnQuY29sdW1uLFxuICAgICAgICAgICAgbGluZTogdGhpcy5zb3VyY2Uuc3RhcnQubGluZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5zb3VyY2UuZW5kID8ge1xuICAgICAgICAgICAgY29sdW1uOiB0aGlzLnNvdXJjZS5lbmQuY29sdW1uICsgMSxcbiAgICAgICAgICAgIGxpbmU6IHRoaXMuc291cmNlLmVuZC5saW5lXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgICBjb2x1bW46IHN0YXJ0LmNvbHVtbiArIDEsXG4gICAgICAgICAgICBsaW5lOiBzdGFydC5saW5lXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRzLndvcmQpIHtcbiAgICAgICAgICAgIHZhciBzdHJpbmdSZXByZXNlbnRhdGlvbiA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHZhciBpbmRleDIgPSBzdHJpbmdSZXByZXNlbnRhdGlvbi5pbmRleE9mKG9wdHMud29yZCk7XG4gICAgICAgICAgICBpZiAoaW5kZXgyICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5wb3NpdGlvbkluc2lkZShpbmRleDIsIHN0cmluZ1JlcHJlc2VudGF0aW9uKTtcbiAgICAgICAgICAgICAgICBlbmQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKGluZGV4MiArIG9wdHMud29yZC5sZW5ndGgsIHN0cmluZ1JlcHJlc2VudGF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvcHRzLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbjogb3B0cy5zdGFydC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IG9wdHMuc3RhcnQubGluZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdHMuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMucG9zaXRpb25JbnNpZGUob3B0cy5pbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5lbmQpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbjogb3B0cy5lbmQuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiBvcHRzLmVuZC5saW5lXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdHMuZW5kSW5kZXggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKG9wdHMuZW5kSW5kZXgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRzLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgZW5kID0gdGhpcy5wb3NpdGlvbkluc2lkZShvcHRzLmluZGV4ICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZC5saW5lIDwgc3RhcnQubGluZSB8fCBlbmQubGluZSA9PT0gc3RhcnQubGluZSAmJiBlbmQuY29sdW1uIDw9IHN0YXJ0LmNvbHVtbikge1xuICAgICAgICAgICAgZW5kID0ge1xuICAgICAgICAgICAgICAgIGNvbHVtbjogc3RhcnQuY29sdW1uICsgMSxcbiAgICAgICAgICAgICAgICBsaW5lOiBzdGFydC5saW5lXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydFxuICAgICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLnJhdyA9IGZ1bmN0aW9uIHJhdyhwcm9wLCBkZWZhdWx0VHlwZSkge1xuICAgICAgICB2YXIgc3RyID0gbmV3IFN0cmluZ2lmaWVyMiQxKCk7XG4gICAgICAgIHJldHVybiBzdHIucmF3KHRoaXMsIHByb3AsIGRlZmF1bHRUeXBlKTtcbiAgICB9O1xuICAgIF9wcm90by5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJlbnQgPSB2b2lkIDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLnJlcGxhY2VXaXRoID0gZnVuY3Rpb24gcmVwbGFjZVdpdGgoKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG5vZGVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBub2Rlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBib29rbWFyayA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZm91bmRTZWxmID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShub2RlcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZTIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZTIgPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRTZWxmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZvdW5kU2VsZikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRBZnRlcihib29rbWFyaywgbm9kZTIpO1xuICAgICAgICAgICAgICAgICAgICBib29rbWFyayA9IG5vZGUyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZShib29rbWFyaywgbm9kZTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZm91bmRTZWxmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90by5yb290ID0gZnVuY3Rpb24gcm9vdCgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDIgPSB0aGlzO1xuICAgICAgICB3aGlsZShyZXN1bHQyLnBhcmVudCAmJiByZXN1bHQyLnBhcmVudC50eXBlICE9PSBcImRvY3VtZW50XCIpe1xuICAgICAgICAgICAgcmVzdWx0MiA9IHJlc3VsdDIucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgIH07XG4gICAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTihfLCBpbnB1dHMpIHtcbiAgICAgICAgdmFyIGZpeGVkID0ge307XG4gICAgICAgIHZhciBlbWl0SW5wdXRzID0gaW5wdXRzID09IG51bGw7XG4gICAgICAgIGlucHV0cyA9IGlucHV0cyB8fCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgaW5wdXRzTmV4dEluZGV4ID0gMDtcbiAgICAgICAgZm9yKHZhciBuYW1lIGluIHRoaXMpe1xuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgbmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lID09PSBcInBhcmVudFwiIHx8IG5hbWUgPT09IFwicHJveHlDYWNoZVwiKSBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXNbbmFtZV07XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmaXhlZFtuYW1lXSA9IHZhbHVlLm1hcChmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZiBpMiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihpMikpID09PSBcIm9iamVjdFwiICYmIGkyLnRvSlNPTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkyLnRvSlNPTihudWxsLCBpbnB1dHMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YodmFsdWUpKSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZS50b0pTT04pIHtcbiAgICAgICAgICAgICAgICBmaXhlZFtuYW1lXSA9IHZhbHVlLnRvSlNPTihudWxsLCBpbnB1dHMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSBcInNvdXJjZVwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0SWQgPSBpbnB1dHMuZ2V0KHZhbHVlLmlucHV0KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRJZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0SWQgPSBpbnB1dHNOZXh0SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0cy5zZXQodmFsdWUuaW5wdXQsIGlucHV0c05leHRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0c05leHRJbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaXhlZFtuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZW5kOiB2YWx1ZS5lbmQsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0SWQ6IGlucHV0SWQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB2YWx1ZS5zdGFydFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpeGVkW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVtaXRJbnB1dHMpIHtcbiAgICAgICAgICAgIGZpeGVkLmlucHV0cyA9IFtdLmNvbmNhdChpbnB1dHMua2V5cygpKS5tYXAoZnVuY3Rpb24oaW5wdXQyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0Mi50b0pTT04oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaXhlZDtcbiAgICB9O1xuICAgIF9wcm90by50b1Byb3h5ID0gZnVuY3Rpb24gdG9Qcm94eSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3h5Q2FjaGUpIHtcbiAgICAgICAgICAgIHRoaXMucHJveHlDYWNoZSA9IG5ldyBQcm94eSh0aGlzLCB0aGlzLmdldFByb3h5UHJvY2Vzc29yKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb3h5Q2FjaGU7XG4gICAgfTtcbiAgICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhzdHJpbmdpZmllcjIpIHtcbiAgICAgICAgaWYgKHN0cmluZ2lmaWVyMiA9PT0gdm9pZCAwKSBzdHJpbmdpZmllcjIgPSBzdHJpbmdpZnkkMyQxO1xuICAgICAgICBpZiAoc3RyaW5naWZpZXIyLnN0cmluZ2lmeSkgc3RyaW5naWZpZXIyID0gc3RyaW5naWZpZXIyLnN0cmluZ2lmeTtcbiAgICAgICAgdmFyIHJlc3VsdDIgPSBcIlwiO1xuICAgICAgICBzdHJpbmdpZmllcjIodGhpcywgZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgKz0gaTI7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICB9O1xuICAgIF9wcm90by53YXJuID0gZnVuY3Rpb24gd2FybihyZXN1bHQyLCB0ZXh0LCBvcHRzKSB7XG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgbm9kZTogdGhpc1xuICAgICAgICB9O1xuICAgICAgICBmb3IodmFyIGkyIGluIG9wdHMpZGF0YVtpMl0gPSBvcHRzW2kyXTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDIud2Fybih0ZXh0LCBkYXRhKTtcbiAgICB9O1xuICAgIF9jcmVhdGVfY2xhc3MoTm9kZTIsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInByb3h5T2ZcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIE5vZGUyO1xufSgpO1xudmFyIG5vZGUkMSA9IE5vZGUkNCQxO1xuTm9kZSQ0JDEuZGVmYXVsdCA9IE5vZGUkNCQxO1xudmFyIE5vZGUkMyQxID0gbm9kZSQxO1xudmFyIERlY2xhcmF0aW9uJDQkMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oTm9kZSQzJDEpIHtcbiAgICBfaW5oZXJpdHMoRGVjbGFyYXRpb24sIE5vZGUkMyQxKTtcbiAgICBmdW5jdGlvbiBEZWNsYXJhdGlvbihkZWZhdWx0cykge1xuICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgIGlmIChkZWZhdWx0cyAmJiB0eXBlb2YgZGVmYXVsdHMudmFsdWUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGRlZmF1bHRzLnZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBkZWZhdWx0cyA9IF9leHRlbmRzKHt9LCBkZWZhdWx0cywge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBTdHJpbmcoZGVmYXVsdHMudmFsdWUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcyA9IE5vZGUkMyQxLmNhbGwodGhpcywgZGVmYXVsdHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSBcImRlY2xcIjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBfY3JlYXRlX2NsYXNzKERlY2xhcmF0aW9uLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJ2YXJpYWJsZVwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcC5zdGFydHNXaXRoKFwiLS1cIikgfHwgdGhpcy5wcm9wWzBdID09PSBcIiRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBEZWNsYXJhdGlvbjtcbn0oTm9kZSQzJDEpO1xudmFyIGRlY2xhcmF0aW9uJDEgPSBEZWNsYXJhdGlvbiQ0JDE7XG5EZWNsYXJhdGlvbiQ0JDEuZGVmYXVsdCA9IERlY2xhcmF0aW9uJDQkMTtcbnZhciB1cmxBbHBoYWJldCQxID0gXCJ1c2VhbmRvbS0yNlQxOTgzNDBQWDc1cHhKQUNLVkVSWU1JTkRCVVNIV09MRl9HUVpiZmdoamtscXZ3eXpyaWN0XCI7XG52YXIgbmFub2lkJDEkMSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICBpZiAoc2l6ZSA9PT0gdm9pZCAwKSBzaXplID0gMjE7XG4gICAgdmFyIGlkID0gXCJcIjtcbiAgICB2YXIgaTIgPSBzaXplO1xuICAgIHdoaWxlKGkyLS0pe1xuICAgICAgICBpZCArPSB1cmxBbHBoYWJldCQxW01hdGgucmFuZG9tKCkgKiA2NCB8IDBdO1xuICAgIH1cbiAgICByZXR1cm4gaWQ7XG59O1xudmFyIG5vblNlY3VyZSQxID0ge1xuICAgIG5hbm9pZDogbmFub2lkJDEkMVxufTtcbnZhciBTb3VyY2VNYXBDb25zdW1lciQyJDEgPSByZXF1aXJlJCQyJDEuU291cmNlTWFwQ29uc3VtZXIsIFNvdXJjZU1hcEdlbmVyYXRvciQyJDEgPSByZXF1aXJlJCQyJDEuU291cmNlTWFwR2VuZXJhdG9yO1xudmFyIGV4aXN0c1N5bmMkMSA9IHJlcXVpcmUkJDIkMS5leGlzdHNTeW5jLCByZWFkRmlsZVN5bmMkMSA9IHJlcXVpcmUkJDIkMS5yZWFkRmlsZVN5bmM7XG52YXIgZGlybmFtZSQxJDEgPSByZXF1aXJlJCQyJDEuZGlybmFtZSwgam9pbiQxID0gcmVxdWlyZSQkMiQxLmpvaW47XG5mdW5jdGlvbiBmcm9tQmFzZTY0JDEoc3RyKSB7XG4gICAgaWYgKEJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oc3RyLCBcImJhc2U2NFwiKS50b1N0cmluZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuYXRvYihzdHIpO1xuICAgIH1cbn1cbnZhciBQcmV2aW91c01hcCQyJDEgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFByZXZpb3VzTWFwKGNzcywgb3B0cykge1xuICAgICAgICBpZiAob3B0cy5tYXAgPT09IGZhbHNlKSByZXR1cm47XG4gICAgICAgIHRoaXMubG9hZEFubm90YXRpb24oY3NzKTtcbiAgICAgICAgdGhpcy5pbmxpbmUgPSB0aGlzLnN0YXJ0V2l0aCh0aGlzLmFubm90YXRpb24sIFwiZGF0YTpcIik7XG4gICAgICAgIHZhciBwcmV2ID0gb3B0cy5tYXAgPyBvcHRzLm1hcC5wcmV2IDogdm9pZCAwO1xuICAgICAgICB2YXIgdGV4dCA9IHRoaXMubG9hZE1hcChvcHRzLmZyb20sIHByZXYpO1xuICAgICAgICBpZiAoIXRoaXMubWFwRmlsZSAmJiBvcHRzLmZyb20pIHtcbiAgICAgICAgICAgIHRoaXMubWFwRmlsZSA9IG9wdHMuZnJvbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXBGaWxlKSB0aGlzLnJvb3QgPSBkaXJuYW1lJDEkMSh0aGlzLm1hcEZpbGUpO1xuICAgICAgICBpZiAodGV4dCkgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFByZXZpb3VzTWFwLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uY29uc3VtZXIgPSBmdW5jdGlvbiBjb25zdW1lcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnN1bWVyQ2FjaGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29uc3VtZXJDYWNoZSA9IG5ldyBTb3VyY2VNYXBDb25zdW1lciQyJDEodGhpcy50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lckNhY2hlO1xuICAgIH07XG4gICAgX3Byb3RvLmRlY29kZUlubGluZSA9IGZ1bmN0aW9uIGRlY29kZUlubGluZSh0ZXh0KSB7XG4gICAgICAgIHZhciBiYXNlQ2hhcnNldFVyaSA9IC9eZGF0YTphcHBsaWNhdGlvblxcL2pzb247Y2hhcnNldD11dGYtPzg7YmFzZTY0LC87XG4gICAgICAgIHZhciBiYXNlVXJpID0gL15kYXRhOmFwcGxpY2F0aW9uXFwvanNvbjtiYXNlNjQsLztcbiAgICAgICAgdmFyIGNoYXJzZXRVcmkgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uO2NoYXJzZXQ9dXRmLT84LC87XG4gICAgICAgIHZhciB1cmkgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uLC87XG4gICAgICAgIGlmIChjaGFyc2V0VXJpLnRlc3QodGV4dCkgfHwgdXJpLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQodGV4dC5zdWJzdHIoUmVnRXhwLmxhc3RNYXRjaC5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFzZUNoYXJzZXRVcmkudGVzdCh0ZXh0KSB8fCBiYXNlVXJpLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tQmFzZTY0JDEodGV4dC5zdWJzdHIoUmVnRXhwLmxhc3RNYXRjaC5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW5jb2RpbmcgPSB0ZXh0Lm1hdGNoKC9kYXRhOmFwcGxpY2F0aW9uXFwvanNvbjsoW14sXSspLC8pWzFdO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBzb3VyY2UgbWFwIGVuY29kaW5nIFwiICsgZW5jb2RpbmcpO1xuICAgIH07XG4gICAgX3Byb3RvLmdldEFubm90YXRpb25VUkwgPSBmdW5jdGlvbiBnZXRBbm5vdGF0aW9uVVJMKHNvdXJjZU1hcFN0cmluZykge1xuICAgICAgICByZXR1cm4gc291cmNlTWFwU3RyaW5nLnJlcGxhY2UoL15cXC9cXCpcXHMqIyBzb3VyY2VNYXBwaW5nVVJMPS8sIFwiXCIpLnRyaW0oKTtcbiAgICB9O1xuICAgIF9wcm90by5pc01hcCA9IGZ1bmN0aW9uIGlzTWFwKG1hcCkge1xuICAgICAgICBpZiAoKHR5cGVvZiBtYXAgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YobWFwKSkgIT09IFwib2JqZWN0XCIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBtYXAubWFwcGluZ3MgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG1hcC5fbWFwcGluZ3MgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheShtYXAuc2VjdGlvbnMpO1xuICAgIH07XG4gICAgX3Byb3RvLmxvYWRBbm5vdGF0aW9uID0gZnVuY3Rpb24gbG9hZEFubm90YXRpb24oY3NzKSB7XG4gICAgICAgIHZhciBjb21tZW50cyA9IGNzcy5tYXRjaCgvXFwvXFwqXFxzKiMgc291cmNlTWFwcGluZ1VSTD0vZ20pO1xuICAgICAgICBpZiAoIWNvbW1lbnRzKSByZXR1cm47XG4gICAgICAgIHZhciBzdGFydCA9IGNzcy5sYXN0SW5kZXhPZihjb21tZW50cy5wb3AoKSk7XG4gICAgICAgIHZhciBlbmQgPSBjc3MuaW5kZXhPZihcIiovXCIsIHN0YXJ0KTtcbiAgICAgICAgaWYgKHN0YXJ0ID4gLTEgJiYgZW5kID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuYW5ub3RhdGlvbiA9IHRoaXMuZ2V0QW5ub3RhdGlvblVSTChjc3Muc3Vic3RyaW5nKHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmxvYWRGaWxlID0gZnVuY3Rpb24gbG9hZEZpbGUocGF0aCkge1xuICAgICAgICB0aGlzLnJvb3QgPSBkaXJuYW1lJDEkMShwYXRoKTtcbiAgICAgICAgaWYgKGV4aXN0c1N5bmMkMShwYXRoKSkge1xuICAgICAgICAgICAgdGhpcy5tYXBGaWxlID0gcGF0aDtcbiAgICAgICAgICAgIHJldHVybiByZWFkRmlsZVN5bmMkMShwYXRoLCBcInV0Zi04XCIpLnRvU3RyaW5nKCkudHJpbSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ubG9hZE1hcCA9IGZ1bmN0aW9uIGxvYWRNYXAoZmlsZSwgcHJldikge1xuICAgICAgICBpZiAocHJldiA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJldiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcHJldiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZQYXRoID0gcHJldihmaWxlKTtcbiAgICAgICAgICAgICAgICBpZiAocHJldlBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hcCA9IHRoaXMubG9hZEZpbGUocHJldlBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGxvYWQgcHJldmlvdXMgc291cmNlIG1hcDogXCIgKyBwcmV2UGF0aC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX2luc3RhbmNlb2YocHJldiwgU291cmNlTWFwQ29uc3VtZXIkMiQxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTb3VyY2VNYXBHZW5lcmF0b3IkMiQxLmZyb21Tb3VyY2VNYXAocHJldikudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX2luc3RhbmNlb2YocHJldiwgU291cmNlTWFwR2VuZXJhdG9yJDIkMSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldi50b1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzTWFwKHByZXYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHByZXYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBwcmV2aW91cyBzb3VyY2UgbWFwIGZvcm1hdDogXCIgKyBwcmV2LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaW5saW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVJbmxpbmUodGhpcy5hbm5vdGF0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmFubm90YXRpb24pIHtcbiAgICAgICAgICAgIHZhciBtYXAxID0gdGhpcy5hbm5vdGF0aW9uO1xuICAgICAgICAgICAgaWYgKGZpbGUpIG1hcDEgPSBqb2luJDEoZGlybmFtZSQxJDEoZmlsZSksIG1hcDEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZEZpbGUobWFwMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5zdGFydFdpdGggPSBmdW5jdGlvbiBzdGFydFdpdGgoc3RyaW5nLCBzdGFydCkge1xuICAgICAgICBpZiAoIXN0cmluZykgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gc3RyaW5nLnN1YnN0cigwLCBzdGFydC5sZW5ndGgpID09PSBzdGFydDtcbiAgICB9O1xuICAgIF9wcm90by53aXRoQ29udGVudCA9IGZ1bmN0aW9uIHdpdGhDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy5jb25zdW1lcigpLnNvdXJjZXNDb250ZW50ICYmIHRoaXMuY29uc3VtZXIoKS5zb3VyY2VzQ29udGVudC5sZW5ndGggPiAwKTtcbiAgICB9O1xuICAgIHJldHVybiBQcmV2aW91c01hcDtcbn0oKTtcbnZhciBwcmV2aW91c01hcCQxID0gUHJldmlvdXNNYXAkMiQxO1xuUHJldmlvdXNNYXAkMiQxLmRlZmF1bHQgPSBQcmV2aW91c01hcCQyJDE7XG52YXIgU291cmNlTWFwQ29uc3VtZXIkMSQxID0gcmVxdWlyZSQkMiQxLlNvdXJjZU1hcENvbnN1bWVyLCBTb3VyY2VNYXBHZW5lcmF0b3IkMSQxID0gcmVxdWlyZSQkMiQxLlNvdXJjZU1hcEdlbmVyYXRvcjtcbnZhciBmaWxlVVJMVG9QYXRoJDEgPSByZXF1aXJlJCQyJDEuZmlsZVVSTFRvUGF0aCwgcGF0aFRvRmlsZVVSTCQxJDEgPSByZXF1aXJlJCQyJDEucGF0aFRvRmlsZVVSTDtcbnZhciBpc0Fic29sdXRlJDEgPSByZXF1aXJlJCQyJDEuaXNBYnNvbHV0ZSwgcmVzb2x2ZSQxJDEgPSByZXF1aXJlJCQyJDEucmVzb2x2ZTtcbnZhciBuYW5vaWQkMiA9IG5vblNlY3VyZSQxLm5hbm9pZDtcbnZhciB0ZXJtaW5hbEhpZ2hsaWdodCQyID0gcmVxdWlyZSQkMiQxO1xudmFyIENzc1N5bnRheEVycm9yJDEkMSA9IGNzc1N5bnRheEVycm9yJDE7XG52YXIgUHJldmlvdXNNYXAkMSQxID0gcHJldmlvdXNNYXAkMTtcbnZhciBmcm9tT2Zmc2V0Q2FjaGUkMSA9IFN5bWJvbChcImZyb21PZmZzZXRDYWNoZVwiKTtcbnZhciBzb3VyY2VNYXBBdmFpbGFibGUkMSQxID0gQm9vbGVhbihTb3VyY2VNYXBDb25zdW1lciQxJDEgJiYgU291cmNlTWFwR2VuZXJhdG9yJDEkMSk7XG52YXIgcGF0aEF2YWlsYWJsZSQxJDEgPSBCb29sZWFuKHJlc29sdmUkMSQxICYmIGlzQWJzb2x1dGUkMSk7XG52YXIgSW5wdXQkNCQxID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBJbnB1dChjc3MsIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgb3B0cyA9IHt9O1xuICAgICAgICBpZiAoY3NzID09PSBudWxsIHx8IHR5cGVvZiBjc3MgPT09IFwidW5kZWZpbmVkXCIgfHwgKHR5cGVvZiBjc3MgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YoY3NzKSkgPT09IFwib2JqZWN0XCIgJiYgIWNzcy50b1N0cmluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9zdENTUyByZWNlaXZlZCBcIiArIGNzcyArIFwiIGluc3RlYWQgb2YgQ1NTIHN0cmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNzcyA9IGNzcy50b1N0cmluZygpO1xuICAgICAgICBpZiAodGhpcy5jc3NbMF0gPT09IFwiXFx1RkVGRlwiIHx8IHRoaXMuY3NzWzBdID09PSBcIu+/vlwiKSB7XG4gICAgICAgICAgICB0aGlzLmhhc0JPTSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNzcyA9IHRoaXMuY3NzLnNsaWNlKDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYXNCT00gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5mcm9tKSB7XG4gICAgICAgICAgICBpZiAoIXBhdGhBdmFpbGFibGUkMSQxIHx8IC9eXFx3KzpcXC9cXC8vLnRlc3Qob3B0cy5mcm9tKSB8fCBpc0Fic29sdXRlJDEob3B0cy5mcm9tKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZSA9IG9wdHMuZnJvbTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlID0gcmVzb2x2ZSQxJDEob3B0cy5mcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aEF2YWlsYWJsZSQxJDEgJiYgc291cmNlTWFwQXZhaWxhYmxlJDEkMSkge1xuICAgICAgICAgICAgdmFyIG1hcCA9IG5ldyBQcmV2aW91c01hcCQxJDEodGhpcy5jc3MsIG9wdHMpO1xuICAgICAgICAgICAgaWYgKG1hcC50ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGUgPSBtYXAuY29uc3VtZXIoKS5maWxlO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5maWxlICYmIGZpbGUpIHRoaXMuZmlsZSA9IHRoaXMubWFwUmVzb2x2ZShmaWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZmlsZSkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IFwiPGlucHV0IGNzcyBcIiArIG5hbm9pZCQyKDYpICsgXCI+XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWFwKSB0aGlzLm1hcC5maWxlID0gdGhpcy5mcm9tO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gSW5wdXQucHJvdG90eXBlO1xuICAgIF9wcm90by5lcnJvciA9IGZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UsIGxpbmUsIGNvbHVtbiwgb3B0cykge1xuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSBvcHRzID0ge307XG4gICAgICAgIHZhciByZXN1bHQyLCBlbmRMaW5lLCBlbmRDb2x1bW47XG4gICAgICAgIGlmIChsaW5lICYmICh0eXBlb2YgbGluZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihsaW5lKSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGxpbmU7XG4gICAgICAgICAgICB2YXIgZW5kID0gY29sdW1uO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGFydC5vZmZzZXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5mcm9tT2Zmc2V0KHN0YXJ0Lm9mZnNldCk7XG4gICAgICAgICAgICAgICAgbGluZSA9IHBvcy5saW5lO1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IHBvcy5jb2w7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBzdGFydC5saW5lO1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IHN0YXJ0LmNvbHVtbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5kLm9mZnNldCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHZhciBwb3MxID0gdGhpcy5mcm9tT2Zmc2V0KGVuZC5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGVuZExpbmUgPSBwb3MxLmxpbmU7XG4gICAgICAgICAgICAgICAgZW5kQ29sdW1uID0gcG9zMS5jb2w7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZExpbmUgPSBlbmQubGluZTtcbiAgICAgICAgICAgICAgICBlbmRDb2x1bW4gPSBlbmQuY29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFjb2x1bW4pIHtcbiAgICAgICAgICAgIHZhciBwb3MyID0gdGhpcy5mcm9tT2Zmc2V0KGxpbmUpO1xuICAgICAgICAgICAgbGluZSA9IHBvczIubGluZTtcbiAgICAgICAgICAgIGNvbHVtbiA9IHBvczIuY29sO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcmlnaW4gPSB0aGlzLm9yaWdpbihsaW5lLCBjb2x1bW4sIGVuZExpbmUsIGVuZENvbHVtbik7XG4gICAgICAgIGlmIChvcmlnaW4pIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBuZXcgQ3NzU3ludGF4RXJyb3IkMSQxKG1lc3NhZ2UsIG9yaWdpbi5lbmRMaW5lID09PSB2b2lkIDAgPyBvcmlnaW4ubGluZSA6IHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IG9yaWdpbi5jb2x1bW4sXG4gICAgICAgICAgICAgICAgbGluZTogb3JpZ2luLmxpbmVcbiAgICAgICAgICAgIH0sIG9yaWdpbi5lbmRMaW5lID09PSB2b2lkIDAgPyBvcmlnaW4uY29sdW1uIDoge1xuICAgICAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luLmVuZENvbHVtbixcbiAgICAgICAgICAgICAgICBsaW5lOiBvcmlnaW4uZW5kTGluZVxuICAgICAgICAgICAgfSwgb3JpZ2luLnNvdXJjZSwgb3JpZ2luLmZpbGUsIG9wdHMucGx1Z2luKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBuZXcgQ3NzU3ludGF4RXJyb3IkMSQxKG1lc3NhZ2UsIGVuZExpbmUgPT09IHZvaWQgMCA/IGxpbmUgOiB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICAgICAgbGluZTogbGluZVxuICAgICAgICAgICAgfSwgZW5kTGluZSA9PT0gdm9pZCAwID8gY29sdW1uIDoge1xuICAgICAgICAgICAgICAgIGNvbHVtbjogZW5kQ29sdW1uLFxuICAgICAgICAgICAgICAgIGxpbmU6IGVuZExpbmVcbiAgICAgICAgICAgIH0sIHRoaXMuY3NzLCB0aGlzLmZpbGUsIG9wdHMucGx1Z2luKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQyLmlucHV0ID0ge1xuICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICBlbmRDb2x1bW46IGVuZENvbHVtbixcbiAgICAgICAgICAgIGVuZExpbmU6IGVuZExpbmUsXG4gICAgICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICAgICAgc291cmNlOiB0aGlzLmNzc1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5maWxlKSB7XG4gICAgICAgICAgICBpZiAocGF0aFRvRmlsZVVSTCQxJDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyLmlucHV0LnVybCA9IHBhdGhUb0ZpbGVVUkwkMSQxKHRoaXMuZmlsZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdDIuaW5wdXQuZmlsZSA9IHRoaXMuZmlsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICB9O1xuICAgIF9wcm90by5mcm9tT2Zmc2V0ID0gZnVuY3Rpb24gZnJvbU9mZnNldChvZmZzZXQpIHtcbiAgICAgICAgdmFyIGxhc3RMaW5lLCBsaW5lVG9JbmRleDtcbiAgICAgICAgaWYgKCF0aGlzW2Zyb21PZmZzZXRDYWNoZSQxXSkge1xuICAgICAgICAgICAgdmFyIGxpbmVzID0gdGhpcy5jc3Muc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICBsaW5lVG9JbmRleCA9IG5ldyBBcnJheShsaW5lcy5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIHByZXZJbmRleCA9IDA7XG4gICAgICAgICAgICBmb3IodmFyIGkyID0gMCwgbDIgPSBsaW5lcy5sZW5ndGg7IGkyIDwgbDI7IGkyKyspe1xuICAgICAgICAgICAgICAgIGxpbmVUb0luZGV4W2kyXSA9IHByZXZJbmRleDtcbiAgICAgICAgICAgICAgICBwcmV2SW5kZXggKz0gbGluZXNbaTJdLmxlbmd0aCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzW2Zyb21PZmZzZXRDYWNoZSQxXSA9IGxpbmVUb0luZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGluZVRvSW5kZXggPSB0aGlzW2Zyb21PZmZzZXRDYWNoZSQxXTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0TGluZSA9IGxpbmVUb0luZGV4W2xpbmVUb0luZGV4Lmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgbWluID0gMDtcbiAgICAgICAgaWYgKG9mZnNldCA+PSBsYXN0TGluZSkge1xuICAgICAgICAgICAgbWluID0gbGluZVRvSW5kZXgubGVuZ3RoIC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtYXggPSBsaW5lVG9JbmRleC5sZW5ndGggLSAyO1xuICAgICAgICAgICAgdmFyIG1pZDtcbiAgICAgICAgICAgIHdoaWxlKG1pbiA8IG1heCl7XG4gICAgICAgICAgICAgICAgbWlkID0gbWluICsgKG1heCAtIG1pbiA+PiAxKTtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDwgbGluZVRvSW5kZXhbbWlkXSkge1xuICAgICAgICAgICAgICAgICAgICBtYXggPSBtaWQgLSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob2Zmc2V0ID49IGxpbmVUb0luZGV4W21pZCArIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IG1pZCArIDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gbWlkO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbDogb2Zmc2V0IC0gbGluZVRvSW5kZXhbbWluXSArIDEsXG4gICAgICAgICAgICBsaW5lOiBtaW4gKyAxXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8ubWFwUmVzb2x2ZSA9IGZ1bmN0aW9uIG1hcFJlc29sdmUoZmlsZSkge1xuICAgICAgICBpZiAoL15cXHcrOlxcL1xcLy8udGVzdChmaWxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUkMSQxKHRoaXMubWFwLmNvbnN1bWVyKCkuc291cmNlUm9vdCB8fCB0aGlzLm1hcC5yb290IHx8IFwiLlwiLCBmaWxlKTtcbiAgICB9O1xuICAgIF9wcm90by5vcmlnaW4gPSBmdW5jdGlvbiBvcmlnaW4obGluZSwgY29sdW1uLCBlbmRMaW5lLCBlbmRDb2x1bW4pIHtcbiAgICAgICAgaWYgKCF0aGlzLm1hcCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgY29uc3VtZXIgPSB0aGlzLm1hcC5jb25zdW1lcigpO1xuICAgICAgICB2YXIgZnJvbSA9IGNvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICBsaW5lOiBsaW5lXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWZyb20uc291cmNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciB0bztcbiAgICAgICAgaWYgKHR5cGVvZiBlbmRMaW5lID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0byA9IGNvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgICAgICAgICAgIGNvbHVtbjogZW5kQ29sdW1uLFxuICAgICAgICAgICAgICAgIGxpbmU6IGVuZExpbmVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmcm9tVXJsO1xuICAgICAgICBpZiAoaXNBYnNvbHV0ZSQxKGZyb20uc291cmNlKSkge1xuICAgICAgICAgICAgZnJvbVVybCA9IHBhdGhUb0ZpbGVVUkwkMSQxKGZyb20uc291cmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyb21VcmwgPSBuZXcgVVJMKGZyb20uc291cmNlLCB0aGlzLm1hcC5jb25zdW1lcigpLnNvdXJjZVJvb3QgfHwgcGF0aFRvRmlsZVVSTCQxJDEodGhpcy5tYXAubWFwRmlsZSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQyID0ge1xuICAgICAgICAgICAgY29sdW1uOiBmcm9tLmNvbHVtbixcbiAgICAgICAgICAgIGVuZENvbHVtbjogdG8gJiYgdG8uY29sdW1uLFxuICAgICAgICAgICAgZW5kTGluZTogdG8gJiYgdG8ubGluZSxcbiAgICAgICAgICAgIGxpbmU6IGZyb20ubGluZSxcbiAgICAgICAgICAgIHVybDogZnJvbVVybC50b1N0cmluZygpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChmcm9tVXJsLnByb3RvY29sID09PSBcImZpbGU6XCIpIHtcbiAgICAgICAgICAgIGlmIChmaWxlVVJMVG9QYXRoJDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyLmZpbGUgPSBmaWxlVVJMVG9QYXRoJDEoZnJvbVVybCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZpbGU6IHByb3RvY29sIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBQb3N0Q1NTIGJ1aWxkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzb3VyY2UgPSBjb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKGZyb20uc291cmNlKTtcbiAgICAgICAgaWYgKHNvdXJjZSkgcmVzdWx0Mi5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgIH07XG4gICAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgdmFyIGpzb24gPSB7fTtcbiAgICAgICAgZm9yKHZhciBfaSA9IDAsIF9pdGVyID0gW1xuICAgICAgICAgICAgXCJoYXNCT01cIixcbiAgICAgICAgICAgIFwiY3NzXCIsXG4gICAgICAgICAgICBcImZpbGVcIixcbiAgICAgICAgICAgIFwiaWRcIlxuICAgICAgICBdOyBfaSA8IF9pdGVyLmxlbmd0aDsgX2krKyl7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IF9pdGVyW19pXTtcbiAgICAgICAgICAgIGlmICh0aGlzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBqc29uW25hbWVdID0gdGhpc1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXApIHtcbiAgICAgICAgICAgIGpzb24ubWFwID0gX2V4dGVuZHMoe30sIHRoaXMubWFwKTtcbiAgICAgICAgICAgIGlmIChqc29uLm1hcC5jb25zdW1lckNhY2hlKSB7XG4gICAgICAgICAgICAgICAganNvbi5tYXAuY29uc3VtZXJDYWNoZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9O1xuICAgIF9jcmVhdGVfY2xhc3MoSW5wdXQsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZyb21cIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGUgfHwgdGhpcy5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBJbnB1dDtcbn0oKTtcbnZhciBpbnB1dCQxID0gSW5wdXQkNCQxO1xuSW5wdXQkNCQxLmRlZmF1bHQgPSBJbnB1dCQ0JDE7XG5pZiAodGVybWluYWxIaWdobGlnaHQkMiAmJiB0ZXJtaW5hbEhpZ2hsaWdodCQyLnJlZ2lzdGVySW5wdXQpIHtcbiAgICB0ZXJtaW5hbEhpZ2hsaWdodCQyLnJlZ2lzdGVySW5wdXQoSW5wdXQkNCQxKTtcbn1cbnZhciBTb3VyY2VNYXBDb25zdW1lciQzID0gcmVxdWlyZSQkMiQxLlNvdXJjZU1hcENvbnN1bWVyLCBTb3VyY2VNYXBHZW5lcmF0b3IkMyA9IHJlcXVpcmUkJDIkMS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG52YXIgZGlybmFtZSQyID0gcmVxdWlyZSQkMiQxLmRpcm5hbWUsIHJlbGF0aXZlJDEgPSByZXF1aXJlJCQyJDEucmVsYXRpdmUsIHJlc29sdmUkMiA9IHJlcXVpcmUkJDIkMS5yZXNvbHZlLCBzZXAkMSA9IHJlcXVpcmUkJDIkMS5zZXA7XG52YXIgcGF0aFRvRmlsZVVSTCQyID0gcmVxdWlyZSQkMiQxLnBhdGhUb0ZpbGVVUkw7XG52YXIgSW5wdXQkMyQxID0gaW5wdXQkMTtcbnZhciBzb3VyY2VNYXBBdmFpbGFibGUkMiA9IEJvb2xlYW4oU291cmNlTWFwQ29uc3VtZXIkMyAmJiBTb3VyY2VNYXBHZW5lcmF0b3IkMyk7XG52YXIgcGF0aEF2YWlsYWJsZSQyID0gQm9vbGVhbihkaXJuYW1lJDIgJiYgcmVzb2x2ZSQyICYmIHJlbGF0aXZlJDEgJiYgc2VwJDEpO1xudmFyIE1hcEdlbmVyYXRvciQyJDEgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIE1hcEdlbmVyYXRvcihzdHJpbmdpZnkyLCByb290Miwgb3B0cywgY3NzU3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5MjtcbiAgICAgICAgdGhpcy5tYXBPcHRzID0gb3B0cy5tYXAgfHwge307XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3QyO1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgICB0aGlzLmNzcyA9IGNzc1N0cmluZztcbiAgICAgICAgdGhpcy5vcmlnaW5hbENTUyA9IGNzc1N0cmluZztcbiAgICAgICAgdGhpcy51c2VzRmlsZVVybHMgPSAhdGhpcy5tYXBPcHRzLmZyb20gJiYgdGhpcy5tYXBPcHRzLmFic29sdXRlO1xuICAgICAgICB0aGlzLm1lbW9pemVkRmlsZVVSTHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm1lbW9pemVkUGF0aHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm1lbW9pemVkVVJMcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBNYXBHZW5lcmF0b3IucHJvdG90eXBlO1xuICAgIF9wcm90by5hZGRBbm5vdGF0aW9uID0gZnVuY3Rpb24gYWRkQW5ub3RhdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQ7XG4gICAgICAgIGlmICh0aGlzLmlzSW5saW5lKCkpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBcImRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyB0aGlzLnRvQmFzZTY0KHRoaXMubWFwLnRvU3RyaW5nKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29udGVudCA9IHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gdGhpcy5tYXBPcHRzLmFubm90YXRpb24odGhpcy5vcHRzLnRvLCB0aGlzLnJvb3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGVudCA9IHRoaXMub3V0cHV0RmlsZSgpICsgXCIubWFwXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVvbCA9IFwiXFxuXCI7XG4gICAgICAgIGlmICh0aGlzLmNzcy5pbmNsdWRlcyhcIlxcclxcblwiKSkgZW9sID0gXCJcXHJcXG5cIjtcbiAgICAgICAgdGhpcy5jc3MgKz0gZW9sICsgXCIvKiMgc291cmNlTWFwcGluZ1VSTD1cIiArIGNvbnRlbnQgKyBcIiAqL1wiO1xuICAgIH07XG4gICAgX3Byb3RvLmFwcGx5UHJldk1hcHMgPSBmdW5jdGlvbiBhcHBseVByZXZNYXBzKCkge1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZSh0aGlzLnByZXZpb3VzKCkpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgcHJldiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGZyb20gPSB0aGlzLnRvVXJsKHRoaXMucGF0aChwcmV2LmZpbGUpKTtcbiAgICAgICAgICAgIHZhciByb290MiA9IHByZXYucm9vdCB8fCBkaXJuYW1lJDIocHJldi5maWxlKTtcbiAgICAgICAgICAgIHZhciBtYXAgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXBPcHRzLnNvdXJjZXNDb250ZW50ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG1hcCA9IG5ldyBTb3VyY2VNYXBDb25zdW1lciQzKHByZXYudGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcC5zb3VyY2VzQ29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICBtYXAuc291cmNlc0NvbnRlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFwID0gcHJldi5jb25zdW1lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tYXAuYXBwbHlTb3VyY2VNYXAobWFwLCBmcm9tLCB0aGlzLnRvVXJsKHRoaXMucGF0aChyb290MikpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmNsZWFyQW5ub3RhdGlvbiA9IGZ1bmN0aW9uIGNsZWFyQW5ub3RhdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICAgICAgICB2YXIgbm9kZTI7XG4gICAgICAgICAgICBmb3IodmFyIGkyID0gdGhpcy5yb290Lm5vZGVzLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pe1xuICAgICAgICAgICAgICAgIG5vZGUyID0gdGhpcy5yb290Lm5vZGVzW2kyXTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZTIudHlwZSAhPT0gXCJjb21tZW50XCIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlMi50ZXh0LmluZGV4T2YoXCIjIHNvdXJjZU1hcHBpbmdVUkw9XCIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm9vdC5yZW1vdmVDaGlsZChpMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY3NzKSB7XG4gICAgICAgICAgICB0aGlzLmNzcyA9IHRoaXMuY3NzLnJlcGxhY2UoL1xcbio/XFwvXFwqI1tcXFNcXHNdKj9cXCpcXC8kL2dtLCBcIlwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmdlbmVyYXRlID0gZnVuY3Rpb24gZ2VuZXJhdGUoKSB7XG4gICAgICAgIHRoaXMuY2xlYXJBbm5vdGF0aW9uKCk7XG4gICAgICAgIGlmIChwYXRoQXZhaWxhYmxlJDIgJiYgc291cmNlTWFwQXZhaWxhYmxlJDIgJiYgdGhpcy5pc01hcCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZU1hcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDIgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5zdHJpbmdpZnkodGhpcy5yb290LCBmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIgKz0gaTI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgcmVzdWx0MlxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmdlbmVyYXRlTWFwID0gZnVuY3Rpb24gZ2VuZXJhdGVNYXAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVTdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXZpb3VzKCkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB2YXIgcHJldiA9IHRoaXMucHJldmlvdXMoKVswXS5jb25zdW1lcigpO1xuICAgICAgICAgICAgcHJldi5maWxlID0gdGhpcy5vdXRwdXRGaWxlKCk7XG4gICAgICAgICAgICB0aGlzLm1hcCA9IFNvdXJjZU1hcEdlbmVyYXRvciQzLmZyb21Tb3VyY2VNYXAocHJldiwge1xuICAgICAgICAgICAgICAgIGlnbm9yZUludmFsaWRNYXBwaW5nOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvciQzKHtcbiAgICAgICAgICAgICAgICBmaWxlOiB0aGlzLm91dHB1dEZpbGUoKSxcbiAgICAgICAgICAgICAgICBpZ25vcmVJbnZhbGlkTWFwcGluZzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLm1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiAwLFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiAxXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IDAsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IDFcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcy5vcHRzLmZyb20gPyB0aGlzLnRvVXJsKHRoaXMucGF0aCh0aGlzLm9wdHMuZnJvbSkpIDogXCI8bm8gc291cmNlPlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1NvdXJjZXNDb250ZW50KCkpIHRoaXMuc2V0U291cmNlc0NvbnRlbnQoKTtcbiAgICAgICAgaWYgKHRoaXMucm9vdCAmJiB0aGlzLnByZXZpb3VzKCkubGVuZ3RoID4gMCkgdGhpcy5hcHBseVByZXZNYXBzKCk7XG4gICAgICAgIGlmICh0aGlzLmlzQW5ub3RhdGlvbigpKSB0aGlzLmFkZEFubm90YXRpb24oKTtcbiAgICAgICAgaWYgKHRoaXMuaXNJbmxpbmUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB0aGlzLmNzc1xuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgdGhpcy5jc3MsXG4gICAgICAgICAgICAgICAgdGhpcy5tYXBcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5nZW5lcmF0ZVN0cmluZyA9IGZ1bmN0aW9uIGdlbmVyYXRlU3RyaW5nKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNzcyA9IFwiXCI7XG4gICAgICAgIHRoaXMubWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvciQzKHtcbiAgICAgICAgICAgIGZpbGU6IHRoaXMub3V0cHV0RmlsZSgpLFxuICAgICAgICAgICAgaWdub3JlSW52YWxpZE1hcHBpbmc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBsaW5lID0gMTtcbiAgICAgICAgdmFyIGNvbHVtbiA9IDE7XG4gICAgICAgIHZhciBub1NvdXJjZSA9IFwiPG5vIHNvdXJjZT5cIjtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSB7XG4gICAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IDAsXG4gICAgICAgICAgICAgICAgbGluZTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiAwLFxuICAgICAgICAgICAgICAgIGxpbmU6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzb3VyY2U6IFwiXCJcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGxpbmVzLCBsYXN0O1xuICAgICAgICB0aGlzLnN0cmluZ2lmeSh0aGlzLnJvb3QsIGZ1bmN0aW9uKHN0ciwgbm9kZTIsIHR5cGUpIHtcbiAgICAgICAgICAgIF90aGlzLmNzcyArPSBzdHI7XG4gICAgICAgICAgICBpZiAobm9kZTIgJiYgdHlwZSAhPT0gXCJlbmRcIikge1xuICAgICAgICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmxpbmUgPSBsaW5lO1xuICAgICAgICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmNvbHVtbiA9IGNvbHVtbiAtIDE7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUyLnNvdXJjZSAmJiBub2RlMi5zb3VyY2Uuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBfdGhpcy5zb3VyY2VQYXRoKG5vZGUyKTtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5saW5lID0gbm9kZTIuc291cmNlLnN0YXJ0LmxpbmU7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwuY29sdW1uID0gbm9kZTIuc291cmNlLnN0YXJ0LmNvbHVtbiAtIDE7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm1hcC5hZGRNYXBwaW5nKG1hcHBpbmcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gbm9Tb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwubGluZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwuY29sdW1uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubWFwLmFkZE1hcHBpbmcobWFwcGluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGluZXMgPSBzdHIubWF0Y2goL1xcbi9nKTtcbiAgICAgICAgICAgIGlmIChsaW5lcykge1xuICAgICAgICAgICAgICAgIGxpbmUgKz0gbGluZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxhc3QgPSBzdHIubGFzdEluZGV4T2YoXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgY29sdW1uID0gc3RyLmxlbmd0aCAtIGxhc3Q7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbHVtbiArPSBzdHIubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUyICYmIHR5cGUgIT09IFwic3RhcnRcIikge1xuICAgICAgICAgICAgICAgIHZhciBwID0gbm9kZTIucGFyZW50IHx8IHtcbiAgICAgICAgICAgICAgICAgICAgcmF3czoge31cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZGxlc3MgPSBub2RlMi50eXBlID09PSBcImRlY2xcIiB8fCBub2RlMi50eXBlID09PSBcImF0cnVsZVwiICYmICFub2RlMi5ub2RlcztcbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkbGVzcyB8fCBub2RlMiAhPT0gcC5sYXN0IHx8IHAucmF3cy5zZW1pY29sb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUyLnNvdXJjZSAmJiBub2RlMi5zb3VyY2UuZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IF90aGlzLnNvdXJjZVBhdGgobm9kZTIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5saW5lID0gbm9kZTIuc291cmNlLmVuZC5saW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5jb2x1bW4gPSBub2RlMi5zb3VyY2UuZW5kLmNvbHVtbiAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZC5saW5lID0gbGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmNvbHVtbiA9IGNvbHVtbiAtIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXAuYWRkTWFwcGluZyhtYXBwaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gbm9Tb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmxpbmUgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5jb2x1bW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQubGluZSA9IGxpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZC5jb2x1bW4gPSBjb2x1bW4gLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubWFwLmFkZE1hcHBpbmcobWFwcGluZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmlzQW5ub3RhdGlvbiA9IGZ1bmN0aW9uIGlzQW5ub3RhdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNJbmxpbmUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91cygpLnNvbWUoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTIuYW5ub3RhdGlvbjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgX3Byb3RvLmlzSW5saW5lID0gZnVuY3Rpb24gaXNJbmxpbmUoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLmlubGluZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwT3B0cy5pbmxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFubm90YXRpb24gPSB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbjtcbiAgICAgICAgaWYgKHR5cGVvZiBhbm5vdGF0aW9uICE9PSBcInVuZGVmaW5lZFwiICYmIGFubm90YXRpb24gIT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcmV2aW91cygpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXMoKS5zb21lKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkyLmlubGluZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgX3Byb3RvLmlzTWFwID0gZnVuY3Rpb24gaXNNYXAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRzLm1hcCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5vcHRzLm1hcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91cygpLmxlbmd0aCA+IDA7XG4gICAgfTtcbiAgICBfcHJvdG8uaXNTb3VyY2VzQ29udGVudCA9IGZ1bmN0aW9uIGlzU291cmNlc0NvbnRlbnQoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLnNvdXJjZXNDb250ZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXBPcHRzLnNvdXJjZXNDb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91cygpLnNvbWUoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTIud2l0aENvbnRlbnQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgX3Byb3RvLm91dHB1dEZpbGUgPSBmdW5jdGlvbiBvdXRwdXRGaWxlKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRzLnRvKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXRoKHRoaXMub3B0cy50byk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRzLmZyb20pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhdGgodGhpcy5vcHRzLmZyb20pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwidG8uY3NzXCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5wYXRoID0gZnVuY3Rpb24gcGF0aChmaWxlKSB7XG4gICAgICAgIGlmICh0aGlzLm1hcE9wdHMuYWJzb2x1dGUpIHJldHVybiBmaWxlO1xuICAgICAgICBpZiAoZmlsZS5jaGFyQ29kZUF0KDApID09PSA2MCkgcmV0dXJuIGZpbGU7XG4gICAgICAgIGlmICgvXlxcdys6XFwvXFwvLy50ZXN0KGZpbGUpKSByZXR1cm4gZmlsZTtcbiAgICAgICAgdmFyIGNhY2hlZCA9IHRoaXMubWVtb2l6ZWRQYXRocy5nZXQoZmlsZSk7XG4gICAgICAgIGlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIHZhciBmcm9tID0gdGhpcy5vcHRzLnRvID8gZGlybmFtZSQyKHRoaXMub3B0cy50bykgOiBcIi5cIjtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZnJvbSA9IGRpcm5hbWUkMihyZXNvbHZlJDIoZnJvbSwgdGhpcy5tYXBPcHRzLmFubm90YXRpb24pKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGF0aCA9IHJlbGF0aXZlJDEoZnJvbSwgZmlsZSk7XG4gICAgICAgIHRoaXMubWVtb2l6ZWRQYXRocy5zZXQoZmlsZSwgcGF0aCk7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH07XG4gICAgX3Byb3RvLnByZXZpb3VzID0gZnVuY3Rpb24gcHJldmlvdXMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5wcmV2aW91c01hcHMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNNYXBzID0gW107XG4gICAgICAgICAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290LndhbGsoZnVuY3Rpb24obm9kZTIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUyLnNvdXJjZSAmJiBub2RlMi5zb3VyY2UuaW5wdXQubWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFwID0gbm9kZTIuc291cmNlLmlucHV0Lm1hcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMucHJldmlvdXNNYXBzLmluY2x1ZGVzKG1hcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcmV2aW91c01hcHMucHVzaChtYXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dDIgPSBuZXcgSW5wdXQkMyQxKHRoaXMub3JpZ2luYWxDU1MsIHRoaXMub3B0cyk7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0Mi5tYXApIHRoaXMucHJldmlvdXNNYXBzLnB1c2goaW5wdXQyLm1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXNNYXBzO1xuICAgIH07XG4gICAgX3Byb3RvLnNldFNvdXJjZXNDb250ZW50ID0gZnVuY3Rpb24gc2V0U291cmNlc0NvbnRlbnQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhbHJlYWR5ID0ge307XG4gICAgICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdC53YWxrKGZ1bmN0aW9uKG5vZGUyKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUyLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnJvbSA9IG5vZGUyLnNvdXJjZS5pbnB1dC5mcm9tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSAmJiAhYWxyZWFkeVtmcm9tXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxyZWFkeVtmcm9tXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJvbVVybCA9IF90aGlzLnVzZXNGaWxlVXJscyA/IF90aGlzLnRvRmlsZVVybChmcm9tKSA6IF90aGlzLnRvVXJsKF90aGlzLnBhdGgoZnJvbSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubWFwLnNldFNvdXJjZUNvbnRlbnQoZnJvbVVybCwgbm9kZTIuc291cmNlLmlucHV0LmNzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNzcykge1xuICAgICAgICAgICAgdmFyIGZyb20gPSB0aGlzLm9wdHMuZnJvbSA/IHRoaXMudG9VcmwodGhpcy5wYXRoKHRoaXMub3B0cy5mcm9tKSkgOiBcIjxubyBzb3VyY2U+XCI7XG4gICAgICAgICAgICB0aGlzLm1hcC5zZXRTb3VyY2VDb250ZW50KGZyb20sIHRoaXMuY3NzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnNvdXJjZVBhdGggPSBmdW5jdGlvbiBzb3VyY2VQYXRoKG5vZGUyKSB7XG4gICAgICAgIGlmICh0aGlzLm1hcE9wdHMuZnJvbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9VcmwodGhpcy5tYXBPcHRzLmZyb20pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudXNlc0ZpbGVVcmxzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0ZpbGVVcmwobm9kZTIuc291cmNlLmlucHV0LmZyb20pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9VcmwodGhpcy5wYXRoKG5vZGUyLnNvdXJjZS5pbnB1dC5mcm9tKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by50b0Jhc2U2NCA9IGZ1bmN0aW9uIHRvQmFzZTY0KHN0cikge1xuICAgICAgICBpZiAoQnVmZmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oc3RyKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8udG9GaWxlVXJsID0gZnVuY3Rpb24gdG9GaWxlVXJsKHBhdGgpIHtcbiAgICAgICAgdmFyIGNhY2hlZCA9IHRoaXMubWVtb2l6ZWRGaWxlVVJMcy5nZXQocGF0aCk7XG4gICAgICAgIGlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIGlmIChwYXRoVG9GaWxlVVJMJDIpIHtcbiAgICAgICAgICAgIHZhciBmaWxlVVJMID0gcGF0aFRvRmlsZVVSTCQyKHBhdGgpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB0aGlzLm1lbW9pemVkRmlsZVVSTHMuc2V0KHBhdGgsIGZpbGVVUkwpO1xuICAgICAgICAgICAgcmV0dXJuIGZpbGVVUkw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgbWFwLmFic29sdXRlYCBvcHRpb24gaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIFBvc3RDU1MgYnVpbGRcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by50b1VybCA9IGZ1bmN0aW9uIHRvVXJsKHBhdGgpIHtcbiAgICAgICAgdmFyIGNhY2hlZCA9IHRoaXMubWVtb2l6ZWRVUkxzLmdldChwYXRoKTtcbiAgICAgICAgaWYgKGNhY2hlZCkgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgaWYgKHNlcCQxID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFxcXC9nLCBcIi9cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVybCA9IGVuY29kZVVSSShwYXRoKS5yZXBsYWNlKC9bIz9dL2csIGVuY29kZVVSSUNvbXBvbmVudCk7XG4gICAgICAgIHRoaXMubWVtb2l6ZWRVUkxzLnNldChwYXRoLCB1cmwpO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcEdlbmVyYXRvcjtcbn0oKTtcbnZhciBtYXBHZW5lcmF0b3IkMSA9IE1hcEdlbmVyYXRvciQyJDE7XG52YXIgTm9kZSQyJDEgPSBub2RlJDE7XG52YXIgQ29tbWVudCQ0JDEgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKE5vZGUkMiQxKSB7XG4gICAgX2luaGVyaXRzKENvbW1lbnQsIE5vZGUkMiQxKTtcbiAgICBmdW5jdGlvbiBDb21tZW50KGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgX3RoaXMgPSBOb2RlJDIkMS5jYWxsKHRoaXMsIGRlZmF1bHRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlID0gXCJjb21tZW50XCI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENvbW1lbnQ7XG59KE5vZGUkMiQxKTtcbnZhciBjb21tZW50JDEgPSBDb21tZW50JDQkMTtcbkNvbW1lbnQkNCQxLmRlZmF1bHQgPSBDb21tZW50JDQkMTtcbnZhciBpc0NsZWFuJDEkMSA9IHN5bWJvbHMkMS5pc0NsZWFuLCBteSQxJDEgPSBzeW1ib2xzJDEubXk7XG52YXIgRGVjbGFyYXRpb24kMyQxID0gZGVjbGFyYXRpb24kMTtcbnZhciBDb21tZW50JDMkMSA9IGNvbW1lbnQkMTtcbnZhciBOb2RlJDEkMSA9IG5vZGUkMTtcbnZhciBwYXJzZSQ0JDEsIFJ1bGUkNCQxLCBBdFJ1bGUkNCQxLCBSb290JDYkMTtcbmZ1bmN0aW9uIGNsZWFuU291cmNlJDEobm9kZXMpIHtcbiAgICByZXR1cm4gbm9kZXMubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgIGlmIChpMi5ub2RlcykgaTIubm9kZXMgPSBjbGVhblNvdXJjZSQxKGkyLm5vZGVzKTtcbiAgICAgICAgZGVsZXRlIGkyLnNvdXJjZTtcbiAgICAgICAgcmV0dXJuIGkyO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gbWFya0RpcnR5VXAkMShub2RlMikge1xuICAgIG5vZGUyW2lzQ2xlYW4kMSQxXSA9IGZhbHNlO1xuICAgIGlmIChub2RlMi5wcm94eU9mLm5vZGVzKSB7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKG5vZGUyLnByb3h5T2Yubm9kZXMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgaTIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIG1hcmtEaXJ0eVVwJDEoaTIpO1xuICAgICAgICB9XG4gICAgfVxufVxudmFyIENvbnRhaW5lciQ3JDEgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKE5vZGUkMSQxKSB7XG4gICAgX2luaGVyaXRzKENvbnRhaW5lciwgTm9kZSQxJDEpO1xuICAgIGZ1bmN0aW9uIENvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIE5vZGUkMSQxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IENvbnRhaW5lci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZCgpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgY2hpbGRyZW4gPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIGNoaWxkcmVuW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKGNoaWxkcmVuKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vcm1hbGl6ZShjaGlsZCwgdGhpcy5sYXN0KTtcbiAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yMSA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShub2RlcyksIF9zdGVwMTsgIShfc3RlcDEgPSBfaXRlcmF0b3IxKCkpLmRvbmU7KXtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZTIgPSBfc3RlcDEudmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm94eU9mLm5vZGVzLnB1c2gobm9kZTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLmNsZWFuUmF3cyA9IGZ1bmN0aW9uIGNsZWFuUmF3cyhrZWVwQmV0d2Vlbikge1xuICAgICAgICBOb2RlJDEkMS5wcm90b3R5cGUuY2xlYW5SYXdzLmNhbGwodGhpcywga2VlcEJldHdlZW4pO1xuICAgICAgICBpZiAodGhpcy5ub2Rlcykge1xuICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UodGhpcy5ub2RlcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZTIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICBub2RlMi5jbGVhblJhd3Moa2VlcEJldHdlZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZWFjaCA9IGZ1bmN0aW9uIGVhY2goY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3h5T2Yubm9kZXMpIHJldHVybiB2b2lkIDA7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuZ2V0SXRlcmF0b3IoKTtcbiAgICAgICAgdmFyIGluZGV4MiwgcmVzdWx0MjtcbiAgICAgICAgd2hpbGUodGhpcy5pbmRleGVzW2l0ZXJhdG9yXSA8IHRoaXMucHJveHlPZi5ub2Rlcy5sZW5ndGgpe1xuICAgICAgICAgICAgaW5kZXgyID0gdGhpcy5pbmRleGVzW2l0ZXJhdG9yXTtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBjYWxsYmFjayh0aGlzLnByb3h5T2Yubm9kZXNbaW5kZXgyXSwgaW5kZXgyKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQyID09PSBmYWxzZSkgYnJlYWs7XG4gICAgICAgICAgICB0aGlzLmluZGV4ZXNbaXRlcmF0b3JdICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMuaW5kZXhlc1tpdGVyYXRvcl07XG4gICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgIH07XG4gICAgX3Byb3RvLmV2ZXJ5ID0gZnVuY3Rpb24gZXZlcnkoY29uZGl0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLmV2ZXJ5KGNvbmRpdGlvbik7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0SXRlcmF0b3IgPSBmdW5jdGlvbiBnZXRJdGVyYXRvcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxhc3RFYWNoKSB0aGlzLmxhc3RFYWNoID0gMDtcbiAgICAgICAgaWYgKCF0aGlzLmluZGV4ZXMpIHRoaXMuaW5kZXhlcyA9IHt9O1xuICAgICAgICB0aGlzLmxhc3RFYWNoICs9IDE7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMubGFzdEVhY2g7XG4gICAgICAgIHRoaXMuaW5kZXhlc1tpdGVyYXRvcl0gPSAwO1xuICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0UHJveHlQcm9jZXNzb3IgPSBmdW5jdGlvbiBnZXRQcm94eVByb2Nlc3NvcigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KG5vZGUyLCBwcm9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgPT09IFwicHJveHlPZlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlMjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFub2RlMltwcm9wXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTJbcHJvcF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBcImVhY2hcIiB8fCB0eXBlb2YgcHJvcCA9PT0gXCJzdHJpbmdcIiAmJiBwcm9wLnN0YXJ0c1dpdGgoXCJ3YWxrXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9ub2RlMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoX25vZGUyID0gbm9kZTIpW3Byb3BdLmFwcGx5KF9ub2RlMiwgW10uY29uY2F0KGFyZ3MubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihjaGlsZCwgaW5kZXgyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTIoY2hpbGQudG9Qcm94eSgpLCBpbmRleDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJldmVyeVwiIHx8IHByb3AgPT09IFwic29tZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihjYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUyW3Byb3BdKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgb3RoZXIgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiLmFwcGx5KHZvaWQgMCwgW10uY29uY2F0KFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQudG9Qcm94eSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwgb3RoZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUyLnJvb3QoKS50b1Byb3h5KCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBcIm5vZGVzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUyLm5vZGVzLm1hcChmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkyLnRvUHJveHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBcImZpcnN0XCIgfHwgcHJvcCA9PT0gXCJsYXN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUyW3Byb3BdLnRvUHJveHkoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTJbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KG5vZGUyLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlMltwcm9wXSA9PT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIG5vZGUyW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgPT09IFwibmFtZVwiIHx8IHByb3AgPT09IFwicGFyYW1zXCIgfHwgcHJvcCA9PT0gXCJzZWxlY3RvclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUyLm1hcmtEaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIF9wcm90by5pbmRleCA9IGZ1bmN0aW9uIGluZGV4KGNoaWxkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09IFwibnVtYmVyXCIpIHJldHVybiBjaGlsZDtcbiAgICAgICAgaWYgKGNoaWxkLnByb3h5T2YpIGNoaWxkID0gY2hpbGQucHJveHlPZjtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJveHlPZi5ub2Rlcy5pbmRleE9mKGNoaWxkKTtcbiAgICB9O1xuICAgIF9wcm90by5pbnNlcnRBZnRlciA9IGZ1bmN0aW9uIGluc2VydEFmdGVyKGV4aXN0LCBhZGQpIHtcbiAgICAgICAgdmFyIGV4aXN0SW5kZXggPSB0aGlzLmluZGV4KGV4aXN0KTtcbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub3JtYWxpemUoYWRkLCB0aGlzLnByb3h5T2Yubm9kZXNbZXhpc3RJbmRleF0pLnJldmVyc2UoKTtcbiAgICAgICAgZXhpc3RJbmRleCA9IHRoaXMuaW5kZXgoZXhpc3QpO1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShub2RlcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBub2RlMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5wcm94eU9mLm5vZGVzLnNwbGljZShleGlzdEluZGV4ICsgMSwgMCwgbm9kZTIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleDI7XG4gICAgICAgIGZvcih2YXIgaWQgaW4gdGhpcy5pbmRleGVzKXtcbiAgICAgICAgICAgIGluZGV4MiA9IHRoaXMuaW5kZXhlc1tpZF07XG4gICAgICAgICAgICBpZiAoZXhpc3RJbmRleCA8IGluZGV4Mikge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhlc1tpZF0gPSBpbmRleDIgKyBub2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8uaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKGV4aXN0LCBhZGQpIHtcbiAgICAgICAgdmFyIGV4aXN0SW5kZXggPSB0aGlzLmluZGV4KGV4aXN0KTtcbiAgICAgICAgdmFyIHR5cGUgPSBleGlzdEluZGV4ID09PSAwID8gXCJwcmVwZW5kXCIgOiBmYWxzZTtcbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub3JtYWxpemUoYWRkLCB0aGlzLnByb3h5T2Yubm9kZXNbZXhpc3RJbmRleF0sIHR5cGUpLnJldmVyc2UoKTtcbiAgICAgICAgZXhpc3RJbmRleCA9IHRoaXMuaW5kZXgoZXhpc3QpO1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShub2RlcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBub2RlMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5wcm94eU9mLm5vZGVzLnNwbGljZShleGlzdEluZGV4LCAwLCBub2RlMik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4MjtcbiAgICAgICAgZm9yKHZhciBpZCBpbiB0aGlzLmluZGV4ZXMpe1xuICAgICAgICAgICAgaW5kZXgyID0gdGhpcy5pbmRleGVzW2lkXTtcbiAgICAgICAgICAgIGlmIChleGlzdEluZGV4IDw9IGluZGV4Mikge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhlc1tpZF0gPSBpbmRleDIgKyBub2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8ubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKG5vZGVzLCBzYW1wbGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbm9kZXMgPSBjbGVhblNvdXJjZSQxKHBhcnNlJDQkMShub2Rlcykubm9kZXMpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbm9kZXMgPSBbXTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG5vZGVzKSkge1xuICAgICAgICAgICAgbm9kZXMgPSBub2Rlcy5zbGljZSgwKTtcbiAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKG5vZGVzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgIHZhciBpMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChpMi5wYXJlbnQpIGkyLnBhcmVudC5yZW1vdmVDaGlsZChpMiwgXCJpZ25vcmVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZXMudHlwZSA9PT0gXCJyb290XCIgJiYgdGhpcy50eXBlICE9PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgICAgIG5vZGVzID0gbm9kZXMubm9kZXMuc2xpY2UoMCk7XG4gICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvcjEgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uobm9kZXMpLCBfc3RlcDE7ICEoX3N0ZXAxID0gX2l0ZXJhdG9yMSgpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgdmFyIGkyMSA9IF9zdGVwMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaTIxLnBhcmVudCkgaTIxLnBhcmVudC5yZW1vdmVDaGlsZChpMjEsIFwiaWdub3JlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGVzLnR5cGUpIHtcbiAgICAgICAgICAgIG5vZGVzID0gW1xuICAgICAgICAgICAgICAgIG5vZGVzXG4gICAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGVzLnByb3ApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZXMudmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWx1ZSBmaWVsZCBpcyBtaXNzZWQgaW4gbm9kZSBjcmVhdGlvblwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGVzLnZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgbm9kZXMudmFsdWUgPSBTdHJpbmcobm9kZXMudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZXMgPSBbXG4gICAgICAgICAgICAgICAgbmV3IERlY2xhcmF0aW9uJDMkMShub2RlcylcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZXMuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIG5vZGVzID0gW1xuICAgICAgICAgICAgICAgIG5ldyBSdWxlJDQkMShub2RlcylcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZXMubmFtZSkge1xuICAgICAgICAgICAgbm9kZXMgPSBbXG4gICAgICAgICAgICAgICAgbmV3IEF0UnVsZSQ0JDEobm9kZXMpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGVzLnRleHQpIHtcbiAgICAgICAgICAgIG5vZGVzID0gW1xuICAgICAgICAgICAgICAgIG5ldyBDb21tZW50JDMkMShub2RlcylcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG5vZGUgdHlwZSBpbiBub2RlIGNyZWF0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9jZXNzZWQgPSBub2Rlcy5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIGlmICghaTJbbXkkMSQxXSkgQ29udGFpbmVyLnJlYnVpbGQoaTIpO1xuICAgICAgICAgICAgaTIgPSBpMi5wcm94eU9mO1xuICAgICAgICAgICAgaWYgKGkyLnBhcmVudCkgaTIucGFyZW50LnJlbW92ZUNoaWxkKGkyKTtcbiAgICAgICAgICAgIGlmIChpMltpc0NsZWFuJDEkMV0pIG1hcmtEaXJ0eVVwJDEoaTIpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpMi5yYXdzLmJlZm9yZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGlmIChzYW1wbGUgJiYgdHlwZW9mIHNhbXBsZS5yYXdzLmJlZm9yZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBpMi5yYXdzLmJlZm9yZSA9IHNhbXBsZS5yYXdzLmJlZm9yZS5yZXBsYWNlKC9cXFMvZywgXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaTIucGFyZW50ID0gX3RoaXMucHJveHlPZjtcbiAgICAgICAgICAgIHJldHVybiBpMjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9jZXNzZWQ7XG4gICAgfTtcbiAgICBfcHJvdG8ucHJlcGVuZCA9IGZ1bmN0aW9uIHByZXBlbmQoKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGNoaWxkcmVuID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBjaGlsZHJlbltfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLnJldmVyc2UoKTtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UoY2hpbGRyZW4pLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIHZhciBub2RlcyA9IHRoaXMubm9ybWFsaXplKGNoaWxkLCB0aGlzLmZpcnN0LCBcInByZXBlbmRcIikucmV2ZXJzZSgpO1xuICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IxID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKG5vZGVzKSwgX3N0ZXAxOyAhKF9zdGVwMSA9IF9pdGVyYXRvcjEoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgIHZhciBub2RlMiA9IF9zdGVwMS52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3h5T2Yubm9kZXMudW5zaGlmdChub2RlMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IodmFyIGlkIGluIHRoaXMuaW5kZXhlcyl7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleGVzW2lkXSA9IHRoaXMuaW5kZXhlc1tpZF0gKyBub2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8ucHVzaCA9IGZ1bmN0aW9uIHB1c2goY2hpbGQpIHtcbiAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICAgICAgdGhpcy5wcm94eU9mLm5vZGVzLnB1c2goY2hpbGQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90by5yZW1vdmVBbGwgPSBmdW5jdGlvbiByZW1vdmVBbGwoKSB7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHRoaXMucHJveHlPZi5ub2RlcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBub2RlMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgbm9kZTIucGFyZW50ID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJveHlPZi5ub2RlcyA9IFtdO1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90by5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIHJlbW92ZUNoaWxkKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkID0gdGhpcy5pbmRleChjaGlsZCk7XG4gICAgICAgIHRoaXMucHJveHlPZi5ub2Rlc1tjaGlsZF0ucGFyZW50ID0gdm9pZCAwO1xuICAgICAgICB0aGlzLnByb3h5T2Yubm9kZXMuc3BsaWNlKGNoaWxkLCAxKTtcbiAgICAgICAgdmFyIGluZGV4MjtcbiAgICAgICAgZm9yKHZhciBpZCBpbiB0aGlzLmluZGV4ZXMpe1xuICAgICAgICAgICAgaW5kZXgyID0gdGhpcy5pbmRleGVzW2lkXTtcbiAgICAgICAgICAgIGlmIChpbmRleDIgPj0gY2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4ZXNbaWRdID0gaW5kZXgyIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90by5yZXBsYWNlVmFsdWVzID0gZnVuY3Rpb24gcmVwbGFjZVZhbHVlcyhwYXR0ZXJuLCBvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgICAgICAgICBvcHRzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YWxrRGVjbHMoZnVuY3Rpb24oZGVjbCkge1xuICAgICAgICAgICAgaWYgKG9wdHMucHJvcHMgJiYgIW9wdHMucHJvcHMuaW5jbHVkZXMoZGVjbC5wcm9wKSkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKG9wdHMuZmFzdCAmJiAhZGVjbC52YWx1ZS5pbmNsdWRlcyhvcHRzLmZhc3QpKSByZXR1cm47XG4gICAgICAgICAgICBkZWNsLnZhbHVlID0gZGVjbC52YWx1ZS5yZXBsYWNlKHBhdHRlcm4sIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLnNvbWUgPSBmdW5jdGlvbiBzb21lKGNvbmRpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5zb21lKGNvbmRpdGlvbik7XG4gICAgfTtcbiAgICBfcHJvdG8ud2FsayA9IGZ1bmN0aW9uIHdhbGsoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQyO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQyID0gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY2hpbGQuYWRkVG9FcnJvcihlMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gZmFsc2UgJiYgY2hpbGQud2Fsaykge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBjaGlsZC53YWxrKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by53YWxrQXRSdWxlcyA9IGZ1bmN0aW9uIHdhbGtBdFJ1bGVzKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gbmFtZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiYXRydWxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9pbnN0YW5jZW9mKG5hbWUsIFJlZ0V4cCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiYXRydWxlXCIgJiYgbmFtZS50ZXN0KGNoaWxkLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJhdHJ1bGVcIiAmJiBjaGlsZC5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLndhbGtDb21tZW50cyA9IGZ1bmN0aW9uIHdhbGtDb21tZW50cyhjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy53YWxrKGZ1bmN0aW9uKGNoaWxkLCBpMikge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLndhbGtEZWNscyA9IGZ1bmN0aW9uIHdhbGtEZWNscyhwcm9wLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHByb3A7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53YWxrKGZ1bmN0aW9uKGNoaWxkLCBpMikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImRlY2xcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2luc3RhbmNlb2YocHJvcCwgUmVnRXhwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJkZWNsXCIgJiYgcHJvcC50ZXN0KGNoaWxkLnByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJkZWNsXCIgJiYgY2hpbGQucHJvcCA9PT0gcHJvcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by53YWxrUnVsZXMgPSBmdW5jdGlvbiB3YWxrUnVsZXMoc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gc2VsZWN0b3I7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53YWxrKGZ1bmN0aW9uKGNoaWxkLCBpMikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcInJ1bGVcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2luc3RhbmNlb2Yoc2VsZWN0b3IsIFJlZ0V4cCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwicnVsZVwiICYmIHNlbGVjdG9yLnRlc3QoY2hpbGQuc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJydWxlXCIgJiYgY2hpbGQuc2VsZWN0b3IgPT09IHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX2NyZWF0ZV9jbGFzcyhDb250YWluZXIsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZpcnN0XCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHJveHlPZi5ub2RlcykgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm94eU9mLm5vZGVzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwibGFzdFwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByb3h5T2Yubm9kZXMpIHJldHVybiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJveHlPZi5ub2Rlc1t0aGlzLnByb3h5T2Yubm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gQ29udGFpbmVyO1xufShOb2RlJDEkMSk7XG5Db250YWluZXIkNyQxLnJlZ2lzdGVyUGFyc2UgPSBmdW5jdGlvbihkZXBlbmRhbnQpIHtcbiAgICBwYXJzZSQ0JDEgPSBkZXBlbmRhbnQ7XG59O1xuQ29udGFpbmVyJDckMS5yZWdpc3RlclJ1bGUgPSBmdW5jdGlvbihkZXBlbmRhbnQpIHtcbiAgICBSdWxlJDQkMSA9IGRlcGVuZGFudDtcbn07XG5Db250YWluZXIkNyQxLnJlZ2lzdGVyQXRSdWxlID0gZnVuY3Rpb24oZGVwZW5kYW50KSB7XG4gICAgQXRSdWxlJDQkMSA9IGRlcGVuZGFudDtcbn07XG5Db250YWluZXIkNyQxLnJlZ2lzdGVyUm9vdCA9IGZ1bmN0aW9uKGRlcGVuZGFudCkge1xuICAgIFJvb3QkNiQxID0gZGVwZW5kYW50O1xufTtcbnZhciBjb250YWluZXIkMSA9IENvbnRhaW5lciQ3JDE7XG5Db250YWluZXIkNyQxLmRlZmF1bHQgPSBDb250YWluZXIkNyQxO1xuQ29udGFpbmVyJDckMS5yZWJ1aWxkID0gZnVuY3Rpb24obm9kZTIpIHtcbiAgICBpZiAobm9kZTIudHlwZSA9PT0gXCJhdHJ1bGVcIikge1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZTIsIEF0UnVsZSQ0JDEucHJvdG90eXBlKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwicnVsZVwiKSB7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihub2RlMiwgUnVsZSQ0JDEucHJvdG90eXBlKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihub2RlMiwgRGVjbGFyYXRpb24kMyQxLnByb3RvdHlwZSk7XG4gICAgfSBlbHNlIGlmIChub2RlMi50eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZTIsIENvbW1lbnQkMyQxLnByb3RvdHlwZSk7XG4gICAgfSBlbHNlIGlmIChub2RlMi50eXBlID09PSBcInJvb3RcIikge1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZTIsIFJvb3QkNiQxLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIG5vZGUyW215JDEkMV0gPSB0cnVlO1xuICAgIGlmIChub2RlMi5ub2Rlcykge1xuICAgICAgICBub2RlMi5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICBDb250YWluZXIkNyQxLnJlYnVpbGQoY2hpbGQpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xudmFyIENvbnRhaW5lciQ2JDEgPSBjb250YWluZXIkMTtcbnZhciBMYXp5UmVzdWx0JDQkMSwgUHJvY2Vzc29yJDMkMTtcbnZhciBEb2N1bWVudCQzJDEgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKENvbnRhaW5lciQ2JDEpIHtcbiAgICBfaW5oZXJpdHMoRG9jdW1lbnQyLCBDb250YWluZXIkNiQxKTtcbiAgICBmdW5jdGlvbiBEb2N1bWVudDIoZGVmYXVsdHMpIHtcbiAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICBfdGhpcyA9IENvbnRhaW5lciQ2JDEuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgICB0eXBlOiBcImRvY3VtZW50XCJcbiAgICAgICAgfSwgZGVmYXVsdHMpKSB8fCB0aGlzO1xuICAgICAgICBpZiAoIV90aGlzLm5vZGVzKSB7XG4gICAgICAgICAgICBfdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IERvY3VtZW50Mi5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnRvUmVzdWx0ID0gZnVuY3Rpb24gdG9SZXN1bHQob3B0cykge1xuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSBvcHRzID0ge307XG4gICAgICAgIHZhciBsYXp5ID0gbmV3IExhenlSZXN1bHQkNCQxKG5ldyBQcm9jZXNzb3IkMyQxKCksIHRoaXMsIG9wdHMpO1xuICAgICAgICByZXR1cm4gbGF6eS5zdHJpbmdpZnkoKTtcbiAgICB9O1xuICAgIHJldHVybiBEb2N1bWVudDI7XG59KENvbnRhaW5lciQ2JDEpO1xuRG9jdW1lbnQkMyQxLnJlZ2lzdGVyTGF6eVJlc3VsdCA9IGZ1bmN0aW9uKGRlcGVuZGFudCkge1xuICAgIExhenlSZXN1bHQkNCQxID0gZGVwZW5kYW50O1xufTtcbkRvY3VtZW50JDMkMS5yZWdpc3RlclByb2Nlc3NvciA9IGZ1bmN0aW9uKGRlcGVuZGFudCkge1xuICAgIFByb2Nlc3NvciQzJDEgPSBkZXBlbmRhbnQ7XG59O1xudmFyIGRvY3VtZW50JDEkMSA9IERvY3VtZW50JDMkMTtcbkRvY3VtZW50JDMkMS5kZWZhdWx0ID0gRG9jdW1lbnQkMyQxO1xudmFyIHByaW50ZWQkMSA9IHt9O1xudmFyIHdhcm5PbmNlJDIkMSA9IGZ1bmN0aW9uIHdhcm5PbmNlKG1lc3NhZ2UpIHtcbiAgICBpZiAocHJpbnRlZCQxW21lc3NhZ2VdKSByZXR1cm47XG4gICAgcHJpbnRlZCQxW21lc3NhZ2VdID0gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG59O1xudmFyIFdhcm5pbmckMiQxID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBXYXJuaW5nKHRleHQsIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgb3B0cyA9IHt9O1xuICAgICAgICB0aGlzLnR5cGUgPSBcIndhcm5pbmdcIjtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgaWYgKG9wdHMubm9kZSAmJiBvcHRzLm5vZGUuc291cmNlKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBvcHRzLm5vZGUucmFuZ2VCeShvcHRzKTtcbiAgICAgICAgICAgIHRoaXMubGluZSA9IHJhbmdlLnN0YXJ0LmxpbmU7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbiA9IHJhbmdlLnN0YXJ0LmNvbHVtbjtcbiAgICAgICAgICAgIHRoaXMuZW5kTGluZSA9IHJhbmdlLmVuZC5saW5lO1xuICAgICAgICAgICAgdGhpcy5lbmRDb2x1bW4gPSByYW5nZS5lbmQuY29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGZvcih2YXIgb3B0IGluIG9wdHMpdGhpc1tvcHRdID0gb3B0c1tvcHRdO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gV2FybmluZy5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGUuZXJyb3IodGhpcy50ZXh0LCB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsXG4gICAgICAgICAgICAgICAgcGx1Z2luOiB0aGlzLnBsdWdpbixcbiAgICAgICAgICAgICAgICB3b3JkOiB0aGlzLndvcmRcbiAgICAgICAgICAgIH0pLm1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGx1Z2luKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wbHVnaW4gKyBcIjogXCIgKyB0aGlzLnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICB9O1xuICAgIHJldHVybiBXYXJuaW5nO1xufSgpO1xudmFyIHdhcm5pbmckMSA9IFdhcm5pbmckMiQxO1xuV2FybmluZyQyJDEuZGVmYXVsdCA9IFdhcm5pbmckMiQxO1xudmFyIFdhcm5pbmckMSQxID0gd2FybmluZyQxO1xudmFyIFJlc3VsdCQzJDEgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFJlc3VsdChwcm9jZXNzb3IyLCByb290Miwgb3B0cykge1xuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjI7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBbXTtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDI7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICAgIHRoaXMuY3NzID0gdm9pZCAwO1xuICAgICAgICB0aGlzLm1hcCA9IHZvaWQgMDtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFJlc3VsdC5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNzcztcbiAgICB9O1xuICAgIF9wcm90by53YXJuID0gZnVuY3Rpb24gd2Fybih0ZXh0LCBvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzID09PSB2b2lkIDApIG9wdHMgPSB7fTtcbiAgICAgICAgaWYgKCFvcHRzLnBsdWdpbikge1xuICAgICAgICAgICAgaWYgKHRoaXMubGFzdFBsdWdpbiAmJiB0aGlzLmxhc3RQbHVnaW4ucG9zdGNzc1BsdWdpbikge1xuICAgICAgICAgICAgICAgIG9wdHMucGx1Z2luID0gdGhpcy5sYXN0UGx1Z2luLnBvc3Rjc3NQbHVnaW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdhcm5pbmcyID0gbmV3IFdhcm5pbmckMSQxKHRleHQsIG9wdHMpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzLnB1c2god2FybmluZzIpO1xuICAgICAgICByZXR1cm4gd2FybmluZzI7XG4gICAgfTtcbiAgICBfcHJvdG8ud2FybmluZ3MgPSBmdW5jdGlvbiB3YXJuaW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXMuZmlsdGVyKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICByZXR1cm4gaTIudHlwZSA9PT0gXCJ3YXJuaW5nXCI7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX2NyZWF0ZV9jbGFzcyhSZXN1bHQsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNvbnRlbnRcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBSZXN1bHQ7XG59KCk7XG52YXIgcmVzdWx0JDEgPSBSZXN1bHQkMyQxO1xuUmVzdWx0JDMkMS5kZWZhdWx0ID0gUmVzdWx0JDMkMTtcbnZhciBTSU5HTEVfUVVPVEUkMSA9IFwiJ1wiLmNoYXJDb2RlQXQoMCk7XG52YXIgRE9VQkxFX1FVT1RFJDEgPSAnXCInLmNoYXJDb2RlQXQoMCk7XG52YXIgQkFDS1NMQVNIJDEgPSBcIlxcXFxcIi5jaGFyQ29kZUF0KDApO1xudmFyIFNMQVNIJDEgPSBcIi9cIi5jaGFyQ29kZUF0KDApO1xudmFyIE5FV0xJTkUkMSA9IFwiXFxuXCIuY2hhckNvZGVBdCgwKTtcbnZhciBTUEFDRSQxID0gXCIgXCIuY2hhckNvZGVBdCgwKTtcbnZhciBGRUVEJDEgPSBcIlxcZlwiLmNoYXJDb2RlQXQoMCk7XG52YXIgVEFCJDEgPSBcIlx0XCIuY2hhckNvZGVBdCgwKTtcbnZhciBDUiQxID0gXCJcXHJcIi5jaGFyQ29kZUF0KDApO1xudmFyIE9QRU5fU1FVQVJFJDEgPSBcIltcIi5jaGFyQ29kZUF0KDApO1xudmFyIENMT1NFX1NRVUFSRSQxID0gXCJdXCIuY2hhckNvZGVBdCgwKTtcbnZhciBPUEVOX1BBUkVOVEhFU0VTJDEgPSBcIihcIi5jaGFyQ29kZUF0KDApO1xudmFyIENMT1NFX1BBUkVOVEhFU0VTJDEgPSBcIilcIi5jaGFyQ29kZUF0KDApO1xudmFyIE9QRU5fQ1VSTFkkMSA9IFwie1wiLmNoYXJDb2RlQXQoMCk7XG52YXIgQ0xPU0VfQ1VSTFkkMSA9IFwifVwiLmNoYXJDb2RlQXQoMCk7XG52YXIgU0VNSUNPTE9OJDEgPSBcIjtcIi5jaGFyQ29kZUF0KDApO1xudmFyIEFTVEVSSVNLJDEgPSBcIipcIi5jaGFyQ29kZUF0KDApO1xudmFyIENPTE9OJDEgPSBcIjpcIi5jaGFyQ29kZUF0KDApO1xudmFyIEFUJDEgPSBcIkBcIi5jaGFyQ29kZUF0KDApO1xudmFyIFJFX0FUX0VORCQxID0gL1tcXHRcXG5cXGZcXHIgXCIjJygpLztbXFxcXFxcXXt9XS9nO1xudmFyIFJFX1dPUkRfRU5EJDEgPSAvW1xcdFxcblxcZlxcciAhXCIjJygpOjtAW1xcXFxcXF17fV18XFwvKD89XFwqKS9nO1xudmFyIFJFX0JBRF9CUkFDS0VUJDEgPSAvLltcXHJcXG5cIicoL1xcXFxdLztcbnZhciBSRV9IRVhfRVNDQVBFJDEgPSAvW1xcZGEtZl0vaTtcbnZhciB0b2tlbml6ZSQxID0gZnVuY3Rpb24gdG9rZW5pemVyKGlucHV0Miwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgY3NzID0gaW5wdXQyLmNzcy52YWx1ZU9mKCk7XG4gICAgdmFyIGlnbm9yZSA9IG9wdGlvbnMuaWdub3JlRXJyb3JzO1xuICAgIHZhciBjb2RlLCBuZXh0LCBxdW90ZSwgY29udGVudCwgZXNjYXBlO1xuICAgIHZhciBlc2NhcGVkLCBlc2NhcGVQb3MsIHByZXYsIG4yLCBjdXJyZW50VG9rZW47XG4gICAgdmFyIGxlbmd0aCA9IGNzcy5sZW5ndGg7XG4gICAgdmFyIHBvcyA9IDA7XG4gICAgdmFyIGJ1ZmZlciA9IFtdO1xuICAgIHZhciByZXR1cm5lZCA9IFtdO1xuICAgIGZ1bmN0aW9uIHBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bmNsb3NlZCh3aGF0KSB7XG4gICAgICAgIHRocm93IGlucHV0Mi5lcnJvcihcIlVuY2xvc2VkIFwiICsgd2hhdCwgcG9zKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5kT2ZGaWxlKCkge1xuICAgICAgICByZXR1cm4gcmV0dXJuZWQubGVuZ3RoID09PSAwICYmIHBvcyA+PSBsZW5ndGg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5leHRUb2tlbihvcHRzKSB7XG4gICAgICAgIGlmIChyZXR1cm5lZC5sZW5ndGgpIHJldHVybiByZXR1cm5lZC5wb3AoKTtcbiAgICAgICAgaWYgKHBvcyA+PSBsZW5ndGgpIHJldHVybjtcbiAgICAgICAgdmFyIGlnbm9yZVVuY2xvc2VkID0gb3B0cyA/IG9wdHMuaWdub3JlVW5jbG9zZWQgOiBmYWxzZTtcbiAgICAgICAgY29kZSA9IGNzcy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIHN3aXRjaChjb2RlKXtcbiAgICAgICAgICAgIGNhc2UgTkVXTElORSQxOlxuICAgICAgICAgICAgY2FzZSBTUEFDRSQxOlxuICAgICAgICAgICAgY2FzZSBUQUIkMTpcbiAgICAgICAgICAgIGNhc2UgQ1IkMTpcbiAgICAgICAgICAgIGNhc2UgRkVFRCQxOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNzcy5jaGFyQ29kZUF0KG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB9d2hpbGUgKGNvZGUgPT09IFNQQUNFJDEgfHwgY29kZSA9PT0gTkVXTElORSQxIHx8IGNvZGUgPT09IFRBQiQxIHx8IGNvZGUgPT09IENSJDEgfHwgY29kZSA9PT0gRkVFRCQxKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJzcGFjZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzLnNsaWNlKHBvcywgbmV4dClcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gbmV4dCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgT1BFTl9TUVVBUkUkMTpcbiAgICAgICAgICAgIGNhc2UgQ0xPU0VfU1FVQVJFJDE6XG4gICAgICAgICAgICBjYXNlIE9QRU5fQ1VSTFkkMTpcbiAgICAgICAgICAgIGNhc2UgQ0xPU0VfQ1VSTFkkMTpcbiAgICAgICAgICAgIGNhc2UgQ09MT04kMTpcbiAgICAgICAgICAgIGNhc2UgU0VNSUNPTE9OJDE6XG4gICAgICAgICAgICBjYXNlIENMT1NFX1BBUkVOVEhFU0VTJDE6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sQ2hhcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xDaGFyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgT1BFTl9QQVJFTlRIRVNFUyQxOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldiA9IGJ1ZmZlci5sZW5ndGggPyBidWZmZXIucG9wKClbMV0gOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBuMiA9IGNzcy5jaGFyQ29kZUF0KHBvcyArIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldiA9PT0gXCJ1cmxcIiAmJiBuMiAhPT0gU0lOR0xFX1FVT1RFJDEgJiYgbjIgIT09IERPVUJMRV9RVU9URSQxICYmIG4yICE9PSBTUEFDRSQxICYmIG4yICE9PSBORVdMSU5FJDEgJiYgbjIgIT09IFRBQiQxICYmIG4yICE9PSBGRUVEJDEgJiYgbjIgIT09IENSJDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBjc3MuaW5kZXhPZihcIilcIiwgbmV4dCArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlIHx8IGlnbm9yZVVuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmNsb3NlZChcImJyYWNrZXRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlUG9zID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZShjc3MuY2hhckNvZGVBdChlc2NhcGVQb3MgLSAxKSA9PT0gQkFDS1NMQVNIJDEpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVQb3MgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH13aGlsZSAoZXNjYXBlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJicmFja2V0c1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gY3NzLmluZGV4T2YoXCIpXCIsIHBvcyArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IGNzcy5zbGljZShwb3MsIG5leHQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSAtMSB8fCBSRV9CQURfQlJBQ0tFVCQxLnRlc3QoY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIihcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJyYWNrZXRzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFNJTkdMRV9RVU9URSQxOlxuICAgICAgICAgICAgY2FzZSBET1VCTEVfUVVPVEUkMTpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHF1b3RlID0gY29kZSA9PT0gU0lOR0xFX1FVT1RFJDEgPyBcIidcIiA6ICdcIic7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBjc3MuaW5kZXhPZihxdW90ZSwgbmV4dCArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlnbm9yZSB8fCBpZ25vcmVVbmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gcG9zICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5jbG9zZWQoXCJzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlUG9zID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKGNzcy5jaGFyQ29kZUF0KGVzY2FwZVBvcyAtIDEpID09PSBCQUNLU0xBU0gkMSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlUG9zIC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9d2hpbGUgKGVzY2FwZWQpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEFUJDE6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBSRV9BVF9FTkQkMS5sYXN0SW5kZXggPSBwb3MgKyAxO1xuICAgICAgICAgICAgICAgICAgICBSRV9BVF9FTkQkMS50ZXN0KGNzcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChSRV9BVF9FTkQkMS5sYXN0SW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBjc3MubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBSRV9BVF9FTkQkMS5sYXN0SW5kZXggLSAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYXQtd29yZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEJBQ0tTTEFTSCQxOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUoY3NzLmNoYXJDb2RlQXQobmV4dCArIDEpID09PSBCQUNLU0xBU0gkMSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGUgPSAhZXNjYXBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjc3MuY2hhckNvZGVBdChuZXh0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlc2NhcGUgJiYgY29kZSAhPT0gU0xBU0gkMSAmJiBjb2RlICE9PSBTUEFDRSQxICYmIGNvZGUgIT09IE5FV0xJTkUkMSAmJiBjb2RlICE9PSBUQUIkMSAmJiBjb2RlICE9PSBDUiQxICYmIGNvZGUgIT09IEZFRUQkMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFJFX0hFWF9FU0NBUEUkMS50ZXN0KGNzcy5jaGFyQXQobmV4dCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUoUkVfSEVYX0VTQ0FQRSQxLnRlc3QoY3NzLmNoYXJBdChuZXh0ICsgMSkpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3NzLmNoYXJDb2RlQXQobmV4dCArIDEpID09PSBTUEFDRSQxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ3b3JkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gU0xBU0gkMSAmJiBjc3MuY2hhckNvZGVBdChwb3MgKyAxKSA9PT0gQVNURVJJU0skMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGNzcy5pbmRleE9mKFwiKi9cIiwgcG9zICsgMikgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlIHx8IGlnbm9yZVVuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBjc3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuY2xvc2VkKFwiY29tbWVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb21tZW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJFX1dPUkRfRU5EJDEubGFzdEluZGV4ID0gcG9zICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJFX1dPUkRfRU5EJDEudGVzdChjc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFJFX1dPUkRfRU5EJDEubGFzdEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGNzcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gUkVfV09SRF9FTkQkMS5sYXN0SW5kZXggLSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid29yZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGN1cnJlbnRUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwb3MrKztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRUb2tlbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmFjayh0b2tlbikge1xuICAgICAgICByZXR1cm5lZC5wdXNoKHRva2VuKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmFjazogYmFjayxcbiAgICAgICAgZW5kT2ZGaWxlOiBlbmRPZkZpbGUsXG4gICAgICAgIG5leHRUb2tlbjogbmV4dFRva2VuLFxuICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgICB9O1xufTtcbnZhciBDb250YWluZXIkNSQxID0gY29udGFpbmVyJDE7XG52YXIgQXRSdWxlJDMkMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oQ29udGFpbmVyJDUkMSkge1xuICAgIF9pbmhlcml0cyhBdFJ1bGUsIENvbnRhaW5lciQ1JDEpO1xuICAgIGZ1bmN0aW9uIEF0UnVsZShkZWZhdWx0cykge1xuICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgIF90aGlzID0gQ29udGFpbmVyJDUkMS5jYWxsKHRoaXMsIGRlZmF1bHRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlID0gXCJhdHJ1bGVcIjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gQXRSdWxlLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBjaGlsZHJlbiA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgY2hpbGRyZW5bX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9Db250YWluZXIkNSQxX3Byb3RvdHlwZV9hcHBlbmQ7XG4gICAgICAgIGlmICghdGhpcy5wcm94eU9mLm5vZGVzKSB0aGlzLm5vZGVzID0gW107XG4gICAgICAgIHJldHVybiAoX0NvbnRhaW5lciQ1JDFfcHJvdG90eXBlX2FwcGVuZCA9IENvbnRhaW5lciQ1JDEucHJvdG90eXBlLmFwcGVuZCkuY2FsbC5hcHBseShfQ29udGFpbmVyJDUkMV9wcm90b3R5cGVfYXBwZW5kLCBbXS5jb25jYXQoW1xuICAgICAgICAgICAgdGhpc1xuICAgICAgICBdLCBjaGlsZHJlbikpO1xuICAgIH07XG4gICAgX3Byb3RvLnByZXBlbmQgPSBmdW5jdGlvbiBwcmVwZW5kKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBjaGlsZHJlbiA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgY2hpbGRyZW5bX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9Db250YWluZXIkNSQxX3Byb3RvdHlwZV9wcmVwZW5kO1xuICAgICAgICBpZiAoIXRoaXMucHJveHlPZi5ub2RlcykgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICByZXR1cm4gKF9Db250YWluZXIkNSQxX3Byb3RvdHlwZV9wcmVwZW5kID0gQ29udGFpbmVyJDUkMS5wcm90b3R5cGUucHJlcGVuZCkuY2FsbC5hcHBseShfQ29udGFpbmVyJDUkMV9wcm90b3R5cGVfcHJlcGVuZCwgW10uY29uY2F0KFtcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgXSwgY2hpbGRyZW4pKTtcbiAgICB9O1xuICAgIHJldHVybiBBdFJ1bGU7XG59KENvbnRhaW5lciQ1JDEpO1xudmFyIGF0UnVsZSQxID0gQXRSdWxlJDMkMTtcbkF0UnVsZSQzJDEuZGVmYXVsdCA9IEF0UnVsZSQzJDE7XG5Db250YWluZXIkNSQxLnJlZ2lzdGVyQXRSdWxlKEF0UnVsZSQzJDEpO1xudmFyIENvbnRhaW5lciQ0JDEgPSBjb250YWluZXIkMTtcbnZhciBMYXp5UmVzdWx0JDMkMSwgUHJvY2Vzc29yJDIkMTtcbnZhciBSb290JDUkMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oQ29udGFpbmVyJDQkMSkge1xuICAgIF9pbmhlcml0cyhSb290LCBDb250YWluZXIkNCQxKTtcbiAgICBmdW5jdGlvbiBSb290KGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgX3RoaXMgPSBDb250YWluZXIkNCQxLmNhbGwodGhpcywgZGVmYXVsdHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSBcInJvb3RcIjtcbiAgICAgICAgaWYgKCFfdGhpcy5ub2RlcykgX3RoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gUm9vdC5wcm90b3R5cGU7XG4gICAgX3Byb3RvLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShjaGlsZCwgc2FtcGxlLCB0eXBlKSB7XG4gICAgICAgIHZhciBub2RlcyA9IENvbnRhaW5lciQ0JDEucHJvdG90eXBlLm5vcm1hbGl6ZS5jYWxsKHRoaXMsIGNoaWxkKTtcbiAgICAgICAgaWYgKHNhbXBsZSkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwicHJlcGVuZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBzYW1wbGUucmF3cy5iZWZvcmUgPSB0aGlzLm5vZGVzWzFdLnJhd3MuYmVmb3JlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzYW1wbGUucmF3cy5iZWZvcmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZpcnN0ICE9PSBzYW1wbGUpIHtcbiAgICAgICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShub2RlcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUyLnJhd3MuYmVmb3JlID0gc2FtcGxlLnJhd3MuYmVmb3JlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiByZW1vdmVDaGlsZChjaGlsZCwgaWdub3JlKSB7XG4gICAgICAgIHZhciBpbmRleDIgPSB0aGlzLmluZGV4KGNoaWxkKTtcbiAgICAgICAgaWYgKCFpZ25vcmUgJiYgaW5kZXgyID09PSAwICYmIHRoaXMubm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhpcy5ub2Rlc1sxXS5yYXdzLmJlZm9yZSA9IHRoaXMubm9kZXNbaW5kZXgyXS5yYXdzLmJlZm9yZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ29udGFpbmVyJDQkMS5wcm90b3R5cGUucmVtb3ZlQ2hpbGQuY2FsbCh0aGlzLCBjaGlsZCk7XG4gICAgfTtcbiAgICBfcHJvdG8udG9SZXN1bHQgPSBmdW5jdGlvbiB0b1Jlc3VsdChvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzID09PSB2b2lkIDApIG9wdHMgPSB7fTtcbiAgICAgICAgdmFyIGxhenkgPSBuZXcgTGF6eVJlc3VsdCQzJDEobmV3IFByb2Nlc3NvciQyJDEoKSwgdGhpcywgb3B0cyk7XG4gICAgICAgIHJldHVybiBsYXp5LnN0cmluZ2lmeSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFJvb3Q7XG59KENvbnRhaW5lciQ0JDEpO1xuUm9vdCQ1JDEucmVnaXN0ZXJMYXp5UmVzdWx0ID0gZnVuY3Rpb24oZGVwZW5kYW50KSB7XG4gICAgTGF6eVJlc3VsdCQzJDEgPSBkZXBlbmRhbnQ7XG59O1xuUm9vdCQ1JDEucmVnaXN0ZXJQcm9jZXNzb3IgPSBmdW5jdGlvbihkZXBlbmRhbnQpIHtcbiAgICBQcm9jZXNzb3IkMiQxID0gZGVwZW5kYW50O1xufTtcbnZhciByb290JDEgPSBSb290JDUkMTtcblJvb3QkNSQxLmRlZmF1bHQgPSBSb290JDUkMTtcbkNvbnRhaW5lciQ0JDEucmVnaXN0ZXJSb290KFJvb3QkNSQxKTtcbnZhciBsaXN0JDIkMSA9IHtcbiAgICBjb21tYTogZnVuY3Rpb24gY29tbWEoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBsaXN0JDIkMS5zcGxpdChzdHJpbmcsIFtcbiAgICAgICAgICAgIFwiLFwiXG4gICAgICAgIF0sIHRydWUpO1xuICAgIH0sXG4gICAgc3BhY2U6IGZ1bmN0aW9uIHNwYWNlKHN0cmluZykge1xuICAgICAgICB2YXIgc3BhY2VzID0gW1xuICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICBcIlxcblwiLFxuICAgICAgICAgICAgXCJcdFwiXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBsaXN0JDIkMS5zcGxpdChzdHJpbmcsIHNwYWNlcyk7XG4gICAgfSxcbiAgICBzcGxpdDogZnVuY3Rpb24gc3BsaXQoc3RyaW5nLCBzZXBhcmF0b3JzLCBsYXN0KSB7XG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgICB2YXIgY3VycmVudCA9IFwiXCI7XG4gICAgICAgIHZhciBzcGxpdCA9IGZhbHNlO1xuICAgICAgICB2YXIgZnVuYyA9IDA7XG4gICAgICAgIHZhciBpblF1b3RlID0gZmFsc2U7XG4gICAgICAgIHZhciBwcmV2UXVvdGUgPSBcIlwiO1xuICAgICAgICB2YXIgZXNjYXBlID0gZmFsc2U7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHN0cmluZyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBsZXR0ZXIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgICAgICAgICBlc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgIGVzY2FwZSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluUXVvdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobGV0dGVyID09PSBwcmV2UXVvdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5RdW90ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSAnXCInIHx8IGxldHRlciA9PT0gXCInXCIpIHtcbiAgICAgICAgICAgICAgICBpblF1b3RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcmV2UXVvdGUgPSBsZXR0ZXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxldHRlciA9PT0gXCIoXCIpIHtcbiAgICAgICAgICAgICAgICBmdW5jICs9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxldHRlciA9PT0gXCIpXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnVuYyA+IDApIGZ1bmMgLT0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZnVuYyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChzZXBhcmF0b3JzLmluY2x1ZGVzKGxldHRlcikpIHNwbGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcGxpdCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBcIlwiKSBhcnJheS5wdXNoKGN1cnJlbnQudHJpbSgpKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBzcGxpdCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ICs9IGxldHRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdCB8fCBjdXJyZW50ICE9PSBcIlwiKSBhcnJheS5wdXNoKGN1cnJlbnQudHJpbSgpKTtcbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbn07XG52YXIgbGlzdF8xJDEgPSBsaXN0JDIkMTtcbmxpc3QkMiQxLmRlZmF1bHQgPSBsaXN0JDIkMTtcbnZhciBDb250YWluZXIkMyQxID0gY29udGFpbmVyJDE7XG52YXIgbGlzdCQxJDEgPSBsaXN0XzEkMTtcbnZhciBSdWxlJDMkMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oQ29udGFpbmVyJDMkMSkge1xuICAgIF9pbmhlcml0cyhSdWxlLCBDb250YWluZXIkMyQxKTtcbiAgICBmdW5jdGlvbiBSdWxlKGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgX3RoaXMgPSBDb250YWluZXIkMyQxLmNhbGwodGhpcywgZGVmYXVsdHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSBcInJ1bGVcIjtcbiAgICAgICAgaWYgKCFfdGhpcy5ub2RlcykgX3RoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBfY3JlYXRlX2NsYXNzKFJ1bGUsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInNlbGVjdG9yc1wiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3QkMSQxLmNvbW1hKHRoaXMuc2VsZWN0b3IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlcykge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHRoaXMuc2VsZWN0b3IgPyB0aGlzLnNlbGVjdG9yLm1hdGNoKC8sXFxzKi8pIDogbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgc2VwMiA9IG1hdGNoID8gbWF0Y2hbMF0gOiBcIixcIiArIHRoaXMucmF3KFwiYmV0d2VlblwiLCBcImJlZm9yZU9wZW5cIik7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvciA9IHZhbHVlcy5qb2luKHNlcDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIFJ1bGU7XG59KENvbnRhaW5lciQzJDEpO1xudmFyIHJ1bGUkMSA9IFJ1bGUkMyQxO1xuUnVsZSQzJDEuZGVmYXVsdCA9IFJ1bGUkMyQxO1xuQ29udGFpbmVyJDMkMS5yZWdpc3RlclJ1bGUoUnVsZSQzJDEpO1xudmFyIERlY2xhcmF0aW9uJDIkMSA9IGRlY2xhcmF0aW9uJDE7XG52YXIgdG9rZW5pemVyMiQxID0gdG9rZW5pemUkMTtcbnZhciBDb21tZW50JDIkMSA9IGNvbW1lbnQkMTtcbnZhciBBdFJ1bGUkMiQxID0gYXRSdWxlJDE7XG52YXIgUm9vdCQ0JDEgPSByb290JDE7XG52YXIgUnVsZSQyJDEgPSBydWxlJDE7XG52YXIgU0FGRV9DT01NRU5UX05FSUdIQk9SJDEgPSB7XG4gICAgZW1wdHk6IHRydWUsXG4gICAgc3BhY2U6IHRydWVcbn07XG5mdW5jdGlvbiBmaW5kTGFzdFdpdGhQb3NpdGlvbiQxKHRva2Vucykge1xuICAgIGZvcih2YXIgaTIgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSl7XG4gICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpMl07XG4gICAgICAgIHZhciBwb3MgPSB0b2tlblszXSB8fCB0b2tlblsyXTtcbiAgICAgICAgaWYgKHBvcykgcmV0dXJuIHBvcztcbiAgICB9XG59XG52YXIgUGFyc2VyJDEkMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gUGFyc2VyKGlucHV0Mikge1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQyO1xuICAgICAgICB0aGlzLnJvb3QgPSBuZXcgUm9vdCQ0JDEoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5yb290O1xuICAgICAgICB0aGlzLnNwYWNlcyA9IFwiXCI7XG4gICAgICAgIHRoaXMuc2VtaWNvbG9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3JlYXRlVG9rZW5pemVyKCk7XG4gICAgICAgIHRoaXMucm9vdC5zb3VyY2UgPSB7XG4gICAgICAgICAgICBpbnB1dDogaW5wdXQyLFxuICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IDEsXG4gICAgICAgICAgICAgICAgbGluZTogMSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFBhcnNlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmF0cnVsZSA9IGZ1bmN0aW9uIGF0cnVsZSh0b2tlbikge1xuICAgICAgICB2YXIgbm9kZTIgPSBuZXcgQXRSdWxlJDIkMSgpO1xuICAgICAgICBub2RlMi5uYW1lID0gdG9rZW5bMV0uc2xpY2UoMSk7XG4gICAgICAgIGlmIChub2RlMi5uYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgICB0aGlzLnVubmFtZWRBdHJ1bGUobm9kZTIsIHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXQobm9kZTIsIHRva2VuWzJdKTtcbiAgICAgICAgdmFyIHR5cGU7XG4gICAgICAgIHZhciBwcmV2O1xuICAgICAgICB2YXIgc2hpZnQ7XG4gICAgICAgIHZhciBsYXN0ID0gZmFsc2U7XG4gICAgICAgIHZhciBvcGVuID0gZmFsc2U7XG4gICAgICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICAgICAgdmFyIGJyYWNrZXRzID0gW107XG4gICAgICAgIHdoaWxlKCF0aGlzLnRva2VuaXplci5lbmRPZkZpbGUoKSl7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMudG9rZW5pemVyLm5leHRUb2tlbigpO1xuICAgICAgICAgICAgdHlwZSA9IHRva2VuWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiKFwiIHx8IHR5cGUgPT09IFwiW1wiKSB7XG4gICAgICAgICAgICAgICAgYnJhY2tldHMucHVzaCh0eXBlID09PSBcIihcIiA/IFwiKVwiIDogXCJdXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIntcIiAmJiBicmFja2V0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgYnJhY2tldHMucHVzaChcIn1cIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IGJyYWNrZXRzW2JyYWNrZXRzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICAgICAgYnJhY2tldHMucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnJhY2tldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiO1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUyLnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKHRva2VuWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTIuc291cmNlLmVuZC5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW1pY29sb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwie1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSBwYXJhbXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSBwYXJhbXNbc2hpZnRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUocHJldiAmJiBwcmV2WzBdID09PSBcInNwYWNlXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSBwYXJhbXNbLS1zaGlmdF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUyLnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKHByZXZbM10gfHwgcHJldlsyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTIuc291cmNlLmVuZC5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnRva2VuaXplci5lbmRPZkZpbGUoKSkge1xuICAgICAgICAgICAgICAgIGxhc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGUyLnJhd3MuYmV0d2VlbiA9IHRoaXMuc3BhY2VzQW5kQ29tbWVudHNGcm9tRW5kKHBhcmFtcyk7XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBub2RlMi5yYXdzLmFmdGVyTmFtZSA9IHRoaXMuc3BhY2VzQW5kQ29tbWVudHNGcm9tU3RhcnQocGFyYW1zKTtcbiAgICAgICAgICAgIHRoaXMucmF3KG5vZGUyLCBcInBhcmFtc1wiLCBwYXJhbXMpO1xuICAgICAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHBhcmFtc1twYXJhbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgbm9kZTIuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5bM10gfHwgdG9rZW5bMl0pO1xuICAgICAgICAgICAgICAgIG5vZGUyLnNvdXJjZS5lbmQub2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGFjZXMgPSBub2RlMi5yYXdzLmJldHdlZW47XG4gICAgICAgICAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUyLnJhd3MuYWZ0ZXJOYW1lID0gXCJcIjtcbiAgICAgICAgICAgIG5vZGUyLnBhcmFtcyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgIG5vZGUyLm5vZGVzID0gW107XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBub2RlMjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmNoZWNrTWlzc2VkU2VtaWNvbG9uID0gZnVuY3Rpb24gY2hlY2tNaXNzZWRTZW1pY29sb24odG9rZW5zKSB7XG4gICAgICAgIHZhciBjb2xvbiA9IHRoaXMuY29sb24odG9rZW5zKTtcbiAgICAgICAgaWYgKGNvbG9uID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICB2YXIgZm91bmRlZCA9IDA7XG4gICAgICAgIHZhciB0b2tlbjtcbiAgICAgICAgZm9yKHZhciBqID0gY29sb24gLSAxOyBqID49IDA7IGotLSl7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tqXTtcbiAgICAgICAgICAgIGlmICh0b2tlblswXSAhPT0gXCJzcGFjZVwiKSB7XG4gICAgICAgICAgICAgICAgZm91bmRlZCArPSAxO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZGVkID09PSAyKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFwiTWlzc2VkIHNlbWljb2xvblwiLCB0b2tlblswXSA9PT0gXCJ3b3JkXCIgPyB0b2tlblszXSArIDEgOiB0b2tlblsyXSk7XG4gICAgfTtcbiAgICBfcHJvdG8uY29sb24gPSBmdW5jdGlvbiBjb2xvbih0b2tlbnMpIHtcbiAgICAgICAgdmFyIGJyYWNrZXRzID0gMDtcbiAgICAgICAgdmFyIHRva2VuLCB0eXBlLCBwcmV2O1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZSh0b2tlbnMuZW50cmllcygpKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIF9zdGVwX3ZhbHVlID0gX3N0ZXAudmFsdWUsIGkyID0gX3N0ZXBfdmFsdWVbMF0sIGVsZW1lbnQgPSBfc3RlcF92YWx1ZVsxXTtcbiAgICAgICAgICAgIHRva2VuID0gZWxlbWVudDtcbiAgICAgICAgICAgIHR5cGUgPSB0b2tlblswXTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcIihcIikge1xuICAgICAgICAgICAgICAgIGJyYWNrZXRzICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCIpXCIpIHtcbiAgICAgICAgICAgICAgICBicmFja2V0cyAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJyYWNrZXRzID09PSAwICYmIHR5cGUgPT09IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG91YmxlQ29sb24odG9rZW4pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldlswXSA9PT0gXCJ3b3JkXCIgJiYgcHJldlsxXSA9PT0gXCJwcm9naWRcIikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldiA9IHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIF9wcm90by5jb21tZW50ID0gZnVuY3Rpb24gY29tbWVudCh0b2tlbikge1xuICAgICAgICB2YXIgbm9kZTIgPSBuZXcgQ29tbWVudCQyJDEoKTtcbiAgICAgICAgdGhpcy5pbml0KG5vZGUyLCB0b2tlblsyXSk7XG4gICAgICAgIG5vZGUyLnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKHRva2VuWzNdIHx8IHRva2VuWzJdKTtcbiAgICAgICAgbm9kZTIuc291cmNlLmVuZC5vZmZzZXQrKztcbiAgICAgICAgdmFyIHRleHQgPSB0b2tlblsxXS5zbGljZSgyLCAtMik7XG4gICAgICAgIGlmICgvXlxccyokLy50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICBub2RlMi50ZXh0ID0gXCJcIjtcbiAgICAgICAgICAgIG5vZGUyLnJhd3MubGVmdCA9IHRleHQ7XG4gICAgICAgICAgICBub2RlMi5yYXdzLnJpZ2h0ID0gXCJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IHRleHQubWF0Y2goL14oXFxzKikoW15dKlxcUykoXFxzKikkLyk7XG4gICAgICAgICAgICBub2RlMi50ZXh0ID0gbWF0Y2hbMl07XG4gICAgICAgICAgICBub2RlMi5yYXdzLmxlZnQgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIG5vZGUyLnJhd3MucmlnaHQgPSBtYXRjaFszXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmNyZWF0ZVRva2VuaXplciA9IGZ1bmN0aW9uIGNyZWF0ZVRva2VuaXplcigpIHtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIgPSB0b2tlbml6ZXIyJDEodGhpcy5pbnB1dCk7XG4gICAgfTtcbiAgICBfcHJvdG8uZGVjbCA9IGZ1bmN0aW9uIGRlY2wodG9rZW5zLCBjdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICB2YXIgbm9kZTIgPSBuZXcgRGVjbGFyYXRpb24kMiQxKCk7XG4gICAgICAgIHRoaXMuaW5pdChub2RlMiwgdG9rZW5zWzBdWzJdKTtcbiAgICAgICAgdmFyIGxhc3QgPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdFswXSA9PT0gXCI7XCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2VtaWNvbG9uID0gdHJ1ZTtcbiAgICAgICAgICAgIHRva2Vucy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlMi5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbihsYXN0WzNdIHx8IGxhc3RbMl0gfHwgZmluZExhc3RXaXRoUG9zaXRpb24kMSh0b2tlbnMpKTtcbiAgICAgICAgbm9kZTIuc291cmNlLmVuZC5vZmZzZXQrKztcbiAgICAgICAgd2hpbGUodG9rZW5zWzBdWzBdICE9PSBcIndvcmRcIil7XG4gICAgICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMSkgdGhpcy51bmtub3duV29yZCh0b2tlbnMpO1xuICAgICAgICAgICAgbm9kZTIucmF3cy5iZWZvcmUgKz0gdG9rZW5zLnNoaWZ0KClbMV07XG4gICAgICAgIH1cbiAgICAgICAgbm9kZTIuc291cmNlLnN0YXJ0ID0gdGhpcy5nZXRQb3NpdGlvbih0b2tlbnNbMF1bMl0pO1xuICAgICAgICBub2RlMi5wcm9wID0gXCJcIjtcbiAgICAgICAgd2hpbGUodG9rZW5zLmxlbmd0aCl7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHRva2Vuc1swXVswXTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcIjpcIiB8fCB0eXBlID09PSBcInNwYWNlXCIgfHwgdHlwZSA9PT0gXCJjb21tZW50XCIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUyLnByb3AgKz0gdG9rZW5zLnNoaWZ0KClbMV07XG4gICAgICAgIH1cbiAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuID0gXCJcIjtcbiAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICB3aGlsZSh0b2tlbnMubGVuZ3RoKXtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAodG9rZW5bMF0gPT09IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuICs9IHRva2VuWzFdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5bMF0gPT09IFwid29yZFwiICYmIC9cXHcvLnRlc3QodG9rZW5bMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5rbm93bldvcmQoW1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUyLnJhd3MuYmV0d2VlbiArPSB0b2tlblsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZTIucHJvcFswXSA9PT0gXCJfXCIgfHwgbm9kZTIucHJvcFswXSA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgIG5vZGUyLnJhd3MuYmVmb3JlICs9IG5vZGUyLnByb3BbMF07XG4gICAgICAgICAgICBub2RlMi5wcm9wID0gbm9kZTIucHJvcC5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlyc3RTcGFjZXMgPSBbXTtcbiAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgIHdoaWxlKHRva2Vucy5sZW5ndGgpe1xuICAgICAgICAgICAgbmV4dCA9IHRva2Vuc1swXVswXTtcbiAgICAgICAgICAgIGlmIChuZXh0ICE9PSBcInNwYWNlXCIgJiYgbmV4dCAhPT0gXCJjb21tZW50XCIpIGJyZWFrO1xuICAgICAgICAgICAgZmlyc3RTcGFjZXMucHVzaCh0b2tlbnMuc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVjaGVja01pc3NlZFNlbWljb2xvbih0b2tlbnMpO1xuICAgICAgICBmb3IodmFyIGkyID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pe1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaTJdO1xuICAgICAgICAgICAgaWYgKHRva2VuWzFdLnRvTG93ZXJDYXNlKCkgPT09IFwiIWltcG9ydGFudFwiKSB7XG4gICAgICAgICAgICAgICAgbm9kZTIuaW1wb3J0YW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgc3RyaW5nID0gdGhpcy5zdHJpbmdGcm9tKHRva2VucywgaTIpO1xuICAgICAgICAgICAgICAgIHN0cmluZyA9IHRoaXMuc3BhY2VzRnJvbUVuZCh0b2tlbnMpICsgc3RyaW5nO1xuICAgICAgICAgICAgICAgIGlmIChzdHJpbmcgIT09IFwiICFpbXBvcnRhbnRcIikgbm9kZTIucmF3cy5pbXBvcnRhbnQgPSBzdHJpbmc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuWzFdLnRvTG93ZXJDYXNlKCkgPT09IFwiaW1wb3J0YW50XCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGUgPSB0b2tlbnMuc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBqID0gaTI7IGogPiAwOyBqLS0pe1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZTEgPSBjYWNoZVtqXVswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0ci50cmltKCkuaW5kZXhPZihcIiFcIikgPT09IDAgJiYgdHlwZTEgIT09IFwic3BhY2VcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RyID0gY2FjaGUucG9wKClbMV0gKyBzdHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdHIudHJpbSgpLmluZGV4T2YoXCIhXCIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUyLmltcG9ydGFudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUyLnJhd3MuaW1wb3J0YW50ID0gc3RyO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMgPSBjYWNoZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW5bMF0gIT09IFwic3BhY2VcIiAmJiB0b2tlblswXSAhPT0gXCJjb21tZW50XCIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgaGFzV29yZCA9IHRva2Vucy5zb21lKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICByZXR1cm4gaTJbMF0gIT09IFwic3BhY2VcIiAmJiBpMlswXSAhPT0gXCJjb21tZW50XCI7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaGFzV29yZCkge1xuICAgICAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuICs9IGZpcnN0U3BhY2VzLm1hcChmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpMlsxXTtcbiAgICAgICAgICAgIH0pLmpvaW4oXCJcIik7XG4gICAgICAgICAgICBmaXJzdFNwYWNlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmF3KG5vZGUyLCBcInZhbHVlXCIsIGZpcnN0U3BhY2VzLmNvbmNhdCh0b2tlbnMpLCBjdXN0b21Qcm9wZXJ0eSk7XG4gICAgICAgIGlmIChub2RlMi52YWx1ZS5pbmNsdWRlcyhcIjpcIikgJiYgIWN1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrTWlzc2VkU2VtaWNvbG9uKHRva2Vucyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5kb3VibGVDb2xvbiA9IGZ1bmN0aW9uIGRvdWJsZUNvbG9uKHRva2VuKSB7XG4gICAgICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXCJEb3VibGUgY29sb25cIiwge1xuICAgICAgICAgICAgb2Zmc2V0OiB0b2tlblsyXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRva2VuWzJdICsgdG9rZW5bMV0ubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmVtcHR5UnVsZSA9IGZ1bmN0aW9uIGVtcHR5UnVsZSh0b2tlbikge1xuICAgICAgICB2YXIgbm9kZTIgPSBuZXcgUnVsZSQyJDEoKTtcbiAgICAgICAgdGhpcy5pbml0KG5vZGUyLCB0b2tlblsyXSk7XG4gICAgICAgIG5vZGUyLnNlbGVjdG9yID0gXCJcIjtcbiAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuID0gXCJcIjtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gbm9kZTI7XG4gICAgfTtcbiAgICBfcHJvdG8uZW5kID0gZnVuY3Rpb24gZW5kKHRva2VuKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQubm9kZXMgJiYgdGhpcy5jdXJyZW50Lm5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50LnJhd3Muc2VtaWNvbG9uID0gdGhpcy5zZW1pY29sb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZW1pY29sb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJyZW50LnJhd3MuYWZ0ZXIgPSAodGhpcy5jdXJyZW50LnJhd3MuYWZ0ZXIgfHwgXCJcIikgKyB0aGlzLnNwYWNlcztcbiAgICAgICAgdGhpcy5zcGFjZXMgPSBcIlwiO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50LnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50LnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKHRva2VuWzJdKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudC5zb3VyY2UuZW5kLm9mZnNldCsrO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5jdXJyZW50LnBhcmVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudW5leHBlY3RlZENsb3NlKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmVuZEZpbGUgPSBmdW5jdGlvbiBlbmRGaWxlKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50LnBhcmVudCkgdGhpcy51bmNsb3NlZEJsb2NrKCk7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQubm9kZXMgJiYgdGhpcy5jdXJyZW50Lm5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50LnJhd3Muc2VtaWNvbG9uID0gdGhpcy5zZW1pY29sb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50LnJhd3MuYWZ0ZXIgPSAodGhpcy5jdXJyZW50LnJhd3MuYWZ0ZXIgfHwgXCJcIikgKyB0aGlzLnNwYWNlcztcbiAgICAgICAgdGhpcy5yb290LnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKHRoaXMudG9rZW5pemVyLnBvc2l0aW9uKCkpO1xuICAgIH07XG4gICAgX3Byb3RvLmZyZWVTZW1pY29sb24gPSBmdW5jdGlvbiBmcmVlU2VtaWNvbG9uKHRva2VuKSB7XG4gICAgICAgIHRoaXMuc3BhY2VzICs9IHRva2VuWzFdO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50Lm5vZGVzKSB7XG4gICAgICAgICAgICB2YXIgcHJldiA9IHRoaXMuY3VycmVudC5ub2Rlc1t0aGlzLmN1cnJlbnQubm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAocHJldiAmJiBwcmV2LnR5cGUgPT09IFwicnVsZVwiICYmICFwcmV2LnJhd3Mub3duU2VtaWNvbG9uKSB7XG4gICAgICAgICAgICAgICAgcHJldi5yYXdzLm93blNlbWljb2xvbiA9IHRoaXMuc3BhY2VzO1xuICAgICAgICAgICAgICAgIHRoaXMuc3BhY2VzID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gSGVscGVyc1xuICAgIF9wcm90by5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIGdldFBvc2l0aW9uKG9mZnNldCkge1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5pbnB1dC5mcm9tT2Zmc2V0KG9mZnNldCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2x1bW46IHBvcy5jb2wsXG4gICAgICAgICAgICBsaW5lOiBwb3MubGluZSxcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8uaW5pdCA9IGZ1bmN0aW9uIGluaXQobm9kZTIsIG9mZnNldCkge1xuICAgICAgICB0aGlzLmN1cnJlbnQucHVzaChub2RlMik7XG4gICAgICAgIG5vZGUyLnNvdXJjZSA9IHtcbiAgICAgICAgICAgIGlucHV0OiB0aGlzLmlucHV0LFxuICAgICAgICAgICAgc3RhcnQ6IHRoaXMuZ2V0UG9zaXRpb24ob2Zmc2V0KVxuICAgICAgICB9O1xuICAgICAgICBub2RlMi5yYXdzLmJlZm9yZSA9IHRoaXMuc3BhY2VzO1xuICAgICAgICB0aGlzLnNwYWNlcyA9IFwiXCI7XG4gICAgICAgIGlmIChub2RlMi50eXBlICE9PSBcImNvbW1lbnRcIikgdGhpcy5zZW1pY29sb24gPSBmYWxzZTtcbiAgICB9O1xuICAgIF9wcm90by5vdGhlciA9IGZ1bmN0aW9uIG90aGVyKHN0YXJ0KSB7XG4gICAgICAgIHZhciBlbmQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHR5cGUgPSBudWxsO1xuICAgICAgICB2YXIgY29sb24gPSBmYWxzZTtcbiAgICAgICAgdmFyIGJyYWNrZXQgPSBudWxsO1xuICAgICAgICB2YXIgYnJhY2tldHMgPSBbXTtcbiAgICAgICAgdmFyIGN1c3RvbVByb3BlcnR5ID0gc3RhcnRbMV0uc3RhcnRzV2l0aChcIi0tXCIpO1xuICAgICAgICB2YXIgdG9rZW5zID0gW107XG4gICAgICAgIHZhciB0b2tlbiA9IHN0YXJ0O1xuICAgICAgICB3aGlsZSh0b2tlbil7XG4gICAgICAgICAgICB0eXBlID0gdG9rZW5bMF07XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCIoXCIgfHwgdHlwZSA9PT0gXCJbXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJyYWNrZXQpIGJyYWNrZXQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBicmFja2V0cy5wdXNoKHR5cGUgPT09IFwiKFwiID8gXCIpXCIgOiBcIl1cIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1c3RvbVByb3BlcnR5ICYmIGNvbG9uICYmIHR5cGUgPT09IFwie1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFicmFja2V0KSBicmFja2V0ID0gdG9rZW47XG4gICAgICAgICAgICAgICAgYnJhY2tldHMucHVzaChcIn1cIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJyYWNrZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcIjtcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjbCh0b2tlbnMsIGN1c3RvbVByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIntcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bGUodG9rZW5zKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b2tlbml6ZXIuYmFjayh0b2tlbnMucG9wKCkpO1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IGJyYWNrZXRzW2JyYWNrZXRzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICAgICAgYnJhY2tldHMucG9wKCk7XG4gICAgICAgICAgICAgICAgaWYgKGJyYWNrZXRzLmxlbmd0aCA9PT0gMCkgYnJhY2tldCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMudG9rZW5pemVyLm5leHRUb2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRva2VuaXplci5lbmRPZkZpbGUoKSkgZW5kID0gdHJ1ZTtcbiAgICAgICAgaWYgKGJyYWNrZXRzLmxlbmd0aCA+IDApIHRoaXMudW5jbG9zZWRCcmFja2V0KGJyYWNrZXQpO1xuICAgICAgICBpZiAoZW5kICYmIGNvbG9uKSB7XG4gICAgICAgICAgICBpZiAoIWN1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUodG9rZW5zLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXVswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBcInNwYWNlXCIgJiYgdG9rZW4gIT09IFwiY29tbWVudFwiKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b2tlbml6ZXIuYmFjayh0b2tlbnMucG9wKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVjbCh0b2tlbnMsIGN1c3RvbVByb3BlcnR5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudW5rbm93bldvcmQodG9rZW5zKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoKSB7XG4gICAgICAgIHZhciB0b2tlbjtcbiAgICAgICAgd2hpbGUoIXRoaXMudG9rZW5pemVyLmVuZE9mRmlsZSgpKXtcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy50b2tlbml6ZXIubmV4dFRva2VuKCk7XG4gICAgICAgICAgICBzd2l0Y2godG9rZW5bMF0pe1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzcGFjZVwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwYWNlcyArPSB0b2tlblsxXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIjtcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmVlU2VtaWNvbG9uKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIn1cIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmQodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29tbWVudFwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1lbnQodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiYXQtd29yZFwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0cnVsZSh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ7XCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1wdHlSdWxlKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vdGhlcih0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW5kRmlsZSgpO1xuICAgIH07XG4gICAgX3Byb3RvLnByZWNoZWNrTWlzc2VkU2VtaWNvbG9uID0gZnVuY3Rpb24gcHJlY2hlY2tNaXNzZWRTZW1pY29sb24oKSB7fTtcbiAgICBfcHJvdG8ucmF3ID0gZnVuY3Rpb24gcmF3KG5vZGUyLCBwcm9wLCB0b2tlbnMsIGN1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgIHZhciB0b2tlbiwgdHlwZTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRva2Vucy5sZW5ndGg7XG4gICAgICAgIHZhciB2YWx1ZSA9IFwiXCI7XG4gICAgICAgIHZhciBjbGVhbiA9IHRydWU7XG4gICAgICAgIHZhciBuZXh0LCBwcmV2O1xuICAgICAgICBmb3IodmFyIGkyID0gMDsgaTIgPCBsZW5ndGg7IGkyICs9IDEpe1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaTJdO1xuICAgICAgICAgICAgdHlwZSA9IHRva2VuWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwic3BhY2VcIiAmJiBpMiA9PT0gbGVuZ3RoIC0gMSAmJiAhY3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgICAgICAgICAgICAgIHByZXYgPSB0b2tlbnNbaTIgLSAxXSA/IHRva2Vuc1tpMiAtIDFdWzBdIDogXCJlbXB0eVwiO1xuICAgICAgICAgICAgICAgIG5leHQgPSB0b2tlbnNbaTIgKyAxXSA/IHRva2Vuc1tpMiArIDFdWzBdIDogXCJlbXB0eVwiO1xuICAgICAgICAgICAgICAgIGlmICghU0FGRV9DT01NRU5UX05FSUdIQk9SJDFbcHJldl0gJiYgIVNBRkVfQ09NTUVOVF9ORUlHSEJPUiQxW25leHRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5zbGljZSgtMSkgPT09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gdG9rZW5bMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gdG9rZW5bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjbGVhbikge1xuICAgICAgICAgICAgdmFyIHJhdyA9IHRva2Vucy5yZWR1Y2UoZnVuY3Rpb24oYWxsLCBpMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhbGwgKyBpMlsxXTtcbiAgICAgICAgICAgIH0sIFwiXCIpO1xuICAgICAgICAgICAgbm9kZTIucmF3c1twcm9wXSA9IHtcbiAgICAgICAgICAgICAgICByYXc6IHJhdyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbm9kZTJbcHJvcF0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5ydWxlID0gZnVuY3Rpb24gcnVsZSh0b2tlbnMpIHtcbiAgICAgICAgdG9rZW5zLnBvcCgpO1xuICAgICAgICB2YXIgbm9kZTIgPSBuZXcgUnVsZSQyJDEoKTtcbiAgICAgICAgdGhpcy5pbml0KG5vZGUyLCB0b2tlbnNbMF1bMl0pO1xuICAgICAgICBub2RlMi5yYXdzLmJldHdlZW4gPSB0aGlzLnNwYWNlc0FuZENvbW1lbnRzRnJvbUVuZCh0b2tlbnMpO1xuICAgICAgICB0aGlzLnJhdyhub2RlMiwgXCJzZWxlY3RvclwiLCB0b2tlbnMpO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBub2RlMjtcbiAgICB9O1xuICAgIF9wcm90by5zcGFjZXNBbmRDb21tZW50c0Zyb21FbmQgPSBmdW5jdGlvbiBzcGFjZXNBbmRDb21tZW50c0Zyb21FbmQodG9rZW5zKSB7XG4gICAgICAgIHZhciBsYXN0VG9rZW5UeXBlO1xuICAgICAgICB2YXIgc3BhY2VzID0gXCJcIjtcbiAgICAgICAgd2hpbGUodG9rZW5zLmxlbmd0aCl7XG4gICAgICAgICAgICBsYXN0VG9rZW5UeXBlID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXVswXTtcbiAgICAgICAgICAgIGlmIChsYXN0VG9rZW5UeXBlICE9PSBcInNwYWNlXCIgJiYgbGFzdFRva2VuVHlwZSAhPT0gXCJjb21tZW50XCIpIGJyZWFrO1xuICAgICAgICAgICAgc3BhY2VzID0gdG9rZW5zLnBvcCgpWzFdICsgc3BhY2VzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFjZXM7XG4gICAgfTtcbiAgICAvLyBFcnJvcnNcbiAgICBfcHJvdG8uc3BhY2VzQW5kQ29tbWVudHNGcm9tU3RhcnQgPSBmdW5jdGlvbiBzcGFjZXNBbmRDb21tZW50c0Zyb21TdGFydCh0b2tlbnMpIHtcbiAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgIHZhciBzcGFjZXMgPSBcIlwiO1xuICAgICAgICB3aGlsZSh0b2tlbnMubGVuZ3RoKXtcbiAgICAgICAgICAgIG5leHQgPSB0b2tlbnNbMF1bMF07XG4gICAgICAgICAgICBpZiAobmV4dCAhPT0gXCJzcGFjZVwiICYmIG5leHQgIT09IFwiY29tbWVudFwiKSBicmVhaztcbiAgICAgICAgICAgIHNwYWNlcyArPSB0b2tlbnMuc2hpZnQoKVsxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BhY2VzO1xuICAgIH07XG4gICAgX3Byb3RvLnNwYWNlc0Zyb21FbmQgPSBmdW5jdGlvbiBzcGFjZXNGcm9tRW5kKHRva2Vucykge1xuICAgICAgICB2YXIgbGFzdFRva2VuVHlwZTtcbiAgICAgICAgdmFyIHNwYWNlcyA9IFwiXCI7XG4gICAgICAgIHdoaWxlKHRva2Vucy5sZW5ndGgpe1xuICAgICAgICAgICAgbGFzdFRva2VuVHlwZSA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV1bMF07XG4gICAgICAgICAgICBpZiAobGFzdFRva2VuVHlwZSAhPT0gXCJzcGFjZVwiKSBicmVhaztcbiAgICAgICAgICAgIHNwYWNlcyA9IHRva2Vucy5wb3AoKVsxXSArIHNwYWNlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BhY2VzO1xuICAgIH07XG4gICAgX3Byb3RvLnN0cmluZ0Zyb20gPSBmdW5jdGlvbiBzdHJpbmdGcm9tKHRva2VucywgZnJvbSkge1xuICAgICAgICB2YXIgcmVzdWx0MiA9IFwiXCI7XG4gICAgICAgIGZvcih2YXIgaTIgPSBmcm9tOyBpMiA8IHRva2Vucy5sZW5ndGg7IGkyKyspe1xuICAgICAgICAgICAgcmVzdWx0MiArPSB0b2tlbnNbaTJdWzFdO1xuICAgICAgICB9XG4gICAgICAgIHRva2Vucy5zcGxpY2UoZnJvbSwgdG9rZW5zLmxlbmd0aCAtIGZyb20pO1xuICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICB9O1xuICAgIF9wcm90by51bmNsb3NlZEJsb2NrID0gZnVuY3Rpb24gdW5jbG9zZWRCbG9jaygpIHtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuY3VycmVudC5zb3VyY2Uuc3RhcnQ7XG4gICAgICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXCJVbmNsb3NlZCBibG9ja1wiLCBwb3MubGluZSwgcG9zLmNvbHVtbik7XG4gICAgfTtcbiAgICBfcHJvdG8udW5jbG9zZWRCcmFja2V0ID0gZnVuY3Rpb24gdW5jbG9zZWRCcmFja2V0KGJyYWNrZXQpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcIlVuY2xvc2VkIGJyYWNrZXRcIiwge1xuICAgICAgICAgICAgb2Zmc2V0OiBicmFja2V0WzJdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG9mZnNldDogYnJhY2tldFsyXSArIDFcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8udW5leHBlY3RlZENsb3NlID0gZnVuY3Rpb24gdW5leHBlY3RlZENsb3NlKHRva2VuKSB7XG4gICAgICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXCJVbmV4cGVjdGVkIH1cIiwge1xuICAgICAgICAgICAgb2Zmc2V0OiB0b2tlblsyXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRva2VuWzJdICsgMVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by51bmtub3duV29yZCA9IGZ1bmN0aW9uIHVua25vd25Xb3JkKHRva2Vucykge1xuICAgICAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFwiVW5rbm93biB3b3JkXCIsIHtcbiAgICAgICAgICAgIG9mZnNldDogdG9rZW5zWzBdWzJdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG9mZnNldDogdG9rZW5zWzBdWzJdICsgdG9rZW5zWzBdWzFdLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by51bm5hbWVkQXRydWxlID0gZnVuY3Rpb24gdW5uYW1lZEF0cnVsZShub2RlMiwgdG9rZW4pIHtcbiAgICAgICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcIkF0LXJ1bGUgd2l0aG91dCBuYW1lXCIsIHtcbiAgICAgICAgICAgIG9mZnNldDogdG9rZW5bMl1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgb2Zmc2V0OiB0b2tlblsyXSArIHRva2VuWzFdLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBQYXJzZXI7XG59KCk7XG52YXIgcGFyc2VyJDEgPSBQYXJzZXIkMSQxO1xudmFyIENvbnRhaW5lciQyJDEgPSBjb250YWluZXIkMTtcbnZhciBQYXJzZXIyJDEgPSBwYXJzZXIkMTtcbnZhciBJbnB1dCQyJDEgPSBpbnB1dCQxO1xuZnVuY3Rpb24gcGFyc2UkMyQxKGNzcywgb3B0cykge1xuICAgIHZhciBpbnB1dDIgPSBuZXcgSW5wdXQkMiQxKGNzcywgb3B0cyk7XG4gICAgdmFyIHBhcnNlcjIgPSBuZXcgUGFyc2VyMiQxKGlucHV0Mik7XG4gICAgdHJ5IHtcbiAgICAgICAgcGFyc2VyMi5wYXJzZSgpO1xuICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmIChlMi5uYW1lID09PSBcIkNzc1N5bnRheEVycm9yXCIgJiYgb3B0cyAmJiBvcHRzLmZyb20pIHtcbiAgICAgICAgICAgICAgICBpZiAoL1xcLnNjc3MkL2kudGVzdChvcHRzLmZyb20pKSB7XG4gICAgICAgICAgICAgICAgICAgIGUyLm1lc3NhZ2UgKz0gXCJcXG5Zb3UgdHJpZWQgdG8gcGFyc2UgU0NTUyB3aXRoIHRoZSBzdGFuZGFyZCBDU1MgcGFyc2VyOyB0cnkgYWdhaW4gd2l0aCB0aGUgcG9zdGNzcy1zY3NzIHBhcnNlclwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoL1xcLnNhc3MvaS50ZXN0KG9wdHMuZnJvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZTIubWVzc2FnZSArPSBcIlxcbllvdSB0cmllZCB0byBwYXJzZSBTYXNzIHdpdGggdGhlIHN0YW5kYXJkIENTUyBwYXJzZXI7IHRyeSBhZ2FpbiB3aXRoIHRoZSBwb3N0Y3NzLXNhc3MgcGFyc2VyXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgvXFwubGVzcyQvaS50ZXN0KG9wdHMuZnJvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZTIubWVzc2FnZSArPSBcIlxcbllvdSB0cmllZCB0byBwYXJzZSBMZXNzIHdpdGggdGhlIHN0YW5kYXJkIENTUyBwYXJzZXI7IHRyeSBhZ2FpbiB3aXRoIHRoZSBwb3N0Y3NzLWxlc3MgcGFyc2VyXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGUyO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VyMi5yb290O1xufVxudmFyIHBhcnNlXzEkMSA9IHBhcnNlJDMkMTtcbnBhcnNlJDMkMS5kZWZhdWx0ID0gcGFyc2UkMyQxO1xuQ29udGFpbmVyJDIkMS5yZWdpc3RlclBhcnNlKHBhcnNlJDMkMSk7XG52YXIgaXNDbGVhbiQzID0gc3ltYm9scyQxLmlzQ2xlYW4sIG15JDMgPSBzeW1ib2xzJDEubXk7XG52YXIgTWFwR2VuZXJhdG9yJDEkMSA9IG1hcEdlbmVyYXRvciQxO1xudmFyIHN0cmluZ2lmeSQyJDEgPSBzdHJpbmdpZnlfMSQxO1xudmFyIENvbnRhaW5lciQxJDEgPSBjb250YWluZXIkMTtcbnZhciBEb2N1bWVudCQyJDEgPSBkb2N1bWVudCQxJDE7XG52YXIgd2Fybk9uY2UkMSQxID0gd2Fybk9uY2UkMiQxO1xudmFyIFJlc3VsdCQyJDEgPSByZXN1bHQkMTtcbnZhciBwYXJzZSQyJDEgPSBwYXJzZV8xJDE7XG52YXIgUm9vdCQzJDEgPSByb290JDE7XG52YXIgVFlQRV9UT19DTEFTU19OQU1FJDEgPSB7XG4gICAgYXRydWxlOiBcIkF0UnVsZVwiLFxuICAgIGNvbW1lbnQ6IFwiQ29tbWVudFwiLFxuICAgIGRlY2w6IFwiRGVjbGFyYXRpb25cIixcbiAgICBkb2N1bWVudDogXCJEb2N1bWVudFwiLFxuICAgIHJvb3Q6IFwiUm9vdFwiLFxuICAgIHJ1bGU6IFwiUnVsZVwiXG59O1xudmFyIFBMVUdJTl9QUk9QUyQxID0ge1xuICAgIEF0UnVsZTogdHJ1ZSxcbiAgICBBdFJ1bGVFeGl0OiB0cnVlLFxuICAgIENvbW1lbnQ6IHRydWUsXG4gICAgQ29tbWVudEV4aXQ6IHRydWUsXG4gICAgRGVjbGFyYXRpb246IHRydWUsXG4gICAgRGVjbGFyYXRpb25FeGl0OiB0cnVlLFxuICAgIERvY3VtZW50OiB0cnVlLFxuICAgIERvY3VtZW50RXhpdDogdHJ1ZSxcbiAgICBPbmNlOiB0cnVlLFxuICAgIE9uY2VFeGl0OiB0cnVlLFxuICAgIHBvc3Rjc3NQbHVnaW46IHRydWUsXG4gICAgcHJlcGFyZTogdHJ1ZSxcbiAgICBSb290OiB0cnVlLFxuICAgIFJvb3RFeGl0OiB0cnVlLFxuICAgIFJ1bGU6IHRydWUsXG4gICAgUnVsZUV4aXQ6IHRydWVcbn07XG52YXIgTk9UX1ZJU0lUT1JTJDEgPSB7XG4gICAgT25jZTogdHJ1ZSxcbiAgICBwb3N0Y3NzUGx1Z2luOiB0cnVlLFxuICAgIHByZXBhcmU6IHRydWVcbn07XG52YXIgQ0hJTERSRU4kMSA9IDA7XG5mdW5jdGlvbiBpc1Byb21pc2UkMShvYmopIHtcbiAgICByZXR1cm4gKHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2Yob2JqKSkgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iai50aGVuID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBnZXRFdmVudHMkMShub2RlMikge1xuICAgIHZhciBrZXkgPSBmYWxzZTtcbiAgICB2YXIgdHlwZSA9IFRZUEVfVE9fQ0xBU1NfTkFNRSQxW25vZGUyLnR5cGVdO1xuICAgIGlmIChub2RlMi50eXBlID09PSBcImRlY2xcIikge1xuICAgICAgICBrZXkgPSBub2RlMi5wcm9wLnRvTG93ZXJDYXNlKCk7XG4gICAgfSBlbHNlIGlmIChub2RlMi50eXBlID09PSBcImF0cnVsZVwiKSB7XG4gICAgICAgIGtleSA9IG5vZGUyLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgaWYgKGtleSAmJiBub2RlMi5hcHBlbmQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICB0eXBlICsgXCItXCIgKyBrZXksXG4gICAgICAgICAgICBDSElMRFJFTiQxLFxuICAgICAgICAgICAgdHlwZSArIFwiRXhpdFwiLFxuICAgICAgICAgICAgdHlwZSArIFwiRXhpdC1cIiArIGtleVxuICAgICAgICBdO1xuICAgIH0gZWxzZSBpZiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgdHlwZSArIFwiLVwiICsga2V5LFxuICAgICAgICAgICAgdHlwZSArIFwiRXhpdFwiLFxuICAgICAgICAgICAgdHlwZSArIFwiRXhpdC1cIiArIGtleVxuICAgICAgICBdO1xuICAgIH0gZWxzZSBpZiAobm9kZTIuYXBwZW5kKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgQ0hJTERSRU4kMSxcbiAgICAgICAgICAgIHR5cGUgKyBcIkV4aXRcIlxuICAgICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgdHlwZSArIFwiRXhpdFwiXG4gICAgICAgIF07XG4gICAgfVxufVxuZnVuY3Rpb24gdG9TdGFjayQxKG5vZGUyKSB7XG4gICAgdmFyIGV2ZW50cztcbiAgICBpZiAobm9kZTIudHlwZSA9PT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICAgIGV2ZW50cyA9IFtcbiAgICAgICAgICAgIFwiRG9jdW1lbnRcIixcbiAgICAgICAgICAgIENISUxEUkVOJDEsXG4gICAgICAgICAgICBcIkRvY3VtZW50RXhpdFwiXG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmIChub2RlMi50eXBlID09PSBcInJvb3RcIikge1xuICAgICAgICBldmVudHMgPSBbXG4gICAgICAgICAgICBcIlJvb3RcIixcbiAgICAgICAgICAgIENISUxEUkVOJDEsXG4gICAgICAgICAgICBcIlJvb3RFeGl0XCJcbiAgICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBldmVudHMgPSBnZXRFdmVudHMkMShub2RlMik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGV2ZW50SW5kZXg6IDAsXG4gICAgICAgIGV2ZW50czogZXZlbnRzLFxuICAgICAgICBpdGVyYXRvcjogMCxcbiAgICAgICAgbm9kZTogbm9kZTIsXG4gICAgICAgIHZpc2l0b3JJbmRleDogMCxcbiAgICAgICAgdmlzaXRvcnM6IFtdXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNsZWFuTWFya3MkMShub2RlMikge1xuICAgIG5vZGUyW2lzQ2xlYW4kM10gPSBmYWxzZTtcbiAgICBpZiAobm9kZTIubm9kZXMpIG5vZGUyLm5vZGVzLmZvckVhY2goZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgcmV0dXJuIGNsZWFuTWFya3MkMShpMik7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5vZGUyO1xufVxudmFyIHBvc3Rjc3MkMiQxID0ge307XG52YXIgTGF6eVJlc3VsdCQyJDEgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIExhenlSZXN1bHQocHJvY2Vzc29yMiwgY3NzLCBvcHRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc3RyaW5naWZpZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHJvb3QyO1xuICAgICAgICBpZiAoKHR5cGVvZiBjc3MgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YoY3NzKSkgPT09IFwib2JqZWN0XCIgJiYgY3NzICE9PSBudWxsICYmIChjc3MudHlwZSA9PT0gXCJyb290XCIgfHwgY3NzLnR5cGUgPT09IFwiZG9jdW1lbnRcIikpIHtcbiAgICAgICAgICAgIHJvb3QyID0gY2xlYW5NYXJrcyQxKGNzcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2luc3RhbmNlb2YoY3NzLCBMYXp5UmVzdWx0KSB8fCBfaW5zdGFuY2VvZihjc3MsIFJlc3VsdCQyJDEpKSB7XG4gICAgICAgICAgICByb290MiA9IGNsZWFuTWFya3MkMShjc3Mucm9vdCk7XG4gICAgICAgICAgICBpZiAoY3NzLm1hcCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0cy5tYXAgPT09IFwidW5kZWZpbmVkXCIpIG9wdHMubWFwID0ge307XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRzLm1hcC5pbmxpbmUpIG9wdHMubWFwLmlubGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG9wdHMubWFwLnByZXYgPSBjc3MubWFwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBhcnNlcjIgPSBwYXJzZSQyJDE7XG4gICAgICAgICAgICBpZiAob3B0cy5zeW50YXgpIHBhcnNlcjIgPSBvcHRzLnN5bnRheC5wYXJzZTtcbiAgICAgICAgICAgIGlmIChvcHRzLnBhcnNlcikgcGFyc2VyMiA9IG9wdHMucGFyc2VyO1xuICAgICAgICAgICAgaWYgKHBhcnNlcjIucGFyc2UpIHBhcnNlcjIgPSBwYXJzZXIyLnBhcnNlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByb290MiA9IHBhcnNlcjIoY3NzLCBvcHRzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyb290MiAmJiAhcm9vdDJbbXkkM10pIHtcbiAgICAgICAgICAgICAgICBDb250YWluZXIkMSQxLnJlYnVpbGQocm9vdDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzdWx0ID0gbmV3IFJlc3VsdCQyJDEocHJvY2Vzc29yMiwgcm9vdDIsIG9wdHMpO1xuICAgICAgICB0aGlzLmhlbHBlcnMgPSBfZXh0ZW5kcyh7fSwgcG9zdGNzcyQyJDEsIHtcbiAgICAgICAgICAgIHBvc3Rjc3M6IHBvc3Rjc3MkMiQxLFxuICAgICAgICAgICAgcmVzdWx0OiB0aGlzLnJlc3VsdFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gdGhpcy5wcm9jZXNzb3IucGx1Z2lucy5tYXAoZnVuY3Rpb24ocGx1Z2luMjIpIHtcbiAgICAgICAgICAgIGlmICgodHlwZW9mIHBsdWdpbjIyID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKHBsdWdpbjIyKSkgPT09IFwib2JqZWN0XCIgJiYgcGx1Z2luMjIucHJlcGFyZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgcGx1Z2luMjIsIHBsdWdpbjIyLnByZXBhcmUoX3RoaXMucmVzdWx0KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBwbHVnaW4yMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBMYXp5UmVzdWx0LnByb3RvdHlwZTtcbiAgICBfcHJvdG8uYXN5bmMgPSBmdW5jdGlvbiBhc3luYygpIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmVycm9yKTtcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2VkKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMucmVzdWx0KTtcbiAgICAgICAgaWYgKCF0aGlzLnByb2Nlc3NpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZyA9IHRoaXMucnVuQXN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzaW5nO1xuICAgIH07XG4gICAgX3Byb3RvLmNhdGNoID0gZnVuY3Rpb24gX2NhdGNoKG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXN5bmMoKS5jYXRjaChvblJlamVjdGVkKTtcbiAgICB9O1xuICAgIF9wcm90by5maW5hbGx5ID0gZnVuY3Rpb24gX2ZpbmFsbHkob25GaW5hbGx5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzeW5jKCkudGhlbihvbkZpbmFsbHksIG9uRmluYWxseSk7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0QXN5bmNFcnJvciA9IGZ1bmN0aW9uIGdldEFzeW5jRXJyb3IoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVzZSBwcm9jZXNzKGNzcykudGhlbihjYikgdG8gd29yayB3aXRoIGFzeW5jIHBsdWdpbnNcIik7XG4gICAgfTtcbiAgICBfcHJvdG8uaGFuZGxlRXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnJvciwgbm9kZTIpIHtcbiAgICAgICAgdmFyIHBsdWdpbjIyID0gdGhpcy5yZXN1bHQubGFzdFBsdWdpbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChub2RlMikgbm9kZTIuYWRkVG9FcnJvcihlcnJvcik7XG4gICAgICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gXCJDc3NTeW50YXhFcnJvclwiICYmICFlcnJvci5wbHVnaW4pIHtcbiAgICAgICAgICAgICAgICBlcnJvci5wbHVnaW4gPSBwbHVnaW4yMi5wb3N0Y3NzUGx1Z2luO1xuICAgICAgICAgICAgICAgIGVycm9yLnNldE1lc3NhZ2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGx1Z2luMjIucG9zdGNzc1ZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwbHVnaW5OYW1lID0gcGx1Z2luMjIucG9zdGNzc1BsdWdpbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBsdWdpblZlciA9IHBsdWdpbjIyLnBvc3Rjc3NWZXJzaW9uO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnVudGltZVZlciA9IHRoaXMucmVzdWx0LnByb2Nlc3Nvci52ZXJzaW9uO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYTIgPSBwbHVnaW5WZXIuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHJ1bnRpbWVWZXIuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYTJbMF0gIT09IGJbMF0gfHwgcGFyc2VJbnQoYTJbMV0pID4gcGFyc2VJbnQoYlsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmtub3duIGVycm9yIGZyb20gUG9zdENTUyBwbHVnaW4uIFlvdXIgY3VycmVudCBQb3N0Q1NTIHZlcnNpb24gaXMgXCIgKyBydW50aW1lVmVyICsgXCIsIGJ1dCBcIiArIHBsdWdpbk5hbWUgKyBcIiB1c2VzIFwiICsgcGx1Z2luVmVyICsgXCIuIFBlcmhhcHMgdGhpcyBpcyB0aGUgc291cmNlIG9mIHRoZSBlcnJvciBiZWxvdy5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS5lcnJvcikgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9O1xuICAgIF9wcm90by5wcmVwYXJlVmlzaXRvcnMgPSBmdW5jdGlvbiBwcmVwYXJlVmlzaXRvcnMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0ge307XG4gICAgICAgIHZhciBhZGQgPSBmdW5jdGlvbihwbHVnaW4yMiwgdHlwZSwgY2IpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMubGlzdGVuZXJzW3R5cGVdKSBfdGhpcy5saXN0ZW5lcnNbdHlwZV0gPSBbXTtcbiAgICAgICAgICAgIF90aGlzLmxpc3RlbmVyc1t0eXBlXS5wdXNoKFtcbiAgICAgICAgICAgICAgICBwbHVnaW4yMixcbiAgICAgICAgICAgICAgICBjYlxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHRoaXMucGx1Z2lucyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBwbHVnaW4yMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgaWYgKCh0eXBlb2YgcGx1Z2luMjIgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YocGx1Z2luMjIpKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgZXZlbnQgaW4gcGx1Z2luMjIpe1xuICAgICAgICAgICAgICAgICAgICBpZiAoIVBMVUdJTl9QUk9QUyQxW2V2ZW50XSAmJiAvXltBLVpdLy50ZXN0KGV2ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBldmVudCBcIiArIGV2ZW50ICsgXCIgaW4gXCIgKyBwbHVnaW4yMi5wb3N0Y3NzUGx1Z2luICsgXCIuIFRyeSB0byB1cGRhdGUgUG9zdENTUyAoXCIgKyB0aGlzLnByb2Nlc3Nvci52ZXJzaW9uICsgXCIgbm93KS5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFOT1RfVklTSVRPUlMkMVtldmVudF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdHlwZV9vZihwbHVnaW4yMltldmVudF0pID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBmaWx0ZXIgaW4gcGx1Z2luMjJbZXZlbnRdKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlciA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZChwbHVnaW4yMiwgZXZlbnQsIHBsdWdpbjIyW2V2ZW50XVtmaWx0ZXJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZChwbHVnaW4yMiwgZXZlbnQgKyBcIi1cIiArIGZpbHRlci50b0xvd2VyQ2FzZSgpLCBwbHVnaW4yMltldmVudF1bZmlsdGVyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4yMltldmVudF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZChwbHVnaW4yMiwgZXZlbnQsIHBsdWdpbjIyW2V2ZW50XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYXNMaXN0ZW5lciA9IE9iamVjdC5rZXlzKHRoaXMubGlzdGVuZXJzKS5sZW5ndGggPiAwO1xuICAgIH07XG4gICAgX3Byb3RvLnJ1bkFzeW5jID0gZnVuY3Rpb24gcnVuQXN5bmMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBfYXN5bmNfdG9fZ2VuZXJhdG9yKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGkyLCBwbHVnaW4yMiwgcHJvbWlzZSwgZXJyb3IsIHJvb3QyLCBzdGFjaywgcHJvbWlzZTEsIGUyLCBub2RlMiwgX2xvb3AsIF9pdGVyYXRvciwgX3N0ZXA7XG4gICAgICAgICAgICByZXR1cm4gX3RzX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbihfc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2goX3N0YXRlLmxhYmVsKXtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucGx1Z2luID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGkyIDwgX3RoaXMucGx1Z2lucy5sZW5ndGgpKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNlxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbjIyID0gX3RoaXMucGx1Z2luc1tpMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gX3RoaXMucnVuT25Sb290KHBsdWdpbjIyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNQcm9taXNlJDEocHJvbWlzZSkpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA1XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnRyeXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA1XG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDVcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF90aGlzLmhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgaTIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcmVwYXJlVmlzaXRvcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuaGFzTGlzdGVuZXIpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxOFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QyID0gX3RoaXMucmVzdWx0LnJvb3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUubGFiZWwgPSA3O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISFyb290Mltpc0NsZWFuJDNdKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTRcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICByb290Mltpc0NsZWFuJDNdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvU3RhY2skMShyb290MilcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUubGFiZWwgPSA4O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShzdGFjay5sZW5ndGggPiAwKSkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEzXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZTEgPSBfdGhpcy52aXNpdFRpY2soc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Byb21pc2UkMShwcm9taXNlMSkpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMlxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5sYWJlbCA9IDk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS50cnlzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEyXG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlMVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTJcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgICAgICBlMiA9IF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlMiA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLm5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfdGhpcy5oYW5kbGVFcnJvcihlMiwgbm9kZTIpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDhcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgN1xuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMubGlzdGVuZXJzLk9uY2VFeGl0KSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMThcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBfbG9vcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfc3RlcF92YWx1ZSwgcGx1Z2luMjIsIHZpc2l0b3IsIHJvb3RzLCBlMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RzX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbihfc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoKF9zdGF0ZS5sYWJlbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3N0ZXBfdmFsdWUgPSBfc3RlcC52YWx1ZSwgcGx1Z2luMjIgPSBfc3RlcF92YWx1ZVswXSwgdmlzaXRvciA9IF9zdGVwX3ZhbHVlWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc3VsdC5sYXN0UGx1Z2luID0gcGx1Z2luMjI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUudHJ5cy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocm9vdDIudHlwZSA9PT0gXCJkb2N1bWVudFwiKSkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgM1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdHMgPSByb290Mi5ub2Rlcy5tYXAoZnVuY3Rpb24oc3ViUm9vdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRvcihzdWJSb290LCBfdGhpcy5oZWxwZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChyb290cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRvcihyb290MiwgX3RoaXMuaGVscGVycylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLmxhYmVsID0gNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlMiA9IF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX3RoaXMuaGFuZGxlRXJyb3IoZTIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKF90aGlzLmxpc3RlbmVycy5PbmNlRXhpdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUubGFiZWwgPSAxNTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMThcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RzX3ZhbHVlcyhfbG9vcCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUubGFiZWwgPSAxNztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnByb2Nlc3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RyaW5naWZ5KClcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKCk7XG4gICAgfTtcbiAgICBfcHJvdG8ucnVuT25Sb290ID0gZnVuY3Rpb24gcnVuT25Sb290KHBsdWdpbjIyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucmVzdWx0Lmxhc3RQbHVnaW4gPSBwbHVnaW4yMjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICgodHlwZW9mIHBsdWdpbjIyID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKHBsdWdpbjIyKSkgPT09IFwib2JqZWN0XCIgJiYgcGx1Z2luMjIuT25jZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc3VsdC5yb290LnR5cGUgPT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm9vdHMgPSB0aGlzLnJlc3VsdC5yb290Lm5vZGVzLm1hcChmdW5jdGlvbihyb290Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbjIyLk9uY2Uocm9vdDIsIF90aGlzLmhlbHBlcnMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJvbWlzZSQxKHJvb3RzWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHJvb3RzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm9vdHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwbHVnaW4yMi5PbmNlKHRoaXMucmVzdWx0LnJvb3QsIHRoaXMuaGVscGVycyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4yMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbjIyKHRoaXMucmVzdWx0LnJvb3QsIHRoaXMucmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uc3RyaW5naWZ5ID0gZnVuY3Rpb24gc3RyaW5naWZ5KCkge1xuICAgICAgICBpZiAodGhpcy5lcnJvcikgdGhyb3cgdGhpcy5lcnJvcjtcbiAgICAgICAgaWYgKHRoaXMuc3RyaW5naWZpZWQpIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgICAgICAgdGhpcy5zdHJpbmdpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3luYygpO1xuICAgICAgICB2YXIgb3B0cyA9IHRoaXMucmVzdWx0Lm9wdHM7XG4gICAgICAgIHZhciBzdHIgPSBzdHJpbmdpZnkkMiQxO1xuICAgICAgICBpZiAob3B0cy5zeW50YXgpIHN0ciA9IG9wdHMuc3ludGF4LnN0cmluZ2lmeTtcbiAgICAgICAgaWYgKG9wdHMuc3RyaW5naWZpZXIpIHN0ciA9IG9wdHMuc3RyaW5naWZpZXI7XG4gICAgICAgIGlmIChzdHIuc3RyaW5naWZ5KSBzdHIgPSBzdHIuc3RyaW5naWZ5O1xuICAgICAgICB2YXIgbWFwID0gbmV3IE1hcEdlbmVyYXRvciQxJDEoc3RyLCB0aGlzLnJlc3VsdC5yb290LCB0aGlzLnJlc3VsdC5vcHRzKTtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXAuZ2VuZXJhdGUoKTtcbiAgICAgICAgdGhpcy5yZXN1bHQuY3NzID0gZGF0YVswXTtcbiAgICAgICAgdGhpcy5yZXN1bHQubWFwID0gZGF0YVsxXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0O1xuICAgIH07XG4gICAgX3Byb3RvLnN5bmMgPSBmdW5jdGlvbiBzeW5jKCkge1xuICAgICAgICBpZiAodGhpcy5lcnJvcikgdGhyb3cgdGhpcy5lcnJvcjtcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2VkKSByZXR1cm4gdGhpcy5yZXN1bHQ7XG4gICAgICAgIHRoaXMucHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2luZykge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5nZXRBc3luY0Vycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UodGhpcy5wbHVnaW5zKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIHBsdWdpbjIyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMucnVuT25Sb290KHBsdWdpbjIyKTtcbiAgICAgICAgICAgIGlmIChpc1Byb21pc2UkMShwcm9taXNlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZ2V0QXN5bmNFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlcGFyZVZpc2l0b3JzKCk7XG4gICAgICAgIGlmICh0aGlzLmhhc0xpc3RlbmVyKSB7XG4gICAgICAgICAgICB2YXIgcm9vdDIgPSB0aGlzLnJlc3VsdC5yb290O1xuICAgICAgICAgICAgd2hpbGUoIXJvb3QyW2lzQ2xlYW4kM10pe1xuICAgICAgICAgICAgICAgIHJvb3QyW2lzQ2xlYW4kM10gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMud2Fsa1N5bmMocm9vdDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJzLk9uY2VFeGl0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvb3QyLnR5cGUgPT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvcjEgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uocm9vdDIubm9kZXMpLCBfc3RlcDE7ICEoX3N0ZXAxID0gX2l0ZXJhdG9yMSgpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ViUm9vdCA9IF9zdGVwMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXRTeW5jKHRoaXMubGlzdGVuZXJzLk9uY2VFeGl0LCBzdWJSb290KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXRTeW5jKHRoaXMubGlzdGVuZXJzLk9uY2VFeGl0LCByb290Mik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgICB9O1xuICAgIF9wcm90by50aGVuID0gZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAoIShcImZyb21cIiBpbiB0aGlzLm9wdHMpKSB7XG4gICAgICAgICAgICAgICAgd2Fybk9uY2UkMSQxKFwiV2l0aG91dCBgZnJvbWAgb3B0aW9uIFBvc3RDU1MgY291bGQgZ2VuZXJhdGUgd3Jvbmcgc291cmNlIG1hcCBhbmQgd2lsbCBub3QgZmluZCBCcm93c2Vyc2xpc3QgY29uZmlnLiBTZXQgaXQgdG8gQ1NTIGZpbGUgcGF0aCBvciB0byBgdW5kZWZpbmVkYCB0byBwcmV2ZW50IHRoaXMgd2FybmluZy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICB9O1xuICAgIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jc3M7XG4gICAgfTtcbiAgICBfcHJvdG8udmlzaXRTeW5jID0gZnVuY3Rpb24gdmlzaXRTeW5jKHZpc2l0b3JzLCBub2RlMikge1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZSh2aXNpdG9ycyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBfc3RlcF92YWx1ZSA9IF9zdGVwLnZhbHVlLCBwbHVnaW4yMiA9IF9zdGVwX3ZhbHVlWzBdLCB2aXNpdG9yID0gX3N0ZXBfdmFsdWVbMV07XG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5sYXN0UGx1Z2luID0gcGx1Z2luMjI7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9IHZpc2l0b3Iobm9kZTIsIHRoaXMuaGVscGVycyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuaGFuZGxlRXJyb3IoZTIsIG5vZGUyLnByb3h5T2YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUyLnR5cGUgIT09IFwicm9vdFwiICYmIG5vZGUyLnR5cGUgIT09IFwiZG9jdW1lbnRcIiAmJiAhbm9kZTIucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNQcm9taXNlJDEocHJvbWlzZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmdldEFzeW5jRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnZpc2l0VGljayA9IGZ1bmN0aW9uIHZpc2l0VGljayhzdGFjaykge1xuICAgICAgICB2YXIgdmlzaXQyID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBub2RlMiA9IHZpc2l0Mi5ub2RlLCB2aXNpdG9ycyA9IHZpc2l0Mi52aXNpdG9ycztcbiAgICAgICAgaWYgKG5vZGUyLnR5cGUgIT09IFwicm9vdFwiICYmIG5vZGUyLnR5cGUgIT09IFwiZG9jdW1lbnRcIiAmJiAhbm9kZTIucGFyZW50KSB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlzaXRvcnMubGVuZ3RoID4gMCAmJiB2aXNpdDIudmlzaXRvckluZGV4IDwgdmlzaXRvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgX3Zpc2l0b3JzX3Zpc2l0Ml92aXNpdG9ySW5kZXggPSB2aXNpdG9yc1t2aXNpdDIudmlzaXRvckluZGV4XSwgcGx1Z2luMjIgPSBfdmlzaXRvcnNfdmlzaXQyX3Zpc2l0b3JJbmRleFswXSwgdmlzaXRvciA9IF92aXNpdG9yc192aXNpdDJfdmlzaXRvckluZGV4WzFdO1xuICAgICAgICAgICAgdmlzaXQyLnZpc2l0b3JJbmRleCArPSAxO1xuICAgICAgICAgICAgaWYgKHZpc2l0Mi52aXNpdG9ySW5kZXggPT09IHZpc2l0b3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZpc2l0Mi52aXNpdG9ycyA9IFtdO1xuICAgICAgICAgICAgICAgIHZpc2l0Mi52aXNpdG9ySW5kZXggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXN1bHQubGFzdFBsdWdpbiA9IHBsdWdpbjIyO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRvcihub2RlMi50b1Byb3h5KCksIHRoaXMuaGVscGVycyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuaGFuZGxlRXJyb3IoZTIsIG5vZGUyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmlzaXQyLml0ZXJhdG9yICE9PSAwKSB7XG4gICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSB2aXNpdDIuaXRlcmF0b3I7XG4gICAgICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgICAgICB3aGlsZShjaGlsZCA9IG5vZGUyLm5vZGVzW25vZGUyLmluZGV4ZXNbaXRlcmF0b3JdXSl7XG4gICAgICAgICAgICAgICAgbm9kZTIuaW5kZXhlc1tpdGVyYXRvcl0gKz0gMTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkW2lzQ2xlYW4kM10pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRbaXNDbGVhbiQzXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godG9TdGFjayQxKGNoaWxkKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2aXNpdDIuaXRlcmF0b3IgPSAwO1xuICAgICAgICAgICAgZGVsZXRlIG5vZGUyLmluZGV4ZXNbaXRlcmF0b3JdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBldmVudHMgPSB2aXNpdDIuZXZlbnRzO1xuICAgICAgICB3aGlsZSh2aXNpdDIuZXZlbnRJbmRleCA8IGV2ZW50cy5sZW5ndGgpe1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gZXZlbnRzW3Zpc2l0Mi5ldmVudEluZGV4XTtcbiAgICAgICAgICAgIHZpc2l0Mi5ldmVudEluZGV4ICs9IDE7XG4gICAgICAgICAgICBpZiAoZXZlbnQgPT09IENISUxEUkVOJDEpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZTIubm9kZXMgJiYgbm9kZTIubm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUyW2lzQ2xlYW4kM10gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2aXNpdDIuaXRlcmF0b3IgPSBub2RlMi5nZXRJdGVyYXRvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGlzdGVuZXJzW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgIHZpc2l0Mi52aXNpdG9ycyA9IHRoaXMubGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgfTtcbiAgICBfcHJvdG8ud2Fsa1N5bmMgPSBmdW5jdGlvbiB3YWxrU3luYyhub2RlMikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBub2RlMltpc0NsZWFuJDNdID0gdHJ1ZTtcbiAgICAgICAgdmFyIGV2ZW50cyA9IGdldEV2ZW50cyQxKG5vZGUyKTtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UoZXZlbnRzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICBpZiAoZXZlbnQgPT09IENISUxEUkVOJDEpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZTIubm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTIuZWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZFtpc0NsZWFuJDNdKSBfdGhpcy53YWxrU3luYyhjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHZpc2l0b3JzID0gdGhpcy5saXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICAgICAgICAgIGlmICh2aXNpdG9ycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52aXNpdFN5bmModmlzaXRvcnMsIG5vZGUyLnRvUHJveHkoKSkpIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by53YXJuaW5ncyA9IGZ1bmN0aW9uIHdhcm5pbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zeW5jKCkud2FybmluZ3MoKTtcbiAgICB9O1xuICAgIF9jcmVhdGVfY2xhc3MoTGF6eVJlc3VsdCwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY29udGVudFwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5KCkuY29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNzc1wiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5KCkuY3NzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwibWFwXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmdpZnkoKS5tYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJtZXNzYWdlc1wiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3luYygpLm1lc3NhZ2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwib3B0c1wiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0Lm9wdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJwcm9jZXNzb3JcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdC5wcm9jZXNzb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJyb290XCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zeW5jKCkucm9vdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBTeW1ib2wudG9TdHJpbmdUYWcsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJMYXp5UmVzdWx0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gTGF6eVJlc3VsdDtcbn0oKTtcbkxhenlSZXN1bHQkMiQxLnJlZ2lzdGVyUG9zdGNzcyA9IGZ1bmN0aW9uKGRlcGVuZGFudCkge1xuICAgIHBvc3Rjc3MkMiQxID0gZGVwZW5kYW50O1xufTtcbnZhciBsYXp5UmVzdWx0JDEgPSBMYXp5UmVzdWx0JDIkMTtcbkxhenlSZXN1bHQkMiQxLmRlZmF1bHQgPSBMYXp5UmVzdWx0JDIkMTtcblJvb3QkMyQxLnJlZ2lzdGVyTGF6eVJlc3VsdChMYXp5UmVzdWx0JDIkMSk7XG5Eb2N1bWVudCQyJDEucmVnaXN0ZXJMYXp5UmVzdWx0KExhenlSZXN1bHQkMiQxKTtcbnZhciBNYXBHZW5lcmF0b3IyJDEgPSBtYXBHZW5lcmF0b3IkMTtcbnZhciBzdHJpbmdpZnkkMSQxID0gc3RyaW5naWZ5XzEkMTtcbnZhciB3YXJuT25jZTIkMSA9IHdhcm5PbmNlJDIkMTtcbnZhciBwYXJzZSQxJDEgPSBwYXJzZV8xJDE7XG52YXIgUmVzdWx0JDEkMSA9IHJlc3VsdCQxO1xudmFyIE5vV29ya1Jlc3VsdCQxJDEgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIE5vV29ya1Jlc3VsdChwcm9jZXNzb3IyLCBjc3MsIG9wdHMpIHtcbiAgICAgICAgY3NzID0gY3NzLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMuc3RyaW5naWZpZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc29yID0gcHJvY2Vzc29yMjtcbiAgICAgICAgdGhpcy5fY3NzID0gY3NzO1xuICAgICAgICB0aGlzLl9vcHRzID0gb3B0cztcbiAgICAgICAgdGhpcy5fbWFwID0gdm9pZCAwO1xuICAgICAgICB2YXIgcm9vdDI7XG4gICAgICAgIHZhciBzdHIgPSBzdHJpbmdpZnkkMSQxO1xuICAgICAgICB0aGlzLnJlc3VsdCA9IG5ldyBSZXN1bHQkMSQxKHRoaXMuX3Byb2Nlc3Nvciwgcm9vdDIsIHRoaXMuX29wdHMpO1xuICAgICAgICB0aGlzLnJlc3VsdC5jc3MgPSBjc3M7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMucmVzdWx0LCBcInJvb3RcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucm9vdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBtYXAgPSBuZXcgTWFwR2VuZXJhdG9yMiQxKHN0ciwgcm9vdDIsIHRoaXMuX29wdHMsIGNzcyk7XG4gICAgICAgIGlmIChtYXAuaXNNYXAoKSkge1xuICAgICAgICAgICAgdmFyIF9tYXBfZ2VuZXJhdGUgPSBtYXAuZ2VuZXJhdGUoKSwgZ2VuZXJhdGVkQ1NTID0gX21hcF9nZW5lcmF0ZVswXSwgZ2VuZXJhdGVkTWFwID0gX21hcF9nZW5lcmF0ZVsxXTtcbiAgICAgICAgICAgIGlmIChnZW5lcmF0ZWRDU1MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5jc3MgPSBnZW5lcmF0ZWRDU1M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2VuZXJhdGVkTWFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQubWFwID0gZ2VuZXJhdGVkTWFwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFwLmNsZWFyQW5ub3RhdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQuY3NzID0gbWFwLmNzcztcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gTm9Xb3JrUmVzdWx0LnByb3RvdHlwZTtcbiAgICBfcHJvdG8uYXN5bmMgPSBmdW5jdGlvbiBhc3luYygpIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmVycm9yKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnJlc3VsdCk7XG4gICAgfTtcbiAgICBfcHJvdG8uY2F0Y2ggPSBmdW5jdGlvbiBfY2F0Y2gob25SZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc3luYygpLmNhdGNoKG9uUmVqZWN0ZWQpO1xuICAgIH07XG4gICAgX3Byb3RvLmZpbmFsbHkgPSBmdW5jdGlvbiBfZmluYWxseShvbkZpbmFsbHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRmluYWxseSwgb25GaW5hbGx5KTtcbiAgICB9O1xuICAgIF9wcm90by5zeW5jID0gZnVuY3Rpb24gc3luYygpIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHRocm93IHRoaXMuZXJyb3I7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgICB9O1xuICAgIF9wcm90by50aGVuID0gZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAoIShcImZyb21cIiBpbiB0aGlzLl9vcHRzKSkge1xuICAgICAgICAgICAgICAgIHdhcm5PbmNlMiQxKFwiV2l0aG91dCBgZnJvbWAgb3B0aW9uIFBvc3RDU1MgY291bGQgZ2VuZXJhdGUgd3Jvbmcgc291cmNlIG1hcCBhbmQgd2lsbCBub3QgZmluZCBCcm93c2Vyc2xpc3QgY29uZmlnLiBTZXQgaXQgdG8gQ1NTIGZpbGUgcGF0aCBvciB0byBgdW5kZWZpbmVkYCB0byBwcmV2ZW50IHRoaXMgd2FybmluZy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICB9O1xuICAgIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3NzO1xuICAgIH07XG4gICAgX3Byb3RvLndhcm5pbmdzID0gZnVuY3Rpb24gd2FybmluZ3MoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIF9jcmVhdGVfY2xhc3MoTm9Xb3JrUmVzdWx0LCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjb250ZW50XCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQuY3NzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY3NzXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQuY3NzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwibWFwXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQubWFwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwibWVzc2FnZXNcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcIm9wdHNcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdC5vcHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwicHJvY2Vzc29yXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQucHJvY2Vzc29yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwicm9vdFwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Jvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByb290MjtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VyMiA9IHBhcnNlJDEkMTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByb290MiA9IHBhcnNlcjIodGhpcy5fY3NzLCB0aGlzLl9vcHRzKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZXJyb3I7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcm9vdCA9IHJvb3QyO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm9vdDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFN5bWJvbC50b1N0cmluZ1RhZyxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIk5vV29ya1Jlc3VsdFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIE5vV29ya1Jlc3VsdDtcbn0oKTtcbnZhciBub1dvcmtSZXN1bHQkMSA9IE5vV29ya1Jlc3VsdCQxJDE7XG5Ob1dvcmtSZXN1bHQkMSQxLmRlZmF1bHQgPSBOb1dvcmtSZXN1bHQkMSQxO1xudmFyIE5vV29ya1Jlc3VsdDIkMSA9IG5vV29ya1Jlc3VsdCQxO1xudmFyIExhenlSZXN1bHQkMSQxID0gbGF6eVJlc3VsdCQxO1xudmFyIERvY3VtZW50JDEkMSA9IGRvY3VtZW50JDEkMTtcbnZhciBSb290JDIkMSA9IHJvb3QkMTtcbnZhciBQcm9jZXNzb3IkMSQxID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBQcm9jZXNzb3IocGx1Z2lucykge1xuICAgICAgICBpZiAocGx1Z2lucyA9PT0gdm9pZCAwKSBwbHVnaW5zID0gW107XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IFwiOC40LjM4XCI7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IHRoaXMubm9ybWFsaXplKHBsdWdpbnMpO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gUHJvY2Vzc29yLnByb3RvdHlwZTtcbiAgICBfcHJvdG8ubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKHBsdWdpbnMpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBbXTtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UocGx1Z2lucyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBpMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGkyLnBvc3Rjc3MgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpMiA9IGkyKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkyLnBvc3Rjc3MpIHtcbiAgICAgICAgICAgICAgICBpMiA9IGkyLnBvc3Rjc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBpMiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihpMikpID09PSBcIm9iamVjdFwiICYmIEFycmF5LmlzQXJyYXkoaTIucGx1Z2lucykpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkID0gbm9ybWFsaXplZC5jb25jYXQoaTIucGx1Z2lucyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCh0eXBlb2YgaTIgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YoaTIpKSA9PT0gXCJvYmplY3RcIiAmJiBpMi5wb3N0Y3NzUGx1Z2luKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZC5wdXNoKGkyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGkyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkLnB1c2goaTIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgodHlwZW9mIGkyID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKGkyKSkgPT09IFwib2JqZWN0XCIgJiYgKGkyLnBhcnNlIHx8IGkyLnN0cmluZ2lmeSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvc3RDU1Mgc3ludGF4ZXMgY2Fubm90IGJlIHVzZWQgYXMgcGx1Z2lucy4gSW5zdGVhZCwgcGxlYXNlIHVzZSBvbmUgb2YgdGhlIHN5bnRheC9wYXJzZXIvc3RyaW5naWZpZXIgb3B0aW9ucyBhcyBvdXRsaW5lZCBpbiB5b3VyIFBvc3RDU1MgcnVubmVyIGRvY3VtZW50YXRpb24uXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGkyICsgXCIgaXMgbm90IGEgUG9zdENTUyBwbHVnaW5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gICAgfTtcbiAgICBfcHJvdG8ucHJvY2VzcyA9IGZ1bmN0aW9uIHByb2Nlc3MxKGNzcywgb3B0cykge1xuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSBvcHRzID0ge307XG4gICAgICAgIGlmICghdGhpcy5wbHVnaW5zLmxlbmd0aCAmJiAhb3B0cy5wYXJzZXIgJiYgIW9wdHMuc3RyaW5naWZpZXIgJiYgIW9wdHMuc3ludGF4KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vV29ya1Jlc3VsdDIkMSh0aGlzLCBjc3MsIG9wdHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMYXp5UmVzdWx0JDEkMSh0aGlzLCBjc3MsIG9wdHMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8udXNlID0gZnVuY3Rpb24gdXNlKHBsdWdpbjIyKSB7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IHRoaXMucGx1Z2lucy5jb25jYXQodGhpcy5ub3JtYWxpemUoW1xuICAgICAgICAgICAgcGx1Z2luMjJcbiAgICAgICAgXSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBQcm9jZXNzb3I7XG59KCk7XG52YXIgcHJvY2Vzc29yJDEgPSBQcm9jZXNzb3IkMSQxO1xuUHJvY2Vzc29yJDEkMS5kZWZhdWx0ID0gUHJvY2Vzc29yJDEkMTtcblJvb3QkMiQxLnJlZ2lzdGVyUHJvY2Vzc29yKFByb2Nlc3NvciQxJDEpO1xuRG9jdW1lbnQkMSQxLnJlZ2lzdGVyUHJvY2Vzc29yKFByb2Nlc3NvciQxJDEpO1xudmFyIERlY2xhcmF0aW9uJDEkMSA9IGRlY2xhcmF0aW9uJDE7XG52YXIgUHJldmlvdXNNYXAyJDEgPSBwcmV2aW91c01hcCQxO1xudmFyIENvbW1lbnQkMSQxID0gY29tbWVudCQxO1xudmFyIEF0UnVsZSQxJDEgPSBhdFJ1bGUkMTtcbnZhciBJbnB1dCQxJDEgPSBpbnB1dCQxO1xudmFyIFJvb3QkMSQxID0gcm9vdCQxO1xudmFyIFJ1bGUkMSQxID0gcnVsZSQxO1xuZnVuY3Rpb24gZnJvbUpTT04kMSQxKGpzb24sIGlucHV0cykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGpzb24pKSByZXR1cm4ganNvbi5tYXAoZnVuY3Rpb24objIpIHtcbiAgICAgICAgcmV0dXJuIGZyb21KU09OJDEkMShuMik7XG4gICAgfSk7XG4gICAgdmFyIG93bklucHV0cyA9IGpzb24uaW5wdXRzLCBkZWZhdWx0cyA9IF9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlKGpzb24sIFtcbiAgICAgICAgXCJpbnB1dHNcIlxuICAgIF0pO1xuICAgIGlmIChvd25JbnB1dHMpIHtcbiAgICAgICAgaW5wdXRzID0gW107XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKG93bklucHV0cyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBpbnB1dDIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIHZhciBpbnB1dEh5ZHJhdGVkID0gX2V4dGVuZHMoe30sIGlucHV0Miwge1xuICAgICAgICAgICAgICAgIF9fcHJvdG9fXzogSW5wdXQkMSQxLnByb3RvdHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaW5wdXRIeWRyYXRlZC5tYXApIHtcbiAgICAgICAgICAgICAgICBpbnB1dEh5ZHJhdGVkLm1hcCA9IF9leHRlbmRzKHt9LCBpbnB1dEh5ZHJhdGVkLm1hcCwge1xuICAgICAgICAgICAgICAgICAgICBfX3Byb3RvX186IFByZXZpb3VzTWFwMiQxLnByb3RvdHlwZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5wdXRzLnB1c2goaW5wdXRIeWRyYXRlZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZmF1bHRzLm5vZGVzKSB7XG4gICAgICAgIGRlZmF1bHRzLm5vZGVzID0ganNvbi5ub2Rlcy5tYXAoZnVuY3Rpb24objIpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tSlNPTiQxJDEobjIsIGlucHV0cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZGVmYXVsdHMuc291cmNlKSB7XG4gICAgICAgIHZhciBfZGVmYXVsdHNfc291cmNlID0gZGVmYXVsdHMuc291cmNlLCBpbnB1dElkID0gX2RlZmF1bHRzX3NvdXJjZS5pbnB1dElkLCBzb3VyY2UgPSBfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZShfZGVmYXVsdHNfc291cmNlLCBbXG4gICAgICAgICAgICBcImlucHV0SWRcIlxuICAgICAgICBdKTtcbiAgICAgICAgZGVmYXVsdHMuc291cmNlID0gc291cmNlO1xuICAgICAgICBpZiAoaW5wdXRJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBkZWZhdWx0cy5zb3VyY2UuaW5wdXQgPSBpbnB1dHNbaW5wdXRJZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZmF1bHRzLnR5cGUgPT09IFwicm9vdFwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgUm9vdCQxJDEoZGVmYXVsdHMpO1xuICAgIH0gZWxzZSBpZiAoZGVmYXVsdHMudHlwZSA9PT0gXCJkZWNsXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNsYXJhdGlvbiQxJDEoZGVmYXVsdHMpO1xuICAgIH0gZWxzZSBpZiAoZGVmYXVsdHMudHlwZSA9PT0gXCJydWxlXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSdWxlJDEkMShkZWZhdWx0cyk7XG4gICAgfSBlbHNlIGlmIChkZWZhdWx0cy50eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgICAgICByZXR1cm4gbmV3IENvbW1lbnQkMSQxKGRlZmF1bHRzKTtcbiAgICB9IGVsc2UgaWYgKGRlZmF1bHRzLnR5cGUgPT09IFwiYXRydWxlXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdFJ1bGUkMSQxKGRlZmF1bHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG5vZGUgdHlwZTogXCIgKyBqc29uLnR5cGUpO1xuICAgIH1cbn1cbnZhciBmcm9tSlNPTl8xJDEgPSBmcm9tSlNPTiQxJDE7XG5mcm9tSlNPTiQxJDEuZGVmYXVsdCA9IGZyb21KU09OJDEkMTtcbnZhciBDc3NTeW50YXhFcnJvcjIkMSA9IGNzc1N5bnRheEVycm9yJDE7XG52YXIgRGVjbGFyYXRpb24yJDEgPSBkZWNsYXJhdGlvbiQxO1xudmFyIExhenlSZXN1bHQyJDEgPSBsYXp5UmVzdWx0JDE7XG52YXIgQ29udGFpbmVyMiQxID0gY29udGFpbmVyJDE7XG52YXIgUHJvY2Vzc29yMiQxID0gcHJvY2Vzc29yJDE7XG52YXIgc3RyaW5naWZ5JDUgPSBzdHJpbmdpZnlfMSQxO1xudmFyIGZyb21KU09OJDIgPSBmcm9tSlNPTl8xJDE7XG52YXIgRG9jdW1lbnQyMiA9IGRvY3VtZW50JDEkMTtcbnZhciBXYXJuaW5nMiQxID0gd2FybmluZyQxO1xudmFyIENvbW1lbnQyJDEgPSBjb21tZW50JDE7XG52YXIgQXRSdWxlMiQxID0gYXRSdWxlJDE7XG52YXIgUmVzdWx0MiQxID0gcmVzdWx0JDE7XG52YXIgSW5wdXQyJDEgPSBpbnB1dCQxO1xudmFyIHBhcnNlJDUgPSBwYXJzZV8xJDE7XG52YXIgbGlzdCQzID0gbGlzdF8xJDE7XG52YXIgUnVsZTIkMSA9IHJ1bGUkMTtcbnZhciBSb290MiQxID0gcm9vdCQxO1xudmFyIE5vZGUyJDEgPSBub2RlJDE7XG5mdW5jdGlvbiBwb3N0Y3NzJDMoKSB7XG4gICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGx1Z2lucyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICBwbHVnaW5zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBpZiAocGx1Z2lucy5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShwbHVnaW5zWzBdKSkge1xuICAgICAgICBwbHVnaW5zID0gcGx1Z2luc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9jZXNzb3IyJDEocGx1Z2lucyk7XG59XG5wb3N0Y3NzJDMucGx1Z2luID0gZnVuY3Rpb24gcGx1Z2luKG5hbWUsIGluaXRpYWxpemVyKSB7XG4gICAgdmFyIHdhcm5pbmdQcmludGVkID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gY3JlYXRvcigpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4gJiYgIXdhcm5pbmdQcmludGVkKSB7XG4gICAgICAgICAgICB3YXJuaW5nUHJpbnRlZCA9IHRydWU7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4obmFtZSArIFwiOiBwb3N0Y3NzLnBsdWdpbiB3YXMgZGVwcmVjYXRlZC4gTWlncmF0aW9uIGd1aWRlOlxcbmh0dHBzOi8vZXZpbG1hcnRpYW5zLmNvbS9jaHJvbmljbGVzL3Bvc3Rjc3MtOC1wbHVnaW4tbWlncmF0aW9uXCIpO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52LkxBTkcgJiYgcHJvY2Vzcy5lbnYuTEFORy5zdGFydHNXaXRoKFwiY25cIikpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4obmFtZSArIFwiOiDph4zpnaIgcG9zdGNzcy5wbHVnaW4g6KKr5byD55SoLiDov4Hnp7vmjIfljZc6XFxuaHR0cHM6Ly93d3cudzNjdGVjaC5jb20vdG9waWMvMjIyNlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdHJhbnNmb3JtZXIgPSBpbml0aWFsaXplci5hcHBseSh2b2lkIDAsIFtdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIHRyYW5zZm9ybWVyLnBvc3Rjc3NQbHVnaW4gPSBuYW1lO1xuICAgICAgICB0cmFuc2Zvcm1lci5wb3N0Y3NzVmVyc2lvbiA9IG5ldyBQcm9jZXNzb3IyJDEoKS52ZXJzaW9uO1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXI7XG4gICAgfVxuICAgIHZhciBjYWNoZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRvciwgXCJwb3N0Y3NzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlKSBjYWNoZSA9IGNyZWF0b3IoKTtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNyZWF0b3IucHJvY2VzcyA9IGZ1bmN0aW9uKGNzcywgcHJvY2Vzc09wdHMsIHBsdWdpbk9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHBvc3Rjc3MkMyhbXG4gICAgICAgICAgICBjcmVhdG9yKHBsdWdpbk9wdHMpXG4gICAgICAgIF0pLnByb2Nlc3MoY3NzLCBwcm9jZXNzT3B0cyk7XG4gICAgfTtcbiAgICByZXR1cm4gY3JlYXRvcjtcbn07XG5wb3N0Y3NzJDMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5JDU7XG5wb3N0Y3NzJDMucGFyc2UgPSBwYXJzZSQ1O1xucG9zdGNzcyQzLmZyb21KU09OID0gZnJvbUpTT04kMjtcbnBvc3Rjc3MkMy5saXN0ID0gbGlzdCQzO1xucG9zdGNzcyQzLmNvbW1lbnQgPSBmdW5jdGlvbihkZWZhdWx0cykge1xuICAgIHJldHVybiBuZXcgQ29tbWVudDIkMShkZWZhdWx0cyk7XG59O1xucG9zdGNzcyQzLmF0UnVsZSA9IGZ1bmN0aW9uKGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIG5ldyBBdFJ1bGUyJDEoZGVmYXVsdHMpO1xufTtcbnBvc3Rjc3MkMy5kZWNsID0gZnVuY3Rpb24oZGVmYXVsdHMpIHtcbiAgICByZXR1cm4gbmV3IERlY2xhcmF0aW9uMiQxKGRlZmF1bHRzKTtcbn07XG5wb3N0Y3NzJDMucnVsZSA9IGZ1bmN0aW9uKGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIG5ldyBSdWxlMiQxKGRlZmF1bHRzKTtcbn07XG5wb3N0Y3NzJDMucm9vdCA9IGZ1bmN0aW9uKGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIG5ldyBSb290MiQxKGRlZmF1bHRzKTtcbn07XG5wb3N0Y3NzJDMuZG9jdW1lbnQgPSBmdW5jdGlvbihkZWZhdWx0cykge1xuICAgIHJldHVybiBuZXcgRG9jdW1lbnQyMihkZWZhdWx0cyk7XG59O1xucG9zdGNzcyQzLkNzc1N5bnRheEVycm9yID0gQ3NzU3ludGF4RXJyb3IyJDE7XG5wb3N0Y3NzJDMuRGVjbGFyYXRpb24gPSBEZWNsYXJhdGlvbjIkMTtcbnBvc3Rjc3MkMy5Db250YWluZXIgPSBDb250YWluZXIyJDE7XG5wb3N0Y3NzJDMuUHJvY2Vzc29yID0gUHJvY2Vzc29yMiQxO1xucG9zdGNzcyQzLkRvY3VtZW50ID0gRG9jdW1lbnQyMjtcbnBvc3Rjc3MkMy5Db21tZW50ID0gQ29tbWVudDIkMTtcbnBvc3Rjc3MkMy5XYXJuaW5nID0gV2FybmluZzIkMTtcbnBvc3Rjc3MkMy5BdFJ1bGUgPSBBdFJ1bGUyJDE7XG5wb3N0Y3NzJDMuUmVzdWx0ID0gUmVzdWx0MiQxO1xucG9zdGNzcyQzLklucHV0ID0gSW5wdXQyJDE7XG5wb3N0Y3NzJDMuUnVsZSA9IFJ1bGUyJDE7XG5wb3N0Y3NzJDMuUm9vdCA9IFJvb3QyJDE7XG5wb3N0Y3NzJDMuTm9kZSA9IE5vZGUyJDE7XG5MYXp5UmVzdWx0MiQxLnJlZ2lzdGVyUG9zdGNzcyhwb3N0Y3NzJDMpO1xudmFyIHBvc3Rjc3NfMSQxID0gcG9zdGNzcyQzO1xucG9zdGNzcyQzLmRlZmF1bHQgPSBwb3N0Y3NzJDM7XG52YXIgcG9zdGNzcyQxJDEgPSAvKiBAX19QVVJFX18gKi8gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMkMShwb3N0Y3NzXzEkMSk7XG5wb3N0Y3NzJDEkMS5zdHJpbmdpZnk7XG5wb3N0Y3NzJDEkMS5mcm9tSlNPTjtcbnBvc3Rjc3MkMSQxLnBsdWdpbjtcbnBvc3Rjc3MkMSQxLnBhcnNlO1xucG9zdGNzcyQxJDEubGlzdDtcbnBvc3Rjc3MkMSQxLmRvY3VtZW50O1xucG9zdGNzcyQxJDEuY29tbWVudDtcbnBvc3Rjc3MkMSQxLmF0UnVsZTtcbnBvc3Rjc3MkMSQxLnJ1bGU7XG5wb3N0Y3NzJDEkMS5kZWNsO1xucG9zdGNzcyQxJDEucm9vdDtcbnBvc3Rjc3MkMSQxLkNzc1N5bnRheEVycm9yO1xucG9zdGNzcyQxJDEuRGVjbGFyYXRpb247XG5wb3N0Y3NzJDEkMS5Db250YWluZXI7XG5wb3N0Y3NzJDEkMS5Qcm9jZXNzb3I7XG5wb3N0Y3NzJDEkMS5Eb2N1bWVudDtcbnBvc3Rjc3MkMSQxLkNvbW1lbnQ7XG5wb3N0Y3NzJDEkMS5XYXJuaW5nO1xucG9zdGNzcyQxJDEuQXRSdWxlO1xucG9zdGNzcyQxJDEuUmVzdWx0O1xucG9zdGNzcyQxJDEuSW5wdXQ7XG5wb3N0Y3NzJDEkMS5SdWxlO1xucG9zdGNzcyQxJDEuUm9vdDtcbnBvc3Rjc3MkMSQxLk5vZGU7XG52YXIgX19kZWZQcm9wMiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AyID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIGtleSBpbiBvYmogPyBfX2RlZlByb3AyKG9iaiwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbn07XG52YXIgX19wdWJsaWNGaWVsZDIgPSBmdW5jdGlvbihvYmosIGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gX19kZWZOb3JtYWxQcm9wMihvYmosICh0eXBlb2Yga2V5ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKGtleSkpICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xufTtcbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHgyKSB7XG4gICAgcmV0dXJuIHgyICYmIHgyLl9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgyLCBcImRlZmF1bHRcIikgPyB4MltcImRlZmF1bHRcIl0gOiB4Mjtcbn1cbmZ1bmN0aW9uIGdldEF1Z21lbnRlZE5hbWVzcGFjZShuMikge1xuICAgIGlmIChuMi5fX2VzTW9kdWxlKSByZXR1cm4gbjI7XG4gICAgdmFyIGYyID0gbjIuZGVmYXVsdDtcbiAgICBpZiAodHlwZW9mIGYyID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB2YXIgYTIgPSBmdW5jdGlvbiBhMjIoKSB7XG4gICAgICAgICAgICBpZiAoX2luc3RhbmNlb2YodGhpcywgYTIyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmNvbnN0cnVjdChmMiwgYXJndW1lbnRzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgICBhMi5wcm90b3R5cGUgPSBmMi5wcm90b3R5cGU7XG4gICAgfSBlbHNlIGEyID0ge307XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEyLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5rZXlzKG4yKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4yLCBrKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEyLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG4yW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gYTI7XG59XG52YXIgcGljb2NvbG9yc19icm93c2VyID0ge1xuICAgIGV4cG9ydHM6IHt9XG59O1xudmFyIHggPSBTdHJpbmc7XG52YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlzQ29sb3JTdXBwb3J0ZWQ6IGZhbHNlLFxuICAgICAgICByZXNldDogeCxcbiAgICAgICAgYm9sZDogeCxcbiAgICAgICAgZGltOiB4LFxuICAgICAgICBpdGFsaWM6IHgsXG4gICAgICAgIHVuZGVybGluZTogeCxcbiAgICAgICAgaW52ZXJzZTogeCxcbiAgICAgICAgaGlkZGVuOiB4LFxuICAgICAgICBzdHJpa2V0aHJvdWdoOiB4LFxuICAgICAgICBibGFjazogeCxcbiAgICAgICAgcmVkOiB4LFxuICAgICAgICBncmVlbjogeCxcbiAgICAgICAgeWVsbG93OiB4LFxuICAgICAgICBibHVlOiB4LFxuICAgICAgICBtYWdlbnRhOiB4LFxuICAgICAgICBjeWFuOiB4LFxuICAgICAgICB3aGl0ZTogeCxcbiAgICAgICAgZ3JheTogeCxcbiAgICAgICAgYmdCbGFjazogeCxcbiAgICAgICAgYmdSZWQ6IHgsXG4gICAgICAgIGJnR3JlZW46IHgsXG4gICAgICAgIGJnWWVsbG93OiB4LFxuICAgICAgICBiZ0JsdWU6IHgsXG4gICAgICAgIGJnTWFnZW50YTogeCxcbiAgICAgICAgYmdDeWFuOiB4LFxuICAgICAgICBiZ1doaXRlOiB4XG4gICAgfTtcbn07XG5waWNvY29sb3JzX2Jyb3dzZXIuZXhwb3J0cyA9IGNyZWF0ZSgpO1xucGljb2NvbG9yc19icm93c2VyLmV4cG9ydHMuY3JlYXRlQ29sb3JzID0gY3JlYXRlO1xudmFyIHBpY29jb2xvcnNfYnJvd3NlckV4cG9ydHMgPSBwaWNvY29sb3JzX2Jyb3dzZXIuZXhwb3J0cztcbnZhciBfX3ZpdGVCcm93c2VyRXh0ZXJuYWwgPSB7fTtcbnZhciBfX3ZpdGVCcm93c2VyRXh0ZXJuYWwkMSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBkZWZhdWx0OiBfX3ZpdGVCcm93c2VyRXh0ZXJuYWxcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgIHZhbHVlOiBcIk1vZHVsZVwiXG59KSk7XG52YXIgcmVxdWlyZSQkMiA9IC8qIEBfX1BVUkVfXyAqLyBnZXRBdWdtZW50ZWROYW1lc3BhY2UoX192aXRlQnJvd3NlckV4dGVybmFsJDEpO1xudmFyIHBpY28gPSBwaWNvY29sb3JzX2Jyb3dzZXJFeHBvcnRzO1xudmFyIHRlcm1pbmFsSGlnaGxpZ2h0JDEgPSByZXF1aXJlJCQyO1xudmFyIENzc1N5bnRheEVycm9yJDMgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKEVycm9yMSkge1xuICAgIF9pbmhlcml0cyhDc3NTeW50YXhFcnJvcjIsIEVycm9yMSk7XG4gICAgZnVuY3Rpb24gQ3NzU3ludGF4RXJyb3IyKG1lc3NhZ2UsIGxpbmUsIGNvbHVtbiwgc291cmNlLCBmaWxlLCBwbHVnaW4yMikge1xuICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgIF90aGlzID0gRXJyb3IxLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9IFwiQ3NzU3ludGF4RXJyb3JcIjtcbiAgICAgICAgX3RoaXMucmVhc29uID0gbWVzc2FnZTtcbiAgICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgICAgIF90aGlzLmZpbGUgPSBmaWxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIF90aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGx1Z2luMjIpIHtcbiAgICAgICAgICAgIF90aGlzLnBsdWdpbiA9IHBsdWdpbjIyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbGluZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY29sdW1uICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxpbmUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5saW5lID0gbGluZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLmxpbmUgPSBsaW5lLmxpbmU7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29sdW1uID0gbGluZS5jb2x1bW47XG4gICAgICAgICAgICAgICAgX3RoaXMuZW5kTGluZSA9IGNvbHVtbi5saW5lO1xuICAgICAgICAgICAgICAgIF90aGlzLmVuZENvbHVtbiA9IGNvbHVtbi5jb2x1bW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuc2V0TWVzc2FnZSgpO1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKF90aGlzLCBDc3NTeW50YXhFcnJvcjIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IENzc1N5bnRheEVycm9yMi5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnNldE1lc3NhZ2UgPSBmdW5jdGlvbiBzZXRNZXNzYWdlKCkge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLnBsdWdpbiA/IHRoaXMucGx1Z2luICsgXCI6IFwiIDogXCJcIjtcbiAgICAgICAgdGhpcy5tZXNzYWdlICs9IHRoaXMuZmlsZSA/IHRoaXMuZmlsZSA6IFwiPGNzcyBpbnB1dD5cIjtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmxpbmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSArPSBcIjpcIiArIHRoaXMubGluZSArIFwiOlwiICsgdGhpcy5jb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZXNzYWdlICs9IFwiOiBcIiArIHRoaXMucmVhc29uO1xuICAgIH07XG4gICAgX3Byb3RvLnNob3dTb3VyY2VDb2RlID0gZnVuY3Rpb24gc2hvd1NvdXJjZUNvZGUoY29sb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnNvdXJjZSkgcmV0dXJuIFwiXCI7XG4gICAgICAgIHZhciBjc3MgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgaWYgKGNvbG9yID09IG51bGwpIGNvbG9yID0gcGljby5pc0NvbG9yU3VwcG9ydGVkO1xuICAgICAgICBpZiAodGVybWluYWxIaWdobGlnaHQkMSkge1xuICAgICAgICAgICAgaWYgKGNvbG9yKSBjc3MgPSB0ZXJtaW5hbEhpZ2hsaWdodCQxKGNzcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpbmVzID0gY3NzLnNwbGl0KC9cXHI/XFxuLyk7XG4gICAgICAgIHZhciBzdGFydCA9IE1hdGgubWF4KHRoaXMubGluZSAtIDMsIDApO1xuICAgICAgICB2YXIgZW5kID0gTWF0aC5taW4odGhpcy5saW5lICsgMiwgbGluZXMubGVuZ3RoKTtcbiAgICAgICAgdmFyIG1heFdpZHRoID0gU3RyaW5nKGVuZCkubGVuZ3RoO1xuICAgICAgICB2YXIgbWFyaywgYXNpZGU7XG4gICAgICAgIGlmIChjb2xvcikge1xuICAgICAgICAgICAgdmFyIF9waWNvX2NyZWF0ZUNvbG9ycyA9IHBpY28uY3JlYXRlQ29sb3JzKHRydWUpLCBib2xkID0gX3BpY29fY3JlYXRlQ29sb3JzLmJvbGQsIGdyYXkgPSBfcGljb19jcmVhdGVDb2xvcnMuZ3JheSwgcmVkID0gX3BpY29fY3JlYXRlQ29sb3JzLnJlZDtcbiAgICAgICAgICAgIG1hcmsgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJvbGQocmVkKHRleHQpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhc2lkZSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ3JheSh0ZXh0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXJrID0gYXNpZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZXMuc2xpY2Uoc3RhcnQsIGVuZCkubWFwKGZ1bmN0aW9uKGxpbmUsIGluZGV4Mikge1xuICAgICAgICAgICAgdmFyIG51bWJlciA9IHN0YXJ0ICsgMSArIGluZGV4MjtcbiAgICAgICAgICAgIHZhciBndXR0ZXIgPSBcIiBcIiArIChcIiBcIiArIG51bWJlcikuc2xpY2UoLW1heFdpZHRoKSArIFwiIHwgXCI7XG4gICAgICAgICAgICBpZiAobnVtYmVyID09PSBfdGhpcy5saW5lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNwYWNpbmcgPSBhc2lkZShndXR0ZXIucmVwbGFjZSgvXFxkL2csIFwiIFwiKSkgKyBsaW5lLnNsaWNlKDAsIF90aGlzLmNvbHVtbiAtIDEpLnJlcGxhY2UoL1teXFx0XS9nLCBcIiBcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcmsoXCI+XCIpICsgYXNpZGUoZ3V0dGVyKSArIGxpbmUgKyBcIlxcbiBcIiArIHNwYWNpbmcgKyBtYXJrKFwiXlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBcIiBcIiArIGFzaWRlKGd1dHRlcikgKyBsaW5lO1xuICAgICAgICB9KS5qb2luKFwiXFxuXCIpO1xuICAgIH07XG4gICAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHZhciBjb2RlID0gdGhpcy5zaG93U291cmNlQ29kZSgpO1xuICAgICAgICBpZiAoY29kZSkge1xuICAgICAgICAgICAgY29kZSA9IFwiXFxuXFxuXCIgKyBjb2RlICsgXCJcXG5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgXCI6IFwiICsgdGhpcy5tZXNzYWdlICsgY29kZTtcbiAgICB9O1xuICAgIHJldHVybiBDc3NTeW50YXhFcnJvcjI7XG59KF93cmFwX25hdGl2ZV9zdXBlcihFcnJvcikpO1xudmFyIGNzc1N5bnRheEVycm9yID0gQ3NzU3ludGF4RXJyb3IkMztcbkNzc1N5bnRheEVycm9yJDMuZGVmYXVsdCA9IENzc1N5bnRheEVycm9yJDM7XG52YXIgc3ltYm9scyA9IHt9O1xuc3ltYm9scy5pc0NsZWFuID0gU3ltYm9sKFwiaXNDbGVhblwiKTtcbnN5bWJvbHMubXkgPSBTeW1ib2woXCJteVwiKTtcbnZhciBERUZBVUxUX1JBVyA9IHtcbiAgICBhZnRlcjogXCJcXG5cIixcbiAgICBiZWZvcmVDbG9zZTogXCJcXG5cIixcbiAgICBiZWZvcmVDb21tZW50OiBcIlxcblwiLFxuICAgIGJlZm9yZURlY2w6IFwiXFxuXCIsXG4gICAgYmVmb3JlT3BlbjogXCIgXCIsXG4gICAgYmVmb3JlUnVsZTogXCJcXG5cIixcbiAgICBjb2xvbjogXCI6IFwiLFxuICAgIGNvbW1lbnRMZWZ0OiBcIiBcIixcbiAgICBjb21tZW50UmlnaHQ6IFwiIFwiLFxuICAgIGVtcHR5Qm9keTogXCJcIixcbiAgICBpbmRlbnQ6IFwiICAgIFwiLFxuICAgIHNlbWljb2xvbjogZmFsc2Vcbn07XG5mdW5jdGlvbiBjYXBpdGFsaXplKHN0cikge1xuICAgIHJldHVybiBzdHJbMF0udG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn1cbnZhciBTdHJpbmdpZmllciQyID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBTdHJpbmdpZmllcjIoYnVpbGRlcikge1xuICAgICAgICB0aGlzLmJ1aWxkZXIgPSBidWlsZGVyO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gU3RyaW5naWZpZXIyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uYXRydWxlID0gZnVuY3Rpb24gYXRydWxlKG5vZGUyLCBzZW1pY29sb24pIHtcbiAgICAgICAgdmFyIG5hbWUgPSBcIkBcIiArIG5vZGUyLm5hbWU7XG4gICAgICAgIHZhciBwYXJhbXMgPSBub2RlMi5wYXJhbXMgPyB0aGlzLnJhd1ZhbHVlKG5vZGUyLCBcInBhcmFtc1wiKSA6IFwiXCI7XG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZTIucmF3cy5hZnRlck5hbWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIG5hbWUgKz0gbm9kZTIucmF3cy5hZnRlck5hbWU7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1zKSB7XG4gICAgICAgICAgICBuYW1lICs9IFwiIFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlMi5ub2Rlcykge1xuICAgICAgICAgICAgdGhpcy5ibG9jayhub2RlMiwgbmFtZSArIHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZW5kID0gKG5vZGUyLnJhd3MuYmV0d2VlbiB8fCBcIlwiKSArIChzZW1pY29sb24gPyBcIjtcIiA6IFwiXCIpO1xuICAgICAgICAgICAgdGhpcy5idWlsZGVyKG5hbWUgKyBwYXJhbXMgKyBlbmQsIG5vZGUyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmJlZm9yZUFmdGVyID0gZnVuY3Rpb24gYmVmb3JlQWZ0ZXIobm9kZTIsIGRldGVjdCkge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIGlmIChub2RlMi50eXBlID09PSBcImRlY2xcIikge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJiZWZvcmVEZWNsXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImJlZm9yZUNvbW1lbnRcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoZGV0ZWN0ID09PSBcImJlZm9yZVwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImJlZm9yZVJ1bGVcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImJlZm9yZUNsb3NlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWYgPSBub2RlMi5wYXJlbnQ7XG4gICAgICAgIHZhciBkZXB0aCA9IDA7XG4gICAgICAgIHdoaWxlKGJ1ZiAmJiBidWYudHlwZSAhPT0gXCJyb290XCIpe1xuICAgICAgICAgICAgZGVwdGggKz0gMTtcbiAgICAgICAgICAgIGJ1ZiA9IGJ1Zi5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICAgICAgICB2YXIgaW5kZW50ID0gdGhpcy5yYXcobm9kZTIsIG51bGwsIFwiaW5kZW50XCIpO1xuICAgICAgICAgICAgaWYgKGluZGVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IodmFyIHN0ZXAgPSAwOyBzdGVwIDwgZGVwdGg7IHN0ZXArKyl2YWx1ZSArPSBpbmRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLmJsb2NrID0gZnVuY3Rpb24gYmxvY2sobm9kZTIsIHN0YXJ0KSB7XG4gICAgICAgIHZhciBiZXR3ZWVuID0gdGhpcy5yYXcobm9kZTIsIFwiYmV0d2VlblwiLCBcImJlZm9yZU9wZW5cIik7XG4gICAgICAgIHRoaXMuYnVpbGRlcihzdGFydCArIGJldHdlZW4gKyBcIntcIiwgbm9kZTIsIFwic3RhcnRcIik7XG4gICAgICAgIHZhciBhZnRlcjtcbiAgICAgICAgaWYgKG5vZGUyLm5vZGVzICYmIG5vZGUyLm5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5ib2R5KG5vZGUyKTtcbiAgICAgICAgICAgIGFmdGVyID0gdGhpcy5yYXcobm9kZTIsIFwiYWZ0ZXJcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZnRlciA9IHRoaXMucmF3KG5vZGUyLCBcImFmdGVyXCIsIFwiZW1wdHlCb2R5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZnRlcikgdGhpcy5idWlsZGVyKGFmdGVyKTtcbiAgICAgICAgdGhpcy5idWlsZGVyKFwifVwiLCBub2RlMiwgXCJlbmRcIik7XG4gICAgfTtcbiAgICBfcHJvdG8uYm9keSA9IGZ1bmN0aW9uIGJvZHkobm9kZTIpIHtcbiAgICAgICAgdmFyIGxhc3QgPSBub2RlMi5ub2Rlcy5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZShsYXN0ID4gMCl7XG4gICAgICAgICAgICBpZiAobm9kZTIubm9kZXNbbGFzdF0udHlwZSAhPT0gXCJjb21tZW50XCIpIGJyZWFrO1xuICAgICAgICAgICAgbGFzdCAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZW1pY29sb24gPSB0aGlzLnJhdyhub2RlMiwgXCJzZW1pY29sb25cIik7XG4gICAgICAgIGZvcih2YXIgaTIgPSAwOyBpMiA8IG5vZGUyLm5vZGVzLmxlbmd0aDsgaTIrKyl7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBub2RlMi5ub2Rlc1tpMl07XG4gICAgICAgICAgICB2YXIgYmVmb3JlID0gdGhpcy5yYXcoY2hpbGQsIFwiYmVmb3JlXCIpO1xuICAgICAgICAgICAgaWYgKGJlZm9yZSkgdGhpcy5idWlsZGVyKGJlZm9yZSk7XG4gICAgICAgICAgICB0aGlzLnN0cmluZ2lmeShjaGlsZCwgbGFzdCAhPT0gaTIgfHwgc2VtaWNvbG9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmNvbW1lbnQgPSBmdW5jdGlvbiBjb21tZW50KG5vZGUyKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy5yYXcobm9kZTIsIFwibGVmdFwiLCBcImNvbW1lbnRMZWZ0XCIpO1xuICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnJhdyhub2RlMiwgXCJyaWdodFwiLCBcImNvbW1lbnRSaWdodFwiKTtcbiAgICAgICAgdGhpcy5idWlsZGVyKFwiLypcIiArIGxlZnQgKyBub2RlMi50ZXh0ICsgcmlnaHQgKyBcIiovXCIsIG5vZGUyKTtcbiAgICB9O1xuICAgIF9wcm90by5kZWNsID0gZnVuY3Rpb24gZGVjbChub2RlMiwgc2VtaWNvbG9uKSB7XG4gICAgICAgIHZhciBiZXR3ZWVuID0gdGhpcy5yYXcobm9kZTIsIFwiYmV0d2VlblwiLCBcImNvbG9uXCIpO1xuICAgICAgICB2YXIgc3RyaW5nID0gbm9kZTIucHJvcCArIGJldHdlZW4gKyB0aGlzLnJhd1ZhbHVlKG5vZGUyLCBcInZhbHVlXCIpO1xuICAgICAgICBpZiAobm9kZTIuaW1wb3J0YW50KSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gbm9kZTIucmF3cy5pbXBvcnRhbnQgfHwgXCIgIWltcG9ydGFudFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZW1pY29sb24pIHN0cmluZyArPSBcIjtcIjtcbiAgICAgICAgdGhpcy5idWlsZGVyKHN0cmluZywgbm9kZTIpO1xuICAgIH07XG4gICAgX3Byb3RvLmRvY3VtZW50ID0gZnVuY3Rpb24gZG9jdW1lbnQxKG5vZGUyKSB7XG4gICAgICAgIHRoaXMuYm9keShub2RlMik7XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3ID0gZnVuY3Rpb24gcmF3KG5vZGUyLCBvd24sIGRldGVjdCkge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIGlmICghZGV0ZWN0KSBkZXRlY3QgPSBvd247XG4gICAgICAgIGlmIChvd24pIHtcbiAgICAgICAgICAgIHZhbHVlID0gbm9kZTIucmF3c1tvd25dO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJlbnQgPSBub2RlMi5wYXJlbnQ7XG4gICAgICAgIGlmIChkZXRlY3QgPT09IFwiYmVmb3JlXCIpIHtcbiAgICAgICAgICAgIGlmICghcGFyZW50IHx8IHBhcmVudC50eXBlID09PSBcInJvb3RcIiAmJiBwYXJlbnQuZmlyc3QgPT09IG5vZGUyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC50eXBlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmVudCkgcmV0dXJuIERFRkFVTFRfUkFXW2RldGVjdF07XG4gICAgICAgIHZhciByb290MiA9IG5vZGUyLnJvb3QoKTtcbiAgICAgICAgaWYgKCFyb290Mi5yYXdDYWNoZSkgcm9vdDIucmF3Q2FjaGUgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiByb290Mi5yYXdDYWNoZVtkZXRlY3RdICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDIucmF3Q2FjaGVbZGV0ZWN0XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGV0ZWN0ID09PSBcImJlZm9yZVwiIHx8IGRldGVjdCA9PT0gXCJhZnRlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVBZnRlcihub2RlMiwgZGV0ZWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBcInJhd1wiICsgY2FwaXRhbGl6ZShkZXRlY3QpO1xuICAgICAgICAgICAgaWYgKHRoaXNbbWV0aG9kXSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpc1ttZXRob2RdKHJvb3QyLCBub2RlMik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvb3QyLndhbGsoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpMi5yYXdzW293bl07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB2YWx1ZSA9IERFRkFVTFRfUkFXW2RldGVjdF07XG4gICAgICAgIHJvb3QyLnJhd0NhY2hlW2RldGVjdF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJhd0JlZm9yZUNsb3NlID0gZnVuY3Rpb24gcmF3QmVmb3JlQ2xvc2Uocm9vdDIpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICByb290Mi53YWxrKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICBpZiAoaTIubm9kZXMgJiYgaTIubm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5hZnRlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYWZ0ZXI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcbl0rJC8sIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodmFsdWUpIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxTL2csIFwiXCIpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3QmVmb3JlQ29tbWVudCA9IGZ1bmN0aW9uIHJhd0JlZm9yZUNvbW1lbnQocm9vdDIsIG5vZGUyKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgcm9vdDIud2Fsa0NvbW1lbnRzKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmVmb3JlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpMi5yYXdzLmJlZm9yZTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcbl0rJC8sIFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImJlZm9yZURlY2xcIik7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxTL2csIFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5yYXdCZWZvcmVEZWNsID0gZnVuY3Rpb24gcmF3QmVmb3JlRGVjbChyb290Miwgbm9kZTIpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICByb290Mi53YWxrRGVjbHMoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5iZWZvcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYmVmb3JlO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1teXFxuXSskLywgXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZTIsIG51bGwsIFwiYmVmb3JlUnVsZVwiKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFMvZywgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJhd0JlZm9yZU9wZW4gPSBmdW5jdGlvbiByYXdCZWZvcmVPcGVuKHJvb3QyKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgcm9vdDIud2FsayhmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgaWYgKGkyLnR5cGUgIT09IFwiZGVjbFwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpMi5yYXdzLmJldHdlZW47XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJhd0JlZm9yZVJ1bGUgPSBmdW5jdGlvbiByYXdCZWZvcmVSdWxlKHJvb3QyKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgcm9vdDIud2FsayhmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgaWYgKGkyLm5vZGVzICYmIChpMi5wYXJlbnQgIT09IHJvb3QyIHx8IHJvb3QyLmZpcnN0ICE9PSBpMikpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmVmb3JlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaTIucmF3cy5iZWZvcmU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcbl0rJC8sIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodmFsdWUpIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxTL2csIFwiXCIpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3Q29sb24gPSBmdW5jdGlvbiByYXdDb2xvbihyb290Mikge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHJvb3QyLndhbGtEZWNscyhmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpMi5yYXdzLmJldHdlZW4gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYmV0d2Vlbi5yZXBsYWNlKC9bXlxcczpdL2csIFwiXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5yYXdFbXB0eUJvZHkgPSBmdW5jdGlvbiByYXdFbXB0eUJvZHkocm9vdDIpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICByb290Mi53YWxrKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICBpZiAoaTIubm9kZXMgJiYgaTIubm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpMi5yYXdzLmFmdGVyO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5yYXdJbmRlbnQgPSBmdW5jdGlvbiByYXdJbmRlbnQocm9vdDIpIHtcbiAgICAgICAgaWYgKHJvb3QyLnJhd3MuaW5kZW50KSByZXR1cm4gcm9vdDIucmF3cy5pbmRlbnQ7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgcm9vdDIud2FsayhmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgdmFyIHAgPSBpMi5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAocCAmJiBwICE9PSByb290MiAmJiBwLnBhcmVudCAmJiBwLnBhcmVudCA9PT0gcm9vdDIpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmVmb3JlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IGkyLnJhd3MuYmVmb3JlLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcUy9nLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5yYXdTZW1pY29sb24gPSBmdW5jdGlvbiByYXdTZW1pY29sb24ocm9vdDIpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICByb290Mi53YWxrKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICBpZiAoaTIubm9kZXMgJiYgaTIubm9kZXMubGVuZ3RoICYmIGkyLmxhc3QudHlwZSA9PT0gXCJkZWNsXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3Muc2VtaWNvbG9uO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5yYXdWYWx1ZSA9IGZ1bmN0aW9uIHJhd1ZhbHVlKG5vZGUyLCBwcm9wKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG5vZGUyW3Byb3BdO1xuICAgICAgICB2YXIgcmF3ID0gbm9kZTIucmF3c1twcm9wXTtcbiAgICAgICAgaWYgKHJhdyAmJiByYXcudmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmF3LnJhdztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8ucm9vdCA9IGZ1bmN0aW9uIHJvb3Qobm9kZTIpIHtcbiAgICAgICAgdGhpcy5ib2R5KG5vZGUyKTtcbiAgICAgICAgaWYgKG5vZGUyLnJhd3MuYWZ0ZXIpIHRoaXMuYnVpbGRlcihub2RlMi5yYXdzLmFmdGVyKTtcbiAgICB9O1xuICAgIF9wcm90by5ydWxlID0gZnVuY3Rpb24gcnVsZShub2RlMikge1xuICAgICAgICB0aGlzLmJsb2NrKG5vZGUyLCB0aGlzLnJhd1ZhbHVlKG5vZGUyLCBcInNlbGVjdG9yXCIpKTtcbiAgICAgICAgaWYgKG5vZGUyLnJhd3Mub3duU2VtaWNvbG9uKSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkZXIobm9kZTIucmF3cy5vd25TZW1pY29sb24sIG5vZGUyLCBcImVuZFwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIHN0cmluZ2lmeShub2RlMiwgc2VtaWNvbG9uKSB7XG4gICAgICAgIGlmICghdGhpc1tub2RlMi50eXBlXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBBU1Qgbm9kZSB0eXBlIFwiICsgbm9kZTIudHlwZSArIFwiLiBNYXliZSB5b3UgbmVlZCB0byBjaGFuZ2UgUG9zdENTUyBzdHJpbmdpZmllci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tub2RlMi50eXBlXShub2RlMiwgc2VtaWNvbG9uKTtcbiAgICB9O1xuICAgIHJldHVybiBTdHJpbmdpZmllcjI7XG59KCk7XG52YXIgc3RyaW5naWZpZXIgPSBTdHJpbmdpZmllciQyO1xuU3RyaW5naWZpZXIkMi5kZWZhdWx0ID0gU3RyaW5naWZpZXIkMjtcbnZhciBTdHJpbmdpZmllciQxID0gc3RyaW5naWZpZXI7XG5mdW5jdGlvbiBzdHJpbmdpZnkkNChub2RlMiwgYnVpbGRlcikge1xuICAgIHZhciBzdHIgPSBuZXcgU3RyaW5naWZpZXIkMShidWlsZGVyKTtcbiAgICBzdHIuc3RyaW5naWZ5KG5vZGUyKTtcbn1cbnZhciBzdHJpbmdpZnlfMSA9IHN0cmluZ2lmeSQ0O1xuc3RyaW5naWZ5JDQuZGVmYXVsdCA9IHN0cmluZ2lmeSQ0O1xudmFyIGlzQ2xlYW4kMiA9IHN5bWJvbHMuaXNDbGVhbiwgbXkkMiA9IHN5bWJvbHMubXk7XG52YXIgQ3NzU3ludGF4RXJyb3IkMiA9IGNzc1N5bnRheEVycm9yO1xudmFyIFN0cmluZ2lmaWVyMjIgPSBzdHJpbmdpZmllcjtcbnZhciBzdHJpbmdpZnkkMyA9IHN0cmluZ2lmeV8xO1xuZnVuY3Rpb24gY2xvbmVOb2RlKG9iaiwgcGFyZW50KSB7XG4gICAgdmFyIGNsb25lZCA9IG5ldyBvYmouY29uc3RydWN0b3IoKTtcbiAgICBmb3IodmFyIGkyIGluIG9iail7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaTIpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaTIgPT09IFwicHJveHlDYWNoZVwiKSBjb250aW51ZTtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqW2kyXTtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YodmFsdWUpO1xuICAgICAgICBpZiAoaTIgPT09IFwicGFyZW50XCIgJiYgdHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKHBhcmVudCkgY2xvbmVkW2kyXSA9IHBhcmVudDtcbiAgICAgICAgfSBlbHNlIGlmIChpMiA9PT0gXCJzb3VyY2VcIikge1xuICAgICAgICAgICAgY2xvbmVkW2kyXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBjbG9uZWRbaTJdID0gdmFsdWUubWFwKGZ1bmN0aW9uKGopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVOb2RlKGosIGNsb25lZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB2YWx1ZSA9IGNsb25lTm9kZSh2YWx1ZSk7XG4gICAgICAgICAgICBjbG9uZWRbaTJdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsb25lZDtcbn1cbnZhciBOb2RlJDQgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIE5vZGUzKGRlZmF1bHRzKSB7XG4gICAgICAgIGlmIChkZWZhdWx0cyA9PT0gdm9pZCAwKSBkZWZhdWx0cyA9IHt9O1xuICAgICAgICB0aGlzLnJhd3MgPSB7fTtcbiAgICAgICAgdGhpc1tpc0NsZWFuJDJdID0gZmFsc2U7XG4gICAgICAgIHRoaXNbbXkkMl0gPSB0cnVlO1xuICAgICAgICBmb3IodmFyIG5hbWUgaW4gZGVmYXVsdHMpe1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwibm9kZXNcIikge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShkZWZhdWx0c1tuYW1lXSksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZTIuY2xvbmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmQobm9kZTIuY2xvbmUoKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZChub2RlMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbbmFtZV0gPSBkZWZhdWx0c1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gTm9kZTMucHJvdG90eXBlO1xuICAgIF9wcm90by5hZGRUb0Vycm9yID0gZnVuY3Rpb24gYWRkVG9FcnJvcihlcnJvcikge1xuICAgICAgICBlcnJvci5wb3N0Y3NzTm9kZSA9IHRoaXM7XG4gICAgICAgIGlmIChlcnJvci5zdGFjayAmJiB0aGlzLnNvdXJjZSAmJiAvXFxuXFxzezR9YXQgLy50ZXN0KGVycm9yLnN0YWNrKSkge1xuICAgICAgICAgICAgdmFyIHMyID0gdGhpcy5zb3VyY2U7XG4gICAgICAgICAgICBlcnJvci5zdGFjayA9IGVycm9yLnN0YWNrLnJlcGxhY2UoL1xcblxcc3s0fWF0IC8sIFwiJCZcIiArIHMyLmlucHV0LmZyb20gKyBcIjpcIiArIHMyLnN0YXJ0LmxpbmUgKyBcIjpcIiArIHMyLnN0YXJ0LmNvbHVtbiArIFwiJCZcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH07XG4gICAgX3Byb3RvLmFmdGVyID0gZnVuY3Rpb24gYWZ0ZXIoYWRkKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lmluc2VydEFmdGVyKHRoaXMsIGFkZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLmFzc2lnbiA9IGZ1bmN0aW9uIGFzc2lnbihvdmVycmlkZXMpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlcyA9PT0gdm9pZCAwKSBvdmVycmlkZXMgPSB7fTtcbiAgICAgICAgZm9yKHZhciBuYW1lIGluIG92ZXJyaWRlcyl7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gb3ZlcnJpZGVzW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLmJlZm9yZSA9IGZ1bmN0aW9uIGJlZm9yZShhZGQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMsIGFkZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLmNsZWFuUmF3cyA9IGZ1bmN0aW9uIGNsZWFuUmF3cyhrZWVwQmV0d2Vlbikge1xuICAgICAgICBkZWxldGUgdGhpcy5yYXdzLmJlZm9yZTtcbiAgICAgICAgZGVsZXRlIHRoaXMucmF3cy5hZnRlcjtcbiAgICAgICAgaWYgKCFrZWVwQmV0d2VlbikgZGVsZXRlIHRoaXMucmF3cy5iZXR3ZWVuO1xuICAgIH07XG4gICAgX3Byb3RvLmNsb25lID0gZnVuY3Rpb24gY2xvbmUob3ZlcnJpZGVzKSB7XG4gICAgICAgIGlmIChvdmVycmlkZXMgPT09IHZvaWQgMCkgb3ZlcnJpZGVzID0ge307XG4gICAgICAgIHZhciBjbG9uZWQgPSBjbG9uZU5vZGUodGhpcyk7XG4gICAgICAgIGZvcih2YXIgbmFtZSBpbiBvdmVycmlkZXMpe1xuICAgICAgICAgICAgY2xvbmVkW25hbWVdID0gb3ZlcnJpZGVzW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgfTtcbiAgICBfcHJvdG8uY2xvbmVBZnRlciA9IGZ1bmN0aW9uIGNsb25lQWZ0ZXIob3ZlcnJpZGVzKSB7XG4gICAgICAgIGlmIChvdmVycmlkZXMgPT09IHZvaWQgMCkgb3ZlcnJpZGVzID0ge307XG4gICAgICAgIHZhciBjbG9uZWQgPSB0aGlzLmNsb25lKG92ZXJyaWRlcyk7XG4gICAgICAgIHRoaXMucGFyZW50Lmluc2VydEFmdGVyKHRoaXMsIGNsb25lZCk7XG4gICAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgfTtcbiAgICBfcHJvdG8uY2xvbmVCZWZvcmUgPSBmdW5jdGlvbiBjbG9uZUJlZm9yZShvdmVycmlkZXMpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlcyA9PT0gdm9pZCAwKSBvdmVycmlkZXMgPSB7fTtcbiAgICAgICAgdmFyIGNsb25lZCA9IHRoaXMuY2xvbmUob3ZlcnJpZGVzKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMsIGNsb25lZCk7XG4gICAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgfTtcbiAgICBfcHJvdG8uZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihtZXNzYWdlLCBvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzID09PSB2b2lkIDApIG9wdHMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuc291cmNlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXNfcmFuZ2VCeSA9IHRoaXMucmFuZ2VCeShvcHRzKSwgZW5kID0gX3RoaXNfcmFuZ2VCeS5lbmQsIHN0YXJ0ID0gX3RoaXNfcmFuZ2VCeS5zdGFydDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5pbnB1dC5lcnJvcihtZXNzYWdlLCB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBzdGFydC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgbGluZTogc3RhcnQubGluZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGNvbHVtbjogZW5kLmNvbHVtbixcbiAgICAgICAgICAgICAgICBsaW5lOiBlbmQubGluZVxuICAgICAgICAgICAgfSwgb3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDc3NTeW50YXhFcnJvciQyKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgX3Byb3RvLmdldFByb3h5UHJvY2Vzc29yID0gZnVuY3Rpb24gZ2V0UHJveHlQcm9jZXNzb3IoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldChub2RlMiwgcHJvcCkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSBcInByb3h5T2ZcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBcInJvb3RcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTIucm9vdCgpLnRvUHJveHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTJbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KG5vZGUyLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlMltwcm9wXSA9PT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIG5vZGUyW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgPT09IFwicHJvcFwiIHx8IHByb3AgPT09IFwidmFsdWVcIiB8fCBwcm9wID09PSBcIm5hbWVcIiB8fCBwcm9wID09PSBcInBhcmFtc1wiIHx8IHByb3AgPT09IFwiaW1wb3J0YW50XCIgfHwgLyogYzggaWdub3JlIG5leHQgKi8gcHJvcCA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTIubWFya0RpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLm1hcmtEaXJ0eSA9IGZ1bmN0aW9uIG1hcmtEaXJ0eSgpIHtcbiAgICAgICAgaWYgKHRoaXNbaXNDbGVhbiQyXSkge1xuICAgICAgICAgICAgdGhpc1tpc0NsZWFuJDJdID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZShuZXh0ID0gbmV4dC5wYXJlbnQpe1xuICAgICAgICAgICAgICAgIG5leHRbaXNDbGVhbiQyXSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ubmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHJldHVybiB2b2lkIDA7XG4gICAgICAgIHZhciBpbmRleDIgPSB0aGlzLnBhcmVudC5pbmRleCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm5vZGVzW2luZGV4MiArIDFdO1xuICAgIH07XG4gICAgX3Byb3RvLnBvc2l0aW9uQnkgPSBmdW5jdGlvbiBwb3NpdGlvbkJ5KG9wdHMsIHN0cmluZ1JlcHJlc2VudGF0aW9uKSB7XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnNvdXJjZS5zdGFydDtcbiAgICAgICAgaWYgKG9wdHMuaW5kZXgpIHtcbiAgICAgICAgICAgIHBvcyA9IHRoaXMucG9zaXRpb25JbnNpZGUob3B0cy5pbmRleCwgc3RyaW5nUmVwcmVzZW50YXRpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdHMud29yZCkge1xuICAgICAgICAgICAgc3RyaW5nUmVwcmVzZW50YXRpb24gPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB2YXIgaW5kZXgyID0gc3RyaW5nUmVwcmVzZW50YXRpb24uaW5kZXhPZihvcHRzLndvcmQpO1xuICAgICAgICAgICAgaWYgKGluZGV4MiAhPT0gLTEpIHBvcyA9IHRoaXMucG9zaXRpb25JbnNpZGUoaW5kZXgyLCBzdHJpbmdSZXByZXNlbnRhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9O1xuICAgIF9wcm90by5wb3NpdGlvbkluc2lkZSA9IGZ1bmN0aW9uIHBvc2l0aW9uSW5zaWRlKGluZGV4Miwgc3RyaW5nUmVwcmVzZW50YXRpb24pIHtcbiAgICAgICAgdmFyIHN0cmluZyA9IHN0cmluZ1JlcHJlc2VudGF0aW9uIHx8IHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuc291cmNlLnN0YXJ0LmNvbHVtbjtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLnNvdXJjZS5zdGFydC5saW5lO1xuICAgICAgICBmb3IodmFyIGkyID0gMDsgaTIgPCBpbmRleDI7IGkyKyspe1xuICAgICAgICAgICAgaWYgKHN0cmluZ1tpMl0gPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSAxO1xuICAgICAgICAgICAgICAgIGxpbmUgKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29sdW1uICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgICAgICAgbGluZTogbGluZVxuICAgICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLnByZXYgPSBmdW5jdGlvbiBwcmV2KCkge1xuICAgICAgICBpZiAoIXRoaXMucGFyZW50KSByZXR1cm4gdm9pZCAwO1xuICAgICAgICB2YXIgaW5kZXgyID0gdGhpcy5wYXJlbnQuaW5kZXgodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5ub2Rlc1tpbmRleDIgLSAxXTtcbiAgICB9O1xuICAgIF9wcm90by5yYW5nZUJ5ID0gZnVuY3Rpb24gcmFuZ2VCeShvcHRzKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHtcbiAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zb3VyY2Uuc3RhcnQuY29sdW1uLFxuICAgICAgICAgICAgbGluZTogdGhpcy5zb3VyY2Uuc3RhcnQubGluZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5zb3VyY2UuZW5kID8ge1xuICAgICAgICAgICAgY29sdW1uOiB0aGlzLnNvdXJjZS5lbmQuY29sdW1uICsgMSxcbiAgICAgICAgICAgIGxpbmU6IHRoaXMuc291cmNlLmVuZC5saW5lXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgICBjb2x1bW46IHN0YXJ0LmNvbHVtbiArIDEsXG4gICAgICAgICAgICBsaW5lOiBzdGFydC5saW5lXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRzLndvcmQpIHtcbiAgICAgICAgICAgIHZhciBzdHJpbmdSZXByZXNlbnRhdGlvbiA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHZhciBpbmRleDIgPSBzdHJpbmdSZXByZXNlbnRhdGlvbi5pbmRleE9mKG9wdHMud29yZCk7XG4gICAgICAgICAgICBpZiAoaW5kZXgyICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5wb3NpdGlvbkluc2lkZShpbmRleDIsIHN0cmluZ1JlcHJlc2VudGF0aW9uKTtcbiAgICAgICAgICAgICAgICBlbmQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKGluZGV4MiArIG9wdHMud29yZC5sZW5ndGgsIHN0cmluZ1JlcHJlc2VudGF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvcHRzLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbjogb3B0cy5zdGFydC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IG9wdHMuc3RhcnQubGluZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdHMuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMucG9zaXRpb25JbnNpZGUob3B0cy5pbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5lbmQpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbjogb3B0cy5lbmQuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiBvcHRzLmVuZC5saW5lXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdHMuZW5kSW5kZXggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKG9wdHMuZW5kSW5kZXgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRzLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgZW5kID0gdGhpcy5wb3NpdGlvbkluc2lkZShvcHRzLmluZGV4ICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZC5saW5lIDwgc3RhcnQubGluZSB8fCBlbmQubGluZSA9PT0gc3RhcnQubGluZSAmJiBlbmQuY29sdW1uIDw9IHN0YXJ0LmNvbHVtbikge1xuICAgICAgICAgICAgZW5kID0ge1xuICAgICAgICAgICAgICAgIGNvbHVtbjogc3RhcnQuY29sdW1uICsgMSxcbiAgICAgICAgICAgICAgICBsaW5lOiBzdGFydC5saW5lXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydFxuICAgICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLnJhdyA9IGZ1bmN0aW9uIHJhdyhwcm9wLCBkZWZhdWx0VHlwZSkge1xuICAgICAgICB2YXIgc3RyID0gbmV3IFN0cmluZ2lmaWVyMjIoKTtcbiAgICAgICAgcmV0dXJuIHN0ci5yYXcodGhpcywgcHJvcCwgZGVmYXVsdFR5cGUpO1xuICAgIH07XG4gICAgX3Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcmVudCA9IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVwbGFjZVdpdGggPSBmdW5jdGlvbiByZXBsYWNlV2l0aCgpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbm9kZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIG5vZGVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdmFyIGJvb2ttYXJrID0gdGhpcztcbiAgICAgICAgICAgIHZhciBmb3VuZFNlbGYgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKG5vZGVzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgIHZhciBub2RlMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlMiA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZFNlbGYgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZm91bmRTZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Lmluc2VydEFmdGVyKGJvb2ttYXJrLCBub2RlMik7XG4gICAgICAgICAgICAgICAgICAgIGJvb2ttYXJrID0gbm9kZTI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKGJvb2ttYXJrLCBub2RlMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmb3VuZFNlbGYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLnJvb3QgPSBmdW5jdGlvbiByb290KCkge1xuICAgICAgICB2YXIgcmVzdWx0MiA9IHRoaXM7XG4gICAgICAgIHdoaWxlKHJlc3VsdDIucGFyZW50ICYmIHJlc3VsdDIucGFyZW50LnR5cGUgIT09IFwiZG9jdW1lbnRcIil7XG4gICAgICAgICAgICByZXN1bHQyID0gcmVzdWx0Mi5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgfTtcbiAgICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKF8sIGlucHV0cykge1xuICAgICAgICB2YXIgZml4ZWQgPSB7fTtcbiAgICAgICAgdmFyIGVtaXRJbnB1dHMgPSBpbnB1dHMgPT0gbnVsbDtcbiAgICAgICAgaW5wdXRzID0gaW5wdXRzIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBpbnB1dHNOZXh0SW5kZXggPSAwO1xuICAgICAgICBmb3IodmFyIG5hbWUgaW4gdGhpcyl7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBuYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwicGFyZW50XCIgfHwgbmFtZSA9PT0gXCJwcm94eUNhY2hlXCIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZpeGVkW25hbWVdID0gdmFsdWUubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIGkyID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKGkyKSkgPT09IFwib2JqZWN0XCIgJiYgaTIudG9KU09OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTIudG9KU09OKG51bGwsIGlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZih2YWx1ZSkpID09PSBcIm9iamVjdFwiICYmIHZhbHVlLnRvSlNPTikge1xuICAgICAgICAgICAgICAgIGZpeGVkW25hbWVdID0gdmFsdWUudG9KU09OKG51bGwsIGlucHV0cyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwic291cmNlXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXRJZCA9IGlucHV0cy5nZXQodmFsdWUuaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dElkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRJZCA9IGlucHV0c05leHRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzLnNldCh2YWx1ZS5pbnB1dCwgaW5wdXRzTmV4dEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzTmV4dEluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpeGVkW25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICBlbmQ6IHZhbHVlLmVuZCxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRJZDogaW5wdXRJZCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHZhbHVlLnN0YXJ0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZml4ZWRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW1pdElucHV0cykge1xuICAgICAgICAgICAgZml4ZWQuaW5wdXRzID0gW10uY29uY2F0KGlucHV0cy5rZXlzKCkpLm1hcChmdW5jdGlvbihpbnB1dDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQyLnRvSlNPTigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpeGVkO1xuICAgIH07XG4gICAgX3Byb3RvLnRvUHJveHkgPSBmdW5jdGlvbiB0b1Byb3h5KCkge1xuICAgICAgICBpZiAoIXRoaXMucHJveHlDYWNoZSkge1xuICAgICAgICAgICAgdGhpcy5wcm94eUNhY2hlID0gbmV3IFByb3h5KHRoaXMsIHRoaXMuZ2V0UHJveHlQcm9jZXNzb3IoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJveHlDYWNoZTtcbiAgICB9O1xuICAgIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKHN0cmluZ2lmaWVyMikge1xuICAgICAgICBpZiAoc3RyaW5naWZpZXIyID09PSB2b2lkIDApIHN0cmluZ2lmaWVyMiA9IHN0cmluZ2lmeSQzO1xuICAgICAgICBpZiAoc3RyaW5naWZpZXIyLnN0cmluZ2lmeSkgc3RyaW5naWZpZXIyID0gc3RyaW5naWZpZXIyLnN0cmluZ2lmeTtcbiAgICAgICAgdmFyIHJlc3VsdDIgPSBcIlwiO1xuICAgICAgICBzdHJpbmdpZmllcjIodGhpcywgZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgKz0gaTI7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICB9O1xuICAgIF9wcm90by53YXJuID0gZnVuY3Rpb24gd2FybihyZXN1bHQyLCB0ZXh0LCBvcHRzKSB7XG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgbm9kZTogdGhpc1xuICAgICAgICB9O1xuICAgICAgICBmb3IodmFyIGkyIGluIG9wdHMpZGF0YVtpMl0gPSBvcHRzW2kyXTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDIud2Fybih0ZXh0LCBkYXRhKTtcbiAgICB9O1xuICAgIF9jcmVhdGVfY2xhc3MoTm9kZTMsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInByb3h5T2ZcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIE5vZGUzO1xufSgpO1xudmFyIG5vZGUgPSBOb2RlJDQ7XG5Ob2RlJDQuZGVmYXVsdCA9IE5vZGUkNDtcbnZhciBOb2RlJDMgPSBub2RlO1xudmFyIERlY2xhcmF0aW9uJDQgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKE5vZGUkMykge1xuICAgIF9pbmhlcml0cyhEZWNsYXJhdGlvbjIsIE5vZGUkMyk7XG4gICAgZnVuY3Rpb24gRGVjbGFyYXRpb24yKGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgaWYgKGRlZmF1bHRzICYmIHR5cGVvZiBkZWZhdWx0cy52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgZGVmYXVsdHMudmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGRlZmF1bHRzID0gX2V4dGVuZHMoe30sIGRlZmF1bHRzLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFN0cmluZyhkZWZhdWx0cy52YWx1ZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzID0gTm9kZSQzLmNhbGwodGhpcywgZGVmYXVsdHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSBcImRlY2xcIjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBfY3JlYXRlX2NsYXNzKERlY2xhcmF0aW9uMiwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwidmFyaWFibGVcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3Auc3RhcnRzV2l0aChcIi0tXCIpIHx8IHRoaXMucHJvcFswXSA9PT0gXCIkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gRGVjbGFyYXRpb24yO1xufShOb2RlJDMpO1xudmFyIGRlY2xhcmF0aW9uID0gRGVjbGFyYXRpb24kNDtcbkRlY2xhcmF0aW9uJDQuZGVmYXVsdCA9IERlY2xhcmF0aW9uJDQ7XG52YXIgdXJsQWxwaGFiZXQgPSBcInVzZWFuZG9tLTI2VDE5ODM0MFBYNzVweEpBQ0tWRVJZTUlOREJVU0hXT0xGX0dRWmJmZ2hqa2xxdnd5enJpY3RcIjtcbnZhciBuYW5vaWQkMSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICBpZiAoc2l6ZSA9PT0gdm9pZCAwKSBzaXplID0gMjE7XG4gICAgdmFyIGlkID0gXCJcIjtcbiAgICB2YXIgaTIgPSBzaXplO1xuICAgIHdoaWxlKGkyLS0pe1xuICAgICAgICBpZCArPSB1cmxBbHBoYWJldFtNYXRoLnJhbmRvbSgpICogNjQgfCAwXTtcbiAgICB9XG4gICAgcmV0dXJuIGlkO1xufTtcbnZhciBub25TZWN1cmUgPSB7XG4gICAgbmFub2lkOiBuYW5vaWQkMVxufTtcbnZhciBTb3VyY2VNYXBDb25zdW1lciQyID0gcmVxdWlyZSQkMi5Tb3VyY2VNYXBDb25zdW1lciwgU291cmNlTWFwR2VuZXJhdG9yJDIgPSByZXF1aXJlJCQyLlNvdXJjZU1hcEdlbmVyYXRvcjtcbnZhciBleGlzdHNTeW5jID0gcmVxdWlyZSQkMi5leGlzdHNTeW5jLCByZWFkRmlsZVN5bmMgPSByZXF1aXJlJCQyLnJlYWRGaWxlU3luYztcbnZhciBkaXJuYW1lJDEgPSByZXF1aXJlJCQyLmRpcm5hbWUsIGpvaW4gPSByZXF1aXJlJCQyLmpvaW47XG5mdW5jdGlvbiBmcm9tQmFzZTY0KHN0cikge1xuICAgIGlmIChCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0ciwgXCJiYXNlNjRcIikudG9TdHJpbmcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gd2luZG93LmF0b2Ioc3RyKTtcbiAgICB9XG59XG52YXIgUHJldmlvdXNNYXAkMiA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gUHJldmlvdXNNYXAyKGNzcywgb3B0cykge1xuICAgICAgICBpZiAob3B0cy5tYXAgPT09IGZhbHNlKSByZXR1cm47XG4gICAgICAgIHRoaXMubG9hZEFubm90YXRpb24oY3NzKTtcbiAgICAgICAgdGhpcy5pbmxpbmUgPSB0aGlzLnN0YXJ0V2l0aCh0aGlzLmFubm90YXRpb24sIFwiZGF0YTpcIik7XG4gICAgICAgIHZhciBwcmV2ID0gb3B0cy5tYXAgPyBvcHRzLm1hcC5wcmV2IDogdm9pZCAwO1xuICAgICAgICB2YXIgdGV4dCA9IHRoaXMubG9hZE1hcChvcHRzLmZyb20sIHByZXYpO1xuICAgICAgICBpZiAoIXRoaXMubWFwRmlsZSAmJiBvcHRzLmZyb20pIHtcbiAgICAgICAgICAgIHRoaXMubWFwRmlsZSA9IG9wdHMuZnJvbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXBGaWxlKSB0aGlzLnJvb3QgPSBkaXJuYW1lJDEodGhpcy5tYXBGaWxlKTtcbiAgICAgICAgaWYgKHRleHQpIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBQcmV2aW91c01hcDIucHJvdG90eXBlO1xuICAgIF9wcm90by5jb25zdW1lciA9IGZ1bmN0aW9uIGNvbnN1bWVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29uc3VtZXJDYWNoZSkge1xuICAgICAgICAgICAgdGhpcy5jb25zdW1lckNhY2hlID0gbmV3IFNvdXJjZU1hcENvbnN1bWVyJDIodGhpcy50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lckNhY2hlO1xuICAgIH07XG4gICAgX3Byb3RvLmRlY29kZUlubGluZSA9IGZ1bmN0aW9uIGRlY29kZUlubGluZSh0ZXh0KSB7XG4gICAgICAgIHZhciBiYXNlQ2hhcnNldFVyaSA9IC9eZGF0YTphcHBsaWNhdGlvblxcL2pzb247Y2hhcnNldD11dGYtPzg7YmFzZTY0LC87XG4gICAgICAgIHZhciBiYXNlVXJpID0gL15kYXRhOmFwcGxpY2F0aW9uXFwvanNvbjtiYXNlNjQsLztcbiAgICAgICAgdmFyIGNoYXJzZXRVcmkgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uO2NoYXJzZXQ9dXRmLT84LC87XG4gICAgICAgIHZhciB1cmkgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uLC87XG4gICAgICAgIGlmIChjaGFyc2V0VXJpLnRlc3QodGV4dCkgfHwgdXJpLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQodGV4dC5zdWJzdHIoUmVnRXhwLmxhc3RNYXRjaC5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFzZUNoYXJzZXRVcmkudGVzdCh0ZXh0KSB8fCBiYXNlVXJpLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tQmFzZTY0KHRleHQuc3Vic3RyKFJlZ0V4cC5sYXN0TWF0Y2gubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVuY29kaW5nID0gdGV4dC5tYXRjaCgvZGF0YTphcHBsaWNhdGlvblxcL2pzb247KFteLF0rKSwvKVsxXTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgc291cmNlIG1hcCBlbmNvZGluZyBcIiArIGVuY29kaW5nKTtcbiAgICB9O1xuICAgIF9wcm90by5nZXRBbm5vdGF0aW9uVVJMID0gZnVuY3Rpb24gZ2V0QW5ub3RhdGlvblVSTChzb3VyY2VNYXBTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZU1hcFN0cmluZy5yZXBsYWNlKC9eXFwvXFwqXFxzKiMgc291cmNlTWFwcGluZ1VSTD0vLCBcIlwiKS50cmltKCk7XG4gICAgfTtcbiAgICBfcHJvdG8uaXNNYXAgPSBmdW5jdGlvbiBpc01hcChtYXApIHtcbiAgICAgICAgaWYgKCh0eXBlb2YgbWFwID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKG1hcCkpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0eXBlb2YgbWFwLm1hcHBpbmdzID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBtYXAuX21hcHBpbmdzID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkobWFwLnNlY3Rpb25zKTtcbiAgICB9O1xuICAgIF9wcm90by5sb2FkQW5ub3RhdGlvbiA9IGZ1bmN0aW9uIGxvYWRBbm5vdGF0aW9uKGNzcykge1xuICAgICAgICB2YXIgY29tbWVudHMgPSBjc3MubWF0Y2goL1xcL1xcKlxccyojIHNvdXJjZU1hcHBpbmdVUkw9L2dtKTtcbiAgICAgICAgaWYgKCFjb21tZW50cykgcmV0dXJuO1xuICAgICAgICB2YXIgc3RhcnQgPSBjc3MubGFzdEluZGV4T2YoY29tbWVudHMucG9wKCkpO1xuICAgICAgICB2YXIgZW5kID0gY3NzLmluZGV4T2YoXCIqL1wiLCBzdGFydCk7XG4gICAgICAgIGlmIChzdGFydCA+IC0xICYmIGVuZCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmFubm90YXRpb24gPSB0aGlzLmdldEFubm90YXRpb25VUkwoY3NzLnN1YnN0cmluZyhzdGFydCwgZW5kKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5sb2FkRmlsZSA9IGZ1bmN0aW9uIGxvYWRGaWxlKHBhdGgpIHtcbiAgICAgICAgdGhpcy5yb290ID0gZGlybmFtZSQxKHBhdGgpO1xuICAgICAgICBpZiAoZXhpc3RzU3luYyhwYXRoKSkge1xuICAgICAgICAgICAgdGhpcy5tYXBGaWxlID0gcGF0aDtcbiAgICAgICAgICAgIHJldHVybiByZWFkRmlsZVN5bmMocGF0aCwgXCJ1dGYtOFwiKS50b1N0cmluZygpLnRyaW0oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmxvYWRNYXAgPSBmdW5jdGlvbiBsb2FkTWFwKGZpbGUsIHByZXYpIHtcbiAgICAgICAgaWYgKHByZXYgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByZXYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHByZXYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2UGF0aCA9IHByZXYoZmlsZSk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXAgPSB0aGlzLmxvYWRGaWxlKHByZXZQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBsb2FkIHByZXZpb3VzIHNvdXJjZSBtYXA6IFwiICsgcHJldlBhdGgudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF9pbnN0YW5jZW9mKHByZXYsIFNvdXJjZU1hcENvbnN1bWVyJDIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNvdXJjZU1hcEdlbmVyYXRvciQyLmZyb21Tb3VyY2VNYXAocHJldikudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX2luc3RhbmNlb2YocHJldiwgU291cmNlTWFwR2VuZXJhdG9yJDIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXYudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc01hcChwcmV2KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwcmV2KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgcHJldmlvdXMgc291cmNlIG1hcCBmb3JtYXQ6IFwiICsgcHJldi50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlubGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlSW5saW5lKHRoaXMuYW5ub3RhdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5hbm5vdGF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbWFwMSA9IHRoaXMuYW5ub3RhdGlvbjtcbiAgICAgICAgICAgIGlmIChmaWxlKSBtYXAxID0gam9pbihkaXJuYW1lJDEoZmlsZSksIG1hcDEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZEZpbGUobWFwMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5zdGFydFdpdGggPSBmdW5jdGlvbiBzdGFydFdpdGgoc3RyaW5nLCBzdGFydCkge1xuICAgICAgICBpZiAoIXN0cmluZykgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gc3RyaW5nLnN1YnN0cigwLCBzdGFydC5sZW5ndGgpID09PSBzdGFydDtcbiAgICB9O1xuICAgIF9wcm90by53aXRoQ29udGVudCA9IGZ1bmN0aW9uIHdpdGhDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy5jb25zdW1lcigpLnNvdXJjZXNDb250ZW50ICYmIHRoaXMuY29uc3VtZXIoKS5zb3VyY2VzQ29udGVudC5sZW5ndGggPiAwKTtcbiAgICB9O1xuICAgIHJldHVybiBQcmV2aW91c01hcDI7XG59KCk7XG52YXIgcHJldmlvdXNNYXAgPSBQcmV2aW91c01hcCQyO1xuUHJldmlvdXNNYXAkMi5kZWZhdWx0ID0gUHJldmlvdXNNYXAkMjtcbnZhciBTb3VyY2VNYXBDb25zdW1lciQxID0gcmVxdWlyZSQkMi5Tb3VyY2VNYXBDb25zdW1lciwgU291cmNlTWFwR2VuZXJhdG9yJDEgPSByZXF1aXJlJCQyLlNvdXJjZU1hcEdlbmVyYXRvcjtcbnZhciBmaWxlVVJMVG9QYXRoID0gcmVxdWlyZSQkMi5maWxlVVJMVG9QYXRoLCBwYXRoVG9GaWxlVVJMJDEgPSByZXF1aXJlJCQyLnBhdGhUb0ZpbGVVUkw7XG52YXIgaXNBYnNvbHV0ZSA9IHJlcXVpcmUkJDIuaXNBYnNvbHV0ZSwgcmVzb2x2ZSQxID0gcmVxdWlyZSQkMi5yZXNvbHZlO1xudmFyIG5hbm9pZCA9IG5vblNlY3VyZS5uYW5vaWQ7XG52YXIgdGVybWluYWxIaWdobGlnaHQgPSByZXF1aXJlJCQyO1xudmFyIENzc1N5bnRheEVycm9yJDEgPSBjc3NTeW50YXhFcnJvcjtcbnZhciBQcmV2aW91c01hcCQxID0gcHJldmlvdXNNYXA7XG52YXIgZnJvbU9mZnNldENhY2hlID0gU3ltYm9sKFwiZnJvbU9mZnNldENhY2hlXCIpO1xudmFyIHNvdXJjZU1hcEF2YWlsYWJsZSQxID0gQm9vbGVhbihTb3VyY2VNYXBDb25zdW1lciQxICYmIFNvdXJjZU1hcEdlbmVyYXRvciQxKTtcbnZhciBwYXRoQXZhaWxhYmxlJDEgPSBCb29sZWFuKHJlc29sdmUkMSAmJiBpc0Fic29sdXRlKTtcbnZhciBJbnB1dCQ0ID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBJbnB1dDIoY3NzLCBvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzID09PSB2b2lkIDApIG9wdHMgPSB7fTtcbiAgICAgICAgaWYgKGNzcyA9PT0gbnVsbCB8fCB0eXBlb2YgY3NzID09PSBcInVuZGVmaW5lZFwiIHx8ICh0eXBlb2YgY3NzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKGNzcykpID09PSBcIm9iamVjdFwiICYmICFjc3MudG9TdHJpbmcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvc3RDU1MgcmVjZWl2ZWQgXCIgKyBjc3MgKyBcIiBpbnN0ZWFkIG9mIENTUyBzdHJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jc3MgPSBjc3MudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHRoaXMuY3NzWzBdID09PSBcIlxcdUZFRkZcIiB8fCB0aGlzLmNzc1swXSA9PT0gXCLvv75cIikge1xuICAgICAgICAgICAgdGhpcy5oYXNCT00gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jc3MgPSB0aGlzLmNzcy5zbGljZSgxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGFzQk9NID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuZnJvbSkge1xuICAgICAgICAgICAgaWYgKCFwYXRoQXZhaWxhYmxlJDEgfHwgL15cXHcrOlxcL1xcLy8udGVzdChvcHRzLmZyb20pIHx8IGlzQWJzb2x1dGUob3B0cy5mcm9tKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZSA9IG9wdHMuZnJvbTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlID0gcmVzb2x2ZSQxKG9wdHMuZnJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGhBdmFpbGFibGUkMSAmJiBzb3VyY2VNYXBBdmFpbGFibGUkMSkge1xuICAgICAgICAgICAgdmFyIG1hcCA9IG5ldyBQcmV2aW91c01hcCQxKHRoaXMuY3NzLCBvcHRzKTtcbiAgICAgICAgICAgIGlmIChtYXAudGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFwID0gbWFwO1xuICAgICAgICAgICAgICAgIHZhciBmaWxlID0gbWFwLmNvbnN1bWVyKCkuZmlsZTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZmlsZSAmJiBmaWxlKSB0aGlzLmZpbGUgPSB0aGlzLm1hcFJlc29sdmUoZmlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmZpbGUpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBcIjxpbnB1dCBjc3MgXCIgKyBuYW5vaWQoNikgKyBcIj5cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXApIHRoaXMubWFwLmZpbGUgPSB0aGlzLmZyb207XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBJbnB1dDIucHJvdG90eXBlO1xuICAgIF9wcm90by5lcnJvciA9IGZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UsIGxpbmUsIGNvbHVtbiwgb3B0cykge1xuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSBvcHRzID0ge307XG4gICAgICAgIHZhciByZXN1bHQyLCBlbmRMaW5lLCBlbmRDb2x1bW47XG4gICAgICAgIGlmIChsaW5lICYmICh0eXBlb2YgbGluZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihsaW5lKSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGxpbmU7XG4gICAgICAgICAgICB2YXIgZW5kID0gY29sdW1uO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGFydC5vZmZzZXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5mcm9tT2Zmc2V0KHN0YXJ0Lm9mZnNldCk7XG4gICAgICAgICAgICAgICAgbGluZSA9IHBvcy5saW5lO1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IHBvcy5jb2w7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBzdGFydC5saW5lO1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IHN0YXJ0LmNvbHVtbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5kLm9mZnNldCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHZhciBwb3MxID0gdGhpcy5mcm9tT2Zmc2V0KGVuZC5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGVuZExpbmUgPSBwb3MxLmxpbmU7XG4gICAgICAgICAgICAgICAgZW5kQ29sdW1uID0gcG9zMS5jb2w7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZExpbmUgPSBlbmQubGluZTtcbiAgICAgICAgICAgICAgICBlbmRDb2x1bW4gPSBlbmQuY29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFjb2x1bW4pIHtcbiAgICAgICAgICAgIHZhciBwb3MyID0gdGhpcy5mcm9tT2Zmc2V0KGxpbmUpO1xuICAgICAgICAgICAgbGluZSA9IHBvczIubGluZTtcbiAgICAgICAgICAgIGNvbHVtbiA9IHBvczIuY29sO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcmlnaW4gPSB0aGlzLm9yaWdpbihsaW5lLCBjb2x1bW4sIGVuZExpbmUsIGVuZENvbHVtbik7XG4gICAgICAgIGlmIChvcmlnaW4pIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBuZXcgQ3NzU3ludGF4RXJyb3IkMShtZXNzYWdlLCBvcmlnaW4uZW5kTGluZSA9PT0gdm9pZCAwID8gb3JpZ2luLmxpbmUgOiB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBvcmlnaW4uY29sdW1uLFxuICAgICAgICAgICAgICAgIGxpbmU6IG9yaWdpbi5saW5lXG4gICAgICAgICAgICB9LCBvcmlnaW4uZW5kTGluZSA9PT0gdm9pZCAwID8gb3JpZ2luLmNvbHVtbiA6IHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IG9yaWdpbi5lbmRDb2x1bW4sXG4gICAgICAgICAgICAgICAgbGluZTogb3JpZ2luLmVuZExpbmVcbiAgICAgICAgICAgIH0sIG9yaWdpbi5zb3VyY2UsIG9yaWdpbi5maWxlLCBvcHRzLnBsdWdpbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQyID0gbmV3IENzc1N5bnRheEVycm9yJDEobWVzc2FnZSwgZW5kTGluZSA9PT0gdm9pZCAwID8gbGluZSA6IHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgICAgICBsaW5lOiBsaW5lXG4gICAgICAgICAgICB9LCBlbmRMaW5lID09PSB2b2lkIDAgPyBjb2x1bW4gOiB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBlbmRDb2x1bW4sXG4gICAgICAgICAgICAgICAgbGluZTogZW5kTGluZVxuICAgICAgICAgICAgfSwgdGhpcy5jc3MsIHRoaXMuZmlsZSwgb3B0cy5wbHVnaW4pO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdDIuaW5wdXQgPSB7XG4gICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgIGVuZENvbHVtbjogZW5kQ29sdW1uLFxuICAgICAgICAgICAgZW5kTGluZTogZW5kTGluZSxcbiAgICAgICAgICAgIGxpbmU6IGxpbmUsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuY3NzXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmZpbGUpIHtcbiAgICAgICAgICAgIGlmIChwYXRoVG9GaWxlVVJMJDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyLmlucHV0LnVybCA9IHBhdGhUb0ZpbGVVUkwkMSh0aGlzLmZpbGUpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQyLmlucHV0LmZpbGUgPSB0aGlzLmZpbGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgfTtcbiAgICBfcHJvdG8uZnJvbU9mZnNldCA9IGZ1bmN0aW9uIGZyb21PZmZzZXQob2Zmc2V0KSB7XG4gICAgICAgIHZhciBsYXN0TGluZSwgbGluZVRvSW5kZXg7XG4gICAgICAgIGlmICghdGhpc1tmcm9tT2Zmc2V0Q2FjaGVdKSB7XG4gICAgICAgICAgICB2YXIgbGluZXMgPSB0aGlzLmNzcy5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgIGxpbmVUb0luZGV4ID0gbmV3IEFycmF5KGxpbmVzLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgcHJldkluZGV4ID0gMDtcbiAgICAgICAgICAgIGZvcih2YXIgaTIgPSAwLCBsMiA9IGxpbmVzLmxlbmd0aDsgaTIgPCBsMjsgaTIrKyl7XG4gICAgICAgICAgICAgICAgbGluZVRvSW5kZXhbaTJdID0gcHJldkluZGV4O1xuICAgICAgICAgICAgICAgIHByZXZJbmRleCArPSBsaW5lc1tpMl0ubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbZnJvbU9mZnNldENhY2hlXSA9IGxpbmVUb0luZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGluZVRvSW5kZXggPSB0aGlzW2Zyb21PZmZzZXRDYWNoZV07XG4gICAgICAgIH1cbiAgICAgICAgbGFzdExpbmUgPSBsaW5lVG9JbmRleFtsaW5lVG9JbmRleC5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIG1pbiA9IDA7XG4gICAgICAgIGlmIChvZmZzZXQgPj0gbGFzdExpbmUpIHtcbiAgICAgICAgICAgIG1pbiA9IGxpbmVUb0luZGV4Lmxlbmd0aCAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbWF4ID0gbGluZVRvSW5kZXgubGVuZ3RoIC0gMjtcbiAgICAgICAgICAgIHZhciBtaWQ7XG4gICAgICAgICAgICB3aGlsZShtaW4gPCBtYXgpe1xuICAgICAgICAgICAgICAgIG1pZCA9IG1pbiArIChtYXggLSBtaW4gPj4gMSk7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IGxpbmVUb0luZGV4W21pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gbWlkIC0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9mZnNldCA+PSBsaW5lVG9JbmRleFttaWQgKyAxXSkge1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSBtaWQgKyAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IG1pZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2w6IG9mZnNldCAtIGxpbmVUb0luZGV4W21pbl0gKyAxLFxuICAgICAgICAgICAgbGluZTogbWluICsgMVxuICAgICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLm1hcFJlc29sdmUgPSBmdW5jdGlvbiBtYXBSZXNvbHZlKGZpbGUpIHtcbiAgICAgICAgaWYgKC9eXFx3KzpcXC9cXC8vLnRlc3QoZmlsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlJDEodGhpcy5tYXAuY29uc3VtZXIoKS5zb3VyY2VSb290IHx8IHRoaXMubWFwLnJvb3QgfHwgXCIuXCIsIGZpbGUpO1xuICAgIH07XG4gICAgX3Byb3RvLm9yaWdpbiA9IGZ1bmN0aW9uIG9yaWdpbihsaW5lLCBjb2x1bW4sIGVuZExpbmUsIGVuZENvbHVtbikge1xuICAgICAgICBpZiAoIXRoaXMubWFwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBjb25zdW1lciA9IHRoaXMubWFwLmNvbnN1bWVyKCk7XG4gICAgICAgIHZhciBmcm9tID0gY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgIGxpbmU6IGxpbmVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghZnJvbS5zb3VyY2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIHRvO1xuICAgICAgICBpZiAodHlwZW9mIGVuZExpbmUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRvID0gY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBlbmRDb2x1bW4sXG4gICAgICAgICAgICAgICAgbGluZTogZW5kTGluZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZyb21Vcmw7XG4gICAgICAgIGlmIChpc0Fic29sdXRlKGZyb20uc291cmNlKSkge1xuICAgICAgICAgICAgZnJvbVVybCA9IHBhdGhUb0ZpbGVVUkwkMShmcm9tLnNvdXJjZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcm9tVXJsID0gbmV3IFVSTChmcm9tLnNvdXJjZSwgdGhpcy5tYXAuY29uc3VtZXIoKS5zb3VyY2VSb290IHx8IHBhdGhUb0ZpbGVVUkwkMSh0aGlzLm1hcC5tYXBGaWxlKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdDIgPSB7XG4gICAgICAgICAgICBjb2x1bW46IGZyb20uY29sdW1uLFxuICAgICAgICAgICAgZW5kQ29sdW1uOiB0byAmJiB0by5jb2x1bW4sXG4gICAgICAgICAgICBlbmRMaW5lOiB0byAmJiB0by5saW5lLFxuICAgICAgICAgICAgbGluZTogZnJvbS5saW5lLFxuICAgICAgICAgICAgdXJsOiBmcm9tVXJsLnRvU3RyaW5nKClcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGZyb21VcmwucHJvdG9jb2wgPT09IFwiZmlsZTpcIikge1xuICAgICAgICAgICAgaWYgKGZpbGVVUkxUb1BhdGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyLmZpbGUgPSBmaWxlVVJMVG9QYXRoKGZyb21VcmwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaWxlOiBwcm90b2NvbCBpcyBub3QgYXZhaWxhYmxlIGluIHRoaXMgUG9zdENTUyBidWlsZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgc291cmNlID0gY29uc3VtZXIuc291cmNlQ29udGVudEZvcihmcm9tLnNvdXJjZSk7XG4gICAgICAgIGlmIChzb3VyY2UpIHJlc3VsdDIuc291cmNlID0gc291cmNlO1xuICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICB9O1xuICAgIF9wcm90by50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgIHZhciBqc29uID0ge307XG4gICAgICAgIGZvcih2YXIgX2kgPSAwLCBfaXRlciA9IFtcbiAgICAgICAgICAgIFwiaGFzQk9NXCIsXG4gICAgICAgICAgICBcImNzc1wiLFxuICAgICAgICAgICAgXCJmaWxlXCIsXG4gICAgICAgICAgICBcImlkXCJcbiAgICAgICAgXTsgX2kgPCBfaXRlci5sZW5ndGg7IF9pKyspe1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBfaXRlcltfaV07XG4gICAgICAgICAgICBpZiAodGhpc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAganNvbltuYW1lXSA9IHRoaXNbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWFwKSB7XG4gICAgICAgICAgICBqc29uLm1hcCA9IF9leHRlbmRzKHt9LCB0aGlzLm1hcCk7XG4gICAgICAgICAgICBpZiAoanNvbi5tYXAuY29uc3VtZXJDYWNoZSkge1xuICAgICAgICAgICAgICAgIGpzb24ubWFwLmNvbnN1bWVyQ2FjaGUgPSB2b2lkIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfTtcbiAgICBfY3JlYXRlX2NsYXNzKElucHV0MiwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbVwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsZSB8fCB0aGlzLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIElucHV0Mjtcbn0oKTtcbnZhciBpbnB1dCA9IElucHV0JDQ7XG5JbnB1dCQ0LmRlZmF1bHQgPSBJbnB1dCQ0O1xuaWYgKHRlcm1pbmFsSGlnaGxpZ2h0ICYmIHRlcm1pbmFsSGlnaGxpZ2h0LnJlZ2lzdGVySW5wdXQpIHtcbiAgICB0ZXJtaW5hbEhpZ2hsaWdodC5yZWdpc3RlcklucHV0KElucHV0JDQpO1xufVxudmFyIFNvdXJjZU1hcENvbnN1bWVyID0gcmVxdWlyZSQkMi5Tb3VyY2VNYXBDb25zdW1lciwgU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSQkMi5Tb3VyY2VNYXBHZW5lcmF0b3I7XG52YXIgZGlybmFtZSA9IHJlcXVpcmUkJDIuZGlybmFtZSwgcmVsYXRpdmUgPSByZXF1aXJlJCQyLnJlbGF0aXZlLCByZXNvbHZlJDMgPSByZXF1aXJlJCQyLnJlc29sdmUsIHNlcCA9IHJlcXVpcmUkJDIuc2VwO1xudmFyIHBhdGhUb0ZpbGVVUkwgPSByZXF1aXJlJCQyLnBhdGhUb0ZpbGVVUkw7XG52YXIgSW5wdXQkMyA9IGlucHV0O1xudmFyIHNvdXJjZU1hcEF2YWlsYWJsZSA9IEJvb2xlYW4oU291cmNlTWFwQ29uc3VtZXIgJiYgU291cmNlTWFwR2VuZXJhdG9yKTtcbnZhciBwYXRoQXZhaWxhYmxlID0gQm9vbGVhbihkaXJuYW1lICYmIHJlc29sdmUkMyAmJiByZWxhdGl2ZSAmJiBzZXApO1xudmFyIE1hcEdlbmVyYXRvciQyID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBNYXBHZW5lcmF0b3IyKHN0cmluZ2lmeTIsIHJvb3QyLCBvcHRzLCBjc3NTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zdHJpbmdpZnkgPSBzdHJpbmdpZnkyO1xuICAgICAgICB0aGlzLm1hcE9wdHMgPSBvcHRzLm1hcCB8fCB7fTtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDI7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICAgIHRoaXMuY3NzID0gY3NzU3RyaW5nO1xuICAgICAgICB0aGlzLm9yaWdpbmFsQ1NTID0gY3NzU3RyaW5nO1xuICAgICAgICB0aGlzLnVzZXNGaWxlVXJscyA9ICF0aGlzLm1hcE9wdHMuZnJvbSAmJiB0aGlzLm1hcE9wdHMuYWJzb2x1dGU7XG4gICAgICAgIHRoaXMubWVtb2l6ZWRGaWxlVVJMcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubWVtb2l6ZWRQYXRocyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubWVtb2l6ZWRVUkxzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IE1hcEdlbmVyYXRvcjIucHJvdG90eXBlO1xuICAgIF9wcm90by5hZGRBbm5vdGF0aW9uID0gZnVuY3Rpb24gYWRkQW5ub3RhdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQ7XG4gICAgICAgIGlmICh0aGlzLmlzSW5saW5lKCkpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBcImRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyB0aGlzLnRvQmFzZTY0KHRoaXMubWFwLnRvU3RyaW5nKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29udGVudCA9IHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gdGhpcy5tYXBPcHRzLmFubm90YXRpb24odGhpcy5vcHRzLnRvLCB0aGlzLnJvb3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGVudCA9IHRoaXMub3V0cHV0RmlsZSgpICsgXCIubWFwXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVvbCA9IFwiXFxuXCI7XG4gICAgICAgIGlmICh0aGlzLmNzcy5pbmNsdWRlcyhcIlxcclxcblwiKSkgZW9sID0gXCJcXHJcXG5cIjtcbiAgICAgICAgdGhpcy5jc3MgKz0gZW9sICsgXCIvKiMgc291cmNlTWFwcGluZ1VSTD1cIiArIGNvbnRlbnQgKyBcIiAqL1wiO1xuICAgIH07XG4gICAgX3Byb3RvLmFwcGx5UHJldk1hcHMgPSBmdW5jdGlvbiBhcHBseVByZXZNYXBzKCkge1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZSh0aGlzLnByZXZpb3VzKCkpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgcHJldiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGZyb20gPSB0aGlzLnRvVXJsKHRoaXMucGF0aChwcmV2LmZpbGUpKTtcbiAgICAgICAgICAgIHZhciByb290MiA9IHByZXYucm9vdCB8fCBkaXJuYW1lKHByZXYuZmlsZSk7XG4gICAgICAgICAgICB2YXIgbWFwID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKHRoaXMubWFwT3B0cy5zb3VyY2VzQ29udGVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBtYXAgPSBuZXcgU291cmNlTWFwQ29uc3VtZXIocHJldi50ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAobWFwLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcC5zb3VyY2VzQ29udGVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXAgPSBwcmV2LmNvbnN1bWVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1hcC5hcHBseVNvdXJjZU1hcChtYXAsIGZyb20sIHRoaXMudG9VcmwodGhpcy5wYXRoKHJvb3QyKSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uY2xlYXJBbm5vdGF0aW9uID0gZnVuY3Rpb24gY2xlYXJBbm5vdGF0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5tYXBPcHRzLmFubm90YXRpb24gPT09IGZhbHNlKSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgIHZhciBub2RlMjtcbiAgICAgICAgICAgIGZvcih2YXIgaTIgPSB0aGlzLnJvb3Qubm9kZXMubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSl7XG4gICAgICAgICAgICAgICAgbm9kZTIgPSB0aGlzLnJvb3Qubm9kZXNbaTJdO1xuICAgICAgICAgICAgICAgIGlmIChub2RlMi50eXBlICE9PSBcImNvbW1lbnRcIikgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUyLnRleHQuaW5kZXhPZihcIiMgc291cmNlTWFwcGluZ1VSTD1cIikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290LnJlbW92ZUNoaWxkKGkyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jc3MpIHtcbiAgICAgICAgICAgIHRoaXMuY3NzID0gdGhpcy5jc3MucmVwbGFjZSgvXFxuKj9cXC9cXCojW1xcU1xcc10qP1xcKlxcLyQvZ20sIFwiXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZ2VuZXJhdGUgPSBmdW5jdGlvbiBnZW5lcmF0ZSgpIHtcbiAgICAgICAgdGhpcy5jbGVhckFubm90YXRpb24oKTtcbiAgICAgICAgaWYgKHBhdGhBdmFpbGFibGUgJiYgc291cmNlTWFwQXZhaWxhYmxlICYmIHRoaXMuaXNNYXAoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVNYXAoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQyID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuc3RyaW5naWZ5KHRoaXMucm9vdCwgZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyICs9IGkyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHJlc3VsdDJcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5nZW5lcmF0ZU1hcCA9IGZ1bmN0aW9uIGdlbmVyYXRlTWFwKCkge1xuICAgICAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2aW91cygpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdmFyIHByZXYgPSB0aGlzLnByZXZpb3VzKClbMF0uY29uc3VtZXIoKTtcbiAgICAgICAgICAgIHByZXYuZmlsZSA9IHRoaXMub3V0cHV0RmlsZSgpO1xuICAgICAgICAgICAgdGhpcy5tYXAgPSBTb3VyY2VNYXBHZW5lcmF0b3IuZnJvbVNvdXJjZU1hcChwcmV2LCB7XG4gICAgICAgICAgICAgICAgaWdub3JlSW52YWxpZE1hcHBpbmc6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYXAgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKHtcbiAgICAgICAgICAgICAgICBmaWxlOiB0aGlzLm91dHB1dEZpbGUoKSxcbiAgICAgICAgICAgICAgICBpZ25vcmVJbnZhbGlkTWFwcGluZzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLm1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiAwLFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiAxXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IDAsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IDFcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcy5vcHRzLmZyb20gPyB0aGlzLnRvVXJsKHRoaXMucGF0aCh0aGlzLm9wdHMuZnJvbSkpIDogXCI8bm8gc291cmNlPlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1NvdXJjZXNDb250ZW50KCkpIHRoaXMuc2V0U291cmNlc0NvbnRlbnQoKTtcbiAgICAgICAgaWYgKHRoaXMucm9vdCAmJiB0aGlzLnByZXZpb3VzKCkubGVuZ3RoID4gMCkgdGhpcy5hcHBseVByZXZNYXBzKCk7XG4gICAgICAgIGlmICh0aGlzLmlzQW5ub3RhdGlvbigpKSB0aGlzLmFkZEFubm90YXRpb24oKTtcbiAgICAgICAgaWYgKHRoaXMuaXNJbmxpbmUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB0aGlzLmNzc1xuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgdGhpcy5jc3MsXG4gICAgICAgICAgICAgICAgdGhpcy5tYXBcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5nZW5lcmF0ZVN0cmluZyA9IGZ1bmN0aW9uIGdlbmVyYXRlU3RyaW5nKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNzcyA9IFwiXCI7XG4gICAgICAgIHRoaXMubWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcih7XG4gICAgICAgICAgICBmaWxlOiB0aGlzLm91dHB1dEZpbGUoKSxcbiAgICAgICAgICAgIGlnbm9yZUludmFsaWRNYXBwaW5nOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbGluZSA9IDE7XG4gICAgICAgIHZhciBjb2x1bW4gPSAxO1xuICAgICAgICB2YXIgbm9Tb3VyY2UgPSBcIjxubyBzb3VyY2U+XCI7XG4gICAgICAgIHZhciBtYXBwaW5nID0ge1xuICAgICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiAwLFxuICAgICAgICAgICAgICAgIGxpbmU6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgICAgIGNvbHVtbjogMCxcbiAgICAgICAgICAgICAgICBsaW5lOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc291cmNlOiBcIlwiXG4gICAgICAgIH07XG4gICAgICAgIHZhciBsaW5lcywgbGFzdDtcbiAgICAgICAgdGhpcy5zdHJpbmdpZnkodGhpcy5yb290LCBmdW5jdGlvbihzdHIsIG5vZGUyLCB0eXBlKSB7XG4gICAgICAgICAgICBfdGhpcy5jc3MgKz0gc3RyO1xuICAgICAgICAgICAgaWYgKG5vZGUyICYmIHR5cGUgIT09IFwiZW5kXCIpIHtcbiAgICAgICAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZC5saW5lID0gbGluZTtcbiAgICAgICAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZC5jb2x1bW4gPSBjb2x1bW4gLSAxO1xuICAgICAgICAgICAgICAgIGlmIChub2RlMi5zb3VyY2UgJiYgbm9kZTIuc291cmNlLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gX3RoaXMuc291cmNlUGF0aChub2RlMik7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwubGluZSA9IG5vZGUyLnNvdXJjZS5zdGFydC5saW5lO1xuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmNvbHVtbiA9IG5vZGUyLnNvdXJjZS5zdGFydC5jb2x1bW4gLSAxO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXAuYWRkTWFwcGluZyhtYXBwaW5nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IG5vU291cmNlO1xuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmxpbmUgPSAxO1xuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmNvbHVtbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm1hcC5hZGRNYXBwaW5nKG1hcHBpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmVzID0gc3RyLm1hdGNoKC9cXG4vZyk7XG4gICAgICAgICAgICBpZiAobGluZXMpIHtcbiAgICAgICAgICAgICAgICBsaW5lICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsYXN0ID0gc3RyLmxhc3RJbmRleE9mKFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IHN0ci5sZW5ndGggLSBsYXN0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4gKz0gc3RyLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlMiAmJiB0eXBlICE9PSBcInN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IG5vZGUyLnBhcmVudCB8fCB7XG4gICAgICAgICAgICAgICAgICAgIHJhd3M6IHt9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRsZXNzID0gbm9kZTIudHlwZSA9PT0gXCJkZWNsXCIgfHwgbm9kZTIudHlwZSA9PT0gXCJhdHJ1bGVcIiAmJiAhbm9kZTIubm9kZXM7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZGxlc3MgfHwgbm9kZTIgIT09IHAubGFzdCB8fCBwLnJhd3Muc2VtaWNvbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlMi5zb3VyY2UgJiYgbm9kZTIuc291cmNlLmVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBfdGhpcy5zb3VyY2VQYXRoKG5vZGUyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwubGluZSA9IG5vZGUyLnNvdXJjZS5lbmQubGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwuY29sdW1uID0gbm9kZTIuc291cmNlLmVuZC5jb2x1bW4gLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQubGluZSA9IGxpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZC5jb2x1bW4gPSBjb2x1bW4gLSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubWFwLmFkZE1hcHBpbmcobWFwcGluZyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IG5vU291cmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5saW5lID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwuY29sdW1uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmxpbmUgPSBsaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQuY29sdW1uID0gY29sdW1uIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm1hcC5hZGRNYXBwaW5nKG1hcHBpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5pc0Fubm90YXRpb24gPSBmdW5jdGlvbiBpc0Fubm90YXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmlzSW5saW5lKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLmFubm90YXRpb24gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcmV2aW91cygpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXMoKS5zb21lKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkyLmFubm90YXRpb247XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIF9wcm90by5pc0lubGluZSA9IGZ1bmN0aW9uIGlzSW5saW5lKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5pbmxpbmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcE9wdHMuaW5saW5lO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbm5vdGF0aW9uID0gdGhpcy5tYXBPcHRzLmFubm90YXRpb247XG4gICAgICAgIGlmICh0eXBlb2YgYW5ub3RhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhbm5vdGF0aW9uICE9PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJldmlvdXMoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzKCkuc29tZShmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpMi5pbmxpbmU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIF9wcm90by5pc01hcCA9IGZ1bmN0aW9uIGlzTWFwKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0cy5tYXAgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMub3B0cy5tYXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXMoKS5sZW5ndGggPiAwO1xuICAgIH07XG4gICAgX3Byb3RvLmlzU291cmNlc0NvbnRlbnQgPSBmdW5jdGlvbiBpc1NvdXJjZXNDb250ZW50KCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5zb3VyY2VzQ29udGVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwT3B0cy5zb3VyY2VzQ29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcmV2aW91cygpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXMoKS5zb21lKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkyLndpdGhDb250ZW50KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIF9wcm90by5vdXRwdXRGaWxlID0gZnVuY3Rpb24gb3V0cHV0RmlsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0cy50bykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGF0aCh0aGlzLm9wdHMudG8pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0cy5mcm9tKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXRoKHRoaXMub3B0cy5mcm9tKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcInRvLmNzc1wiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ucGF0aCA9IGZ1bmN0aW9uIHBhdGgoZmlsZSkge1xuICAgICAgICBpZiAodGhpcy5tYXBPcHRzLmFic29sdXRlKSByZXR1cm4gZmlsZTtcbiAgICAgICAgaWYgKGZpbGUuY2hhckNvZGVBdCgwKSA9PT0gNjApIHJldHVybiBmaWxlO1xuICAgICAgICBpZiAoL15cXHcrOlxcL1xcLy8udGVzdChmaWxlKSkgcmV0dXJuIGZpbGU7XG4gICAgICAgIHZhciBjYWNoZWQgPSB0aGlzLm1lbW9pemVkUGF0aHMuZ2V0KGZpbGUpO1xuICAgICAgICBpZiAoY2FjaGVkKSByZXR1cm4gY2FjaGVkO1xuICAgICAgICB2YXIgZnJvbSA9IHRoaXMub3B0cy50byA/IGRpcm5hbWUodGhpcy5vcHRzLnRvKSA6IFwiLlwiO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBmcm9tID0gZGlybmFtZShyZXNvbHZlJDMoZnJvbSwgdGhpcy5tYXBPcHRzLmFubm90YXRpb24pKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGF0aCA9IHJlbGF0aXZlKGZyb20sIGZpbGUpO1xuICAgICAgICB0aGlzLm1lbW9pemVkUGF0aHMuc2V0KGZpbGUsIHBhdGgpO1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9O1xuICAgIF9wcm90by5wcmV2aW91cyA9IGZ1bmN0aW9uIHByZXZpb3VzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMucHJldmlvdXNNYXBzKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzTWFwcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgICAgICAgICAgIHRoaXMucm9vdC53YWxrKGZ1bmN0aW9uKG5vZGUyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlMi5zb3VyY2UgJiYgbm9kZTIuc291cmNlLmlucHV0Lm1hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hcCA9IG5vZGUyLnNvdXJjZS5pbnB1dC5tYXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnByZXZpb3VzTWFwcy5pbmNsdWRlcyhtYXApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJldmlvdXNNYXBzLnB1c2gobWFwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQyID0gbmV3IElucHV0JDModGhpcy5vcmlnaW5hbENTUywgdGhpcy5vcHRzKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQyLm1hcCkgdGhpcy5wcmV2aW91c01hcHMucHVzaChpbnB1dDIubWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91c01hcHM7XG4gICAgfTtcbiAgICBfcHJvdG8uc2V0U291cmNlc0NvbnRlbnQgPSBmdW5jdGlvbiBzZXRTb3VyY2VzQ29udGVudCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFscmVhZHkgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgICAgICAgdGhpcy5yb290LndhbGsoZnVuY3Rpb24obm9kZTIpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZTIuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmcm9tID0gbm9kZTIuc291cmNlLmlucHV0LmZyb207XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcm9tICYmICFhbHJlYWR5W2Zyb21dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHJlYWR5W2Zyb21dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcm9tVXJsID0gX3RoaXMudXNlc0ZpbGVVcmxzID8gX3RoaXMudG9GaWxlVXJsKGZyb20pIDogX3RoaXMudG9VcmwoX3RoaXMucGF0aChmcm9tKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXAuc2V0U291cmNlQ29udGVudChmcm9tVXJsLCBub2RlMi5zb3VyY2UuaW5wdXQuY3NzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY3NzKSB7XG4gICAgICAgICAgICB2YXIgZnJvbSA9IHRoaXMub3B0cy5mcm9tID8gdGhpcy50b1VybCh0aGlzLnBhdGgodGhpcy5vcHRzLmZyb20pKSA6IFwiPG5vIHNvdXJjZT5cIjtcbiAgICAgICAgICAgIHRoaXMubWFwLnNldFNvdXJjZUNvbnRlbnQoZnJvbSwgdGhpcy5jc3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uc291cmNlUGF0aCA9IGZ1bmN0aW9uIHNvdXJjZVBhdGgobm9kZTIpIHtcbiAgICAgICAgaWYgKHRoaXMubWFwT3B0cy5mcm9tKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b1VybCh0aGlzLm1hcE9wdHMuZnJvbSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy51c2VzRmlsZVVybHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvRmlsZVVybChub2RlMi5zb3VyY2UuaW5wdXQuZnJvbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b1VybCh0aGlzLnBhdGgobm9kZTIuc291cmNlLmlucHV0LmZyb20pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnRvQmFzZTY0ID0gZnVuY3Rpb24gdG9CYXNlNjQoc3RyKSB7XG4gICAgICAgIGlmIChCdWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5idG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by50b0ZpbGVVcmwgPSBmdW5jdGlvbiB0b0ZpbGVVcmwocGF0aCkge1xuICAgICAgICB2YXIgY2FjaGVkID0gdGhpcy5tZW1vaXplZEZpbGVVUkxzLmdldChwYXRoKTtcbiAgICAgICAgaWYgKGNhY2hlZCkgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgaWYgKHBhdGhUb0ZpbGVVUkwpIHtcbiAgICAgICAgICAgIHZhciBmaWxlVVJMID0gcGF0aFRvRmlsZVVSTChwYXRoKS50b1N0cmluZygpO1xuICAgICAgICAgICAgdGhpcy5tZW1vaXplZEZpbGVVUkxzLnNldChwYXRoLCBmaWxlVVJMKTtcbiAgICAgICAgICAgIHJldHVybiBmaWxlVVJMO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYG1hcC5hYnNvbHV0ZWAgb3B0aW9uIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBQb3N0Q1NTIGJ1aWxkXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8udG9VcmwgPSBmdW5jdGlvbiB0b1VybChwYXRoKSB7XG4gICAgICAgIHZhciBjYWNoZWQgPSB0aGlzLm1lbW9pemVkVVJMcy5nZXQocGF0aCk7XG4gICAgICAgIGlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIGlmIChzZXAgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXJsID0gZW5jb2RlVVJJKHBhdGgpLnJlcGxhY2UoL1sjP10vZywgZW5jb2RlVVJJQ29tcG9uZW50KTtcbiAgICAgICAgdGhpcy5tZW1vaXplZFVSTHMuc2V0KHBhdGgsIHVybCk7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfTtcbiAgICByZXR1cm4gTWFwR2VuZXJhdG9yMjtcbn0oKTtcbnZhciBtYXBHZW5lcmF0b3IgPSBNYXBHZW5lcmF0b3IkMjtcbnZhciBOb2RlJDIgPSBub2RlO1xudmFyIENvbW1lbnQkNCA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oTm9kZSQyKSB7XG4gICAgX2luaGVyaXRzKENvbW1lbnQyLCBOb2RlJDIpO1xuICAgIGZ1bmN0aW9uIENvbW1lbnQyKGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgX3RoaXMgPSBOb2RlJDIuY2FsbCh0aGlzLCBkZWZhdWx0cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9IFwiY29tbWVudFwiO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb21tZW50Mjtcbn0oTm9kZSQyKTtcbnZhciBjb21tZW50ID0gQ29tbWVudCQ0O1xuQ29tbWVudCQ0LmRlZmF1bHQgPSBDb21tZW50JDQ7XG52YXIgaXNDbGVhbiQxID0gc3ltYm9scy5pc0NsZWFuLCBteSQxID0gc3ltYm9scy5teTtcbnZhciBEZWNsYXJhdGlvbiQzID0gZGVjbGFyYXRpb247XG52YXIgQ29tbWVudCQzID0gY29tbWVudDtcbnZhciBOb2RlJDEgPSBub2RlO1xudmFyIHBhcnNlJDQsIFJ1bGUkNCwgQXRSdWxlJDQsIFJvb3QkNjtcbmZ1bmN0aW9uIGNsZWFuU291cmNlKG5vZGVzKSB7XG4gICAgcmV0dXJuIG5vZGVzLm1hcChmdW5jdGlvbihpMikge1xuICAgICAgICBpZiAoaTIubm9kZXMpIGkyLm5vZGVzID0gY2xlYW5Tb3VyY2UoaTIubm9kZXMpO1xuICAgICAgICBkZWxldGUgaTIuc291cmNlO1xuICAgICAgICByZXR1cm4gaTI7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBtYXJrRGlydHlVcChub2RlMikge1xuICAgIG5vZGUyW2lzQ2xlYW4kMV0gPSBmYWxzZTtcbiAgICBpZiAobm9kZTIucHJveHlPZi5ub2Rlcykge1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShub2RlMi5wcm94eU9mLm5vZGVzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIGkyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICBtYXJrRGlydHlVcChpMik7XG4gICAgICAgIH1cbiAgICB9XG59XG52YXIgQ29udGFpbmVyJDcgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKE5vZGUkMSkge1xuICAgIF9pbmhlcml0cyhDb250YWluZXIyLCBOb2RlJDEpO1xuICAgIGZ1bmN0aW9uIENvbnRhaW5lcjIoKSB7XG4gICAgICAgIHJldHVybiBOb2RlJDEuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gQ29udGFpbmVyMi5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZCgpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgY2hpbGRyZW4gPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIGNoaWxkcmVuW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKGNoaWxkcmVuKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vcm1hbGl6ZShjaGlsZCwgdGhpcy5sYXN0KTtcbiAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yMSA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShub2RlcyksIF9zdGVwMTsgIShfc3RlcDEgPSBfaXRlcmF0b3IxKCkpLmRvbmU7KXtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZTIgPSBfc3RlcDEudmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm94eU9mLm5vZGVzLnB1c2gobm9kZTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLmNsZWFuUmF3cyA9IGZ1bmN0aW9uIGNsZWFuUmF3cyhrZWVwQmV0d2Vlbikge1xuICAgICAgICBOb2RlJDEucHJvdG90eXBlLmNsZWFuUmF3cy5jYWxsKHRoaXMsIGtlZXBCZXR3ZWVuKTtcbiAgICAgICAgaWYgKHRoaXMubm9kZXMpIHtcbiAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHRoaXMubm9kZXMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgbm9kZTIuY2xlYW5SYXdzKGtlZXBCZXR3ZWVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmVhY2ggPSBmdW5jdGlvbiBlYWNoKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm94eU9mLm5vZGVzKSByZXR1cm4gdm9pZCAwO1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLmdldEl0ZXJhdG9yKCk7XG4gICAgICAgIHZhciBpbmRleDIsIHJlc3VsdDI7XG4gICAgICAgIHdoaWxlKHRoaXMuaW5kZXhlc1tpdGVyYXRvcl0gPCB0aGlzLnByb3h5T2Yubm9kZXMubGVuZ3RoKXtcbiAgICAgICAgICAgIGluZGV4MiA9IHRoaXMuaW5kZXhlc1tpdGVyYXRvcl07XG4gICAgICAgICAgICByZXN1bHQyID0gY2FsbGJhY2sodGhpcy5wcm94eU9mLm5vZGVzW2luZGV4Ml0sIGluZGV4Mik7XG4gICAgICAgICAgICBpZiAocmVzdWx0MiA9PT0gZmFsc2UpIGJyZWFrO1xuICAgICAgICAgICAgdGhpcy5pbmRleGVzW2l0ZXJhdG9yXSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLmluZGV4ZXNbaXRlcmF0b3JdO1xuICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICB9O1xuICAgIF9wcm90by5ldmVyeSA9IGZ1bmN0aW9uIGV2ZXJ5KGNvbmRpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5ldmVyeShjb25kaXRpb24pO1xuICAgIH07XG4gICAgX3Byb3RvLmdldEl0ZXJhdG9yID0gZnVuY3Rpb24gZ2V0SXRlcmF0b3IoKSB7XG4gICAgICAgIGlmICghdGhpcy5sYXN0RWFjaCkgdGhpcy5sYXN0RWFjaCA9IDA7XG4gICAgICAgIGlmICghdGhpcy5pbmRleGVzKSB0aGlzLmluZGV4ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5sYXN0RWFjaCArPSAxO1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLmxhc3RFYWNoO1xuICAgICAgICB0aGlzLmluZGV4ZXNbaXRlcmF0b3JdID0gMDtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgIH07XG4gICAgX3Byb3RvLmdldFByb3h5UHJvY2Vzc29yID0gZnVuY3Rpb24gZ2V0UHJveHlQcm9jZXNzb3IoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldChub2RlMiwgcHJvcCkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSBcInByb3h5T2ZcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghbm9kZTJbcHJvcF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUyW3Byb3BdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJlYWNoXCIgfHwgdHlwZW9mIHByb3AgPT09IFwic3RyaW5nXCIgJiYgcHJvcC5zdGFydHNXaXRoKFwid2Fsa1wiKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfbm9kZTI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9ub2RlMiA9IG5vZGUyKVtwcm9wXS5hcHBseShfbm9kZTIsIFtdLmNvbmNhdChhcmdzLm1hcChmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oY2hpbGQsIGluZGV4Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkyKGNoaWxkLnRvUHJveHkoKSwgaW5kZXgyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09IFwiZXZlcnlcIiB8fCBwcm9wID09PSBcInNvbWVcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlMltwcm9wXShmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG90aGVyID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlcltfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYi5hcHBseSh2b2lkIDAsIFtdLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnRvUHJveHkoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sIG90aGVyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlMi5yb290KCkudG9Qcm94eSgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJub2Rlc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlMi5ub2Rlcy5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpMi50b1Byb3h5KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJmaXJzdFwiIHx8IHByb3AgPT09IFwibGFzdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlMltwcm9wXS50b1Byb3h5KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUyW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChub2RlMiwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZTJbcHJvcF0gPT09IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBub2RlMltwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSBcIm5hbWVcIiB8fCBwcm9wID09PSBcInBhcmFtc1wiIHx8IHByb3AgPT09IFwic2VsZWN0b3JcIikge1xuICAgICAgICAgICAgICAgICAgICBub2RlMi5tYXJrRGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8uaW5kZXggPSBmdW5jdGlvbiBpbmRleChjaGlsZCkge1xuICAgICAgICBpZiAodHlwZW9mIGNoaWxkID09PSBcIm51bWJlclwiKSByZXR1cm4gY2hpbGQ7XG4gICAgICAgIGlmIChjaGlsZC5wcm94eU9mKSBjaGlsZCA9IGNoaWxkLnByb3h5T2Y7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3h5T2Yubm9kZXMuaW5kZXhPZihjaGlsZCk7XG4gICAgfTtcbiAgICBfcHJvdG8uaW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbiBpbnNlcnRBZnRlcihleGlzdCwgYWRkKSB7XG4gICAgICAgIHZhciBleGlzdEluZGV4ID0gdGhpcy5pbmRleChleGlzdCk7XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMubm9ybWFsaXplKGFkZCwgdGhpcy5wcm94eU9mLm5vZGVzW2V4aXN0SW5kZXhdKS5yZXZlcnNlKCk7XG4gICAgICAgIGV4aXN0SW5kZXggPSB0aGlzLmluZGV4KGV4aXN0KTtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uobm9kZXMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgbm9kZTIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMucHJveHlPZi5ub2Rlcy5zcGxpY2UoZXhpc3RJbmRleCArIDEsIDAsIG5vZGUyKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXgyO1xuICAgICAgICBmb3IodmFyIGlkIGluIHRoaXMuaW5kZXhlcyl7XG4gICAgICAgICAgICBpbmRleDIgPSB0aGlzLmluZGV4ZXNbaWRdO1xuICAgICAgICAgICAgaWYgKGV4aXN0SW5kZXggPCBpbmRleDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4ZXNbaWRdID0gaW5kZXgyICsgbm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIGluc2VydEJlZm9yZShleGlzdCwgYWRkKSB7XG4gICAgICAgIHZhciBleGlzdEluZGV4ID0gdGhpcy5pbmRleChleGlzdCk7XG4gICAgICAgIHZhciB0eXBlID0gZXhpc3RJbmRleCA9PT0gMCA/IFwicHJlcGVuZFwiIDogZmFsc2U7XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMubm9ybWFsaXplKGFkZCwgdGhpcy5wcm94eU9mLm5vZGVzW2V4aXN0SW5kZXhdLCB0eXBlKS5yZXZlcnNlKCk7XG4gICAgICAgIGV4aXN0SW5kZXggPSB0aGlzLmluZGV4KGV4aXN0KTtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uobm9kZXMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgbm9kZTIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMucHJveHlPZi5ub2Rlcy5zcGxpY2UoZXhpc3RJbmRleCwgMCwgbm9kZTIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleDI7XG4gICAgICAgIGZvcih2YXIgaWQgaW4gdGhpcy5pbmRleGVzKXtcbiAgICAgICAgICAgIGluZGV4MiA9IHRoaXMuaW5kZXhlc1tpZF07XG4gICAgICAgICAgICBpZiAoZXhpc3RJbmRleCA8PSBpbmRleDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4ZXNbaWRdID0gaW5kZXgyICsgbm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShub2Rlcywgc2FtcGxlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG5vZGVzID0gY2xlYW5Tb3VyY2UocGFyc2UkNChub2Rlcykubm9kZXMpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbm9kZXMgPSBbXTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG5vZGVzKSkge1xuICAgICAgICAgICAgbm9kZXMgPSBub2Rlcy5zbGljZSgwKTtcbiAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKG5vZGVzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgIHZhciBpMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChpMi5wYXJlbnQpIGkyLnBhcmVudC5yZW1vdmVDaGlsZChpMiwgXCJpZ25vcmVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZXMudHlwZSA9PT0gXCJyb290XCIgJiYgdGhpcy50eXBlICE9PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgICAgIG5vZGVzID0gbm9kZXMubm9kZXMuc2xpY2UoMCk7XG4gICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvcjEgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uobm9kZXMpLCBfc3RlcDE7ICEoX3N0ZXAxID0gX2l0ZXJhdG9yMSgpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgdmFyIGkyMSA9IF9zdGVwMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaTIxLnBhcmVudCkgaTIxLnBhcmVudC5yZW1vdmVDaGlsZChpMjEsIFwiaWdub3JlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGVzLnR5cGUpIHtcbiAgICAgICAgICAgIG5vZGVzID0gW1xuICAgICAgICAgICAgICAgIG5vZGVzXG4gICAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGVzLnByb3ApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZXMudmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWx1ZSBmaWVsZCBpcyBtaXNzZWQgaW4gbm9kZSBjcmVhdGlvblwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGVzLnZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgbm9kZXMudmFsdWUgPSBTdHJpbmcobm9kZXMudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZXMgPSBbXG4gICAgICAgICAgICAgICAgbmV3IERlY2xhcmF0aW9uJDMobm9kZXMpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGVzLnNlbGVjdG9yKSB7XG4gICAgICAgICAgICBub2RlcyA9IFtcbiAgICAgICAgICAgICAgICBuZXcgUnVsZSQ0KG5vZGVzKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIGlmIChub2Rlcy5uYW1lKSB7XG4gICAgICAgICAgICBub2RlcyA9IFtcbiAgICAgICAgICAgICAgICBuZXcgQXRSdWxlJDQobm9kZXMpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGVzLnRleHQpIHtcbiAgICAgICAgICAgIG5vZGVzID0gW1xuICAgICAgICAgICAgICAgIG5ldyBDb21tZW50JDMobm9kZXMpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBub2RlIHR5cGUgaW4gbm9kZSBjcmVhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvY2Vzc2VkID0gbm9kZXMubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICBpZiAoIWkyW215JDFdKSBDb250YWluZXIyLnJlYnVpbGQoaTIpO1xuICAgICAgICAgICAgaTIgPSBpMi5wcm94eU9mO1xuICAgICAgICAgICAgaWYgKGkyLnBhcmVudCkgaTIucGFyZW50LnJlbW92ZUNoaWxkKGkyKTtcbiAgICAgICAgICAgIGlmIChpMltpc0NsZWFuJDFdKSBtYXJrRGlydHlVcChpMik7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmVmb3JlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNhbXBsZSAmJiB0eXBlb2Ygc2FtcGxlLnJhd3MuYmVmb3JlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGkyLnJhd3MuYmVmb3JlID0gc2FtcGxlLnJhd3MuYmVmb3JlLnJlcGxhY2UoL1xcUy9nLCBcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpMi5wYXJlbnQgPSBfdGhpcy5wcm94eU9mO1xuICAgICAgICAgICAgcmV0dXJuIGkyO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZDtcbiAgICB9O1xuICAgIF9wcm90by5wcmVwZW5kID0gZnVuY3Rpb24gcHJlcGVuZCgpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgY2hpbGRyZW4gPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIGNoaWxkcmVuW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW4ucmV2ZXJzZSgpO1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShjaGlsZHJlbiksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub3JtYWxpemUoY2hpbGQsIHRoaXMuZmlyc3QsIFwicHJlcGVuZFwiKS5yZXZlcnNlKCk7XG4gICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvcjEgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uobm9kZXMpLCBfc3RlcDE7ICEoX3N0ZXAxID0gX2l0ZXJhdG9yMSgpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUyID0gX3N0ZXAxLnZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMucHJveHlPZi5ub2Rlcy51bnNoaWZ0KG5vZGUyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcih2YXIgaWQgaW4gdGhpcy5pbmRleGVzKXtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4ZXNbaWRdID0gdGhpcy5pbmRleGVzW2lkXSArIG5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90by5wdXNoID0gZnVuY3Rpb24gcHVzaChjaGlsZCkge1xuICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICB0aGlzLnByb3h5T2Yubm9kZXMucHVzaChjaGlsZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLnJlbW92ZUFsbCA9IGZ1bmN0aW9uIHJlbW92ZUFsbCgpIHtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UodGhpcy5wcm94eU9mLm5vZGVzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIG5vZGUyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICBub2RlMi5wYXJlbnQgPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm94eU9mLm5vZGVzID0gW107XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGQoY2hpbGQpIHtcbiAgICAgICAgY2hpbGQgPSB0aGlzLmluZGV4KGNoaWxkKTtcbiAgICAgICAgdGhpcy5wcm94eU9mLm5vZGVzW2NoaWxkXS5wYXJlbnQgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMucHJveHlPZi5ub2Rlcy5zcGxpY2UoY2hpbGQsIDEpO1xuICAgICAgICB2YXIgaW5kZXgyO1xuICAgICAgICBmb3IodmFyIGlkIGluIHRoaXMuaW5kZXhlcyl7XG4gICAgICAgICAgICBpbmRleDIgPSB0aGlzLmluZGV4ZXNbaWRdO1xuICAgICAgICAgICAgaWYgKGluZGV4MiA+PSBjaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhlc1tpZF0gPSBpbmRleDIgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLnJlcGxhY2VWYWx1ZXMgPSBmdW5jdGlvbiByZXBsYWNlVmFsdWVzKHBhdHRlcm4sIG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICAgICAgICAgIG9wdHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhbGtEZWNscyhmdW5jdGlvbihkZWNsKSB7XG4gICAgICAgICAgICBpZiAob3B0cy5wcm9wcyAmJiAhb3B0cy5wcm9wcy5pbmNsdWRlcyhkZWNsLnByb3ApKSByZXR1cm47XG4gICAgICAgICAgICBpZiAob3B0cy5mYXN0ICYmICFkZWNsLnZhbHVlLmluY2x1ZGVzKG9wdHMuZmFzdCkpIHJldHVybjtcbiAgICAgICAgICAgIGRlY2wudmFsdWUgPSBkZWNsLnZhbHVlLnJlcGxhY2UocGF0dGVybiwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8uc29tZSA9IGZ1bmN0aW9uIHNvbWUoY29uZGl0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLnNvbWUoY29uZGl0aW9uKTtcbiAgICB9O1xuICAgIF9wcm90by53YWxrID0gZnVuY3Rpb24gd2FsayhjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGNoaWxkLCBpMikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDI7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjaGlsZC5hZGRUb0Vycm9yKGUyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBmYWxzZSAmJiBjaGlsZC53YWxrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MiA9IGNoaWxkLndhbGsoY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLndhbGtBdFJ1bGVzID0gZnVuY3Rpb24gd2Fsa0F0UnVsZXMobmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBuYW1lO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJhdHJ1bGVcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2luc3RhbmNlb2YobmFtZSwgUmVnRXhwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJhdHJ1bGVcIiAmJiBuYW1lLnRlc3QoY2hpbGQubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImF0cnVsZVwiICYmIGNoaWxkLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8ud2Fsa0NvbW1lbnRzID0gZnVuY3Rpb24gd2Fsa0NvbW1lbnRzKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJjb21tZW50XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8ud2Fsa0RlY2xzID0gZnVuY3Rpb24gd2Fsa0RlY2xzKHByb3AsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gcHJvcDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfaW5zdGFuY2VvZihwcm9wLCBSZWdFeHApKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53YWxrKGZ1bmN0aW9uKGNoaWxkLCBpMikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImRlY2xcIiAmJiBwcm9wLnRlc3QoY2hpbGQucHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImRlY2xcIiAmJiBjaGlsZC5wcm9wID09PSBwcm9wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLndhbGtSdWxlcyA9IGZ1bmN0aW9uIHdhbGtSdWxlcyhzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBzZWxlY3RvcjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwicnVsZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfaW5zdGFuY2VvZihzZWxlY3RvciwgUmVnRXhwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJydWxlXCIgJiYgc2VsZWN0b3IudGVzdChjaGlsZC5zZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcInJ1bGVcIiAmJiBjaGlsZC5zZWxlY3RvciA9PT0gc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfY3JlYXRlX2NsYXNzKENvbnRhaW5lcjIsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZpcnN0XCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHJveHlPZi5ub2RlcykgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm94eU9mLm5vZGVzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwibGFzdFwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByb3h5T2Yubm9kZXMpIHJldHVybiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJveHlPZi5ub2Rlc1t0aGlzLnByb3h5T2Yubm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gQ29udGFpbmVyMjtcbn0oTm9kZSQxKTtcbkNvbnRhaW5lciQ3LnJlZ2lzdGVyUGFyc2UgPSBmdW5jdGlvbihkZXBlbmRhbnQpIHtcbiAgICBwYXJzZSQ0ID0gZGVwZW5kYW50O1xufTtcbkNvbnRhaW5lciQ3LnJlZ2lzdGVyUnVsZSA9IGZ1bmN0aW9uKGRlcGVuZGFudCkge1xuICAgIFJ1bGUkNCA9IGRlcGVuZGFudDtcbn07XG5Db250YWluZXIkNy5yZWdpc3RlckF0UnVsZSA9IGZ1bmN0aW9uKGRlcGVuZGFudCkge1xuICAgIEF0UnVsZSQ0ID0gZGVwZW5kYW50O1xufTtcbkNvbnRhaW5lciQ3LnJlZ2lzdGVyUm9vdCA9IGZ1bmN0aW9uKGRlcGVuZGFudCkge1xuICAgIFJvb3QkNiA9IGRlcGVuZGFudDtcbn07XG52YXIgY29udGFpbmVyID0gQ29udGFpbmVyJDc7XG5Db250YWluZXIkNy5kZWZhdWx0ID0gQ29udGFpbmVyJDc7XG5Db250YWluZXIkNy5yZWJ1aWxkID0gZnVuY3Rpb24obm9kZTIpIHtcbiAgICBpZiAobm9kZTIudHlwZSA9PT0gXCJhdHJ1bGVcIikge1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZTIsIEF0UnVsZSQ0LnByb3RvdHlwZSk7XG4gICAgfSBlbHNlIGlmIChub2RlMi50eXBlID09PSBcInJ1bGVcIikge1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZTIsIFJ1bGUkNC5wcm90b3R5cGUpO1xuICAgIH0gZWxzZSBpZiAobm9kZTIudHlwZSA9PT0gXCJkZWNsXCIpIHtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5vZGUyLCBEZWNsYXJhdGlvbiQzLnByb3RvdHlwZSk7XG4gICAgfSBlbHNlIGlmIChub2RlMi50eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZTIsIENvbW1lbnQkMy5wcm90b3R5cGUpO1xuICAgIH0gZWxzZSBpZiAobm9kZTIudHlwZSA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5vZGUyLCBSb290JDYucHJvdG90eXBlKTtcbiAgICB9XG4gICAgbm9kZTJbbXkkMV0gPSB0cnVlO1xuICAgIGlmIChub2RlMi5ub2Rlcykge1xuICAgICAgICBub2RlMi5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICBDb250YWluZXIkNy5yZWJ1aWxkKGNoaWxkKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbnZhciBDb250YWluZXIkNiA9IGNvbnRhaW5lcjtcbnZhciBMYXp5UmVzdWx0JDQsIFByb2Nlc3NvciQzO1xudmFyIERvY3VtZW50JDMgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKENvbnRhaW5lciQ2KSB7XG4gICAgX2luaGVyaXRzKERvY3VtZW50MjMsIENvbnRhaW5lciQ2KTtcbiAgICBmdW5jdGlvbiBEb2N1bWVudDIzKGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgX3RoaXMgPSBDb250YWluZXIkNi5jYWxsKHRoaXMsIF9leHRlbmRzKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZG9jdW1lbnRcIlxuICAgICAgICB9LCBkZWZhdWx0cykpIHx8IHRoaXM7XG4gICAgICAgIGlmICghX3RoaXMubm9kZXMpIHtcbiAgICAgICAgICAgIF90aGlzLm5vZGVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gRG9jdW1lbnQyMy5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnRvUmVzdWx0ID0gZnVuY3Rpb24gdG9SZXN1bHQob3B0cykge1xuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSBvcHRzID0ge307XG4gICAgICAgIHZhciBsYXp5ID0gbmV3IExhenlSZXN1bHQkNChuZXcgUHJvY2Vzc29yJDMoKSwgdGhpcywgb3B0cyk7XG4gICAgICAgIHJldHVybiBsYXp5LnN0cmluZ2lmeSgpO1xuICAgIH07XG4gICAgcmV0dXJuIERvY3VtZW50MjM7XG59KENvbnRhaW5lciQ2KTtcbkRvY3VtZW50JDMucmVnaXN0ZXJMYXp5UmVzdWx0ID0gZnVuY3Rpb24oZGVwZW5kYW50KSB7XG4gICAgTGF6eVJlc3VsdCQ0ID0gZGVwZW5kYW50O1xufTtcbkRvY3VtZW50JDMucmVnaXN0ZXJQcm9jZXNzb3IgPSBmdW5jdGlvbihkZXBlbmRhbnQpIHtcbiAgICBQcm9jZXNzb3IkMyA9IGRlcGVuZGFudDtcbn07XG52YXIgZG9jdW1lbnQkMSQyID0gRG9jdW1lbnQkMztcbkRvY3VtZW50JDMuZGVmYXVsdCA9IERvY3VtZW50JDM7XG52YXIgcHJpbnRlZCA9IHt9O1xudmFyIHdhcm5PbmNlJDIgPSBmdW5jdGlvbiB3YXJuT25jZTIobWVzc2FnZSkge1xuICAgIGlmIChwcmludGVkW21lc3NhZ2VdKSByZXR1cm47XG4gICAgcHJpbnRlZFttZXNzYWdlXSA9IHRydWU7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgfVxufTtcbnZhciBXYXJuaW5nJDIgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFdhcm5pbmcyKHRleHQsIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgb3B0cyA9IHt9O1xuICAgICAgICB0aGlzLnR5cGUgPSBcIndhcm5pbmdcIjtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgaWYgKG9wdHMubm9kZSAmJiBvcHRzLm5vZGUuc291cmNlKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBvcHRzLm5vZGUucmFuZ2VCeShvcHRzKTtcbiAgICAgICAgICAgIHRoaXMubGluZSA9IHJhbmdlLnN0YXJ0LmxpbmU7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbiA9IHJhbmdlLnN0YXJ0LmNvbHVtbjtcbiAgICAgICAgICAgIHRoaXMuZW5kTGluZSA9IHJhbmdlLmVuZC5saW5lO1xuICAgICAgICAgICAgdGhpcy5lbmRDb2x1bW4gPSByYW5nZS5lbmQuY29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGZvcih2YXIgb3B0IGluIG9wdHMpdGhpc1tvcHRdID0gb3B0c1tvcHRdO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gV2FybmluZzIucHJvdG90eXBlO1xuICAgIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5ub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmVycm9yKHRoaXMudGV4dCwge1xuICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4LFxuICAgICAgICAgICAgICAgIHBsdWdpbjogdGhpcy5wbHVnaW4sXG4gICAgICAgICAgICAgICAgd29yZDogdGhpcy53b3JkXG4gICAgICAgICAgICB9KS5tZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBsdWdpbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGx1Z2luICsgXCI6IFwiICsgdGhpcy50ZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQ7XG4gICAgfTtcbiAgICByZXR1cm4gV2FybmluZzI7XG59KCk7XG52YXIgd2FybmluZyA9IFdhcm5pbmckMjtcbldhcm5pbmckMi5kZWZhdWx0ID0gV2FybmluZyQyO1xudmFyIFdhcm5pbmckMSA9IHdhcm5pbmc7XG52YXIgUmVzdWx0JDMgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFJlc3VsdDIocHJvY2Vzc29yMiwgcm9vdDIsIG9wdHMpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzb3IgPSBwcm9jZXNzb3IyO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzID0gW107XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3QyO1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgICB0aGlzLmNzcyA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5tYXAgPSB2b2lkIDA7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBSZXN1bHQyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3NzO1xuICAgIH07XG4gICAgX3Byb3RvLndhcm4gPSBmdW5jdGlvbiB3YXJuKHRleHQsIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgb3B0cyA9IHt9O1xuICAgICAgICBpZiAoIW9wdHMucGx1Z2luKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0UGx1Z2luICYmIHRoaXMubGFzdFBsdWdpbi5wb3N0Y3NzUGx1Z2luKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5wbHVnaW4gPSB0aGlzLmxhc3RQbHVnaW4ucG9zdGNzc1BsdWdpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgd2FybmluZzIgPSBuZXcgV2FybmluZyQxKHRleHQsIG9wdHMpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzLnB1c2god2FybmluZzIpO1xuICAgICAgICByZXR1cm4gd2FybmluZzI7XG4gICAgfTtcbiAgICBfcHJvdG8ud2FybmluZ3MgPSBmdW5jdGlvbiB3YXJuaW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXMuZmlsdGVyKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICByZXR1cm4gaTIudHlwZSA9PT0gXCJ3YXJuaW5nXCI7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX2NyZWF0ZV9jbGFzcyhSZXN1bHQyLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjb250ZW50XCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gUmVzdWx0Mjtcbn0oKTtcbnZhciByZXN1bHQgPSBSZXN1bHQkMztcblJlc3VsdCQzLmRlZmF1bHQgPSBSZXN1bHQkMztcbnZhciBTSU5HTEVfUVVPVEUgPSBcIidcIi5jaGFyQ29kZUF0KDApO1xudmFyIERPVUJMRV9RVU9URSA9ICdcIicuY2hhckNvZGVBdCgwKTtcbnZhciBCQUNLU0xBU0ggPSBcIlxcXFxcIi5jaGFyQ29kZUF0KDApO1xudmFyIFNMQVNIID0gXCIvXCIuY2hhckNvZGVBdCgwKTtcbnZhciBORVdMSU5FID0gXCJcXG5cIi5jaGFyQ29kZUF0KDApO1xudmFyIFNQQUNFID0gXCIgXCIuY2hhckNvZGVBdCgwKTtcbnZhciBGRUVEID0gXCJcXGZcIi5jaGFyQ29kZUF0KDApO1xudmFyIFRBQiA9IFwiXHRcIi5jaGFyQ29kZUF0KDApO1xudmFyIENSID0gXCJcXHJcIi5jaGFyQ29kZUF0KDApO1xudmFyIE9QRU5fU1FVQVJFID0gXCJbXCIuY2hhckNvZGVBdCgwKTtcbnZhciBDTE9TRV9TUVVBUkUgPSBcIl1cIi5jaGFyQ29kZUF0KDApO1xudmFyIE9QRU5fUEFSRU5USEVTRVMgPSBcIihcIi5jaGFyQ29kZUF0KDApO1xudmFyIENMT1NFX1BBUkVOVEhFU0VTID0gXCIpXCIuY2hhckNvZGVBdCgwKTtcbnZhciBPUEVOX0NVUkxZID0gXCJ7XCIuY2hhckNvZGVBdCgwKTtcbnZhciBDTE9TRV9DVVJMWSA9IFwifVwiLmNoYXJDb2RlQXQoMCk7XG52YXIgU0VNSUNPTE9OID0gXCI7XCIuY2hhckNvZGVBdCgwKTtcbnZhciBBU1RFUklTSyA9IFwiKlwiLmNoYXJDb2RlQXQoMCk7XG52YXIgQ09MT04gPSBcIjpcIi5jaGFyQ29kZUF0KDApO1xudmFyIEFUID0gXCJAXCIuY2hhckNvZGVBdCgwKTtcbnZhciBSRV9BVF9FTkQgPSAvW1xcdFxcblxcZlxcciBcIiMnKCkvO1tcXFxcXFxde31dL2c7XG52YXIgUkVfV09SRF9FTkQgPSAvW1xcdFxcblxcZlxcciAhXCIjJygpOjtAW1xcXFxcXF17fV18XFwvKD89XFwqKS9nO1xudmFyIFJFX0JBRF9CUkFDS0VUID0gLy5bXFxyXFxuXCInKC9cXFxcXS87XG52YXIgUkVfSEVYX0VTQ0FQRSA9IC9bXFxkYS1mXS9pO1xudmFyIHRva2VuaXplID0gZnVuY3Rpb24gdG9rZW5pemVyMihpbnB1dDIsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSBvcHRpb25zID0ge307XG4gICAgdmFyIGNzcyA9IGlucHV0Mi5jc3MudmFsdWVPZigpO1xuICAgIHZhciBpZ25vcmUgPSBvcHRpb25zLmlnbm9yZUVycm9ycztcbiAgICB2YXIgY29kZSwgbmV4dCwgcXVvdGUsIGNvbnRlbnQsIGVzY2FwZTtcbiAgICB2YXIgZXNjYXBlZCwgZXNjYXBlUG9zLCBwcmV2LCBuMiwgY3VycmVudFRva2VuO1xuICAgIHZhciBsZW5ndGggPSBjc3MubGVuZ3RoO1xuICAgIHZhciBwb3MgPSAwO1xuICAgIHZhciBidWZmZXIgPSBbXTtcbiAgICB2YXIgcmV0dXJuZWQgPSBbXTtcbiAgICBmdW5jdGlvbiBwb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5jbG9zZWQod2hhdCkge1xuICAgICAgICB0aHJvdyBpbnB1dDIuZXJyb3IoXCJVbmNsb3NlZCBcIiArIHdoYXQsIHBvcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuZE9mRmlsZSgpIHtcbiAgICAgICAgcmV0dXJuIHJldHVybmVkLmxlbmd0aCA9PT0gMCAmJiBwb3MgPj0gbGVuZ3RoO1xuICAgIH1cbiAgICBmdW5jdGlvbiBuZXh0VG9rZW4ob3B0cykge1xuICAgICAgICBpZiAocmV0dXJuZWQubGVuZ3RoKSByZXR1cm4gcmV0dXJuZWQucG9wKCk7XG4gICAgICAgIGlmIChwb3MgPj0gbGVuZ3RoKSByZXR1cm47XG4gICAgICAgIHZhciBpZ25vcmVVbmNsb3NlZCA9IG9wdHMgPyBvcHRzLmlnbm9yZVVuY2xvc2VkIDogZmFsc2U7XG4gICAgICAgIGNvZGUgPSBjc3MuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBzd2l0Y2goY29kZSl7XG4gICAgICAgICAgICBjYXNlIE5FV0xJTkU6XG4gICAgICAgICAgICBjYXNlIFNQQUNFOlxuICAgICAgICAgICAgY2FzZSBUQUI6XG4gICAgICAgICAgICBjYXNlIENSOlxuICAgICAgICAgICAgY2FzZSBGRUVEOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNzcy5jaGFyQ29kZUF0KG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB9d2hpbGUgKGNvZGUgPT09IFNQQUNFIHx8IGNvZGUgPT09IE5FV0xJTkUgfHwgY29kZSA9PT0gVEFCIHx8IGNvZGUgPT09IENSIHx8IGNvZGUgPT09IEZFRUQpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcInNwYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3Muc2xpY2UocG9zLCBuZXh0KVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBuZXh0IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBPUEVOX1NRVUFSRTpcbiAgICAgICAgICAgIGNhc2UgQ0xPU0VfU1FVQVJFOlxuICAgICAgICAgICAgY2FzZSBPUEVOX0NVUkxZOlxuICAgICAgICAgICAgY2FzZSBDTE9TRV9DVVJMWTpcbiAgICAgICAgICAgIGNhc2UgQ09MT046XG4gICAgICAgICAgICBjYXNlIFNFTUlDT0xPTjpcbiAgICAgICAgICAgIGNhc2UgQ0xPU0VfUEFSRU5USEVTRVM6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sQ2hhcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xDaGFyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgT1BFTl9QQVJFTlRIRVNFUzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHByZXYgPSBidWZmZXIubGVuZ3RoID8gYnVmZmVyLnBvcCgpWzFdIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgbjIgPSBjc3MuY2hhckNvZGVBdChwb3MgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXYgPT09IFwidXJsXCIgJiYgbjIgIT09IFNJTkdMRV9RVU9URSAmJiBuMiAhPT0gRE9VQkxFX1FVT1RFICYmIG4yICE9PSBTUEFDRSAmJiBuMiAhPT0gTkVXTElORSAmJiBuMiAhPT0gVEFCICYmIG4yICE9PSBGRUVEICYmIG4yICE9PSBDUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGNzcy5pbmRleE9mKFwiKVwiLCBuZXh0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZ25vcmUgfHwgaWdub3JlVW5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuY2xvc2VkKFwiYnJhY2tldFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVQb3MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKGNzcy5jaGFyQ29kZUF0KGVzY2FwZVBvcyAtIDEpID09PSBCQUNLU0xBU0gpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVQb3MgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH13aGlsZSAoZXNjYXBlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJicmFja2V0c1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gY3NzLmluZGV4T2YoXCIpXCIsIHBvcyArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IGNzcy5zbGljZShwb3MsIG5leHQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSAtMSB8fCBSRV9CQURfQlJBQ0tFVC50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIihcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJicmFja2V0c1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBTSU5HTEVfUVVPVEU6XG4gICAgICAgICAgICBjYXNlIERPVUJMRV9RVU9URTpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHF1b3RlID0gY29kZSA9PT0gU0lOR0xFX1FVT1RFID8gXCInXCIgOiAnXCInO1xuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gY3NzLmluZGV4T2YocXVvdGUsIG5leHQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZ25vcmUgfHwgaWdub3JlVW5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHBvcyArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuY2xvc2VkKFwic3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZVBvcyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZShjc3MuY2hhckNvZGVBdChlc2NhcGVQb3MgLSAxKSA9PT0gQkFDS1NMQVNIKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVQb3MgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH13aGlsZSAoZXNjYXBlZCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQVQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBSRV9BVF9FTkQubGFzdEluZGV4ID0gcG9zICsgMTtcbiAgICAgICAgICAgICAgICAgICAgUkVfQVRfRU5ELnRlc3QoY3NzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFJFX0FUX0VORC5sYXN0SW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBjc3MubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBSRV9BVF9FTkQubGFzdEluZGV4IC0gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcImF0LXdvcmRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBCQUNLU0xBU0g6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICBlc2NhcGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZShjc3MuY2hhckNvZGVBdChuZXh0ICsgMSkgPT09IEJBQ0tTTEFTSCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGUgPSAhZXNjYXBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjc3MuY2hhckNvZGVBdChuZXh0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlc2NhcGUgJiYgY29kZSAhPT0gU0xBU0ggJiYgY29kZSAhPT0gU1BBQ0UgJiYgY29kZSAhPT0gTkVXTElORSAmJiBjb2RlICE9PSBUQUIgJiYgY29kZSAhPT0gQ1IgJiYgY29kZSAhPT0gRkVFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFJFX0hFWF9FU0NBUEUudGVzdChjc3MuY2hhckF0KG5leHQpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKFJFX0hFWF9FU0NBUEUudGVzdChjc3MuY2hhckF0KG5leHQgKyAxKSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjc3MuY2hhckNvZGVBdChuZXh0ICsgMSkgPT09IFNQQUNFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ3b3JkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gU0xBU0ggJiYgY3NzLmNoYXJDb2RlQXQocG9zICsgMSkgPT09IEFTVEVSSVNLKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gY3NzLmluZGV4T2YoXCIqL1wiLCBwb3MgKyAyKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZ25vcmUgfHwgaWdub3JlVW5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGNzcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5jbG9zZWQoXCJjb21tZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbW1lbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgUkVfV09SRF9FTkQubGFzdEluZGV4ID0gcG9zICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJFX1dPUkRfRU5ELnRlc3QoY3NzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChSRV9XT1JEX0VORC5sYXN0SW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gY3NzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBSRV9XT1JEX0VORC5sYXN0SW5kZXggLSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid29yZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGN1cnJlbnRUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwb3MrKztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRUb2tlbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmFjayh0b2tlbikge1xuICAgICAgICByZXR1cm5lZC5wdXNoKHRva2VuKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmFjazogYmFjayxcbiAgICAgICAgZW5kT2ZGaWxlOiBlbmRPZkZpbGUsXG4gICAgICAgIG5leHRUb2tlbjogbmV4dFRva2VuLFxuICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgICB9O1xufTtcbnZhciBDb250YWluZXIkNSA9IGNvbnRhaW5lcjtcbnZhciBBdFJ1bGUkMyA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oQ29udGFpbmVyJDUpIHtcbiAgICBfaW5oZXJpdHMoQXRSdWxlMiwgQ29udGFpbmVyJDUpO1xuICAgIGZ1bmN0aW9uIEF0UnVsZTIoZGVmYXVsdHMpIHtcbiAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICBfdGhpcyA9IENvbnRhaW5lciQ1LmNhbGwodGhpcywgZGVmYXVsdHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSBcImF0cnVsZVwiO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBBdFJ1bGUyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBjaGlsZHJlbiA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgY2hpbGRyZW5bX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9Db250YWluZXIkNV9wcm90b3R5cGVfYXBwZW5kO1xuICAgICAgICBpZiAoIXRoaXMucHJveHlPZi5ub2RlcykgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICByZXR1cm4gKF9Db250YWluZXIkNV9wcm90b3R5cGVfYXBwZW5kID0gQ29udGFpbmVyJDUucHJvdG90eXBlLmFwcGVuZCkuY2FsbC5hcHBseShfQ29udGFpbmVyJDVfcHJvdG90eXBlX2FwcGVuZCwgW10uY29uY2F0KFtcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgXSwgY2hpbGRyZW4pKTtcbiAgICB9O1xuICAgIF9wcm90by5wcmVwZW5kID0gZnVuY3Rpb24gcHJlcGVuZCgpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgY2hpbGRyZW4gPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIGNoaWxkcmVuW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfQ29udGFpbmVyJDVfcHJvdG90eXBlX3ByZXBlbmQ7XG4gICAgICAgIGlmICghdGhpcy5wcm94eU9mLm5vZGVzKSB0aGlzLm5vZGVzID0gW107XG4gICAgICAgIHJldHVybiAoX0NvbnRhaW5lciQ1X3Byb3RvdHlwZV9wcmVwZW5kID0gQ29udGFpbmVyJDUucHJvdG90eXBlLnByZXBlbmQpLmNhbGwuYXBwbHkoX0NvbnRhaW5lciQ1X3Byb3RvdHlwZV9wcmVwZW5kLCBbXS5jb25jYXQoW1xuICAgICAgICAgICAgdGhpc1xuICAgICAgICBdLCBjaGlsZHJlbikpO1xuICAgIH07XG4gICAgcmV0dXJuIEF0UnVsZTI7XG59KENvbnRhaW5lciQ1KTtcbnZhciBhdFJ1bGUgPSBBdFJ1bGUkMztcbkF0UnVsZSQzLmRlZmF1bHQgPSBBdFJ1bGUkMztcbkNvbnRhaW5lciQ1LnJlZ2lzdGVyQXRSdWxlKEF0UnVsZSQzKTtcbnZhciBDb250YWluZXIkNCA9IGNvbnRhaW5lcjtcbnZhciBMYXp5UmVzdWx0JDMsIFByb2Nlc3NvciQyO1xudmFyIFJvb3QkNSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oQ29udGFpbmVyJDQpIHtcbiAgICBfaW5oZXJpdHMoUm9vdDIsIENvbnRhaW5lciQ0KTtcbiAgICBmdW5jdGlvbiBSb290MihkZWZhdWx0cykge1xuICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgIF90aGlzID0gQ29udGFpbmVyJDQuY2FsbCh0aGlzLCBkZWZhdWx0cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9IFwicm9vdFwiO1xuICAgICAgICBpZiAoIV90aGlzLm5vZGVzKSBfdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBSb290Mi5wcm90b3R5cGU7XG4gICAgX3Byb3RvLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShjaGlsZCwgc2FtcGxlLCB0eXBlKSB7XG4gICAgICAgIHZhciBub2RlcyA9IENvbnRhaW5lciQ0LnByb3RvdHlwZS5ub3JtYWxpemUuY2FsbCh0aGlzLCBjaGlsZCk7XG4gICAgICAgIGlmIChzYW1wbGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcInByZXBlbmRcIikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlLnJhd3MuYmVmb3JlID0gdGhpcy5ub2Rlc1sxXS5yYXdzLmJlZm9yZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2FtcGxlLnJhd3MuYmVmb3JlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5maXJzdCAhPT0gc2FtcGxlKSB7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uobm9kZXMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBub2RlMi5yYXdzLmJlZm9yZSA9IHNhbXBsZS5yYXdzLmJlZm9yZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH07XG4gICAgX3Byb3RvLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGQoY2hpbGQsIGlnbm9yZSkge1xuICAgICAgICB2YXIgaW5kZXgyID0gdGhpcy5pbmRleChjaGlsZCk7XG4gICAgICAgIGlmICghaWdub3JlICYmIGluZGV4MiA9PT0gMCAmJiB0aGlzLm5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZXNbMV0ucmF3cy5iZWZvcmUgPSB0aGlzLm5vZGVzW2luZGV4Ml0ucmF3cy5iZWZvcmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENvbnRhaW5lciQ0LnByb3RvdHlwZS5yZW1vdmVDaGlsZC5jYWxsKHRoaXMsIGNoaWxkKTtcbiAgICB9O1xuICAgIF9wcm90by50b1Jlc3VsdCA9IGZ1bmN0aW9uIHRvUmVzdWx0KG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgb3B0cyA9IHt9O1xuICAgICAgICB2YXIgbGF6eSA9IG5ldyBMYXp5UmVzdWx0JDMobmV3IFByb2Nlc3NvciQyKCksIHRoaXMsIG9wdHMpO1xuICAgICAgICByZXR1cm4gbGF6eS5zdHJpbmdpZnkoKTtcbiAgICB9O1xuICAgIHJldHVybiBSb290Mjtcbn0oQ29udGFpbmVyJDQpO1xuUm9vdCQ1LnJlZ2lzdGVyTGF6eVJlc3VsdCA9IGZ1bmN0aW9uKGRlcGVuZGFudCkge1xuICAgIExhenlSZXN1bHQkMyA9IGRlcGVuZGFudDtcbn07XG5Sb290JDUucmVnaXN0ZXJQcm9jZXNzb3IgPSBmdW5jdGlvbihkZXBlbmRhbnQpIHtcbiAgICBQcm9jZXNzb3IkMiA9IGRlcGVuZGFudDtcbn07XG52YXIgcm9vdCA9IFJvb3QkNTtcblJvb3QkNS5kZWZhdWx0ID0gUm9vdCQ1O1xuQ29udGFpbmVyJDQucmVnaXN0ZXJSb290KFJvb3QkNSk7XG52YXIgbGlzdCQyID0ge1xuICAgIGNvbW1hOiBmdW5jdGlvbiBjb21tYShzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGxpc3QkMi5zcGxpdChzdHJpbmcsIFtcbiAgICAgICAgICAgIFwiLFwiXG4gICAgICAgIF0sIHRydWUpO1xuICAgIH0sXG4gICAgc3BhY2U6IGZ1bmN0aW9uIHNwYWNlKHN0cmluZykge1xuICAgICAgICB2YXIgc3BhY2VzID0gW1xuICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICBcIlxcblwiLFxuICAgICAgICAgICAgXCJcdFwiXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBsaXN0JDIuc3BsaXQoc3RyaW5nLCBzcGFjZXMpO1xuICAgIH0sXG4gICAgc3BsaXQ6IGZ1bmN0aW9uIHNwbGl0KHN0cmluZywgc2VwYXJhdG9ycywgbGFzdCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBcIlwiO1xuICAgICAgICB2YXIgc3BsaXQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGZ1bmMgPSAwO1xuICAgICAgICB2YXIgaW5RdW90ZSA9IGZhbHNlO1xuICAgICAgICB2YXIgcHJldlF1b3RlID0gXCJcIjtcbiAgICAgICAgdmFyIGVzY2FwZSA9IGZhbHNlO1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShzdHJpbmcpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgbGV0dGVyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICBpZiAoZXNjYXBlKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBlID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxldHRlciA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgICAgICBlc2NhcGUgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpblF1b3RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxldHRlciA9PT0gcHJldlF1b3RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGluUXVvdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxldHRlciA9PT0gJ1wiJyB8fCBsZXR0ZXIgPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICAgICAgaW5RdW90ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHJldlF1b3RlID0gbGV0dGVyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsZXR0ZXIgPT09IFwiKFwiKSB7XG4gICAgICAgICAgICAgICAgZnVuYyArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsZXR0ZXIgPT09IFwiKVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bmMgPiAwKSBmdW5jIC09IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZ1bmMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VwYXJhdG9ycy5pbmNsdWRlcyhsZXR0ZXIpKSBzcGxpdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3BsaXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCAhPT0gXCJcIikgYXJyYXkucHVzaChjdXJyZW50LnRyaW0oKSk7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgc3BsaXQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCArPSBsZXR0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3QgfHwgY3VycmVudCAhPT0gXCJcIikgYXJyYXkucHVzaChjdXJyZW50LnRyaW0oKSk7XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG59O1xudmFyIGxpc3RfMSA9IGxpc3QkMjtcbmxpc3QkMi5kZWZhdWx0ID0gbGlzdCQyO1xudmFyIENvbnRhaW5lciQzID0gY29udGFpbmVyO1xudmFyIGxpc3QkMSA9IGxpc3RfMTtcbnZhciBSdWxlJDMgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKENvbnRhaW5lciQzKSB7XG4gICAgX2luaGVyaXRzKFJ1bGUyLCBDb250YWluZXIkMyk7XG4gICAgZnVuY3Rpb24gUnVsZTIoZGVmYXVsdHMpIHtcbiAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICBfdGhpcyA9IENvbnRhaW5lciQzLmNhbGwodGhpcywgZGVmYXVsdHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSBcInJ1bGVcIjtcbiAgICAgICAgaWYgKCFfdGhpcy5ub2RlcykgX3RoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBfY3JlYXRlX2NsYXNzKFJ1bGUyLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJzZWxlY3RvcnNcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0JDEuY29tbWEodGhpcy5zZWxlY3Rvcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gdGhpcy5zZWxlY3RvciA/IHRoaXMuc2VsZWN0b3IubWF0Y2goLyxcXHMqLykgOiBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBzZXAyID0gbWF0Y2ggPyBtYXRjaFswXSA6IFwiLFwiICsgdGhpcy5yYXcoXCJiZXR3ZWVuXCIsIFwiYmVmb3JlT3BlblwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gdmFsdWVzLmpvaW4oc2VwMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gUnVsZTI7XG59KENvbnRhaW5lciQzKTtcbnZhciBydWxlID0gUnVsZSQzO1xuUnVsZSQzLmRlZmF1bHQgPSBSdWxlJDM7XG5Db250YWluZXIkMy5yZWdpc3RlclJ1bGUoUnVsZSQzKTtcbnZhciBEZWNsYXJhdGlvbiQyID0gZGVjbGFyYXRpb247XG52YXIgdG9rZW5pemVyMjIgPSB0b2tlbml6ZTtcbnZhciBDb21tZW50JDIgPSBjb21tZW50O1xudmFyIEF0UnVsZSQyID0gYXRSdWxlO1xudmFyIFJvb3QkNCA9IHJvb3Q7XG52YXIgUnVsZSQyID0gcnVsZTtcbnZhciBTQUZFX0NPTU1FTlRfTkVJR0hCT1IgPSB7XG4gICAgZW1wdHk6IHRydWUsXG4gICAgc3BhY2U6IHRydWVcbn07XG5mdW5jdGlvbiBmaW5kTGFzdFdpdGhQb3NpdGlvbih0b2tlbnMpIHtcbiAgICBmb3IodmFyIGkyID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pe1xuICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaTJdO1xuICAgICAgICB2YXIgcG9zID0gdG9rZW5bM10gfHwgdG9rZW5bMl07XG4gICAgICAgIGlmIChwb3MpIHJldHVybiBwb3M7XG4gICAgfVxufVxudmFyIFBhcnNlciQxID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBQYXJzZXIyKGlucHV0Mikge1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQyO1xuICAgICAgICB0aGlzLnJvb3QgPSBuZXcgUm9vdCQ0KCk7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMucm9vdDtcbiAgICAgICAgdGhpcy5zcGFjZXMgPSBcIlwiO1xuICAgICAgICB0aGlzLnNlbWljb2xvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNyZWF0ZVRva2VuaXplcigpO1xuICAgICAgICB0aGlzLnJvb3Quc291cmNlID0ge1xuICAgICAgICAgICAgaW5wdXQ6IGlucHV0MixcbiAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiAxLFxuICAgICAgICAgICAgICAgIGxpbmU6IDEsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBQYXJzZXIyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uYXRydWxlID0gZnVuY3Rpb24gYXRydWxlKHRva2VuKSB7XG4gICAgICAgIHZhciBub2RlMiA9IG5ldyBBdFJ1bGUkMigpO1xuICAgICAgICBub2RlMi5uYW1lID0gdG9rZW5bMV0uc2xpY2UoMSk7XG4gICAgICAgIGlmIChub2RlMi5uYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgICB0aGlzLnVubmFtZWRBdHJ1bGUobm9kZTIsIHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXQobm9kZTIsIHRva2VuWzJdKTtcbiAgICAgICAgdmFyIHR5cGU7XG4gICAgICAgIHZhciBwcmV2O1xuICAgICAgICB2YXIgc2hpZnQ7XG4gICAgICAgIHZhciBsYXN0ID0gZmFsc2U7XG4gICAgICAgIHZhciBvcGVuID0gZmFsc2U7XG4gICAgICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICAgICAgdmFyIGJyYWNrZXRzID0gW107XG4gICAgICAgIHdoaWxlKCF0aGlzLnRva2VuaXplci5lbmRPZkZpbGUoKSl7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMudG9rZW5pemVyLm5leHRUb2tlbigpO1xuICAgICAgICAgICAgdHlwZSA9IHRva2VuWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiKFwiIHx8IHR5cGUgPT09IFwiW1wiKSB7XG4gICAgICAgICAgICAgICAgYnJhY2tldHMucHVzaCh0eXBlID09PSBcIihcIiA/IFwiKVwiIDogXCJdXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIntcIiAmJiBicmFja2V0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgYnJhY2tldHMucHVzaChcIn1cIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IGJyYWNrZXRzW2JyYWNrZXRzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICAgICAgYnJhY2tldHMucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnJhY2tldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiO1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUyLnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKHRva2VuWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTIuc291cmNlLmVuZC5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW1pY29sb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwie1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSBwYXJhbXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSBwYXJhbXNbc2hpZnRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUocHJldiAmJiBwcmV2WzBdID09PSBcInNwYWNlXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSBwYXJhbXNbLS1zaGlmdF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUyLnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKHByZXZbM10gfHwgcHJldlsyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTIuc291cmNlLmVuZC5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnRva2VuaXplci5lbmRPZkZpbGUoKSkge1xuICAgICAgICAgICAgICAgIGxhc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGUyLnJhd3MuYmV0d2VlbiA9IHRoaXMuc3BhY2VzQW5kQ29tbWVudHNGcm9tRW5kKHBhcmFtcyk7XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBub2RlMi5yYXdzLmFmdGVyTmFtZSA9IHRoaXMuc3BhY2VzQW5kQ29tbWVudHNGcm9tU3RhcnQocGFyYW1zKTtcbiAgICAgICAgICAgIHRoaXMucmF3KG5vZGUyLCBcInBhcmFtc1wiLCBwYXJhbXMpO1xuICAgICAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHBhcmFtc1twYXJhbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgbm9kZTIuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5bM10gfHwgdG9rZW5bMl0pO1xuICAgICAgICAgICAgICAgIG5vZGUyLnNvdXJjZS5lbmQub2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGFjZXMgPSBub2RlMi5yYXdzLmJldHdlZW47XG4gICAgICAgICAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUyLnJhd3MuYWZ0ZXJOYW1lID0gXCJcIjtcbiAgICAgICAgICAgIG5vZGUyLnBhcmFtcyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgIG5vZGUyLm5vZGVzID0gW107XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBub2RlMjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmNoZWNrTWlzc2VkU2VtaWNvbG9uID0gZnVuY3Rpb24gY2hlY2tNaXNzZWRTZW1pY29sb24odG9rZW5zKSB7XG4gICAgICAgIHZhciBjb2xvbiA9IHRoaXMuY29sb24odG9rZW5zKTtcbiAgICAgICAgaWYgKGNvbG9uID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICB2YXIgZm91bmRlZCA9IDA7XG4gICAgICAgIHZhciB0b2tlbjtcbiAgICAgICAgZm9yKHZhciBqID0gY29sb24gLSAxOyBqID49IDA7IGotLSl7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tqXTtcbiAgICAgICAgICAgIGlmICh0b2tlblswXSAhPT0gXCJzcGFjZVwiKSB7XG4gICAgICAgICAgICAgICAgZm91bmRlZCArPSAxO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZGVkID09PSAyKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFwiTWlzc2VkIHNlbWljb2xvblwiLCB0b2tlblswXSA9PT0gXCJ3b3JkXCIgPyB0b2tlblszXSArIDEgOiB0b2tlblsyXSk7XG4gICAgfTtcbiAgICBfcHJvdG8uY29sb24gPSBmdW5jdGlvbiBjb2xvbih0b2tlbnMpIHtcbiAgICAgICAgdmFyIGJyYWNrZXRzID0gMDtcbiAgICAgICAgdmFyIHRva2VuLCB0eXBlLCBwcmV2O1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZSh0b2tlbnMuZW50cmllcygpKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIF9zdGVwX3ZhbHVlID0gX3N0ZXAudmFsdWUsIGkyID0gX3N0ZXBfdmFsdWVbMF0sIGVsZW1lbnQgPSBfc3RlcF92YWx1ZVsxXTtcbiAgICAgICAgICAgIHRva2VuID0gZWxlbWVudDtcbiAgICAgICAgICAgIHR5cGUgPSB0b2tlblswXTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcIihcIikge1xuICAgICAgICAgICAgICAgIGJyYWNrZXRzICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCIpXCIpIHtcbiAgICAgICAgICAgICAgICBicmFja2V0cyAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJyYWNrZXRzID09PSAwICYmIHR5cGUgPT09IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG91YmxlQ29sb24odG9rZW4pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldlswXSA9PT0gXCJ3b3JkXCIgJiYgcHJldlsxXSA9PT0gXCJwcm9naWRcIikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldiA9IHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIF9wcm90by5jb21tZW50ID0gZnVuY3Rpb24gY29tbWVudCh0b2tlbikge1xuICAgICAgICB2YXIgbm9kZTIgPSBuZXcgQ29tbWVudCQyKCk7XG4gICAgICAgIHRoaXMuaW5pdChub2RlMiwgdG9rZW5bMl0pO1xuICAgICAgICBub2RlMi5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbih0b2tlblszXSB8fCB0b2tlblsyXSk7XG4gICAgICAgIG5vZGUyLnNvdXJjZS5lbmQub2Zmc2V0Kys7XG4gICAgICAgIHZhciB0ZXh0ID0gdG9rZW5bMV0uc2xpY2UoMiwgLTIpO1xuICAgICAgICBpZiAoL15cXHMqJC8udGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgbm9kZTIudGV4dCA9IFwiXCI7XG4gICAgICAgICAgICBub2RlMi5yYXdzLmxlZnQgPSB0ZXh0O1xuICAgICAgICAgICAgbm9kZTIucmF3cy5yaWdodCA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSB0ZXh0Lm1hdGNoKC9eKFxccyopKFteXSpcXFMpKFxccyopJC8pO1xuICAgICAgICAgICAgbm9kZTIudGV4dCA9IG1hdGNoWzJdO1xuICAgICAgICAgICAgbm9kZTIucmF3cy5sZWZ0ID0gbWF0Y2hbMV07XG4gICAgICAgICAgICBub2RlMi5yYXdzLnJpZ2h0ID0gbWF0Y2hbM107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5jcmVhdGVUb2tlbml6ZXIgPSBmdW5jdGlvbiBjcmVhdGVUb2tlbml6ZXIoKSB7XG4gICAgICAgIHRoaXMudG9rZW5pemVyID0gdG9rZW5pemVyMjIodGhpcy5pbnB1dCk7XG4gICAgfTtcbiAgICBfcHJvdG8uZGVjbCA9IGZ1bmN0aW9uIGRlY2wodG9rZW5zLCBjdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICB2YXIgbm9kZTIgPSBuZXcgRGVjbGFyYXRpb24kMigpO1xuICAgICAgICB0aGlzLmluaXQobm9kZTIsIHRva2Vuc1swXVsyXSk7XG4gICAgICAgIHZhciBsYXN0ID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3RbMF0gPT09IFwiO1wiKSB7XG4gICAgICAgICAgICB0aGlzLnNlbWljb2xvbiA9IHRydWU7XG4gICAgICAgICAgICB0b2tlbnMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZTIuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24obGFzdFszXSB8fCBsYXN0WzJdIHx8IGZpbmRMYXN0V2l0aFBvc2l0aW9uKHRva2VucykpO1xuICAgICAgICBub2RlMi5zb3VyY2UuZW5kLm9mZnNldCsrO1xuICAgICAgICB3aGlsZSh0b2tlbnNbMF1bMF0gIT09IFwid29yZFwiKXtcbiAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAxKSB0aGlzLnVua25vd25Xb3JkKHRva2Vucyk7XG4gICAgICAgICAgICBub2RlMi5yYXdzLmJlZm9yZSArPSB0b2tlbnMuc2hpZnQoKVsxXTtcbiAgICAgICAgfVxuICAgICAgICBub2RlMi5zb3VyY2Uuc3RhcnQgPSB0aGlzLmdldFBvc2l0aW9uKHRva2Vuc1swXVsyXSk7XG4gICAgICAgIG5vZGUyLnByb3AgPSBcIlwiO1xuICAgICAgICB3aGlsZSh0b2tlbnMubGVuZ3RoKXtcbiAgICAgICAgICAgIHZhciB0eXBlID0gdG9rZW5zWzBdWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiOlwiIHx8IHR5cGUgPT09IFwic3BhY2VcIiB8fCB0eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZTIucHJvcCArPSB0b2tlbnMuc2hpZnQoKVsxXTtcbiAgICAgICAgfVxuICAgICAgICBub2RlMi5yYXdzLmJldHdlZW4gPSBcIlwiO1xuICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgIHdoaWxlKHRva2Vucy5sZW5ndGgpe1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnMuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmICh0b2tlblswXSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICBub2RlMi5yYXdzLmJldHdlZW4gKz0gdG9rZW5bMV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlblswXSA9PT0gXCJ3b3JkXCIgJiYgL1xcdy8udGVzdCh0b2tlblsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bmtub3duV29yZChbXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlblxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuICs9IHRva2VuWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlMi5wcm9wWzBdID09PSBcIl9cIiB8fCBub2RlMi5wcm9wWzBdID09PSBcIipcIikge1xuICAgICAgICAgICAgbm9kZTIucmF3cy5iZWZvcmUgKz0gbm9kZTIucHJvcFswXTtcbiAgICAgICAgICAgIG5vZGUyLnByb3AgPSBub2RlMi5wcm9wLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaXJzdFNwYWNlcyA9IFtdO1xuICAgICAgICB2YXIgbmV4dDtcbiAgICAgICAgd2hpbGUodG9rZW5zLmxlbmd0aCl7XG4gICAgICAgICAgICBuZXh0ID0gdG9rZW5zWzBdWzBdO1xuICAgICAgICAgICAgaWYgKG5leHQgIT09IFwic3BhY2VcIiAmJiBuZXh0ICE9PSBcImNvbW1lbnRcIikgYnJlYWs7XG4gICAgICAgICAgICBmaXJzdFNwYWNlcy5wdXNoKHRva2Vucy5zaGlmdCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZWNoZWNrTWlzc2VkU2VtaWNvbG9uKHRva2Vucyk7XG4gICAgICAgIGZvcih2YXIgaTIgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSl7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpMl07XG4gICAgICAgICAgICBpZiAodG9rZW5bMV0udG9Mb3dlckNhc2UoKSA9PT0gXCIhaW1wb3J0YW50XCIpIHtcbiAgICAgICAgICAgICAgICBub2RlMi5pbXBvcnRhbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBzdHJpbmcgPSB0aGlzLnN0cmluZ0Zyb20odG9rZW5zLCBpMik7XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gdGhpcy5zcGFjZXNGcm9tRW5kKHRva2VucykgKyBzdHJpbmc7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmluZyAhPT0gXCIgIWltcG9ydGFudFwiKSBub2RlMi5yYXdzLmltcG9ydGFudCA9IHN0cmluZztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW5bMV0udG9Mb3dlckNhc2UoKSA9PT0gXCJpbXBvcnRhbnRcIikge1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZSA9IHRva2Vucy5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RyID0gXCJcIjtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGogPSBpMjsgaiA+IDA7IGotLSl7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlMSA9IGNhY2hlW2pdWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyLnRyaW0oKS5pbmRleE9mKFwiIVwiKSA9PT0gMCAmJiB0eXBlMSAhPT0gXCJzcGFjZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdHIgPSBjYWNoZS5wb3AoKVsxXSArIHN0cjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0ci50cmltKCkuaW5kZXhPZihcIiFcIikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTIuaW1wb3J0YW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTIucmF3cy5pbXBvcnRhbnQgPSBzdHI7XG4gICAgICAgICAgICAgICAgICAgIHRva2VucyA9IGNhY2hlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlblswXSAhPT0gXCJzcGFjZVwiICYmIHRva2VuWzBdICE9PSBcImNvbW1lbnRcIikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBoYXNXb3JkID0gdG9rZW5zLnNvbWUoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIHJldHVybiBpMlswXSAhPT0gXCJzcGFjZVwiICYmIGkyWzBdICE9PSBcImNvbW1lbnRcIjtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChoYXNXb3JkKSB7XG4gICAgICAgICAgICBub2RlMi5yYXdzLmJldHdlZW4gKz0gZmlyc3RTcGFjZXMubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkyWzFdO1xuICAgICAgICAgICAgfSkuam9pbihcIlwiKTtcbiAgICAgICAgICAgIGZpcnN0U3BhY2VzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yYXcobm9kZTIsIFwidmFsdWVcIiwgZmlyc3RTcGFjZXMuY29uY2F0KHRva2VucyksIGN1c3RvbVByb3BlcnR5KTtcbiAgICAgICAgaWYgKG5vZGUyLnZhbHVlLmluY2x1ZGVzKFwiOlwiKSAmJiAhY3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tNaXNzZWRTZW1pY29sb24odG9rZW5zKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmRvdWJsZUNvbG9uID0gZnVuY3Rpb24gZG91YmxlQ29sb24odG9rZW4pIHtcbiAgICAgICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcIkRvdWJsZSBjb2xvblwiLCB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRva2VuWzJdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG9mZnNldDogdG9rZW5bMl0gKyB0b2tlblsxXS5sZW5ndGhcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8uZW1wdHlSdWxlID0gZnVuY3Rpb24gZW1wdHlSdWxlKHRva2VuKSB7XG4gICAgICAgIHZhciBub2RlMiA9IG5ldyBSdWxlJDIoKTtcbiAgICAgICAgdGhpcy5pbml0KG5vZGUyLCB0b2tlblsyXSk7XG4gICAgICAgIG5vZGUyLnNlbGVjdG9yID0gXCJcIjtcbiAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuID0gXCJcIjtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gbm9kZTI7XG4gICAgfTtcbiAgICBfcHJvdG8uZW5kID0gZnVuY3Rpb24gZW5kKHRva2VuKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQubm9kZXMgJiYgdGhpcy5jdXJyZW50Lm5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50LnJhd3Muc2VtaWNvbG9uID0gdGhpcy5zZW1pY29sb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZW1pY29sb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJyZW50LnJhd3MuYWZ0ZXIgPSAodGhpcy5jdXJyZW50LnJhd3MuYWZ0ZXIgfHwgXCJcIikgKyB0aGlzLnNwYWNlcztcbiAgICAgICAgdGhpcy5zcGFjZXMgPSBcIlwiO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50LnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50LnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKHRva2VuWzJdKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudC5zb3VyY2UuZW5kLm9mZnNldCsrO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5jdXJyZW50LnBhcmVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudW5leHBlY3RlZENsb3NlKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmVuZEZpbGUgPSBmdW5jdGlvbiBlbmRGaWxlKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50LnBhcmVudCkgdGhpcy51bmNsb3NlZEJsb2NrKCk7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQubm9kZXMgJiYgdGhpcy5jdXJyZW50Lm5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50LnJhd3Muc2VtaWNvbG9uID0gdGhpcy5zZW1pY29sb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50LnJhd3MuYWZ0ZXIgPSAodGhpcy5jdXJyZW50LnJhd3MuYWZ0ZXIgfHwgXCJcIikgKyB0aGlzLnNwYWNlcztcbiAgICAgICAgdGhpcy5yb290LnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKHRoaXMudG9rZW5pemVyLnBvc2l0aW9uKCkpO1xuICAgIH07XG4gICAgX3Byb3RvLmZyZWVTZW1pY29sb24gPSBmdW5jdGlvbiBmcmVlU2VtaWNvbG9uKHRva2VuKSB7XG4gICAgICAgIHRoaXMuc3BhY2VzICs9IHRva2VuWzFdO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50Lm5vZGVzKSB7XG4gICAgICAgICAgICB2YXIgcHJldiA9IHRoaXMuY3VycmVudC5ub2Rlc1t0aGlzLmN1cnJlbnQubm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAocHJldiAmJiBwcmV2LnR5cGUgPT09IFwicnVsZVwiICYmICFwcmV2LnJhd3Mub3duU2VtaWNvbG9uKSB7XG4gICAgICAgICAgICAgICAgcHJldi5yYXdzLm93blNlbWljb2xvbiA9IHRoaXMuc3BhY2VzO1xuICAgICAgICAgICAgICAgIHRoaXMuc3BhY2VzID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gSGVscGVyc1xuICAgIF9wcm90by5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIGdldFBvc2l0aW9uKG9mZnNldCkge1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5pbnB1dC5mcm9tT2Zmc2V0KG9mZnNldCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2x1bW46IHBvcy5jb2wsXG4gICAgICAgICAgICBsaW5lOiBwb3MubGluZSxcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8uaW5pdCA9IGZ1bmN0aW9uIGluaXQobm9kZTIsIG9mZnNldCkge1xuICAgICAgICB0aGlzLmN1cnJlbnQucHVzaChub2RlMik7XG4gICAgICAgIG5vZGUyLnNvdXJjZSA9IHtcbiAgICAgICAgICAgIGlucHV0OiB0aGlzLmlucHV0LFxuICAgICAgICAgICAgc3RhcnQ6IHRoaXMuZ2V0UG9zaXRpb24ob2Zmc2V0KVxuICAgICAgICB9O1xuICAgICAgICBub2RlMi5yYXdzLmJlZm9yZSA9IHRoaXMuc3BhY2VzO1xuICAgICAgICB0aGlzLnNwYWNlcyA9IFwiXCI7XG4gICAgICAgIGlmIChub2RlMi50eXBlICE9PSBcImNvbW1lbnRcIikgdGhpcy5zZW1pY29sb24gPSBmYWxzZTtcbiAgICB9O1xuICAgIF9wcm90by5vdGhlciA9IGZ1bmN0aW9uIG90aGVyKHN0YXJ0KSB7XG4gICAgICAgIHZhciBlbmQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHR5cGUgPSBudWxsO1xuICAgICAgICB2YXIgY29sb24gPSBmYWxzZTtcbiAgICAgICAgdmFyIGJyYWNrZXQgPSBudWxsO1xuICAgICAgICB2YXIgYnJhY2tldHMgPSBbXTtcbiAgICAgICAgdmFyIGN1c3RvbVByb3BlcnR5ID0gc3RhcnRbMV0uc3RhcnRzV2l0aChcIi0tXCIpO1xuICAgICAgICB2YXIgdG9rZW5zID0gW107XG4gICAgICAgIHZhciB0b2tlbiA9IHN0YXJ0O1xuICAgICAgICB3aGlsZSh0b2tlbil7XG4gICAgICAgICAgICB0eXBlID0gdG9rZW5bMF07XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCIoXCIgfHwgdHlwZSA9PT0gXCJbXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJyYWNrZXQpIGJyYWNrZXQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBicmFja2V0cy5wdXNoKHR5cGUgPT09IFwiKFwiID8gXCIpXCIgOiBcIl1cIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1c3RvbVByb3BlcnR5ICYmIGNvbG9uICYmIHR5cGUgPT09IFwie1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFicmFja2V0KSBicmFja2V0ID0gdG9rZW47XG4gICAgICAgICAgICAgICAgYnJhY2tldHMucHVzaChcIn1cIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJyYWNrZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcIjtcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjbCh0b2tlbnMsIGN1c3RvbVByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIntcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bGUodG9rZW5zKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b2tlbml6ZXIuYmFjayh0b2tlbnMucG9wKCkpO1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IGJyYWNrZXRzW2JyYWNrZXRzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICAgICAgYnJhY2tldHMucG9wKCk7XG4gICAgICAgICAgICAgICAgaWYgKGJyYWNrZXRzLmxlbmd0aCA9PT0gMCkgYnJhY2tldCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMudG9rZW5pemVyLm5leHRUb2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRva2VuaXplci5lbmRPZkZpbGUoKSkgZW5kID0gdHJ1ZTtcbiAgICAgICAgaWYgKGJyYWNrZXRzLmxlbmd0aCA+IDApIHRoaXMudW5jbG9zZWRCcmFja2V0KGJyYWNrZXQpO1xuICAgICAgICBpZiAoZW5kICYmIGNvbG9uKSB7XG4gICAgICAgICAgICBpZiAoIWN1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUodG9rZW5zLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXVswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBcInNwYWNlXCIgJiYgdG9rZW4gIT09IFwiY29tbWVudFwiKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b2tlbml6ZXIuYmFjayh0b2tlbnMucG9wKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVjbCh0b2tlbnMsIGN1c3RvbVByb3BlcnR5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudW5rbm93bldvcmQodG9rZW5zKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoKSB7XG4gICAgICAgIHZhciB0b2tlbjtcbiAgICAgICAgd2hpbGUoIXRoaXMudG9rZW5pemVyLmVuZE9mRmlsZSgpKXtcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy50b2tlbml6ZXIubmV4dFRva2VuKCk7XG4gICAgICAgICAgICBzd2l0Y2godG9rZW5bMF0pe1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzcGFjZVwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwYWNlcyArPSB0b2tlblsxXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIjtcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmVlU2VtaWNvbG9uKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIn1cIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmQodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29tbWVudFwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1lbnQodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiYXQtd29yZFwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0cnVsZSh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ7XCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1wdHlSdWxlKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vdGhlcih0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW5kRmlsZSgpO1xuICAgIH07XG4gICAgX3Byb3RvLnByZWNoZWNrTWlzc2VkU2VtaWNvbG9uID0gZnVuY3Rpb24gcHJlY2hlY2tNaXNzZWRTZW1pY29sb24oKSB7fTtcbiAgICBfcHJvdG8ucmF3ID0gZnVuY3Rpb24gcmF3KG5vZGUyLCBwcm9wLCB0b2tlbnMsIGN1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgIHZhciB0b2tlbiwgdHlwZTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRva2Vucy5sZW5ndGg7XG4gICAgICAgIHZhciB2YWx1ZSA9IFwiXCI7XG4gICAgICAgIHZhciBjbGVhbiA9IHRydWU7XG4gICAgICAgIHZhciBuZXh0LCBwcmV2O1xuICAgICAgICBmb3IodmFyIGkyID0gMDsgaTIgPCBsZW5ndGg7IGkyICs9IDEpe1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaTJdO1xuICAgICAgICAgICAgdHlwZSA9IHRva2VuWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwic3BhY2VcIiAmJiBpMiA9PT0gbGVuZ3RoIC0gMSAmJiAhY3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgICAgICAgICAgICAgIHByZXYgPSB0b2tlbnNbaTIgLSAxXSA/IHRva2Vuc1tpMiAtIDFdWzBdIDogXCJlbXB0eVwiO1xuICAgICAgICAgICAgICAgIG5leHQgPSB0b2tlbnNbaTIgKyAxXSA/IHRva2Vuc1tpMiArIDFdWzBdIDogXCJlbXB0eVwiO1xuICAgICAgICAgICAgICAgIGlmICghU0FGRV9DT01NRU5UX05FSUdIQk9SW3ByZXZdICYmICFTQUZFX0NPTU1FTlRfTkVJR0hCT1JbbmV4dF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLnNsaWNlKC0xKSA9PT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSB0b2tlblsxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSB0b2tlblsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNsZWFuKSB7XG4gICAgICAgICAgICB2YXIgcmF3ID0gdG9rZW5zLnJlZHVjZShmdW5jdGlvbihhbGwsIGkyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFsbCArIGkyWzFdO1xuICAgICAgICAgICAgfSwgXCJcIik7XG4gICAgICAgICAgICBub2RlMi5yYXdzW3Byb3BdID0ge1xuICAgICAgICAgICAgICAgIHJhdzogcmF3LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBub2RlMltwcm9wXSA9IHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJ1bGUgPSBmdW5jdGlvbiBydWxlKHRva2Vucykge1xuICAgICAgICB0b2tlbnMucG9wKCk7XG4gICAgICAgIHZhciBub2RlMiA9IG5ldyBSdWxlJDIoKTtcbiAgICAgICAgdGhpcy5pbml0KG5vZGUyLCB0b2tlbnNbMF1bMl0pO1xuICAgICAgICBub2RlMi5yYXdzLmJldHdlZW4gPSB0aGlzLnNwYWNlc0FuZENvbW1lbnRzRnJvbUVuZCh0b2tlbnMpO1xuICAgICAgICB0aGlzLnJhdyhub2RlMiwgXCJzZWxlY3RvclwiLCB0b2tlbnMpO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBub2RlMjtcbiAgICB9O1xuICAgIF9wcm90by5zcGFjZXNBbmRDb21tZW50c0Zyb21FbmQgPSBmdW5jdGlvbiBzcGFjZXNBbmRDb21tZW50c0Zyb21FbmQodG9rZW5zKSB7XG4gICAgICAgIHZhciBsYXN0VG9rZW5UeXBlO1xuICAgICAgICB2YXIgc3BhY2VzID0gXCJcIjtcbiAgICAgICAgd2hpbGUodG9rZW5zLmxlbmd0aCl7XG4gICAgICAgICAgICBsYXN0VG9rZW5UeXBlID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXVswXTtcbiAgICAgICAgICAgIGlmIChsYXN0VG9rZW5UeXBlICE9PSBcInNwYWNlXCIgJiYgbGFzdFRva2VuVHlwZSAhPT0gXCJjb21tZW50XCIpIGJyZWFrO1xuICAgICAgICAgICAgc3BhY2VzID0gdG9rZW5zLnBvcCgpWzFdICsgc3BhY2VzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFjZXM7XG4gICAgfTtcbiAgICAvLyBFcnJvcnNcbiAgICBfcHJvdG8uc3BhY2VzQW5kQ29tbWVudHNGcm9tU3RhcnQgPSBmdW5jdGlvbiBzcGFjZXNBbmRDb21tZW50c0Zyb21TdGFydCh0b2tlbnMpIHtcbiAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgIHZhciBzcGFjZXMgPSBcIlwiO1xuICAgICAgICB3aGlsZSh0b2tlbnMubGVuZ3RoKXtcbiAgICAgICAgICAgIG5leHQgPSB0b2tlbnNbMF1bMF07XG4gICAgICAgICAgICBpZiAobmV4dCAhPT0gXCJzcGFjZVwiICYmIG5leHQgIT09IFwiY29tbWVudFwiKSBicmVhaztcbiAgICAgICAgICAgIHNwYWNlcyArPSB0b2tlbnMuc2hpZnQoKVsxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BhY2VzO1xuICAgIH07XG4gICAgX3Byb3RvLnNwYWNlc0Zyb21FbmQgPSBmdW5jdGlvbiBzcGFjZXNGcm9tRW5kKHRva2Vucykge1xuICAgICAgICB2YXIgbGFzdFRva2VuVHlwZTtcbiAgICAgICAgdmFyIHNwYWNlcyA9IFwiXCI7XG4gICAgICAgIHdoaWxlKHRva2Vucy5sZW5ndGgpe1xuICAgICAgICAgICAgbGFzdFRva2VuVHlwZSA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV1bMF07XG4gICAgICAgICAgICBpZiAobGFzdFRva2VuVHlwZSAhPT0gXCJzcGFjZVwiKSBicmVhaztcbiAgICAgICAgICAgIHNwYWNlcyA9IHRva2Vucy5wb3AoKVsxXSArIHNwYWNlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BhY2VzO1xuICAgIH07XG4gICAgX3Byb3RvLnN0cmluZ0Zyb20gPSBmdW5jdGlvbiBzdHJpbmdGcm9tKHRva2VucywgZnJvbSkge1xuICAgICAgICB2YXIgcmVzdWx0MiA9IFwiXCI7XG4gICAgICAgIGZvcih2YXIgaTIgPSBmcm9tOyBpMiA8IHRva2Vucy5sZW5ndGg7IGkyKyspe1xuICAgICAgICAgICAgcmVzdWx0MiArPSB0b2tlbnNbaTJdWzFdO1xuICAgICAgICB9XG4gICAgICAgIHRva2Vucy5zcGxpY2UoZnJvbSwgdG9rZW5zLmxlbmd0aCAtIGZyb20pO1xuICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICB9O1xuICAgIF9wcm90by51bmNsb3NlZEJsb2NrID0gZnVuY3Rpb24gdW5jbG9zZWRCbG9jaygpIHtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuY3VycmVudC5zb3VyY2Uuc3RhcnQ7XG4gICAgICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXCJVbmNsb3NlZCBibG9ja1wiLCBwb3MubGluZSwgcG9zLmNvbHVtbik7XG4gICAgfTtcbiAgICBfcHJvdG8udW5jbG9zZWRCcmFja2V0ID0gZnVuY3Rpb24gdW5jbG9zZWRCcmFja2V0KGJyYWNrZXQpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcIlVuY2xvc2VkIGJyYWNrZXRcIiwge1xuICAgICAgICAgICAgb2Zmc2V0OiBicmFja2V0WzJdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG9mZnNldDogYnJhY2tldFsyXSArIDFcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8udW5leHBlY3RlZENsb3NlID0gZnVuY3Rpb24gdW5leHBlY3RlZENsb3NlKHRva2VuKSB7XG4gICAgICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXCJVbmV4cGVjdGVkIH1cIiwge1xuICAgICAgICAgICAgb2Zmc2V0OiB0b2tlblsyXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRva2VuWzJdICsgMVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by51bmtub3duV29yZCA9IGZ1bmN0aW9uIHVua25vd25Xb3JkKHRva2Vucykge1xuICAgICAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFwiVW5rbm93biB3b3JkXCIsIHtcbiAgICAgICAgICAgIG9mZnNldDogdG9rZW5zWzBdWzJdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG9mZnNldDogdG9rZW5zWzBdWzJdICsgdG9rZW5zWzBdWzFdLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by51bm5hbWVkQXRydWxlID0gZnVuY3Rpb24gdW5uYW1lZEF0cnVsZShub2RlMiwgdG9rZW4pIHtcbiAgICAgICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcIkF0LXJ1bGUgd2l0aG91dCBuYW1lXCIsIHtcbiAgICAgICAgICAgIG9mZnNldDogdG9rZW5bMl1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgb2Zmc2V0OiB0b2tlblsyXSArIHRva2VuWzFdLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBQYXJzZXIyO1xufSgpO1xudmFyIHBhcnNlciA9IFBhcnNlciQxO1xudmFyIENvbnRhaW5lciQyID0gY29udGFpbmVyO1xudmFyIFBhcnNlcjIyID0gcGFyc2VyO1xudmFyIElucHV0JDIgPSBpbnB1dDtcbmZ1bmN0aW9uIHBhcnNlJDMoY3NzLCBvcHRzKSB7XG4gICAgdmFyIGlucHV0MiA9IG5ldyBJbnB1dCQyKGNzcywgb3B0cyk7XG4gICAgdmFyIHBhcnNlcjIgPSBuZXcgUGFyc2VyMjIoaW5wdXQyKTtcbiAgICB0cnkge1xuICAgICAgICBwYXJzZXIyLnBhcnNlKCk7XG4gICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKGUyLm5hbWUgPT09IFwiQ3NzU3ludGF4RXJyb3JcIiAmJiBvcHRzICYmIG9wdHMuZnJvbSkge1xuICAgICAgICAgICAgICAgIGlmICgvXFwuc2NzcyQvaS50ZXN0KG9wdHMuZnJvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZTIubWVzc2FnZSArPSBcIlxcbllvdSB0cmllZCB0byBwYXJzZSBTQ1NTIHdpdGggdGhlIHN0YW5kYXJkIENTUyBwYXJzZXI7IHRyeSBhZ2FpbiB3aXRoIHRoZSBwb3N0Y3NzLXNjc3MgcGFyc2VyXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgvXFwuc2Fzcy9pLnRlc3Qob3B0cy5mcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICBlMi5tZXNzYWdlICs9IFwiXFxuWW91IHRyaWVkIHRvIHBhcnNlIFNhc3Mgd2l0aCB0aGUgc3RhbmRhcmQgQ1NTIHBhcnNlcjsgdHJ5IGFnYWluIHdpdGggdGhlIHBvc3Rjc3Mtc2FzcyBwYXJzZXJcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKC9cXC5sZXNzJC9pLnRlc3Qob3B0cy5mcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICBlMi5tZXNzYWdlICs9IFwiXFxuWW91IHRyaWVkIHRvIHBhcnNlIExlc3Mgd2l0aCB0aGUgc3RhbmRhcmQgQ1NTIHBhcnNlcjsgdHJ5IGFnYWluIHdpdGggdGhlIHBvc3Rjc3MtbGVzcyBwYXJzZXJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTI7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZXIyLnJvb3Q7XG59XG52YXIgcGFyc2VfMSA9IHBhcnNlJDM7XG5wYXJzZSQzLmRlZmF1bHQgPSBwYXJzZSQzO1xuQ29udGFpbmVyJDIucmVnaXN0ZXJQYXJzZShwYXJzZSQzKTtcbnZhciBpc0NsZWFuID0gc3ltYm9scy5pc0NsZWFuLCBteSA9IHN5bWJvbHMubXk7XG52YXIgTWFwR2VuZXJhdG9yJDEgPSBtYXBHZW5lcmF0b3I7XG52YXIgc3RyaW5naWZ5JDIgPSBzdHJpbmdpZnlfMTtcbnZhciBDb250YWluZXIkMSA9IGNvbnRhaW5lcjtcbnZhciBEb2N1bWVudCQyID0gZG9jdW1lbnQkMSQyO1xudmFyIHdhcm5PbmNlJDEgPSB3YXJuT25jZSQyO1xudmFyIFJlc3VsdCQyID0gcmVzdWx0O1xudmFyIHBhcnNlJDIgPSBwYXJzZV8xO1xudmFyIFJvb3QkMyA9IHJvb3Q7XG52YXIgVFlQRV9UT19DTEFTU19OQU1FID0ge1xuICAgIGF0cnVsZTogXCJBdFJ1bGVcIixcbiAgICBjb21tZW50OiBcIkNvbW1lbnRcIixcbiAgICBkZWNsOiBcIkRlY2xhcmF0aW9uXCIsXG4gICAgZG9jdW1lbnQ6IFwiRG9jdW1lbnRcIixcbiAgICByb290OiBcIlJvb3RcIixcbiAgICBydWxlOiBcIlJ1bGVcIlxufTtcbnZhciBQTFVHSU5fUFJPUFMgPSB7XG4gICAgQXRSdWxlOiB0cnVlLFxuICAgIEF0UnVsZUV4aXQ6IHRydWUsXG4gICAgQ29tbWVudDogdHJ1ZSxcbiAgICBDb21tZW50RXhpdDogdHJ1ZSxcbiAgICBEZWNsYXJhdGlvbjogdHJ1ZSxcbiAgICBEZWNsYXJhdGlvbkV4aXQ6IHRydWUsXG4gICAgRG9jdW1lbnQ6IHRydWUsXG4gICAgRG9jdW1lbnRFeGl0OiB0cnVlLFxuICAgIE9uY2U6IHRydWUsXG4gICAgT25jZUV4aXQ6IHRydWUsXG4gICAgcG9zdGNzc1BsdWdpbjogdHJ1ZSxcbiAgICBwcmVwYXJlOiB0cnVlLFxuICAgIFJvb3Q6IHRydWUsXG4gICAgUm9vdEV4aXQ6IHRydWUsXG4gICAgUnVsZTogdHJ1ZSxcbiAgICBSdWxlRXhpdDogdHJ1ZVxufTtcbnZhciBOT1RfVklTSVRPUlMgPSB7XG4gICAgT25jZTogdHJ1ZSxcbiAgICBwb3N0Y3NzUGx1Z2luOiB0cnVlLFxuICAgIHByZXBhcmU6IHRydWVcbn07XG52YXIgQ0hJTERSRU4gPSAwO1xuZnVuY3Rpb24gaXNQcm9taXNlKG9iaikge1xuICAgIHJldHVybiAodHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihvYmopKSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqLnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50cyhub2RlMikge1xuICAgIHZhciBrZXkgPSBmYWxzZTtcbiAgICB2YXIgdHlwZSA9IFRZUEVfVE9fQ0xBU1NfTkFNRVtub2RlMi50eXBlXTtcbiAgICBpZiAobm9kZTIudHlwZSA9PT0gXCJkZWNsXCIpIHtcbiAgICAgICAga2V5ID0gbm9kZTIucHJvcC50b0xvd2VyQ2FzZSgpO1xuICAgIH0gZWxzZSBpZiAobm9kZTIudHlwZSA9PT0gXCJhdHJ1bGVcIikge1xuICAgICAgICBrZXkgPSBub2RlMi5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIGlmIChrZXkgJiYgbm9kZTIuYXBwZW5kKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgdHlwZSArIFwiLVwiICsga2V5LFxuICAgICAgICAgICAgQ0hJTERSRU4sXG4gICAgICAgICAgICB0eXBlICsgXCJFeGl0XCIsXG4gICAgICAgICAgICB0eXBlICsgXCJFeGl0LVwiICsga2V5XG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICB0eXBlICsgXCItXCIgKyBrZXksXG4gICAgICAgICAgICB0eXBlICsgXCJFeGl0XCIsXG4gICAgICAgICAgICB0eXBlICsgXCJFeGl0LVwiICsga2V5XG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmIChub2RlMi5hcHBlbmQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBDSElMRFJFTixcbiAgICAgICAgICAgIHR5cGUgKyBcIkV4aXRcIlxuICAgICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgdHlwZSArIFwiRXhpdFwiXG4gICAgICAgIF07XG4gICAgfVxufVxuZnVuY3Rpb24gdG9TdGFjayhub2RlMikge1xuICAgIHZhciBldmVudHM7XG4gICAgaWYgKG5vZGUyLnR5cGUgPT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICBldmVudHMgPSBbXG4gICAgICAgICAgICBcIkRvY3VtZW50XCIsXG4gICAgICAgICAgICBDSElMRFJFTixcbiAgICAgICAgICAgIFwiRG9jdW1lbnRFeGl0XCJcbiAgICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwicm9vdFwiKSB7XG4gICAgICAgIGV2ZW50cyA9IFtcbiAgICAgICAgICAgIFwiUm9vdFwiLFxuICAgICAgICAgICAgQ0hJTERSRU4sXG4gICAgICAgICAgICBcIlJvb3RFeGl0XCJcbiAgICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBldmVudHMgPSBnZXRFdmVudHMobm9kZTIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBldmVudEluZGV4OiAwLFxuICAgICAgICBldmVudHM6IGV2ZW50cyxcbiAgICAgICAgaXRlcmF0b3I6IDAsXG4gICAgICAgIG5vZGU6IG5vZGUyLFxuICAgICAgICB2aXNpdG9ySW5kZXg6IDAsXG4gICAgICAgIHZpc2l0b3JzOiBbXVxuICAgIH07XG59XG5mdW5jdGlvbiBjbGVhbk1hcmtzKG5vZGUyKSB7XG4gICAgbm9kZTJbaXNDbGVhbl0gPSBmYWxzZTtcbiAgICBpZiAobm9kZTIubm9kZXMpIG5vZGUyLm5vZGVzLmZvckVhY2goZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgcmV0dXJuIGNsZWFuTWFya3MoaTIpO1xuICAgIH0pO1xuICAgIHJldHVybiBub2RlMjtcbn1cbnZhciBwb3N0Y3NzJDIgPSB7fTtcbnZhciBMYXp5UmVzdWx0JDIgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIExhenlSZXN1bHQyKHByb2Nlc3NvcjIsIGNzcywgb3B0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnN0cmluZ2lmaWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgICAgIHZhciByb290MjtcbiAgICAgICAgaWYgKCh0eXBlb2YgY3NzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKGNzcykpID09PSBcIm9iamVjdFwiICYmIGNzcyAhPT0gbnVsbCAmJiAoY3NzLnR5cGUgPT09IFwicm9vdFwiIHx8IGNzcy50eXBlID09PSBcImRvY3VtZW50XCIpKSB7XG4gICAgICAgICAgICByb290MiA9IGNsZWFuTWFya3MoY3NzKTtcbiAgICAgICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZihjc3MsIExhenlSZXN1bHQyKSB8fCBfaW5zdGFuY2VvZihjc3MsIFJlc3VsdCQyKSkge1xuICAgICAgICAgICAgcm9vdDIgPSBjbGVhbk1hcmtzKGNzcy5yb290KTtcbiAgICAgICAgICAgIGlmIChjc3MubWFwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRzLm1hcCA9PT0gXCJ1bmRlZmluZWRcIikgb3B0cy5tYXAgPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdHMubWFwLmlubGluZSkgb3B0cy5tYXAuaW5saW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgb3B0cy5tYXAucHJldiA9IGNzcy5tYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VyMiA9IHBhcnNlJDI7XG4gICAgICAgICAgICBpZiAob3B0cy5zeW50YXgpIHBhcnNlcjIgPSBvcHRzLnN5bnRheC5wYXJzZTtcbiAgICAgICAgICAgIGlmIChvcHRzLnBhcnNlcikgcGFyc2VyMiA9IG9wdHMucGFyc2VyO1xuICAgICAgICAgICAgaWYgKHBhcnNlcjIucGFyc2UpIHBhcnNlcjIgPSBwYXJzZXIyLnBhcnNlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByb290MiA9IHBhcnNlcjIoY3NzLCBvcHRzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyb290MiAmJiAhcm9vdDJbbXldKSB7XG4gICAgICAgICAgICAgICAgQ29udGFpbmVyJDEucmVidWlsZChyb290Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXN1bHQgPSBuZXcgUmVzdWx0JDIocHJvY2Vzc29yMiwgcm9vdDIsIG9wdHMpO1xuICAgICAgICB0aGlzLmhlbHBlcnMgPSBfZXh0ZW5kcyh7fSwgcG9zdGNzcyQyLCB7XG4gICAgICAgICAgICBwb3N0Y3NzOiBwb3N0Y3NzJDIsXG4gICAgICAgICAgICByZXN1bHQ6IHRoaXMucmVzdWx0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSB0aGlzLnByb2Nlc3Nvci5wbHVnaW5zLm1hcChmdW5jdGlvbihwbHVnaW4yMikge1xuICAgICAgICAgICAgaWYgKCh0eXBlb2YgcGx1Z2luMjIgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YocGx1Z2luMjIpKSA9PT0gXCJvYmplY3RcIiAmJiBwbHVnaW4yMi5wcmVwYXJlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBwbHVnaW4yMiwgcGx1Z2luMjIucHJlcGFyZShfdGhpcy5yZXN1bHQpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbjIyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IExhenlSZXN1bHQyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uYXN5bmMgPSBmdW5jdGlvbiBhc3luYygpIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmVycm9yKTtcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2VkKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMucmVzdWx0KTtcbiAgICAgICAgaWYgKCF0aGlzLnByb2Nlc3NpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZyA9IHRoaXMucnVuQXN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzaW5nO1xuICAgIH07XG4gICAgX3Byb3RvLmNhdGNoID0gZnVuY3Rpb24gX2NhdGNoKG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXN5bmMoKS5jYXRjaChvblJlamVjdGVkKTtcbiAgICB9O1xuICAgIF9wcm90by5maW5hbGx5ID0gZnVuY3Rpb24gX2ZpbmFsbHkob25GaW5hbGx5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzeW5jKCkudGhlbihvbkZpbmFsbHksIG9uRmluYWxseSk7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0QXN5bmNFcnJvciA9IGZ1bmN0aW9uIGdldEFzeW5jRXJyb3IoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVzZSBwcm9jZXNzKGNzcykudGhlbihjYikgdG8gd29yayB3aXRoIGFzeW5jIHBsdWdpbnNcIik7XG4gICAgfTtcbiAgICBfcHJvdG8uaGFuZGxlRXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnJvciwgbm9kZTIpIHtcbiAgICAgICAgdmFyIHBsdWdpbjIyID0gdGhpcy5yZXN1bHQubGFzdFBsdWdpbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChub2RlMikgbm9kZTIuYWRkVG9FcnJvcihlcnJvcik7XG4gICAgICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gXCJDc3NTeW50YXhFcnJvclwiICYmICFlcnJvci5wbHVnaW4pIHtcbiAgICAgICAgICAgICAgICBlcnJvci5wbHVnaW4gPSBwbHVnaW4yMi5wb3N0Y3NzUGx1Z2luO1xuICAgICAgICAgICAgICAgIGVycm9yLnNldE1lc3NhZ2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGx1Z2luMjIucG9zdGNzc1ZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwbHVnaW5OYW1lID0gcGx1Z2luMjIucG9zdGNzc1BsdWdpbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBsdWdpblZlciA9IHBsdWdpbjIyLnBvc3Rjc3NWZXJzaW9uO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnVudGltZVZlciA9IHRoaXMucmVzdWx0LnByb2Nlc3Nvci52ZXJzaW9uO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYTIgPSBwbHVnaW5WZXIuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHJ1bnRpbWVWZXIuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYTJbMF0gIT09IGJbMF0gfHwgcGFyc2VJbnQoYTJbMV0pID4gcGFyc2VJbnQoYlsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmtub3duIGVycm9yIGZyb20gUG9zdENTUyBwbHVnaW4uIFlvdXIgY3VycmVudCBQb3N0Q1NTIHZlcnNpb24gaXMgXCIgKyBydW50aW1lVmVyICsgXCIsIGJ1dCBcIiArIHBsdWdpbk5hbWUgKyBcIiB1c2VzIFwiICsgcGx1Z2luVmVyICsgXCIuIFBlcmhhcHMgdGhpcyBpcyB0aGUgc291cmNlIG9mIHRoZSBlcnJvciBiZWxvdy5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS5lcnJvcikgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9O1xuICAgIF9wcm90by5wcmVwYXJlVmlzaXRvcnMgPSBmdW5jdGlvbiBwcmVwYXJlVmlzaXRvcnMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0ge307XG4gICAgICAgIHZhciBhZGQgPSBmdW5jdGlvbihwbHVnaW4yMiwgdHlwZSwgY2IpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMubGlzdGVuZXJzW3R5cGVdKSBfdGhpcy5saXN0ZW5lcnNbdHlwZV0gPSBbXTtcbiAgICAgICAgICAgIF90aGlzLmxpc3RlbmVyc1t0eXBlXS5wdXNoKFtcbiAgICAgICAgICAgICAgICBwbHVnaW4yMixcbiAgICAgICAgICAgICAgICBjYlxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHRoaXMucGx1Z2lucyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBwbHVnaW4yMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgaWYgKCh0eXBlb2YgcGx1Z2luMjIgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YocGx1Z2luMjIpKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgZXZlbnQgaW4gcGx1Z2luMjIpe1xuICAgICAgICAgICAgICAgICAgICBpZiAoIVBMVUdJTl9QUk9QU1tldmVudF0gJiYgL15bQS1aXS8udGVzdChldmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZXZlbnQgXCIgKyBldmVudCArIFwiIGluIFwiICsgcGx1Z2luMjIucG9zdGNzc1BsdWdpbiArIFwiLiBUcnkgdG8gdXBkYXRlIFBvc3RDU1MgKFwiICsgdGhpcy5wcm9jZXNzb3IudmVyc2lvbiArIFwiIG5vdykuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghTk9UX1ZJU0lUT1JTW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90eXBlX29mKHBsdWdpbjIyW2V2ZW50XSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGZpbHRlciBpbiBwbHVnaW4yMltldmVudF0pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyID09PSBcIipcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkKHBsdWdpbjIyLCBldmVudCwgcGx1Z2luMjJbZXZlbnRdW2ZpbHRlcl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkKHBsdWdpbjIyLCBldmVudCArIFwiLVwiICsgZmlsdGVyLnRvTG93ZXJDYXNlKCksIHBsdWdpbjIyW2V2ZW50XVtmaWx0ZXJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbjIyW2V2ZW50XSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkKHBsdWdpbjIyLCBldmVudCwgcGx1Z2luMjJbZXZlbnRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhc0xpc3RlbmVyID0gT2JqZWN0LmtleXModGhpcy5saXN0ZW5lcnMpLmxlbmd0aCA+IDA7XG4gICAgfTtcbiAgICBfcHJvdG8ucnVuQXN5bmMgPSBmdW5jdGlvbiBydW5Bc3luYygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaTIsIHBsdWdpbjIyLCBwcm9taXNlLCBlcnJvciwgcm9vdDIsIHN0YWNrLCBwcm9taXNlMSwgZTIsIG5vZGUyLCBfbG9vcCwgX2l0ZXJhdG9yLCBfc3RlcDtcbiAgICAgICAgICAgIHJldHVybiBfdHNfZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKF9zdGF0ZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaChfc3RhdGUubGFiZWwpe1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wbHVnaW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaTIgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaTIgPCBfdGhpcy5wbHVnaW5zLmxlbmd0aCkpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA2XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luMjIgPSBfdGhpcy5wbHVnaW5zW2kyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBfdGhpcy5ydW5PblJvb3QocGx1Z2luMjIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Byb21pc2UocHJvbWlzZSkpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA1XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnRyeXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA1XG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDVcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF90aGlzLmhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgaTIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcmVwYXJlVmlzaXRvcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuaGFzTGlzdGVuZXIpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxOFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QyID0gX3RoaXMucmVzdWx0LnJvb3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUubGFiZWwgPSA3O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISFyb290Mltpc0NsZWFuXSkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE0XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdDJbaXNDbGVhbl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9TdGFjayhyb290MilcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUubGFiZWwgPSA4O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShzdGFjay5sZW5ndGggPiAwKSkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEzXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZTEgPSBfdGhpcy52aXNpdFRpY2soc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Byb21pc2UocHJvbWlzZTEpKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTJcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUubGFiZWwgPSA5O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUudHJ5cy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDExLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMlxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZTFcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEyXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICAgICAgZTIgPSBfc3RhdGUuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTIgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXS5ub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX3RoaXMuaGFuZGxlRXJyb3IoZTIsIG5vZGUyKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA4XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDdcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmxpc3RlbmVycy5PbmNlRXhpdCkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE4XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3N0ZXBfdmFsdWUsIHBsdWdpbjIyLCB2aXNpdG9yLCByb290cywgZTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90c19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24oX3N0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaChfc3RhdGUubGFiZWwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zdGVwX3ZhbHVlID0gX3N0ZXAudmFsdWUsIHBsdWdpbjIyID0gX3N0ZXBfdmFsdWVbMF0sIHZpc2l0b3IgPSBfc3RlcF92YWx1ZVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXN1bHQubGFzdFBsdWdpbiA9IHBsdWdpbjIyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnRyeXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgN1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJvb3QyLnR5cGUgPT09IFwiZG9jdW1lbnRcIikpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RzID0gcm9vdDIubm9kZXMubWFwKGZ1bmN0aW9uKHN1YlJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3Ioc3ViUm9vdCwgX3RoaXMuaGVscGVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwocm9vdHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0b3Iocm9vdDIsIF90aGlzLmhlbHBlcnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5sYWJlbCA9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgN1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZTIgPSBfc3RhdGUuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF90aGlzLmhhbmRsZUVycm9yKGUyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShfdGhpcy5saXN0ZW5lcnMuT25jZUV4aXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLmxhYmVsID0gMTU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZSkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE4XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90c192YWx1ZXMoX2xvb3AoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLmxhYmVsID0gMTc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTVcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN0cmluZ2lmeSgpXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSgpO1xuICAgIH07XG4gICAgX3Byb3RvLnJ1bk9uUm9vdCA9IGZ1bmN0aW9uIHJ1bk9uUm9vdChwbHVnaW4yMikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnJlc3VsdC5sYXN0UGx1Z2luID0gcGx1Z2luMjI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBwbHVnaW4yMiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihwbHVnaW4yMikpID09PSBcIm9iamVjdFwiICYmIHBsdWdpbjIyLk9uY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXN1bHQucm9vdC50eXBlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3RzID0gdGhpcy5yZXN1bHQucm9vdC5ub2Rlcy5tYXAoZnVuY3Rpb24ocm9vdDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwbHVnaW4yMi5PbmNlKHJvb3QyLCBfdGhpcy5oZWxwZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Byb21pc2Uocm9vdHNbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocm9vdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb290cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbjIyLk9uY2UodGhpcy5yZXN1bHQucm9vdCwgdGhpcy5oZWxwZXJzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbjIyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGx1Z2luMjIodGhpcy5yZXN1bHQucm9vdCwgdGhpcy5yZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5zdHJpbmdpZnkgPSBmdW5jdGlvbiBzdHJpbmdpZnkoKSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9yKSB0aHJvdyB0aGlzLmVycm9yO1xuICAgICAgICBpZiAodGhpcy5zdHJpbmdpZmllZCkgcmV0dXJuIHRoaXMucmVzdWx0O1xuICAgICAgICB0aGlzLnN0cmluZ2lmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zeW5jKCk7XG4gICAgICAgIHZhciBvcHRzID0gdGhpcy5yZXN1bHQub3B0cztcbiAgICAgICAgdmFyIHN0ciA9IHN0cmluZ2lmeSQyO1xuICAgICAgICBpZiAob3B0cy5zeW50YXgpIHN0ciA9IG9wdHMuc3ludGF4LnN0cmluZ2lmeTtcbiAgICAgICAgaWYgKG9wdHMuc3RyaW5naWZpZXIpIHN0ciA9IG9wdHMuc3RyaW5naWZpZXI7XG4gICAgICAgIGlmIChzdHIuc3RyaW5naWZ5KSBzdHIgPSBzdHIuc3RyaW5naWZ5O1xuICAgICAgICB2YXIgbWFwID0gbmV3IE1hcEdlbmVyYXRvciQxKHN0ciwgdGhpcy5yZXN1bHQucm9vdCwgdGhpcy5yZXN1bHQub3B0cyk7XG4gICAgICAgIHZhciBkYXRhID0gbWFwLmdlbmVyYXRlKCk7XG4gICAgICAgIHRoaXMucmVzdWx0LmNzcyA9IGRhdGFbMF07XG4gICAgICAgIHRoaXMucmVzdWx0Lm1hcCA9IGRhdGFbMV07XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgICB9O1xuICAgIF9wcm90by5zeW5jID0gZnVuY3Rpb24gc3luYygpIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHRocm93IHRoaXMuZXJyb3I7XG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3NlZCkgcmV0dXJuIHRoaXMucmVzdWx0O1xuICAgICAgICB0aGlzLnByb2Nlc3NlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3NpbmcpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuZ2V0QXN5bmNFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHRoaXMucGx1Z2lucyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBwbHVnaW4yMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLnJ1bk9uUm9vdChwbHVnaW4yMik7XG4gICAgICAgICAgICBpZiAoaXNQcm9taXNlKHByb21pc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5nZXRBc3luY0Vycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVwYXJlVmlzaXRvcnMoKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHZhciByb290MiA9IHRoaXMucmVzdWx0LnJvb3Q7XG4gICAgICAgICAgICB3aGlsZSghcm9vdDJbaXNDbGVhbl0pe1xuICAgICAgICAgICAgICAgIHJvb3QyW2lzQ2xlYW5dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLndhbGtTeW5jKHJvb3QyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3RlbmVycy5PbmNlRXhpdCkge1xuICAgICAgICAgICAgICAgIGlmIChyb290Mi50eXBlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IxID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHJvb3QyLm5vZGVzKSwgX3N0ZXAxOyAhKF9zdGVwMSA9IF9pdGVyYXRvcjEoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1YlJvb3QgPSBfc3RlcDEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0U3luYyh0aGlzLmxpc3RlbmVycy5PbmNlRXhpdCwgc3ViUm9vdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0U3luYyh0aGlzLmxpc3RlbmVycy5PbmNlRXhpdCwgcm9vdDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQ7XG4gICAgfTtcbiAgICBfcHJvdG8udGhlbiA9IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKCEoXCJmcm9tXCIgaW4gdGhpcy5vcHRzKSkge1xuICAgICAgICAgICAgICAgIHdhcm5PbmNlJDEoXCJXaXRob3V0IGBmcm9tYCBvcHRpb24gUG9zdENTUyBjb3VsZCBnZW5lcmF0ZSB3cm9uZyBzb3VyY2UgbWFwIGFuZCB3aWxsIG5vdCBmaW5kIEJyb3dzZXJzbGlzdCBjb25maWcuIFNldCBpdCB0byBDU1MgZmlsZSBwYXRoIG9yIHRvIGB1bmRlZmluZWRgIHRvIHByZXZlbnQgdGhpcyB3YXJuaW5nLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hc3luYygpLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH07XG4gICAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNzcztcbiAgICB9O1xuICAgIF9wcm90by52aXNpdFN5bmMgPSBmdW5jdGlvbiB2aXNpdFN5bmModmlzaXRvcnMsIG5vZGUyKSB7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHZpc2l0b3JzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIF9zdGVwX3ZhbHVlID0gX3N0ZXAudmFsdWUsIHBsdWdpbjIyID0gX3N0ZXBfdmFsdWVbMF0sIHZpc2l0b3IgPSBfc3RlcF92YWx1ZVsxXTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0Lmxhc3RQbHVnaW4gPSBwbHVnaW4yMjtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gdm9pZCAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gdmlzaXRvcihub2RlMiwgdGhpcy5oZWxwZXJzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5oYW5kbGVFcnJvcihlMiwgbm9kZTIucHJveHlPZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZTIudHlwZSAhPT0gXCJyb290XCIgJiYgbm9kZTIudHlwZSAhPT0gXCJkb2N1bWVudFwiICYmICFub2RlMi5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1Byb21pc2UocHJvbWlzZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmdldEFzeW5jRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnZpc2l0VGljayA9IGZ1bmN0aW9uIHZpc2l0VGljayhzdGFjaykge1xuICAgICAgICB2YXIgdmlzaXQyID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBub2RlMiA9IHZpc2l0Mi5ub2RlLCB2aXNpdG9ycyA9IHZpc2l0Mi52aXNpdG9ycztcbiAgICAgICAgaWYgKG5vZGUyLnR5cGUgIT09IFwicm9vdFwiICYmIG5vZGUyLnR5cGUgIT09IFwiZG9jdW1lbnRcIiAmJiAhbm9kZTIucGFyZW50KSB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlzaXRvcnMubGVuZ3RoID4gMCAmJiB2aXNpdDIudmlzaXRvckluZGV4IDwgdmlzaXRvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgX3Zpc2l0b3JzX3Zpc2l0Ml92aXNpdG9ySW5kZXggPSB2aXNpdG9yc1t2aXNpdDIudmlzaXRvckluZGV4XSwgcGx1Z2luMjIgPSBfdmlzaXRvcnNfdmlzaXQyX3Zpc2l0b3JJbmRleFswXSwgdmlzaXRvciA9IF92aXNpdG9yc192aXNpdDJfdmlzaXRvckluZGV4WzFdO1xuICAgICAgICAgICAgdmlzaXQyLnZpc2l0b3JJbmRleCArPSAxO1xuICAgICAgICAgICAgaWYgKHZpc2l0Mi52aXNpdG9ySW5kZXggPT09IHZpc2l0b3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZpc2l0Mi52aXNpdG9ycyA9IFtdO1xuICAgICAgICAgICAgICAgIHZpc2l0Mi52aXNpdG9ySW5kZXggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXN1bHQubGFzdFBsdWdpbiA9IHBsdWdpbjIyO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRvcihub2RlMi50b1Byb3h5KCksIHRoaXMuaGVscGVycyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuaGFuZGxlRXJyb3IoZTIsIG5vZGUyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmlzaXQyLml0ZXJhdG9yICE9PSAwKSB7XG4gICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSB2aXNpdDIuaXRlcmF0b3I7XG4gICAgICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgICAgICB3aGlsZShjaGlsZCA9IG5vZGUyLm5vZGVzW25vZGUyLmluZGV4ZXNbaXRlcmF0b3JdXSl7XG4gICAgICAgICAgICAgICAgbm9kZTIuaW5kZXhlc1tpdGVyYXRvcl0gKz0gMTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkW2lzQ2xlYW5dKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkW2lzQ2xlYW5dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh0b1N0YWNrKGNoaWxkKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2aXNpdDIuaXRlcmF0b3IgPSAwO1xuICAgICAgICAgICAgZGVsZXRlIG5vZGUyLmluZGV4ZXNbaXRlcmF0b3JdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBldmVudHMgPSB2aXNpdDIuZXZlbnRzO1xuICAgICAgICB3aGlsZSh2aXNpdDIuZXZlbnRJbmRleCA8IGV2ZW50cy5sZW5ndGgpe1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gZXZlbnRzW3Zpc2l0Mi5ldmVudEluZGV4XTtcbiAgICAgICAgICAgIHZpc2l0Mi5ldmVudEluZGV4ICs9IDE7XG4gICAgICAgICAgICBpZiAoZXZlbnQgPT09IENISUxEUkVOKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUyLm5vZGVzICYmIG5vZGUyLm5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlMltpc0NsZWFuXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZpc2l0Mi5pdGVyYXRvciA9IG5vZGUyLmdldEl0ZXJhdG9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5saXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICAgICAgICAgICAgdmlzaXQyLnZpc2l0b3JzID0gdGhpcy5saXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICB9O1xuICAgIF9wcm90by53YWxrU3luYyA9IGZ1bmN0aW9uIHdhbGtTeW5jKG5vZGUyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG5vZGUyW2lzQ2xlYW5dID0gdHJ1ZTtcbiAgICAgICAgdmFyIGV2ZW50cyA9IGdldEV2ZW50cyhub2RlMik7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKGV2ZW50cyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBldmVudCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGV2ZW50ID09PSBDSElMRFJFTikge1xuICAgICAgICAgICAgICAgIGlmIChub2RlMi5ub2Rlcykge1xuICAgICAgICAgICAgICAgICAgICBub2RlMi5lYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkW2lzQ2xlYW5dKSBfdGhpcy53YWxrU3luYyhjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHZpc2l0b3JzID0gdGhpcy5saXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICAgICAgICAgIGlmICh2aXNpdG9ycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52aXNpdFN5bmModmlzaXRvcnMsIG5vZGUyLnRvUHJveHkoKSkpIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by53YXJuaW5ncyA9IGZ1bmN0aW9uIHdhcm5pbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zeW5jKCkud2FybmluZ3MoKTtcbiAgICB9O1xuICAgIF9jcmVhdGVfY2xhc3MoTGF6eVJlc3VsdDIsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNvbnRlbnRcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmluZ2lmeSgpLmNvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjc3NcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmluZ2lmeSgpLmNzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcIm1hcFwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5KCkubWFwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwibWVzc2FnZXNcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN5bmMoKS5tZXNzYWdlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcIm9wdHNcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdC5vcHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwicHJvY2Vzc29yXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQucHJvY2Vzc29yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwicm9vdFwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3luYygpLnJvb3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogU3ltYm9sLnRvU3RyaW5nVGFnLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiTGF6eVJlc3VsdFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIExhenlSZXN1bHQyO1xufSgpO1xuTGF6eVJlc3VsdCQyLnJlZ2lzdGVyUG9zdGNzcyA9IGZ1bmN0aW9uKGRlcGVuZGFudCkge1xuICAgIHBvc3Rjc3MkMiA9IGRlcGVuZGFudDtcbn07XG52YXIgbGF6eVJlc3VsdCA9IExhenlSZXN1bHQkMjtcbkxhenlSZXN1bHQkMi5kZWZhdWx0ID0gTGF6eVJlc3VsdCQyO1xuUm9vdCQzLnJlZ2lzdGVyTGF6eVJlc3VsdChMYXp5UmVzdWx0JDIpO1xuRG9jdW1lbnQkMi5yZWdpc3RlckxhenlSZXN1bHQoTGF6eVJlc3VsdCQyKTtcbnZhciBNYXBHZW5lcmF0b3IyMiA9IG1hcEdlbmVyYXRvcjtcbnZhciBzdHJpbmdpZnkkMSA9IHN0cmluZ2lmeV8xO1xudmFyIHdhcm5PbmNlMjIgPSB3YXJuT25jZSQyO1xudmFyIHBhcnNlJDEgPSBwYXJzZV8xO1xudmFyIFJlc3VsdCQxID0gcmVzdWx0O1xudmFyIE5vV29ya1Jlc3VsdCQxID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBOb1dvcmtSZXN1bHQyKHByb2Nlc3NvcjIsIGNzcywgb3B0cykge1xuICAgICAgICBjc3MgPSBjc3MudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5zdHJpbmdpZmllZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcm9jZXNzb3IgPSBwcm9jZXNzb3IyO1xuICAgICAgICB0aGlzLl9jc3MgPSBjc3M7XG4gICAgICAgIHRoaXMuX29wdHMgPSBvcHRzO1xuICAgICAgICB0aGlzLl9tYXAgPSB2b2lkIDA7XG4gICAgICAgIHZhciByb290MjtcbiAgICAgICAgdmFyIHN0ciA9IHN0cmluZ2lmeSQxO1xuICAgICAgICB0aGlzLnJlc3VsdCA9IG5ldyBSZXN1bHQkMSh0aGlzLl9wcm9jZXNzb3IsIHJvb3QyLCB0aGlzLl9vcHRzKTtcbiAgICAgICAgdGhpcy5yZXN1bHQuY3NzID0gY3NzO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnJlc3VsdCwgXCJyb290XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnJvb3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbWFwID0gbmV3IE1hcEdlbmVyYXRvcjIyKHN0ciwgcm9vdDIsIHRoaXMuX29wdHMsIGNzcyk7XG4gICAgICAgIGlmIChtYXAuaXNNYXAoKSkge1xuICAgICAgICAgICAgdmFyIF9tYXBfZ2VuZXJhdGUgPSBtYXAuZ2VuZXJhdGUoKSwgZ2VuZXJhdGVkQ1NTID0gX21hcF9nZW5lcmF0ZVswXSwgZ2VuZXJhdGVkTWFwID0gX21hcF9nZW5lcmF0ZVsxXTtcbiAgICAgICAgICAgIGlmIChnZW5lcmF0ZWRDU1MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5jc3MgPSBnZW5lcmF0ZWRDU1M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2VuZXJhdGVkTWFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQubWFwID0gZ2VuZXJhdGVkTWFwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFwLmNsZWFyQW5ub3RhdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQuY3NzID0gbWFwLmNzcztcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gTm9Xb3JrUmVzdWx0Mi5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmFzeW5jID0gZnVuY3Rpb24gYXN5bmMoKSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9yKSByZXR1cm4gUHJvbWlzZS5yZWplY3QodGhpcy5lcnJvcik7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5yZXN1bHQpO1xuICAgIH07XG4gICAgX3Byb3RvLmNhdGNoID0gZnVuY3Rpb24gX2NhdGNoKG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXN5bmMoKS5jYXRjaChvblJlamVjdGVkKTtcbiAgICB9O1xuICAgIF9wcm90by5maW5hbGx5ID0gZnVuY3Rpb24gX2ZpbmFsbHkob25GaW5hbGx5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzeW5jKCkudGhlbihvbkZpbmFsbHksIG9uRmluYWxseSk7XG4gICAgfTtcbiAgICBfcHJvdG8uc3luYyA9IGZ1bmN0aW9uIHN5bmMoKSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9yKSB0aHJvdyB0aGlzLmVycm9yO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQ7XG4gICAgfTtcbiAgICBfcHJvdG8udGhlbiA9IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKCEoXCJmcm9tXCIgaW4gdGhpcy5fb3B0cykpIHtcbiAgICAgICAgICAgICAgICB3YXJuT25jZTIyKFwiV2l0aG91dCBgZnJvbWAgb3B0aW9uIFBvc3RDU1MgY291bGQgZ2VuZXJhdGUgd3Jvbmcgc291cmNlIG1hcCBhbmQgd2lsbCBub3QgZmluZCBCcm93c2Vyc2xpc3QgY29uZmlnLiBTZXQgaXQgdG8gQ1NTIGZpbGUgcGF0aCBvciB0byBgdW5kZWZpbmVkYCB0byBwcmV2ZW50IHRoaXMgd2FybmluZy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICB9O1xuICAgIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3NzO1xuICAgIH07XG4gICAgX3Byb3RvLndhcm5pbmdzID0gZnVuY3Rpb24gd2FybmluZ3MoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIF9jcmVhdGVfY2xhc3MoTm9Xb3JrUmVzdWx0MiwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY29udGVudFwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0LmNzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNzc1wiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0LmNzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcIm1hcFwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0Lm1hcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcIm1lc3NhZ2VzXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJvcHRzXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQub3B0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInByb2Nlc3NvclwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0LnByb2Nlc3NvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInJvb3RcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yb290KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb290O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcm9vdDI7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlcjIgPSBwYXJzZSQxO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QyID0gcGFyc2VyMih0aGlzLl9jc3MsIHRoaXMuX29wdHMpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5lcnJvcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yb290ID0gcm9vdDI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb290MjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogU3ltYm9sLnRvU3RyaW5nVGFnLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiTm9Xb3JrUmVzdWx0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gTm9Xb3JrUmVzdWx0Mjtcbn0oKTtcbnZhciBub1dvcmtSZXN1bHQgPSBOb1dvcmtSZXN1bHQkMTtcbk5vV29ya1Jlc3VsdCQxLmRlZmF1bHQgPSBOb1dvcmtSZXN1bHQkMTtcbnZhciBOb1dvcmtSZXN1bHQyMiA9IG5vV29ya1Jlc3VsdDtcbnZhciBMYXp5UmVzdWx0JDEgPSBsYXp5UmVzdWx0O1xudmFyIERvY3VtZW50JDEgPSBkb2N1bWVudCQxJDI7XG52YXIgUm9vdCQyID0gcm9vdDtcbnZhciBQcm9jZXNzb3IkMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gUHJvY2Vzc29yMihwbHVnaW5zKSB7XG4gICAgICAgIGlmIChwbHVnaW5zID09PSB2b2lkIDApIHBsdWdpbnMgPSBbXTtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gXCI4LjQuMzhcIjtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gdGhpcy5ub3JtYWxpemUocGx1Z2lucyk7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBQcm9jZXNzb3IyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8ubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKHBsdWdpbnMpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBbXTtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UocGx1Z2lucyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBpMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGkyLnBvc3Rjc3MgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpMiA9IGkyKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkyLnBvc3Rjc3MpIHtcbiAgICAgICAgICAgICAgICBpMiA9IGkyLnBvc3Rjc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBpMiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihpMikpID09PSBcIm9iamVjdFwiICYmIEFycmF5LmlzQXJyYXkoaTIucGx1Z2lucykpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkID0gbm9ybWFsaXplZC5jb25jYXQoaTIucGx1Z2lucyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCh0eXBlb2YgaTIgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YoaTIpKSA9PT0gXCJvYmplY3RcIiAmJiBpMi5wb3N0Y3NzUGx1Z2luKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZC5wdXNoKGkyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGkyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkLnB1c2goaTIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgodHlwZW9mIGkyID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKGkyKSkgPT09IFwib2JqZWN0XCIgJiYgKGkyLnBhcnNlIHx8IGkyLnN0cmluZ2lmeSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvc3RDU1Mgc3ludGF4ZXMgY2Fubm90IGJlIHVzZWQgYXMgcGx1Z2lucy4gSW5zdGVhZCwgcGxlYXNlIHVzZSBvbmUgb2YgdGhlIHN5bnRheC9wYXJzZXIvc3RyaW5naWZpZXIgb3B0aW9ucyBhcyBvdXRsaW5lZCBpbiB5b3VyIFBvc3RDU1MgcnVubmVyIGRvY3VtZW50YXRpb24uXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGkyICsgXCIgaXMgbm90IGEgUG9zdENTUyBwbHVnaW5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gICAgfTtcbiAgICBfcHJvdG8ucHJvY2VzcyA9IGZ1bmN0aW9uIHByb2Nlc3MxKGNzcywgb3B0cykge1xuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSBvcHRzID0ge307XG4gICAgICAgIGlmICghdGhpcy5wbHVnaW5zLmxlbmd0aCAmJiAhb3B0cy5wYXJzZXIgJiYgIW9wdHMuc3RyaW5naWZpZXIgJiYgIW9wdHMuc3ludGF4KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vV29ya1Jlc3VsdDIyKHRoaXMsIGNzcywgb3B0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExhenlSZXN1bHQkMSh0aGlzLCBjc3MsIG9wdHMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8udXNlID0gZnVuY3Rpb24gdXNlKHBsdWdpbjIyKSB7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IHRoaXMucGx1Z2lucy5jb25jYXQodGhpcy5ub3JtYWxpemUoW1xuICAgICAgICAgICAgcGx1Z2luMjJcbiAgICAgICAgXSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBQcm9jZXNzb3IyO1xufSgpO1xudmFyIHByb2Nlc3NvciA9IFByb2Nlc3NvciQxO1xuUHJvY2Vzc29yJDEuZGVmYXVsdCA9IFByb2Nlc3NvciQxO1xuUm9vdCQyLnJlZ2lzdGVyUHJvY2Vzc29yKFByb2Nlc3NvciQxKTtcbkRvY3VtZW50JDEucmVnaXN0ZXJQcm9jZXNzb3IoUHJvY2Vzc29yJDEpO1xudmFyIERlY2xhcmF0aW9uJDEgPSBkZWNsYXJhdGlvbjtcbnZhciBQcmV2aW91c01hcDIyID0gcHJldmlvdXNNYXA7XG52YXIgQ29tbWVudCQxID0gY29tbWVudDtcbnZhciBBdFJ1bGUkMSA9IGF0UnVsZTtcbnZhciBJbnB1dCQxID0gaW5wdXQ7XG52YXIgUm9vdCQxID0gcm9vdDtcbnZhciBSdWxlJDEgPSBydWxlO1xuZnVuY3Rpb24gZnJvbUpTT04kMShqc29uLCBpbnB1dHMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShqc29uKSkgcmV0dXJuIGpzb24ubWFwKGZ1bmN0aW9uKG4yKSB7XG4gICAgICAgIHJldHVybiBmcm9tSlNPTiQxKG4yKTtcbiAgICB9KTtcbiAgICB2YXIgb3duSW5wdXRzID0ganNvbi5pbnB1dHMsIGRlZmF1bHRzID0gX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UoanNvbiwgW1xuICAgICAgICBcImlucHV0c1wiXG4gICAgXSk7XG4gICAgaWYgKG93bklucHV0cykge1xuICAgICAgICBpbnB1dHMgPSBbXTtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uob3duSW5wdXRzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIGlucHV0MiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGlucHV0SHlkcmF0ZWQgPSBfZXh0ZW5kcyh7fSwgaW5wdXQyLCB7XG4gICAgICAgICAgICAgICAgX19wcm90b19fOiBJbnB1dCQxLnByb3RvdHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaW5wdXRIeWRyYXRlZC5tYXApIHtcbiAgICAgICAgICAgICAgICBpbnB1dEh5ZHJhdGVkLm1hcCA9IF9leHRlbmRzKHt9LCBpbnB1dEh5ZHJhdGVkLm1hcCwge1xuICAgICAgICAgICAgICAgICAgICBfX3Byb3RvX186IFByZXZpb3VzTWFwMjIucHJvdG90eXBlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dHMucHVzaChpbnB1dEh5ZHJhdGVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmYXVsdHMubm9kZXMpIHtcbiAgICAgICAgZGVmYXVsdHMubm9kZXMgPSBqc29uLm5vZGVzLm1hcChmdW5jdGlvbihuMikge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21KU09OJDEobjIsIGlucHV0cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZGVmYXVsdHMuc291cmNlKSB7XG4gICAgICAgIHZhciBfZGVmYXVsdHNfc291cmNlID0gZGVmYXVsdHMuc291cmNlLCBpbnB1dElkID0gX2RlZmF1bHRzX3NvdXJjZS5pbnB1dElkLCBzb3VyY2UgPSBfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZShfZGVmYXVsdHNfc291cmNlLCBbXG4gICAgICAgICAgICBcImlucHV0SWRcIlxuICAgICAgICBdKTtcbiAgICAgICAgZGVmYXVsdHMuc291cmNlID0gc291cmNlO1xuICAgICAgICBpZiAoaW5wdXRJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBkZWZhdWx0cy5zb3VyY2UuaW5wdXQgPSBpbnB1dHNbaW5wdXRJZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZmF1bHRzLnR5cGUgPT09IFwicm9vdFwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgUm9vdCQxKGRlZmF1bHRzKTtcbiAgICB9IGVsc2UgaWYgKGRlZmF1bHRzLnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjbGFyYXRpb24kMShkZWZhdWx0cyk7XG4gICAgfSBlbHNlIGlmIChkZWZhdWx0cy50eXBlID09PSBcInJ1bGVcIikge1xuICAgICAgICByZXR1cm4gbmV3IFJ1bGUkMShkZWZhdWx0cyk7XG4gICAgfSBlbHNlIGlmIChkZWZhdWx0cy50eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgICAgICByZXR1cm4gbmV3IENvbW1lbnQkMShkZWZhdWx0cyk7XG4gICAgfSBlbHNlIGlmIChkZWZhdWx0cy50eXBlID09PSBcImF0cnVsZVwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXRSdWxlJDEoZGVmYXVsdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbm9kZSB0eXBlOiBcIiArIGpzb24udHlwZSk7XG4gICAgfVxufVxudmFyIGZyb21KU09OXzEgPSBmcm9tSlNPTiQxO1xuZnJvbUpTT04kMS5kZWZhdWx0ID0gZnJvbUpTT04kMTtcbnZhciBDc3NTeW50YXhFcnJvcjIyID0gY3NzU3ludGF4RXJyb3I7XG52YXIgRGVjbGFyYXRpb24yMiA9IGRlY2xhcmF0aW9uO1xudmFyIExhenlSZXN1bHQyMiA9IGxhenlSZXN1bHQ7XG52YXIgQ29udGFpbmVyMjIgPSBjb250YWluZXI7XG52YXIgUHJvY2Vzc29yMjIgPSBwcm9jZXNzb3I7XG52YXIgc3RyaW5naWZ5JDYgPSBzdHJpbmdpZnlfMTtcbnZhciBmcm9tSlNPTiA9IGZyb21KU09OXzE7XG52YXIgRG9jdW1lbnQyMjIgPSBkb2N1bWVudCQxJDI7XG52YXIgV2FybmluZzIyID0gd2FybmluZztcbnZhciBDb21tZW50MjIgPSBjb21tZW50O1xudmFyIEF0UnVsZTIyID0gYXRSdWxlO1xudmFyIFJlc3VsdDIyID0gcmVzdWx0O1xudmFyIElucHV0MjIgPSBpbnB1dDtcbnZhciBwYXJzZSA9IHBhcnNlXzE7XG52YXIgbGlzdCA9IGxpc3RfMTtcbnZhciBSdWxlMjIgPSBydWxlO1xudmFyIFJvb3QyMiA9IHJvb3Q7XG52YXIgTm9kZTIyID0gbm9kZTtcbmZ1bmN0aW9uIHBvc3Rjc3MoKSB7XG4gICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGx1Z2lucyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICBwbHVnaW5zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBpZiAocGx1Z2lucy5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShwbHVnaW5zWzBdKSkge1xuICAgICAgICBwbHVnaW5zID0gcGx1Z2luc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9jZXNzb3IyMihwbHVnaW5zKTtcbn1cbnBvc3Rjc3MucGx1Z2luID0gZnVuY3Rpb24gcGx1Z2luMihuYW1lLCBpbml0aWFsaXplcikge1xuICAgIHZhciB3YXJuaW5nUHJpbnRlZCA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIGNyZWF0b3IoKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuICYmICF3YXJuaW5nUHJpbnRlZCkge1xuICAgICAgICAgICAgd2FybmluZ1ByaW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKG5hbWUgKyBcIjogcG9zdGNzcy5wbHVnaW4gd2FzIGRlcHJlY2F0ZWQuIE1pZ3JhdGlvbiBndWlkZTpcXG5odHRwczovL2V2aWxtYXJ0aWFucy5jb20vY2hyb25pY2xlcy9wb3N0Y3NzLTgtcGx1Z2luLW1pZ3JhdGlvblwiKTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5MQU5HICYmIHByb2Nlc3MuZW52LkxBTkcuc3RhcnRzV2l0aChcImNuXCIpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKG5hbWUgKyBcIjog6YeM6Z2iIHBvc3Rjc3MucGx1Z2luIOiiq+W8g+eUqC4g6L+B56e75oyH5Y2XOlxcbmh0dHBzOi8vd3d3LnczY3RlY2guY29tL3RvcGljLzIyMjZcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRyYW5zZm9ybWVyID0gaW5pdGlhbGl6ZXIuYXBwbHkodm9pZCAwLCBbXS5jb25jYXQoYXJncykpO1xuICAgICAgICB0cmFuc2Zvcm1lci5wb3N0Y3NzUGx1Z2luID0gbmFtZTtcbiAgICAgICAgdHJhbnNmb3JtZXIucG9zdGNzc1ZlcnNpb24gPSBuZXcgUHJvY2Vzc29yMjIoKS52ZXJzaW9uO1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXI7XG4gICAgfVxuICAgIHZhciBjYWNoZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRvciwgXCJwb3N0Y3NzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlKSBjYWNoZSA9IGNyZWF0b3IoKTtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNyZWF0b3IucHJvY2VzcyA9IGZ1bmN0aW9uKGNzcywgcHJvY2Vzc09wdHMsIHBsdWdpbk9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHBvc3Rjc3MoW1xuICAgICAgICAgICAgY3JlYXRvcihwbHVnaW5PcHRzKVxuICAgICAgICBdKS5wcm9jZXNzKGNzcywgcHJvY2Vzc09wdHMpO1xuICAgIH07XG4gICAgcmV0dXJuIGNyZWF0b3I7XG59O1xucG9zdGNzcy5zdHJpbmdpZnkgPSBzdHJpbmdpZnkkNjtcbnBvc3Rjc3MucGFyc2UgPSBwYXJzZTtcbnBvc3Rjc3MuZnJvbUpTT04gPSBmcm9tSlNPTjtcbnBvc3Rjc3MubGlzdCA9IGxpc3Q7XG5wb3N0Y3NzLmNvbW1lbnQgPSBmdW5jdGlvbihkZWZhdWx0cykge1xuICAgIHJldHVybiBuZXcgQ29tbWVudDIyKGRlZmF1bHRzKTtcbn07XG5wb3N0Y3NzLmF0UnVsZSA9IGZ1bmN0aW9uKGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIG5ldyBBdFJ1bGUyMihkZWZhdWx0cyk7XG59O1xucG9zdGNzcy5kZWNsID0gZnVuY3Rpb24oZGVmYXVsdHMpIHtcbiAgICByZXR1cm4gbmV3IERlY2xhcmF0aW9uMjIoZGVmYXVsdHMpO1xufTtcbnBvc3Rjc3MucnVsZSA9IGZ1bmN0aW9uKGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIG5ldyBSdWxlMjIoZGVmYXVsdHMpO1xufTtcbnBvc3Rjc3Mucm9vdCA9IGZ1bmN0aW9uKGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIG5ldyBSb290MjIoZGVmYXVsdHMpO1xufTtcbnBvc3Rjc3MuZG9jdW1lbnQgPSBmdW5jdGlvbihkZWZhdWx0cykge1xuICAgIHJldHVybiBuZXcgRG9jdW1lbnQyMjIoZGVmYXVsdHMpO1xufTtcbnBvc3Rjc3MuQ3NzU3ludGF4RXJyb3IgPSBDc3NTeW50YXhFcnJvcjIyO1xucG9zdGNzcy5EZWNsYXJhdGlvbiA9IERlY2xhcmF0aW9uMjI7XG5wb3N0Y3NzLkNvbnRhaW5lciA9IENvbnRhaW5lcjIyO1xucG9zdGNzcy5Qcm9jZXNzb3IgPSBQcm9jZXNzb3IyMjtcbnBvc3Rjc3MuRG9jdW1lbnQgPSBEb2N1bWVudDIyMjtcbnBvc3Rjc3MuQ29tbWVudCA9IENvbW1lbnQyMjtcbnBvc3Rjc3MuV2FybmluZyA9IFdhcm5pbmcyMjtcbnBvc3Rjc3MuQXRSdWxlID0gQXRSdWxlMjI7XG5wb3N0Y3NzLlJlc3VsdCA9IFJlc3VsdDIyO1xucG9zdGNzcy5JbnB1dCA9IElucHV0MjI7XG5wb3N0Y3NzLlJ1bGUgPSBSdWxlMjI7XG5wb3N0Y3NzLlJvb3QgPSBSb290MjI7XG5wb3N0Y3NzLk5vZGUgPSBOb2RlMjI7XG5MYXp5UmVzdWx0MjIucmVnaXN0ZXJQb3N0Y3NzKHBvc3Rjc3MpO1xudmFyIHBvc3Rjc3NfMSA9IHBvc3Rjc3M7XG5wb3N0Y3NzLmRlZmF1bHQgPSBwb3N0Y3NzO1xudmFyIHBvc3Rjc3MkMSA9IC8qIEBfX1BVUkVfXyAqLyBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhwb3N0Y3NzXzEpO1xucG9zdGNzcyQxLnN0cmluZ2lmeTtcbnBvc3Rjc3MkMS5mcm9tSlNPTjtcbnBvc3Rjc3MkMS5wbHVnaW47XG5wb3N0Y3NzJDEucGFyc2U7XG5wb3N0Y3NzJDEubGlzdDtcbnBvc3Rjc3MkMS5kb2N1bWVudDtcbnBvc3Rjc3MkMS5jb21tZW50O1xucG9zdGNzcyQxLmF0UnVsZTtcbnBvc3Rjc3MkMS5ydWxlO1xucG9zdGNzcyQxLmRlY2w7XG5wb3N0Y3NzJDEucm9vdDtcbnBvc3Rjc3MkMS5Dc3NTeW50YXhFcnJvcjtcbnBvc3Rjc3MkMS5EZWNsYXJhdGlvbjtcbnBvc3Rjc3MkMS5Db250YWluZXI7XG5wb3N0Y3NzJDEuUHJvY2Vzc29yO1xucG9zdGNzcyQxLkRvY3VtZW50O1xucG9zdGNzcyQxLkNvbW1lbnQ7XG5wb3N0Y3NzJDEuV2FybmluZztcbnBvc3Rjc3MkMS5BdFJ1bGU7XG5wb3N0Y3NzJDEuUmVzdWx0O1xucG9zdGNzcyQxLklucHV0O1xucG9zdGNzcyQxLlJ1bGU7XG5wb3N0Y3NzJDEuUm9vdDtcbnBvc3Rjc3MkMS5Ob2RlO1xudmFyIEJhc2VSUk5vZGUgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIEJhc2VSUk5vZGUoKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBfYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBfX3B1YmxpY0ZpZWxkMih0aGlzLCBcInBhcmVudEVsZW1lbnRcIiwgbnVsbCk7XG4gICAgICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwicGFyZW50Tm9kZVwiLCBudWxsKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZDIodGhpcywgXCJvd25lckRvY3VtZW50XCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkMih0aGlzLCBcImZpcnN0Q2hpbGRcIiwgbnVsbCk7XG4gICAgICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwibGFzdENoaWxkXCIsIG51bGwpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkMih0aGlzLCBcInByZXZpb3VzU2libGluZ1wiLCBudWxsKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZDIodGhpcywgXCJuZXh0U2libGluZ1wiLCBudWxsKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZDIodGhpcywgXCJFTEVNRU5UX05PREVcIiwgMSk7XG4gICAgICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwiVEVYVF9OT0RFXCIsIDMpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkMih0aGlzLCBcIm5vZGVUeXBlXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkMih0aGlzLCBcIm5vZGVOYW1lXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkMih0aGlzLCBcIlJSTm9kZVR5cGVcIik7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBCYXNlUlJOb2RlLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uY29udGFpbnMgPSBmdW5jdGlvbiBjb250YWlucyhub2RlMikge1xuICAgICAgICBpZiAoIV9pbnN0YW5jZW9mKG5vZGUyLCBCYXNlUlJOb2RlKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBlbHNlIGlmIChub2RlMi5vd25lckRvY3VtZW50ICE9PSB0aGlzLm93bmVyRG9jdW1lbnQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgZWxzZSBpZiAobm9kZTIgPT09IHRoaXMpIHJldHVybiB0cnVlO1xuICAgICAgICB3aGlsZShub2RlMi5wYXJlbnROb2RlKXtcbiAgICAgICAgICAgIGlmIChub2RlMi5wYXJlbnROb2RlID09PSB0aGlzKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIG5vZGUyID0gbm9kZTIucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgX3Byb3RvLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gYXBwZW5kQ2hpbGQoX25ld0NoaWxkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJSRG9tRXhjZXB0aW9uOiBGYWlsZWQgdG8gZXhlY3V0ZSAnYXBwZW5kQ2hpbGQnIG9uICdSUk5vZGUnOiBUaGlzIFJSTm9kZSB0eXBlIGRvZXMgbm90IHN1cHBvcnQgdGhpcyBtZXRob2QuXCIpO1xuICAgIH07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIF9wcm90by5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiBpbnNlcnRCZWZvcmUoX25ld0NoaWxkLCBfcmVmQ2hpbGQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUlJEb21FeGNlcHRpb246IEZhaWxlZCB0byBleGVjdXRlICdpbnNlcnRCZWZvcmUnIG9uICdSUk5vZGUnOiBUaGlzIFJSTm9kZSB0eXBlIGRvZXMgbm90IHN1cHBvcnQgdGhpcyBtZXRob2QuXCIpO1xuICAgIH07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIF9wcm90by5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIHJlbW92ZUNoaWxkKF9ub2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJSRG9tRXhjZXB0aW9uOiBGYWlsZWQgdG8gZXhlY3V0ZSAncmVtb3ZlQ2hpbGQnIG9uICdSUk5vZGUnOiBUaGlzIFJSTm9kZSB0eXBlIGRvZXMgbm90IHN1cHBvcnQgdGhpcyBtZXRob2QuXCIpO1xuICAgIH07XG4gICAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcIlJSTm9kZVwiO1xuICAgIH07XG4gICAgX2NyZWF0ZV9jbGFzcyhCYXNlUlJOb2RlLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjaGlsZE5vZGVzXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGROb2RlczIgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRJdGVyYXRvciA9IHRoaXMuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICB3aGlsZShjaGlsZEl0ZXJhdG9yKXtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlczIucHVzaChjaGlsZEl0ZXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRJdGVyYXRvciA9IGNoaWxkSXRlcmF0b3IubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZE5vZGVzMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBCYXNlUlJOb2RlO1xufSgpO1xudmFyIHRlc3RhYmxlQWNjZXNzb3JzID0ge1xuICAgIE5vZGU6IFtcbiAgICAgICAgXCJjaGlsZE5vZGVzXCIsXG4gICAgICAgIFwicGFyZW50Tm9kZVwiLFxuICAgICAgICBcInBhcmVudEVsZW1lbnRcIixcbiAgICAgICAgXCJ0ZXh0Q29udGVudFwiXG4gICAgXSxcbiAgICBTaGFkb3dSb290OiBbXG4gICAgICAgIFwiaG9zdFwiLFxuICAgICAgICBcInN0eWxlU2hlZXRzXCJcbiAgICBdLFxuICAgIEVsZW1lbnQ6IFtcbiAgICAgICAgXCJzaGFkb3dSb290XCIsXG4gICAgICAgIFwicXVlcnlTZWxlY3RvclwiLFxuICAgICAgICBcInF1ZXJ5U2VsZWN0b3JBbGxcIlxuICAgIF0sXG4gICAgTXV0YXRpb25PYnNlcnZlcjogW11cbn07XG52YXIgdGVzdGFibGVNZXRob2RzID0ge1xuICAgIE5vZGU6IFtcbiAgICAgICAgXCJjb250YWluc1wiLFxuICAgICAgICBcImdldFJvb3ROb2RlXCJcbiAgICBdLFxuICAgIFNoYWRvd1Jvb3Q6IFtcbiAgICAgICAgXCJnZXRTZWxlY3Rpb25cIlxuICAgIF0sXG4gICAgRWxlbWVudDogW10sXG4gICAgTXV0YXRpb25PYnNlcnZlcjogW1xuICAgICAgICBcImNvbnN0cnVjdG9yXCJcbiAgICBdXG59O1xudmFyIHVudGFpbnRlZEJhc2VQcm90b3R5cGUgPSB7fTtcbnZhciBpc0FuZ3VsYXJab25lUHJlc2VudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhIWdsb2JhbFRoaXMuWm9uZTtcbn07XG5mdW5jdGlvbiBnZXRVbnRhaW50ZWRQcm90b3R5cGUoa2V5KSB7XG4gICAgaWYgKHVudGFpbnRlZEJhc2VQcm90b3R5cGVba2V5XSkgcmV0dXJuIHVudGFpbnRlZEJhc2VQcm90b3R5cGVba2V5XTtcbiAgICB2YXIgZGVmYXVsdE9iaiA9IGdsb2JhbFRoaXNba2V5XTtcbiAgICB2YXIgZGVmYXVsdFByb3RvdHlwZSA9IGRlZmF1bHRPYmoucHJvdG90eXBlO1xuICAgIHZhciBhY2Nlc3Nvck5hbWVzID0ga2V5IGluIHRlc3RhYmxlQWNjZXNzb3JzID8gdGVzdGFibGVBY2Nlc3NvcnNba2V5XSA6IHZvaWQgMDtcbiAgICB2YXIgaXNVbnRhaW50ZWRBY2Nlc3NvcnMgPSBCb29sZWFuKGFjY2Vzc29yTmFtZXMgJiYgLy8gQHRzLWV4cGVjdC1lcnJvciAyMzQ1XG4gICAgYWNjZXNzb3JOYW1lcy5ldmVyeShmdW5jdGlvbihhY2Nlc3Nvcikge1xuICAgICAgICB2YXIgX2EyLCBfYjtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oKF9iID0gKF9hMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZGVmYXVsdFByb3RvdHlwZSwgYWNjZXNzb3IpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnRvU3RyaW5nKCkuaW5jbHVkZXMoXCJbbmF0aXZlIGNvZGVdXCIpKTtcbiAgICB9KSk7XG4gICAgdmFyIG1ldGhvZE5hbWVzID0ga2V5IGluIHRlc3RhYmxlTWV0aG9kcyA/IHRlc3RhYmxlTWV0aG9kc1trZXldIDogdm9pZCAwO1xuICAgIHZhciBpc1VudGFpbnRlZE1ldGhvZHMgPSBCb29sZWFuKG1ldGhvZE5hbWVzICYmIG1ldGhvZE5hbWVzLmV2ZXJ5KC8vIEB0cy1leHBlY3QtZXJyb3IgMjM0NVxuICAgIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGRlZmF1bHRQcm90b3R5cGVbbWV0aG9kXSA9PT0gXCJmdW5jdGlvblwiICYmICgoX2EyID0gZGVmYXVsdFByb3RvdHlwZVttZXRob2RdKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnRvU3RyaW5nKCkuaW5jbHVkZXMoXCJbbmF0aXZlIGNvZGVdXCIpKTtcbiAgICB9KSk7XG4gICAgaWYgKGlzVW50YWludGVkQWNjZXNzb3JzICYmIGlzVW50YWludGVkTWV0aG9kcyAmJiAhaXNBbmd1bGFyWm9uZVByZXNlbnQoKSkge1xuICAgICAgICB1bnRhaW50ZWRCYXNlUHJvdG90eXBlW2tleV0gPSBkZWZhdWx0T2JqLnByb3RvdHlwZTtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRPYmoucHJvdG90eXBlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB2YXIgaWZyYW1lRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZUVsKTtcbiAgICAgICAgdmFyIHdpbiA9IGlmcmFtZUVsLmNvbnRlbnRXaW5kb3c7XG4gICAgICAgIGlmICghd2luKSByZXR1cm4gZGVmYXVsdE9iai5wcm90b3R5cGU7XG4gICAgICAgIHZhciB1bnRhaW50ZWRPYmplY3QgPSB3aW5ba2V5XS5wcm90b3R5cGU7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lRWwpO1xuICAgICAgICBpZiAoIXVudGFpbnRlZE9iamVjdCkgcmV0dXJuIGRlZmF1bHRQcm90b3R5cGU7XG4gICAgICAgIHJldHVybiB1bnRhaW50ZWRCYXNlUHJvdG90eXBlW2tleV0gPSB1bnRhaW50ZWRPYmplY3Q7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFByb3RvdHlwZTtcbiAgICB9XG59XG52YXIgdW50YWludGVkQWNjZXNzb3JDYWNoZSA9IHt9O1xuZnVuY3Rpb24gZ2V0VW50YWludGVkQWNjZXNzb3Ioa2V5LCBpbnN0YW5jZSwgYWNjZXNzb3IpIHtcbiAgICB2YXIgX2EyO1xuICAgIHZhciBjYWNoZUtleSA9IGtleSArIFwiLlwiICsgU3RyaW5nKGFjY2Vzc29yKTtcbiAgICBpZiAodW50YWludGVkQWNjZXNzb3JDYWNoZVtjYWNoZUtleV0pIHJldHVybiB1bnRhaW50ZWRBY2Nlc3NvckNhY2hlW2NhY2hlS2V5XS5jYWxsKGluc3RhbmNlKTtcbiAgICB2YXIgdW50YWludGVkUHJvdG90eXBlID0gZ2V0VW50YWludGVkUHJvdG90eXBlKGtleSk7XG4gICAgdmFyIHVudGFpbnRlZEFjY2Vzc29yID0gKF9hMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodW50YWludGVkUHJvdG90eXBlLCBhY2Nlc3NvcikpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZ2V0O1xuICAgIGlmICghdW50YWludGVkQWNjZXNzb3IpIHJldHVybiBpbnN0YW5jZVthY2Nlc3Nvcl07XG4gICAgdW50YWludGVkQWNjZXNzb3JDYWNoZVtjYWNoZUtleV0gPSB1bnRhaW50ZWRBY2Nlc3NvcjtcbiAgICByZXR1cm4gdW50YWludGVkQWNjZXNzb3IuY2FsbChpbnN0YW5jZSk7XG59XG52YXIgdW50YWludGVkTWV0aG9kQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGdldFVudGFpbnRlZE1ldGhvZChrZXksIGluc3RhbmNlLCBtZXRob2QpIHtcbiAgICB2YXIgY2FjaGVLZXkgPSBrZXkgKyBcIi5cIiArIFN0cmluZyhtZXRob2QpO1xuICAgIGlmICh1bnRhaW50ZWRNZXRob2RDYWNoZVtjYWNoZUtleV0pIHJldHVybiB1bnRhaW50ZWRNZXRob2RDYWNoZVtjYWNoZUtleV0uYmluZChpbnN0YW5jZSk7XG4gICAgdmFyIHVudGFpbnRlZFByb3RvdHlwZSA9IGdldFVudGFpbnRlZFByb3RvdHlwZShrZXkpO1xuICAgIHZhciB1bnRhaW50ZWRNZXRob2QgPSB1bnRhaW50ZWRQcm90b3R5cGVbbWV0aG9kXTtcbiAgICBpZiAodHlwZW9mIHVudGFpbnRlZE1ldGhvZCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gaW5zdGFuY2VbbWV0aG9kXTtcbiAgICB1bnRhaW50ZWRNZXRob2RDYWNoZVtjYWNoZUtleV0gPSB1bnRhaW50ZWRNZXRob2Q7XG4gICAgcmV0dXJuIHVudGFpbnRlZE1ldGhvZC5iaW5kKGluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIGNoaWxkTm9kZXMobjIpIHtcbiAgICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IoXCJOb2RlXCIsIG4yLCBcImNoaWxkTm9kZXNcIik7XG59XG5mdW5jdGlvbiBwYXJlbnROb2RlKG4yKSB7XG4gICAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yKFwiTm9kZVwiLCBuMiwgXCJwYXJlbnROb2RlXCIpO1xufVxuZnVuY3Rpb24gcGFyZW50RWxlbWVudChuMikge1xuICAgIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvcihcIk5vZGVcIiwgbjIsIFwicGFyZW50RWxlbWVudFwiKTtcbn1cbmZ1bmN0aW9uIHRleHRDb250ZW50KG4yKSB7XG4gICAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yKFwiTm9kZVwiLCBuMiwgXCJ0ZXh0Q29udGVudFwiKTtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zKG4yLCBvdGhlcikge1xuICAgIHJldHVybiBnZXRVbnRhaW50ZWRNZXRob2QoXCJOb2RlXCIsIG4yLCBcImNvbnRhaW5zXCIpKG90aGVyKTtcbn1cbmZ1bmN0aW9uIGdldFJvb3ROb2RlKG4yKSB7XG4gICAgcmV0dXJuIGdldFVudGFpbnRlZE1ldGhvZChcIk5vZGVcIiwgbjIsIFwiZ2V0Um9vdE5vZGVcIikoKTtcbn1cbmZ1bmN0aW9uIGhvc3QobjIpIHtcbiAgICBpZiAoIW4yIHx8ICEoXCJob3N0XCIgaW4gbjIpKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IoXCJTaGFkb3dSb290XCIsIG4yLCBcImhvc3RcIik7XG59XG5mdW5jdGlvbiBzdHlsZVNoZWV0cyhuMikge1xuICAgIHJldHVybiBuMi5zdHlsZVNoZWV0cztcbn1cbmZ1bmN0aW9uIHNoYWRvd1Jvb3QobjIpIHtcbiAgICBpZiAoIW4yIHx8ICEoXCJzaGFkb3dSb290XCIgaW4gbjIpKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IoXCJFbGVtZW50XCIsIG4yLCBcInNoYWRvd1Jvb3RcIik7XG59XG5mdW5jdGlvbiBxdWVyeVNlbGVjdG9yKG4yLCBzZWxlY3RvcnMpIHtcbiAgICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IoXCJFbGVtZW50XCIsIG4yLCBcInF1ZXJ5U2VsZWN0b3JcIikoc2VsZWN0b3JzKTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3JBbGwobjIsIHNlbGVjdG9ycykge1xuICAgIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvcihcIkVsZW1lbnRcIiwgbjIsIFwicXVlcnlTZWxlY3RvckFsbFwiKShzZWxlY3RvcnMpO1xufVxuZnVuY3Rpb24gbXV0YXRpb25PYnNlcnZlckN0b3IoKSB7XG4gICAgcmV0dXJuIGdldFVudGFpbnRlZFByb3RvdHlwZShcIk11dGF0aW9uT2JzZXJ2ZXJcIikuY29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBwYXRjaCQyKHNvdXJjZSwgbmFtZSwgcmVwbGFjZW1lbnQpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIShuYW1lIGluIHNvdXJjZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcmlnaW5hbCA9IHNvdXJjZVtuYW1lXTtcbiAgICAgICAgdmFyIHdyYXBwZWQgPSByZXBsYWNlbWVudChvcmlnaW5hbCk7XG4gICAgICAgIGlmICh0eXBlb2Ygd3JhcHBlZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB3cmFwcGVkLnByb3RvdHlwZSA9IHdyYXBwZWQucHJvdG90eXBlIHx8IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMod3JhcHBlZCwge1xuICAgICAgICAgICAgICAgIF9fcnJ3ZWJfb3JpZ2luYWxfXzoge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlW25hbWVdID0gd3JhcHBlZDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc291cmNlW25hbWVdID0gb3JpZ2luYWw7XG4gICAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG59XG52YXIgaW5kZXggPSB7XG4gICAgY2hpbGROb2RlczogY2hpbGROb2RlcyxcbiAgICBwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuICAgIHBhcmVudEVsZW1lbnQ6IHBhcmVudEVsZW1lbnQsXG4gICAgdGV4dENvbnRlbnQ6IHRleHRDb250ZW50LFxuICAgIGNvbnRhaW5zOiBjb250YWlucyxcbiAgICBnZXRSb290Tm9kZTogZ2V0Um9vdE5vZGUsXG4gICAgaG9zdDogaG9zdCxcbiAgICBzdHlsZVNoZWV0czogc3R5bGVTaGVldHMsXG4gICAgc2hhZG93Um9vdDogc2hhZG93Um9vdCxcbiAgICBxdWVyeVNlbGVjdG9yOiBxdWVyeVNlbGVjdG9yLFxuICAgIHF1ZXJ5U2VsZWN0b3JBbGw6IHF1ZXJ5U2VsZWN0b3JBbGwsXG4gICAgbXV0YXRpb25PYnNlcnZlcjogbXV0YXRpb25PYnNlcnZlckN0b3IsXG4gICAgcGF0Y2g6IHBhdGNoJDJcbn07XG5mdW5jdGlvbiBvbih0eXBlLCBmbiwgdGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldCA9PT0gdm9pZCAwKSB0YXJnZXQgPSBkb2N1bWVudDtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH07XG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIG9wdGlvbnMpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBvcHRpb25zKTtcbiAgICB9O1xufVxudmFyIERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyA9IFwiUGxlYXNlIHN0b3AgaW1wb3J0IG1pcnJvciBkaXJlY3RseS4gSW5zdGVhZCBvZiB0aGF0LFxcclxcbm5vdyB5b3UgY2FuIHVzZSByZXBsYXllci5nZXRNaXJyb3IoKSB0byBhY2Nlc3MgdGhlIG1pcnJvciBpbnN0YW5jZSBvZiBhIHJlcGxheWVyLFxcclxcbm9yIHlvdSBjYW4gdXNlIHJlY29yZC5taXJyb3IgdG8gYWNjZXNzIHRoZSBtaXJyb3IgaW5zdGFuY2UgZHVyaW5nIHJlY29yZGluZy5cIjtcbnZhciBfbWlycm9yID0ge1xuICAgIG1hcDoge30sXG4gICAgZ2V0SWQ6IGZ1bmN0aW9uIGdldElkKCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9LFxuICAgIGdldE5vZGU6IGZ1bmN0aW9uIGdldE5vZGUoKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICByZW1vdmVOb2RlRnJvbU1hcDogZnVuY3Rpb24gcmVtb3ZlTm9kZUZyb21NYXAoKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcbiAgICB9LFxuICAgIGhhczogZnVuY3Rpb24gaGFzKCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIHJlc2V0OiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcpO1xuICAgIH1cbn07XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuUHJveHkgJiYgd2luZG93LlJlZmxlY3QpIHtcbiAgICBfbWlycm9yID0gbmV3IFByb3h5KF9taXJyb3IsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICAgICAgaWYgKHByb3AgPT09IFwibWFwXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSBvcHRpb25zID0ge307XG4gICAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAoIXByZXZpb3VzICYmIG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICB9XG4gICAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICB9LCByZW1haW5pbmcpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhvb2tTZXR0ZXIodGFyZ2V0LCBrZXksIGQsIGlzUmV2b2tlZCwgd2luKSB7XG4gICAgaWYgKHdpbiA9PT0gdm9pZCAwKSB3aW4gPSB3aW5kb3c7XG4gICAgdmFyIG9yaWdpbmFsID0gd2luLk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuICAgIHdpbi5PYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGlzUmV2b2tlZCA/IGQgOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkLnNldC5jYWxsKF90aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbCAmJiBvcmlnaW5hbC5zZXQpIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbC5zZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBob29rU2V0dGVyKHRhcmdldCwga2V5LCBvcmlnaW5hbCB8fCB7fSwgdHJ1ZSk7XG4gICAgfTtcbn1cbnZhciBub3dUaW1lc3RhbXAgPSBEYXRlLm5vdztcbmlmICghLyogQF9fUFVSRV9fICovIC9bMS05XVswLTldezEyfS8udGVzdChEYXRlLm5vdygpLnRvU3RyaW5nKCkpKSB7XG4gICAgbm93VGltZXN0YW1wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbCh3aW4pIHtcbiAgICB2YXIgX2EyLCBfYiwgX2MsIF9kO1xuICAgIHZhciBkb2MgPSB3aW4uZG9jdW1lbnQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogZG9jLnNjcm9sbGluZ0VsZW1lbnQgPyBkb2Muc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxMZWZ0IDogd2luLnBhZ2VYT2Zmc2V0ICE9PSB2b2lkIDAgPyB3aW4ucGFnZVhPZmZzZXQgOiBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgKGRvYyA9PSBudWxsID8gdm9pZCAwIDogZG9jLmJvZHkpICYmICgoX2EyID0gaW5kZXgucGFyZW50RWxlbWVudChkb2MuYm9keSkpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuc2Nyb2xsTGVmdCkgfHwgKChfYiA9IGRvYyA9PSBudWxsID8gdm9pZCAwIDogZG9jLmJvZHkpID09IG51bGwgPyB2b2lkIDAgOiBfYi5zY3JvbGxMZWZ0KSB8fCAwLFxuICAgICAgICB0b3A6IGRvYy5zY3JvbGxpbmdFbGVtZW50ID8gZG9jLnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsVG9wIDogd2luLnBhZ2VZT2Zmc2V0ICE9PSB2b2lkIDAgPyB3aW4ucGFnZVlPZmZzZXQgOiAoZG9jID09IG51bGwgPyB2b2lkIDAgOiBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCkgfHwgKGRvYyA9PSBudWxsID8gdm9pZCAwIDogZG9jLmJvZHkpICYmICgoX2MgPSBpbmRleC5wYXJlbnRFbGVtZW50KGRvYy5ib2R5KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnNjcm9sbFRvcCkgfHwgKChfZCA9IGRvYyA9PSBudWxsID8gdm9pZCAwIDogZG9jLmJvZHkpID09IG51bGwgPyB2b2lkIDAgOiBfZC5zY3JvbGxUb3ApIHx8IDBcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0V2luZG93SGVpZ2h0KCkge1xuICAgIHJldHVybiB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgfHwgZG9jdW1lbnQuYm9keSAmJiBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodDtcbn1cbmZ1bmN0aW9uIGdldFdpbmRvd1dpZHRoKCkge1xuICAgIHJldHVybiB3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIHx8IGRvY3VtZW50LmJvZHkgJiYgZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aDtcbn1cbmZ1bmN0aW9uIGNsb3Nlc3RFbGVtZW50T2ZOb2RlKG5vZGUyKSB7XG4gICAgaWYgKCFub2RlMikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGVsID0gbm9kZTIubm9kZVR5cGUgPT09IG5vZGUyLkVMRU1FTlRfTk9ERSA/IG5vZGUyIDogaW5kZXgucGFyZW50RWxlbWVudChub2RlMik7XG4gICAgcmV0dXJuIGVsO1xufVxuZnVuY3Rpb24gaXNCbG9ja2VkKG5vZGUyLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBjaGVja0FuY2VzdG9ycykge1xuICAgIGlmICghbm9kZTIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZWwgPSBjbG9zZXN0RWxlbWVudE9mTm9kZShub2RlMik7XG4gICAgaWYgKCFlbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgYmxvY2tDbGFzcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucyhibG9ja0NsYXNzKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoY2hlY2tBbmNlc3RvcnMgJiYgZWwuY2xvc2VzdChcIi5cIiArIGJsb2NrQ2xhc3MpICE9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjbGFzc01hdGNoZXNSZWdleChlbCwgYmxvY2tDbGFzcywgY2hlY2tBbmNlc3RvcnMpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUyKSB7fVxuICAgIGlmIChibG9ja1NlbGVjdG9yKSB7XG4gICAgICAgIGlmIChlbC5tYXRjaGVzKGJsb2NrU2VsZWN0b3IpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGNoZWNrQW5jZXN0b3JzICYmIGVsLmNsb3Nlc3QoYmxvY2tTZWxlY3RvcikgIT09IG51bGwpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1NlcmlhbGl6ZWQobjIsIG1pcnJvcjIpIHtcbiAgICByZXR1cm4gbWlycm9yMi5nZXRJZChuMikgIT09IC0xO1xufVxuZnVuY3Rpb24gaXNJZ25vcmVkKG4yLCBtaXJyb3IyLCBzbGltRE9NT3B0aW9ucykge1xuICAgIGlmIChuMi50YWdOYW1lID09PSBcIlRJVExFXCIgJiYgc2xpbURPTU9wdGlvbnMuaGVhZFRpdGxlTXV0YXRpb25zKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gbWlycm9yMi5nZXRJZChuMikgPT09IElHTk9SRURfTk9ERTtcbn1cbmZ1bmN0aW9uIGlzQW5jZXN0b3JSZW1vdmVkKHRhcmdldCwgbWlycm9yMikge1xuICAgIGlmIChpc1NoYWRvd1Jvb3QodGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBpZCA9IG1pcnJvcjIuZ2V0SWQodGFyZ2V0KTtcbiAgICBpZiAoIW1pcnJvcjIuaGFzKGlkKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHBhcmVudCA9IGluZGV4LnBhcmVudE5vZGUodGFyZ2V0KTtcbiAgICBpZiAocGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSA9PT0gdGFyZ2V0LkRPQ1VNRU5UX05PREUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzQW5jZXN0b3JSZW1vdmVkKHBhcmVudCwgbWlycm9yMik7XG59XG5mdW5jdGlvbiBsZWdhY3lfaXNUb3VjaEV2ZW50KGV2ZW50KSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oZXZlbnQuY2hhbmdlZFRvdWNoZXMpO1xufVxuZnVuY3Rpb24gcG9seWZpbGwkMSh3aW4pIHtcbiAgICBpZiAod2luID09PSB2b2lkIDApIHdpbiA9IHdpbmRvdztcbiAgICBpZiAoXCJOb2RlTGlzdFwiIGluIHdpbiAmJiAhd2luLk5vZGVMaXN0LnByb3RvdHlwZS5mb3JFYWNoKSB7XG4gICAgICAgIHdpbi5Ob2RlTGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoO1xuICAgIH1cbiAgICBpZiAoXCJET01Ub2tlbkxpc3RcIiBpbiB3aW4gJiYgIXdpbi5ET01Ub2tlbkxpc3QucHJvdG90eXBlLmZvckVhY2gpIHtcbiAgICAgICAgd2luLkRPTVRva2VuTGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzU2VyaWFsaXplZElmcmFtZShuMiwgbWlycm9yMikge1xuICAgIHJldHVybiBCb29sZWFuKG4yLm5vZGVOYW1lID09PSBcIklGUkFNRVwiICYmIG1pcnJvcjIuZ2V0TWV0YShuMikpO1xufVxuZnVuY3Rpb24gaXNTZXJpYWxpemVkU3R5bGVzaGVldChuMiwgbWlycm9yMikge1xuICAgIHJldHVybiBCb29sZWFuKG4yLm5vZGVOYW1lID09PSBcIkxJTktcIiAmJiBuMi5ub2RlVHlwZSA9PT0gbjIuRUxFTUVOVF9OT0RFICYmIG4yLmdldEF0dHJpYnV0ZSAmJiBuMi5nZXRBdHRyaWJ1dGUoXCJyZWxcIikgPT09IFwic3R5bGVzaGVldFwiICYmIG1pcnJvcjIuZ2V0TWV0YShuMikpO1xufVxuZnVuY3Rpb24gaGFzU2hhZG93Um9vdChuMikge1xuICAgIGlmICghbjIpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoX2luc3RhbmNlb2YobjIsIEJhc2VSUk5vZGUpICYmIFwic2hhZG93Um9vdFwiIGluIG4yKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKG4yLnNoYWRvd1Jvb3QpO1xuICAgIH1cbiAgICByZXR1cm4gQm9vbGVhbihpbmRleC5zaGFkb3dSb290KG4yKSk7XG59XG52YXIgU3R5bGVTaGVldE1pcnJvciA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gU3R5bGVTaGVldE1pcnJvcigpIHtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiaWRcIiwgMSk7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcInN0eWxlSURNYXBcIiwgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJpZFN0eWxlTWFwXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gU3R5bGVTaGVldE1pcnJvci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmdldElkID0gZnVuY3Rpb24gZ2V0SWQoc3R5bGVzaGVldCkge1xuICAgICAgICB2YXIgX3RoaXNfc3R5bGVJRE1hcF9nZXQ7XG4gICAgICAgIHJldHVybiAoX3RoaXNfc3R5bGVJRE1hcF9nZXQgPSB0aGlzLnN0eWxlSURNYXAuZ2V0KHN0eWxlc2hlZXQpKSAhPSBudWxsID8gX3RoaXNfc3R5bGVJRE1hcF9nZXQgOiAtMTtcbiAgICB9O1xuICAgIF9wcm90by5oYXMgPSBmdW5jdGlvbiBoYXMoc3R5bGVzaGVldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZUlETWFwLmhhcyhzdHlsZXNoZWV0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgKiBAcmV0dXJucyBJZiB0aGUgc3R5bGVzaGVldCBpcyBpbiB0aGUgbWlycm9yLCByZXR1cm5zIHRoZSBpZCBvZiB0aGUgc3R5bGVzaGVldC4gSWYgbm90LCByZXR1cm4gdGhlIG5ldyBhc3NpZ25lZCBpZC5cbiAgICovIF9wcm90by5hZGQgPSBmdW5jdGlvbiBhZGQoc3R5bGVzaGVldCwgaWQpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzKHN0eWxlc2hlZXQpKSByZXR1cm4gdGhpcy5nZXRJZChzdHlsZXNoZWV0KTtcbiAgICAgICAgdmFyIG5ld0lkO1xuICAgICAgICBpZiAoaWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgbmV3SWQgPSB0aGlzLmlkKys7XG4gICAgICAgIH0gZWxzZSBuZXdJZCA9IGlkO1xuICAgICAgICB0aGlzLnN0eWxlSURNYXAuc2V0KHN0eWxlc2hlZXQsIG5ld0lkKTtcbiAgICAgICAgdGhpcy5pZFN0eWxlTWFwLnNldChuZXdJZCwgc3R5bGVzaGVldCk7XG4gICAgICAgIHJldHVybiBuZXdJZDtcbiAgICB9O1xuICAgIF9wcm90by5nZXRTdHlsZSA9IGZ1bmN0aW9uIGdldFN0eWxlKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkU3R5bGVNYXAuZ2V0KGlkKSB8fCBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuc3R5bGVJRE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgICAgICB0aGlzLmlkU3R5bGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmlkID0gMTtcbiAgICB9O1xuICAgIF9wcm90by5nZW5lcmF0ZUlkID0gZnVuY3Rpb24gZ2VuZXJhdGVJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQrKztcbiAgICB9O1xuICAgIHJldHVybiBTdHlsZVNoZWV0TWlycm9yO1xufSgpO1xuZnVuY3Rpb24gZ2V0U2hhZG93SG9zdChuMikge1xuICAgIHZhciBfYTI7XG4gICAgdmFyIHNoYWRvd0hvc3QgPSBudWxsO1xuICAgIGlmIChcImdldFJvb3ROb2RlXCIgaW4gbjIgJiYgKChfYTIgPSBpbmRleC5nZXRSb290Tm9kZShuMikpID09IG51bGwgPyB2b2lkIDAgOiBfYTIubm9kZVR5cGUpID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUgJiYgaW5kZXguaG9zdChpbmRleC5nZXRSb290Tm9kZShuMikpKSBzaGFkb3dIb3N0ID0gaW5kZXguaG9zdChpbmRleC5nZXRSb290Tm9kZShuMikpO1xuICAgIHJldHVybiBzaGFkb3dIb3N0O1xufVxuZnVuY3Rpb24gZ2V0Um9vdFNoYWRvd0hvc3QobjIpIHtcbiAgICB2YXIgcm9vdFNoYWRvd0hvc3QgPSBuMjtcbiAgICB2YXIgc2hhZG93SG9zdDtcbiAgICB3aGlsZShzaGFkb3dIb3N0ID0gZ2V0U2hhZG93SG9zdChyb290U2hhZG93SG9zdCkpcm9vdFNoYWRvd0hvc3QgPSBzaGFkb3dIb3N0O1xuICAgIHJldHVybiByb290U2hhZG93SG9zdDtcbn1cbmZ1bmN0aW9uIHNoYWRvd0hvc3RJbkRvbShuMikge1xuICAgIHZhciBkb2MgPSBuMi5vd25lckRvY3VtZW50O1xuICAgIGlmICghZG9jKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHNoYWRvd0hvc3QgPSBnZXRSb290U2hhZG93SG9zdChuMik7XG4gICAgcmV0dXJuIGluZGV4LmNvbnRhaW5zKGRvYywgc2hhZG93SG9zdCk7XG59XG5mdW5jdGlvbiBpbkRvbShuMikge1xuICAgIHZhciBkb2MgPSBuMi5vd25lckRvY3VtZW50O1xuICAgIGlmICghZG9jKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGluZGV4LmNvbnRhaW5zKGRvYywgbjIpIHx8IHNoYWRvd0hvc3RJbkRvbShuMik7XG59XG52YXIgRXZlbnRUeXBlID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKEV2ZW50VHlwZTIpIHtcbiAgICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJEb21Db250ZW50TG9hZGVkXCJdID0gMF0gPSBcIkRvbUNvbnRlbnRMb2FkZWRcIjtcbiAgICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJMb2FkXCJdID0gMV0gPSBcIkxvYWRcIjtcbiAgICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJGdWxsU25hcHNob3RcIl0gPSAyXSA9IFwiRnVsbFNuYXBzaG90XCI7XG4gICAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiSW5jcmVtZW50YWxTbmFwc2hvdFwiXSA9IDNdID0gXCJJbmNyZW1lbnRhbFNuYXBzaG90XCI7XG4gICAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiTWV0YVwiXSA9IDRdID0gXCJNZXRhXCI7XG4gICAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiQ3VzdG9tXCJdID0gNV0gPSBcIkN1c3RvbVwiO1xuICAgIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIlBsdWdpblwiXSA9IDZdID0gXCJQbHVnaW5cIjtcbiAgICByZXR1cm4gRXZlbnRUeXBlMjtcbn0oRXZlbnRUeXBlIHx8IHt9KTtcbnZhciBJbmNyZW1lbnRhbFNvdXJjZSA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbihJbmNyZW1lbnRhbFNvdXJjZTIpIHtcbiAgICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTXV0YXRpb25cIl0gPSAwXSA9IFwiTXV0YXRpb25cIjtcbiAgICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTW91c2VNb3ZlXCJdID0gMV0gPSBcIk1vdXNlTW92ZVwiO1xuICAgIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJNb3VzZUludGVyYWN0aW9uXCJdID0gMl0gPSBcIk1vdXNlSW50ZXJhY3Rpb25cIjtcbiAgICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiU2Nyb2xsXCJdID0gM10gPSBcIlNjcm9sbFwiO1xuICAgIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJWaWV3cG9ydFJlc2l6ZVwiXSA9IDRdID0gXCJWaWV3cG9ydFJlc2l6ZVwiO1xuICAgIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJJbnB1dFwiXSA9IDVdID0gXCJJbnB1dFwiO1xuICAgIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJUb3VjaE1vdmVcIl0gPSA2XSA9IFwiVG91Y2hNb3ZlXCI7XG4gICAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIk1lZGlhSW50ZXJhY3Rpb25cIl0gPSA3XSA9IFwiTWVkaWFJbnRlcmFjdGlvblwiO1xuICAgIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJTdHlsZVNoZWV0UnVsZVwiXSA9IDhdID0gXCJTdHlsZVNoZWV0UnVsZVwiO1xuICAgIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJDYW52YXNNdXRhdGlvblwiXSA9IDldID0gXCJDYW52YXNNdXRhdGlvblwiO1xuICAgIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJGb250XCJdID0gMTBdID0gXCJGb250XCI7XG4gICAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkxvZ1wiXSA9IDExXSA9IFwiTG9nXCI7XG4gICAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkRyYWdcIl0gPSAxMl0gPSBcIkRyYWdcIjtcbiAgICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiU3R5bGVEZWNsYXJhdGlvblwiXSA9IDEzXSA9IFwiU3R5bGVEZWNsYXJhdGlvblwiO1xuICAgIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJTZWxlY3Rpb25cIl0gPSAxNF0gPSBcIlNlbGVjdGlvblwiO1xuICAgIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJBZG9wdGVkU3R5bGVTaGVldFwiXSA9IDE1XSA9IFwiQWRvcHRlZFN0eWxlU2hlZXRcIjtcbiAgICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiQ3VzdG9tRWxlbWVudFwiXSA9IDE2XSA9IFwiQ3VzdG9tRWxlbWVudFwiO1xuICAgIHJldHVybiBJbmNyZW1lbnRhbFNvdXJjZTI7XG59KEluY3JlbWVudGFsU291cmNlIHx8IHt9KTtcbnZhciBNb3VzZUludGVyYWN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbihNb3VzZUludGVyYWN0aW9uczIpIHtcbiAgICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiTW91c2VVcFwiXSA9IDBdID0gXCJNb3VzZVVwXCI7XG4gICAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIk1vdXNlRG93blwiXSA9IDFdID0gXCJNb3VzZURvd25cIjtcbiAgICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiQ2xpY2tcIl0gPSAyXSA9IFwiQ2xpY2tcIjtcbiAgICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiQ29udGV4dE1lbnVcIl0gPSAzXSA9IFwiQ29udGV4dE1lbnVcIjtcbiAgICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiRGJsQ2xpY2tcIl0gPSA0XSA9IFwiRGJsQ2xpY2tcIjtcbiAgICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiRm9jdXNcIl0gPSA1XSA9IFwiRm9jdXNcIjtcbiAgICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiQmx1clwiXSA9IDZdID0gXCJCbHVyXCI7XG4gICAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIlRvdWNoU3RhcnRcIl0gPSA3XSA9IFwiVG91Y2hTdGFydFwiO1xuICAgIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJUb3VjaE1vdmVfRGVwYXJ0ZWRcIl0gPSA4XSA9IFwiVG91Y2hNb3ZlX0RlcGFydGVkXCI7XG4gICAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIlRvdWNoRW5kXCJdID0gOV0gPSBcIlRvdWNoRW5kXCI7XG4gICAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIlRvdWNoQ2FuY2VsXCJdID0gMTBdID0gXCJUb3VjaENhbmNlbFwiO1xuICAgIHJldHVybiBNb3VzZUludGVyYWN0aW9uczI7XG59KE1vdXNlSW50ZXJhY3Rpb25zIHx8IHt9KTtcbnZhciBQb2ludGVyVHlwZXMgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oUG9pbnRlclR5cGVzMikge1xuICAgIFBvaW50ZXJUeXBlczJbUG9pbnRlclR5cGVzMltcIk1vdXNlXCJdID0gMF0gPSBcIk1vdXNlXCI7XG4gICAgUG9pbnRlclR5cGVzMltQb2ludGVyVHlwZXMyW1wiUGVuXCJdID0gMV0gPSBcIlBlblwiO1xuICAgIFBvaW50ZXJUeXBlczJbUG9pbnRlclR5cGVzMltcIlRvdWNoXCJdID0gMl0gPSBcIlRvdWNoXCI7XG4gICAgcmV0dXJuIFBvaW50ZXJUeXBlczI7XG59KFBvaW50ZXJUeXBlcyB8fCB7fSk7XG52YXIgQ2FudmFzQ29udGV4dCA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbihDYW52YXNDb250ZXh0Mikge1xuICAgIENhbnZhc0NvbnRleHQyW0NhbnZhc0NvbnRleHQyW1wiMkRcIl0gPSAwXSA9IFwiMkRcIjtcbiAgICBDYW52YXNDb250ZXh0MltDYW52YXNDb250ZXh0MltcIldlYkdMXCJdID0gMV0gPSBcIldlYkdMXCI7XG4gICAgQ2FudmFzQ29udGV4dDJbQ2FudmFzQ29udGV4dDJbXCJXZWJHTDJcIl0gPSAyXSA9IFwiV2ViR0wyXCI7XG4gICAgcmV0dXJuIENhbnZhc0NvbnRleHQyO1xufShDYW52YXNDb250ZXh0IHx8IHt9KTtcbnZhciBNZWRpYUludGVyYWN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbihNZWRpYUludGVyYWN0aW9uczIpIHtcbiAgICBNZWRpYUludGVyYWN0aW9uczJbTWVkaWFJbnRlcmFjdGlvbnMyW1wiUGxheVwiXSA9IDBdID0gXCJQbGF5XCI7XG4gICAgTWVkaWFJbnRlcmFjdGlvbnMyW01lZGlhSW50ZXJhY3Rpb25zMltcIlBhdXNlXCJdID0gMV0gPSBcIlBhdXNlXCI7XG4gICAgTWVkaWFJbnRlcmFjdGlvbnMyW01lZGlhSW50ZXJhY3Rpb25zMltcIlNlZWtlZFwiXSA9IDJdID0gXCJTZWVrZWRcIjtcbiAgICBNZWRpYUludGVyYWN0aW9uczJbTWVkaWFJbnRlcmFjdGlvbnMyW1wiVm9sdW1lQ2hhbmdlXCJdID0gM10gPSBcIlZvbHVtZUNoYW5nZVwiO1xuICAgIE1lZGlhSW50ZXJhY3Rpb25zMltNZWRpYUludGVyYWN0aW9uczJbXCJSYXRlQ2hhbmdlXCJdID0gNF0gPSBcIlJhdGVDaGFuZ2VcIjtcbiAgICByZXR1cm4gTWVkaWFJbnRlcmFjdGlvbnMyO1xufShNZWRpYUludGVyYWN0aW9ucyB8fCB7fSk7XG52YXIgTm9kZVR5cGUgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oTm9kZVR5cGUyKSB7XG4gICAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkRvY3VtZW50XCJdID0gMF0gPSBcIkRvY3VtZW50XCI7XG4gICAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkRvY3VtZW50VHlwZVwiXSA9IDFdID0gXCJEb2N1bWVudFR5cGVcIjtcbiAgICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiRWxlbWVudFwiXSA9IDJdID0gXCJFbGVtZW50XCI7XG4gICAgTm9kZVR5cGUyW05vZGVUeXBlMltcIlRleHRcIl0gPSAzXSA9IFwiVGV4dFwiO1xuICAgIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJDREFUQVwiXSA9IDRdID0gXCJDREFUQVwiO1xuICAgIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJDb21tZW50XCJdID0gNV0gPSBcIkNvbW1lbnRcIjtcbiAgICByZXR1cm4gTm9kZVR5cGUyO1xufShOb2RlVHlwZSB8fCB7fSk7XG5mdW5jdGlvbiBpc05vZGVJbkxpbmtlZExpc3QobjIpIHtcbiAgICByZXR1cm4gXCJfX2xuXCIgaW4gbjI7XG59XG52YXIgRG91YmxlTGlua2VkTGlzdCA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gRG91YmxlTGlua2VkTGlzdCgpIHtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwibGVuZ3RoXCIsIDApO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJoZWFkXCIsIG51bGwpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJ0YWlsXCIsIG51bGwpO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gRG91YmxlTGlua2VkTGlzdC5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChwb3NpdGlvbikge1xuICAgICAgICBpZiAocG9zaXRpb24gPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvc2l0aW9uIG91dHNpZGUgb2YgbGlzdCByYW5nZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuaGVhZDtcbiAgICAgICAgZm9yKHZhciBpbmRleDIgPSAwOyBpbmRleDIgPCBwb3NpdGlvbjsgaW5kZXgyKyspe1xuICAgICAgICAgICAgY3VycmVudCA9IChjdXJyZW50ID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50Lm5leHQpIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfTtcbiAgICBfcHJvdG8uYWRkTm9kZSA9IGZ1bmN0aW9uIGFkZE5vZGUobjIpIHtcbiAgICAgICAgdmFyIG5vZGUyID0ge1xuICAgICAgICAgICAgdmFsdWU6IG4yLFxuICAgICAgICAgICAgcHJldmlvdXM6IG51bGwsXG4gICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIG4yLl9fbG4gPSBub2RlMjtcbiAgICAgICAgaWYgKG4yLnByZXZpb3VzU2libGluZyAmJiBpc05vZGVJbkxpbmtlZExpc3QobjIucHJldmlvdXNTaWJsaW5nKSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBuMi5wcmV2aW91c1NpYmxpbmcuX19sbi5uZXh0O1xuICAgICAgICAgICAgbm9kZTIubmV4dCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICBub2RlMi5wcmV2aW91cyA9IG4yLnByZXZpb3VzU2libGluZy5fX2xuO1xuICAgICAgICAgICAgbjIucHJldmlvdXNTaWJsaW5nLl9fbG4ubmV4dCA9IG5vZGUyO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LnByZXZpb3VzID0gbm9kZTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobjIubmV4dFNpYmxpbmcgJiYgaXNOb2RlSW5MaW5rZWRMaXN0KG4yLm5leHRTaWJsaW5nKSAmJiBuMi5uZXh0U2libGluZy5fX2xuLnByZXZpb3VzKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudDEgPSBuMi5uZXh0U2libGluZy5fX2xuLnByZXZpb3VzO1xuICAgICAgICAgICAgbm9kZTIucHJldmlvdXMgPSBjdXJyZW50MTtcbiAgICAgICAgICAgIG5vZGUyLm5leHQgPSBuMi5uZXh0U2libGluZy5fX2xuO1xuICAgICAgICAgICAgbjIubmV4dFNpYmxpbmcuX19sbi5wcmV2aW91cyA9IG5vZGUyO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQxKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudDEubmV4dCA9IG5vZGUyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGVhZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhZC5wcmV2aW91cyA9IG5vZGUyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZTIubmV4dCA9IHRoaXMuaGVhZDtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IG5vZGUyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlMi5uZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRhaWwgPSBub2RlMjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH07XG4gICAgX3Byb3RvLnJlbW92ZU5vZGUgPSBmdW5jdGlvbiByZW1vdmVOb2RlKG4yKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gbjIuX19sbjtcbiAgICAgICAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnJlbnQucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgIGlmICh0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWQucHJldmlvdXMgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudC5wcmV2aW91cy5uZXh0ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQubmV4dCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQubmV4dC5wcmV2aW91cyA9IGN1cnJlbnQucHJldmlvdXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudGFpbCA9IGN1cnJlbnQucHJldmlvdXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4yLl9fbG4pIHtcbiAgICAgICAgICAgIGRlbGV0ZSBuMi5fX2xuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgfTtcbiAgICByZXR1cm4gRG91YmxlTGlua2VkTGlzdDtcbn0oKTtcbnZhciBtb3ZlS2V5ID0gZnVuY3Rpb24oaWQsIHBhcmVudElkKSB7XG4gICAgcmV0dXJuIGlkICsgXCJAXCIgKyBwYXJlbnRJZDtcbn07XG52YXIgTXV0YXRpb25CdWZmZXIgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIE11dGF0aW9uQnVmZmVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJmcm96ZW5cIiwgZmFsc2UpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJsb2NrZWRcIiwgZmFsc2UpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJ0ZXh0c1wiLCBbXSk7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImF0dHJpYnV0ZXNcIiwgW10pO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJhdHRyaWJ1dGVNYXBcIiwgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJyZW1vdmVzXCIsIFtdKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwibWFwUmVtb3Zlc1wiLCBbXSk7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcIm1vdmVkTWFwXCIsIHt9KTtcbiAgICAgICAgLyoqXG4gICAgICogdGhlIGJyb3dzZXIgTXV0YXRpb25PYnNlcnZlciBlbWl0cyBtdWx0aXBsZSBtdXRhdGlvbnMgYWZ0ZXJcbiAgICAgKiBhIGRlbGF5IGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCBtYWtpbmcgdHJhY2luZyBhZGRlZCBub2RlcyBoYXJkXG4gICAgICogaW4gb3VyIGBwcm9jZXNzTXV0YXRpb25zYCBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBGb3IgZXhhbXBsZSwgaWYgd2UgYXBwZW5kIGFuIGVsZW1lbnQgZWxfMSBpbnRvIGJvZHksIGFuZCB0aGVuIGFwcGVuZFxuICAgICAqIGFub3RoZXIgZWxlbWVudCBlbF8yIGludG8gZWxfMSwgdGhlc2UgdHdvIG11dGF0aW9ucyBtYXkgYmUgcGFzc2VkIHRvIHRoZVxuICAgICAqIGNhbGxiYWNrIGZ1bmN0aW9uIHRvZ2V0aGVyIHdoZW4gdGhlIHR3byBvcGVyYXRpb25zIHdlcmUgZG9uZS5cbiAgICAgKiBHZW5lcmFsbHkgd2UgbmVlZCB0byB0cmFjZSBjaGlsZCBub2RlcyBvZiBuZXdseSBhZGRlZCBub2RlcywgYnV0IGluIHRoaXNcbiAgICAgKiBjYXNlIGlmIHdlIGNvdW50IGVsXzIgYXMgZWxfMSdzIGNoaWxkIG5vZGUgaW4gdGhlIGZpcnN0IG11dGF0aW9uIHJlY29yZCxcbiAgICAgKiB0aGVuIHdlIHdpbGwgY291bnQgZWxfMiBhZ2FpbiBpbiB0aGUgc2Vjb25kIG11dGF0aW9uIHJlY29yZCB3aGljaCB3YXNcbiAgICAgKiBkdXBsaWNhdGVkLlxuICAgICAqIFRvIGF2b2lkIG9mIGR1cGxpY2F0ZSBjb3VudGluZyBhZGRlZCBub2Rlcywgd2UgdXNlIGEgU2V0IHRvIHN0b3JlXG4gICAgICogYWRkZWQgbm9kZXMgYW5kIGl0cyBjaGlsZCBub2RlcyBkdXJpbmcgaXRlcmF0ZSBtdXRhdGlvbiByZWNvcmRzLiBUaGVuXG4gICAgICogY29sbGVjdCBhZGRlZCBub2RlcyBmcm9tIHRoZSBTZXQgd2hpY2ggaGF2ZSBubyBkdXBsaWNhdGUgY29weS4gQnV0XG4gICAgICogdGhpcyBhbHNvIGNhdXNlcyBuZXdseSBhZGRlZCBub2RlcyB3aWxsIG5vdCBiZSBzZXJpYWxpemVkIHdpdGggaWQgQVNBUCxcbiAgICAgKiB3aGljaCBtZWFucyBhbGwgdGhlIGlkIHJlbGF0ZWQgY2FsY3VsYXRpb24gc2hvdWxkIGJlIGxhenkgdG9vLlxuICAgICAqLyBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJhZGRlZFNldFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwibW92ZWRTZXRcIiwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImRyb3BwZWRTZXRcIiwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcInJlbW92ZXNTdWJUcmVlQ2FjaGVcIiwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcIm11dGF0aW9uQ2JcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImJsb2NrQ2xhc3NcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImJsb2NrU2VsZWN0b3JcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcIm1hc2tUZXh0Q2xhc3NcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcIm1hc2tUZXh0U2VsZWN0b3JcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImlubGluZVN0eWxlc2hlZXRcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcIm1hc2tJbnB1dE9wdGlvbnNcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcIm1hc2tUZXh0Rm5cIik7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcIm1hc2tJbnB1dEZuXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJrZWVwSWZyYW1lU3JjRm5cIik7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcInJlY29yZENhbnZhc1wiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiaW5saW5lSW1hZ2VzXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJzbGltRE9NT3B0aW9uc1wiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiZGF0YVVSTE9wdGlvbnNcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImRvY1wiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwibWlycm9yXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJpZnJhbWVNYW5hZ2VyXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJzdHlsZXNoZWV0TWFuYWdlclwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwic2hhZG93RG9tTWFuYWdlclwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiY2FudmFzTWFuYWdlclwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwicHJvY2Vzc2VkTm9kZU1hbmFnZXJcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcInVuYXR0YWNoZWREb2NcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcInByb2Nlc3NNdXRhdGlvbnNcIiwgZnVuY3Rpb24obXV0YXRpb25zKSB7XG4gICAgICAgICAgICBtdXRhdGlvbnMuZm9yRWFjaChfdGhpcy5wcm9jZXNzTXV0YXRpb24pO1xuICAgICAgICAgICAgX3RoaXMuZW1pdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiZW1pdFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5mcm96ZW4gfHwgX3RoaXMubG9ja2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFkZHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBhZGRlZElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICAgICAgICB2YXIgYWRkTGlzdCA9IG5ldyBEb3VibGVMaW5rZWRMaXN0KCk7XG4gICAgICAgICAgICB2YXIgZ2V0TmV4dElkID0gZnVuY3Rpb24objIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbnMgPSBuMjtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dElkID0gSUdOT1JFRF9OT0RFO1xuICAgICAgICAgICAgICAgIHdoaWxlKG5leHRJZCA9PT0gSUdOT1JFRF9OT0RFKXtcbiAgICAgICAgICAgICAgICAgICAgbnMgPSBucyAmJiBucy5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgbmV4dElkID0gbnMgJiYgX3RoaXMubWlycm9yLmdldElkKG5zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRJZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcHVzaEFkZCA9IGZ1bmN0aW9uKG4yKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGluZGV4LnBhcmVudE5vZGUobjIpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyZW50IHx8ICFpbkRvbShuMikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY3NzQ2FwdHVyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAobjIubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnQudGFnTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFRhZyA9PT0gXCJURVhUQVJFQVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50VGFnID09PSBcIlNUWUxFXCIgJiYgX3RoaXMuYWRkZWRTZXQuaGFzKHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc0NhcHR1cmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50SWQgPSBpc1NoYWRvd1Jvb3QocGFyZW50KSA/IF90aGlzLm1pcnJvci5nZXRJZChnZXRTaGFkb3dIb3N0KG4yKSkgOiBfdGhpcy5taXJyb3IuZ2V0SWQocGFyZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dElkID0gZ2V0TmV4dElkKG4yKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50SWQgPT09IC0xIHx8IG5leHRJZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZExpc3QuYWRkTm9kZShuMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzbiA9IHNlcmlhbGl6ZU5vZGVXaXRoSWQobjIsIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jOiBfdGhpcy5kb2MsXG4gICAgICAgICAgICAgICAgICAgIG1pcnJvcjogX3RoaXMubWlycm9yLFxuICAgICAgICAgICAgICAgICAgICBibG9ja0NsYXNzOiBfdGhpcy5ibG9ja0NsYXNzLFxuICAgICAgICAgICAgICAgICAgICBibG9ja1NlbGVjdG9yOiBfdGhpcy5ibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dENsYXNzOiBfdGhpcy5tYXNrVGV4dENsYXNzLFxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yOiBfdGhpcy5tYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgICBza2lwQ2hpbGQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG5ld2x5QWRkZWRFbGVtZW50OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0OiBfdGhpcy5pbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiBfdGhpcy5tYXNrSW5wdXRPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dEZuOiBfdGhpcy5tYXNrVGV4dEZuLFxuICAgICAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbjogX3RoaXMubWFza0lucHV0Rm4sXG4gICAgICAgICAgICAgICAgICAgIHNsaW1ET01PcHRpb25zOiBfdGhpcy5zbGltRE9NT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnM6IF90aGlzLmRhdGFVUkxPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICByZWNvcmRDYW52YXM6IF90aGlzLnJlY29yZENhbnZhcyxcbiAgICAgICAgICAgICAgICAgICAgaW5saW5lSW1hZ2VzOiBfdGhpcy5pbmxpbmVJbWFnZXMsXG4gICAgICAgICAgICAgICAgICAgIG9uU2VyaWFsaXplOiBmdW5jdGlvbihjdXJyZW50Tikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2VyaWFsaXplZElmcmFtZShjdXJyZW50TiwgX3RoaXMubWlycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmlmcmFtZU1hbmFnZXIuYWRkSWZyYW1lKGN1cnJlbnROKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1NlcmlhbGl6ZWRTdHlsZXNoZWV0KGN1cnJlbnROLCBfdGhpcy5taXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3R5bGVzaGVldE1hbmFnZXIudHJhY2tMaW5rRWxlbWVudChjdXJyZW50Tik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzU2hhZG93Um9vdChuMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zaGFkb3dEb21NYW5hZ2VyLmFkZFNoYWRvd1Jvb3QoaW5kZXguc2hhZG93Um9vdChuMiksIF90aGlzLmRvYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uSWZyYW1lTG9hZDogZnVuY3Rpb24oaWZyYW1lLCBjaGlsZFNuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pZnJhbWVNYW5hZ2VyLmF0dGFjaElmcmFtZShpZnJhbWUsIGNoaWxkU24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2hhZG93RG9tTWFuYWdlci5vYnNlcnZlQXR0YWNoU2hhZG93KGlmcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uU3R5bGVzaGVldExvYWQ6IGZ1bmN0aW9uKGxpbmssIGNoaWxkU24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN0eWxlc2hlZXRNYW5hZ2VyLmF0dGFjaExpbmtFbGVtZW50KGxpbmssIGNoaWxkU24pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjc3NDYXB0dXJlZDogY3NzQ2FwdHVyZWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc24pIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiBwYXJlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRJZDogbmV4dElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTogc25cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZGVkSWRzLmFkZChzbi5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdoaWxlKF90aGlzLm1hcFJlbW92ZXMubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICBfdGhpcy5taXJyb3IucmVtb3ZlTm9kZUZyb21NYXAoX3RoaXMubWFwUmVtb3Zlcy5zaGlmdCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKF90aGlzLm1vdmVkU2V0KSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgIHZhciBuMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChpc1BhcmVudFJlbW92ZWQoX3RoaXMucmVtb3Zlc1N1YlRyZWVDYWNoZSwgbjIsIF90aGlzLm1pcnJvcikgJiYgIV90aGlzLm1vdmVkU2V0LmhhcyhpbmRleC5wYXJlbnROb2RlKG4yKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHB1c2hBZGQobjIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IxID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKF90aGlzLmFkZGVkU2V0KSwgX3N0ZXAxOyAhKF9zdGVwMSA9IF9pdGVyYXRvcjEoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgIHZhciBuMjEgPSBfc3RlcDEudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0FuY2VzdG9ySW5TZXQoX3RoaXMuZHJvcHBlZFNldCwgbjIxKSAmJiAhaXNQYXJlbnRSZW1vdmVkKF90aGlzLnJlbW92ZXNTdWJUcmVlQ2FjaGUsIG4yMSwgX3RoaXMubWlycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICBwdXNoQWRkKG4yMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0FuY2VzdG9ySW5TZXQoX3RoaXMubW92ZWRTZXQsIG4yMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaEFkZChuMjEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRyb3BwZWRTZXQuYWRkKG4yMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IG51bGw7XG4gICAgICAgICAgICB3aGlsZShhZGRMaXN0Lmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRJZCA9IF90aGlzLm1pcnJvci5nZXRJZChpbmRleC5wYXJlbnROb2RlKGNhbmRpZGF0ZS52YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dElkID0gZ2V0TmV4dElkKGNhbmRpZGF0ZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRJZCAhPT0gLTEgJiYgbmV4dElkICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTIgPSBjYW5kaWRhdGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlMikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFpbE5vZGUgPSBhZGRMaXN0LnRhaWw7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKHRhaWxOb2RlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfbm9kZSA9IHRhaWxOb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFpbE5vZGUgPSB0YWlsTm9kZS5wcmV2aW91cztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRJZDEgPSBfdGhpcy5taXJyb3IuZ2V0SWQoaW5kZXgucGFyZW50Tm9kZShfbm9kZS52YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0SWQxID0gZ2V0TmV4dElkKF9ub2RlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dElkMSA9PT0gLTEpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudElkMSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTIgPSBfbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVuaGFuZGxlZE5vZGUgPSBfbm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGluZGV4LnBhcmVudE5vZGUodW5oYW5kbGVkTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaGFkb3dIb3N0ID0gaW5kZXguaG9zdChwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudElkMiA9IF90aGlzLm1pcnJvci5nZXRJZChzaGFkb3dIb3N0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRJZDIgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTIgPSBfbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUyKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKGFkZExpc3QuaGVhZCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRMaXN0LnJlbW92ZU5vZGUoYWRkTGlzdC5oZWFkLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlID0gbm9kZTIucHJldmlvdXM7XG4gICAgICAgICAgICAgICAgYWRkTGlzdC5yZW1vdmVOb2RlKG5vZGUyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBwdXNoQWRkKG5vZGUyLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHRleHRzOiBfdGhpcy50ZXh0cy5tYXAoZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbjIgPSB0ZXh0Lm5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBpbmRleC5wYXJlbnROb2RlKG4yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5nZW5UZXh0QXJlYVZhbHVlTXV0YXRpb24ocGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IF90aGlzLm1pcnJvci5nZXRJZChuMiksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGV4dC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhYWRkZWRJZHMuaGFzKHRleHQuaWQpO1xuICAgICAgICAgICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5taXJyb3IuaGFzKHRleHQuaWQpO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IF90aGlzLmF0dHJpYnV0ZXMubWFwKGZ1bmN0aW9uKGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZS5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMuc3R5bGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaWZmQXNTdHIgPSBKU09OLnN0cmluZ2lmeShhdHRyaWJ1dGUuc3R5bGVEaWZmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1bmNoYW5nZWRBc1N0ciA9IEpTT04uc3RyaW5naWZ5KGF0dHJpYnV0ZS5fdW5jaGFuZ2VkU3R5bGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaWZmQXNTdHIubGVuZ3RoIDwgYXR0cmlidXRlcy5zdHlsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGRpZmZBc1N0ciArIHVuY2hhbmdlZEFzU3RyKS5zcGxpdChcInZhcihcIikubGVuZ3RoID09PSBhdHRyaWJ1dGVzLnN0eWxlLnNwbGl0KFwidmFyKFwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcy5zdHlsZSA9IGF0dHJpYnV0ZS5zdHlsZURpZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogX3RoaXMubWlycm9yLmdldElkKGF0dHJpYnV0ZS5ub2RlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24oYXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhYWRkZWRJZHMuaGFzKGF0dHJpYnV0ZS5pZCk7XG4gICAgICAgICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubWlycm9yLmhhcyhhdHRyaWJ1dGUuaWQpO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHJlbW92ZXM6IF90aGlzLnJlbW92ZXMsXG4gICAgICAgICAgICAgICAgYWRkczogYWRkc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghcGF5bG9hZC50ZXh0cy5sZW5ndGggJiYgIXBheWxvYWQuYXR0cmlidXRlcy5sZW5ndGggJiYgIXBheWxvYWQucmVtb3Zlcy5sZW5ndGggJiYgIXBheWxvYWQuYWRkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy50ZXh0cyA9IFtdO1xuICAgICAgICAgICAgX3RoaXMuYXR0cmlidXRlcyA9IFtdO1xuICAgICAgICAgICAgX3RoaXMuYXR0cmlidXRlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgICAgICAgICBfdGhpcy5yZW1vdmVzID0gW107XG4gICAgICAgICAgICBfdGhpcy5hZGRlZFNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICAgICAgICBfdGhpcy5tb3ZlZFNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICAgICAgICBfdGhpcy5kcm9wcGVkU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgICAgIF90aGlzLnJlbW92ZXNTdWJUcmVlQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICAgICAgX3RoaXMubW92ZWRNYXAgPSB7fTtcbiAgICAgICAgICAgIF90aGlzLm11dGF0aW9uQ2IocGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJnZW5UZXh0QXJlYVZhbHVlTXV0YXRpb25cIiwgZnVuY3Rpb24odGV4dGFyZWEpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gX3RoaXMuYXR0cmlidXRlTWFwLmdldCh0ZXh0YXJlYSk7XG4gICAgICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpdGVtID0ge1xuICAgICAgICAgICAgICAgICAgICBub2RlOiB0ZXh0YXJlYSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlRGlmZjoge30sXG4gICAgICAgICAgICAgICAgICAgIF91bmNoYW5nZWRTdHlsZXM6IHt9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hdHRyaWJ1dGVzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYXR0cmlidXRlTWFwLnNldCh0ZXh0YXJlYSwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBBcnJheS5mcm9tKGluZGV4LmNoaWxkTm9kZXModGV4dGFyZWEpLCBmdW5jdGlvbihjbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleC50ZXh0Q29udGVudChjbikgfHwgXCJcIjtcbiAgICAgICAgICAgIH0pLmpvaW4oXCJcIik7XG4gICAgICAgICAgICBpdGVtLmF0dHJpYnV0ZXMudmFsdWUgPSBtYXNrSW5wdXRWYWx1ZSh7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogdGV4dGFyZWEsXG4gICAgICAgICAgICAgICAgbWFza0lucHV0T3B0aW9uczogX3RoaXMubWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiB0ZXh0YXJlYS50YWdOYW1lLFxuICAgICAgICAgICAgICAgIHR5cGU6IGdldElucHV0VHlwZSh0ZXh0YXJlYSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIG1hc2tJbnB1dEZuOiBfdGhpcy5tYXNrSW5wdXRGblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJwcm9jZXNzTXV0YXRpb25cIiwgZnVuY3Rpb24obSkge1xuICAgICAgICAgICAgaWYgKGlzSWdub3JlZChtLnRhcmdldCwgX3RoaXMubWlycm9yLCBfdGhpcy5zbGltRE9NT3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2gobS50eXBlKXtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY2hhcmFjdGVyRGF0YVwiOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBpbmRleC50ZXh0Q29udGVudChtLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQmxvY2tlZChtLnRhcmdldCwgX3RoaXMuYmxvY2tDbGFzcywgX3RoaXMuYmxvY2tTZWxlY3RvciwgZmFsc2UpICYmIHZhbHVlICE9PSBtLm9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudGV4dHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZWVkTWFza2luZ1RleHQobS50YXJnZXQsIF90aGlzLm1hc2tUZXh0Q2xhc3MsIF90aGlzLm1hc2tUZXh0U2VsZWN0b3IsIHRydWUpICYmIHZhbHVlID8gX3RoaXMubWFza1RleHRGbiA/IF90aGlzLm1hc2tUZXh0Rm4odmFsdWUsIGNsb3Nlc3RFbGVtZW50T2ZOb2RlKG0udGFyZ2V0KSkgOiB2YWx1ZS5yZXBsYWNlKC9bXFxTXS9nLCBcIipcIikgOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTogbS50YXJnZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcImF0dHJpYnV0ZXNcIjpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IG0udGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBtLmF0dHJpYnV0ZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUxID0gbS50YXJnZXQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUgPT09IFwidmFsdWVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZ2V0SW5wdXRUeXBlKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUxID0gbWFza0lucHV0VmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnM6IF90aGlzLm1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ05hbWU6IHRhcmdldC50YWdOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbjogX3RoaXMubWFza0lucHV0Rm5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Jsb2NrZWQobS50YXJnZXQsIF90aGlzLmJsb2NrQ2xhc3MsIF90aGlzLmJsb2NrU2VsZWN0b3IsIGZhbHNlKSB8fCB2YWx1ZTEgPT09IG0ub2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IF90aGlzLmF0dHJpYnV0ZU1hcC5nZXQobS50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldC50YWdOYW1lID09PSBcIklGUkFNRVwiICYmIGF0dHJpYnV0ZU5hbWUgPT09IFwic3JjXCIgJiYgIV90aGlzLmtlZXBJZnJhbWVTcmNGbih2YWx1ZTEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQuY29udGVudERvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWUgPSBcInJyX3NyY1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlOiBtLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlRGlmZjoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF91bmNoYW5nZWRTdHlsZXM6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRyaWJ1dGVzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cmlidXRlTWFwLnNldChtLnRhcmdldCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSA9PT0gXCJ0eXBlXCIgJiYgdGFyZ2V0LnRhZ05hbWUgPT09IFwiSU5QVVRcIiAmJiAobS5vbGRWYWx1ZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpID09PSBcInBhc3N3b3JkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwiZGF0YS1yci1pcy1wYXNzd29yZFwiLCBcInRydWVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlnbm9yZUF0dHJpYnV0ZSh0YXJnZXQudGFnTmFtZSwgYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPSB0cmFuc2Zvcm1BdHRyaWJ1dGUoX3RoaXMuZG9jLCB0b0xvd2VyQ2FzZSh0YXJnZXQudGFnTmFtZSksIHRvTG93ZXJDYXNlKGF0dHJpYnV0ZU5hbWUpLCB2YWx1ZTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVOYW1lID09PSBcInN0eWxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy51bmF0dGFjaGVkRG9jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnVuYXR0YWNoZWREb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudW5hdHRhY2hlZERvYyA9IF90aGlzLmRvYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkID0gX3RoaXMudW5hdHRhY2hlZERvYy5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0ub2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBtLm9sZFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShBcnJheS5mcm9tKHRhcmdldC5zdHlsZSkpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG5hbWUgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHRhcmdldC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdQcmlvcml0eSA9IHRhcmdldC5zdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KHBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkLnN0eWxlLmdldFByb3BlcnR5VmFsdWUocG5hbWUpIHx8IG5ld1ByaW9yaXR5ICE9PSBvbGQuc3R5bGUuZ2V0UHJvcGVydHlQcmlvcml0eShwbmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3UHJpb3JpdHkgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zdHlsZURpZmZbcG5hbWVdID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zdHlsZURpZmZbcG5hbWVdID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdQcmlvcml0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5fdW5jaGFuZ2VkU3R5bGVzW3BuYW1lXSA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ByaW9yaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvcjEgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UoQXJyYXkuZnJvbShvbGQuc3R5bGUpKSwgX3N0ZXAxOyAhKF9zdGVwMSA9IF9pdGVyYXRvcjEoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBuYW1lMSA9IF9zdGVwMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwbmFtZTEpID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zdHlsZURpZmZbcG5hbWUxXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhdHRyaWJ1dGVOYW1lID09PSBcIm9wZW5cIiAmJiB0YXJnZXQudGFnTmFtZSA9PT0gXCJESUFMT0dcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Lm1hdGNoZXMoXCJkaWFsb2c6bW9kYWxcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYXR0cmlidXRlc1tcInJyX29wZW5fbW9kZVwiXSA9IFwibW9kYWxcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYXR0cmlidXRlc1tcInJyX29wZW5fbW9kZVwiXSA9IFwibm9uLW1vZGFsXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZExpc3RcIjpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQmxvY2tlZChtLnRhcmdldCwgX3RoaXMuYmxvY2tDbGFzcywgX3RoaXMuYmxvY2tTZWxlY3RvciwgdHJ1ZSkpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtLnRhcmdldC50YWdOYW1lID09PSBcIlRFWFRBUkVBXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5nZW5UZXh0QXJlYVZhbHVlTXV0YXRpb24obS50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG0uYWRkZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG4yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdlbkFkZHMobjIsIG0udGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbS5yZW1vdmVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbihuMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlSWQgPSBfdGhpcy5taXJyb3IuZ2V0SWQobjIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRJZCA9IGlzU2hhZG93Um9vdChtLnRhcmdldCkgPyBfdGhpcy5taXJyb3IuZ2V0SWQoaW5kZXguaG9zdChtLnRhcmdldCkpIDogX3RoaXMubWlycm9yLmdldElkKG0udGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNCbG9ja2VkKG0udGFyZ2V0LCBfdGhpcy5ibG9ja0NsYXNzLCBfdGhpcy5ibG9ja1NlbGVjdG9yLCBmYWxzZSkgfHwgaXNJZ25vcmVkKG4yLCBfdGhpcy5taXJyb3IsIF90aGlzLnNsaW1ET01PcHRpb25zKSB8fCAhaXNTZXJpYWxpemVkKG4yLCBfdGhpcy5taXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmFkZGVkU2V0LmhhcyhuMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVlcERlbGV0ZShfdGhpcy5hZGRlZFNldCwgbjIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kcm9wcGVkU2V0LmFkZChuMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChfdGhpcy5hZGRlZFNldC5oYXMobS50YXJnZXQpICYmIG5vZGVJZCA9PT0gLTEpIDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0FuY2VzdG9yUmVtb3ZlZChtLnRhcmdldCwgX3RoaXMubWlycm9yKSkgO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLm1vdmVkU2V0LmhhcyhuMikgJiYgX3RoaXMubW92ZWRNYXBbbW92ZUtleShub2RlSWQsIHBhcmVudElkKV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVlcERlbGV0ZShfdGhpcy5tb3ZlZFNldCwgbjIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbW92ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZDogcGFyZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogbm9kZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTaGFkb3c6IGlzU2hhZG93Um9vdChtLnRhcmdldCkgJiYgaXNOYXRpdmVTaGFkb3dEb20obS50YXJnZXQpID8gdHJ1ZSA6IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc1JlbW92ZXMobjIsIF90aGlzLnJlbW92ZXNTdWJUcmVlQ2FjaGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXBSZW1vdmVzLnB1c2gobjIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICogTWFrZSBzdXJlIHlvdSBjaGVjayBpZiBgbmAncyBwYXJlbnQgaXMgYmxvY2tlZCBiZWZvcmUgY2FsbGluZyB0aGlzIGZ1bmN0aW9uXG4gICAgICogKi8gX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiZ2VuQWRkc1wiLCBmdW5jdGlvbihuMiwgdGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvY2Vzc2VkTm9kZU1hbmFnZXIuaW5PdGhlckJ1ZmZlcihuMiwgX3RoaXMpKSByZXR1cm47XG4gICAgICAgICAgICBpZiAoX3RoaXMuYWRkZWRTZXQuaGFzKG4yKSB8fCBfdGhpcy5tb3ZlZFNldC5oYXMobjIpKSByZXR1cm47XG4gICAgICAgICAgICBpZiAoX3RoaXMubWlycm9yLmhhc05vZGUobjIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzSWdub3JlZChuMiwgX3RoaXMubWlycm9yLCBfdGhpcy5zbGltRE9NT3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5tb3ZlZFNldC5hZGQobjIpO1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAmJiBfdGhpcy5taXJyb3IuaGFzTm9kZSh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldElkID0gX3RoaXMubWlycm9yLmdldElkKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRJZCAmJiB0YXJnZXRJZCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubW92ZWRNYXBbbW92ZUtleShfdGhpcy5taXJyb3IuZ2V0SWQobjIpLCB0YXJnZXRJZCldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLmFkZGVkU2V0LmFkZChuMik7XG4gICAgICAgICAgICAgICAgX3RoaXMuZHJvcHBlZFNldC5kZWxldGUobjIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0Jsb2NrZWQobjIsIF90aGlzLmJsb2NrQ2xhc3MsIF90aGlzLmJsb2NrU2VsZWN0b3IsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIGluZGV4LmNoaWxkTm9kZXMobjIpLmZvckVhY2goZnVuY3Rpb24oY2hpbGROKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZW5BZGRzKGNoaWxkTik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1NoYWRvd1Jvb3QobjIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4LmNoaWxkTm9kZXMoaW5kZXguc2hhZG93Um9vdChuMikpLmZvckVhY2goZnVuY3Rpb24oY2hpbGROKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9jZXNzZWROb2RlTWFuYWdlci5hZGQoY2hpbGROLCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5nZW5BZGRzKGNoaWxkTiwgbjIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gTXV0YXRpb25CdWZmZXIucHJvdG90eXBlO1xuICAgIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIFtcbiAgICAgICAgICAgIFwibXV0YXRpb25DYlwiLFxuICAgICAgICAgICAgXCJibG9ja0NsYXNzXCIsXG4gICAgICAgICAgICBcImJsb2NrU2VsZWN0b3JcIixcbiAgICAgICAgICAgIFwibWFza1RleHRDbGFzc1wiLFxuICAgICAgICAgICAgXCJtYXNrVGV4dFNlbGVjdG9yXCIsXG4gICAgICAgICAgICBcImlubGluZVN0eWxlc2hlZXRcIixcbiAgICAgICAgICAgIFwibWFza0lucHV0T3B0aW9uc1wiLFxuICAgICAgICAgICAgXCJtYXNrVGV4dEZuXCIsXG4gICAgICAgICAgICBcIm1hc2tJbnB1dEZuXCIsXG4gICAgICAgICAgICBcImtlZXBJZnJhbWVTcmNGblwiLFxuICAgICAgICAgICAgXCJyZWNvcmRDYW52YXNcIixcbiAgICAgICAgICAgIFwiaW5saW5lSW1hZ2VzXCIsXG4gICAgICAgICAgICBcInNsaW1ET01PcHRpb25zXCIsXG4gICAgICAgICAgICBcImRhdGFVUkxPcHRpb25zXCIsXG4gICAgICAgICAgICBcImRvY1wiLFxuICAgICAgICAgICAgXCJtaXJyb3JcIixcbiAgICAgICAgICAgIFwiaWZyYW1lTWFuYWdlclwiLFxuICAgICAgICAgICAgXCJzdHlsZXNoZWV0TWFuYWdlclwiLFxuICAgICAgICAgICAgXCJzaGFkb3dEb21NYW5hZ2VyXCIsXG4gICAgICAgICAgICBcImNhbnZhc01hbmFnZXJcIixcbiAgICAgICAgICAgIFwicHJvY2Vzc2VkTm9kZU1hbmFnZXJcIlxuICAgICAgICBdLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBfdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5mcmVlemUgPSBmdW5jdGlvbiBmcmVlemUoKSB7XG4gICAgICAgIHRoaXMuZnJvemVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jYW52YXNNYW5hZ2VyLmZyZWV6ZSgpO1xuICAgIH07XG4gICAgX3Byb3RvLnVuZnJlZXplID0gZnVuY3Rpb24gdW5mcmVlemUoKSB7XG4gICAgICAgIHRoaXMuZnJvemVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FudmFzTWFuYWdlci51bmZyZWV6ZSgpO1xuICAgICAgICB0aGlzLmVtaXQoKTtcbiAgICB9O1xuICAgIF9wcm90by5pc0Zyb3plbiA9IGZ1bmN0aW9uIGlzRnJvemVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm96ZW47XG4gICAgfTtcbiAgICBfcHJvdG8ubG9jayA9IGZ1bmN0aW9uIGxvY2soKSB7XG4gICAgICAgIHRoaXMubG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jYW52YXNNYW5hZ2VyLmxvY2soKTtcbiAgICB9O1xuICAgIF9wcm90by51bmxvY2sgPSBmdW5jdGlvbiB1bmxvY2soKSB7XG4gICAgICAgIHRoaXMubG9ja2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FudmFzTWFuYWdlci51bmxvY2soKTtcbiAgICAgICAgdGhpcy5lbWl0KCk7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgdGhpcy5zaGFkb3dEb21NYW5hZ2VyLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuY2FudmFzTWFuYWdlci5yZXNldCgpO1xuICAgIH07XG4gICAgcmV0dXJuIE11dGF0aW9uQnVmZmVyO1xufSgpO1xuZnVuY3Rpb24gZGVlcERlbGV0ZShhZGRzU2V0LCBuMikge1xuICAgIGFkZHNTZXQuZGVsZXRlKG4yKTtcbiAgICBpbmRleC5jaGlsZE5vZGVzKG4yKS5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkTikge1xuICAgICAgICByZXR1cm4gZGVlcERlbGV0ZShhZGRzU2V0LCBjaGlsZE4pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcHJvY2Vzc1JlbW92ZXMobjIsIGNhY2hlKSB7XG4gICAgdmFyIHF1ZXVlID0gW1xuICAgICAgICBuMlxuICAgIF07XG4gICAgd2hpbGUocXVldWUubGVuZ3RoKXtcbiAgICAgICAgdmFyIG5leHQgPSBxdWV1ZS5wb3AoKTtcbiAgICAgICAgaWYgKGNhY2hlLmhhcyhuZXh0KSkgY29udGludWU7XG4gICAgICAgIGNhY2hlLmFkZChuZXh0KTtcbiAgICAgICAgaW5kZXguY2hpbGROb2RlcyhuZXh0KS5mb3JFYWNoKGZ1bmN0aW9uKG4yMikge1xuICAgICAgICAgICAgcmV0dXJuIHF1ZXVlLnB1c2gobjIyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybjtcbn1cbmZ1bmN0aW9uIGlzUGFyZW50UmVtb3ZlZChyZW1vdmVzLCBuMiwgbWlycm9yMikge1xuICAgIGlmIChyZW1vdmVzLnNpemUgPT09IDApIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gX2lzUGFyZW50UmVtb3ZlZChyZW1vdmVzLCBuMik7XG59XG5mdW5jdGlvbiBfaXNQYXJlbnRSZW1vdmVkKHJlbW92ZXMsIG4yLCBfbWlycm9yMikge1xuICAgIHZhciBub2RlMiA9IGluZGV4LnBhcmVudE5vZGUobjIpO1xuICAgIGlmICghbm9kZTIpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gcmVtb3Zlcy5oYXMobm9kZTIpO1xufVxuZnVuY3Rpb24gaXNBbmNlc3RvckluU2V0KHNldCwgbjIpIHtcbiAgICBpZiAoc2V0LnNpemUgPT09IDApIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gX2lzQW5jZXN0b3JJblNldChzZXQsIG4yKTtcbn1cbmZ1bmN0aW9uIF9pc0FuY2VzdG9ySW5TZXQoc2V0LCBuMikge1xuICAgIHZhciBwYXJlbnQgPSBpbmRleC5wYXJlbnROb2RlKG4yKTtcbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzZXQuaGFzKHBhcmVudCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBfaXNBbmNlc3RvckluU2V0KHNldCwgcGFyZW50KTtcbn1cbnZhciBlcnJvckhhbmRsZXI7XG5mdW5jdGlvbiByZWdpc3RlckVycm9ySGFuZGxlcihoYW5kbGVyKSB7XG4gICAgZXJyb3JIYW5kbGVyID0gaGFuZGxlcjtcbn1cbmZ1bmN0aW9uIHVucmVnaXN0ZXJFcnJvckhhbmRsZXIoKSB7XG4gICAgZXJyb3JIYW5kbGVyID0gdm9pZCAwO1xufVxudmFyIGNhbGxiYWNrV3JhcHBlciA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgaWYgKCFlcnJvckhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIGNiO1xuICAgIH1cbiAgICB2YXIgcnJ3ZWJXcmFwcGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIHJlc3RbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBjYi5hcHBseSh2b2lkIDAsIFtdLmNvbmNhdChyZXN0KSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3JIYW5kbGVyICYmIGVycm9ySGFuZGxlcihlcnJvcikgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHJyd2ViV3JhcHBlZDtcbn07XG52YXIgbXV0YXRpb25CdWZmZXJzID0gW107XG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChldmVudCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChcImNvbXBvc2VkUGF0aFwiIGluIGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IGV2ZW50LmNvbXBvc2VkUGF0aCgpO1xuICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoXCJwYXRoXCIgaW4gZXZlbnQgJiYgZXZlbnQucGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudC5wYXRoWzBdO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZXZlbnQgJiYgZXZlbnQudGFyZ2V0O1xufVxuZnVuY3Rpb24gaW5pdE11dGF0aW9uT2JzZXJ2ZXIob3B0aW9ucywgcm9vdEVsKSB7XG4gICAgdmFyIG11dGF0aW9uQnVmZmVyID0gbmV3IE11dGF0aW9uQnVmZmVyKCk7XG4gICAgbXV0YXRpb25CdWZmZXJzLnB1c2gobXV0YXRpb25CdWZmZXIpO1xuICAgIG11dGF0aW9uQnVmZmVyLmluaXQob3B0aW9ucyk7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IChtdXRhdGlvbk9ic2VydmVyQ3RvcigpKShjYWxsYmFja1dyYXBwZXIobXV0YXRpb25CdWZmZXIucHJvY2Vzc011dGF0aW9ucy5iaW5kKG11dGF0aW9uQnVmZmVyKSkpO1xuICAgIG9ic2VydmVyLm9ic2VydmUocm9vdEVsLCB7XG4gICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgIGF0dHJpYnV0ZU9sZFZhbHVlOiB0cnVlLFxuICAgICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgICAgICBjaGFyYWN0ZXJEYXRhT2xkVmFsdWU6IHRydWUsXG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBvYnNlcnZlcjtcbn1cbmZ1bmN0aW9uIGluaXRNb3ZlT2JzZXJ2ZXIocGFyYW0pIHtcbiAgICB2YXIgbW91c2Vtb3ZlQ2IgPSBwYXJhbS5tb3VzZW1vdmVDYiwgc2FtcGxpbmcgPSBwYXJhbS5zYW1wbGluZywgZG9jID0gcGFyYW0uZG9jLCBtaXJyb3IyID0gcGFyYW0ubWlycm9yO1xuICAgIGlmIChzYW1wbGluZy5tb3VzZW1vdmUgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgICB2YXIgdGhyZXNob2xkID0gdHlwZW9mIHNhbXBsaW5nLm1vdXNlbW92ZSA9PT0gXCJudW1iZXJcIiA/IHNhbXBsaW5nLm1vdXNlbW92ZSA6IDUwO1xuICAgIHZhciBjYWxsYmFja1RocmVzaG9sZCA9IHR5cGVvZiBzYW1wbGluZy5tb3VzZW1vdmVDYWxsYmFjayA9PT0gXCJudW1iZXJcIiA/IHNhbXBsaW5nLm1vdXNlbW92ZUNhbGxiYWNrIDogNTAwO1xuICAgIHZhciBwb3NpdGlvbnMgPSBbXTtcbiAgICB2YXIgdGltZUJhc2VsaW5lO1xuICAgIHZhciB3cmFwcGVkQ2IgPSB0aHJvdHRsZShjYWxsYmFja1dyYXBwZXIoZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIHZhciB0b3RhbE9mZnNldCA9IERhdGUubm93KCkgLSB0aW1lQmFzZWxpbmU7XG4gICAgICAgIG1vdXNlbW92ZUNiKHBvc2l0aW9ucy5tYXAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgcC50aW1lT2Zmc2V0IC09IHRvdGFsT2Zmc2V0O1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0pLCBzb3VyY2UpO1xuICAgICAgICBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgdGltZUJhc2VsaW5lID0gbnVsbDtcbiAgICB9KSwgY2FsbGJhY2tUaHJlc2hvbGQpO1xuICAgIHZhciB1cGRhdGVQb3NpdGlvbiA9IGNhbGxiYWNrV3JhcHBlcih0aHJvdHRsZShjYWxsYmFja1dyYXBwZXIoZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldnQpO1xuICAgICAgICB2YXIgX3JlZiA9IGxlZ2FjeV9pc1RvdWNoRXZlbnQoZXZ0KSA/IGV2dC5jaGFuZ2VkVG91Y2hlc1swXSA6IGV2dCwgY2xpZW50WCA9IF9yZWYuY2xpZW50WCwgY2xpZW50WSA9IF9yZWYuY2xpZW50WTtcbiAgICAgICAgaWYgKCF0aW1lQmFzZWxpbmUpIHtcbiAgICAgICAgICAgIHRpbWVCYXNlbGluZSA9IG5vd1RpbWVzdGFtcCgpO1xuICAgICAgICB9XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHg6IGNsaWVudFgsXG4gICAgICAgICAgICB5OiBjbGllbnRZLFxuICAgICAgICAgICAgaWQ6IG1pcnJvcjIuZ2V0SWQodGFyZ2V0KSxcbiAgICAgICAgICAgIHRpbWVPZmZzZXQ6IG5vd1RpbWVzdGFtcCgpIC0gdGltZUJhc2VsaW5lXG4gICAgICAgIH0pO1xuICAgICAgICB3cmFwcGVkQ2IodHlwZW9mIERyYWdFdmVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBfaW5zdGFuY2VvZihldnQsIERyYWdFdmVudCkgPyBJbmNyZW1lbnRhbFNvdXJjZS5EcmFnIDogX2luc3RhbmNlb2YoZXZ0LCBNb3VzZUV2ZW50KSA/IEluY3JlbWVudGFsU291cmNlLk1vdXNlTW92ZSA6IEluY3JlbWVudGFsU291cmNlLlRvdWNoTW92ZSk7XG4gICAgfSksIHRocmVzaG9sZCwge1xuICAgICAgICB0cmFpbGluZzogZmFsc2VcbiAgICB9KSk7XG4gICAgdmFyIGhhbmRsZXJzID0gW1xuICAgICAgICBvbihcIm1vdXNlbW92ZVwiLCB1cGRhdGVQb3NpdGlvbiwgZG9jKSxcbiAgICAgICAgb24oXCJ0b3VjaG1vdmVcIiwgdXBkYXRlUG9zaXRpb24sIGRvYyksXG4gICAgICAgIG9uKFwiZHJhZ1wiLCB1cGRhdGVQb3NpdGlvbiwgZG9jKVxuICAgIF07XG4gICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbigpIHtcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICByZXR1cm4gaCgpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRNb3VzZUludGVyYWN0aW9uT2JzZXJ2ZXIocGFyYW0pIHtcbiAgICB2YXIgbW91c2VJbnRlcmFjdGlvbkNiID0gcGFyYW0ubW91c2VJbnRlcmFjdGlvbkNiLCBkb2MgPSBwYXJhbS5kb2MsIG1pcnJvcjIgPSBwYXJhbS5taXJyb3IsIGJsb2NrQ2xhc3MgPSBwYXJhbS5ibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yID0gcGFyYW0uYmxvY2tTZWxlY3Rvciwgc2FtcGxpbmcgPSBwYXJhbS5zYW1wbGluZztcbiAgICBpZiAoc2FtcGxpbmcubW91c2VJbnRlcmFjdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge307XG4gICAgfVxuICAgIHZhciBkaXNhYmxlTWFwID0gc2FtcGxpbmcubW91c2VJbnRlcmFjdGlvbiA9PT0gdHJ1ZSB8fCBzYW1wbGluZy5tb3VzZUludGVyYWN0aW9uID09PSB2b2lkIDAgPyB7fSA6IHNhbXBsaW5nLm1vdXNlSW50ZXJhY3Rpb247XG4gICAgdmFyIGhhbmRsZXJzID0gW107XG4gICAgdmFyIGN1cnJlbnRQb2ludGVyVHlwZSA9IG51bGw7XG4gICAgdmFyIGdldEhhbmRsZXIgPSBmdW5jdGlvbihldmVudEtleSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldmVudCk7XG4gICAgICAgICAgICBpZiAoaXNCbG9ja2VkKHRhcmdldCwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcG9pbnRlclR5cGUgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHRoaXNFdmVudEtleSA9IGV2ZW50S2V5O1xuICAgICAgICAgICAgaWYgKFwicG9pbnRlclR5cGVcIiBpbiBldmVudCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaChldmVudC5wb2ludGVyVHlwZSl7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtb3VzZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGUgPSBQb2ludGVyVHlwZXMuTW91c2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvdWNoXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZSA9IFBvaW50ZXJUeXBlcy5Ub3VjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicGVuXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZSA9IFBvaW50ZXJUeXBlcy5QZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBvaW50ZXJUeXBlID09PSBQb2ludGVyVHlwZXMuVG91Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1vdXNlSW50ZXJhY3Rpb25zW2V2ZW50S2V5XSA9PT0gTW91c2VJbnRlcmFjdGlvbnMuTW91c2VEb3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzRXZlbnRLZXkgPSBcIlRvdWNoU3RhcnRcIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChNb3VzZUludGVyYWN0aW9uc1tldmVudEtleV0gPT09IE1vdXNlSW50ZXJhY3Rpb25zLk1vdXNlVXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNFdmVudEtleSA9IFwiVG91Y2hFbmRcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocG9pbnRlclR5cGUgPT09IFBvaW50ZXJUeXBlcy5QZW4pIDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGVnYWN5X2lzVG91Y2hFdmVudChldmVudCkpIHtcbiAgICAgICAgICAgICAgICBwb2ludGVyVHlwZSA9IFBvaW50ZXJUeXBlcy5Ub3VjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb2ludGVyVHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQb2ludGVyVHlwZSA9IHBvaW50ZXJUeXBlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzRXZlbnRLZXkuc3RhcnRzV2l0aChcIlRvdWNoXCIpICYmIHBvaW50ZXJUeXBlID09PSBQb2ludGVyVHlwZXMuVG91Y2ggfHwgdGhpc0V2ZW50S2V5LnN0YXJ0c1dpdGgoXCJNb3VzZVwiKSAmJiBwb2ludGVyVHlwZSA9PT0gUG9pbnRlclR5cGVzLk1vdXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKE1vdXNlSW50ZXJhY3Rpb25zW2V2ZW50S2V5XSA9PT0gTW91c2VJbnRlcmFjdGlvbnMuQ2xpY2spIHtcbiAgICAgICAgICAgICAgICBwb2ludGVyVHlwZSA9IGN1cnJlbnRQb2ludGVyVHlwZTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9pbnRlclR5cGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGUyID0gbGVnYWN5X2lzVG91Y2hFdmVudChldmVudCkgPyBldmVudC5jaGFuZ2VkVG91Y2hlc1swXSA6IGV2ZW50O1xuICAgICAgICAgICAgaWYgKCFlMikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpZCA9IG1pcnJvcjIuZ2V0SWQodGFyZ2V0KTtcbiAgICAgICAgICAgIHZhciBjbGllbnRYID0gZTIuY2xpZW50WCwgY2xpZW50WSA9IGUyLmNsaWVudFk7XG4gICAgICAgICAgICBjYWxsYmFja1dyYXBwZXIobW91c2VJbnRlcmFjdGlvbkNiKShfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgdHlwZTogTW91c2VJbnRlcmFjdGlvbnNbdGhpc0V2ZW50S2V5XSxcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgeDogY2xpZW50WCxcbiAgICAgICAgICAgICAgICB5OiBjbGllbnRZXG4gICAgICAgICAgICB9LCBwb2ludGVyVHlwZSAhPT0gbnVsbCAmJiB7XG4gICAgICAgICAgICAgICAgcG9pbnRlclR5cGU6IHBvaW50ZXJUeXBlXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBPYmplY3Qua2V5cyhNb3VzZUludGVyYWN0aW9ucykuZmlsdGVyKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gTnVtYmVyLmlzTmFOKE51bWJlcihrZXkpKSAmJiAha2V5LmVuZHNXaXRoKFwiX0RlcGFydGVkXCIpICYmIGRpc2FibGVNYXBba2V5XSAhPT0gZmFsc2U7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbihldmVudEtleSkge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gdG9Mb3dlckNhc2UoZXZlbnRLZXkpO1xuICAgICAgICB2YXIgaGFuZGxlciA9IGdldEhhbmRsZXIoZXZlbnRLZXkpO1xuICAgICAgICBpZiAod2luZG93LlBvaW50ZXJFdmVudCkge1xuICAgICAgICAgICAgc3dpdGNoKE1vdXNlSW50ZXJhY3Rpb25zW2V2ZW50S2V5XSl7XG4gICAgICAgICAgICAgICAgY2FzZSBNb3VzZUludGVyYWN0aW9ucy5Nb3VzZURvd246XG4gICAgICAgICAgICAgICAgY2FzZSBNb3VzZUludGVyYWN0aW9ucy5Nb3VzZVVwOlxuICAgICAgICAgICAgICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWUucmVwbGFjZShcIm1vdXNlXCIsIFwicG9pbnRlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBNb3VzZUludGVyYWN0aW9ucy5Ub3VjaFN0YXJ0OlxuICAgICAgICAgICAgICAgIGNhc2UgTW91c2VJbnRlcmFjdGlvbnMuVG91Y2hFbmQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVycy5wdXNoKG9uKGV2ZW50TmFtZSwgaGFuZGxlciwgZG9jKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbigpIHtcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICByZXR1cm4gaCgpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRTY3JvbGxPYnNlcnZlcihwYXJhbSkge1xuICAgIHZhciBzY3JvbGxDYiA9IHBhcmFtLnNjcm9sbENiLCBkb2MgPSBwYXJhbS5kb2MsIG1pcnJvcjIgPSBwYXJhbS5taXJyb3IsIGJsb2NrQ2xhc3MgPSBwYXJhbS5ibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yID0gcGFyYW0uYmxvY2tTZWxlY3Rvciwgc2FtcGxpbmcgPSBwYXJhbS5zYW1wbGluZztcbiAgICB2YXIgdXBkYXRlUG9zaXRpb24gPSBjYWxsYmFja1dyYXBwZXIodGhyb3R0bGUoY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZ0KTtcbiAgICAgICAgaWYgKCF0YXJnZXQgfHwgaXNCbG9ja2VkKHRhcmdldCwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaWQgPSBtaXJyb3IyLmdldElkKHRhcmdldCk7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IGRvYyAmJiBkb2MuZGVmYXVsdFZpZXcpIHtcbiAgICAgICAgICAgIHZhciBzY3JvbGxMZWZ0VG9wID0gZ2V0V2luZG93U2Nyb2xsKGRvYy5kZWZhdWx0Vmlldyk7XG4gICAgICAgICAgICBzY3JvbGxDYih7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIHg6IHNjcm9sbExlZnRUb3AubGVmdCxcbiAgICAgICAgICAgICAgICB5OiBzY3JvbGxMZWZ0VG9wLnRvcFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY3JvbGxDYih7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIHg6IHRhcmdldC5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgICAgIHk6IHRhcmdldC5zY3JvbGxUb3BcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSksIHNhbXBsaW5nLnNjcm9sbCB8fCAxMDApKTtcbiAgICByZXR1cm4gb24oXCJzY3JvbGxcIiwgdXBkYXRlUG9zaXRpb24sIGRvYyk7XG59XG5mdW5jdGlvbiBpbml0Vmlld3BvcnRSZXNpemVPYnNlcnZlcihwYXJhbSwgcGFyYW0xKSB7XG4gICAgdmFyIHZpZXdwb3J0UmVzaXplQ2IgPSBwYXJhbS52aWV3cG9ydFJlc2l6ZUNiO1xuICAgIHZhciB3aW4gPSBwYXJhbTEud2luO1xuICAgIHZhciBsYXN0SCA9IC0xO1xuICAgIHZhciBsYXN0VyA9IC0xO1xuICAgIHZhciB1cGRhdGVEaW1lbnNpb24gPSBjYWxsYmFja1dyYXBwZXIodGhyb3R0bGUoY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gZ2V0V2luZG93SGVpZ2h0KCk7XG4gICAgICAgIHZhciB3aWR0aCA9IGdldFdpbmRvd1dpZHRoKCk7XG4gICAgICAgIGlmIChsYXN0SCAhPT0gaGVpZ2h0IHx8IGxhc3RXICE9PSB3aWR0aCkge1xuICAgICAgICAgICAgdmlld3BvcnRSZXNpemVDYih7XG4gICAgICAgICAgICAgICAgd2lkdGg6IE51bWJlcih3aWR0aCksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBOdW1iZXIoaGVpZ2h0KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsYXN0SCA9IGhlaWdodDtcbiAgICAgICAgICAgIGxhc3RXID0gd2lkdGg7XG4gICAgICAgIH1cbiAgICB9KSwgMjAwKSk7XG4gICAgcmV0dXJuIG9uKFwicmVzaXplXCIsIHVwZGF0ZURpbWVuc2lvbiwgd2luKTtcbn1cbnZhciBJTlBVVF9UQUdTID0gW1xuICAgIFwiSU5QVVRcIixcbiAgICBcIlRFWFRBUkVBXCIsXG4gICAgXCJTRUxFQ1RcIlxuXTtcbnZhciBsYXN0SW5wdXRWYWx1ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gaW5pdElucHV0T2JzZXJ2ZXIocGFyYW0pIHtcbiAgICB2YXIgaW5wdXRDYiA9IHBhcmFtLmlucHV0Q2IsIGRvYyA9IHBhcmFtLmRvYywgbWlycm9yMiA9IHBhcmFtLm1pcnJvciwgYmxvY2tDbGFzcyA9IHBhcmFtLmJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IgPSBwYXJhbS5ibG9ja1NlbGVjdG9yLCBpZ25vcmVDbGFzcyA9IHBhcmFtLmlnbm9yZUNsYXNzLCBpZ25vcmVTZWxlY3RvciA9IHBhcmFtLmlnbm9yZVNlbGVjdG9yLCBtYXNrSW5wdXRPcHRpb25zID0gcGFyYW0ubWFza0lucHV0T3B0aW9ucywgbWFza0lucHV0Rm4gPSBwYXJhbS5tYXNrSW5wdXRGbiwgc2FtcGxpbmcgPSBwYXJhbS5zYW1wbGluZywgdXNlclRyaWdnZXJlZE9uSW5wdXQgPSBwYXJhbS51c2VyVHJpZ2dlcmVkT25JbnB1dDtcbiAgICBmdW5jdGlvbiBldmVudEhhbmRsZXIoZXZlbnQpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcbiAgICAgICAgdmFyIHVzZXJUcmlnZ2VyZWQgPSBldmVudC5pc1RydXN0ZWQ7XG4gICAgICAgIHZhciB0YWdOYW1lID0gdGFyZ2V0ICYmIHRhcmdldC50YWdOYW1lO1xuICAgICAgICBpZiAodGFyZ2V0ICYmIHRhZ05hbWUgPT09IFwiT1BUSU9OXCIpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IGluZGV4LnBhcmVudEVsZW1lbnQodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRhcmdldCB8fCAhdGFnTmFtZSB8fCBJTlBVVF9UQUdTLmluZGV4T2YodGFnTmFtZSkgPCAwIHx8IGlzQmxvY2tlZCh0YXJnZXQsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoaWdub3JlQ2xhc3MpIHx8IGlnbm9yZVNlbGVjdG9yICYmIHRhcmdldC5tYXRjaGVzKGlnbm9yZVNlbGVjdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZXh0ID0gdGFyZ2V0LnZhbHVlO1xuICAgICAgICB2YXIgaXNDaGVja2VkID0gZmFsc2U7XG4gICAgICAgIHZhciB0eXBlID0gZ2V0SW5wdXRUeXBlKHRhcmdldCkgfHwgXCJcIjtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwicmFkaW9cIiB8fCB0eXBlID09PSBcImNoZWNrYm94XCIpIHtcbiAgICAgICAgICAgIGlzQ2hlY2tlZCA9IHRhcmdldC5jaGVja2VkO1xuICAgICAgICB9IGVsc2UgaWYgKG1hc2tJbnB1dE9wdGlvbnNbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXSB8fCBtYXNrSW5wdXRPcHRpb25zW3R5cGVdKSB7XG4gICAgICAgICAgICB0ZXh0ID0gbWFza0lucHV0VmFsdWUoe1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiBtYXNrSW5wdXRPcHRpb25zLFxuICAgICAgICAgICAgICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGV4dCxcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbjogbWFza0lucHV0Rm5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNiV2l0aERlZHVwKHRhcmdldCwgdXNlclRyaWdnZXJlZE9uSW5wdXQgPyB7XG4gICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgaXNDaGVja2VkOiBpc0NoZWNrZWQsXG4gICAgICAgICAgICB1c2VyVHJpZ2dlcmVkOiB1c2VyVHJpZ2dlcmVkXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgaXNDaGVja2VkOiBpc0NoZWNrZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBuYW1lID0gdGFyZ2V0Lm5hbWU7XG4gICAgICAgIGlmICh0eXBlID09PSBcInJhZGlvXCIgJiYgbmFtZSAmJiBpc0NoZWNrZWQpIHtcbiAgICAgICAgICAgIGRvYy5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwicmFkaW9cIl1bbmFtZT1cIicgKyBuYW1lICsgJ1wiXScpLmZvckVhY2goZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWwgIT09IHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dDIgPSBlbC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2JXaXRoRGVkdXAoZWwsIHVzZXJUcmlnZ2VyZWRPbklucHV0ID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dDIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0NoZWNrZWQ6ICFpc0NoZWNrZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyVHJpZ2dlcmVkOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dDIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0NoZWNrZWQ6ICFpc0NoZWNrZWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2JXaXRoRGVkdXAodGFyZ2V0LCB2Mikge1xuICAgICAgICB2YXIgbGFzdElucHV0VmFsdWUgPSBsYXN0SW5wdXRWYWx1ZU1hcC5nZXQodGFyZ2V0KTtcbiAgICAgICAgaWYgKCFsYXN0SW5wdXRWYWx1ZSB8fCBsYXN0SW5wdXRWYWx1ZS50ZXh0ICE9PSB2Mi50ZXh0IHx8IGxhc3RJbnB1dFZhbHVlLmlzQ2hlY2tlZCAhPT0gdjIuaXNDaGVja2VkKSB7XG4gICAgICAgICAgICBsYXN0SW5wdXRWYWx1ZU1hcC5zZXQodGFyZ2V0LCB2Mik7XG4gICAgICAgICAgICB2YXIgaWQgPSBtaXJyb3IyLmdldElkKHRhcmdldCk7XG4gICAgICAgICAgICBjYWxsYmFja1dyYXBwZXIoaW5wdXRDYikoX2V4dGVuZHMoe30sIHYyLCB7XG4gICAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGV2ZW50cyA9IHNhbXBsaW5nLmlucHV0ID09PSBcImxhc3RcIiA/IFtcbiAgICAgICAgXCJjaGFuZ2VcIlxuICAgIF0gOiBbXG4gICAgICAgIFwiaW5wdXRcIixcbiAgICAgICAgXCJjaGFuZ2VcIlxuICAgIF07XG4gICAgdmFyIGhhbmRsZXJzID0gZXZlbnRzLm1hcChmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG9uKGV2ZW50TmFtZSwgY2FsbGJhY2tXcmFwcGVyKGV2ZW50SGFuZGxlciksIGRvYyk7XG4gICAgfSk7XG4gICAgdmFyIGN1cnJlbnRXaW5kb3cgPSBkb2MuZGVmYXVsdFZpZXc7XG4gICAgaWYgKCFjdXJyZW50V2luZG93KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHByb3BlcnR5RGVzY3JpcHRvciA9IGN1cnJlbnRXaW5kb3cuT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjdXJyZW50V2luZG93LkhUTUxJbnB1dEVsZW1lbnQucHJvdG90eXBlLCBcInZhbHVlXCIpO1xuICAgIHZhciBob29rUHJvcGVydGllcyA9IFtcbiAgICAgICAgW1xuICAgICAgICAgICAgY3VycmVudFdpbmRvdy5IVE1MSW5wdXRFbGVtZW50LnByb3RvdHlwZSxcbiAgICAgICAgICAgIFwidmFsdWVcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICBjdXJyZW50V2luZG93LkhUTUxJbnB1dEVsZW1lbnQucHJvdG90eXBlLFxuICAgICAgICAgICAgXCJjaGVja2VkXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgY3VycmVudFdpbmRvdy5IVE1MU2VsZWN0RWxlbWVudC5wcm90b3R5cGUsXG4gICAgICAgICAgICBcInZhbHVlXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgY3VycmVudFdpbmRvdy5IVE1MVGV4dEFyZWFFbGVtZW50LnByb3RvdHlwZSxcbiAgICAgICAgICAgIFwidmFsdWVcIlxuICAgICAgICBdLFxuICAgICAgICAvLyBTb21lIFVJIGxpYnJhcnkgdXNlIHNlbGVjdGVkSW5kZXggdG8gc2V0IHNlbGVjdCB2YWx1ZVxuICAgICAgICBbXG4gICAgICAgICAgICBjdXJyZW50V2luZG93LkhUTUxTZWxlY3RFbGVtZW50LnByb3RvdHlwZSxcbiAgICAgICAgICAgIFwic2VsZWN0ZWRJbmRleFwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICAgIGN1cnJlbnRXaW5kb3cuSFRNTE9wdGlvbkVsZW1lbnQucHJvdG90eXBlLFxuICAgICAgICAgICAgXCJzZWxlY3RlZFwiXG4gICAgICAgIF1cbiAgICBdO1xuICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IgJiYgcHJvcGVydHlEZXNjcmlwdG9yLnNldCkge1xuICAgICAgICB2YXIgX2hhbmRsZXJzO1xuICAgICAgICAoX2hhbmRsZXJzID0gaGFuZGxlcnMpLnB1c2guYXBwbHkoX2hhbmRsZXJzLCBbXS5jb25jYXQoaG9va1Byb3BlcnRpZXMubWFwKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIHJldHVybiBob29rU2V0dGVyKHBbMF0sIHBbMV0sIHtcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tXcmFwcGVyKGV2ZW50SGFuZGxlcikoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNUcnVzdGVkOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmYWxzZSwgY3VycmVudFdpbmRvdyk7XG4gICAgICAgIH0pKSk7XG4gICAgfVxuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgcmV0dXJuIGgoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXROZXN0ZWRDU1NSdWxlUG9zaXRpb25zKHJ1bGUyKSB7XG4gICAgdmFyIHBvc2l0aW9ucyA9IFtdO1xuICAgIGZ1bmN0aW9uIHJlY3Vyc2UoY2hpbGRSdWxlLCBwb3MpIHtcbiAgICAgICAgaWYgKGhhc05lc3RlZENTU1J1bGUoXCJDU1NHcm91cGluZ1J1bGVcIikgJiYgX2luc3RhbmNlb2YoY2hpbGRSdWxlLnBhcmVudFJ1bGUsIENTU0dyb3VwaW5nUnVsZSkgfHwgaGFzTmVzdGVkQ1NTUnVsZShcIkNTU01lZGlhUnVsZVwiKSAmJiBfaW5zdGFuY2VvZihjaGlsZFJ1bGUucGFyZW50UnVsZSwgQ1NTTWVkaWFSdWxlKSB8fCBoYXNOZXN0ZWRDU1NSdWxlKFwiQ1NTU3VwcG9ydHNSdWxlXCIpICYmIF9pbnN0YW5jZW9mKGNoaWxkUnVsZS5wYXJlbnRSdWxlLCBDU1NTdXBwb3J0c1J1bGUpIHx8IGhhc05lc3RlZENTU1J1bGUoXCJDU1NDb25kaXRpb25SdWxlXCIpICYmIF9pbnN0YW5jZW9mKGNoaWxkUnVsZS5wYXJlbnRSdWxlLCBDU1NDb25kaXRpb25SdWxlKSkge1xuICAgICAgICAgICAgdmFyIHJ1bGVzMiA9IEFycmF5LmZyb20oY2hpbGRSdWxlLnBhcmVudFJ1bGUuY3NzUnVsZXMpO1xuICAgICAgICAgICAgdmFyIGluZGV4MiA9IHJ1bGVzMi5pbmRleE9mKGNoaWxkUnVsZSk7XG4gICAgICAgICAgICBwb3MudW5zaGlmdChpbmRleDIpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkUnVsZS5wYXJlbnRTdHlsZVNoZWV0KSB7XG4gICAgICAgICAgICB2YXIgcnVsZXMyMSA9IEFycmF5LmZyb20oY2hpbGRSdWxlLnBhcmVudFN0eWxlU2hlZXQuY3NzUnVsZXMpO1xuICAgICAgICAgICAgdmFyIGluZGV4MjEgPSBydWxlczIxLmluZGV4T2YoY2hpbGRSdWxlKTtcbiAgICAgICAgICAgIHBvcy51bnNoaWZ0KGluZGV4MjEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIHJldHVybiByZWN1cnNlKHJ1bGUyLCBwb3NpdGlvbnMpO1xufVxuZnVuY3Rpb24gZ2V0SWRBbmRTdHlsZUlkKHNoZWV0LCBtaXJyb3IyLCBzdHlsZU1pcnJvcikge1xuICAgIHZhciBpZCwgc3R5bGVJZDtcbiAgICBpZiAoIXNoZWV0KSByZXR1cm4ge307XG4gICAgaWYgKHNoZWV0Lm93bmVyTm9kZSkgaWQgPSBtaXJyb3IyLmdldElkKHNoZWV0Lm93bmVyTm9kZSk7XG4gICAgZWxzZSBzdHlsZUlkID0gc3R5bGVNaXJyb3IuZ2V0SWQoc2hlZXQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0eWxlSWQ6IHN0eWxlSWQsXG4gICAgICAgIGlkOiBpZFxuICAgIH07XG59XG5mdW5jdGlvbiBpbml0U3R5bGVTaGVldE9ic2VydmVyKHBhcmFtLCBwYXJhbTEpIHtcbiAgICB2YXIgc3R5bGVTaGVldFJ1bGVDYiA9IHBhcmFtLnN0eWxlU2hlZXRSdWxlQ2IsIG1pcnJvcjIgPSBwYXJhbS5taXJyb3IsIHN0eWxlc2hlZXRNYW5hZ2VyID0gcGFyYW0uc3R5bGVzaGVldE1hbmFnZXI7XG4gICAgdmFyIHdpbiA9IHBhcmFtMS53aW47XG4gICAgaWYgKCF3aW4uQ1NTU3R5bGVTaGVldCB8fCAhd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgICB2YXIgaW5zZXJ0UnVsZSA9IHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5pbnNlcnRSdWxlO1xuICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5pbnNlcnRSdWxlID0gbmV3IFByb3h5KGluc2VydFJ1bGUsIHtcbiAgICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbih0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpIHtcbiAgICAgICAgICAgIHZhciBydWxlMiA9IGFyZ3VtZW50c0xpc3RbMF0sIGluZGV4MiA9IGFyZ3VtZW50c0xpc3RbMV07XG4gICAgICAgICAgICB2YXIgX2dldElkQW5kU3R5bGVJZCA9IGdldElkQW5kU3R5bGVJZCh0aGlzQXJnLCBtaXJyb3IyLCBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvciksIGlkID0gX2dldElkQW5kU3R5bGVJZC5pZCwgc3R5bGVJZCA9IF9nZXRJZEFuZFN0eWxlSWQuc3R5bGVJZDtcbiAgICAgICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xuICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlSWQ6IHN0eWxlSWQsXG4gICAgICAgICAgICAgICAgICAgIGFkZHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBydWxlMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XG4gICAgICAgIH0pXG4gICAgfSk7XG4gICAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmFkZFJ1bGUgPSBmdW5jdGlvbihzZWxlY3Rvciwgc3R5bGVCbG9jaywgaW5kZXgyKSB7XG4gICAgICAgIGlmIChpbmRleDIgPT09IHZvaWQgMCkgaW5kZXgyID0gdGhpcy5jc3NSdWxlcy5sZW5ndGg7XG4gICAgICAgIHZhciBydWxlMiA9IHNlbGVjdG9yICsgXCIgeyBcIiArIHN0eWxlQmxvY2sgKyBcIiB9XCI7XG4gICAgICAgIHJldHVybiB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuaW5zZXJ0UnVsZS5hcHBseSh0aGlzLCBbXG4gICAgICAgICAgICBydWxlMixcbiAgICAgICAgICAgIGluZGV4MlxuICAgICAgICBdKTtcbiAgICB9O1xuICAgIHZhciBkZWxldGVSdWxlID0gd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmRlbGV0ZVJ1bGU7XG4gICAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmRlbGV0ZVJ1bGUgPSBuZXcgUHJveHkoZGVsZXRlUnVsZSwge1xuICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkge1xuICAgICAgICAgICAgdmFyIGluZGV4MiA9IGFyZ3VtZW50c0xpc3RbMF07XG4gICAgICAgICAgICB2YXIgX2dldElkQW5kU3R5bGVJZCA9IGdldElkQW5kU3R5bGVJZCh0aGlzQXJnLCBtaXJyb3IyLCBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvciksIGlkID0gX2dldElkQW5kU3R5bGVJZC5pZCwgc3R5bGVJZCA9IF9nZXRJZEFuZFN0eWxlSWQuc3R5bGVJZDtcbiAgICAgICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xuICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlSWQ6IHN0eWxlSWQsXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XG4gICAgICAgIH0pXG4gICAgfSk7XG4gICAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlbW92ZVJ1bGUgPSBmdW5jdGlvbihpbmRleDIpIHtcbiAgICAgICAgcmV0dXJuIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5kZWxldGVSdWxlLmFwcGx5KHRoaXMsIFtcbiAgICAgICAgICAgIGluZGV4MlxuICAgICAgICBdKTtcbiAgICB9O1xuICAgIHZhciByZXBsYWNlO1xuICAgIGlmICh3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUucmVwbGFjZSkge1xuICAgICAgICByZXBsYWNlID0gd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2U7XG4gICAgICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlID0gbmV3IFByb3h5KHJlcGxhY2UsIHtcbiAgICAgICAgICAgIGFwcGx5OiBjYWxsYmFja1dyYXBwZXIoZnVuY3Rpb24odGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBhcmd1bWVudHNMaXN0WzBdO1xuICAgICAgICAgICAgICAgIHZhciBfZ2V0SWRBbmRTdHlsZUlkID0gZ2V0SWRBbmRTdHlsZUlkKHRoaXNBcmcsIG1pcnJvcjIsIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yKSwgaWQgPSBfZ2V0SWRBbmRTdHlsZUlkLmlkLCBzdHlsZUlkID0gX2dldElkQW5kU3R5bGVJZC5zdHlsZUlkO1xuICAgICAgICAgICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlSWQ6IHN0eWxlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlOiB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciByZXBsYWNlU3luYztcbiAgICBpZiAod2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2VTeW5jKSB7XG4gICAgICAgIHJlcGxhY2VTeW5jID0gd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2VTeW5jO1xuICAgICAgICB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUucmVwbGFjZVN5bmMgPSBuZXcgUHJveHkocmVwbGFjZVN5bmMsIHtcbiAgICAgICAgICAgIGFwcGx5OiBjYWxsYmFja1dyYXBwZXIoZnVuY3Rpb24odGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBhcmd1bWVudHNMaXN0WzBdO1xuICAgICAgICAgICAgICAgIHZhciBfZ2V0SWRBbmRTdHlsZUlkID0gZ2V0SWRBbmRTdHlsZUlkKHRoaXNBcmcsIG1pcnJvcjIsIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yKSwgaWQgPSBfZ2V0SWRBbmRTdHlsZUlkLmlkLCBzdHlsZUlkID0gX2dldElkQW5kU3R5bGVJZC5zdHlsZUlkO1xuICAgICAgICAgICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlSWQ6IHN0eWxlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlU3luYzogdGV4dFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzID0ge307XG4gICAgaWYgKGNhbk1vbmtleVBhdGNoTmVzdGVkQ1NTUnVsZShcIkNTU0dyb3VwaW5nUnVsZVwiKSkge1xuICAgICAgICBzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMuQ1NTR3JvdXBpbmdSdWxlID0gd2luLkNTU0dyb3VwaW5nUnVsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY2FuTW9ua2V5UGF0Y2hOZXN0ZWRDU1NSdWxlKFwiQ1NTTWVkaWFSdWxlXCIpKSB7XG4gICAgICAgICAgICBzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMuQ1NTTWVkaWFSdWxlID0gd2luLkNTU01lZGlhUnVsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FuTW9ua2V5UGF0Y2hOZXN0ZWRDU1NSdWxlKFwiQ1NTQ29uZGl0aW9uUnVsZVwiKSkge1xuICAgICAgICAgICAgc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzLkNTU0NvbmRpdGlvblJ1bGUgPSB3aW4uQ1NTQ29uZGl0aW9uUnVsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FuTW9ua2V5UGF0Y2hOZXN0ZWRDU1NSdWxlKFwiQ1NTU3VwcG9ydHNSdWxlXCIpKSB7XG4gICAgICAgICAgICBzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMuQ1NTU3VwcG9ydHNSdWxlID0gd2luLkNTU1N1cHBvcnRzUnVsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgdW5tb2RpZmllZEZ1bmN0aW9ucyA9IHt9O1xuICAgIE9iamVjdC5lbnRyaWVzKHN1cHBvcnRlZE5lc3RlZENTU1J1bGVUeXBlcykuZm9yRWFjaChmdW5jdGlvbihwYXJhbSkge1xuICAgICAgICB2YXIgdHlwZUtleSA9IHBhcmFtWzBdLCB0eXBlID0gcGFyYW1bMV07XG4gICAgICAgIHVubW9kaWZpZWRGdW5jdGlvbnNbdHlwZUtleV0gPSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgICAgICAgICBpbnNlcnRSdWxlOiB0eXBlLnByb3RvdHlwZS5pbnNlcnRSdWxlLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgICAgICAgZGVsZXRlUnVsZTogdHlwZS5wcm90b3R5cGUuZGVsZXRlUnVsZVxuICAgICAgICB9O1xuICAgICAgICB0eXBlLnByb3RvdHlwZS5pbnNlcnRSdWxlID0gbmV3IFByb3h5KHVubW9kaWZpZWRGdW5jdGlvbnNbdHlwZUtleV0uaW5zZXJ0UnVsZSwge1xuICAgICAgICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbih0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgcnVsZTIgPSBhcmd1bWVudHNMaXN0WzBdLCBpbmRleDIgPSBhcmd1bWVudHNMaXN0WzFdO1xuICAgICAgICAgICAgICAgIHZhciBfZ2V0SWRBbmRTdHlsZUlkID0gZ2V0SWRBbmRTdHlsZUlkKHRoaXNBcmcucGFyZW50U3R5bGVTaGVldCwgbWlycm9yMiwgc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3IpLCBpZCA9IF9nZXRJZEFuZFN0eWxlSWQuaWQsIHN0eWxlSWQgPSBfZ2V0SWRBbmRTdHlsZUlkLnN0eWxlSWQ7XG4gICAgICAgICAgICAgICAgaWYgKGlkICYmIGlkICE9PSAtMSB8fCBzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVJZDogc3R5bGVJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IHJ1bGUyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogW10uY29uY2F0KGdldE5lc3RlZENTU1J1bGVQb3NpdGlvbnModGhpc0FyZyksIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4MiB8fCAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgICB0eXBlLnByb3RvdHlwZS5kZWxldGVSdWxlID0gbmV3IFByb3h5KHVubW9kaWZpZWRGdW5jdGlvbnNbdHlwZUtleV0uZGVsZXRlUnVsZSwge1xuICAgICAgICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbih0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXgyID0gYXJndW1lbnRzTGlzdFswXTtcbiAgICAgICAgICAgICAgICB2YXIgX2dldElkQW5kU3R5bGVJZCA9IGdldElkQW5kU3R5bGVJZCh0aGlzQXJnLnBhcmVudFN0eWxlU2hlZXQsIG1pcnJvcjIsIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yKSwgaWQgPSBfZ2V0SWRBbmRTdHlsZUlkLmlkLCBzdHlsZUlkID0gX2dldElkQW5kU3R5bGVJZC5zdHlsZUlkO1xuICAgICAgICAgICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlSWQ6IHN0eWxlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogW10uY29uY2F0KGdldE5lc3RlZENTU1J1bGVQb3NpdGlvbnModGhpc0FyZyksIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuaW5zZXJ0UnVsZSA9IGluc2VydFJ1bGU7XG4gICAgICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5kZWxldGVSdWxlID0gZGVsZXRlUnVsZTtcbiAgICAgICAgcmVwbGFjZSAmJiAod2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2UgPSByZXBsYWNlKTtcbiAgICAgICAgcmVwbGFjZVN5bmMgJiYgKHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlU3luYyA9IHJlcGxhY2VTeW5jKTtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICAgICAgICB2YXIgdHlwZUtleSA9IHBhcmFtWzBdLCB0eXBlID0gcGFyYW1bMV07XG4gICAgICAgICAgICB0eXBlLnByb3RvdHlwZS5pbnNlcnRSdWxlID0gdW5tb2RpZmllZEZ1bmN0aW9uc1t0eXBlS2V5XS5pbnNlcnRSdWxlO1xuICAgICAgICAgICAgdHlwZS5wcm90b3R5cGUuZGVsZXRlUnVsZSA9IHVubW9kaWZpZWRGdW5jdGlvbnNbdHlwZUtleV0uZGVsZXRlUnVsZTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpbml0QWRvcHRlZFN0eWxlU2hlZXRPYnNlcnZlcihwYXJhbSwgaG9zdDIpIHtcbiAgICB2YXIgbWlycm9yMiA9IHBhcmFtLm1pcnJvciwgc3R5bGVzaGVldE1hbmFnZXIgPSBwYXJhbS5zdHlsZXNoZWV0TWFuYWdlcjtcbiAgICB2YXIgX2EyLCBfYiwgX2M7XG4gICAgdmFyIGhvc3RJZCA9IG51bGw7XG4gICAgaWYgKGhvc3QyLm5vZGVOYW1lID09PSBcIiNkb2N1bWVudFwiKSBob3N0SWQgPSBtaXJyb3IyLmdldElkKGhvc3QyKTtcbiAgICBlbHNlIGhvc3RJZCA9IG1pcnJvcjIuZ2V0SWQoaW5kZXguaG9zdChob3N0MikpO1xuICAgIHZhciBwYXRjaFRhcmdldCA9IGhvc3QyLm5vZGVOYW1lID09PSBcIiNkb2N1bWVudFwiID8gKF9hMiA9IGhvc3QyLmRlZmF1bHRWaWV3KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLkRvY3VtZW50IDogKF9jID0gKF9iID0gaG9zdDIub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmRlZmF1bHRWaWV3KSA9PSBudWxsID8gdm9pZCAwIDogX2MuU2hhZG93Um9vdDtcbiAgICB2YXIgb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IgPSAocGF0Y2hUYXJnZXQgPT0gbnVsbCA/IHZvaWQgMCA6IHBhdGNoVGFyZ2V0LnByb3RvdHlwZSkgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHBhdGNoVGFyZ2V0ID09IG51bGwgPyB2b2lkIDAgOiBwYXRjaFRhcmdldC5wcm90b3R5cGUsIFwiYWRvcHRlZFN0eWxlU2hlZXRzXCIpIDogdm9pZCAwO1xuICAgIGlmIChob3N0SWQgPT09IG51bGwgfHwgaG9zdElkID09PSAtMSB8fCAhcGF0Y2hUYXJnZXQgfHwgIW9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yKSByZXR1cm4gZnVuY3Rpb24oKSB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaG9zdDIsIFwiYWRvcHRlZFN0eWxlU2hlZXRzXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvci5jb25maWd1cmFibGUsXG4gICAgICAgIGVudW1lcmFibGU6IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgdmFyIF9hMztcbiAgICAgICAgICAgIHJldHVybiAoX2EzID0gb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmNhbGwodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHNoZWV0cykge1xuICAgICAgICAgICAgdmFyIF9hMztcbiAgICAgICAgICAgIHZhciByZXN1bHQyID0gKF9hMyA9IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLnNldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5jYWxsKHRoaXMsIHNoZWV0cyk7XG4gICAgICAgICAgICBpZiAoaG9zdElkICE9PSBudWxsICYmIGhvc3RJZCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlci5hZG9wdFN0eWxlU2hlZXRzKHNoZWV0cywgaG9zdElkKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlMikge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbigpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGhvc3QyLCBcImFkb3B0ZWRTdHlsZVNoZWV0c1wiLCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgICAgICAgICBnZXQ6IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLmdldCxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgICAgICAgIHNldDogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3Iuc2V0XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaW5pdFN0eWxlRGVjbGFyYXRpb25PYnNlcnZlcihwYXJhbSwgcGFyYW0xKSB7XG4gICAgdmFyIHN0eWxlRGVjbGFyYXRpb25DYiA9IHBhcmFtLnN0eWxlRGVjbGFyYXRpb25DYiwgbWlycm9yMiA9IHBhcmFtLm1pcnJvciwgaWdub3JlQ1NTQXR0cmlidXRlcyA9IHBhcmFtLmlnbm9yZUNTU0F0dHJpYnV0ZXMsIHN0eWxlc2hlZXRNYW5hZ2VyID0gcGFyYW0uc3R5bGVzaGVldE1hbmFnZXI7XG4gICAgdmFyIHdpbiA9IHBhcmFtMS53aW47XG4gICAgdmFyIHNldFByb3BlcnR5ID0gd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnNldFByb3BlcnR5O1xuICAgIHdpbi5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5zZXRQcm9wZXJ0eSA9IG5ldyBQcm94eShzZXRQcm9wZXJ0eSwge1xuICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkge1xuICAgICAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IGFyZ3VtZW50c0xpc3RbMF0sIHZhbHVlID0gYXJndW1lbnRzTGlzdFsxXSwgcHJpb3JpdHkgPSBhcmd1bWVudHNMaXN0WzJdO1xuICAgICAgICAgICAgaWYgKGlnbm9yZUNTU0F0dHJpYnV0ZXMuaGFzKHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXRQcm9wZXJ0eS5hcHBseSh0aGlzQXJnLCBbXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHlcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfZ2V0SWRBbmRTdHlsZUlkID0gZ2V0SWRBbmRTdHlsZUlkKChfYTIgPSB0aGlzQXJnLnBhcmVudFJ1bGUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIucGFyZW50U3R5bGVTaGVldCwgbWlycm9yMiwgc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3IpLCBpZCA9IF9nZXRJZEFuZFN0eWxlSWQuaWQsIHN0eWxlSWQgPSBfZ2V0SWRBbmRTdHlsZUlkLnN0eWxlSWQ7XG4gICAgICAgICAgICBpZiAoaWQgJiYgaWQgIT09IC0xIHx8IHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzdHlsZURlY2xhcmF0aW9uQ2Ioe1xuICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlSWQ6IHN0eWxlSWQsXG4gICAgICAgICAgICAgICAgICAgIHNldDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IHByaW9yaXR5XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBnZXROZXN0ZWRDU1NSdWxlUG9zaXRpb25zKHRoaXNBcmcucGFyZW50UnVsZSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XG4gICAgICAgIH0pXG4gICAgfSk7XG4gICAgdmFyIHJlbW92ZVByb3BlcnR5ID0gd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnJlbW92ZVByb3BlcnR5O1xuICAgIHdpbi5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5yZW1vdmVQcm9wZXJ0eSA9IG5ldyBQcm94eShyZW1vdmVQcm9wZXJ0eSwge1xuICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkge1xuICAgICAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IGFyZ3VtZW50c0xpc3RbMF07XG4gICAgICAgICAgICBpZiAoaWdub3JlQ1NTQXR0cmlidXRlcy5oYXMocHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZVByb3BlcnR5LmFwcGx5KHRoaXNBcmcsIFtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfZ2V0SWRBbmRTdHlsZUlkID0gZ2V0SWRBbmRTdHlsZUlkKChfYTIgPSB0aGlzQXJnLnBhcmVudFJ1bGUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIucGFyZW50U3R5bGVTaGVldCwgbWlycm9yMiwgc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3IpLCBpZCA9IF9nZXRJZEFuZFN0eWxlSWQuaWQsIHN0eWxlSWQgPSBfZ2V0SWRBbmRTdHlsZUlkLnN0eWxlSWQ7XG4gICAgICAgICAgICBpZiAoaWQgJiYgaWQgIT09IC0xIHx8IHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzdHlsZURlY2xhcmF0aW9uQ2Ioe1xuICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlSWQ6IHN0eWxlSWQsXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBnZXROZXN0ZWRDU1NSdWxlUG9zaXRpb25zKHRoaXNBcmcucGFyZW50UnVsZSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XG4gICAgICAgIH0pXG4gICAgfSk7XG4gICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbigpIHtcbiAgICAgICAgd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnNldFByb3BlcnR5ID0gc2V0UHJvcGVydHk7XG4gICAgICAgIHdpbi5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5yZW1vdmVQcm9wZXJ0eSA9IHJlbW92ZVByb3BlcnR5O1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaW5pdE1lZGlhSW50ZXJhY3Rpb25PYnNlcnZlcihwYXJhbSkge1xuICAgIHZhciBtZWRpYUludGVyYWN0aW9uQ2IgPSBwYXJhbS5tZWRpYUludGVyYWN0aW9uQ2IsIGJsb2NrQ2xhc3MgPSBwYXJhbS5ibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yID0gcGFyYW0uYmxvY2tTZWxlY3RvciwgbWlycm9yMiA9IHBhcmFtLm1pcnJvciwgc2FtcGxpbmcgPSBwYXJhbS5zYW1wbGluZywgZG9jID0gcGFyYW0uZG9jO1xuICAgIHZhciBoYW5kbGVyID0gY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRocm90dGxlKGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0IHx8IGlzQmxvY2tlZCh0YXJnZXQsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gdGFyZ2V0LmN1cnJlbnRUaW1lLCB2b2x1bWUgPSB0YXJnZXQudm9sdW1lLCBtdXRlZCA9IHRhcmdldC5tdXRlZCwgcGxheWJhY2tSYXRlID0gdGFyZ2V0LnBsYXliYWNrUmF0ZSwgbG9vcCA9IHRhcmdldC5sb29wO1xuICAgICAgICAgICAgbWVkaWFJbnRlcmFjdGlvbkNiKHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIGlkOiBtaXJyb3IyLmdldElkKHRhcmdldCksXG4gICAgICAgICAgICAgICAgY3VycmVudFRpbWU6IGN1cnJlbnRUaW1lLFxuICAgICAgICAgICAgICAgIHZvbHVtZTogdm9sdW1lLFxuICAgICAgICAgICAgICAgIG11dGVkOiBtdXRlZCxcbiAgICAgICAgICAgICAgICBwbGF5YmFja1JhdGU6IHBsYXliYWNrUmF0ZSxcbiAgICAgICAgICAgICAgICBsb29wOiBsb29wXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSksIHNhbXBsaW5nLm1lZGlhIHx8IDUwMCk7XG4gICAgfSk7XG4gICAgdmFyIGhhbmRsZXJzID0gW1xuICAgICAgICBvbihcInBsYXlcIiwgaGFuZGxlcihNZWRpYUludGVyYWN0aW9ucy5QbGF5KSwgZG9jKSxcbiAgICAgICAgb24oXCJwYXVzZVwiLCBoYW5kbGVyKE1lZGlhSW50ZXJhY3Rpb25zLlBhdXNlKSwgZG9jKSxcbiAgICAgICAgb24oXCJzZWVrZWRcIiwgaGFuZGxlcihNZWRpYUludGVyYWN0aW9ucy5TZWVrZWQpLCBkb2MpLFxuICAgICAgICBvbihcInZvbHVtZWNoYW5nZVwiLCBoYW5kbGVyKE1lZGlhSW50ZXJhY3Rpb25zLlZvbHVtZUNoYW5nZSksIGRvYyksXG4gICAgICAgIG9uKFwicmF0ZWNoYW5nZVwiLCBoYW5kbGVyKE1lZGlhSW50ZXJhY3Rpb25zLlJhdGVDaGFuZ2UpLCBkb2MpXG4gICAgXTtcbiAgICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgIHJldHVybiBoKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaW5pdEZvbnRPYnNlcnZlcihwYXJhbSkge1xuICAgIHZhciBmb250Q2IgPSBwYXJhbS5mb250Q2IsIGRvYyA9IHBhcmFtLmRvYztcbiAgICB2YXIgd2luID0gZG9jLmRlZmF1bHRWaWV3O1xuICAgIGlmICghd2luKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgICB2YXIgaGFuZGxlcnMgPSBbXTtcbiAgICB2YXIgZm9udE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgIHZhciBvcmlnaW5hbEZvbnRGYWNlID0gd2luLkZvbnRGYWNlO1xuICAgIHdpbi5Gb250RmFjZSA9IGZ1bmN0aW9uIEZvbnRGYWNlMihmYW1pbHksIHNvdXJjZSwgZGVzY3JpcHRvcnMpIHtcbiAgICAgICAgdmFyIGZvbnRGYWNlID0gbmV3IG9yaWdpbmFsRm9udEZhY2UoZmFtaWx5LCBzb3VyY2UsIGRlc2NyaXB0b3JzKTtcbiAgICAgICAgZm9udE1hcC5zZXQoZm9udEZhY2UsIHtcbiAgICAgICAgICAgIGZhbWlseTogZmFtaWx5LFxuICAgICAgICAgICAgYnVmZmVyOiB0eXBlb2Ygc291cmNlICE9PSBcInN0cmluZ1wiLFxuICAgICAgICAgICAgZGVzY3JpcHRvcnM6IGRlc2NyaXB0b3JzLFxuICAgICAgICAgICAgZm9udFNvdXJjZTogdHlwZW9mIHNvdXJjZSA9PT0gXCJzdHJpbmdcIiA/IHNvdXJjZSA6IEpTT04uc3RyaW5naWZ5KEFycmF5LmZyb20obmV3IFVpbnQ4QXJyYXkoc291cmNlKSkpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZm9udEZhY2U7XG4gICAgfTtcbiAgICB2YXIgcmVzdG9yZUhhbmRsZXIgPSBwYXRjaCQyKGRvYy5mb250cywgXCJhZGRcIiwgZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGZvbnRGYWNlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IGZvbnRNYXAuZ2V0KGZvbnRGYWNlKTtcbiAgICAgICAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgICAgICAgICBmb250Q2IocCk7XG4gICAgICAgICAgICAgICAgICAgIGZvbnRNYXAuZGVsZXRlKGZvbnRGYWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSwgMCk7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgW1xuICAgICAgICAgICAgICAgIGZvbnRGYWNlXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBoYW5kbGVycy5wdXNoKGZ1bmN0aW9uKCkge1xuICAgICAgICB3aW4uRm9udEZhY2UgPSBvcmlnaW5hbEZvbnRGYWNlO1xuICAgIH0pO1xuICAgIGhhbmRsZXJzLnB1c2gocmVzdG9yZUhhbmRsZXIpO1xuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgcmV0dXJuIGgoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpbml0U2VsZWN0aW9uT2JzZXJ2ZXIocGFyYW0pIHtcbiAgICB2YXIgZG9jID0gcGFyYW0uZG9jLCBtaXJyb3IyID0gcGFyYW0ubWlycm9yLCBibG9ja0NsYXNzID0gcGFyYW0uYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciA9IHBhcmFtLmJsb2NrU2VsZWN0b3IsIHNlbGVjdGlvbkNiID0gcGFyYW0uc2VsZWN0aW9uQ2I7XG4gICAgdmFyIGNvbGxhcHNlZCA9IHRydWU7XG4gICAgdmFyIHVwZGF0ZVNlbGVjdGlvbiA9IGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IGRvYy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb24gfHwgY29sbGFwc2VkICYmIChzZWxlY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IHNlbGVjdGlvbi5pc0NvbGxhcHNlZCkpIHJldHVybjtcbiAgICAgICAgY29sbGFwc2VkID0gc2VsZWN0aW9uLmlzQ29sbGFwc2VkIHx8IGZhbHNlO1xuICAgICAgICB2YXIgcmFuZ2VzID0gW107XG4gICAgICAgIHZhciBjb3VudCA9IHNlbGVjdGlvbi5yYW5nZUNvdW50IHx8IDA7XG4gICAgICAgIGZvcih2YXIgaTIgPSAwOyBpMiA8IGNvdW50OyBpMisrKXtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KGkyKTtcbiAgICAgICAgICAgIHZhciBzdGFydENvbnRhaW5lciA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCA9IHJhbmdlLnN0YXJ0T2Zmc2V0LCBlbmRDb250YWluZXIgPSByYW5nZS5lbmRDb250YWluZXIsIGVuZE9mZnNldCA9IHJhbmdlLmVuZE9mZnNldDtcbiAgICAgICAgICAgIHZhciBibG9ja2VkID0gaXNCbG9ja2VkKHN0YXJ0Q29udGFpbmVyLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSB8fCBpc0Jsb2NrZWQoZW5kQ29udGFpbmVyLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChibG9ja2VkKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzdGFydDogbWlycm9yMi5nZXRJZChzdGFydENvbnRhaW5lciksXG4gICAgICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IHN0YXJ0T2Zmc2V0LFxuICAgICAgICAgICAgICAgIGVuZDogbWlycm9yMi5nZXRJZChlbmRDb250YWluZXIpLFxuICAgICAgICAgICAgICAgIGVuZE9mZnNldDogZW5kT2Zmc2V0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3Rpb25DYih7XG4gICAgICAgICAgICByYW5nZXM6IHJhbmdlc1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICB1cGRhdGVTZWxlY3Rpb24oKTtcbiAgICByZXR1cm4gb24oXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdXBkYXRlU2VsZWN0aW9uKTtcbn1cbmZ1bmN0aW9uIGluaXRDdXN0b21FbGVtZW50T2JzZXJ2ZXIocGFyYW0pIHtcbiAgICB2YXIgZG9jID0gcGFyYW0uZG9jLCBjdXN0b21FbGVtZW50Q2IgPSBwYXJhbS5jdXN0b21FbGVtZW50Q2I7XG4gICAgdmFyIHdpbiA9IGRvYy5kZWZhdWx0VmlldztcbiAgICBpZiAoIXdpbiB8fCAhd2luLmN1c3RvbUVsZW1lbnRzKSByZXR1cm4gZnVuY3Rpb24oKSB7fTtcbiAgICB2YXIgcmVzdG9yZUhhbmRsZXIgPSBwYXRjaCQyKHdpbi5jdXN0b21FbGVtZW50cywgXCJkZWZpbmVcIiwgZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUsIGNvbnN0cnVjdG9yLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGN1c3RvbUVsZW1lbnRDYih7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkN1c3RvbSBlbGVtZW50IGNhbGxiYWNrIGZhaWxlZCBmb3IgXCIgKyBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcixcbiAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdG9yZUhhbmRsZXI7XG59XG5mdW5jdGlvbiBtZXJnZUhvb2tzKG8yLCBob29rcykge1xuICAgIHZhciBtdXRhdGlvbkNiID0gbzIubXV0YXRpb25DYiwgbW91c2Vtb3ZlQ2IgPSBvMi5tb3VzZW1vdmVDYiwgbW91c2VJbnRlcmFjdGlvbkNiID0gbzIubW91c2VJbnRlcmFjdGlvbkNiLCBzY3JvbGxDYiA9IG8yLnNjcm9sbENiLCB2aWV3cG9ydFJlc2l6ZUNiID0gbzIudmlld3BvcnRSZXNpemVDYiwgaW5wdXRDYiA9IG8yLmlucHV0Q2IsIG1lZGlhSW50ZXJhY3Rpb25DYiA9IG8yLm1lZGlhSW50ZXJhY3Rpb25DYiwgc3R5bGVTaGVldFJ1bGVDYiA9IG8yLnN0eWxlU2hlZXRSdWxlQ2IsIHN0eWxlRGVjbGFyYXRpb25DYiA9IG8yLnN0eWxlRGVjbGFyYXRpb25DYiwgY2FudmFzTXV0YXRpb25DYiA9IG8yLmNhbnZhc011dGF0aW9uQ2IsIGZvbnRDYiA9IG8yLmZvbnRDYiwgc2VsZWN0aW9uQ2IgPSBvMi5zZWxlY3Rpb25DYiwgY3VzdG9tRWxlbWVudENiID0gbzIuY3VzdG9tRWxlbWVudENiO1xuICAgIG8yLm11dGF0aW9uQ2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcCA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgcFtfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9va3MubXV0YXRpb24pIHtcbiAgICAgICAgICAgIHZhciBfaG9va3M7XG4gICAgICAgICAgICAoX2hvb2tzID0gaG9va3MpLm11dGF0aW9uLmFwcGx5KF9ob29rcywgW10uY29uY2F0KHApKTtcbiAgICAgICAgfVxuICAgICAgICBtdXRhdGlvbkNiLmFwcGx5KHZvaWQgMCwgW10uY29uY2F0KHApKTtcbiAgICB9O1xuICAgIG8yLm1vdXNlbW92ZUNiID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHAgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIHBbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvb2tzLm1vdXNlbW92ZSkge1xuICAgICAgICAgICAgdmFyIF9ob29rcztcbiAgICAgICAgICAgIChfaG9va3MgPSBob29rcykubW91c2Vtb3ZlLmFwcGx5KF9ob29rcywgW10uY29uY2F0KHApKTtcbiAgICAgICAgfVxuICAgICAgICBtb3VzZW1vdmVDYi5hcHBseSh2b2lkIDAsIFtdLmNvbmNhdChwKSk7XG4gICAgfTtcbiAgICBvMi5tb3VzZUludGVyYWN0aW9uQ2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcCA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgcFtfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9va3MubW91c2VJbnRlcmFjdGlvbikge1xuICAgICAgICAgICAgdmFyIF9ob29rcztcbiAgICAgICAgICAgIChfaG9va3MgPSBob29rcykubW91c2VJbnRlcmFjdGlvbi5hcHBseShfaG9va3MsIFtdLmNvbmNhdChwKSk7XG4gICAgICAgIH1cbiAgICAgICAgbW91c2VJbnRlcmFjdGlvbkNiLmFwcGx5KHZvaWQgMCwgW10uY29uY2F0KHApKTtcbiAgICB9O1xuICAgIG8yLnNjcm9sbENiID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHAgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIHBbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvb2tzLnNjcm9sbCkge1xuICAgICAgICAgICAgdmFyIF9ob29rcztcbiAgICAgICAgICAgIChfaG9va3MgPSBob29rcykuc2Nyb2xsLmFwcGx5KF9ob29rcywgW10uY29uY2F0KHApKTtcbiAgICAgICAgfVxuICAgICAgICBzY3JvbGxDYi5hcHBseSh2b2lkIDAsIFtdLmNvbmNhdChwKSk7XG4gICAgfTtcbiAgICBvMi52aWV3cG9ydFJlc2l6ZUNiID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHAgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIHBbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvb2tzLnZpZXdwb3J0UmVzaXplKSB7XG4gICAgICAgICAgICB2YXIgX2hvb2tzO1xuICAgICAgICAgICAgKF9ob29rcyA9IGhvb2tzKS52aWV3cG9ydFJlc2l6ZS5hcHBseShfaG9va3MsIFtdLmNvbmNhdChwKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmlld3BvcnRSZXNpemVDYi5hcHBseSh2b2lkIDAsIFtdLmNvbmNhdChwKSk7XG4gICAgfTtcbiAgICBvMi5pbnB1dENiID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHAgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIHBbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvb2tzLmlucHV0KSB7XG4gICAgICAgICAgICB2YXIgX2hvb2tzO1xuICAgICAgICAgICAgKF9ob29rcyA9IGhvb2tzKS5pbnB1dC5hcHBseShfaG9va3MsIFtdLmNvbmNhdChwKSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXRDYi5hcHBseSh2b2lkIDAsIFtdLmNvbmNhdChwKSk7XG4gICAgfTtcbiAgICBvMi5tZWRpYUludGVyYWN0aW9uQ2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcCA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgcFtfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9va3MubWVkaWFJbnRlYWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgX2hvb2tzO1xuICAgICAgICAgICAgKF9ob29rcyA9IGhvb2tzKS5tZWRpYUludGVhY3Rpb24uYXBwbHkoX2hvb2tzLCBbXS5jb25jYXQocCkpO1xuICAgICAgICB9XG4gICAgICAgIG1lZGlhSW50ZXJhY3Rpb25DYi5hcHBseSh2b2lkIDAsIFtdLmNvbmNhdChwKSk7XG4gICAgfTtcbiAgICBvMi5zdHlsZVNoZWV0UnVsZUNiID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHAgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIHBbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvb2tzLnN0eWxlU2hlZXRSdWxlKSB7XG4gICAgICAgICAgICB2YXIgX2hvb2tzO1xuICAgICAgICAgICAgKF9ob29rcyA9IGhvb2tzKS5zdHlsZVNoZWV0UnVsZS5hcHBseShfaG9va3MsIFtdLmNvbmNhdChwKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGVTaGVldFJ1bGVDYi5hcHBseSh2b2lkIDAsIFtdLmNvbmNhdChwKSk7XG4gICAgfTtcbiAgICBvMi5zdHlsZURlY2xhcmF0aW9uQ2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcCA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgcFtfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9va3Muc3R5bGVEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgdmFyIF9ob29rcztcbiAgICAgICAgICAgIChfaG9va3MgPSBob29rcykuc3R5bGVEZWNsYXJhdGlvbi5hcHBseShfaG9va3MsIFtdLmNvbmNhdChwKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGVEZWNsYXJhdGlvbkNiLmFwcGx5KHZvaWQgMCwgW10uY29uY2F0KHApKTtcbiAgICB9O1xuICAgIG8yLmNhbnZhc011dGF0aW9uQ2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcCA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgcFtfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9va3MuY2FudmFzTXV0YXRpb24pIHtcbiAgICAgICAgICAgIHZhciBfaG9va3M7XG4gICAgICAgICAgICAoX2hvb2tzID0gaG9va3MpLmNhbnZhc011dGF0aW9uLmFwcGx5KF9ob29rcywgW10uY29uY2F0KHApKTtcbiAgICAgICAgfVxuICAgICAgICBjYW52YXNNdXRhdGlvbkNiLmFwcGx5KHZvaWQgMCwgW10uY29uY2F0KHApKTtcbiAgICB9O1xuICAgIG8yLmZvbnRDYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBwW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob29rcy5mb250KSB7XG4gICAgICAgICAgICB2YXIgX2hvb2tzO1xuICAgICAgICAgICAgKF9ob29rcyA9IGhvb2tzKS5mb250LmFwcGx5KF9ob29rcywgW10uY29uY2F0KHApKTtcbiAgICAgICAgfVxuICAgICAgICBmb250Q2IuYXBwbHkodm9pZCAwLCBbXS5jb25jYXQocCkpO1xuICAgIH07XG4gICAgbzIuc2VsZWN0aW9uQ2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcCA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgcFtfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9va3Muc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgX2hvb2tzO1xuICAgICAgICAgICAgKF9ob29rcyA9IGhvb2tzKS5zZWxlY3Rpb24uYXBwbHkoX2hvb2tzLCBbXS5jb25jYXQocCkpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGlvbkNiLmFwcGx5KHZvaWQgMCwgW10uY29uY2F0KHApKTtcbiAgICB9O1xuICAgIG8yLmN1c3RvbUVsZW1lbnRDYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBjMiA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgYzJbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvb2tzLmN1c3RvbUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBfaG9va3M7XG4gICAgICAgICAgICAoX2hvb2tzID0gaG9va3MpLmN1c3RvbUVsZW1lbnQuYXBwbHkoX2hvb2tzLCBbXS5jb25jYXQoYzIpKTtcbiAgICAgICAgfVxuICAgICAgICBjdXN0b21FbGVtZW50Q2IuYXBwbHkodm9pZCAwLCBbXS5jb25jYXQoYzIpKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gaW5pdE9ic2VydmVycyhvMiwgaG9va3MpIHtcbiAgICBpZiAoaG9va3MgPT09IHZvaWQgMCkgaG9va3MgPSB7fTtcbiAgICB2YXIgY3VycmVudFdpbmRvdyA9IG8yLmRvYy5kZWZhdWx0VmlldztcbiAgICBpZiAoIWN1cnJlbnRXaW5kb3cpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge307XG4gICAgfVxuICAgIG1lcmdlSG9va3MobzIsIGhvb2tzKTtcbiAgICB2YXIgbXV0YXRpb25PYnNlcnZlcjtcbiAgICBpZiAobzIucmVjb3JkRE9NKSB7XG4gICAgICAgIG11dGF0aW9uT2JzZXJ2ZXIgPSBpbml0TXV0YXRpb25PYnNlcnZlcihvMiwgbzIuZG9jKTtcbiAgICB9XG4gICAgdmFyIG1vdXNlbW92ZUhhbmRsZXIgPSBpbml0TW92ZU9ic2VydmVyKG8yKTtcbiAgICB2YXIgbW91c2VJbnRlcmFjdGlvbkhhbmRsZXIgPSBpbml0TW91c2VJbnRlcmFjdGlvbk9ic2VydmVyKG8yKTtcbiAgICB2YXIgc2Nyb2xsSGFuZGxlciA9IGluaXRTY3JvbGxPYnNlcnZlcihvMik7XG4gICAgdmFyIHZpZXdwb3J0UmVzaXplSGFuZGxlciA9IGluaXRWaWV3cG9ydFJlc2l6ZU9ic2VydmVyKG8yLCB7XG4gICAgICAgIHdpbjogY3VycmVudFdpbmRvd1xuICAgIH0pO1xuICAgIHZhciBpbnB1dEhhbmRsZXIgPSBpbml0SW5wdXRPYnNlcnZlcihvMik7XG4gICAgdmFyIG1lZGlhSW50ZXJhY3Rpb25IYW5kbGVyID0gaW5pdE1lZGlhSW50ZXJhY3Rpb25PYnNlcnZlcihvMik7XG4gICAgdmFyIHN0eWxlU2hlZXRPYnNlcnZlciA9IGZ1bmN0aW9uKCkge307XG4gICAgdmFyIGFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIgPSBmdW5jdGlvbigpIHt9O1xuICAgIHZhciBzdHlsZURlY2xhcmF0aW9uT2JzZXJ2ZXIgPSBmdW5jdGlvbigpIHt9O1xuICAgIHZhciBmb250T2JzZXJ2ZXIgPSBmdW5jdGlvbigpIHt9O1xuICAgIGlmIChvMi5yZWNvcmRET00pIHtcbiAgICAgICAgc3R5bGVTaGVldE9ic2VydmVyID0gaW5pdFN0eWxlU2hlZXRPYnNlcnZlcihvMiwge1xuICAgICAgICAgICAgd2luOiBjdXJyZW50V2luZG93XG4gICAgICAgIH0pO1xuICAgICAgICBhZG9wdGVkU3R5bGVTaGVldE9ic2VydmVyID0gaW5pdEFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIobzIsIG8yLmRvYyk7XG4gICAgICAgIHN0eWxlRGVjbGFyYXRpb25PYnNlcnZlciA9IGluaXRTdHlsZURlY2xhcmF0aW9uT2JzZXJ2ZXIobzIsIHtcbiAgICAgICAgICAgIHdpbjogY3VycmVudFdpbmRvd1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG8yLmNvbGxlY3RGb250cykge1xuICAgICAgICAgICAgZm9udE9ic2VydmVyID0gaW5pdEZvbnRPYnNlcnZlcihvMik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHNlbGVjdGlvbk9ic2VydmVyID0gaW5pdFNlbGVjdGlvbk9ic2VydmVyKG8yKTtcbiAgICB2YXIgY3VzdG9tRWxlbWVudE9ic2VydmVyID0gaW5pdEN1c3RvbUVsZW1lbnRPYnNlcnZlcihvMik7XG4gICAgdmFyIHBsdWdpbkhhbmRsZXJzID0gW107XG4gICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UobzIucGx1Z2lucyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgdmFyIHBsdWdpbjMgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgcGx1Z2luSGFuZGxlcnMucHVzaChwbHVnaW4zLm9ic2VydmVyKHBsdWdpbjMuY2FsbGJhY2ssIGN1cnJlbnRXaW5kb3csIHBsdWdpbjMub3B0aW9ucykpO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICBtdXRhdGlvbkJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbihiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5yZXNldCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgbXV0YXRpb25PYnNlcnZlciA9PSBudWxsID8gdm9pZCAwIDogbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIG1vdXNlbW92ZUhhbmRsZXIoKTtcbiAgICAgICAgbW91c2VJbnRlcmFjdGlvbkhhbmRsZXIoKTtcbiAgICAgICAgc2Nyb2xsSGFuZGxlcigpO1xuICAgICAgICB2aWV3cG9ydFJlc2l6ZUhhbmRsZXIoKTtcbiAgICAgICAgaW5wdXRIYW5kbGVyKCk7XG4gICAgICAgIG1lZGlhSW50ZXJhY3Rpb25IYW5kbGVyKCk7XG4gICAgICAgIHN0eWxlU2hlZXRPYnNlcnZlcigpO1xuICAgICAgICBhZG9wdGVkU3R5bGVTaGVldE9ic2VydmVyKCk7XG4gICAgICAgIHN0eWxlRGVjbGFyYXRpb25PYnNlcnZlcigpO1xuICAgICAgICBmb250T2JzZXJ2ZXIoKTtcbiAgICAgICAgc2VsZWN0aW9uT2JzZXJ2ZXIoKTtcbiAgICAgICAgY3VzdG9tRWxlbWVudE9ic2VydmVyKCk7XG4gICAgICAgIHBsdWdpbkhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgcmV0dXJuIGgoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBoYXNOZXN0ZWRDU1NSdWxlKHByb3ApIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvd1twcm9wXSAhPT0gXCJ1bmRlZmluZWRcIjtcbn1cbmZ1bmN0aW9uIGNhbk1vbmtleVBhdGNoTmVzdGVkQ1NTUnVsZShwcm9wKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odHlwZW9mIHdpbmRvd1twcm9wXSAhPT0gXCJ1bmRlZmluZWRcIiAmJiAvLyBOb3RlOiBHZW5lcmFsbHksIHRoaXMgY2hlY2sgX3Nob3VsZG4ndF8gYmUgbmVjZXNzYXJ5XG4gICAgLy8gSG93ZXZlciwgaW4gc29tZSBzY2VuYXJpb3MgKGUuZy4ganNkb20pIHRoaXMgY2FuIHNvbWV0aW1lcyBmYWlsLCBzbyB3ZSBjaGVjayBmb3IgaXQgaGVyZVxuICAgIHdpbmRvd1twcm9wXS5wcm90b3R5cGUgJiYgXCJpbnNlcnRSdWxlXCIgaW4gd2luZG93W3Byb3BdLnByb3RvdHlwZSAmJiBcImRlbGV0ZVJ1bGVcIiBpbiB3aW5kb3dbcHJvcF0ucHJvdG90eXBlKTtcbn1cbnZhciBDcm9zc09yaWdpbklmcmFtZU1pcnJvciA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gQ3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3IoZ2VuZXJhdGVJZEZuKSB7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImlmcmFtZUlkVG9SZW1vdGVJZE1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImlmcmFtZVJlbW90ZUlkVG9JZE1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVJZEZuID0gZ2VuZXJhdGVJZEZuO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gQ3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3IucHJvdG90eXBlO1xuICAgIF9wcm90by5nZXRJZCA9IGZ1bmN0aW9uIGdldElkKGlmcmFtZSwgcmVtb3RlSWQsIGlkVG9SZW1vdGVNYXAsIHJlbW90ZVRvSWRNYXApIHtcbiAgICAgICAgdmFyIGlkVG9SZW1vdGVJZE1hcCA9IGlkVG9SZW1vdGVNYXAgfHwgdGhpcy5nZXRJZFRvUmVtb3RlSWRNYXAoaWZyYW1lKTtcbiAgICAgICAgdmFyIHJlbW90ZUlkVG9JZE1hcCA9IHJlbW90ZVRvSWRNYXAgfHwgdGhpcy5nZXRSZW1vdGVJZFRvSWRNYXAoaWZyYW1lKTtcbiAgICAgICAgdmFyIGlkID0gaWRUb1JlbW90ZUlkTWFwLmdldChyZW1vdGVJZCk7XG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIGlkID0gdGhpcy5nZW5lcmF0ZUlkRm4oKTtcbiAgICAgICAgICAgIGlkVG9SZW1vdGVJZE1hcC5zZXQocmVtb3RlSWQsIGlkKTtcbiAgICAgICAgICAgIHJlbW90ZUlkVG9JZE1hcC5zZXQoaWQsIHJlbW90ZUlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0SWRzID0gZnVuY3Rpb24gZ2V0SWRzKGlmcmFtZSwgcmVtb3RlSWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGlkVG9SZW1vdGVJZE1hcCA9IHRoaXMuZ2V0SWRUb1JlbW90ZUlkTWFwKGlmcmFtZSk7XG4gICAgICAgIHZhciByZW1vdGVJZFRvSWRNYXAgPSB0aGlzLmdldFJlbW90ZUlkVG9JZE1hcChpZnJhbWUpO1xuICAgICAgICByZXR1cm4gcmVtb3RlSWQubWFwKGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0SWQoaWZyYW1lLCBpZCwgaWRUb1JlbW90ZUlkTWFwLCByZW1vdGVJZFRvSWRNYXApO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5nZXRSZW1vdGVJZCA9IGZ1bmN0aW9uIGdldFJlbW90ZUlkKGlmcmFtZSwgaWQsIG1hcCkge1xuICAgICAgICB2YXIgcmVtb3RlSWRUb0lkTWFwID0gbWFwIHx8IHRoaXMuZ2V0UmVtb3RlSWRUb0lkTWFwKGlmcmFtZSk7XG4gICAgICAgIGlmICh0eXBlb2YgaWQgIT09IFwibnVtYmVyXCIpIHJldHVybiBpZDtcbiAgICAgICAgdmFyIHJlbW90ZUlkID0gcmVtb3RlSWRUb0lkTWFwLmdldChpZCk7XG4gICAgICAgIGlmICghcmVtb3RlSWQpIHJldHVybiAtMTtcbiAgICAgICAgcmV0dXJuIHJlbW90ZUlkO1xuICAgIH07XG4gICAgX3Byb3RvLmdldFJlbW90ZUlkcyA9IGZ1bmN0aW9uIGdldFJlbW90ZUlkcyhpZnJhbWUsIGlkcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVtb3RlSWRUb0lkTWFwID0gdGhpcy5nZXRSZW1vdGVJZFRvSWRNYXAoaWZyYW1lKTtcbiAgICAgICAgcmV0dXJuIGlkcy5tYXAoZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRSZW1vdGVJZChpZnJhbWUsIGlkLCByZW1vdGVJZFRvSWRNYXApO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KGlmcmFtZSkge1xuICAgICAgICBpZiAoIWlmcmFtZSkge1xuICAgICAgICAgICAgdGhpcy5pZnJhbWVJZFRvUmVtb3RlSWRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuaWZyYW1lUmVtb3RlSWRUb0lkTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pZnJhbWVJZFRvUmVtb3RlSWRNYXAuZGVsZXRlKGlmcmFtZSk7XG4gICAgICAgIHRoaXMuaWZyYW1lUmVtb3RlSWRUb0lkTWFwLmRlbGV0ZShpZnJhbWUpO1xuICAgIH07XG4gICAgX3Byb3RvLmdldElkVG9SZW1vdGVJZE1hcCA9IGZ1bmN0aW9uIGdldElkVG9SZW1vdGVJZE1hcChpZnJhbWUpIHtcbiAgICAgICAgdmFyIGlkVG9SZW1vdGVJZE1hcCA9IHRoaXMuaWZyYW1lSWRUb1JlbW90ZUlkTWFwLmdldChpZnJhbWUpO1xuICAgICAgICBpZiAoIWlkVG9SZW1vdGVJZE1hcCkge1xuICAgICAgICAgICAgaWRUb1JlbW90ZUlkTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuaWZyYW1lSWRUb1JlbW90ZUlkTWFwLnNldChpZnJhbWUsIGlkVG9SZW1vdGVJZE1hcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkVG9SZW1vdGVJZE1hcDtcbiAgICB9O1xuICAgIF9wcm90by5nZXRSZW1vdGVJZFRvSWRNYXAgPSBmdW5jdGlvbiBnZXRSZW1vdGVJZFRvSWRNYXAoaWZyYW1lKSB7XG4gICAgICAgIHZhciByZW1vdGVJZFRvSWRNYXAgPSB0aGlzLmlmcmFtZVJlbW90ZUlkVG9JZE1hcC5nZXQoaWZyYW1lKTtcbiAgICAgICAgaWYgKCFyZW1vdGVJZFRvSWRNYXApIHtcbiAgICAgICAgICAgIHJlbW90ZUlkVG9JZE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLmlmcmFtZVJlbW90ZUlkVG9JZE1hcC5zZXQoaWZyYW1lLCByZW1vdGVJZFRvSWRNYXApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZW1vdGVJZFRvSWRNYXA7XG4gICAgfTtcbiAgICByZXR1cm4gQ3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3I7XG59KCk7XG52YXIgSWZyYW1lTWFuYWdlciA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gSWZyYW1lTWFuYWdlcihvcHRpb25zKSB7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImlmcmFtZXNcIiwgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJjcm9zc09yaWdpbklmcmFtZU1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImNyb3NzT3JpZ2luSWZyYW1lTWlycm9yXCIsIG5ldyBDcm9zc09yaWdpbklmcmFtZU1pcnJvcihnZW5JZCkpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJjcm9zc09yaWdpbklmcmFtZVN0eWxlTWlycm9yXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJjcm9zc09yaWdpbklmcmFtZVJvb3RJZE1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcIm1pcnJvclwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwibXV0YXRpb25DYlwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwid3JhcHBlZEVtaXRcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImxvYWRMaXN0ZW5lclwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwic3R5bGVzaGVldE1hbmFnZXJcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcInJlY29yZENyb3NzT3JpZ2luSWZyYW1lc1wiKTtcbiAgICAgICAgdGhpcy5tdXRhdGlvbkNiID0gb3B0aW9ucy5tdXRhdGlvbkNiO1xuICAgICAgICB0aGlzLndyYXBwZWRFbWl0ID0gb3B0aW9ucy53cmFwcGVkRW1pdDtcbiAgICAgICAgdGhpcy5zdHlsZXNoZWV0TWFuYWdlciA9IG9wdGlvbnMuc3R5bGVzaGVldE1hbmFnZXI7XG4gICAgICAgIHRoaXMucmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzID0gb3B0aW9ucy5yZWNvcmRDcm9zc09yaWdpbklmcmFtZXM7XG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVTdHlsZU1pcnJvciA9IG5ldyBDcm9zc09yaWdpbklmcmFtZU1pcnJvcih0aGlzLnN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yLmdlbmVyYXRlSWQuYmluZCh0aGlzLnN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yKSk7XG4gICAgICAgIHRoaXMubWlycm9yID0gb3B0aW9ucy5taXJyb3I7XG4gICAgICAgIGlmICh0aGlzLnJlY29yZENyb3NzT3JpZ2luSWZyYW1lcykge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuaGFuZGxlTWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gSWZyYW1lTWFuYWdlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmFkZElmcmFtZSA9IGZ1bmN0aW9uIGFkZElmcmFtZShpZnJhbWVFbCkge1xuICAgICAgICB0aGlzLmlmcmFtZXMuc2V0KGlmcmFtZUVsLCB0cnVlKTtcbiAgICAgICAgaWYgKGlmcmFtZUVsLmNvbnRlbnRXaW5kb3cpIHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVNYXAuc2V0KGlmcmFtZUVsLmNvbnRlbnRXaW5kb3csIGlmcmFtZUVsKTtcbiAgICB9O1xuICAgIF9wcm90by5hZGRMb2FkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMb2FkTGlzdGVuZXIoY2IpIHtcbiAgICAgICAgdGhpcy5sb2FkTGlzdGVuZXIgPSBjYjtcbiAgICB9O1xuICAgIF9wcm90by5hdHRhY2hJZnJhbWUgPSBmdW5jdGlvbiBhdHRhY2hJZnJhbWUoaWZyYW1lRWwsIGNoaWxkU24pIHtcbiAgICAgICAgdmFyIF9hMiwgX2I7XG4gICAgICAgIHRoaXMubXV0YXRpb25DYih7XG4gICAgICAgICAgICBhZGRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZDogdGhpcy5taXJyb3IuZ2V0SWQoaWZyYW1lRWwpLFxuICAgICAgICAgICAgICAgICAgICBuZXh0SWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IGNoaWxkU25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgcmVtb3ZlczogW10sXG4gICAgICAgICAgICB0ZXh0czogW10sXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBbXSxcbiAgICAgICAgICAgIGlzQXR0YWNoSWZyYW1lOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5yZWNvcmRDcm9zc09yaWdpbklmcmFtZXMpIChfYTIgPSBpZnJhbWVFbC5jb250ZW50V2luZG93KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuaGFuZGxlTWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgKF9iID0gdGhpcy5sb2FkTGlzdGVuZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKHRoaXMsIGlmcmFtZUVsKTtcbiAgICAgICAgaWYgKGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudCAmJiBpZnJhbWVFbC5jb250ZW50RG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzICYmIGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudC5hZG9wdGVkU3R5bGVTaGVldHMubGVuZ3RoID4gMCkgdGhpcy5zdHlsZXNoZWV0TWFuYWdlci5hZG9wdFN0eWxlU2hlZXRzKGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudC5hZG9wdGVkU3R5bGVTaGVldHMsIHRoaXMubWlycm9yLmdldElkKGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudCkpO1xuICAgIH07XG4gICAgX3Byb3RvLmhhbmRsZU1lc3NhZ2UgPSBmdW5jdGlvbiBoYW5kbGVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIGNyb3NzT3JpZ2luTWVzc2FnZUV2ZW50ID0gbWVzc2FnZTtcbiAgICAgICAgaWYgKGNyb3NzT3JpZ2luTWVzc2FnZUV2ZW50LmRhdGEudHlwZSAhPT0gXCJycndlYlwiIHx8IC8vIFRvIGZpbHRlciBvdXQgdGhlIHJyd2ViIG1lc3NhZ2VzIHdoaWNoIGFyZSBmb3J3YXJkZWQgYnkgc29tZSBzaXRlcy5cbiAgICAgICAgY3Jvc3NPcmlnaW5NZXNzYWdlRXZlbnQub3JpZ2luICE9PSBjcm9zc09yaWdpbk1lc3NhZ2VFdmVudC5kYXRhLm9yaWdpbikgcmV0dXJuO1xuICAgICAgICB2YXIgaWZyYW1lU291cmNlV2luZG93ID0gbWVzc2FnZS5zb3VyY2U7XG4gICAgICAgIGlmICghaWZyYW1lU291cmNlV2luZG93KSByZXR1cm47XG4gICAgICAgIHZhciBpZnJhbWVFbCA9IHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVNYXAuZ2V0KG1lc3NhZ2Uuc291cmNlKTtcbiAgICAgICAgaWYgKCFpZnJhbWVFbCkgcmV0dXJuO1xuICAgICAgICB2YXIgdHJhbnNmb3JtZWRFdmVudCA9IHRoaXMudHJhbnNmb3JtQ3Jvc3NPcmlnaW5FdmVudChpZnJhbWVFbCwgY3Jvc3NPcmlnaW5NZXNzYWdlRXZlbnQuZGF0YS5ldmVudCk7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1lZEV2ZW50KSB0aGlzLndyYXBwZWRFbWl0KHRyYW5zZm9ybWVkRXZlbnQsIGNyb3NzT3JpZ2luTWVzc2FnZUV2ZW50LmRhdGEuaXNDaGVja291dCk7XG4gICAgfTtcbiAgICBfcHJvdG8udHJhbnNmb3JtQ3Jvc3NPcmlnaW5FdmVudCA9IGZ1bmN0aW9uIHRyYW5zZm9ybUNyb3NzT3JpZ2luRXZlbnQoaWZyYW1lRWwsIGUyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHN3aXRjaChlMi50eXBlKXtcbiAgICAgICAgICAgIGNhc2UgRXZlbnRUeXBlLkZ1bGxTbmFwc2hvdDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3IucmVzZXQoaWZyYW1lRWwpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lU3R5bGVNaXJyb3IucmVzZXQoaWZyYW1lRWwpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZE9uTm9kZShlMi5kYXRhLm5vZGUsIGlmcmFtZUVsKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3RJZCA9IGUyLmRhdGEubm9kZS5pZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcm9zc09yaWdpbklmcmFtZVJvb3RJZE1hcC5zZXQoaWZyYW1lRWwsIHJvb3RJZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF0Y2hSb290SWRPbk5vZGUoZTIuZGF0YS5ub2RlLCByb290SWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBlMi50aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLk11dGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQ6IHRoaXMubWlycm9yLmdldElkKGlmcmFtZUVsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRJZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IGUyLmRhdGEubm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0czogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNBdHRhY2hJZnJhbWU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEV2ZW50VHlwZS5NZXRhOlxuICAgICAgICAgICAgY2FzZSBFdmVudFR5cGUuTG9hZDpcbiAgICAgICAgICAgIGNhc2UgRXZlbnRUeXBlLkRvbUNvbnRlbnRMb2FkZWQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBFdmVudFR5cGUuUGx1Z2luOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgRXZlbnRUeXBlLkN1c3RvbTpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhlMi5kYXRhLnBheWxvYWQsIGlmcmFtZUVsLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcImlkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInBhcmVudElkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInByZXZpb3VzSWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibmV4dElkXCJcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGUyLmRhdGEuc291cmNlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuTXV0YXRpb246XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlMi5kYXRhLmFkZHMuZm9yRWFjaChmdW5jdGlvbihuMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVwbGFjZUlkcyhuMiwgaWZyYW1lRWwsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBhcmVudElkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJuZXh0SWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInByZXZpb3VzSWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXBsYWNlSWRPbk5vZGUobjIubm9kZSwgaWZyYW1lRWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3RJZCA9IF90aGlzLmNyb3NzT3JpZ2luSWZyYW1lUm9vdElkTWFwLmdldChpZnJhbWVFbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290SWQgJiYgX3RoaXMucGF0Y2hSb290SWRPbk5vZGUobjIubm9kZSwgcm9vdElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUyLmRhdGEucmVtb3Zlcy5mb3JFYWNoKGZ1bmN0aW9uKG4yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXBsYWNlSWRzKG4yLCBpZnJhbWVFbCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicGFyZW50SWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZTIuZGF0YS5hdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24objIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlcGxhY2VJZHMobjIsIGlmcmFtZUVsLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUyLmRhdGEudGV4dHMuZm9yRWFjaChmdW5jdGlvbihuMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVwbGFjZUlkcyhuMiwgaWZyYW1lRWwsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuRHJhZzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuVG91Y2hNb3ZlOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5Nb3VzZU1vdmU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlMi5kYXRhLnBvc2l0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlcGxhY2VJZHMocCwgaWZyYW1lRWwsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuVmlld3BvcnRSZXNpemU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5NZWRpYUludGVyYWN0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5Nb3VzZUludGVyYWN0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5TY3JvbGw6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLkNhbnZhc011dGF0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5JbnB1dDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhlMi5kYXRhLCBpZnJhbWVFbCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5TdHlsZVNoZWV0UnVsZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuU3R5bGVEZWNsYXJhdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhlMi5kYXRhLCBpZnJhbWVFbCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VTdHlsZUlkcyhlMi5kYXRhLCBpZnJhbWVFbCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzdHlsZUlkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLkZvbnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5TZWxlY3Rpb246XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlMi5kYXRhLnJhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXBsYWNlSWRzKHJhbmdlLCBpZnJhbWVFbCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic3RhcnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImVuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLkFkb3B0ZWRTdHlsZVNoZWV0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRzKGUyLmRhdGEsIGlmcmFtZUVsLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZVN0eWxlSWRzKGUyLmRhdGEsIGlmcmFtZUVsLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInN0eWxlSWRzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYTIgPSBlMi5kYXRhLnN0eWxlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5mb3JFYWNoKGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXBsYWNlU3R5bGVJZHMoc3R5bGUsIGlmcmFtZUVsLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzdHlsZUlkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UoaWZyYW1lTWlycm9yLCBvYmosIGlmcmFtZUVsLCBrZXlzKSB7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKGtleXMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIga2V5ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqW2tleV0pICYmIHR5cGVvZiBvYmpba2V5XSAhPT0gXCJudW1iZXJcIikgY29udGludWU7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IGlmcmFtZU1pcnJvci5nZXRJZHMoaWZyYW1lRWwsIG9ialtrZXldKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSBpZnJhbWVNaXJyb3IuZ2V0SWQoaWZyYW1lRWwsIG9ialtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gICAgX3Byb3RvLnJlcGxhY2VJZHMgPSBmdW5jdGlvbiByZXBsYWNlSWRzKG9iaiwgaWZyYW1lRWwsIGtleXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZSh0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWlycm9yLCBvYmosIGlmcmFtZUVsLCBrZXlzKTtcbiAgICB9O1xuICAgIF9wcm90by5yZXBsYWNlU3R5bGVJZHMgPSBmdW5jdGlvbiByZXBsYWNlU3R5bGVJZHMob2JqLCBpZnJhbWVFbCwga2V5cykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVTdHlsZU1pcnJvciwgb2JqLCBpZnJhbWVFbCwga2V5cyk7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVwbGFjZUlkT25Ob2RlID0gZnVuY3Rpb24gcmVwbGFjZUlkT25Ob2RlKG5vZGUyLCBpZnJhbWVFbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnJlcGxhY2VJZHMobm9kZTIsIGlmcmFtZUVsLCBbXG4gICAgICAgICAgICBcImlkXCIsXG4gICAgICAgICAgICBcInJvb3RJZFwiXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAoXCJjaGlsZE5vZGVzXCIgaW4gbm9kZTIpIHtcbiAgICAgICAgICAgIG5vZGUyLmNoaWxkTm9kZXMuZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlcGxhY2VJZE9uTm9kZShjaGlsZCwgaWZyYW1lRWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5wYXRjaFJvb3RJZE9uTm9kZSA9IGZ1bmN0aW9uIHBhdGNoUm9vdElkT25Ob2RlKG5vZGUyLCByb290SWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG5vZGUyLnR5cGUgIT09IE5vZGVUeXBlLkRvY3VtZW50ICYmICFub2RlMi5yb290SWQpIG5vZGUyLnJvb3RJZCA9IHJvb3RJZDtcbiAgICAgICAgaWYgKFwiY2hpbGROb2Rlc1wiIGluIG5vZGUyKSB7XG4gICAgICAgICAgICBub2RlMi5jaGlsZE5vZGVzLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wYXRjaFJvb3RJZE9uTm9kZShjaGlsZCwgcm9vdElkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSWZyYW1lTWFuYWdlcjtcbn0oKTtcbnZhciBTaGFkb3dEb21NYW5hZ2VyID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBTaGFkb3dEb21NYW5hZ2VyKG9wdGlvbnMpIHtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwic2hhZG93RG9tc1wiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKSk7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcIm11dGF0aW9uQ2JcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcInNjcm9sbENiXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJieXBhc3NPcHRpb25zXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJtaXJyb3JcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcInJlc3RvcmVIYW5kbGVyc1wiLCBbXSk7XG4gICAgICAgIHRoaXMubXV0YXRpb25DYiA9IG9wdGlvbnMubXV0YXRpb25DYjtcbiAgICAgICAgdGhpcy5zY3JvbGxDYiA9IG9wdGlvbnMuc2Nyb2xsQ2I7XG4gICAgICAgIHRoaXMuYnlwYXNzT3B0aW9ucyA9IG9wdGlvbnMuYnlwYXNzT3B0aW9ucztcbiAgICAgICAgdGhpcy5taXJyb3IgPSBvcHRpb25zLm1pcnJvcjtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBTaGFkb3dEb21NYW5hZ2VyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uaW5pdCA9IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgdGhpcy5wYXRjaEF0dGFjaFNoYWRvdyhFbGVtZW50LCBkb2N1bWVudCk7XG4gICAgfTtcbiAgICBfcHJvdG8uYWRkU2hhZG93Um9vdCA9IGZ1bmN0aW9uIGFkZFNoYWRvd1Jvb3Qoc2hhZG93Um9vdDIsIGRvYykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIWlzTmF0aXZlU2hhZG93RG9tKHNoYWRvd1Jvb3QyKSkgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5zaGFkb3dEb21zLmhhcyhzaGFkb3dSb290MikpIHJldHVybjtcbiAgICAgICAgdGhpcy5zaGFkb3dEb21zLmFkZChzaGFkb3dSb290Mik7XG4gICAgICAgIHZhciBvYnNlcnZlciA9IGluaXRNdXRhdGlvbk9ic2VydmVyKF9leHRlbmRzKHt9LCB0aGlzLmJ5cGFzc09wdGlvbnMsIHtcbiAgICAgICAgICAgIGRvYzogZG9jLFxuICAgICAgICAgICAgbXV0YXRpb25DYjogdGhpcy5tdXRhdGlvbkNiLFxuICAgICAgICAgICAgbWlycm9yOiB0aGlzLm1pcnJvcixcbiAgICAgICAgICAgIHNoYWRvd0RvbU1hbmFnZXI6IHRoaXNcbiAgICAgICAgfSksIHNoYWRvd1Jvb3QyKTtcbiAgICAgICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMucHVzaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlc3RvcmVIYW5kbGVycy5wdXNoKGluaXRTY3JvbGxPYnNlcnZlcihfZXh0ZW5kcyh7fSwgdGhpcy5ieXBhc3NPcHRpb25zLCB7XG4gICAgICAgICAgICBzY3JvbGxDYjogdGhpcy5zY3JvbGxDYixcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3ByYXZlZW5wdWdsaWEvMDgzMmRhNjg3ZWQ1YTVkN2EwOTA3MDQ2YzllZjE4MTNcbiAgICAgICAgICAgIC8vIHNjcm9sbCBpcyBub3QgYWxsb3dlZCB0byBwYXNzIHRoZSBib3VuZGFyeSwgc28gd2UgbmVlZCB0byBsaXN0ZW4gdGhlIHNoYWRvdyBkb2N1bWVudFxuICAgICAgICAgICAgZG9jOiBzaGFkb3dSb290MixcbiAgICAgICAgICAgIG1pcnJvcjogdGhpcy5taXJyb3JcbiAgICAgICAgfSkpKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChzaGFkb3dSb290Mi5hZG9wdGVkU3R5bGVTaGVldHMgJiYgc2hhZG93Um9vdDIuYWRvcHRlZFN0eWxlU2hlZXRzLmxlbmd0aCA+IDApIF90aGlzLmJ5cGFzc09wdGlvbnMuc3R5bGVzaGVldE1hbmFnZXIuYWRvcHRTdHlsZVNoZWV0cyhzaGFkb3dSb290Mi5hZG9wdGVkU3R5bGVTaGVldHMsIF90aGlzLm1pcnJvci5nZXRJZChpbmRleC5ob3N0KHNoYWRvd1Jvb3QyKSkpO1xuICAgICAgICAgICAgX3RoaXMucmVzdG9yZUhhbmRsZXJzLnB1c2goaW5pdEFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIoe1xuICAgICAgICAgICAgICAgIG1pcnJvcjogX3RoaXMubWlycm9yLFxuICAgICAgICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyOiBfdGhpcy5ieXBhc3NPcHRpb25zLnN0eWxlc2hlZXRNYW5hZ2VyXG4gICAgICAgICAgICB9LCBzaGFkb3dSb290MikpO1xuICAgICAgICB9LCAwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgKiBNb25rZXkgcGF0Y2ggJ2F0dGFjaFNoYWRvdycgb2YgYW4gSUZyYW1lRWxlbWVudCB0byBvYnNlcnZlIG5ld2x5IGFkZGVkIHNoYWRvdyBkb21zLlxuICAgKi8gX3Byb3RvLm9ic2VydmVBdHRhY2hTaGFkb3cgPSBmdW5jdGlvbiBvYnNlcnZlQXR0YWNoU2hhZG93KGlmcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCFpZnJhbWVFbGVtZW50LmNvbnRlbnRXaW5kb3cgfHwgIWlmcmFtZUVsZW1lbnQuY29udGVudERvY3VtZW50KSByZXR1cm47XG4gICAgICAgIHRoaXMucGF0Y2hBdHRhY2hTaGFkb3coaWZyYW1lRWxlbWVudC5jb250ZW50V2luZG93LkVsZW1lbnQsIGlmcmFtZUVsZW1lbnQuY29udGVudERvY3VtZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgKiBQYXRjaCAnYXR0YWNoU2hhZG93JyB0byBvYnNlcnZlIG5ld2x5IGFkZGVkIHNoYWRvdyBkb21zLlxuICAgKi8gX3Byb3RvLnBhdGNoQXR0YWNoU2hhZG93ID0gZnVuY3Rpb24gcGF0Y2hBdHRhY2hTaGFkb3coZWxlbWVudCwgZG9jKSB7XG4gICAgICAgIHZhciBtYW5hZ2VyID0gdGhpcztcbiAgICAgICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMucHVzaChwYXRjaCQyKGVsZW1lbnQucHJvdG90eXBlLCBcImF0dGFjaFNoYWRvd1wiLCBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9wdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBzUm9vdCA9IG9yaWdpbmFsLmNhbGwodGhpcywgb3B0aW9uKTtcbiAgICAgICAgICAgICAgICB2YXIgc2hhZG93Um9vdEVsID0gaW5kZXguc2hhZG93Um9vdCh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hhZG93Um9vdEVsICYmIGluRG9tKHRoaXMpKSBtYW5hZ2VyLmFkZFNoYWRvd1Jvb3Qoc2hhZG93Um9vdEVsLCBkb2MpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzUm9vdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnJlc3RvcmVIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcigpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZTIpIHt9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlc3RvcmVIYW5kbGVycyA9IFtdO1xuICAgICAgICB0aGlzLnNoYWRvd0RvbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbiAgICB9O1xuICAgIHJldHVybiBTaGFkb3dEb21NYW5hZ2VyO1xufSgpO1xudmFyIGNoYXJzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG52YXIgbG9va3VwID0gdHlwZW9mIFVpbnQ4QXJyYXkgPT09IFwidW5kZWZpbmVkXCIgPyBbXSA6IG5ldyBVaW50OEFycmF5KDI1Nik7XG5mb3IodmFyIGkkMSA9IDA7IGkkMSA8IGNoYXJzLmxlbmd0aDsgaSQxKyspe1xuICAgIGxvb2t1cFtjaGFycy5jaGFyQ29kZUF0KGkkMSldID0gaSQxO1xufVxudmFyIGVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShhcnJheWJ1ZmZlcikge1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSwgaTIsIGxlbiA9IGJ5dGVzLmxlbmd0aCwgYmFzZTY0ID0gXCJcIjtcbiAgICBmb3IoaTIgPSAwOyBpMiA8IGxlbjsgaTIgKz0gMyl7XG4gICAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpMl0gPj4gMl07XG4gICAgICAgIGJhc2U2NCArPSBjaGFyc1soYnl0ZXNbaTJdICYgMykgPDwgNCB8IGJ5dGVzW2kyICsgMV0gPj4gNF07XG4gICAgICAgIGJhc2U2NCArPSBjaGFyc1soYnl0ZXNbaTIgKyAxXSAmIDE1KSA8PCAyIHwgYnl0ZXNbaTIgKyAyXSA+PiA2XTtcbiAgICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kyICsgMl0gJiA2M107XG4gICAgfVxuICAgIGlmIChsZW4gJSAzID09PSAyKSB7XG4gICAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgXCI9XCI7XG4gICAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG4gICAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgXCI9PVwiO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTY0O1xufTtcbnZhciBjYW52YXNWYXJNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gdmFyaWFibGVMaXN0Rm9yJDEoY3R4LCBjdG9yKSB7XG4gICAgdmFyIGNvbnRleHRNYXAgPSBjYW52YXNWYXJNYXAuZ2V0KGN0eCk7XG4gICAgaWYgKCFjb250ZXh0TWFwKSB7XG4gICAgICAgIGNvbnRleHRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICBjYW52YXNWYXJNYXAuc2V0KGN0eCwgY29udGV4dE1hcCk7XG4gICAgfVxuICAgIGlmICghY29udGV4dE1hcC5oYXMoY3RvcikpIHtcbiAgICAgICAgY29udGV4dE1hcC5zZXQoY3RvciwgW10pO1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dE1hcC5nZXQoY3Rvcik7XG59XG52YXIgc2F2ZVdlYkdMVmFyID0gZnVuY3Rpb24odmFsdWUsIHdpbiwgY3R4KSB7XG4gICAgaWYgKCF2YWx1ZSB8fCAhKGlzSW5zdGFuY2VPZldlYkdMT2JqZWN0KHZhbHVlLCB3aW4pIHx8ICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YodmFsdWUpKSA9PT0gXCJvYmplY3RcIikpIHJldHVybjtcbiAgICB2YXIgbmFtZSA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgdmFyIGxpc3QyID0gdmFyaWFibGVMaXN0Rm9yJDEoY3R4LCBuYW1lKTtcbiAgICB2YXIgaW5kZXgyID0gbGlzdDIuaW5kZXhPZih2YWx1ZSk7XG4gICAgaWYgKGluZGV4MiA9PT0gLTEpIHtcbiAgICAgICAgaW5kZXgyID0gbGlzdDIubGVuZ3RoO1xuICAgICAgICBsaXN0Mi5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4Mjtcbn07XG5mdW5jdGlvbiBzZXJpYWxpemVBcmcodmFsdWUsIHdpbiwgY3R4KSB7XG4gICAgaWYgKF9pbnN0YW5jZW9mKHZhbHVlLCBBcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVBcmcoYXJnLCB3aW4sIGN0eCk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoX2luc3RhbmNlb2YodmFsdWUsIEZsb2F0MzJBcnJheSkgfHwgX2luc3RhbmNlb2YodmFsdWUsIEZsb2F0NjRBcnJheSkgfHwgX2luc3RhbmNlb2YodmFsdWUsIEludDMyQXJyYXkpIHx8IF9pbnN0YW5jZW9mKHZhbHVlLCBVaW50MzJBcnJheSkgfHwgX2luc3RhbmNlb2YodmFsdWUsIFVpbnQ4QXJyYXkpIHx8IF9pbnN0YW5jZW9mKHZhbHVlLCBVaW50MTZBcnJheSkgfHwgX2luc3RhbmNlb2YodmFsdWUsIEludDE2QXJyYXkpIHx8IF9pbnN0YW5jZW9mKHZhbHVlLCBJbnQ4QXJyYXkpIHx8IF9pbnN0YW5jZW9mKHZhbHVlLCBVaW50OENsYW1wZWRBcnJheSkpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcnJfdHlwZTogbmFtZSxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICBPYmplY3QudmFsdWVzKHZhbHVlKVxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoLy8gU2hhcmVkQXJyYXlCdWZmZXIgZGlzYWJsZWQgb24gbW9zdCBicm93c2VycyBkdWUgdG8gc3BlY3RyZS5cbiAgICAvLyBNb3JlIGluZm86IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1NoYXJlZEFycmF5QnVmZmVyL1NoYXJlZEFycmF5QnVmZmVyXG4gICAgLy8gdmFsdWUgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlciB8fFxuICAgIF9pbnN0YW5jZW9mKHZhbHVlLCBBcnJheUJ1ZmZlcikpIHtcbiAgICAgICAgdmFyIG5hbWUxID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgdmFyIGJhc2U2NCA9IGVuY29kZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBycl90eXBlOiBuYW1lMSxcbiAgICAgICAgICAgIGJhc2U2NDogYmFzZTY0XG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZih2YWx1ZSwgRGF0YVZpZXcpKSB7XG4gICAgICAgIHZhciBuYW1lMiA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBycl90eXBlOiBuYW1lMixcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVBcmcodmFsdWUuYnVmZmVyLCB3aW4sIGN0eCksXG4gICAgICAgICAgICAgICAgdmFsdWUuYnl0ZU9mZnNldCxcbiAgICAgICAgICAgICAgICB2YWx1ZS5ieXRlTGVuZ3RoXG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZih2YWx1ZSwgSFRNTEltYWdlRWxlbWVudCkpIHtcbiAgICAgICAgdmFyIG5hbWUzID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgdmFyIHNyYyA9IHZhbHVlLnNyYztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJyX3R5cGU6IG5hbWUzLFxuICAgICAgICAgICAgc3JjOiBzcmNcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKF9pbnN0YW5jZW9mKHZhbHVlLCBIVE1MQ2FudmFzRWxlbWVudCkpIHtcbiAgICAgICAgdmFyIG5hbWU0ID0gXCJIVE1MSW1hZ2VFbGVtZW50XCI7XG4gICAgICAgIHZhciBzcmMxID0gdmFsdWUudG9EYXRhVVJMKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBycl90eXBlOiBuYW1lNCxcbiAgICAgICAgICAgIHNyYzogc3JjMVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoX2luc3RhbmNlb2YodmFsdWUsIEltYWdlRGF0YSkpIHtcbiAgICAgICAgdmFyIG5hbWU1ID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJyX3R5cGU6IG5hbWU1LFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZUFyZyh2YWx1ZS5kYXRhLCB3aW4sIGN0eCksXG4gICAgICAgICAgICAgICAgdmFsdWUud2lkdGgsXG4gICAgICAgICAgICAgICAgdmFsdWUuaGVpZ2h0XG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChpc0luc3RhbmNlT2ZXZWJHTE9iamVjdCh2YWx1ZSwgd2luKSB8fCAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKHZhbHVlKSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdmFyIG5hbWU2ID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgdmFyIGluZGV4MiA9IHNhdmVXZWJHTFZhcih2YWx1ZSwgd2luLCBjdHgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcnJfdHlwZTogbmFtZTYsXG4gICAgICAgICAgICBpbmRleDogaW5kZXgyXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbnZhciBzZXJpYWxpemVBcmdzID0gZnVuY3Rpb24oYXJncywgd2luLCBjdHgpIHtcbiAgICByZXR1cm4gYXJncy5tYXAoZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVBcmcoYXJnLCB3aW4sIGN0eCk7XG4gICAgfSk7XG59O1xudmFyIGlzSW5zdGFuY2VPZldlYkdMT2JqZWN0ID0gZnVuY3Rpb24odmFsdWUsIHdpbikge1xuICAgIHZhciB3ZWJHTENvbnN0cnVjdG9yTmFtZXMgPSBbXG4gICAgICAgIFwiV2ViR0xBY3RpdmVJbmZvXCIsXG4gICAgICAgIFwiV2ViR0xCdWZmZXJcIixcbiAgICAgICAgXCJXZWJHTEZyYW1lYnVmZmVyXCIsXG4gICAgICAgIFwiV2ViR0xQcm9ncmFtXCIsXG4gICAgICAgIFwiV2ViR0xSZW5kZXJidWZmZXJcIixcbiAgICAgICAgXCJXZWJHTFNoYWRlclwiLFxuICAgICAgICBcIldlYkdMU2hhZGVyUHJlY2lzaW9uRm9ybWF0XCIsXG4gICAgICAgIFwiV2ViR0xUZXh0dXJlXCIsXG4gICAgICAgIFwiV2ViR0xVbmlmb3JtTG9jYXRpb25cIixcbiAgICAgICAgXCJXZWJHTFZlcnRleEFycmF5T2JqZWN0XCIsXG4gICAgICAgIC8vIEluIG9sZCBDaHJvbWUgdmVyc2lvbnMsIHZhbHVlIHdvbid0IGJlIGFuIGluc3RhbmNlb2YgV2ViR0xWZXJ0ZXhBcnJheU9iamVjdC5cbiAgICAgICAgXCJXZWJHTFZlcnRleEFycmF5T2JqZWN0T0VTXCJcbiAgICBdO1xuICAgIHZhciBzdXBwb3J0ZWRXZWJHTENvbnN0cnVjdG9yTmFtZXMgPSB3ZWJHTENvbnN0cnVjdG9yTmFtZXMuZmlsdGVyKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB3aW5bbmFtZV0gPT09IFwiZnVuY3Rpb25cIjtcbiAgICB9KTtcbiAgICByZXR1cm4gQm9vbGVhbihzdXBwb3J0ZWRXZWJHTENvbnN0cnVjdG9yTmFtZXMuZmluZChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBfaW5zdGFuY2VvZih2YWx1ZSwgd2luW25hbWVdKTtcbiAgICB9KSk7XG59O1xuZnVuY3Rpb24gaW5pdENhbnZhczJETXV0YXRpb25PYnNlcnZlcihjYiwgd2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKSB7XG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwcm9wID0gX3N0ZXAudmFsdWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbi5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlW3Byb3BdICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3RvcmVIYW5kbGVyID0gcGF0Y2gkMih3aW4uQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZSwgcHJvcCwgZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Jsb2NrZWQodGhpcy5jYW52YXMsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWNvcmRBcmdzID0gc2VyaWFsaXplQXJncyhhcmdzLCB3aW4sIF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYihfdGhpcy5jYW52YXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQ2FudmFzQ29udGV4dFtcIjJEXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcHJvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogcmVjb3JkQXJnc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhhbmRsZXJzLnB1c2gocmVzdG9yZUhhbmRsZXIpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB2YXIgaG9va0hhbmRsZXIgPSBob29rU2V0dGVyKHdpbi5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLCBwcm9wLCB7XG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodjIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2IodGhpcy5jYW52YXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IENhbnZhc0NvbnRleHRbXCIyRFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYyXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGVyOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChob29rSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBoYW5kbGVycyA9IFtdO1xuICAgIHZhciBwcm9wczJEID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luLkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUpO1xuICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHByb3BzMkQpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOylfbG9vcCgpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICByZXR1cm4gaCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZENvbnRleHROYW1lKGNvbnRleHRUeXBlKSB7XG4gICAgcmV0dXJuIGNvbnRleHRUeXBlID09PSBcImV4cGVyaW1lbnRhbC13ZWJnbFwiID8gXCJ3ZWJnbFwiIDogY29udGV4dFR5cGU7XG59XG5mdW5jdGlvbiBpbml0Q2FudmFzQ29udGV4dE9ic2VydmVyKHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwgc2V0UHJlc2VydmVEcmF3aW5nQnVmZmVyVG9UcnVlKSB7XG4gICAgdmFyIGhhbmRsZXJzID0gW107XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc3RvcmVIYW5kbGVyID0gcGF0Y2gkMih3aW4uSFRNTENhbnZhc0VsZW1lbnQucHJvdG90eXBlLCBcImdldENvbnRleHRcIiwgZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihjb250ZXh0VHlwZSkge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWlzQmxvY2tlZCh0aGlzLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3R4TmFtZSA9IGdldE5vcm1hbGl6ZWRDb250ZXh0TmFtZShjb250ZXh0VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKFwiX19jb250ZXh0XCIgaW4gdGhpcykpIHRoaXMuX19jb250ZXh0ID0gY3R4TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldFByZXNlcnZlRHJhd2luZ0J1ZmZlclRvVHJ1ZSAmJiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcIndlYmdsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIndlYmdsMlwiXG4gICAgICAgICAgICAgICAgICAgIF0uaW5jbHVkZXMoY3R4TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdzWzBdICYmIF90eXBlX29mKGFyZ3NbMF0pID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRleHRBdHRyaWJ1dGVzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHRBdHRyaWJ1dGVzLnByZXNlcnZlRHJhd2luZ0J1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0QXR0cmlidXRlcy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5zcGxpY2UoMCwgMSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgW10uY29uY2F0KFtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dFR5cGVcbiAgICAgICAgICAgICAgICBdLCBhcmdzKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgaGFuZGxlcnMucHVzaChyZXN0b3JlSGFuZGxlcik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiZmFpbGVkIHRvIHBhdGNoIEhUTUxDYW52YXNFbGVtZW50LnByb3RvdHlwZS5nZXRDb250ZXh0XCIpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgcmV0dXJuIGgoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBhdGNoR0xQcm90b3R5cGUocHJvdG90eXBlLCB0eXBlLCBjYiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwgd2luKSB7XG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwcm9wID0gX3N0ZXAudmFsdWU7XG4gICAgICAgIGlmICgvL3Byb3Auc3RhcnRzV2l0aCgnZ2V0JykgfHwgIC8vIGUuZy4gZ2V0UHJvZ3JhbVBhcmFtZXRlciwgYnV0IHRvbyByaXNreVxuICAgICAgICBbXG4gICAgICAgICAgICBcImlzQ29udGV4dExvc3RcIixcbiAgICAgICAgICAgIFwiY2FudmFzXCIsXG4gICAgICAgICAgICBcImRyYXdpbmdCdWZmZXJXaWR0aFwiLFxuICAgICAgICAgICAgXCJkcmF3aW5nQnVmZmVySGVpZ2h0XCJcbiAgICAgICAgXS5pbmNsdWRlcyhwcm9wKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm90b3R5cGVbcHJvcF0gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdG9yZUhhbmRsZXIgPSBwYXRjaCQyKHByb3RvdHlwZSwgcHJvcCwgZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDIgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgc2F2ZVdlYkdMVmFyKHJlc3VsdDIsIHdpbiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcInRhZ05hbWVcIiBpbiB0aGlzLmNhbnZhcyAmJiAhaXNCbG9ja2VkKHRoaXMuY2FudmFzLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlY29yZEFyZ3MgPSBzZXJpYWxpemVBcmdzKGFyZ3MsIHdpbiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXV0YXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcHJvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiByZWNvcmRBcmdzXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2IodGhpcy5jYW52YXMsIG11dGF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBoYW5kbGVycy5wdXNoKHJlc3RvcmVIYW5kbGVyKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdmFyIGhvb2tIYW5kbGVyID0gaG9va1NldHRlcihwcm90b3R5cGUsIHByb3AsIHtcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2Mikge1xuICAgICAgICAgICAgICAgICAgICBjYih0aGlzLmNhbnZhcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYyXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGVyOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChob29rSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBoYW5kbGVycyA9IFtdO1xuICAgIHZhciBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvdHlwZSk7XG4gICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UocHJvcHMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOylfbG9vcCgpO1xuICAgIHJldHVybiBoYW5kbGVycztcbn1cbmZ1bmN0aW9uIGluaXRDYW52YXNXZWJHTE11dGF0aW9uT2JzZXJ2ZXIoY2IsIHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvcikge1xuICAgIHZhciBfaGFuZGxlcnM7XG4gICAgdmFyIGhhbmRsZXJzID0gW107XG4gICAgKF9oYW5kbGVycyA9IGhhbmRsZXJzKS5wdXNoLmFwcGx5KF9oYW5kbGVycywgW10uY29uY2F0KHBhdGNoR0xQcm90b3R5cGUod2luLldlYkdMUmVuZGVyaW5nQ29udGV4dC5wcm90b3R5cGUsIENhbnZhc0NvbnRleHQuV2ViR0wsIGNiLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB3aW4pKSk7XG4gICAgaWYgKHR5cGVvZiB3aW4uV2ViR0wyUmVuZGVyaW5nQ29udGV4dCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB2YXIgX2hhbmRsZXJzMTtcbiAgICAgICAgKF9oYW5kbGVyczEgPSBoYW5kbGVycykucHVzaC5hcHBseShfaGFuZGxlcnMxLCBbXS5jb25jYXQocGF0Y2hHTFByb3RvdHlwZSh3aW4uV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5wcm90b3R5cGUsIENhbnZhc0NvbnRleHQuV2ViR0wyLCBjYiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwgd2luKSkpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgcmV0dXJuIGgoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbnZhciBlbmNvZGVkSnMgPSBcIktHWjFibU4wYVc5dUtDa2dld29nSUNKMWMyVWdjM1J5YVdOMElqc0tJQ0IyWVhJZ1kyaGhjbk1nUFNBaVFVSkRSRVZHUjBoSlNrdE1UVTVQVUZGU1UxUlZWbGRZV1ZwaFltTmtaV1puYUdscWEyeHRibTl3Y1hKemRIVjJkM2g1ZWpBeE1qTTBOVFkzT0Rrckx5STdDaUFnZG1GeUlHeHZiMnQxY0NBOUlIUjVjR1Z2WmlCVmFXNTBPRUZ5Y21GNUlEMDlQU0FpZFc1a1pXWnBibVZrSWlBL0lGdGRJRG9nYm1WM0lGVnBiblE0UVhKeVlYa29NalUyS1RzS0lDQm1iM0lnS0haaGNpQnBJRDBnTURzZ2FTQThJR05vWVhKekxteGxibWQwYURzZ2FTc3JLU0I3Q2lBZ0lDQnNiMjlyZFhCYlkyaGhjbk11WTJoaGNrTnZaR1ZCZENocEtWMGdQU0JwT3dvZ0lIMEtJQ0IyWVhJZ1pXNWpiMlJsSUQwZ1puVnVZM1JwYjI0b1lYSnlZWGxpZFdabVpYSXBJSHNLSUNBZ0lIWmhjaUJpZVhSbGN5QTlJRzVsZHlCVmFXNTBPRUZ5Y21GNUtHRnljbUY1WW5WbVptVnlLU3dnYVRJc0lHeGxiaUE5SUdKNWRHVnpMbXhsYm1kMGFDd2dZbUZ6WlRZMElEMGdJaUk3Q2lBZ0lDQm1iM0lnS0dreUlEMGdNRHNnYVRJZ1BDQnNaVzQ3SUdreUlDczlJRE1wSUhzS0lDQWdJQ0FnWW1GelpUWTBJQ3M5SUdOb1lYSnpXMko1ZEdWelcya3lYU0ErUGlBeVhUc0tJQ0FnSUNBZ1ltRnpaVFkwSUNzOUlHTm9ZWEp6V3loaWVYUmxjMXRwTWwwZ0ppQXpLU0E4UENBMElId2dZbmwwWlhOYmFUSWdLeUF4WFNBK1BpQTBYVHNLSUNBZ0lDQWdZbUZ6WlRZMElDczlJR05vWVhKeld5aGllWFJsYzF0cE1pQXJJREZkSUNZZ01UVXBJRHc4SURJZ2ZDQmllWFJsYzF0cE1pQXJJREpkSUQ0K0lEWmRPd29nSUNBZ0lDQmlZWE5sTmpRZ0t6MGdZMmhoY25OYllubDBaWE5iYVRJZ0t5QXlYU0FtSURZelhUc0tJQ0FnSUgwS0lDQWdJR2xtSUNoc1pXNGdKU0F6SUQwOVBTQXlLU0I3Q2lBZ0lDQWdJR0poYzJVMk5DQTlJR0poYzJVMk5DNXpkV0p6ZEhKcGJtY29NQ3dnWW1GelpUWTBMbXhsYm1kMGFDQXRJREVwSUNzZ0lqMGlPd29nSUNBZ2ZTQmxiSE5sSUdsbUlDaHNaVzRnSlNBeklEMDlQU0F4S1NCN0NpQWdJQ0FnSUdKaGMyVTJOQ0E5SUdKaGMyVTJOQzV6ZFdKemRISnBibWNvTUN3Z1ltRnpaVFkwTG14bGJtZDBhQ0F0SURJcElDc2dJajA5SWpzS0lDQWdJSDBLSUNBZ0lISmxkSFZ5YmlCaVlYTmxOalE3Q2lBZ2ZUc0tJQ0JqYjI1emRDQnNZWE4wUW14dllrMWhjQ0E5SUM4cUlFQmZYMUJWVWtWZlh5QXFMeUJ1WlhjZ1RXRndLQ2s3Q2lBZ1kyOXVjM1FnZEhKaGJuTndZWEpsYm5SQ2JHOWlUV0Z3SUQwZ0x5b2dRRjlmVUZWU1JWOWZJQ292SUc1bGR5Qk5ZWEFvS1RzS0lDQmhjM2x1WXlCbWRXNWpkR2x2YmlCblpYUlVjbUZ1YzNCaGNtVnVkRUpzYjJKR2IzSW9kMmxrZEdnc0lHaGxhV2RvZEN3Z1pHRjBZVlZTVEU5d2RHbHZibk1wSUhzS0lDQWdJR052Ym5OMElHbGtJRDBnWUNSN2QybGtkR2g5TFNSN2FHVnBaMmgwZldBN0NpQWdJQ0JwWmlBb0lrOW1abk5qY21WbGJrTmhiblpoY3lJZ2FXNGdaMnh2WW1Gc1ZHaHBjeWtnZXdvZ0lDQWdJQ0JwWmlBb2RISmhibk53WVhKbGJuUkNiRzlpVFdGd0xtaGhjeWhwWkNrcElISmxkSFZ5YmlCMGNtRnVjM0JoY21WdWRFSnNiMkpOWVhBdVoyVjBLR2xrS1RzS0lDQWdJQ0FnWTI5dWMzUWdiMlptYzJOeVpXVnVJRDBnYm1WM0lFOW1abk5qY21WbGJrTmhiblpoY3loM2FXUjBhQ3dnYUdWcFoyaDBLVHNLSUNBZ0lDQWdiMlptYzJOeVpXVnVMbWRsZEVOdmJuUmxlSFFvSWpKa0lpazdDaUFnSUNBZ0lHTnZibk4wSUdKc2IySWdQU0JoZDJGcGRDQnZabVp6WTNKbFpXNHVZMjl1ZG1WeWRGUnZRbXh2WWloa1lYUmhWVkpNVDNCMGFXOXVjeWs3Q2lBZ0lDQWdJR052Ym5OMElHRnljbUY1UW5WbVptVnlJRDBnWVhkaGFYUWdZbXh2WWk1aGNuSmhlVUoxWm1abGNpZ3BPd29nSUNBZ0lDQmpiMjV6ZENCaVlYTmxOalFnUFNCbGJtTnZaR1VvWVhKeVlYbENkV1ptWlhJcE93b2dJQ0FnSUNCMGNtRnVjM0JoY21WdWRFSnNiMkpOWVhBdWMyVjBLR2xrTENCaVlYTmxOalFwT3dvZ0lDQWdJQ0J5WlhSMWNtNGdZbUZ6WlRZME93b2dJQ0FnZlNCbGJITmxJSHNLSUNBZ0lDQWdjbVYwZFhKdUlDSWlPd29nSUNBZ2ZRb2dJSDBLSUNCamIyNXpkQ0IzYjNKclpYSWdQU0J6Wld4bU93b2dJSGR2Y210bGNpNXZibTFsYzNOaFoyVWdQU0JoYzNsdVl5Qm1kVzVqZEdsdmJpaGxLU0I3Q2lBZ0lDQnBaaUFvSWs5bVpuTmpjbVZsYmtOaGJuWmhjeUlnYVc0Z1oyeHZZbUZzVkdocGN5a2dld29nSUNBZ0lDQmpiMjV6ZENCN0lHbGtMQ0JpYVhSdFlYQXNJSGRwWkhSb0xDQm9aV2xuYUhRc0lHUmhkR0ZWVWt4UGNIUnBiMjV6SUgwZ1BTQmxMbVJoZEdFN0NpQWdJQ0FnSUdOdmJuTjBJSFJ5WVc1emNHRnlaVzUwUW1GelpUWTBJRDBnWjJWMFZISmhibk53WVhKbGJuUkNiRzlpUm05eUtBb2dJQ0FnSUNBZ0lIZHBaSFJvTEFvZ0lDQWdJQ0FnSUdobGFXZG9kQ3dLSUNBZ0lDQWdJQ0JrWVhSaFZWSk1UM0IwYVc5dWN3b2dJQ0FnSUNBcE93b2dJQ0FnSUNCamIyNXpkQ0J2Wm1aelkzSmxaVzRnUFNCdVpYY2dUMlptYzJOeVpXVnVRMkZ1ZG1GektIZHBaSFJvTENCb1pXbG5hSFFwT3dvZ0lDQWdJQ0JqYjI1emRDQmpkSGdnUFNCdlptWnpZM0psWlc0dVoyVjBRMjl1ZEdWNGRDZ2lNbVFpS1RzS0lDQWdJQ0FnWTNSNExtUnlZWGRKYldGblpTaGlhWFJ0WVhBc0lEQXNJREFwT3dvZ0lDQWdJQ0JpYVhSdFlYQXVZMnh2YzJVb0tUc0tJQ0FnSUNBZ1kyOXVjM1FnWW14dllpQTlJR0YzWVdsMElHOW1abk5qY21WbGJpNWpiMjUyWlhKMFZHOUNiRzlpS0dSaGRHRlZVa3hQY0hScGIyNXpLVHNLSUNBZ0lDQWdZMjl1YzNRZ2RIbHdaU0E5SUdKc2IySXVkSGx3WlRzS0lDQWdJQ0FnWTI5dWMzUWdZWEp5WVhsQ2RXWm1aWElnUFNCaGQyRnBkQ0JpYkc5aUxtRnljbUY1UW5WbVptVnlLQ2s3Q2lBZ0lDQWdJR052Ym5OMElHSmhjMlUyTkNBOUlHVnVZMjlrWlNoaGNuSmhlVUoxWm1abGNpazdDaUFnSUNBZ0lHbG1JQ2doYkdGemRFSnNiMkpOWVhBdWFHRnpLR2xrS1NBbUppQmhkMkZwZENCMGNtRnVjM0JoY21WdWRFSmhjMlUyTkNBOVBUMGdZbUZ6WlRZMEtTQjdDaUFnSUNBZ0lDQWdiR0Z6ZEVKc2IySk5ZWEF1YzJWMEtHbGtMQ0JpWVhObE5qUXBPd29nSUNBZ0lDQWdJSEpsZEhWeWJpQjNiM0pyWlhJdWNHOXpkRTFsYzNOaFoyVW9leUJwWkNCOUtUc0tJQ0FnSUNBZ2ZRb2dJQ0FnSUNCcFppQW9iR0Z6ZEVKc2IySk5ZWEF1WjJWMEtHbGtLU0E5UFQwZ1ltRnpaVFkwS1NCeVpYUjFjbTRnZDI5eWEyVnlMbkJ2YzNSTlpYTnpZV2RsS0hzZ2FXUWdmU2s3Q2lBZ0lDQWdJSGR2Y210bGNpNXdiM04wVFdWemMyRm5aU2g3Q2lBZ0lDQWdJQ0FnYVdRc0NpQWdJQ0FnSUNBZ2RIbHdaU3dLSUNBZ0lDQWdJQ0JpWVhObE5qUXNDaUFnSUNBZ0lDQWdkMmxrZEdnc0NpQWdJQ0FnSUNBZ2FHVnBaMmgwQ2lBZ0lDQWdJSDBwT3dvZ0lDQWdJQ0JzWVhOMFFteHZZazFoY0M1elpYUW9hV1FzSUdKaGMyVTJOQ2s3Q2lBZ0lDQjlJR1ZzYzJVZ2V3b2dJQ0FnSUNCeVpYUjFjbTRnZDI5eWEyVnlMbkJ2YzNSTlpYTnpZV2RsS0hzZ2FXUTZJR1V1WkdGMFlTNXBaQ0I5S1RzS0lDQWdJSDBLSUNCOU93cDlLU2dwT3dvdkx5TWdjMjkxY21ObFRXRndjR2x1WjFWU1REMXBiV0ZuWlMxaWFYUnRZWEF0WkdGMFlTMTFjbXd0ZDI5eWEyVnlMVWxLY0VNM1oxOWlMbXB6TG0xaGNBbz1cIjtcbnZhciBkZWNvZGVCYXNlNjQgPSBmdW5jdGlvbihiYXNlNjQpIHtcbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGF0b2IoYmFzZTY0KSwgZnVuY3Rpb24oYzIpIHtcbiAgICAgICAgcmV0dXJuIGMyLmNoYXJDb2RlQXQoMCk7XG4gICAgfSk7XG59O1xudmFyIGJsb2IgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5CbG9iICYmIG5ldyBCbG9iKFtcbiAgICBkZWNvZGVCYXNlNjQoZW5jb2RlZEpzKVxuXSwge1xuICAgIHR5cGU6IFwidGV4dC9qYXZhc2NyaXB0O2NoYXJzZXQ9dXRmLThcIlxufSk7XG5mdW5jdGlvbiBXb3JrZXJXcmFwcGVyKG9wdGlvbnMpIHtcbiAgICB2YXIgb2JqVVJMO1xuICAgIHRyeSB7XG4gICAgICAgIG9ialVSTCA9IGJsb2IgJiYgKHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTCkuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICBpZiAoIW9ialVSTCkgdGhyb3cgXCJcIjtcbiAgICAgICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIob2JqVVJMLCB7XG4gICAgICAgICAgICBuYW1lOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm5hbWVcbiAgICAgICAgfSk7XG4gICAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAod2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMKS5yZXZva2VPYmplY3RVUkwob2JqVVJMKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB3b3JrZXI7XG4gICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXb3JrZXIoXCJkYXRhOnRleHQvamF2YXNjcmlwdDtiYXNlNjQsXCIgKyBlbmNvZGVkSnMsIHtcbiAgICAgICAgICAgIG5hbWU6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubmFtZVxuICAgICAgICB9KTtcbiAgICB9IGZpbmFsbHl7XG4gICAgICAgIG9ialVSTCAmJiAod2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMKS5yZXZva2VPYmplY3RVUkwob2JqVVJMKTtcbiAgICB9XG59XG52YXIgQ2FudmFzTWFuYWdlciA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gQ2FudmFzTWFuYWdlcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcInBlbmRpbmdDYW52YXNNdXRhdGlvbnNcIiwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcInJhZlN0YW1wc1wiLCB7XG4gICAgICAgICAgICBsYXRlc3RJZDogMCxcbiAgICAgICAgICAgIGludm9rZUlkOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJtaXJyb3JcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcIm11dGF0aW9uQ2JcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcInJlc2V0T2JzZXJ2ZXJzXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJmcm96ZW5cIiwgZmFsc2UpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJsb2NrZWRcIiwgZmFsc2UpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJwcm9jZXNzTXV0YXRpb25cIiwgZnVuY3Rpb24odGFyZ2V0LCBtdXRhdGlvbikge1xuICAgICAgICAgICAgdmFyIG5ld0ZyYW1lID0gX3RoaXMucmFmU3RhbXBzLmludm9rZUlkICYmIF90aGlzLnJhZlN0YW1wcy5sYXRlc3RJZCAhPT0gX3RoaXMucmFmU3RhbXBzLmludm9rZUlkO1xuICAgICAgICAgICAgaWYgKG5ld0ZyYW1lIHx8ICFfdGhpcy5yYWZTdGFtcHMuaW52b2tlSWQpIF90aGlzLnJhZlN0YW1wcy5pbnZva2VJZCA9IF90aGlzLnJhZlN0YW1wcy5sYXRlc3RJZDtcbiAgICAgICAgICAgIGlmICghX3RoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucy5oYXModGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuc2V0KHRhcmdldCwgW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucy5nZXQodGFyZ2V0KS5wdXNoKG11dGF0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBfb3B0aW9uc19zYW1wbGluZyA9IG9wdGlvbnMuc2FtcGxpbmcsIHNhbXBsaW5nID0gX29wdGlvbnNfc2FtcGxpbmcgPT09IHZvaWQgMCA/IFwiYWxsXCIgOiBfb3B0aW9uc19zYW1wbGluZywgd2luID0gb3B0aW9ucy53aW4sIGJsb2NrQ2xhc3MgPSBvcHRpb25zLmJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IgPSBvcHRpb25zLmJsb2NrU2VsZWN0b3IsIHJlY29yZENhbnZhcyA9IG9wdGlvbnMucmVjb3JkQ2FudmFzLCBkYXRhVVJMT3B0aW9ucyA9IG9wdGlvbnMuZGF0YVVSTE9wdGlvbnM7XG4gICAgICAgIHRoaXMubXV0YXRpb25DYiA9IG9wdGlvbnMubXV0YXRpb25DYjtcbiAgICAgICAgdGhpcy5taXJyb3IgPSBvcHRpb25zLm1pcnJvcjtcbiAgICAgICAgaWYgKHJlY29yZENhbnZhcyAmJiBzYW1wbGluZyA9PT0gXCJhbGxcIikgdGhpcy5pbml0Q2FudmFzTXV0YXRpb25PYnNlcnZlcih3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpO1xuICAgICAgICBpZiAocmVjb3JkQ2FudmFzICYmIHR5cGVvZiBzYW1wbGluZyA9PT0gXCJudW1iZXJcIikgdGhpcy5pbml0Q2FudmFzRlBTT2JzZXJ2ZXIoc2FtcGxpbmcsIHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwge1xuICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnM6IGRhdGFVUkxPcHRpb25zXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gQ2FudmFzTWFuYWdlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgIHRoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucy5jbGVhcigpO1xuICAgICAgICB0aGlzLnJlc2V0T2JzZXJ2ZXJzICYmIHRoaXMucmVzZXRPYnNlcnZlcnMoKTtcbiAgICB9O1xuICAgIF9wcm90by5mcmVlemUgPSBmdW5jdGlvbiBmcmVlemUoKSB7XG4gICAgICAgIHRoaXMuZnJvemVuID0gdHJ1ZTtcbiAgICB9O1xuICAgIF9wcm90by51bmZyZWV6ZSA9IGZ1bmN0aW9uIHVuZnJlZXplKCkge1xuICAgICAgICB0aGlzLmZyb3plbiA9IGZhbHNlO1xuICAgIH07XG4gICAgX3Byb3RvLmxvY2sgPSBmdW5jdGlvbiBsb2NrKCkge1xuICAgICAgICB0aGlzLmxvY2tlZCA9IHRydWU7XG4gICAgfTtcbiAgICBfcHJvdG8udW5sb2NrID0gZnVuY3Rpb24gdW5sb2NrKCkge1xuICAgICAgICB0aGlzLmxvY2tlZCA9IGZhbHNlO1xuICAgIH07XG4gICAgX3Byb3RvLmluaXRDYW52YXNGUFNPYnNlcnZlciA9IGZ1bmN0aW9uIGluaXRDYW52YXNGUFNPYnNlcnZlcihmcHMsIHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2FudmFzQ29udGV4dFJlc2V0ID0gaW5pdENhbnZhc0NvbnRleHRPYnNlcnZlcih3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpO1xuICAgICAgICB2YXIgc25hcHNob3RJblByb2dyZXNzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXJXcmFwcGVyKCk7XG4gICAgICAgIHdvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlMikge1xuICAgICAgICAgICAgdmFyIGlkID0gZTIuZGF0YS5pZDtcbiAgICAgICAgICAgIHNuYXBzaG90SW5Qcm9ncmVzc01hcC5zZXQoaWQsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmICghKFwiYmFzZTY0XCIgaW4gZTIuZGF0YSkpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBfZTJfZGF0YSA9IGUyLmRhdGEsIGJhc2U2NCA9IF9lMl9kYXRhLmJhc2U2NCwgdHlwZSA9IF9lMl9kYXRhLnR5cGUsIHdpZHRoID0gX2UyX2RhdGEud2lkdGgsIGhlaWdodCA9IF9lMl9kYXRhLmhlaWdodDtcbiAgICAgICAgICAgIF90aGlzLm11dGF0aW9uQ2Ioe1xuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICB0eXBlOiBDYW52YXNDb250ZXh0W1wiMkRcIl0sXG4gICAgICAgICAgICAgICAgY29tbWFuZHM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IFwiY2xlYXJSZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aXBlIGNhbnZhc1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IFwiZHJhd0ltYWdlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkcmF3cyAoc2VtaS10cmFuc3BhcmVudCkgaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJyX3R5cGU6IFwiSW1hZ2VCaXRtYXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJyX3R5cGU6IFwiQmxvYlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnJfdHlwZTogXCJBcnJheUJ1ZmZlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZTY0OiBiYXNlNjRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdGltZUJldHdlZW5TbmFwc2hvdHMgPSAxZTMgLyBmcHM7XG4gICAgICAgIHZhciBsYXN0U25hcHNob3RUaW1lID0gMDtcbiAgICAgICAgdmFyIHJhZklkO1xuICAgICAgICB2YXIgZ2V0Q2FudmFzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlZENhbnZhcyA9IFtdO1xuICAgICAgICAgICAgd2luLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJjYW52YXNcIikuZm9yRWFjaChmdW5jdGlvbihjYW52YXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQmxvY2tlZChjYW52YXMsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWRDYW52YXMucHVzaChjYW52YXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZWRDYW52YXM7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0YWtlQ2FudmFzU25hcHNob3RzID0gZnVuY3Rpb24odGltZXN0YW1wKSB7XG4gICAgICAgICAgICBpZiAobGFzdFNuYXBzaG90VGltZSAmJiB0aW1lc3RhbXAgLSBsYXN0U25hcHNob3RUaW1lIDwgdGltZUJldHdlZW5TbmFwc2hvdHMpIHtcbiAgICAgICAgICAgICAgICByYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0YWtlQ2FudmFzU25hcHNob3RzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0U25hcHNob3RUaW1lID0gdGltZXN0YW1wO1xuICAgICAgICAgICAgdmFyIF90aGlzMSA9IF90aGlzO1xuICAgICAgICAgICAgZ2V0Q2FudmFzKCkuZm9yRWFjaCgvKiNfX1BVUkVfXyovIF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hMiwgaWQsIGNvbnRleHQsIGJpdG1hcDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RzX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbihfc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKF9zdGF0ZS5sYWJlbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSBfdGhpczEubWlycm9yLmdldElkKGNhbnZhcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNuYXBzaG90SW5Qcm9ncmVzc01hcC5nZXQoaWQpKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FudmFzLndpZHRoID09PSAwIHx8IGNhbnZhcy5oZWlnaHQgPT09IDApIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNuYXBzaG90SW5Qcm9ncmVzc01hcC5zZXQoaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid2ViZ2xcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3ZWJnbDJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0uaW5jbHVkZXMoY2FudmFzLl9fY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KGNhbnZhcy5fX2NvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKChfYTIgPSBjb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBjb250ZXh0LmdldENvbnRleHRBdHRyaWJ1dGVzKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYTIucHJlc2VydmVEcmF3aW5nQnVmZmVyKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2xlYXIoY29udGV4dC5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVJbWFnZUJpdG1hcChjYW52YXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRtYXAgPSBfc3RhdGUuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0bWFwOiBiaXRtYXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogY2FudmFzLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnM6IG9wdGlvbnMuZGF0YVVSTE9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdG1hcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0YWtlQ2FudmFzU25hcHNob3RzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGFrZUNhbnZhc1NuYXBzaG90cyk7XG4gICAgICAgIHRoaXMucmVzZXRPYnNlcnZlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHRSZXNldCgpO1xuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSWQpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLmluaXRDYW52YXNNdXRhdGlvbk9ic2VydmVyID0gZnVuY3Rpb24gaW5pdENhbnZhc011dGF0aW9uT2JzZXJ2ZXIod2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuc3RhcnRSQUZUaW1lc3RhbXBpbmcoKTtcbiAgICAgICAgdGhpcy5zdGFydFBlbmRpbmdDYW52YXNNdXRhdGlvbkZsdXNoZXIoKTtcbiAgICAgICAgdmFyIGNhbnZhc0NvbnRleHRSZXNldCA9IGluaXRDYW52YXNDb250ZXh0T2JzZXJ2ZXIod2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBmYWxzZSk7XG4gICAgICAgIHZhciBjYW52YXMyRFJlc2V0ID0gaW5pdENhbnZhczJETXV0YXRpb25PYnNlcnZlcih0aGlzLnByb2Nlc3NNdXRhdGlvbi5iaW5kKHRoaXMpLCB3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpO1xuICAgICAgICB2YXIgY2FudmFzV2ViR0wxYW5kMlJlc2V0ID0gaW5pdENhbnZhc1dlYkdMTXV0YXRpb25PYnNlcnZlcih0aGlzLnByb2Nlc3NNdXRhdGlvbi5iaW5kKHRoaXMpLCB3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpO1xuICAgICAgICB0aGlzLnJlc2V0T2JzZXJ2ZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjYW52YXNDb250ZXh0UmVzZXQoKTtcbiAgICAgICAgICAgIGNhbnZhczJEUmVzZXQoKTtcbiAgICAgICAgICAgIGNhbnZhc1dlYkdMMWFuZDJSZXNldCgpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLnN0YXJ0UGVuZGluZ0NhbnZhc011dGF0aW9uRmx1c2hlciA9IGZ1bmN0aW9uIHN0YXJ0UGVuZGluZ0NhbnZhc011dGF0aW9uRmx1c2hlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmZsdXNoUGVuZGluZ0NhbnZhc011dGF0aW9ucygpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5zdGFydFJBRlRpbWVzdGFtcGluZyA9IGZ1bmN0aW9uIHN0YXJ0UkFGVGltZXN0YW1waW5nKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc2V0TGF0ZXN0UkFGVGltZXN0YW1wID0gZnVuY3Rpb24odGltZXN0YW1wKSB7XG4gICAgICAgICAgICBfdGhpcy5yYWZTdGFtcHMubGF0ZXN0SWQgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2V0TGF0ZXN0UkFGVGltZXN0YW1wKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHNldExhdGVzdFJBRlRpbWVzdGFtcCk7XG4gICAgfTtcbiAgICBfcHJvdG8uZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25zID0gZnVuY3Rpb24gZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25zKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuZm9yRWFjaChmdW5jdGlvbihfdmFsdWVzLCBjYW52YXMpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IF90aGlzLm1pcnJvci5nZXRJZChjYW52YXMpO1xuICAgICAgICAgICAgX3RoaXMuZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25Gb3IoY2FudmFzLCBpZCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25zKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmZsdXNoUGVuZGluZ0NhbnZhc011dGF0aW9uRm9yID0gZnVuY3Rpb24gZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25Gb3IoY2FudmFzLCBpZCkge1xuICAgICAgICBpZiAodGhpcy5mcm96ZW4gfHwgdGhpcy5sb2NrZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWVzV2l0aFR5cGUgPSB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuZ2V0KGNhbnZhcyk7XG4gICAgICAgIGlmICghdmFsdWVzV2l0aFR5cGUgfHwgaWQgPT09IC0xKSByZXR1cm47XG4gICAgICAgIHZhciB2YWx1ZXMgPSB2YWx1ZXNXaXRoVHlwZS5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlLnR5cGU7IHZhciByZXN0ID0gX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UodmFsdWUsIFtcbiAgICAgICAgICAgICAgICBcInR5cGVcIlxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB0eXBlID0gdmFsdWVzV2l0aFR5cGVbMF0udHlwZTtcbiAgICAgICAgdGhpcy5tdXRhdGlvbkNiKHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBjb21tYW5kczogdmFsdWVzXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuZGVsZXRlKGNhbnZhcyk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FudmFzTWFuYWdlcjtcbn0oKTtcbnZhciBTdHlsZXNoZWV0TWFuYWdlciA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gU3R5bGVzaGVldE1hbmFnZXIob3B0aW9ucykge1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJ0cmFja2VkTGlua0VsZW1lbnRzXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwibXV0YXRpb25DYlwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiYWRvcHRlZFN0eWxlU2hlZXRDYlwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwic3R5bGVNaXJyb3JcIiwgbmV3IFN0eWxlU2hlZXRNaXJyb3IoKSk7XG4gICAgICAgIHRoaXMubXV0YXRpb25DYiA9IG9wdGlvbnMubXV0YXRpb25DYjtcbiAgICAgICAgdGhpcy5hZG9wdGVkU3R5bGVTaGVldENiID0gb3B0aW9ucy5hZG9wdGVkU3R5bGVTaGVldENiO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gU3R5bGVzaGVldE1hbmFnZXIucHJvdG90eXBlO1xuICAgIF9wcm90by5hdHRhY2hMaW5rRWxlbWVudCA9IGZ1bmN0aW9uIGF0dGFjaExpbmtFbGVtZW50KGxpbmtFbCwgY2hpbGRTbikge1xuICAgICAgICBpZiAoXCJfY3NzVGV4dFwiIGluIGNoaWxkU24uYXR0cmlidXRlcykgdGhpcy5tdXRhdGlvbkNiKHtcbiAgICAgICAgICAgIGFkZHM6IFtdLFxuICAgICAgICAgICAgcmVtb3ZlczogW10sXG4gICAgICAgICAgICB0ZXh0czogW10sXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZDogY2hpbGRTbi5pZCxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogY2hpbGRTbi5hdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50cmFja0xpbmtFbGVtZW50KGxpbmtFbCk7XG4gICAgfTtcbiAgICBfcHJvdG8udHJhY2tMaW5rRWxlbWVudCA9IGZ1bmN0aW9uIHRyYWNrTGlua0VsZW1lbnQobGlua0VsKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYWNrZWRMaW5rRWxlbWVudHMuaGFzKGxpbmtFbCkpIHJldHVybjtcbiAgICAgICAgdGhpcy50cmFja2VkTGlua0VsZW1lbnRzLmFkZChsaW5rRWwpO1xuICAgICAgICB0aGlzLnRyYWNrU3R5bGVzaGVldEluTGlua0VsZW1lbnQobGlua0VsKTtcbiAgICB9O1xuICAgIF9wcm90by5hZG9wdFN0eWxlU2hlZXRzID0gZnVuY3Rpb24gYWRvcHRTdHlsZVNoZWV0cyhzaGVldHMsIGhvc3RJZCkge1xuICAgICAgICB2YXIgX3RoaXMsIF9sb29wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2hlZXQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIHZhciBzdHlsZUlkID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5zdHlsZU1pcnJvci5oYXMoc2hlZXQpKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVJZCA9IF90aGlzLnN0eWxlTWlycm9yLmFkZChzaGVldCk7XG4gICAgICAgICAgICAgICAgc3R5bGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzdHlsZUlkOiBzdHlsZUlkLFxuICAgICAgICAgICAgICAgICAgICBydWxlczogQXJyYXkuZnJvbShzaGVldC5ydWxlcyB8fCBDU1NSdWxlLCBmdW5jdGlvbihyMiwgaW5kZXgyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IHN0cmluZ2lmeVJ1bGUocjIsIHNoZWV0LmhyZWYpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleDJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Ugc3R5bGVJZCA9IF90aGlzLnN0eWxlTWlycm9yLmdldElkKHNoZWV0KTtcbiAgICAgICAgICAgIGFkb3B0ZWRTdHlsZVNoZWV0RGF0YS5zdHlsZUlkcy5wdXNoKHN0eWxlSWQpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoc2hlZXRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgICB2YXIgYWRvcHRlZFN0eWxlU2hlZXREYXRhID0ge1xuICAgICAgICAgICAgaWQ6IGhvc3RJZCxcbiAgICAgICAgICAgIHN0eWxlSWRzOiBbXVxuICAgICAgICB9O1xuICAgICAgICB2YXIgc3R5bGVzID0gW107XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHNoZWV0cyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KV90aGlzID0gdGhpcywgX2xvb3AoKTtcbiAgICAgICAgaWYgKHN0eWxlcy5sZW5ndGggPiAwKSBhZG9wdGVkU3R5bGVTaGVldERhdGEuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgICB0aGlzLmFkb3B0ZWRTdHlsZVNoZWV0Q2IoYWRvcHRlZFN0eWxlU2hlZXREYXRhKTtcbiAgICB9O1xuICAgIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnN0eWxlTWlycm9yLnJlc2V0KCk7XG4gICAgICAgIHRoaXMudHJhY2tlZExpbmtFbGVtZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICAgIH07XG4gICAgLy8gVE9ETzogdGFrZSBzbmFwc2hvdCBvbiBzdHlsZXNoZWV0IHJlbG9hZCBieSBhcHBseWluZyBldmVudCBsaXN0ZW5lclxuICAgIF9wcm90by50cmFja1N0eWxlc2hlZXRJbkxpbmtFbGVtZW50ID0gZnVuY3Rpb24gdHJhY2tTdHlsZXNoZWV0SW5MaW5rRWxlbWVudChfbGlua0VsKSB7fTtcbiAgICByZXR1cm4gU3R5bGVzaGVldE1hbmFnZXI7XG59KCk7XG52YXIgUHJvY2Vzc2VkTm9kZU1hbmFnZXIgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFByb2Nlc3NlZE5vZGVNYW5hZ2VyKCkge1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJub2RlTWFwXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiYWN0aXZlXCIsIGZhbHNlKTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFByb2Nlc3NlZE5vZGVNYW5hZ2VyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uaW5PdGhlckJ1ZmZlciA9IGZ1bmN0aW9uIGluT3RoZXJCdWZmZXIobm9kZTIsIHRoaXNCdWZmZXIpIHtcbiAgICAgICAgdmFyIGJ1ZmZlcnMgPSB0aGlzLm5vZGVNYXAuZ2V0KG5vZGUyKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcnMgJiYgQXJyYXkuZnJvbShidWZmZXJzKS5zb21lKGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlciAhPT0gdGhpc0J1ZmZlcjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKG5vZGUyLCBidWZmZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLm5vZGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZU1hcC5zZXQobm9kZTIsICh0aGlzLm5vZGVNYXAuZ2V0KG5vZGUyKSB8fCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKS5hZGQoYnVmZmVyKSk7XG4gICAgfTtcbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7fTtcbiAgICByZXR1cm4gUHJvY2Vzc2VkTm9kZU1hbmFnZXI7XG59KCk7XG52YXIgd3JhcHBlZEVtaXQ7XG52YXIgdGFrZUZ1bGxTbmFwc2hvdCQxO1xudmFyIGNhbnZhc01hbmFnZXI7XG52YXIgcmVjb3JkaW5nID0gZmFsc2U7XG50cnkge1xuICAgIGlmIChBcnJheS5mcm9tKFtcbiAgICAgICAgMVxuICAgIF0sIGZ1bmN0aW9uKHgyKSB7XG4gICAgICAgIHJldHVybiB4MiAqIDI7XG4gICAgfSlbMF0gIT09IDIpIHtcbiAgICAgICAgdmFyIGNsZWFuRnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNsZWFuRnJhbWUpO1xuICAgICAgICBBcnJheS5mcm9tID0gKChfYSA9IGNsZWFuRnJhbWUuY29udGVudFdpbmRvdykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLkFycmF5LmZyb20pIHx8IEFycmF5LmZyb207XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoY2xlYW5GcmFtZSk7XG4gICAgfVxufSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5kZWJ1ZyhcIlVuYWJsZSB0byBvdmVycmlkZSBBcnJheS5mcm9tXCIsIGVycik7XG59XG52YXIgbWlycm9yID0gY3JlYXRlTWlycm9yJDIoKTtcbmZ1bmN0aW9uIHJlY29yZChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBlbWl0ID0gb3B0aW9ucy5lbWl0LCBjaGVja291dEV2ZXJ5Tm1zID0gb3B0aW9ucy5jaGVja291dEV2ZXJ5Tm1zLCBjaGVja291dEV2ZXJ5TnRoID0gb3B0aW9ucy5jaGVja291dEV2ZXJ5TnRoLCBfb3B0aW9uc19ibG9ja0NsYXNzID0gb3B0aW9ucy5ibG9ja0NsYXNzLCBibG9ja0NsYXNzID0gX29wdGlvbnNfYmxvY2tDbGFzcyA9PT0gdm9pZCAwID8gXCJyci1ibG9ja1wiIDogX29wdGlvbnNfYmxvY2tDbGFzcywgX29wdGlvbnNfYmxvY2tTZWxlY3RvciA9IG9wdGlvbnMuYmxvY2tTZWxlY3RvciwgYmxvY2tTZWxlY3RvciA9IF9vcHRpb25zX2Jsb2NrU2VsZWN0b3IgPT09IHZvaWQgMCA/IG51bGwgOiBfb3B0aW9uc19ibG9ja1NlbGVjdG9yLCBfb3B0aW9uc19pZ25vcmVDbGFzcyA9IG9wdGlvbnMuaWdub3JlQ2xhc3MsIGlnbm9yZUNsYXNzID0gX29wdGlvbnNfaWdub3JlQ2xhc3MgPT09IHZvaWQgMCA/IFwicnItaWdub3JlXCIgOiBfb3B0aW9uc19pZ25vcmVDbGFzcywgX29wdGlvbnNfaWdub3JlU2VsZWN0b3IgPSBvcHRpb25zLmlnbm9yZVNlbGVjdG9yLCBpZ25vcmVTZWxlY3RvciA9IF9vcHRpb25zX2lnbm9yZVNlbGVjdG9yID09PSB2b2lkIDAgPyBudWxsIDogX29wdGlvbnNfaWdub3JlU2VsZWN0b3IsIF9vcHRpb25zX21hc2tUZXh0Q2xhc3MgPSBvcHRpb25zLm1hc2tUZXh0Q2xhc3MsIG1hc2tUZXh0Q2xhc3MgPSBfb3B0aW9uc19tYXNrVGV4dENsYXNzID09PSB2b2lkIDAgPyBcInJyLW1hc2tcIiA6IF9vcHRpb25zX21hc2tUZXh0Q2xhc3MsIF9vcHRpb25zX21hc2tUZXh0U2VsZWN0b3IgPSBvcHRpb25zLm1hc2tUZXh0U2VsZWN0b3IsIG1hc2tUZXh0U2VsZWN0b3IgPSBfb3B0aW9uc19tYXNrVGV4dFNlbGVjdG9yID09PSB2b2lkIDAgPyBudWxsIDogX29wdGlvbnNfbWFza1RleHRTZWxlY3RvciwgX29wdGlvbnNfaW5saW5lU3R5bGVzaGVldCA9IG9wdGlvbnMuaW5saW5lU3R5bGVzaGVldCwgaW5saW5lU3R5bGVzaGVldCA9IF9vcHRpb25zX2lubGluZVN0eWxlc2hlZXQgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9uc19pbmxpbmVTdHlsZXNoZWV0LCBtYXNrQWxsSW5wdXRzID0gb3B0aW9ucy5tYXNrQWxsSW5wdXRzLCBfbWFza0lucHV0T3B0aW9ucyA9IG9wdGlvbnMubWFza0lucHV0T3B0aW9ucywgX3NsaW1ET01PcHRpb25zID0gb3B0aW9ucy5zbGltRE9NT3B0aW9ucywgbWFza0lucHV0Rm4gPSBvcHRpb25zLm1hc2tJbnB1dEZuLCBtYXNrVGV4dEZuID0gb3B0aW9ucy5tYXNrVGV4dEZuLCBob29rcyA9IG9wdGlvbnMuaG9va3MsIHBhY2tGbiA9IG9wdGlvbnMucGFja0ZuLCBfb3B0aW9uc19zYW1wbGluZyA9IG9wdGlvbnMuc2FtcGxpbmcsIHNhbXBsaW5nID0gX29wdGlvbnNfc2FtcGxpbmcgPT09IHZvaWQgMCA/IHt9IDogX29wdGlvbnNfc2FtcGxpbmcsIF9vcHRpb25zX2RhdGFVUkxPcHRpb25zID0gb3B0aW9ucy5kYXRhVVJMT3B0aW9ucywgZGF0YVVSTE9wdGlvbnMgPSBfb3B0aW9uc19kYXRhVVJMT3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfb3B0aW9uc19kYXRhVVJMT3B0aW9ucywgbW91c2Vtb3ZlV2FpdCA9IG9wdGlvbnMubW91c2Vtb3ZlV2FpdCwgX29wdGlvbnNfcmVjb3JkRE9NID0gb3B0aW9ucy5yZWNvcmRET00sIHJlY29yZERPTSA9IF9vcHRpb25zX3JlY29yZERPTSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zX3JlY29yZERPTSwgX29wdGlvbnNfcmVjb3JkQ2FudmFzID0gb3B0aW9ucy5yZWNvcmRDYW52YXMsIHJlY29yZENhbnZhcyA9IF9vcHRpb25zX3JlY29yZENhbnZhcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9uc19yZWNvcmRDYW52YXMsIF9vcHRpb25zX3JlY29yZENyb3NzT3JpZ2luSWZyYW1lcyA9IG9wdGlvbnMucmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzLCByZWNvcmRDcm9zc09yaWdpbklmcmFtZXMgPSBfb3B0aW9uc19yZWNvcmRDcm9zc09yaWdpbklmcmFtZXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnNfcmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzLCBfb3B0aW9uc19yZWNvcmRBZnRlciA9IG9wdGlvbnMucmVjb3JkQWZ0ZXIsIHJlY29yZEFmdGVyID0gX29wdGlvbnNfcmVjb3JkQWZ0ZXIgPT09IHZvaWQgMCA/IG9wdGlvbnMucmVjb3JkQWZ0ZXIgPT09IFwiRE9NQ29udGVudExvYWRlZFwiID8gb3B0aW9ucy5yZWNvcmRBZnRlciA6IFwibG9hZFwiIDogX29wdGlvbnNfcmVjb3JkQWZ0ZXIsIF9vcHRpb25zX3VzZXJUcmlnZ2VyZWRPbklucHV0ID0gb3B0aW9ucy51c2VyVHJpZ2dlcmVkT25JbnB1dCwgdXNlclRyaWdnZXJlZE9uSW5wdXQgPSBfb3B0aW9uc191c2VyVHJpZ2dlcmVkT25JbnB1dCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9uc191c2VyVHJpZ2dlcmVkT25JbnB1dCwgX29wdGlvbnNfY29sbGVjdEZvbnRzID0gb3B0aW9ucy5jb2xsZWN0Rm9udHMsIGNvbGxlY3RGb250cyA9IF9vcHRpb25zX2NvbGxlY3RGb250cyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9uc19jb2xsZWN0Rm9udHMsIF9vcHRpb25zX2lubGluZUltYWdlcyA9IG9wdGlvbnMuaW5saW5lSW1hZ2VzLCBpbmxpbmVJbWFnZXMgPSBfb3B0aW9uc19pbmxpbmVJbWFnZXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnNfaW5saW5lSW1hZ2VzLCBwbHVnaW5zID0gb3B0aW9ucy5wbHVnaW5zLCBfb3B0aW9uc19rZWVwSWZyYW1lU3JjRm4gPSBvcHRpb25zLmtlZXBJZnJhbWVTcmNGbiwga2VlcElmcmFtZVNyY0ZuID0gX29wdGlvbnNfa2VlcElmcmFtZVNyY0ZuID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gOiBfb3B0aW9uc19rZWVwSWZyYW1lU3JjRm4sIF9vcHRpb25zX2lnbm9yZUNTU0F0dHJpYnV0ZXMgPSBvcHRpb25zLmlnbm9yZUNTU0F0dHJpYnV0ZXMsIGlnbm9yZUNTU0F0dHJpYnV0ZXMgPSBfb3B0aW9uc19pZ25vcmVDU1NBdHRyaWJ1dGVzID09PSB2b2lkIDAgPyAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXSkgOiBfb3B0aW9uc19pZ25vcmVDU1NBdHRyaWJ1dGVzLCBlcnJvckhhbmRsZXIyID0gb3B0aW9ucy5lcnJvckhhbmRsZXI7XG4gICAgcmVnaXN0ZXJFcnJvckhhbmRsZXIoZXJyb3JIYW5kbGVyMik7XG4gICAgdmFyIGluRW1pdHRpbmdGcmFtZSA9IHJlY29yZENyb3NzT3JpZ2luSWZyYW1lcyA/IHdpbmRvdy5wYXJlbnQgPT09IHdpbmRvdyA6IHRydWU7XG4gICAgdmFyIHBhc3NFbWl0c1RvUGFyZW50ID0gZmFsc2U7XG4gICAgaWYgKCFpbkVtaXR0aW5nRnJhbWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cucGFyZW50LmRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgcGFzc0VtaXRzVG9QYXJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgICAgIHBhc3NFbWl0c1RvUGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5FbWl0dGluZ0ZyYW1lICYmICFlbWl0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImVtaXQgZnVuY3Rpb24gaXMgcmVxdWlyZWRcIik7XG4gICAgfVxuICAgIGlmICghaW5FbWl0dGluZ0ZyYW1lICYmICFwYXNzRW1pdHNUb1BhcmVudCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gICAgaWYgKG1vdXNlbW92ZVdhaXQgIT09IHZvaWQgMCAmJiBzYW1wbGluZy5tb3VzZW1vdmUgPT09IHZvaWQgMCkge1xuICAgICAgICBzYW1wbGluZy5tb3VzZW1vdmUgPSBtb3VzZW1vdmVXYWl0O1xuICAgIH1cbiAgICBtaXJyb3IucmVzZXQoKTtcbiAgICB2YXIgbWFza0lucHV0T3B0aW9ucyA9IG1hc2tBbGxJbnB1dHMgPT09IHRydWUgPyB7XG4gICAgICAgIGNvbG9yOiB0cnVlLFxuICAgICAgICBkYXRlOiB0cnVlLFxuICAgICAgICBcImRhdGV0aW1lLWxvY2FsXCI6IHRydWUsXG4gICAgICAgIGVtYWlsOiB0cnVlLFxuICAgICAgICBtb250aDogdHJ1ZSxcbiAgICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgICByYW5nZTogdHJ1ZSxcbiAgICAgICAgc2VhcmNoOiB0cnVlLFxuICAgICAgICB0ZWw6IHRydWUsXG4gICAgICAgIHRleHQ6IHRydWUsXG4gICAgICAgIHRpbWU6IHRydWUsXG4gICAgICAgIHVybDogdHJ1ZSxcbiAgICAgICAgd2VlazogdHJ1ZSxcbiAgICAgICAgdGV4dGFyZWE6IHRydWUsXG4gICAgICAgIHNlbGVjdDogdHJ1ZSxcbiAgICAgICAgcGFzc3dvcmQ6IHRydWUsXG4gICAgICAgIGhpZGRlbjogdHJ1ZVxuICAgIH0gOiBfbWFza0lucHV0T3B0aW9ucyAhPT0gdm9pZCAwID8gX21hc2tJbnB1dE9wdGlvbnMgOiB7XG4gICAgICAgIHBhc3N3b3JkOiB0cnVlXG4gICAgfTtcbiAgICB2YXIgc2xpbURPTU9wdGlvbnMgPSBfc2xpbURPTU9wdGlvbnMgPT09IHRydWUgfHwgX3NsaW1ET01PcHRpb25zID09PSBcImFsbFwiID8ge1xuICAgICAgICBzY3JpcHQ6IHRydWUsXG4gICAgICAgIGNvbW1lbnQ6IHRydWUsXG4gICAgICAgIGhlYWRGYXZpY29uOiB0cnVlLFxuICAgICAgICBoZWFkV2hpdGVzcGFjZTogdHJ1ZSxcbiAgICAgICAgaGVhZE1ldGFTb2NpYWw6IHRydWUsXG4gICAgICAgIGhlYWRNZXRhUm9ib3RzOiB0cnVlLFxuICAgICAgICBoZWFkTWV0YUh0dHBFcXVpdjogdHJ1ZSxcbiAgICAgICAgaGVhZE1ldGFWZXJpZmljYXRpb246IHRydWUsXG4gICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgYXJlIG9mZiBmb3Igc2xpbURPTU9wdGlvbnMgPT09IHRydWUsXG4gICAgICAgIC8vIGFzIHRoZXkgZGVzdHJveSBzb21lIChoaWRkZW4pIGluZm86XG4gICAgICAgIGhlYWRNZXRhQXV0aG9yc2hpcDogX3NsaW1ET01PcHRpb25zID09PSBcImFsbFwiLFxuICAgICAgICBoZWFkTWV0YURlc2NLZXl3b3JkczogX3NsaW1ET01PcHRpb25zID09PSBcImFsbFwiLFxuICAgICAgICBoZWFkVGl0bGVNdXRhdGlvbnM6IF9zbGltRE9NT3B0aW9ucyA9PT0gXCJhbGxcIlxuICAgIH0gOiBfc2xpbURPTU9wdGlvbnMgPyBfc2xpbURPTU9wdGlvbnMgOiB7fTtcbiAgICBwb2x5ZmlsbCQxKCk7XG4gICAgdmFyIGxhc3RGdWxsU25hcHNob3RFdmVudDtcbiAgICB2YXIgaW5jcmVtZW50YWxTbmFwc2hvdENvdW50ID0gMDtcbiAgICB2YXIgZXZlbnRQcm9jZXNzb3IgPSBmdW5jdGlvbihlMikge1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShwbHVnaW5zIHx8IFtdKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIHBsdWdpbjMgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChwbHVnaW4zLmV2ZW50UHJvY2Vzc29yKSB7XG4gICAgICAgICAgICAgICAgZTIgPSBwbHVnaW4zLmV2ZW50UHJvY2Vzc29yKGUyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGFja0ZuICYmIC8vIERpc2FibGUgcGFja2luZyBldmVudHMgd2hpY2ggd2lsbCBiZSBlbWl0dGVkIHRvIHBhcmVudCBmcmFtZXMuXG4gICAgICAgICFwYXNzRW1pdHNUb1BhcmVudCkge1xuICAgICAgICAgICAgZTIgPSBwYWNrRm4oZTIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlMjtcbiAgICB9O1xuICAgIHdyYXBwZWRFbWl0ID0gZnVuY3Rpb24ocjIsIGlzQ2hlY2tvdXQpIHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgdmFyIGUyID0gcjI7XG4gICAgICAgIGUyLnRpbWVzdGFtcCA9IG5vd1RpbWVzdGFtcCgpO1xuICAgICAgICBpZiAoKChfYTIgPSBtdXRhdGlvbkJ1ZmZlcnNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYTIuaXNGcm96ZW4oKSkgJiYgZTIudHlwZSAhPT0gRXZlbnRUeXBlLkZ1bGxTbmFwc2hvdCAmJiAhKGUyLnR5cGUgPT09IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90ICYmIGUyLmRhdGEuc291cmNlID09PSBJbmNyZW1lbnRhbFNvdXJjZS5NdXRhdGlvbikpIHtcbiAgICAgICAgICAgIG11dGF0aW9uQnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGJ1Zikge1xuICAgICAgICAgICAgICAgIHJldHVybiBidWYudW5mcmVlemUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbkVtaXR0aW5nRnJhbWUpIHtcbiAgICAgICAgICAgIGVtaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGVtaXQoZXZlbnRQcm9jZXNzb3IoZTIpLCBpc0NoZWNrb3V0KTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXNzRW1pdHNUb1BhcmVudCkge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJycndlYlwiLFxuICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudFByb2Nlc3NvcihlMiksXG4gICAgICAgICAgICAgICAgb3JpZ2luOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luLFxuICAgICAgICAgICAgICAgIGlzQ2hlY2tvdXQ6IGlzQ2hlY2tvdXRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cucGFyZW50LnBvc3RNZXNzYWdlKG1lc3NhZ2UsIFwiKlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZTIudHlwZSA9PT0gRXZlbnRUeXBlLkZ1bGxTbmFwc2hvdCkge1xuICAgICAgICAgICAgbGFzdEZ1bGxTbmFwc2hvdEV2ZW50ID0gZTI7XG4gICAgICAgICAgICBpbmNyZW1lbnRhbFNuYXBzaG90Q291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGUyLnR5cGUgPT09IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90KSB7XG4gICAgICAgICAgICBpZiAoZTIuZGF0YS5zb3VyY2UgPT09IEluY3JlbWVudGFsU291cmNlLk11dGF0aW9uICYmIGUyLmRhdGEuaXNBdHRhY2hJZnJhbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmNyZW1lbnRhbFNuYXBzaG90Q291bnQrKztcbiAgICAgICAgICAgIHZhciBleGNlZWRDb3VudCA9IGNoZWNrb3V0RXZlcnlOdGggJiYgaW5jcmVtZW50YWxTbmFwc2hvdENvdW50ID49IGNoZWNrb3V0RXZlcnlOdGg7XG4gICAgICAgICAgICB2YXIgZXhjZWVkVGltZSA9IGNoZWNrb3V0RXZlcnlObXMgJiYgZTIudGltZXN0YW1wIC0gbGFzdEZ1bGxTbmFwc2hvdEV2ZW50LnRpbWVzdGFtcCA+IGNoZWNrb3V0RXZlcnlObXM7XG4gICAgICAgICAgICBpZiAoZXhjZWVkQ291bnQgfHwgZXhjZWVkVGltZSkge1xuICAgICAgICAgICAgICAgIHRha2VGdWxsU25hcHNob3QkMSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHdyYXBwZWRNdXRhdGlvbkVtaXQgPSBmdW5jdGlvbihtKSB7XG4gICAgICAgIHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgZGF0YTogX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuTXV0YXRpb25cbiAgICAgICAgICAgIH0sIG0pXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdmFyIHdyYXBwZWRTY3JvbGxFbWl0ID0gZnVuY3Rpb24ocCkge1xuICAgICAgICByZXR1cm4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICBkYXRhOiBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5TY3JvbGxcbiAgICAgICAgICAgIH0sIHApXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdmFyIHdyYXBwZWRDYW52YXNNdXRhdGlvbkVtaXQgPSBmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgIGRhdGE6IF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLkNhbnZhc011dGF0aW9uXG4gICAgICAgICAgICB9LCBwKVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHZhciB3cmFwcGVkQWRvcHRlZFN0eWxlU2hlZXRFbWl0ID0gZnVuY3Rpb24oYTIpIHtcbiAgICAgICAgcmV0dXJuIHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgZGF0YTogX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuQWRvcHRlZFN0eWxlU2hlZXRcbiAgICAgICAgICAgIH0sIGEyKVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHZhciBzdHlsZXNoZWV0TWFuYWdlciA9IG5ldyBTdHlsZXNoZWV0TWFuYWdlcih7XG4gICAgICAgIG11dGF0aW9uQ2I6IHdyYXBwZWRNdXRhdGlvbkVtaXQsXG4gICAgICAgIGFkb3B0ZWRTdHlsZVNoZWV0Q2I6IHdyYXBwZWRBZG9wdGVkU3R5bGVTaGVldEVtaXRcbiAgICB9KTtcbiAgICB2YXIgaWZyYW1lTWFuYWdlciA9IG5ldyBJZnJhbWVNYW5hZ2VyKHtcbiAgICAgICAgbWlycm9yOiBtaXJyb3IsXG4gICAgICAgIG11dGF0aW9uQ2I6IHdyYXBwZWRNdXRhdGlvbkVtaXQsXG4gICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyOiBzdHlsZXNoZWV0TWFuYWdlcixcbiAgICAgICAgcmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzOiByZWNvcmRDcm9zc09yaWdpbklmcmFtZXMsXG4gICAgICAgIHdyYXBwZWRFbWl0OiB3cmFwcGVkRW1pdFxuICAgIH0pO1xuICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHBsdWdpbnMgfHwgW10pLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgIHZhciBwbHVnaW4zID0gX3N0ZXAudmFsdWU7XG4gICAgICAgIGlmIChwbHVnaW4zLmdldE1pcnJvcikgcGx1Z2luMy5nZXRNaXJyb3Ioe1xuICAgICAgICAgICAgbm9kZU1pcnJvcjogbWlycm9yLFxuICAgICAgICAgICAgY3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3I6IGlmcmFtZU1hbmFnZXIuY3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3IsXG4gICAgICAgICAgICBjcm9zc09yaWdpbklmcmFtZVN0eWxlTWlycm9yOiBpZnJhbWVNYW5hZ2VyLmNyb3NzT3JpZ2luSWZyYW1lU3R5bGVNaXJyb3JcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBwcm9jZXNzZWROb2RlTWFuYWdlciA9IG5ldyBQcm9jZXNzZWROb2RlTWFuYWdlcigpO1xuICAgIGNhbnZhc01hbmFnZXIgPSBuZXcgQ2FudmFzTWFuYWdlcih7XG4gICAgICAgIHJlY29yZENhbnZhczogcmVjb3JkQ2FudmFzLFxuICAgICAgICBtdXRhdGlvbkNiOiB3cmFwcGVkQ2FudmFzTXV0YXRpb25FbWl0LFxuICAgICAgICB3aW46IHdpbmRvdyxcbiAgICAgICAgYmxvY2tDbGFzczogYmxvY2tDbGFzcyxcbiAgICAgICAgYmxvY2tTZWxlY3RvcjogYmxvY2tTZWxlY3RvcixcbiAgICAgICAgbWlycm9yOiBtaXJyb3IsXG4gICAgICAgIHNhbXBsaW5nOiBzYW1wbGluZy5jYW52YXMsXG4gICAgICAgIGRhdGFVUkxPcHRpb25zOiBkYXRhVVJMT3B0aW9uc1xuICAgIH0pO1xuICAgIHZhciBzaGFkb3dEb21NYW5hZ2VyID0gbmV3IFNoYWRvd0RvbU1hbmFnZXIoe1xuICAgICAgICBtdXRhdGlvbkNiOiB3cmFwcGVkTXV0YXRpb25FbWl0LFxuICAgICAgICBzY3JvbGxDYjogd3JhcHBlZFNjcm9sbEVtaXQsXG4gICAgICAgIGJ5cGFzc09wdGlvbnM6IHtcbiAgICAgICAgICAgIGJsb2NrQ2xhc3M6IGJsb2NrQ2xhc3MsXG4gICAgICAgICAgICBibG9ja1NlbGVjdG9yOiBibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgbWFza1RleHRDbGFzczogbWFza1RleHRDbGFzcyxcbiAgICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3I6IG1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0OiBpbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgICAgICAgbWFza0lucHV0T3B0aW9uczogbWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zOiBkYXRhVVJMT3B0aW9ucyxcbiAgICAgICAgICAgIG1hc2tUZXh0Rm46IG1hc2tUZXh0Rm4sXG4gICAgICAgICAgICBtYXNrSW5wdXRGbjogbWFza0lucHV0Rm4sXG4gICAgICAgICAgICByZWNvcmRDYW52YXM6IHJlY29yZENhbnZhcyxcbiAgICAgICAgICAgIGlubGluZUltYWdlczogaW5saW5lSW1hZ2VzLFxuICAgICAgICAgICAgc2FtcGxpbmc6IHNhbXBsaW5nLFxuICAgICAgICAgICAgc2xpbURPTU9wdGlvbnM6IHNsaW1ET01PcHRpb25zLFxuICAgICAgICAgICAgaWZyYW1lTWFuYWdlcjogaWZyYW1lTWFuYWdlcixcbiAgICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyOiBzdHlsZXNoZWV0TWFuYWdlcixcbiAgICAgICAgICAgIGNhbnZhc01hbmFnZXI6IGNhbnZhc01hbmFnZXIsXG4gICAgICAgICAgICBrZWVwSWZyYW1lU3JjRm46IGtlZXBJZnJhbWVTcmNGbixcbiAgICAgICAgICAgIHByb2Nlc3NlZE5vZGVNYW5hZ2VyOiBwcm9jZXNzZWROb2RlTWFuYWdlclxuICAgICAgICB9LFxuICAgICAgICBtaXJyb3I6IG1pcnJvclxuICAgIH0pO1xuICAgIHRha2VGdWxsU25hcHNob3QkMSA9IGZ1bmN0aW9uKGlzQ2hlY2tvdXQpIHtcbiAgICAgICAgaWYgKGlzQ2hlY2tvdXQgPT09IHZvaWQgMCkgaXNDaGVja291dCA9IGZhbHNlO1xuICAgICAgICBpZiAoIXJlY29yZERPTSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5NZXRhLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGhyZWY6IHdpbmRvdy5sb2NhdGlvbi5ocmVmLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBnZXRXaW5kb3dXaWR0aCgpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogZ2V0V2luZG93SGVpZ2h0KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaXNDaGVja291dCk7XG4gICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnJlc2V0KCk7XG4gICAgICAgIHNoYWRvd0RvbU1hbmFnZXIuaW5pdCgpO1xuICAgICAgICBtdXRhdGlvbkJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbihidWYpIHtcbiAgICAgICAgICAgIHJldHVybiBidWYubG9jaygpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG5vZGUyID0gc25hcHNob3QoZG9jdW1lbnQsIHtcbiAgICAgICAgICAgIG1pcnJvcjogbWlycm9yLFxuICAgICAgICAgICAgYmxvY2tDbGFzczogYmxvY2tDbGFzcyxcbiAgICAgICAgICAgIGJsb2NrU2VsZWN0b3I6IGJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgICBtYXNrVGV4dENsYXNzOiBtYXNrVGV4dENsYXNzLFxuICAgICAgICAgICAgbWFza1RleHRTZWxlY3RvcjogbWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQ6IGlubGluZVN0eWxlc2hlZXQsXG4gICAgICAgICAgICBtYXNrQWxsSW5wdXRzOiBtYXNrSW5wdXRPcHRpb25zLFxuICAgICAgICAgICAgbWFza1RleHRGbjogbWFza1RleHRGbixcbiAgICAgICAgICAgIG1hc2tJbnB1dEZuOiBtYXNrSW5wdXRGbixcbiAgICAgICAgICAgIHNsaW1ET006IHNsaW1ET01PcHRpb25zLFxuICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnM6IGRhdGFVUkxPcHRpb25zLFxuICAgICAgICAgICAgcmVjb3JkQ2FudmFzOiByZWNvcmRDYW52YXMsXG4gICAgICAgICAgICBpbmxpbmVJbWFnZXM6IGlubGluZUltYWdlcyxcbiAgICAgICAgICAgIG9uU2VyaWFsaXplOiBmdW5jdGlvbihuMikge1xuICAgICAgICAgICAgICAgIGlmIChpc1NlcmlhbGl6ZWRJZnJhbWUobjIsIG1pcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWZyYW1lTWFuYWdlci5hZGRJZnJhbWUobjIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNTZXJpYWxpemVkU3R5bGVzaGVldChuMiwgbWlycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlci50cmFja0xpbmtFbGVtZW50KG4yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhc1NoYWRvd1Jvb3QobjIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNoYWRvd0RvbU1hbmFnZXIuYWRkU2hhZG93Um9vdChpbmRleC5zaGFkb3dSb290KG4yKSwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbklmcmFtZUxvYWQ6IGZ1bmN0aW9uKGlmcmFtZSwgY2hpbGRTbikge1xuICAgICAgICAgICAgICAgIGlmcmFtZU1hbmFnZXIuYXR0YWNoSWZyYW1lKGlmcmFtZSwgY2hpbGRTbik7XG4gICAgICAgICAgICAgICAgc2hhZG93RG9tTWFuYWdlci5vYnNlcnZlQXR0YWNoU2hhZG93KGlmcmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25TdHlsZXNoZWV0TG9hZDogZnVuY3Rpb24obGlua0VsLCBjaGlsZFNuKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVzaGVldE1hbmFnZXIuYXR0YWNoTGlua0VsZW1lbnQobGlua0VsLCBjaGlsZFNuKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBrZWVwSWZyYW1lU3JjRm46IGtlZXBJZnJhbWVTcmNGblxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFub2RlMikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBzbmFwc2hvdCB0aGUgZG9jdW1lbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkZ1bGxTbmFwc2hvdCxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBub2RlOiBub2RlMixcbiAgICAgICAgICAgICAgICBpbml0aWFsT2Zmc2V0OiBnZXRXaW5kb3dTY3JvbGwod2luZG93KVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBpc0NoZWNrb3V0KTtcbiAgICAgICAgbXV0YXRpb25CdWZmZXJzLmZvckVhY2goZnVuY3Rpb24oYnVmKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmLnVubG9jaygpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRvY3VtZW50LmFkb3B0ZWRTdHlsZVNoZWV0cyAmJiBkb2N1bWVudC5hZG9wdGVkU3R5bGVTaGVldHMubGVuZ3RoID4gMCkgc3R5bGVzaGVldE1hbmFnZXIuYWRvcHRTdHlsZVNoZWV0cyhkb2N1bWVudC5hZG9wdGVkU3R5bGVTaGVldHMsIG1pcnJvci5nZXRJZChkb2N1bWVudCkpO1xuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gW107XG4gICAgICAgIHZhciBvYnNlcnZlID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgICAgICB2YXIgX2EyO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcihpbml0T2JzZXJ2ZXJzKSh7XG4gICAgICAgICAgICAgICAgbXV0YXRpb25DYjogd3JhcHBlZE11dGF0aW9uRW1pdCxcbiAgICAgICAgICAgICAgICBtb3VzZW1vdmVDYjogZnVuY3Rpb24ocG9zaXRpb25zLCBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uczogcG9zaXRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbW91c2VJbnRlcmFjdGlvbkNiOiBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLk1vdXNlSW50ZXJhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGQpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2Nyb2xsQ2I6IHdyYXBwZWRTY3JvbGxFbWl0LFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0UmVzaXplQ2I6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuVmlld3BvcnRSZXNpemVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGQpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5wdXRDYjogZnVuY3Rpb24odjIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuSW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHYyKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1lZGlhSW50ZXJhY3Rpb25DYjogZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5NZWRpYUludGVyYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBwKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2I6IGZ1bmN0aW9uKHIyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLlN0eWxlU2hlZXRSdWxlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCByMilcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHlsZURlY2xhcmF0aW9uQ2I6IGZ1bmN0aW9uKHIyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLlN0eWxlRGVjbGFyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHIyKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNhbnZhc011dGF0aW9uQ2I6IHdyYXBwZWRDYW52YXNNdXRhdGlvbkVtaXQsXG4gICAgICAgICAgICAgICAgZm9udENiOiBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLkZvbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHApXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uQ2I6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5TZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHApXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY3VzdG9tRWxlbWVudENiOiBmdW5jdGlvbihjMikge1xuICAgICAgICAgICAgICAgICAgICB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLkN1c3RvbUVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGMyKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJsb2NrQ2xhc3M6IGJsb2NrQ2xhc3MsXG4gICAgICAgICAgICAgICAgaWdub3JlQ2xhc3M6IGlnbm9yZUNsYXNzLFxuICAgICAgICAgICAgICAgIGlnbm9yZVNlbGVjdG9yOiBpZ25vcmVTZWxlY3RvcixcbiAgICAgICAgICAgICAgICBtYXNrVGV4dENsYXNzOiBtYXNrVGV4dENsYXNzLFxuICAgICAgICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3I6IG1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgbWFza0lucHV0T3B0aW9uczogbWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0OiBpbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgICAgICAgICAgIHNhbXBsaW5nOiBzYW1wbGluZyxcbiAgICAgICAgICAgICAgICByZWNvcmRET006IHJlY29yZERPTSxcbiAgICAgICAgICAgICAgICByZWNvcmRDYW52YXM6IHJlY29yZENhbnZhcyxcbiAgICAgICAgICAgICAgICBpbmxpbmVJbWFnZXM6IGlubGluZUltYWdlcyxcbiAgICAgICAgICAgICAgICB1c2VyVHJpZ2dlcmVkT25JbnB1dDogdXNlclRyaWdnZXJlZE9uSW5wdXQsXG4gICAgICAgICAgICAgICAgY29sbGVjdEZvbnRzOiBjb2xsZWN0Rm9udHMsXG4gICAgICAgICAgICAgICAgZG9jOiBkb2MsXG4gICAgICAgICAgICAgICAgbWFza0lucHV0Rm46IG1hc2tJbnB1dEZuLFxuICAgICAgICAgICAgICAgIG1hc2tUZXh0Rm46IG1hc2tUZXh0Rm4sXG4gICAgICAgICAgICAgICAga2VlcElmcmFtZVNyY0ZuOiBrZWVwSWZyYW1lU3JjRm4sXG4gICAgICAgICAgICAgICAgYmxvY2tTZWxlY3RvcjogYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICAgICAgICBzbGltRE9NT3B0aW9uczogc2xpbURPTU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnM6IGRhdGFVUkxPcHRpb25zLFxuICAgICAgICAgICAgICAgIG1pcnJvcjogbWlycm9yLFxuICAgICAgICAgICAgICAgIGlmcmFtZU1hbmFnZXI6IGlmcmFtZU1hbmFnZXIsXG4gICAgICAgICAgICAgICAgc3R5bGVzaGVldE1hbmFnZXI6IHN0eWxlc2hlZXRNYW5hZ2VyLFxuICAgICAgICAgICAgICAgIHNoYWRvd0RvbU1hbmFnZXI6IHNoYWRvd0RvbU1hbmFnZXIsXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkTm9kZU1hbmFnZXI6IHByb2Nlc3NlZE5vZGVNYW5hZ2VyLFxuICAgICAgICAgICAgICAgIGNhbnZhc01hbmFnZXI6IGNhbnZhc01hbmFnZXIsXG4gICAgICAgICAgICAgICAgaWdub3JlQ1NTQXR0cmlidXRlczogaWdub3JlQ1NTQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBwbHVnaW5zOiAoKF9hMiA9IHBsdWdpbnMgPT0gbnVsbCA/IHZvaWQgMCA6IHBsdWdpbnMuZmlsdGVyKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHAub2JzZXJ2ZXI7XG4gICAgICAgICAgICAgICAgfSkpID09IG51bGwgPyB2b2lkIDAgOiBfYTIubWFwKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyOiBwLm9ic2VydmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogcC5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuUGx1Z2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbHVnaW46IHAubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pKSB8fCBbXVxuICAgICAgICAgICAgfSwgaG9va3MpO1xuICAgICAgICB9O1xuICAgICAgICBpZnJhbWVNYW5hZ2VyLmFkZExvYWRMaXN0ZW5lcihmdW5jdGlvbihpZnJhbWVFbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVycy5wdXNoKG9ic2VydmUoaWZyYW1lRWwuY29udGVudERvY3VtZW50KSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGFrZUZ1bGxTbmFwc2hvdCQxKCk7XG4gICAgICAgICAgICBoYW5kbGVycy5wdXNoKG9ic2VydmUoZG9jdW1lbnQpKTtcbiAgICAgICAgICAgIHJlY29yZGluZyA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImludGVyYWN0aXZlXCIgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgICAgICBpbml0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVycy5wdXNoKG9uKFwiRE9NQ29udGVudExvYWRlZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5Eb21Db250ZW50TG9hZGVkLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7fVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZWNvcmRBZnRlciA9PT0gXCJET01Db250ZW50TG9hZGVkXCIpIGluaXQoKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGhhbmRsZXJzLnB1c2gob24oXCJsb2FkXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkxvYWQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHt9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZEFmdGVyID09PSBcImxvYWRcIikgaW5pdCgpO1xuICAgICAgICAgICAgfSwgd2luZG93KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSBTdHJpbmcoZXJyb3IpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbXNnLmluY2x1ZGVzKFwiY3Jvc3Mtb3JpZ2luXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm9jZXNzZWROb2RlTWFuYWdlci5kZXN0cm95KCk7XG4gICAgICAgICAgICByZWNvcmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHVucmVnaXN0ZXJFcnJvckhhbmRsZXIoKTtcbiAgICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IpO1xuICAgIH1cbn1cbnJlY29yZC5hZGRDdXN0b21FdmVudCA9IGZ1bmN0aW9uKHRhZywgcGF5bG9hZCkge1xuICAgIGlmICghcmVjb3JkaW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInBsZWFzZSBhZGQgY3VzdG9tIGV2ZW50IGFmdGVyIHN0YXJ0IHJlY29yZGluZ1wiKTtcbiAgICB9XG4gICAgd3JhcHBlZEVtaXQoe1xuICAgICAgICB0eXBlOiBFdmVudFR5cGUuQ3VzdG9tLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbnJlY29yZC5mcmVlemVQYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgbXV0YXRpb25CdWZmZXJzLmZvckVhY2goZnVuY3Rpb24oYnVmKSB7XG4gICAgICAgIHJldHVybiBidWYuZnJlZXplKCk7XG4gICAgfSk7XG59O1xucmVjb3JkLnRha2VGdWxsU25hcHNob3QgPSBmdW5jdGlvbihpc0NoZWNrb3V0KSB7XG4gICAgaWYgKCFyZWNvcmRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGxlYXNlIHRha2UgZnVsbCBzbmFwc2hvdCBhZnRlciBzdGFydCByZWNvcmRpbmdcIik7XG4gICAgfVxuICAgIHRha2VGdWxsU25hcHNob3QkMShpc0NoZWNrb3V0KTtcbn07XG5yZWNvcmQubWlycm9yID0gbWlycm9yO1xudmFyIG47XG4hZnVuY3Rpb24odDIpIHtcbiAgICB0Mlt0Mi5Ob3RTdGFydGVkID0gMF0gPSBcIk5vdFN0YXJ0ZWRcIiwgdDJbdDIuUnVubmluZyA9IDFdID0gXCJSdW5uaW5nXCIsIHQyW3QyLlN0b3BwZWQgPSAyXSA9IFwiU3RvcHBlZFwiO1xufShuIHx8IChuID0ge30pKTtcbnJlY29yZC5hZGRDdXN0b21FdmVudDtcbnJlY29yZC5mcmVlemVQYWdlO1xucmVjb3JkLnRha2VGdWxsU25hcHNob3Q7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbn07XG52YXIgX19wdWJsaWNGaWVsZCA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBfX2RlZk5vcm1hbFByb3Aob2JqLCAodHlwZW9mIGtleSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihrZXkpKSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbn07XG5mdW5jdGlvbiBwYXRjaChzb3VyY2UsIG5hbWUsIHJlcGxhY2VtZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKCEobmFtZSBpbiBzb3VyY2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7fTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3JpZ2luYWwgPSBzb3VyY2VbbmFtZV07XG4gICAgICAgIHZhciB3cmFwcGVkID0gcmVwbGFjZW1lbnQob3JpZ2luYWwpO1xuICAgICAgICBpZiAodHlwZW9mIHdyYXBwZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgd3JhcHBlZC5wcm90b3R5cGUgPSB3cmFwcGVkLnByb3RvdHlwZSB8fCB7fTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHdyYXBwZWQsIHtcbiAgICAgICAgICAgICAgICBfX3Jyd2ViX29yaWdpbmFsX186IHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvcmlnaW5hbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZVtuYW1lXSA9IHdyYXBwZWQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNvdXJjZVtuYW1lXSA9IG9yaWdpbmFsO1xuICAgICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge307XG4gICAgfVxufVxudmFyIFN0YWNrRnJhbWUgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFN0YWNrRnJhbWUob2JqKSB7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJmaWxlTmFtZVwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImZ1bmN0aW9uTmFtZVwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImxpbmVOdW1iZXJcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjb2x1bW5OdW1iZXJcIik7XG4gICAgICAgIHRoaXMuZmlsZU5hbWUgPSBvYmouZmlsZU5hbWUgfHwgXCJcIjtcbiAgICAgICAgdGhpcy5mdW5jdGlvbk5hbWUgPSBvYmouZnVuY3Rpb25OYW1lIHx8IFwiXCI7XG4gICAgICAgIHRoaXMubGluZU51bWJlciA9IG9iai5saW5lTnVtYmVyO1xuICAgICAgICB0aGlzLmNvbHVtbk51bWJlciA9IG9iai5jb2x1bW5OdW1iZXI7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBTdGFja0ZyYW1lLnByb3RvdHlwZTtcbiAgICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgdmFyIGxpbmVOdW1iZXIgPSB0aGlzLmxpbmVOdW1iZXIgfHwgXCJcIjtcbiAgICAgICAgdmFyIGNvbHVtbk51bWJlciA9IHRoaXMuY29sdW1uTnVtYmVyIHx8IFwiXCI7XG4gICAgICAgIGlmICh0aGlzLmZ1bmN0aW9uTmFtZSkgcmV0dXJuIHRoaXMuZnVuY3Rpb25OYW1lICsgXCIgKFwiICsgdGhpcy5maWxlTmFtZSArIFwiOlwiICsgbGluZU51bWJlciArIFwiOlwiICsgY29sdW1uTnVtYmVyICsgXCIpXCI7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbGVOYW1lICsgXCI6XCIgKyBsaW5lTnVtYmVyICsgXCI6XCIgKyBjb2x1bW5OdW1iZXI7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhY2tGcmFtZTtcbn0oKTtcbnZhciBGSVJFRk9YX1NBRkFSSV9TVEFDS19SRUdFWFAgPSAvKF58QClcXFMrOlxcZCsvO1xudmFyIENIUk9NRV9JRV9TVEFDS19SRUdFWFAgPSAvXlxccyphdCAuKihcXFMrOlxcZCt8XFwobmF0aXZlXFwpKS9tO1xudmFyIFNBRkFSSV9OQVRJVkVfQ09ERV9SRUdFWFAgPSAvXihldmFsQCk/KFxcW25hdGl2ZSBjb2RlXSk/JC87XG52YXIgRXJyb3JTdGFja1BhcnNlciA9IHtcbiAgICAvKipcbiAgICogR2l2ZW4gYW4gRXJyb3Igb2JqZWN0LCBleHRyYWN0IHRoZSBtb3N0IGluZm9ybWF0aW9uIGZyb20gaXQuXG4gICAqLyBwYXJzZTogZnVuY3Rpb24gcGFyc2UoZXJyb3IpIHtcbiAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICgvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdHlwZW9mIGVycm9yLnN0YWNrdHJhY2UgIT09IFwidW5kZWZpbmVkXCIgfHwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHR5cGVvZiBlcnJvcltcIm9wZXJhI3NvdXJjZWxvY1wiXSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcGVyYShlcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3Iuc3RhY2sgJiYgZXJyb3Iuc3RhY2subWF0Y2goQ0hST01FX0lFX1NUQUNLX1JFR0VYUCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVjhPcklFKGVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvci5zdGFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGRk9yU2FmYXJpKGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltjb25zb2xlLXJlY29yZC1wbHVnaW5dOiBGYWlsZWQgdG8gcGFyc2UgZXJyb3Igb2JqZWN0OlwiLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8vIFNlcGFyYXRlIGxpbmUgYW5kIGNvbHVtbiBudW1iZXJzIGZyb20gYSBzdHJpbmcgb2YgdGhlIGZvcm06IChVUkk6TGluZTpDb2x1bW4pXG4gICAgZXh0cmFjdExvY2F0aW9uOiBmdW5jdGlvbiBleHRyYWN0TG9jYXRpb24odXJsTGlrZSkge1xuICAgICAgICBpZiAodXJsTGlrZS5pbmRleE9mKFwiOlwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgdXJsTGlrZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVnRXhwID0gLyguKz8pKD86OihcXGQrKSk/KD86OihcXGQrKSk/JC87XG4gICAgICAgIHZhciBwYXJ0cyA9IHJlZ0V4cC5leGVjKHVybExpa2UucmVwbGFjZSgvWygpXS9nLCBcIlwiKSk7XG4gICAgICAgIGlmICghcGFydHMpIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBwYXJzZSBnaXZlbiB1cmw6IFwiICsgdXJsTGlrZSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBwYXJ0c1sxXSxcbiAgICAgICAgICAgIHBhcnRzWzJdIHx8IHZvaWQgMCxcbiAgICAgICAgICAgIHBhcnRzWzNdIHx8IHZvaWQgMFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgcGFyc2VWOE9ySUU6IGZ1bmN0aW9uIHBhcnNlVjhPcklFKGVycm9yKSB7XG4gICAgICAgIHZhciBmaWx0ZXJlZCA9IGVycm9yLnN0YWNrLnNwbGl0KFwiXFxuXCIpLmZpbHRlcihmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gISFsaW5lLm1hdGNoKENIUk9NRV9JRV9TVEFDS19SRUdFWFApO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKFwiKGV2YWwgXCIpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKC9ldmFsIGNvZGUvZywgXCJldmFsXCIpLnJlcGxhY2UoLyhcXChldmFsIGF0IFteKCldKil8KFxcKSwuKiQpL2csIFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNhbml0aXplZExpbmUgPSBsaW5lLnJlcGxhY2UoL15cXHMrLywgXCJcIikucmVwbGFjZSgvXFwoZXZhbCBjb2RlL2csIFwiKFwiKTtcbiAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IHNhbml0aXplZExpbmUubWF0Y2goLyAoXFwoKC4rKTooXFxkKyk6KFxcZCspXFwpJCkvKTtcbiAgICAgICAgICAgIHNhbml0aXplZExpbmUgPSBsb2NhdGlvbiA/IHNhbml0aXplZExpbmUucmVwbGFjZShsb2NhdGlvblswXSwgXCJcIikgOiBzYW5pdGl6ZWRMaW5lO1xuICAgICAgICAgICAgdmFyIHRva2VucyA9IHNhbml0aXplZExpbmUuc3BsaXQoL1xccysvKS5zbGljZSgxKTtcbiAgICAgICAgICAgIHZhciBsb2NhdGlvblBhcnRzID0gdGhpcy5leHRyYWN0TG9jYXRpb24obG9jYXRpb24gPyBsb2NhdGlvblsxXSA6IHRva2Vucy5wb3AoKSk7XG4gICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gdG9rZW5zLmpvaW4oXCIgXCIpIHx8IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBmaWxlTmFtZSA9IFtcbiAgICAgICAgICAgICAgICBcImV2YWxcIixcbiAgICAgICAgICAgICAgICBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgIF0uaW5kZXhPZihsb2NhdGlvblBhcnRzWzBdKSA+IC0xID8gdm9pZCAwIDogbG9jYXRpb25QYXJ0c1swXTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgZmlsZU5hbWU6IGZpbGVOYW1lLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxvY2F0aW9uUGFydHNbMV0sXG4gICAgICAgICAgICAgICAgY29sdW1uTnVtYmVyOiBsb2NhdGlvblBhcnRzWzJdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcbiAgICBwYXJzZUZGT3JTYWZhcmk6IGZ1bmN0aW9uIHBhcnNlRkZPclNhZmFyaShlcnJvcikge1xuICAgICAgICB2YXIgZmlsdGVyZWQgPSBlcnJvci5zdGFjay5zcGxpdChcIlxcblwiKS5maWx0ZXIoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICFsaW5lLm1hdGNoKFNBRkFSSV9OQVRJVkVfQ09ERV9SRUdFWFApO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKFwiID4gZXZhbFwiKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvIGxpbmUgKFxcZCspKD86ID4gZXZhbCBsaW5lIFxcZCspKiA+IGV2YWw6XFxkKzpcXGQrL2csIFwiOiQxXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZihcIkBcIikgPT09IC0xICYmIGxpbmUuaW5kZXhPZihcIjpcIikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBsaW5lXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWVSZWdleCA9IC8oKC4qXCIuK1wiW15AXSopP1teQF0qKSg/OkApLztcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IGxpbmUubWF0Y2goZnVuY3Rpb25OYW1lUmVnZXgpO1xuICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSBtYXRjaGVzICYmIG1hdGNoZXNbMV0gPyBtYXRjaGVzWzFdIDogdm9pZCAwO1xuICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvblBhcnRzID0gdGhpcy5leHRyYWN0TG9jYXRpb24obGluZS5yZXBsYWNlKGZ1bmN0aW9uTmFtZVJlZ2V4LCBcIlwiKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBsb2NhdGlvblBhcnRzWzBdLFxuICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsb2NhdGlvblBhcnRzWzFdLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5OdW1iZXI6IGxvY2F0aW9uUGFydHNbMl1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcbiAgICBwYXJzZU9wZXJhOiBmdW5jdGlvbiBwYXJzZU9wZXJhKGUpIHtcbiAgICAgICAgaWYgKCFlLnN0YWNrdHJhY2UgfHwgZS5tZXNzYWdlLmluZGV4T2YoXCJcXG5cIikgPiAtMSAmJiBlLm1lc3NhZ2Uuc3BsaXQoXCJcXG5cIikubGVuZ3RoID4gZS5zdGFja3RyYWNlLnNwbGl0KFwiXFxuXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcGVyYTkoZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWUuc3RhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmExMChlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmExMShlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcGFyc2VPcGVyYTk6IGZ1bmN0aW9uIHBhcnNlT3BlcmE5KGUpIHtcbiAgICAgICAgdmFyIGxpbmVSRSA9IC9MaW5lIChcXGQrKS4qc2NyaXB0ICg/OmluICk/KFxcUyspL2k7XG4gICAgICAgIHZhciBsaW5lcyA9IGUubWVzc2FnZS5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IodmFyIGkgPSAyLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMil7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lUkUuZXhlYyhsaW5lc1tpXSk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBtYXRjaFsyXSxcbiAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogcGFyc2VGbG9hdChtYXRjaFsxXSlcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIHBhcnNlT3BlcmExMDogZnVuY3Rpb24gcGFyc2VPcGVyYTEwKGUpIHtcbiAgICAgICAgdmFyIGxpbmVSRSA9IC9MaW5lIChcXGQrKS4qc2NyaXB0ICg/OmluICk/KFxcUyspKD86OiBJbiBmdW5jdGlvbiAoXFxTKykpPyQvaTtcbiAgICAgICAgdmFyIGxpbmVzID0gZS5zdGFja3RyYWNlLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKXtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IGxpbmVSRS5leGVjKGxpbmVzW2ldKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBtYXRjaFszXSB8fCB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBtYXRjaFsyXSxcbiAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogcGFyc2VGbG9hdChtYXRjaFsxXSlcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIC8vIE9wZXJhIDEwLjY1KyBFcnJvci5zdGFjayB2ZXJ5IHNpbWlsYXIgdG8gRkYvU2FmYXJpXG4gICAgcGFyc2VPcGVyYTExOiBmdW5jdGlvbiBwYXJzZU9wZXJhMTEoZXJyb3IpIHtcbiAgICAgICAgdmFyIGZpbHRlcmVkID0gZXJyb3Iuc3RhY2suc3BsaXQoXCJcXG5cIikuZmlsdGVyKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAhIWxpbmUubWF0Y2goRklSRUZPWF9TQUZBUklfU1RBQ0tfUkVHRVhQKSAmJiAhbGluZS5tYXRjaCgvXkVycm9yIGNyZWF0ZWQgYXQvKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHJldHVybiBmaWx0ZXJlZC5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgdmFyIHRva2VucyA9IGxpbmUuc3BsaXQoXCJAXCIpO1xuICAgICAgICAgICAgdmFyIGxvY2F0aW9uUGFydHMgPSB0aGlzLmV4dHJhY3RMb2NhdGlvbih0b2tlbnMucG9wKCkpO1xuICAgICAgICAgICAgdmFyIGZ1bmN0aW9uQ2FsbCA9IHRva2Vucy5zaGlmdCgpIHx8IFwiXCI7XG4gICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gZnVuY3Rpb25DYWxsLnJlcGxhY2UoLzxhbm9ueW1vdXMgZnVuY3Rpb24oOiAoXFx3KykpPz4vLCBcIiQyXCIpLnJlcGxhY2UoL1xcKFteKV0qXFwpL2csIFwiXCIpIHx8IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgZmlsZU5hbWU6IGxvY2F0aW9uUGFydHNbMF0sXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbG9jYXRpb25QYXJ0c1sxXSxcbiAgICAgICAgICAgICAgICBjb2x1bW5OdW1iZXI6IGxvY2F0aW9uUGFydHNbMl1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gcGF0aFRvU2VsZWN0b3Iobm9kZSkge1xuICAgIGlmICghbm9kZSB8fCAhbm9kZS5vdXRlckhUTUwpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHZhciBwYXRoID0gXCJcIjtcbiAgICB3aGlsZShub2RlLnBhcmVudEVsZW1lbnQpe1xuICAgICAgICB2YXIgbmFtZSA9IG5vZGUubG9jYWxOYW1lO1xuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIHZhciBkb21TaWJsaW5ncyA9IFtdO1xuICAgICAgICBpZiAocGFyZW50LmNoaWxkcmVuICYmIHBhcmVudC5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcGFyZW50LmNoaWxkcmVuLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICB2YXIgc2libGluZyA9IHBhcmVudC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoc2libGluZy5sb2NhbE5hbWUgJiYgc2libGluZy5sb2NhbE5hbWUudG9Mb3dlckNhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpYmxpbmcubG9jYWxOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbVNpYmxpbmdzLnB1c2goc2libGluZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvbVNpYmxpbmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIG5hbWUgKz0gXCI6ZXEoXCIgKyBkb21TaWJsaW5ncy5pbmRleE9mKG5vZGUpICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICAgICAgcGF0aCA9IG5hbWUgKyAocGF0aCA/IFwiPlwiICsgcGF0aCA6IFwiXCIpO1xuICAgICAgICBub2RlID0gcGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbn1cbmZ1bmN0aW9uIGlzT2JqVG9vRGVlcChvYmosIGxpbWl0KSB7XG4gICAgaWYgKGxpbWl0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uoa2V5cyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgdmFyIGtleSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICBpZiAoaXNPYmplY3Qob2JqW2tleV0pICYmIGlzT2JqVG9vRGVlcChvYmpba2V5XSwgbGltaXQgLSAxKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5KG9iaiwgc3RyaW5naWZ5T3B0aW9ucykge1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBudW1PZktleXNMaW1pdDogNTAsXG4gICAgICAgIGRlcHRoT2ZMaW1pdDogNFxuICAgIH07XG4gICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCBzdHJpbmdpZnlPcHRpb25zKTtcbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciB0aGlzUG9zID0gc3RhY2suaW5kZXhPZih0aGlzKTtcbiAgICAgICAgICAgIH50aGlzUG9zID8gc3RhY2suc3BsaWNlKHRoaXNQb3MgKyAxKSA6IHN0YWNrLnB1c2godGhpcyk7XG4gICAgICAgICAgICB+dGhpc1BvcyA/IGtleXMuc3BsaWNlKHRoaXNQb3MsIEluZmluaXR5LCBrZXkpIDoga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICBpZiAofnN0YWNrLmluZGV4T2YodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YWNrWzBdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiW0NpcmN1bGFyIH5dXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBcIltDaXJjdWxhciB+LlwiICsga2V5cy5zbGljZSgwLCBzdGFjay5pbmRleE9mKHZhbHVlKSkuam9pbihcIi5cIikgKyBcIl1cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHJldHVybiBcInVuZGVmaW5lZFwiO1xuICAgICAgICBpZiAoc2hvdWxkSWdub3JlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZih2YWx1ZSkpID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKSArIFwiblwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfaW5zdGFuY2VvZih2YWx1ZSwgRXZlbnQpKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRSZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGZvcih2YXIgZXZlbnRLZXkgaW4gdmFsdWUpe1xuICAgICAgICAgICAgICAgIHZhciBldmVudFZhbHVlID0gdmFsdWVbZXZlbnRLZXldO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50UmVzdWx0W2V2ZW50S2V5XSA9IHBhdGhUb1NlbGVjdG9yKGV2ZW50VmFsdWUubGVuZ3RoID8gZXZlbnRWYWx1ZVswXSA6IG51bGwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50UmVzdWx0W2V2ZW50S2V5XSA9IGV2ZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50UmVzdWx0O1xuICAgICAgICB9IGVsc2UgaWYgKF9pbnN0YW5jZW9mKHZhbHVlLCBOb2RlKSkge1xuICAgICAgICAgICAgaWYgKF9pbnN0YW5jZW9mKHZhbHVlLCBIVE1MRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPyB2YWx1ZS5vdXRlckhUTUwgOiBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm5vZGVOYW1lO1xuICAgICAgICB9IGVsc2UgaWYgKF9pbnN0YW5jZW9mKHZhbHVlLCBFcnJvcikpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zdGFjayA/IHZhbHVlLnN0YWNrICsgXCJcXG5FbmQgb2Ygc3RhY2sgZm9yIEVycm9yIG9iamVjdFwiIDogdmFsdWUubmFtZSArIFwiOiBcIiArIHZhbHVlLm1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHNob3VsZElnbm9yZShfb2JqKSB7XG4gICAgICAgIGlmIChpc09iamVjdChfb2JqKSAmJiBPYmplY3Qua2V5cyhfb2JqKS5sZW5ndGggPiBvcHRpb25zLm51bU9mS2V5c0xpbWl0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIF9vYmogPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzT2JqZWN0KF9vYmopICYmIGlzT2JqVG9vRGVlcChfb2JqLCBvcHRpb25zLmRlcHRoT2ZMaW1pdCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoX29iaikge1xuICAgICAgICB2YXIgc3RyID0gX29iai50b1N0cmluZygpO1xuICAgICAgICBpZiAob3B0aW9ucy5zdHJpbmdMZW5ndGhMaW1pdCAmJiBzdHIubGVuZ3RoID4gb3B0aW9ucy5zdHJpbmdMZW5ndGhMaW1pdCkge1xuICAgICAgICAgICAgc3RyID0gXCJcIiArIHN0ci5zbGljZSgwLCBvcHRpb25zLnN0cmluZ0xlbmd0aExpbWl0KSArIFwiLi4uXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG59XG52YXIgZGVmYXVsdExvZ09wdGlvbnMgPSB7XG4gICAgbGV2ZWw6IFtcbiAgICAgICAgXCJhc3NlcnRcIixcbiAgICAgICAgXCJjbGVhclwiLFxuICAgICAgICBcImNvdW50XCIsXG4gICAgICAgIFwiY291bnRSZXNldFwiLFxuICAgICAgICBcImRlYnVnXCIsXG4gICAgICAgIFwiZGlyXCIsXG4gICAgICAgIFwiZGlyeG1sXCIsXG4gICAgICAgIFwiZXJyb3JcIixcbiAgICAgICAgXCJncm91cFwiLFxuICAgICAgICBcImdyb3VwQ29sbGFwc2VkXCIsXG4gICAgICAgIFwiZ3JvdXBFbmRcIixcbiAgICAgICAgXCJpbmZvXCIsXG4gICAgICAgIFwibG9nXCIsXG4gICAgICAgIFwidGFibGVcIixcbiAgICAgICAgXCJ0aW1lXCIsXG4gICAgICAgIFwidGltZUVuZFwiLFxuICAgICAgICBcInRpbWVMb2dcIixcbiAgICAgICAgXCJ0cmFjZVwiLFxuICAgICAgICBcIndhcm5cIlxuICAgIF0sXG4gICAgbGVuZ3RoVGhyZXNob2xkOiAxZTMsXG4gICAgbG9nZ2VyOiBcImNvbnNvbGVcIlxufTtcbmZ1bmN0aW9uIGluaXRMb2dPYnNlcnZlcihjYiwgd2luLCBvcHRpb25zKSB7XG4gICAgdmFyIGxvZ09wdGlvbnMgPSBvcHRpb25zID8gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdExvZ09wdGlvbnMsIG9wdGlvbnMpIDogZGVmYXVsdExvZ09wdGlvbnM7XG4gICAgdmFyIGxvZ2dlclR5cGUgPSBsb2dPcHRpb25zLmxvZ2dlcjtcbiAgICBpZiAoIWxvZ2dlclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge307XG4gICAgfVxuICAgIHZhciBsb2dnZXI7XG4gICAgaWYgKHR5cGVvZiBsb2dnZXJUeXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGxvZ2dlciA9IHdpbltsb2dnZXJUeXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIgPSBsb2dnZXJUeXBlO1xuICAgIH1cbiAgICB2YXIgbG9nQ291bnQgPSAwO1xuICAgIHZhciBpblN0YWNrID0gZmFsc2U7XG4gICAgdmFyIGNhbmNlbEhhbmRsZXJzID0gW107XG4gICAgaWYgKGxvZ09wdGlvbnMubGV2ZWwuaW5jbHVkZXMoXCJlcnJvclwiKSkge1xuICAgICAgICB2YXIgZXJyb3JIYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gZXZlbnQubWVzc2FnZSwgZXJyb3IgPSBldmVudC5lcnJvcjtcbiAgICAgICAgICAgIHZhciB0cmFjZSA9IEVycm9yU3RhY2tQYXJzZXIucGFyc2UoZXJyb3IpLm1hcChmdW5jdGlvbihzdGFja0ZyYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrRnJhbWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBbXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG1lc3NhZ2UsIGxvZ09wdGlvbnMuc3RyaW5naWZ5T3B0aW9ucylcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjYih7XG4gICAgICAgICAgICAgICAgbGV2ZWw6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICB0cmFjZTogdHJhY2UsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgY2FuY2VsSGFuZGxlcnMucHVzaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB1bmhhbmRsZWRyZWplY3Rpb25IYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgICAgIHZhciBwYXlsb2FkO1xuICAgICAgICAgICAgaWYgKF9pbnN0YW5jZW9mKGV2ZW50LnJlYXNvbiwgRXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBldmVudC5yZWFzb247XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IFtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5naWZ5KFwiVW5jYXVnaHQgKGluIHByb21pc2UpIFwiICsgZXJyb3IubmFtZSArIFwiOiBcIiArIGVycm9yLm1lc3NhZ2UsIGxvZ09wdGlvbnMuc3RyaW5naWZ5T3B0aW9ucylcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIHBheWxvYWQgPSBbXG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ2lmeShcIlVuY2F1Z2h0IChpbiBwcm9taXNlKVwiLCBsb2dPcHRpb25zLnN0cmluZ2lmeU9wdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgICBzdHJpbmdpZnkoZXZlbnQucmVhc29uLCBsb2dPcHRpb25zLnN0cmluZ2lmeU9wdGlvbnMpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0cmFjZSA9IEVycm9yU3RhY2tQYXJzZXIucGFyc2UoZXJyb3IpLm1hcChmdW5jdGlvbihzdGFja0ZyYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrRnJhbWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2Ioe1xuICAgICAgICAgICAgICAgIGxldmVsOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgdHJhY2U6IHRyYWNlLFxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihcInVuaGFuZGxlZHJlamVjdGlvblwiLCB1bmhhbmRsZWRyZWplY3Rpb25IYW5kbGVyKTtcbiAgICAgICAgY2FuY2VsSGFuZGxlcnMucHVzaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwidW5oYW5kbGVkcmVqZWN0aW9uXCIsIHVuaGFuZGxlZHJlamVjdGlvbkhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UobG9nT3B0aW9ucy5sZXZlbCksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgdmFyIGxldmVsVHlwZSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICBjYW5jZWxIYW5kbGVycy5wdXNoKHJlcGxhY2UobG9nZ2VyLCBsZXZlbFR5cGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBjYW5jZWxIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgIHJldHVybiBoKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcmVwbGFjZShfbG9nZ2VyLCBsZXZlbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIV9sb2dnZXJbbGV2ZWxdKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0Y2goX2xvZ2dlciwgbGV2ZWwsIGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMxID0gX3RoaXM7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcmlnaW5hbC5hcHBseShfdGhpczEsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA9PT0gXCJhc3NlcnRcIiAmJiAhIWFyZ3NbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5TdGFjaykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluU3RhY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFjZSA9IEVycm9yU3RhY2tQYXJzZXIucGFyc2UobmV3IEVycm9yKCkpLm1hcChmdW5jdGlvbihzdGFja0ZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2tGcmFtZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9KS5zcGxpY2UoMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzRm9yUGF5bG9hZCA9IGxldmVsID09PSBcImFzc2VydFwiID8gYXJncy5zbGljZSgxKSA6IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXlsb2FkID0gYXJnc0ZvclBheWxvYWQubWFwKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnkocywgbG9nT3B0aW9ucy5zdHJpbmdpZnlPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0NvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2dDb3VudCA8IGxvZ09wdGlvbnMubGVuZ3RoVGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlOiB0cmFjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsb2dDb3VudCA9PT0gbG9nT3B0aW9ucy5sZW5ndGhUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogXCJ3YXJuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2U6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5naWZ5KFwiVGhlIG51bWJlciBvZiBsb2cgcmVjb3JkcyByZWFjaGVkIHRoZSB0aHJlc2hvbGQuXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbC5hcHBseSh2b2lkIDAsIFtdLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgICAgICAgICBcInJyd2ViIGxvZ2dlciBlcnJvcjpcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIF0sIGFyZ3MpKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICAgICAgICAgIGluU3RhY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG59XG52YXIgUExVR0lOX05BTUUgPSBcInJyd2ViL2NvbnNvbGVAMVwiO1xudmFyIGdldFJlY29yZENvbnNvbGVQbHVnaW4gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogUExVR0lOX05BTUUsXG4gICAgICAgIG9ic2VydmVyOiBpbml0TG9nT2JzZXJ2ZXIsXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICB9O1xufTtcblxudmFyIHNldEltbWVkaWF0ZSA9IHdpblsnc2V0SW1tZWRpYXRlJ107XG52YXIgYnVpbHRJblByb3AsIGN5Y2xlLCBzY2hlZHVsaW5nUXVldWUsXG4gICAgVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgIHRpbWVyID0gKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnKSA/XG4gICAgICAgIGZ1bmN0aW9uIHRpbWVyKGZuKSB7IHJldHVybiBzZXRJbW1lZGlhdGUoZm4pOyB9IDpcbiAgICAgICAgc2V0VGltZW91dDtcblxuLy8gZGFtbWl0LCBJRTguXG50cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwneCcse30pO1xuICAgIGJ1aWx0SW5Qcm9wID0gZnVuY3Rpb24gYnVpbHRJblByb3Aob2JqLG5hbWUsdmFsLGNvbmZpZykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaixuYW1lLHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWwsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogY29uZmlnICE9PSBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9O1xufVxuY2F0Y2ggKGVycikge1xuICAgIGJ1aWx0SW5Qcm9wID0gZnVuY3Rpb24gYnVpbHRJblByb3Aob2JqLG5hbWUsdmFsKSB7XG4gICAgICAgIG9ialtuYW1lXSA9IHZhbDtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xufVxuXG4vLyBOb3RlOiB1c2luZyBhIHF1ZXVlIGluc3RlYWQgb2YgYXJyYXkgZm9yIGVmZmljaWVuY3lcbnNjaGVkdWxpbmdRdWV1ZSA9IChmdW5jdGlvbiBRdWV1ZSgpIHtcbiAgICB2YXIgZmlyc3QsIGxhc3QsIGl0ZW07XG5cbiAgICBmdW5jdGlvbiBJdGVtKGZuLHNlbGYpIHtcbiAgICAgICAgdGhpcy5mbiA9IGZuO1xuICAgICAgICB0aGlzLnNlbGYgPSBzZWxmO1xuICAgICAgICB0aGlzLm5leHQgPSB2b2lkIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkOiBmdW5jdGlvbiBhZGQoZm4sc2VsZikge1xuICAgICAgICAgICAgaXRlbSA9IG5ldyBJdGVtKGZuLHNlbGYpO1xuICAgICAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgICAgICBsYXN0Lm5leHQgPSBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdCA9IGl0ZW07XG4gICAgICAgICAgICBpdGVtID0gdm9pZCAwO1xuICAgICAgICB9LFxuICAgICAgICBkcmFpbjogZnVuY3Rpb24gZHJhaW4oKSB7XG4gICAgICAgICAgICB2YXIgZiA9IGZpcnN0O1xuICAgICAgICAgICAgZmlyc3QgPSBsYXN0ID0gY3ljbGUgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIHdoaWxlIChmKSB7XG4gICAgICAgICAgICAgICAgZi5mbi5jYWxsKGYuc2VsZik7XG4gICAgICAgICAgICAgICAgZiA9IGYubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuXG5mdW5jdGlvbiBzY2hlZHVsZShmbixzZWxmKSB7XG4gICAgc2NoZWR1bGluZ1F1ZXVlLmFkZChmbixzZWxmKTtcbiAgICBpZiAoIWN5Y2xlKSB7XG4gICAgICAgIGN5Y2xlID0gdGltZXIoc2NoZWR1bGluZ1F1ZXVlLmRyYWluKTtcbiAgICB9XG59XG5cbi8vIHByb21pc2UgZHVjayB0eXBpbmdcbmZ1bmN0aW9uIGlzVGhlbmFibGUobykge1xuICAgIHZhciBfdGhlbiwgb1R5cGUgPSB0eXBlb2YgbztcblxuICAgIGlmIChvICE9PSBudWxsICYmIChvVHlwZSA9PT0gJ29iamVjdCcgfHwgb1R5cGUgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgIF90aGVuID0gby50aGVuO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIF90aGVuID09PSAnZnVuY3Rpb24nID8gX3RoZW4gOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbm90aWZ5KCkge1xuICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLmNoYWluLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vdGlmeUlzb2xhdGVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICh0aGlzLnN0YXRlID09PSAxKSA/IHRoaXMuY2hhaW5baV0uc3VjY2VzcyA6IHRoaXMuY2hhaW5baV0uZmFpbHVyZSxcbiAgICAgICAgICAgIHRoaXMuY2hhaW5baV1cbiAgICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5jaGFpbi5sZW5ndGggPSAwO1xufVxuXG4vLyBOT1RFOiBUaGlzIGlzIGEgc2VwYXJhdGUgZnVuY3Rpb24gdG8gaXNvbGF0ZVxuLy8gdGhlIGB0cnkuLmNhdGNoYCBzbyB0aGF0IG90aGVyIGNvZGUgY2FuIGJlXG4vLyBvcHRpbWl6ZWQgYmV0dGVyXG5mdW5jdGlvbiBub3RpZnlJc29sYXRlZChzZWxmLGNiLGNoYWluKSB7XG4gICAgdmFyIHJldCwgX3RoZW47XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKGNiID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY2hhaW4ucmVqZWN0KHNlbGYubXNnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjYiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldCA9IHNlbGYubXNnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gY2IuY2FsbCh2b2lkIDAsc2VsZi5tc2cpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmV0ID09PSBjaGFpbi5wcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgY2hhaW4ucmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxuICAgICAgICAgICAgZWxzZSBpZiAoX3RoZW4gPSBpc1RoZW5hYmxlKHJldCkpIHtcbiAgICAgICAgICAgICAgICBfdGhlbi5jYWxsKHJldCxjaGFpbi5yZXNvbHZlLGNoYWluLnJlamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGFpbi5yZXNvbHZlKHJldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBjaGFpbi5yZWplY3QoZXJyKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmUobXNnKSB7XG4gICAgdmFyIF90aGVuLCBzZWxmID0gdGhpcztcblxuICAgIC8vIGFscmVhZHkgdHJpZ2dlcmVkP1xuICAgIGlmIChzZWxmLnRyaWdnZXJlZCkgeyByZXR1cm47IH1cblxuICAgIHNlbGYudHJpZ2dlcmVkID0gdHJ1ZTtcblxuICAgIC8vIHVud3JhcFxuICAgIGlmIChzZWxmLmRlZikge1xuICAgICAgICBzZWxmID0gc2VsZi5kZWY7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgICAgIGlmIChfdGhlbiA9IGlzVGhlbmFibGUobXNnKSkge1xuICAgICAgICAgICAgc2NoZWR1bGUoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICB2YXIgZGVmV3JhcHBlciA9IG5ldyBNYWtlRGVmV3JhcHBlcihzZWxmKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBfdGhlbi5jYWxsKG1zZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICRyZXNvbHZlJCgpeyByZXNvbHZlLmFwcGx5KGRlZldyYXBwZXIsYXJndW1lbnRzKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICRyZWplY3QkKCl7IHJlamVjdC5hcHBseShkZWZXcmFwcGVyLGFyZ3VtZW50cyk7IH1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QuY2FsbChkZWZXcmFwcGVyLGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxmLm1zZyA9IG1zZztcbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAxO1xuICAgICAgICAgICAgaWYgKHNlbGYuY2hhaW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlKG5vdGlmeSxzZWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlamVjdC5jYWxsKG5ldyBNYWtlRGVmV3JhcHBlcihzZWxmKSxlcnIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVqZWN0KG1zZykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIGFscmVhZHkgdHJpZ2dlcmVkP1xuICAgIGlmIChzZWxmLnRyaWdnZXJlZCkgeyByZXR1cm47IH1cblxuICAgIHNlbGYudHJpZ2dlcmVkID0gdHJ1ZTtcblxuICAgIC8vIHVud3JhcFxuICAgIGlmIChzZWxmLmRlZikge1xuICAgICAgICBzZWxmID0gc2VsZi5kZWY7XG4gICAgfVxuXG4gICAgc2VsZi5tc2cgPSBtc2c7XG4gICAgc2VsZi5zdGF0ZSA9IDI7XG4gICAgaWYgKHNlbGYuY2hhaW4ubGVuZ3RoID4gMCkge1xuICAgICAgICBzY2hlZHVsZShub3RpZnksc2VsZik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpdGVyYXRlUHJvbWlzZXMoQ29uc3RydWN0b3IsYXJyLHJlc29sdmVyLHJlamVjdGVyKSB7XG4gICAgZm9yICh2YXIgaWR4PTA7IGlkeDxhcnIubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAoZnVuY3Rpb24gSUlGRShpZHgpe1xuICAgICAgICAgICAgQ29uc3RydWN0b3IucmVzb2x2ZShhcnJbaWR4XSlcbiAgICAgICAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gJHJlc29sdmVyJChtc2cpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZXIoaWR4LG1zZyk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdGVyXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgfSkoaWR4KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIE1ha2VEZWZXcmFwcGVyKHNlbGYpIHtcbiAgICB0aGlzLmRlZiA9IHNlbGY7XG4gICAgdGhpcy50cmlnZ2VyZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gTWFrZURlZihzZWxmKSB7XG4gICAgdGhpcy5wcm9taXNlID0gc2VsZjtcbiAgICB0aGlzLnN0YXRlID0gMDtcbiAgICB0aGlzLnRyaWdnZXJlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2hhaW4gPSBbXTtcbiAgICB0aGlzLm1zZyA9IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gTnBvUHJvbWlzZShleGVjdXRvcikge1xuICAgIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdOb3QgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzWydfX05QT19fJ10gIT09IDApIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdOb3QgYSBwcm9taXNlJyk7XG4gICAgfVxuXG4gICAgLy8gaW5zdGFuY2Ugc2hhZG93aW5nIHRoZSBpbmhlcml0ZWQgXCJicmFuZFwiXG4gICAgLy8gdG8gc2lnbmFsIGFuIGFscmVhZHkgXCJpbml0aWFsaXplZFwiIHByb21pc2VcbiAgICB0aGlzWydfX05QT19fJ10gPSAxO1xuXG4gICAgdmFyIGRlZiA9IG5ldyBNYWtlRGVmKHRoaXMpO1xuXG4gICAgdGhpc1sndGhlbiddID0gZnVuY3Rpb24gdGhlbihzdWNjZXNzLGZhaWx1cmUpIHtcbiAgICAgICAgdmFyIG8gPSB7XG4gICAgICAgICAgICBzdWNjZXNzOiB0eXBlb2Ygc3VjY2VzcyA9PT0gJ2Z1bmN0aW9uJyA/IHN1Y2Nlc3MgOiB0cnVlLFxuICAgICAgICAgICAgZmFpbHVyZTogdHlwZW9mIGZhaWx1cmUgPT09ICdmdW5jdGlvbicgPyBmYWlsdXJlIDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIE5vdGU6IGB0aGVuKC4uKWAgaXRzZWxmIGNhbiBiZSBib3Jyb3dlZCB0byBiZSB1c2VkIGFnYWluc3RcbiAgICAgICAgICAgIC8vIGEgZGlmZmVyZW50IHByb21pc2UgY29uc3RydWN0b3IgZm9yIG1ha2luZyB0aGUgY2hhaW5lZCBwcm9taXNlLFxuICAgICAgICAgICAgLy8gYnkgc3Vic3RpdHV0aW5nIGEgZGlmZmVyZW50IGB0aGlzYCBiaW5kaW5nLlxuICAgICAgICBvLnByb21pc2UgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihmdW5jdGlvbiBleHRyYWN0Q2hhaW4ocmVzb2x2ZSxyZWplY3QpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgcmVqZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdOb3QgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgby5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYuY2hhaW4ucHVzaChvKTtcblxuICAgICAgICBpZiAoZGVmLnN0YXRlICE9PSAwKSB7XG4gICAgICAgICAgICBzY2hlZHVsZShub3RpZnksZGVmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvLnByb21pc2U7XG4gICAgfTtcbiAgICB0aGlzWydjYXRjaCddID0gZnVuY3Rpb24gJGNhdGNoJChmYWlsdXJlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRoZW4odm9pZCAwLGZhaWx1cmUpO1xuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgICBleGVjdXRvci5jYWxsKFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgZnVuY3Rpb24gcHVibGljUmVzb2x2ZShtc2cpe1xuICAgICAgICAgICAgICAgIHJlc29sdmUuY2FsbChkZWYsbXNnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiBwdWJsaWNSZWplY3QobXNnKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0LmNhbGwoZGVmLG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVqZWN0LmNhbGwoZGVmLGVycik7XG4gICAgfVxufVxuXG52YXIgUHJvbWlzZVByb3RvdHlwZSA9IGJ1aWx0SW5Qcm9wKHt9LCdjb25zdHJ1Y3RvcicsTnBvUHJvbWlzZSxcbiAgICAvKmNvbmZpZ3VyYWJsZT0qL2ZhbHNlXG4pO1xuXG4gICAgLy8gTm90ZTogQW5kcm9pZCA0IGNhbm5vdCB1c2UgYE9iamVjdC5kZWZpbmVQcm9wZXJ0eSguLilgIGhlcmVcbk5wb1Byb21pc2UucHJvdG90eXBlID0gUHJvbWlzZVByb3RvdHlwZTtcblxuLy8gYnVpbHQtaW4gXCJicmFuZFwiIHRvIHNpZ25hbCBhbiBcInVuaW5pdGlhbGl6ZWRcIiBwcm9taXNlXG5idWlsdEluUHJvcChQcm9taXNlUHJvdG90eXBlLCdfX05QT19fJywwLFxuICAgIC8qY29uZmlndXJhYmxlPSovZmFsc2Vcbik7XG5cbmJ1aWx0SW5Qcm9wKE5wb1Byb21pc2UsJ3Jlc29sdmUnLGZ1bmN0aW9uIFByb21pc2UkcmVzb2x2ZShtc2cpIHtcbiAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gICAgLy8gc3BlYyBtYW5kYXRlZCBjaGVja3NcbiAgICAvLyBub3RlOiBiZXN0IFwiaXNQcm9taXNlXCIgY2hlY2sgdGhhdCdzIHByYWN0aWNhbCBmb3Igbm93XG4gICAgaWYgKG1zZyAmJiB0eXBlb2YgbXNnID09PSAnb2JqZWN0JyAmJiBtc2dbJ19fTlBPX18nXSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gbXNnO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSxyZWplY3Qpe1xuICAgICAgICBpZiAodHlwZW9mIHJlc29sdmUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHJlamVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdOb3QgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzb2x2ZShtc2cpO1xuICAgIH0pO1xufSk7XG5cbmJ1aWx0SW5Qcm9wKE5wb1Byb21pc2UsJ3JlamVjdCcsZnVuY3Rpb24gUHJvbWlzZSRyZWplY3QobXNnKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUscmVqZWN0KXtcbiAgICAgICAgaWYgKHR5cGVvZiByZXNvbHZlICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiByZWplY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignTm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlamVjdChtc2cpO1xuICAgIH0pO1xufSk7XG5cbmJ1aWx0SW5Qcm9wKE5wb1Byb21pc2UsJ2FsbCcsZnVuY3Rpb24gUHJvbWlzZSRhbGwoYXJyKSB7XG4gICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICAgIC8vIHNwZWMgbWFuZGF0ZWQgY2hlY2tzXG4gICAgaWYgKFRvU3RyaW5nLmNhbGwoYXJyKSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICByZXR1cm4gQ29uc3RydWN0b3IucmVqZWN0KFR5cGVFcnJvcignTm90IGFuIGFycmF5JykpO1xuICAgIH1cbiAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQ29uc3RydWN0b3IucmVzb2x2ZShbXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLHJlamVjdCl7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgcmVqZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ05vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuID0gYXJyLmxlbmd0aCwgbXNncyA9IEFycmF5KGxlbiksIGNvdW50ID0gMDtcblxuICAgICAgICBpdGVyYXRlUHJvbWlzZXMoQ29uc3RydWN0b3IsYXJyLGZ1bmN0aW9uIHJlc29sdmVyKGlkeCxtc2cpIHtcbiAgICAgICAgICAgIG1zZ3NbaWR4XSA9IG1zZztcbiAgICAgICAgICAgIGlmICgrK2NvdW50ID09PSBsZW4pIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG1zZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LHJlamVjdCk7XG4gICAgfSk7XG59KTtcblxuYnVpbHRJblByb3AoTnBvUHJvbWlzZSwncmFjZScsZnVuY3Rpb24gUHJvbWlzZSRyYWNlKGFycikge1xuICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgICAvLyBzcGVjIG1hbmRhdGVkIGNoZWNrc1xuICAgIGlmIChUb1N0cmluZy5jYWxsKGFycikgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yLnJlamVjdChUeXBlRXJyb3IoJ05vdCBhbiBhcnJheScpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUscmVqZWN0KXtcbiAgICAgICAgaWYgKHR5cGVvZiByZXNvbHZlICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiByZWplY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignTm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZXJhdGVQcm9taXNlcyhDb25zdHJ1Y3RvcixhcnIsZnVuY3Rpb24gcmVzb2x2ZXIoaWR4LG1zZyl7XG4gICAgICAgICAgICByZXNvbHZlKG1zZyk7XG4gICAgICAgIH0scmVqZWN0KTtcbiAgICB9KTtcbn0pO1xuXG52YXIgUHJvbWlzZVBvbHlmaWxsO1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBQcm9taXNlLnRvU3RyaW5nKCkuaW5kZXhPZignW25hdGl2ZSBjb2RlXScpICE9PSAtMSkge1xuICAgIFByb21pc2VQb2x5ZmlsbCA9IFByb21pc2U7XG59IGVsc2Uge1xuICAgIFByb21pc2VQb2x5ZmlsbCA9IE5wb1Byb21pc2U7XG59XG5cbnZhciBDb25maWcgPSB7XG4gICAgREVCVUc6IGZhbHNlLFxuICAgIExJQl9WRVJTSU9OOiAnMi43Mi4wJ1xufTtcblxuLyogZXNsaW50IGNhbWVsY2FzZTogXCJvZmZcIiwgZXFlcWVxOiBcIm9mZlwiICovXG5cbi8vIE1heGltdW0gYWxsb3dlZCBzZXNzaW9uIHJlY29yZGluZyBsZW5ndGhcbnZhciBNQVhfUkVDT1JESU5HX01TID0gMjQgKiA2MCAqIDYwICogMTAwMDsgLy8gMjQgaG91cnNcbi8vIE1heGltdW0gYWxsb3dlZCB2YWx1ZSBmb3IgbWluaW11bSBzZXNzaW9uIHJlY29yZGluZyBsZW5ndGhcbnZhciBNQVhfVkFMVUVfRk9SX01JTl9SRUNPUkRJTkdfTVMgPSA4ICogMTAwMDsgLy8gOCBzZWNvbmRzXG5cbi8qXG4gKiBTYXZlZCByZWZlcmVuY2VzIHRvIGxvbmcgdmFyaWFibGUgbmFtZXMsIHNvIHRoYXQgY2xvc3VyZSBjb21waWxlciBjYW5cbiAqIG1pbmltaXplIGZpbGUgc2l6ZS5cbiAqL1xuXG52YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxuICAgIHNsaWNlID0gQXJyYXlQcm90by5zbGljZSxcbiAgICB0b1N0cmluZyA9IE9ialByb3RvLnRvU3RyaW5nLFxuICAgIGhhc093blByb3BlcnR5ID0gT2JqUHJvdG8uaGFzT3duUHJvcGVydHksXG4gICAgd2luZG93Q29uc29sZSA9IHdpbi5jb25zb2xlLFxuICAgIG5hdmlnYXRvciA9IHdpbi5uYXZpZ2F0b3IsXG4gICAgZG9jdW1lbnQkMSA9IHdpbi5kb2N1bWVudCxcbiAgICB3aW5kb3dPcGVyYSA9IHdpbi5vcGVyYSxcbiAgICBzY3JlZW4gPSB3aW4uc2NyZWVuLFxuICAgIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbnZhciBuYXRpdmVCaW5kID0gRnVuY1Byb3RvLmJpbmQsXG4gICAgbmF0aXZlRm9yRWFjaCA9IEFycmF5UHJvdG8uZm9yRWFjaCxcbiAgICBuYXRpdmVJbmRleE9mID0gQXJyYXlQcm90by5pbmRleE9mLFxuICAgIG5hdGl2ZU1hcCA9IEFycmF5UHJvdG8ubWFwLFxuICAgIG5hdGl2ZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5LFxuICAgIGJyZWFrZXIgPSB7fTtcblxudmFyIF8gPSB7XG4gICAgdHJpbTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9UcmltI1BvbHlmaWxsXG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csICcnKTtcbiAgICB9XG59O1xuXG4vLyBDb25zb2xlIG92ZXJyaWRlXG52YXIgY29uc29sZSQxID0ge1xuICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKil9ICovXG4gICAgbG9nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKENvbmZpZy5ERUJVRyAmJiAhXy5pc1VuZGVmaW5lZCh3aW5kb3dDb25zb2xlKSAmJiB3aW5kb3dDb25zb2xlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdpbmRvd0NvbnNvbGUubG9nLmFwcGx5KHdpbmRvd0NvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBfLmVhY2goYXJndW1lbnRzLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Q29uc29sZS5sb2coYXJnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKX0gKi9cbiAgICB3YXJuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKENvbmZpZy5ERUJVRyAmJiAhXy5pc1VuZGVmaW5lZCh3aW5kb3dDb25zb2xlKSAmJiB3aW5kb3dDb25zb2xlKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFsnTWl4cGFuZWwgd2FybmluZzonXS5jb25jYXQoXy50b0FycmF5KGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3aW5kb3dDb25zb2xlLndhcm4uYXBwbHkod2luZG93Q29uc29sZSwgYXJncyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBfLmVhY2goYXJncywgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0NvbnNvbGUud2FybihhcmcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICAvKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopfSAqL1xuICAgIGVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKENvbmZpZy5ERUJVRyAmJiAhXy5pc1VuZGVmaW5lZCh3aW5kb3dDb25zb2xlKSAmJiB3aW5kb3dDb25zb2xlKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFsnTWl4cGFuZWwgZXJyb3I6J10uY29uY2F0KF8udG9BcnJheShhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgd2luZG93Q29uc29sZS5lcnJvci5hcHBseSh3aW5kb3dDb25zb2xlLCBhcmdzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF8uZWFjaChhcmdzLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Q29uc29sZS5lcnJvcihhcmcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICAvKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopfSAqL1xuICAgIGNyaXRpY2FsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHdpbmRvd0NvbnNvbGUpICYmIHdpbmRvd0NvbnNvbGUpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gWydNaXhwYW5lbCBlcnJvcjonXS5jb25jYXQoXy50b0FycmF5KGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3aW5kb3dDb25zb2xlLmVycm9yLmFwcGx5KHdpbmRvd0NvbnNvbGUsIGFyZ3MpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgXy5lYWNoKGFyZ3MsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3dDb25zb2xlLmVycm9yKGFyZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgbG9nX2Z1bmNfd2l0aF9wcmVmaXggPSBmdW5jdGlvbihmdW5jLCBwcmVmaXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGFyZ3VtZW50c1swXSA9ICdbJyArIHByZWZpeCArICddICcgKyBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnNvbGUkMSwgYXJndW1lbnRzKTtcbiAgICB9O1xufTtcbnZhciBjb25zb2xlX3dpdGhfcHJlZml4ID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbG9nOiBsb2dfZnVuY193aXRoX3ByZWZpeChjb25zb2xlJDEubG9nLCBwcmVmaXgpLFxuICAgICAgICBlcnJvcjogbG9nX2Z1bmNfd2l0aF9wcmVmaXgoY29uc29sZSQxLmVycm9yLCBwcmVmaXgpLFxuICAgICAgICBjcml0aWNhbDogbG9nX2Z1bmNfd2l0aF9wcmVmaXgoY29uc29sZSQxLmNyaXRpY2FsLCBwcmVmaXgpXG4gICAgfTtcbn07XG5cblxudmFyIHNhZmV3cmFwID0gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUkMS5jcml0aWNhbCgnSW1wbGVtZW50YXRpb24gZXJyb3IuIFBsZWFzZSB0dXJuIG9uIGRlYnVnIGFuZCBjb250YWN0IHN1cHBvcnRAbWl4cGFuZWwuY29tLicpO1xuICAgICAgICAgICAgaWYgKENvbmZpZy5ERUJVRyl7XG4gICAgICAgICAgICAgICAgY29uc29sZSQxLmNyaXRpY2FsKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn07XG5cbnZhciBzYWZld3JhcENsYXNzID0gZnVuY3Rpb24oa2xhc3MpIHtcbiAgICB2YXIgcHJvdG8gPSBrbGFzcy5wcm90b3R5cGU7XG4gICAgZm9yICh2YXIgZnVuYyBpbiBwcm90bykge1xuICAgICAgICBpZiAodHlwZW9mKHByb3RvW2Z1bmNdKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcHJvdG9bZnVuY10gPSBzYWZld3JhcChwcm90b1tmdW5jXSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbi8vIFVOREVSU0NPUkVcbi8vIEVtYmVkIHBhcnQgb2YgdGhlIFVuZGVyc2NvcmUgTGlicmFyeVxuXy5iaW5kID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCkge1xuICAgIHZhciBhcmdzLCBib3VuZDtcbiAgICBpZiAobmF0aXZlQmluZCAmJiBmdW5jLmJpbmQgPT09IG5hdGl2ZUJpbmQpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICB9XG4gICAgaWYgKCFfLmlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgIH1cbiAgICBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdG9yID0ge307XG4gICAgICAgIGN0b3IucHJvdG90eXBlID0gZnVuYy5wcm90b3R5cGU7XG4gICAgICAgIHZhciBzZWxmID0gbmV3IGN0b3IoKTtcbiAgICAgICAgY3Rvci5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseShzZWxmLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICByZXR1cm4gYm91bmQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7Kj19IG9ialxuICogQHBhcmFtIHtmdW5jdGlvbiguLi4qKT19IGl0ZXJhdG9yXG4gKiBAcGFyYW0ge09iamVjdD19IGNvbnRleHRcbiAqL1xuXy5lYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmIChvYmogPT09IG51bGwgfHwgb2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobmF0aXZlRm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gbmF0aXZlRm9yRWFjaCkge1xuICAgICAgICBvYmouZm9yRWFjaChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIG9iaiAmJiBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSA9PT0gYnJlYWtlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtrZXldLCBrZXksIG9iaikgPT09IGJyZWFrZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbl8uZXh0ZW5kID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXy5lYWNoKHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlW3Byb3BdICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xufTtcblxuXy5pc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuLy8gZnJvbSBhIGNvbW1lbnQgb24gaHR0cDovL2Riai5vcmcvZGJqLz9wPTI4NlxuLy8gZmFpbHMgb24gb25seSBvbmUgdmVyeSByYXJlIGFuZCBkZWxpYmVyYXRlIGN1c3RvbSBvYmplY3Q6XG4vLyB2YXIgYm9tYiA9IHsgdG9TdHJpbmcgOiB1bmRlZmluZWQsIHZhbHVlT2Y6IGZ1bmN0aW9uKG8pIHsgcmV0dXJuIFwiZnVuY3Rpb24gQk9NQkEhXCI7IH19O1xuXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24oZikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAvXlxccypcXGJmdW5jdGlvblxcYi8udGVzdChmKTtcbiAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG5fLmlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgJ2NhbGxlZScpKTtcbn07XG5cbl8udG9BcnJheSA9IGZ1bmN0aW9uKGl0ZXJhYmxlKSB7XG4gICAgaWYgKCFpdGVyYWJsZSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChpdGVyYWJsZS50b0FycmF5KSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZS50b0FycmF5KCk7XG4gICAgfVxuICAgIGlmIChfLmlzQXJyYXkoaXRlcmFibGUpKSB7XG4gICAgICAgIHJldHVybiBzbGljZS5jYWxsKGl0ZXJhYmxlKTtcbiAgICB9XG4gICAgaWYgKF8uaXNBcmd1bWVudHMoaXRlcmFibGUpKSB7XG4gICAgICAgIHJldHVybiBzbGljZS5jYWxsKGl0ZXJhYmxlKTtcbiAgICB9XG4gICAgcmV0dXJuIF8udmFsdWVzKGl0ZXJhYmxlKTtcbn07XG5cbl8ubWFwID0gZnVuY3Rpb24oYXJyLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgIGlmIChuYXRpdmVNYXAgJiYgYXJyLm1hcCA9PT0gbmF0aXZlTWFwKSB7XG4gICAgICAgIHJldHVybiBhcnIubWFwKGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBfLmVhY2goYXJyLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goY2FsbGJhY2suY2FsbChjb250ZXh0LCBpdGVtKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG59O1xuXG5fLmtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmVzdWx0c1tyZXN1bHRzLmxlbmd0aF0gPSBrZXk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG5fLnZhbHVlcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmVzdWx0c1tyZXN1bHRzLmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbn07XG5cbl8uaW5jbHVkZSA9IGZ1bmN0aW9uKG9iaiwgdGFyZ2V0KSB7XG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIGlmIChuYXRpdmVJbmRleE9mICYmIG9iai5pbmRleE9mID09PSBuYXRpdmVJbmRleE9mKSB7XG4gICAgICAgIHJldHVybiBvYmouaW5kZXhPZih0YXJnZXQpICE9IC0xO1xuICAgIH1cbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoZm91bmQgfHwgKGZvdW5kID0gKHZhbHVlID09PSB0YXJnZXQpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGJyZWFrZXI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG59O1xuXG5fLmluY2x1ZGVzID0gZnVuY3Rpb24oc3RyLCBuZWVkbGUpIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2YobmVlZGxlKSAhPT0gLTE7XG59O1xuXG4vLyBVbmRlcnNjb3JlIEFkZG9uc1xuXy5pbmhlcml0ID0gZnVuY3Rpb24oc3ViY2xhc3MsIHN1cGVyY2xhc3MpIHtcbiAgICBzdWJjbGFzcy5wcm90b3R5cGUgPSBuZXcgc3VwZXJjbGFzcygpO1xuICAgIHN1YmNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YmNsYXNzO1xuICAgIHN1YmNsYXNzLnN1cGVyY2xhc3MgPSBzdXBlcmNsYXNzLnByb3RvdHlwZTtcbiAgICByZXR1cm4gc3ViY2xhc3M7XG59O1xuXG5fLmlzT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIChvYmogPT09IE9iamVjdChvYmopICYmICFfLmlzQXJyYXkob2JqKSk7XG59O1xuXG5fLmlzRW1wdHlPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoXy5pc09iamVjdChvYmopKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuXy5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcbn07XG5cbl8uaXNTdHJpbmcgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IFN0cmluZ10nO1xufTtcblxuXy5pc0RhdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IERhdGVdJztcbn07XG5cbl8uaXNOdW1iZXIgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IE51bWJlcl0nO1xufTtcblxuXy5pc0VsZW1lbnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XG59O1xuXG5fLmVuY29kZURhdGVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICBpZiAoXy5pc0RhdGUodikpIHtcbiAgICAgICAgICAgIG9ialtrXSA9IF8uZm9ybWF0RGF0ZSh2KTtcbiAgICAgICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KHYpKSB7XG4gICAgICAgICAgICBvYmpba10gPSBfLmVuY29kZURhdGVzKHYpOyAvLyByZWN1cnNlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xufTtcblxuXy50aW1lc3RhbXAgPSBmdW5jdGlvbigpIHtcbiAgICBEYXRlLm5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gK25ldyBEYXRlO1xuICAgIH07XG4gICAgcmV0dXJuIERhdGUubm93KCk7XG59O1xuXG5fLmZvcm1hdERhdGUgPSBmdW5jdGlvbihkKSB7XG4gICAgLy8gWVlZWS1NTS1ERFRISDpNTTpTUyBpbiBVVENcbiAgICBmdW5jdGlvbiBwYWQobikge1xuICAgICAgICByZXR1cm4gbiA8IDEwID8gJzAnICsgbiA6IG47XG4gICAgfVxuICAgIHJldHVybiBkLmdldFVUQ0Z1bGxZZWFyKCkgKyAnLScgK1xuICAgICAgICBwYWQoZC5nZXRVVENNb250aCgpICsgMSkgKyAnLScgK1xuICAgICAgICBwYWQoZC5nZXRVVENEYXRlKCkpICsgJ1QnICtcbiAgICAgICAgcGFkKGQuZ2V0VVRDSG91cnMoKSkgKyAnOicgK1xuICAgICAgICBwYWQoZC5nZXRVVENNaW51dGVzKCkpICsgJzonICtcbiAgICAgICAgcGFkKGQuZ2V0VVRDU2Vjb25kcygpKTtcbn07XG5cbl8uc3RyaXBfZW1wdHlfcHJvcGVydGllcyA9IGZ1bmN0aW9uKHApIHtcbiAgICB2YXIgcmV0ID0ge307XG4gICAgXy5lYWNoKHAsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgaWYgKF8uaXNTdHJpbmcodikgJiYgdi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXRba10gPSB2O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbi8qXG4gKiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYSBjb3B5IG9mIG9iamVjdCBhZnRlciB0cnVuY2F0aW5nIGl0LiAgSWZcbiAqIHBhc3NlZCBhbiBBcnJheSBvciBPYmplY3QgaXQgd2lsbCBpdGVyYXRlIHRocm91Z2ggb2JqIGFuZFxuICogdHJ1bmNhdGUgYWxsIHRoZSB2YWx1ZXMgcmVjdXJzaXZlbHkuXG4gKi9cbl8udHJ1bmNhdGUgPSBmdW5jdGlvbihvYmosIGxlbmd0aCkge1xuICAgIHZhciByZXQ7XG5cbiAgICBpZiAodHlwZW9mKG9iaikgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldCA9IG9iai5zbGljZSgwLCBsZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAoXy5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgcmV0ID0gW107XG4gICAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgcmV0LnB1c2goXy50cnVuY2F0ZSh2YWwsIGxlbmd0aCkpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3Qob2JqKSkge1xuICAgICAgICByZXQgPSB7fTtcbiAgICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsLCBrZXkpIHtcbiAgICAgICAgICAgIHJldFtrZXldID0gXy50cnVuY2F0ZSh2YWwsIGxlbmd0aCk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IG9iajtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xufTtcblxuXy5KU09ORW5jb2RlID0gKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jdGlvbihtaXhlZF92YWwpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbWl4ZWRfdmFsO1xuICAgICAgICB2YXIgcXVvdGUgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgICAgIHZhciBlc2NhcGFibGUgPSAvW1xcXFxcIlxceDAwLVxceDFmXFx4N2YtXFx4OWZcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb250cm9sLXJlZ2V4XG4gICAgICAgICAgICB2YXIgbWV0YSA9IHsgLy8gdGFibGUgb2YgY2hhcmFjdGVyIHN1YnN0aXR1dGlvbnNcbiAgICAgICAgICAgICAgICAnXFxiJzogJ1xcXFxiJyxcbiAgICAgICAgICAgICAgICAnXFx0JzogJ1xcXFx0JyxcbiAgICAgICAgICAgICAgICAnXFxuJzogJ1xcXFxuJyxcbiAgICAgICAgICAgICAgICAnXFxmJzogJ1xcXFxmJyxcbiAgICAgICAgICAgICAgICAnXFxyJzogJ1xcXFxyJyxcbiAgICAgICAgICAgICAgICAnXCInOiAnXFxcXFwiJyxcbiAgICAgICAgICAgICAgICAnXFxcXCc6ICdcXFxcXFxcXCdcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgcmV0dXJuIGVzY2FwYWJsZS50ZXN0KHN0cmluZykgP1xuICAgICAgICAgICAgICAgICdcIicgKyBzdHJpbmcucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBtZXRhW2FdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGMgPT09ICdzdHJpbmcnID8gYyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAnXFxcXHUnICsgKCcwMDAwJyArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICAgICAgICAgICAgICB9KSArICdcIicgOlxuICAgICAgICAgICAgICAgICdcIicgKyBzdHJpbmcgKyAnXCInO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBzdHIgPSBmdW5jdGlvbihrZXksIGhvbGRlcikge1xuICAgICAgICAgICAgdmFyIGdhcCA9ICcnO1xuICAgICAgICAgICAgdmFyIGluZGVudCA9ICcgICAgJztcbiAgICAgICAgICAgIHZhciBpID0gMDsgLy8gVGhlIGxvb3AgY291bnRlci5cbiAgICAgICAgICAgIHZhciBrID0gJyc7IC8vIFRoZSBtZW1iZXIga2V5LlxuICAgICAgICAgICAgdmFyIHYgPSAnJzsgLy8gVGhlIG1lbWJlciB2YWx1ZS5cbiAgICAgICAgICAgIHZhciBsZW5ndGggPSAwO1xuICAgICAgICAgICAgdmFyIG1pbmQgPSBnYXA7XG4gICAgICAgICAgICB2YXIgcGFydGlhbCA9IFtdO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gaG9sZGVyW2tleV07XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBoYXMgYSB0b0pTT04gbWV0aG9kLCBjYWxsIGl0IHRvIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04oa2V5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2hhdCBoYXBwZW5zIG5leHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUncyB0eXBlLlxuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcXVvdGUodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBFbmNvZGUgbm9uLWZpbml0ZSBudW1iZXJzIGFzIG51bGwuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgPyBTdHJpbmcodmFsdWUpIDogJ251bGwnO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBhIGJvb2xlYW4gb3IgbnVsbCwgY29udmVydCBpdCB0byBhIHN0cmluZy4gTm90ZTpcbiAgICAgICAgICAgICAgICAgICAgLy8gdHlwZW9mIG51bGwgZG9lcyBub3QgcHJvZHVjZSAnbnVsbCcuIFRoZSBjYXNlIGlzIGluY2x1ZGVkIGhlcmUgaW5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJlbW90ZSBjaGFuY2UgdGhhdCB0aGlzIGdldHMgZml4ZWQgc29tZWRheS5cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB0eXBlIGlzICdvYmplY3QnLCB3ZSBtaWdodCBiZSBkZWFsaW5nIHdpdGggYW4gb2JqZWN0IG9yIGFuIGFycmF5IG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG51bGwuXG4gICAgICAgICAgICAgICAgICAgIC8vIER1ZSB0byBhIHNwZWNpZmljYXRpb24gYmx1bmRlciBpbiBFQ01BU2NyaXB0LCB0eXBlb2YgbnVsbCBpcyAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gd2F0Y2ggb3V0IGZvciB0aGF0IGNhc2UuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIGFuIGFycmF5IHRvIGhvbGQgdGhlIHBhcnRpYWwgcmVzdWx0cyBvZiBzdHJpbmdpZnlpbmcgdGhpcyBvYmplY3QgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgIGdhcCArPSBpbmRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpYWwgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJcyB0aGUgdmFsdWUgYW4gYXJyYXk/XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b1N0cmluZy5hcHBseSh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB2YWx1ZSBpcyBhbiBhcnJheS4gU3RyaW5naWZ5IGV2ZXJ5IGVsZW1lbnQuIFVzZSBudWxsIGFzIGEgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBub24tSlNPTiB2YWx1ZXMuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxbaV0gPSBzdHIoaSwgdmFsdWUpIHx8ICdudWxsJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSm9pbiBhbGwgb2YgdGhlIGVsZW1lbnRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsIGFuZCB3cmFwIHRoZW0gaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJyYWNrZXRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwID8gJ1tdJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2FwID8gJ1tcXG4nICsgZ2FwICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLmpvaW4oJyxcXG4nICsgZ2FwKSArICdcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5kICsgJ10nIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1snICsgcGFydGlhbC5qb2luKCcsJykgKyAnXSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBrZXlzIGluIHRoZSBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKGdhcCA/ICc6ICcgOiAnOicpICsgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSm9pbiBhbGwgb2YgdGhlIG1lbWJlciB0ZXh0cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLFxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgd3JhcCB0aGVtIGluIGJyYWNlcy5cbiAgICAgICAgICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwID8gJ3t9JyA6XG4gICAgICAgICAgICAgICAgICAgICAgICBnYXAgPyAneycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICcnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmQgKyAnfScgOiAneycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICd9JztcbiAgICAgICAgICAgICAgICAgICAgZ2FwID0gbWluZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gTWFrZSBhIGZha2Ugcm9vdCBvYmplY3QgY29udGFpbmluZyBvdXIgdmFsdWUgdW5kZXIgdGhlIGtleSBvZiAnJy5cbiAgICAgICAgLy8gUmV0dXJuIHRoZSByZXN1bHQgb2Ygc3RyaW5naWZ5aW5nIHRoZSB2YWx1ZS5cbiAgICAgICAgcmV0dXJuIHN0cignJywge1xuICAgICAgICAgICAgJyc6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL2RvdWdsYXNjcm9ja2ZvcmQvSlNPTi1qcy9ibG9iL21hc3Rlci9qc29uX3BhcnNlLmpzXG4gKiBTbGlnaHRseSBtb2RpZmllZCB0byB0aHJvdyBhIHJlYWwgRXJyb3IgcmF0aGVyIHRoYW4gYSBQT0pPXG4gKi9cbl8uSlNPTkRlY29kZSA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgYXQsIC8vIFRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBjaGFyYWN0ZXJcbiAgICAgICAgY2gsIC8vIFRoZSBjdXJyZW50IGNoYXJhY3RlclxuICAgICAgICBlc2NhcGVlID0ge1xuICAgICAgICAgICAgJ1wiJzogJ1wiJyxcbiAgICAgICAgICAgICdcXFxcJzogJ1xcXFwnLFxuICAgICAgICAgICAgJy8nOiAnLycsXG4gICAgICAgICAgICAnYic6ICdcXGInLFxuICAgICAgICAgICAgJ2YnOiAnXFxmJyxcbiAgICAgICAgICAgICduJzogJ1xcbicsXG4gICAgICAgICAgICAncic6ICdcXHInLFxuICAgICAgICAgICAgJ3QnOiAnXFx0J1xuICAgICAgICB9LFxuICAgICAgICB0ZXh0LFxuICAgICAgICBlcnJvciA9IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICAgIHZhciBlID0gbmV3IFN5bnRheEVycm9yKG0pO1xuICAgICAgICAgICAgZS5hdCA9IGF0O1xuICAgICAgICAgICAgZS50ZXh0ID0gdGV4dDtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0sXG4gICAgICAgIG5leHQgPSBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICAvLyBJZiBhIGMgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLCB2ZXJpZnkgdGhhdCBpdCBtYXRjaGVzIHRoZSBjdXJyZW50IGNoYXJhY3Rlci5cbiAgICAgICAgICAgIGlmIChjICYmIGMgIT09IGNoKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkIFxcJycgKyBjICsgJ1xcJyBpbnN0ZWFkIG9mIFxcJycgKyBjaCArICdcXCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCB0aGUgbmV4dCBjaGFyYWN0ZXIuIFdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgY2hhcmFjdGVycyxcbiAgICAgICAgICAgIC8vIHJldHVybiB0aGUgZW1wdHkgc3RyaW5nLlxuICAgICAgICAgICAgY2ggPSB0ZXh0LmNoYXJBdChhdCk7XG4gICAgICAgICAgICBhdCArPSAxO1xuICAgICAgICAgICAgcmV0dXJuIGNoO1xuICAgICAgICB9LFxuICAgICAgICBudW1iZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFBhcnNlIGEgbnVtYmVyIHZhbHVlLlxuICAgICAgICAgICAgdmFyIG51bWJlcixcbiAgICAgICAgICAgICAgICBzdHJpbmcgPSAnJztcblxuICAgICAgICAgICAgaWYgKGNoID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgPSAnLSc7XG4gICAgICAgICAgICAgICAgbmV4dCgnLScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gJy4nO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0KCkgJiYgY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoID09PSAnZScgfHwgY2ggPT09ICdFJykge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcrJykge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnVtYmVyID0gK3N0cmluZztcbiAgICAgICAgICAgIGlmICghaXNGaW5pdGUobnVtYmVyKSkge1xuICAgICAgICAgICAgICAgIGVycm9yKCdCYWQgbnVtYmVyJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBQYXJzZSBhIHN0cmluZyB2YWx1ZS5cbiAgICAgICAgICAgIHZhciBoZXgsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBzdHJpbmcgPSAnJyxcbiAgICAgICAgICAgICAgICB1ZmZmZjtcbiAgICAgICAgICAgIC8vIFdoZW4gcGFyc2luZyBmb3Igc3RyaW5nIHZhbHVlcywgd2UgbXVzdCBsb29rIGZvciBcIiBhbmQgXFwgY2hhcmFjdGVycy5cbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd1Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVmZmZmID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhleCA9IHBhcnNlSW50KG5leHQoKSwgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRmluaXRlKGhleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVmZmZmID0gdWZmZmYgKiAxNiArIGhleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodWZmZmYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXNjYXBlZVtjaF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGVzY2FwZWVbY2hdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yKCdCYWQgc3RyaW5nJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHdoaXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBTa2lwIHdoaXRlc3BhY2UuXG4gICAgICAgICAgICB3aGlsZSAoY2ggJiYgY2ggPD0gJyAnKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB3b3JkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyB0cnVlLCBmYWxzZSwgb3IgbnVsbC5cbiAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgndCcpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCdyJyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ3UnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnZScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnZicpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCdhJyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ2wnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgncycpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCdlJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnbicpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCd1Jyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ2wnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnbCcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yKCdVbmV4cGVjdGVkIFwiJyArIGNoICsgJ1wiJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlLCAvLyBQbGFjZWhvbGRlciBmb3IgdGhlIHZhbHVlIGZ1bmN0aW9uLlxuICAgICAgICBhcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gUGFyc2UgYW4gYXJyYXkgdmFsdWUuXG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBbXTtcblxuICAgICAgICAgICAgaWYgKGNoID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCdbJyk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCddJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTsgLy8gZW1wdHkgYXJyYXlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5LnB1c2godmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCddJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnLCcpO1xuICAgICAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yKCdCYWQgYXJyYXknKTtcbiAgICAgICAgfSxcbiAgICAgICAgb2JqZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBQYXJzZSBhbiBvYmplY3QgdmFsdWUuXG4gICAgICAgICAgICB2YXIga2V5LFxuICAgICAgICAgICAgICAgIG9iamVjdCA9IHt9O1xuXG4gICAgICAgICAgICBpZiAoY2ggPT09ICd7Jykge1xuICAgICAgICAgICAgICAgIG5leHQoJ3snKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ30nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDsgLy8gZW1wdHkgb2JqZWN0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBzdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnOicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcignRHVwbGljYXRlIGtleSBcIicgKyBrZXkgKyAnXCInKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCd9Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJywnKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcignQmFkIG9iamVjdCcpO1xuICAgICAgICB9O1xuXG4gICAgdmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gUGFyc2UgYSBKU09OIHZhbHVlLiBJdCBjb3VsZCBiZSBhbiBvYmplY3QsIGFuIGFycmF5LCBhIHN0cmluZyxcbiAgICAgICAgLy8gYSBudW1iZXIsIG9yIGEgd29yZC5cbiAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdCgpO1xuICAgICAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5KCk7XG4gICAgICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZygpO1xuICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlcigpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gY2ggPj0gJzAnICYmIGNoIDw9ICc5JyA/IG51bWJlcigpIDogd29yZCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFJldHVybiB0aGUganNvbl9wYXJzZSBmdW5jdGlvbi4gSXQgd2lsbCBoYXZlIGFjY2VzcyB0byBhbGwgb2YgdGhlXG4gICAgLy8gYWJvdmUgZnVuY3Rpb25zIGFuZCB2YXJpYWJsZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIHRleHQgPSBzb3VyY2U7XG4gICAgICAgIGF0ID0gMDtcbiAgICAgICAgY2ggPSAnICc7XG4gICAgICAgIHJlc3VsdCA9IHZhbHVlKCk7XG4gICAgICAgIHdoaXRlKCk7XG4gICAgICAgIGlmIChjaCkge1xuICAgICAgICAgICAgZXJyb3IoJ1N5bnRheCBlcnJvcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufSkoKTtcblxuXy5iYXNlNjRFbmNvZGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIGI2NCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG4gICAgdmFyIG8xLCBvMiwgbzMsIGgxLCBoMiwgaDMsIGg0LCBiaXRzLCBpID0gMCxcbiAgICAgICAgYWMgPSAwLFxuICAgICAgICBlbmMgPSAnJyxcbiAgICAgICAgdG1wX2FyciA9IFtdO1xuXG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGRhdGEgPSBfLnV0ZjhFbmNvZGUoZGF0YSk7XG5cbiAgICBkbyB7IC8vIHBhY2sgdGhyZWUgb2N0ZXRzIGludG8gZm91ciBoZXhldHNcbiAgICAgICAgbzEgPSBkYXRhLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgbzIgPSBkYXRhLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgbzMgPSBkYXRhLmNoYXJDb2RlQXQoaSsrKTtcblxuICAgICAgICBiaXRzID0gbzEgPDwgMTYgfCBvMiA8PCA4IHwgbzM7XG5cbiAgICAgICAgaDEgPSBiaXRzID4+IDE4ICYgMHgzZjtcbiAgICAgICAgaDIgPSBiaXRzID4+IDEyICYgMHgzZjtcbiAgICAgICAgaDMgPSBiaXRzID4+IDYgJiAweDNmO1xuICAgICAgICBoNCA9IGJpdHMgJiAweDNmO1xuXG4gICAgICAgIC8vIHVzZSBoZXhldHMgdG8gaW5kZXggaW50byBiNjQsIGFuZCBhcHBlbmQgcmVzdWx0IHRvIGVuY29kZWQgc3RyaW5nXG4gICAgICAgIHRtcF9hcnJbYWMrK10gPSBiNjQuY2hhckF0KGgxKSArIGI2NC5jaGFyQXQoaDIpICsgYjY0LmNoYXJBdChoMykgKyBiNjQuY2hhckF0KGg0KTtcbiAgICB9IHdoaWxlIChpIDwgZGF0YS5sZW5ndGgpO1xuXG4gICAgZW5jID0gdG1wX2Fyci5qb2luKCcnKTtcblxuICAgIHN3aXRjaCAoZGF0YS5sZW5ndGggJSAzKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGVuYyA9IGVuYy5zbGljZSgwLCAtMikgKyAnPT0nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGVuYyA9IGVuYy5zbGljZSgwLCAtMSkgKyAnPSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gZW5jO1xufTtcblxuXy51dGY4RW5jb2RlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgc3RyaW5nID0gKHN0cmluZyArICcnKS5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpLnJlcGxhY2UoL1xcci9nLCAnXFxuJyk7XG5cbiAgICB2YXIgdXRmdGV4dCA9ICcnLFxuICAgICAgICBzdGFydCxcbiAgICAgICAgZW5kO1xuICAgIHZhciBzdHJpbmdsID0gMCxcbiAgICAgICAgbjtcblxuICAgIHN0YXJ0ID0gZW5kID0gMDtcbiAgICBzdHJpbmdsID0gc3RyaW5nLmxlbmd0aDtcblxuICAgIGZvciAobiA9IDA7IG4gPCBzdHJpbmdsOyBuKyspIHtcbiAgICAgICAgdmFyIGMxID0gc3RyaW5nLmNoYXJDb2RlQXQobik7XG4gICAgICAgIHZhciBlbmMgPSBudWxsO1xuXG4gICAgICAgIGlmIChjMSA8IDEyOCkge1xuICAgICAgICAgICAgZW5kKys7XG4gICAgICAgIH0gZWxzZSBpZiAoKGMxID4gMTI3KSAmJiAoYzEgPCAyMDQ4KSkge1xuICAgICAgICAgICAgZW5jID0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYzEgPj4gNikgfCAxOTIsIChjMSAmIDYzKSB8IDEyOCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbmMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjMSA+PiAxMikgfCAyMjQsICgoYzEgPj4gNikgJiA2MykgfCAxMjgsIChjMSAmIDYzKSB8IDEyOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuYyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGVuZCA+IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgdXRmdGV4dCArPSBzdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXRmdGV4dCArPSBlbmM7XG4gICAgICAgICAgICBzdGFydCA9IGVuZCA9IG4gKyAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVuZCA+IHN0YXJ0KSB7XG4gICAgICAgIHV0ZnRleHQgKz0gc3RyaW5nLnN1YnN0cmluZyhzdGFydCwgc3RyaW5nLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0ZnRleHQ7XG59O1xuXG5fLlVVSUQgPSBmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyB1c2UgbmF0aXZlIENyeXB0byBBUEkgd2hlbiBhdmFpbGFibGVcbiAgICAgICAgcmV0dXJuIHdpblsnY3J5cHRvJ11bJ3JhbmRvbVVVSUQnXSgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBmYWxsIGJhY2sgdG8gZ2VuZXJhdGluZyBvdXIgb3duIFVVSURcbiAgICAgICAgLy8gYmFzZWQgb24gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vc2N3b29kLzNiZmY0MmNjMDA1Y2MyMGFiN2VjOThmMGQ4ZTFkNTlkXG4gICAgICAgIHZhciB1dWlkID0gbmV3IEFycmF5KDM2KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzNjsgaSsrKSB7XG4gICAgICAgICAgICB1dWlkW2ldID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTYpO1xuICAgICAgICB9XG4gICAgICAgIHV1aWRbMTRdID0gNDsgLy8gc2V0IGJpdHMgMTItMTUgb2YgdGltZS1oaWdoLWFuZC12ZXJzaW9uIHRvIDAxMDBcbiAgICAgICAgdXVpZFsxOV0gPSB1dWlkWzE5XSAmPSAtNTsgLy8gc2V0IGJpdCA2IG9mIGNsb2NrLXNlcS1hbmQtcmVzZXJ2ZWQgdG8gemVyb1xuICAgICAgICB1dWlkWzE5XSA9IHV1aWRbMTldIHw9ICgxIDw8IDMpOyAvLyBzZXQgYml0IDcgb2YgY2xvY2stc2VxLWFuZC1yZXNlcnZlZCB0byBvbmVcbiAgICAgICAgdXVpZFs4XSA9IHV1aWRbMTNdID0gdXVpZFsxOF0gPSB1dWlkWzIzXSA9ICctJztcblxuICAgICAgICByZXR1cm4gXy5tYXAodXVpZCwgZnVuY3Rpb24oeCkge1xuICAgICAgICAgICAgcmV0dXJuIHgudG9TdHJpbmcoMTYpO1xuICAgICAgICB9KS5qb2luKCcnKTtcbiAgICB9XG59O1xuXG4vLyBfLmlzQmxvY2tlZFVBKClcbi8vIFRoaXMgaXMgdG8gYmxvY2sgdmFyaW91cyB3ZWIgc3BpZGVycyBmcm9tIGV4ZWN1dGluZyBvdXIgSlMgYW5kXG4vLyBzZW5kaW5nIGZhbHNlIHRyYWNraW5nIGRhdGFcbnZhciBCTE9DS0VEX1VBX1NUUlMgPSBbXG4gICAgJ2FocmVmc2JvdCcsXG4gICAgJ2FocmVmc3NpdGVhdWRpdCcsXG4gICAgJ2FtYXpvbmJvdCcsXG4gICAgJ2JhaWR1c3BpZGVyJyxcbiAgICAnYmluZ2JvdCcsXG4gICAgJ2JpbmdwcmV2aWV3JyxcbiAgICAnY2hyb21lLWxpZ2h0aG91c2UnLFxuICAgICdmYWNlYm9va2V4dGVybmFsJyxcbiAgICAncGV0YWxib3QnLFxuICAgICdwaW50ZXJlc3QnLFxuICAgICdzY3JlYW1pbmcgZnJvZycsXG4gICAgJ3lhaG9vISBzbHVycCcsXG4gICAgJ3lhbmRleCcsXG5cbiAgICAvLyBhIHdob2xlIGJ1bmNoIG9mIGdvb2ctc3BlY2lmaWMgY3Jhd2xlcnNcbiAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9zZWFyY2gvZG9jcy9hZHZhbmNlZC9jcmF3bGluZy9vdmVydmlldy1nb29nbGUtY3Jhd2xlcnNcbiAgICAnYWRzYm90LWdvb2dsZScsXG4gICAgJ2FwaXMtZ29vZ2xlJyxcbiAgICAnZHVwbGV4d2ViLWdvb2dsZScsXG4gICAgJ2ZlZWRmZXRjaGVyLWdvb2dsZScsXG4gICAgJ2dvb2dsZSBmYXZpY29uJyxcbiAgICAnZ29vZ2xlIHdlYiBwcmV2aWV3JyxcbiAgICAnZ29vZ2xlLXJlYWQtYWxvdWQnLFxuICAgICdnb29nbGVib3QnLFxuICAgICdnb29nbGV3ZWJsaWdodCcsXG4gICAgJ21lZGlhcGFydG5lcnMtZ29vZ2xlJyxcbiAgICAnc3RvcmVib3QtZ29vZ2xlJ1xuXTtcbl8uaXNCbG9ja2VkVUEgPSBmdW5jdGlvbih1YSkge1xuICAgIHZhciBpO1xuICAgIHVhID0gdWEudG9Mb3dlckNhc2UoKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgQkxPQ0tFRF9VQV9TVFJTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh1YS5pbmRleE9mKEJMT0NLRURfVUFfU1RSU1tpXSkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0PX0gZm9ybWRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nPX0gYXJnX3NlcGFyYXRvclxuICovXG5fLkhUVFBCdWlsZFF1ZXJ5ID0gZnVuY3Rpb24oZm9ybWRhdGEsIGFyZ19zZXBhcmF0b3IpIHtcbiAgICB2YXIgdXNlX3ZhbCwgdXNlX2tleSwgdG1wX2FyciA9IFtdO1xuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQoYXJnX3NlcGFyYXRvcikpIHtcbiAgICAgICAgYXJnX3NlcGFyYXRvciA9ICcmJztcbiAgICB9XG5cbiAgICBfLmVhY2goZm9ybWRhdGEsIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gICAgICAgIHVzZV92YWwgPSBlbmNvZGVVUklDb21wb25lbnQodmFsLnRvU3RyaW5nKCkpO1xuICAgICAgICB1c2Vfa2V5ID0gZW5jb2RlVVJJQ29tcG9uZW50KGtleSk7XG4gICAgICAgIHRtcF9hcnJbdG1wX2Fyci5sZW5ndGhdID0gdXNlX2tleSArICc9JyArIHVzZV92YWw7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdG1wX2Fyci5qb2luKGFyZ19zZXBhcmF0b3IpO1xufTtcblxuXy5nZXRRdWVyeVBhcmFtID0gZnVuY3Rpb24odXJsLCBwYXJhbSkge1xuICAgIC8vIEV4cGVjdHMgYSByYXcgVVJMXG5cbiAgICBwYXJhbSA9IHBhcmFtLnJlcGxhY2UoL1tbXS9nLCAnXFxcXFsnKS5yZXBsYWNlKC9bXFxdXS9nLCAnXFxcXF0nKTtcbiAgICB2YXIgcmVnZXhTID0gJ1tcXFxcPyZdJyArIHBhcmFtICsgJz0oW14mI10qKScsXG4gICAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChyZWdleFMpLFxuICAgICAgICByZXN1bHRzID0gcmVnZXguZXhlYyh1cmwpO1xuICAgIGlmIChyZXN1bHRzID09PSBudWxsIHx8IChyZXN1bHRzICYmIHR5cGVvZihyZXN1bHRzWzFdKSAhPT0gJ3N0cmluZycgJiYgcmVzdWx0c1sxXS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVzdWx0c1sxXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGRlY29kZVVSSUNvbXBvbmVudChyZXN1bHQpO1xuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgY29uc29sZSQxLmVycm9yKCdTa2lwcGluZyBkZWNvZGluZyBmb3IgbWFsZm9ybWVkIHF1ZXJ5IHBhcmFtOiAnICsgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuICAgIH1cbn07XG5cblxuLy8gXy5jb29raWVcbi8vIE1ldGhvZHMgcGFydGlhbGx5IGJvcnJvd2VkIGZyb20gcXVpcmtzbW9kZS5vcmcvanMvY29va2llcy5odG1sXG5fLmNvb2tpZSA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIG5hbWVFUSA9IG5hbWUgKyAnPSc7XG4gICAgICAgIHZhciBjYSA9IGRvY3VtZW50JDEuY29va2llLnNwbGl0KCc7Jyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2EubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjID0gY2FbaV07XG4gICAgICAgICAgICB3aGlsZSAoYy5jaGFyQXQoMCkgPT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgYyA9IGMuc3Vic3RyaW5nKDEsIGMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjLmluZGV4T2YobmFtZUVRKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoYy5zdWJzdHJpbmcobmFtZUVRLmxlbmd0aCwgYy5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgcGFyc2U6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIGNvb2tpZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvb2tpZSA9IF8uSlNPTkRlY29kZShfLmNvb2tpZS5nZXQobmFtZSkpIHx8IHt9O1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29va2llO1xuICAgIH0sXG5cbiAgICBzZXRfc2Vjb25kczogZnVuY3Rpb24obmFtZSwgdmFsdWUsIHNlY29uZHMsIGlzX2Nyb3NzX3N1YmRvbWFpbiwgaXNfc2VjdXJlLCBpc19jcm9zc19zaXRlLCBkb21haW5fb3ZlcnJpZGUpIHtcbiAgICAgICAgdmFyIGNkb21haW4gPSAnJyxcbiAgICAgICAgICAgIGV4cGlyZXMgPSAnJyxcbiAgICAgICAgICAgIHNlY3VyZSA9ICcnO1xuXG4gICAgICAgIGlmIChkb21haW5fb3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGNkb21haW4gPSAnOyBkb21haW49JyArIGRvbWFpbl9vdmVycmlkZTtcbiAgICAgICAgfSBlbHNlIGlmIChpc19jcm9zc19zdWJkb21haW4pIHtcbiAgICAgICAgICAgIHZhciBkb21haW4gPSBleHRyYWN0X2RvbWFpbihkb2N1bWVudCQxLmxvY2F0aW9uLmhvc3RuYW1lKTtcbiAgICAgICAgICAgIGNkb21haW4gPSBkb21haW4gPyAnOyBkb21haW49LicgKyBkb21haW4gOiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWNvbmRzKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyAoc2Vjb25kcyAqIDEwMDApKTtcbiAgICAgICAgICAgIGV4cGlyZXMgPSAnOyBleHBpcmVzPScgKyBkYXRlLnRvR01UU3RyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNfY3Jvc3Nfc2l0ZSkge1xuICAgICAgICAgICAgaXNfc2VjdXJlID0gdHJ1ZTtcbiAgICAgICAgICAgIHNlY3VyZSA9ICc7IFNhbWVTaXRlPU5vbmUnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc19zZWN1cmUpIHtcbiAgICAgICAgICAgIHNlY3VyZSArPSAnOyBzZWN1cmUnO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQkMS5jb29raWUgPSBuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSArIGV4cGlyZXMgKyAnOyBwYXRoPS8nICsgY2RvbWFpbiArIHNlY3VyZTtcbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgZGF5cywgaXNfY3Jvc3Nfc3ViZG9tYWluLCBpc19zZWN1cmUsIGlzX2Nyb3NzX3NpdGUsIGRvbWFpbl9vdmVycmlkZSkge1xuICAgICAgICB2YXIgY2RvbWFpbiA9ICcnLCBleHBpcmVzID0gJycsIHNlY3VyZSA9ICcnO1xuXG4gICAgICAgIGlmIChkb21haW5fb3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGNkb21haW4gPSAnOyBkb21haW49JyArIGRvbWFpbl9vdmVycmlkZTtcbiAgICAgICAgfSBlbHNlIGlmIChpc19jcm9zc19zdWJkb21haW4pIHtcbiAgICAgICAgICAgIHZhciBkb21haW4gPSBleHRyYWN0X2RvbWFpbihkb2N1bWVudCQxLmxvY2F0aW9uLmhvc3RuYW1lKTtcbiAgICAgICAgICAgIGNkb21haW4gPSBkb21haW4gPyAnOyBkb21haW49LicgKyBkb21haW4gOiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXlzKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyAoZGF5cyAqIDI0ICogNjAgKiA2MCAqIDEwMDApKTtcbiAgICAgICAgICAgIGV4cGlyZXMgPSAnOyBleHBpcmVzPScgKyBkYXRlLnRvR01UU3RyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNfY3Jvc3Nfc2l0ZSkge1xuICAgICAgICAgICAgaXNfc2VjdXJlID0gdHJ1ZTtcbiAgICAgICAgICAgIHNlY3VyZSA9ICc7IFNhbWVTaXRlPU5vbmUnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc19zZWN1cmUpIHtcbiAgICAgICAgICAgIHNlY3VyZSArPSAnOyBzZWN1cmUnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5ld19jb29raWVfdmFsID0gbmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgKyBleHBpcmVzICsgJzsgcGF0aD0vJyArIGNkb21haW4gKyBzZWN1cmU7XG4gICAgICAgIGRvY3VtZW50JDEuY29va2llID0gbmV3X2Nvb2tpZV92YWw7XG4gICAgICAgIHJldHVybiBuZXdfY29va2llX3ZhbDtcbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihuYW1lLCBpc19jcm9zc19zdWJkb21haW4sIGRvbWFpbl9vdmVycmlkZSkge1xuICAgICAgICBfLmNvb2tpZS5zZXQobmFtZSwgJycsIC0xLCBpc19jcm9zc19zdWJkb21haW4sIGZhbHNlLCBmYWxzZSwgZG9tYWluX292ZXJyaWRlKTtcbiAgICB9XG59O1xuXG52YXIgX3Rlc3RTdG9yYWdlU3VwcG9ydGVkID0gZnVuY3Rpb24gKHN0b3JhZ2UpIHtcbiAgICB2YXIgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICB2YXIga2V5ID0gJ19fbXBsc3NfJyArIGNoZWFwX2d1aWQoOCksXG4gICAgICAgICAgICB2YWwgPSAneHl6JztcbiAgICAgICAgc3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsKTtcbiAgICAgICAgaWYgKHN0b3JhZ2UuZ2V0SXRlbShrZXkpICE9PSB2YWwpIHtcbiAgICAgICAgICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cHBvcnRlZDtcbn07XG5cbnZhciBfbG9jYWxTdG9yYWdlU3VwcG9ydGVkID0gbnVsbDtcbnZhciBsb2NhbFN0b3JhZ2VTdXBwb3J0ZWQgPSBmdW5jdGlvbihzdG9yYWdlLCBmb3JjZUNoZWNrKSB7XG4gICAgaWYgKF9sb2NhbFN0b3JhZ2VTdXBwb3J0ZWQgIT09IG51bGwgJiYgIWZvcmNlQ2hlY2spIHtcbiAgICAgICAgcmV0dXJuIF9sb2NhbFN0b3JhZ2VTdXBwb3J0ZWQ7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxTdG9yYWdlU3VwcG9ydGVkID0gX3Rlc3RTdG9yYWdlU3VwcG9ydGVkKHN0b3JhZ2UgfHwgd2luLmxvY2FsU3RvcmFnZSk7XG59O1xuXG52YXIgX3Nlc3Npb25TdG9yYWdlU3VwcG9ydGVkID0gbnVsbDtcbnZhciBzZXNzaW9uU3RvcmFnZVN1cHBvcnRlZCA9IGZ1bmN0aW9uKHN0b3JhZ2UsIGZvcmNlQ2hlY2spIHtcbiAgICBpZiAoX3Nlc3Npb25TdG9yYWdlU3VwcG9ydGVkICE9PSBudWxsICYmICFmb3JjZUNoZWNrKSB7XG4gICAgICAgIHJldHVybiBfc2Vzc2lvblN0b3JhZ2VTdXBwb3J0ZWQ7XG4gICAgfVxuICAgIHJldHVybiBfc2Vzc2lvblN0b3JhZ2VTdXBwb3J0ZWQgPSBfdGVzdFN0b3JhZ2VTdXBwb3J0ZWQoc3RvcmFnZSB8fCB3aW4uc2Vzc2lvblN0b3JhZ2UpO1xufTtcblxuZnVuY3Rpb24gX3N0b3JhZ2VXcmFwcGVyKHN0b3JhZ2UsIG5hbWUsIGlzX3N1cHBvcnRlZF9mbikge1xuICAgIHZhciBsb2dfZXJyb3IgPSBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgY29uc29sZSQxLmVycm9yKG5hbWUgKyAnIGVycm9yOiAnICsgbXNnKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNfc3VwcG9ydGVkOiBmdW5jdGlvbihmb3JjZUNoZWNrKSB7XG4gICAgICAgICAgICB2YXIgc3VwcG9ydGVkID0gaXNfc3VwcG9ydGVkX2ZuKHN0b3JhZ2UsIGZvcmNlQ2hlY2spO1xuICAgICAgICAgICAgaWYgKCFzdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlJDEuZXJyb3IobmFtZSArICcgdW5zdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdXBwb3J0ZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBsb2dfZXJyb3IsXG4gICAgICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGxvZ19lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uSlNPTkRlY29kZShzdG9yYWdlLmdldEl0ZW0oa2V5KSkgfHwge307XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBub29wXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGxvZ19lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGxvZ19lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cblxuXy5sb2NhbFN0b3JhZ2UgPSBfc3RvcmFnZVdyYXBwZXIod2luLmxvY2FsU3RvcmFnZSwgJ2xvY2FsU3RvcmFnZScsIGxvY2FsU3RvcmFnZVN1cHBvcnRlZCk7XG5fLnNlc3Npb25TdG9yYWdlID0gX3N0b3JhZ2VXcmFwcGVyKHdpbi5zZXNzaW9uU3RvcmFnZSwgJ3Nlc3Npb25TdG9yYWdlJywgc2Vzc2lvblN0b3JhZ2VTdXBwb3J0ZWQpO1xuXG5fLnJlZ2lzdGVyX2V2ZW50ID0gKGZ1bmN0aW9uKCkge1xuICAgIC8vIHdyaXR0ZW4gYnkgRGVhbiBFZHdhcmRzLCAyMDA1XG4gICAgLy8gd2l0aCBpbnB1dCBmcm9tIFRpbm8gWmlqZGVsIC0gY3Jpc3BAeHM0YWxsLm5sXG4gICAgLy8gd2l0aCBpbnB1dCBmcm9tIENhcmwgU3ZlcnJlIC0gbWFpbEBjYXJsc3ZlcnJlLmNvbVxuICAgIC8vIHdpdGggaW5wdXQgZnJvbSBNaXhwYW5lbFxuICAgIC8vIGh0dHA6Ly9kZWFuLmVkd2FyZHMubmFtZS93ZWJsb2cvMjAwNS8xMC9hZGQtZXZlbnQvXG4gICAgLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMTkzMDQ0MFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oLi4uKil9IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvbGRTY2hvb2xcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1c2VDYXB0dXJlXG4gICAgICovXG4gICAgdmFyIHJlZ2lzdGVyX2V2ZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgb2xkU2Nob29sLCB1c2VDYXB0dXJlKSB7XG4gICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgICAgY29uc29sZSQxLmVycm9yKCdObyB2YWxpZCBlbGVtZW50IHByb3ZpZGVkIHRvIHJlZ2lzdGVyX2V2ZW50Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxlbWVudC5hZGRFdmVudExpc3RlbmVyICYmICFvbGRTY2hvb2wpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCAhIXVzZUNhcHR1cmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG9udHlwZSA9ICdvbicgKyB0eXBlO1xuICAgICAgICAgICAgdmFyIG9sZF9oYW5kbGVyID0gZWxlbWVudFtvbnR5cGVdOyAvLyBjYW4gYmUgdW5kZWZpbmVkXG4gICAgICAgICAgICBlbGVtZW50W29udHlwZV0gPSBtYWtlSGFuZGxlcihlbGVtZW50LCBoYW5kbGVyLCBvbGRfaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWFrZUhhbmRsZXIoZWxlbWVudCwgbmV3X2hhbmRsZXIsIG9sZF9oYW5kbGVycykge1xuICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudCA9IGV2ZW50IHx8IGZpeEV2ZW50KHdpbi5ldmVudCk7XG5cbiAgICAgICAgICAgIC8vIHRoaXMgYmFzaWNhbGx5IGhhcHBlbnMgaW4gZmlyZWZveCB3aGVuZXZlciBhbm90aGVyIHNjcmlwdFxuICAgICAgICAgICAgLy8gb3ZlcndyaXRlcyB0aGUgb25sb2FkIGNhbGxiYWNrIGFuZCBkb2Vzbid0IHBhc3MgdGhlIGV2ZW50XG4gICAgICAgICAgICAvLyBvYmplY3QgdG8gcHJldmlvdXNseSBkZWZpbmVkIGNhbGxiYWNrcy4gIEFsbCB0aGUgYnJvd3NlcnNcbiAgICAgICAgICAgIC8vIHRoYXQgZG9uJ3QgZGVmaW5lIHdpbmRvdy5ldmVudCBpbXBsZW1lbnQgYWRkRXZlbnRMaXN0ZW5lclxuICAgICAgICAgICAgLy8gc28gdGhlIGRvbV9sb2FkZWQgaGFuZGxlciB3aWxsIHN0aWxsIGJlIGZpcmVkIGFzIHVzdWFsLlxuICAgICAgICAgICAgaWYgKCFldmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXQgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZF9yZXN1bHQsIG5ld19yZXN1bHQ7XG5cbiAgICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24ob2xkX2hhbmRsZXJzKSkge1xuICAgICAgICAgICAgICAgIG9sZF9yZXN1bHQgPSBvbGRfaGFuZGxlcnMoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3X3Jlc3VsdCA9IG5ld19oYW5kbGVyLmNhbGwoZWxlbWVudCwgZXZlbnQpO1xuXG4gICAgICAgICAgICBpZiAoKGZhbHNlID09PSBvbGRfcmVzdWx0KSB8fCAoZmFsc2UgPT09IG5ld19yZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGhhbmRsZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZml4RXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCA9IGZpeEV2ZW50LnByZXZlbnREZWZhdWx0O1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uID0gZml4RXZlbnQuc3RvcFByb3BhZ2F0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICB9XG4gICAgZml4RXZlbnQucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgIH07XG4gICAgZml4RXZlbnQuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHJlZ2lzdGVyX2V2ZW50O1xufSkoKTtcblxuXG52YXIgVE9LRU5fTUFUQ0hfUkVHRVggPSBuZXcgUmVnRXhwKCdeKFxcXFx3KilcXFxcWyhcXFxcdyspKFs9flxcXFx8XFxcXF5cXFxcJFxcXFwqXT8pPT9cIj8oW15cXFxcXVwiXSopXCI/XFxcXF0kJyk7XG5cbl8uZG9tX3F1ZXJ5ID0gKGZ1bmN0aW9uKCkge1xuICAgIC8qIGRvY3VtZW50LmdldEVsZW1lbnRzQnlTZWxlY3RvcihzZWxlY3RvcilcbiAgICAtIHJldHVybnMgYW4gYXJyYXkgb2YgZWxlbWVudCBvYmplY3RzIGZyb20gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAgICBtYXRjaGluZyB0aGUgQ1NTIHNlbGVjdG9yLiBTZWxlY3RvcnMgY2FuIGNvbnRhaW4gZWxlbWVudCBuYW1lcyxcbiAgICBjbGFzcyBuYW1lcyBhbmQgaWRzIGFuZCBjYW4gYmUgbmVzdGVkLiBGb3IgZXhhbXBsZTpcblxuICAgIGVsZW1lbnRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVNlbGVjdG9yKCdkaXYjbWFpbiBwIGEuZXh0ZXJuYWwnKVxuXG4gICAgV2lsbCByZXR1cm4gYW4gYXJyYXkgb2YgYWxsICdhJyBlbGVtZW50cyB3aXRoICdleHRlcm5hbCcgaW4gdGhlaXJcbiAgICBjbGFzcyBhdHRyaWJ1dGUgdGhhdCBhcmUgY29udGFpbmVkIGluc2lkZSAncCcgZWxlbWVudHMgdGhhdCBhcmVcbiAgICBjb250YWluZWQgaW5zaWRlIHRoZSAnZGl2JyBlbGVtZW50IHdoaWNoIGhhcyBpZD1cIm1haW5cIlxuXG4gICAgTmV3IGluIHZlcnNpb24gMC40OiBTdXBwb3J0IGZvciBDU1MyIGFuZCBDU1MzIGF0dHJpYnV0ZSBzZWxlY3RvcnM6XG4gICAgU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cbiAgICBWZXJzaW9uIDAuNCAtIFNpbW9uIFdpbGxpc29uLCBNYXJjaCAyNXRoIDIwMDNcbiAgICAtLSBXb3JrcyBpbiBQaG9lbml4IDAuNSwgTW96aWxsYSAxLjMsIE9wZXJhIDcsIEludGVybmV0IEV4cGxvcmVyIDYsIEludGVybmV0IEV4cGxvcmVyIDUgb24gV2luZG93c1xuICAgIC0tIE9wZXJhIDcgZmFpbHNcblxuICAgIFZlcnNpb24gMC41IC0gQ2FybCBTdmVycmUsIEphbiA3dGggMjAxM1xuICAgIC0tIE5vdyB1c2VzIGpRdWVyeS1lc3F1ZSBgaGFzQ2xhc3NgIGZvciB0ZXN0aW5nIGNsYXNzIG5hbWVcbiAgICBlcXVhbGl0eS4gIFRoaXMgZml4ZXMgYSBidWcgcmVsYXRlZCB0byAnLScgY2hhcmFjdGVycyBiZWluZ1xuICAgIGNvbnNpZGVyZWQgbm90IHBhcnQgb2YgYSAnd29yZCcgaW4gcmVnZXguXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIGdldEFsbENoaWxkcmVuKGUpIHtcbiAgICAgICAgLy8gUmV0dXJucyBhbGwgY2hpbGRyZW4gb2YgZWxlbWVudC4gV29ya2Fyb3VuZCByZXF1aXJlZCBmb3IgSUU1L1dpbmRvd3MuIFVnaC5cbiAgICAgICAgcmV0dXJuIGUuYWxsID8gZS5hbGwgOiBlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJyk7XG4gICAgfVxuXG4gICAgdmFyIGJhZF93aGl0ZXNwYWNlID0gL1tcXHRcXHJcXG5dL2c7XG5cbiAgICBmdW5jdGlvbiBoYXNDbGFzcyhlbGVtLCBzZWxlY3Rvcikge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gJyAnICsgc2VsZWN0b3IgKyAnICc7XG4gICAgICAgIHJldHVybiAoKCcgJyArIGVsZW0uY2xhc3NOYW1lICsgJyAnKS5yZXBsYWNlKGJhZF93aGl0ZXNwYWNlLCAnICcpLmluZGV4T2YoY2xhc3NOYW1lKSA+PSAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFbGVtZW50c0J5U2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBmYWlsIGdyYWNlZnVsbHkgaW4gbGVzc2VyIGJyb3dzZXJzXG4gICAgICAgIGlmICghZG9jdW1lbnQkMS5nZXRFbGVtZW50c0J5VGFnTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNwbGl0IHNlbGVjdG9yIGluIHRvIHRva2Vuc1xuICAgICAgICB2YXIgdG9rZW5zID0gc2VsZWN0b3Iuc3BsaXQoJyAnKTtcbiAgICAgICAgdmFyIHRva2VuLCBiaXRzLCB0YWdOYW1lLCBmb3VuZCwgZm91bmRDb3VudCwgaSwgaiwgaywgZWxlbWVudHMsIGN1cnJlbnRDb250ZXh0SW5kZXg7XG4gICAgICAgIHZhciBjdXJyZW50Q29udGV4dCA9IFtkb2N1bWVudCQxXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV0ucmVwbGFjZSgvXlxccysvLCAnJykucmVwbGFjZSgvXFxzKyQvLCAnJyk7XG4gICAgICAgICAgICBpZiAodG9rZW4uaW5kZXhPZignIycpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBUb2tlbiBpcyBhbiBJRCBzZWxlY3RvclxuICAgICAgICAgICAgICAgIGJpdHMgPSB0b2tlbi5zcGxpdCgnIycpO1xuICAgICAgICAgICAgICAgIHRhZ05hbWUgPSBiaXRzWzBdO1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IGJpdHNbMV07XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudCQxLmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoIWVsZW1lbnQgfHwgKHRhZ05hbWUgJiYgZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9IHRhZ05hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQgbm90IGZvdW5kIG9yIHRhZyB3aXRoIHRoYXQgSUQgbm90IGZvdW5kLCByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTZXQgY3VycmVudENvbnRleHQgdG8gY29udGFpbiBqdXN0IHRoaXMgZWxlbWVudFxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gW2VsZW1lbnRdO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRvIG5leHQgdG9rZW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbi5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFRva2VuIGNvbnRhaW5zIGEgY2xhc3Mgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICBiaXRzID0gdG9rZW4uc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICB0YWdOYW1lID0gYml0c1swXTtcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gYml0c1sxXTtcbiAgICAgICAgICAgICAgICBpZiAoIXRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFnTmFtZSA9ICcqJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gR2V0IGVsZW1lbnRzIG1hdGNoaW5nIHRhZywgZmlsdGVyIHRoZW0gZm9yIGNsYXNzIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgZm91bmQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3VuZENvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY3VycmVudENvbnRleHQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZ05hbWUgPT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IGdldEFsbENoaWxkcmVuKGN1cnJlbnRDb250ZXh0W2pdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gY3VycmVudENvbnRleHRbal0uZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGVsZW1lbnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFtmb3VuZENvdW50KytdID0gZWxlbWVudHNba107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBbXTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZm91bmQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kW2pdLmNsYXNzTmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgXy5pc1N0cmluZyhmb3VuZFtqXS5jbGFzc05hbWUpICYmIC8vIHNvbWUgU1ZHIGVsZW1lbnRzIGhhdmUgY2xhc3NOYW1lcyB3aGljaCBhcmUgbm90IHN0cmluZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NsYXNzKGZvdW5kW2pdLCBjbGFzc05hbWUpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRleHRbY3VycmVudENvbnRleHRJbmRleCsrXSA9IGZvdW5kW2pdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRvIG5leHQgdG9rZW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvZGUgdG8gZGVhbCB3aXRoIGF0dHJpYnV0ZSBzZWxlY3RvcnNcbiAgICAgICAgICAgIHZhciB0b2tlbl9tYXRjaCA9IHRva2VuLm1hdGNoKFRPS0VOX01BVENIX1JFR0VYKTtcbiAgICAgICAgICAgIGlmICh0b2tlbl9tYXRjaCkge1xuICAgICAgICAgICAgICAgIHRhZ05hbWUgPSB0b2tlbl9tYXRjaFsxXTtcbiAgICAgICAgICAgICAgICB2YXIgYXR0ck5hbWUgPSB0b2tlbl9tYXRjaFsyXTtcbiAgICAgICAgICAgICAgICB2YXIgYXR0ck9wZXJhdG9yID0gdG9rZW5fbWF0Y2hbM107XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJWYWx1ZSA9IHRva2VuX21hdGNoWzRdO1xuICAgICAgICAgICAgICAgIGlmICghdGFnTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0YWdOYW1lID0gJyonO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBHcmFiIGFsbCBvZiB0aGUgdGFnTmFtZSBlbGVtZW50cyB3aXRoaW4gY3VycmVudCBjb250ZXh0XG4gICAgICAgICAgICAgICAgZm91bmQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3VuZENvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY3VycmVudENvbnRleHQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZ05hbWUgPT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IGdldEFsbENoaWxkcmVuKGN1cnJlbnRDb250ZXh0W2pdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gY3VycmVudENvbnRleHRbal0uZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGVsZW1lbnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFtmb3VuZENvdW50KytdID0gZWxlbWVudHNba107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBbXTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgY2hlY2tGdW5jdGlvbjsgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHVzZWQgdG8gZmlsdGVyIHRoZSBlbGVtZW50c1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYXR0ck9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJz0nOiAvLyBFcXVhbGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tGdW5jdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKSA9PSBhdHRyVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd+JzogLy8gTWF0Y2ggb25lIG9mIHNwYWNlIHNlcGVyYXRlZCB3b3Jkc1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tGdW5jdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKS5tYXRjaChuZXcgUmVnRXhwKCdcXFxcYicgKyBhdHRyVmFsdWUgKyAnXFxcXGInKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd8JzogLy8gTWF0Y2ggc3RhcnQgd2l0aCB2YWx1ZSBmb2xsb3dlZCBieSBvcHRpb25hbCBoeXBoZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkubWF0Y2gobmV3IFJlZ0V4cCgnXicgKyBhdHRyVmFsdWUgKyAnLT8nKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdeJzogLy8gTWF0Y2ggc3RhcnRzIHdpdGggdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkuaW5kZXhPZihhdHRyVmFsdWUpID09PSAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnJCc6IC8vIE1hdGNoIGVuZHMgd2l0aCB2YWx1ZSAtIGZhaWxzIHdpdGggXCJXYXJuaW5nXCIgaW4gT3BlcmEgN1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tGdW5jdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKS5sYXN0SW5kZXhPZihhdHRyVmFsdWUpID09IGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKS5sZW5ndGggLSBhdHRyVmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnKic6IC8vIE1hdGNoIGVuZHMgd2l0aCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tGdW5jdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKS5pbmRleE9mKGF0dHJWYWx1ZSkgPiAtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBKdXN0IHRlc3QgZm9yIGV4aXN0ZW5jZSBvZiBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gW107XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRleHRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGZvdW5kLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGVja0Z1bmN0aW9uKGZvdW5kW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRleHRbY3VycmVudENvbnRleHRJbmRleCsrXSA9IGZvdW5kW2pdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGFsZXJ0KCdBdHRyaWJ1dGUgU2VsZWN0b3I6ICcrdGFnTmFtZSsnICcrYXR0ck5hbWUrJyAnK2F0dHJPcGVyYXRvcisnICcrYXR0clZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gU2tpcCB0byBuZXh0IHRva2VuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgdG9rZW4gaXMgSlVTVCBhbiBlbGVtZW50IChub3QgYSBjbGFzcyBvciBJRCBzZWxlY3RvcilcbiAgICAgICAgICAgIHRhZ05hbWUgPSB0b2tlbjtcbiAgICAgICAgICAgIGZvdW5kID0gW107XG4gICAgICAgICAgICBmb3VuZENvdW50ID0gMDtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjdXJyZW50Q29udGV4dC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gY3VycmVudENvbnRleHRbal0uZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnTmFtZSk7XG4gICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGVsZW1lbnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kW2ZvdW5kQ291bnQrK10gPSBlbGVtZW50c1trXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Q29udGV4dCA9IGZvdW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50Q29udGV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgaWYgKF8uaXNFbGVtZW50KHF1ZXJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIFtxdWVyeV07XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdChxdWVyeSkgJiYgIV8uaXNVbmRlZmluZWQocXVlcnkubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdldEVsZW1lbnRzQnlTZWxlY3Rvci5jYWxsKHRoaXMsIHF1ZXJ5KTtcbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuXG52YXIgQ0FNUEFJR05fS0VZV09SRFMgPSBbJ3V0bV9zb3VyY2UnLCAndXRtX21lZGl1bScsICd1dG1fY2FtcGFpZ24nLCAndXRtX2NvbnRlbnQnLCAndXRtX3Rlcm0nLCAndXRtX2lkJywgJ3V0bV9zb3VyY2VfcGxhdGZvcm0nLCd1dG1fY2FtcGFpZ25faWQnLCAndXRtX2NyZWF0aXZlX2Zvcm1hdCcsICd1dG1fbWFya2V0aW5nX3RhY3RpYyddO1xudmFyIENMSUNLX0lEUyA9IFsnZGNsaWQnLCAnZmJjbGlkJywgJ2djbGlkJywgJ2tvX2NsaWNrX2lkJywgJ2xpX2ZhdF9pZCcsICdtc2Nsa2lkJywgJ3NjY2lkJywgJ3R0Y2xpZCcsICd0d2NsaWQnLCAnd2JyYWlkJ107XG5cbl8uaW5mbyA9IHtcbiAgICBjYW1wYWlnblBhcmFtczogZnVuY3Rpb24oZGVmYXVsdF92YWx1ZSkge1xuICAgICAgICB2YXIga3cgPSAnJyxcbiAgICAgICAgICAgIHBhcmFtcyA9IHt9O1xuICAgICAgICBfLmVhY2goQ0FNUEFJR05fS0VZV09SRFMsIGZ1bmN0aW9uKGt3a2V5KSB7XG4gICAgICAgICAgICBrdyA9IF8uZ2V0UXVlcnlQYXJhbShkb2N1bWVudCQxLlVSTCwga3drZXkpO1xuICAgICAgICAgICAgaWYgKGt3Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHBhcmFtc1trd2tleV0gPSBrdztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVmYXVsdF92YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zW2t3a2V5XSA9IGRlZmF1bHRfdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfSxcblxuICAgIGNsaWNrUGFyYW1zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGlkID0gJycsXG4gICAgICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgICAgXy5lYWNoKENMSUNLX0lEUywgZnVuY3Rpb24oaWRrZXkpIHtcbiAgICAgICAgICAgIGlkID0gXy5nZXRRdWVyeVBhcmFtKGRvY3VtZW50JDEuVVJMLCBpZGtleSk7XG4gICAgICAgICAgICBpZiAoaWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zW2lka2V5XSA9IGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH0sXG5cbiAgICBtYXJrZXRpbmdQYXJhbXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXy5leHRlbmQoXy5pbmZvLmNhbXBhaWduUGFyYW1zKCksIF8uaW5mby5jbGlja1BhcmFtcygpKTtcbiAgICB9LFxuXG4gICAgc2VhcmNoRW5naW5lOiBmdW5jdGlvbihyZWZlcnJlcikge1xuICAgICAgICBpZiAocmVmZXJyZXIuc2VhcmNoKCdodHRwcz86Ly8oLiopZ29vZ2xlLihbXi8/XSopJykgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnZ29vZ2xlJztcbiAgICAgICAgfSBlbHNlIGlmIChyZWZlcnJlci5zZWFyY2goJ2h0dHBzPzovLyguKiliaW5nLmNvbScpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2JpbmcnO1xuICAgICAgICB9IGVsc2UgaWYgKHJlZmVycmVyLnNlYXJjaCgnaHR0cHM/Oi8vKC4qKXlhaG9vLmNvbScpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3lhaG9vJztcbiAgICAgICAgfSBlbHNlIGlmIChyZWZlcnJlci5zZWFyY2goJ2h0dHBzPzovLyguKilkdWNrZHVja2dvLmNvbScpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2R1Y2tkdWNrZ28nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2VhcmNoSW5mbzogZnVuY3Rpb24ocmVmZXJyZXIpIHtcbiAgICAgICAgdmFyIHNlYXJjaCA9IF8uaW5mby5zZWFyY2hFbmdpbmUocmVmZXJyZXIpLFxuICAgICAgICAgICAgcGFyYW0gPSAoc2VhcmNoICE9ICd5YWhvbycpID8gJ3EnIDogJ3AnLFxuICAgICAgICAgICAgcmV0ID0ge307XG5cbiAgICAgICAgaWYgKHNlYXJjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0Wyckc2VhcmNoX2VuZ2luZSddID0gc2VhcmNoO1xuXG4gICAgICAgICAgICB2YXIga2V5d29yZCA9IF8uZ2V0UXVlcnlQYXJhbShyZWZlcnJlciwgcGFyYW0pO1xuICAgICAgICAgICAgaWYgKGtleXdvcmQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0WydtcF9rZXl3b3JkJ10gPSBrZXl3b3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBkZXRlY3RzIHdoaWNoIGJyb3dzZXIgaXMgcnVubmluZyB0aGlzIHNjcmlwdC5cbiAgICAgKiBUaGUgb3JkZXIgb2YgdGhlIGNoZWNrcyBhcmUgaW1wb3J0YW50IHNpbmNlIG1hbnkgdXNlciBhZ2VudHNcbiAgICAgKiBpbmNsdWRlIGtleSB3b3JkcyB1c2VkIGluIGxhdGVyIGNoZWNrcy5cbiAgICAgKi9cbiAgICBicm93c2VyOiBmdW5jdGlvbih1c2VyX2FnZW50LCB2ZW5kb3IsIG9wZXJhKSB7XG4gICAgICAgIHZlbmRvciA9IHZlbmRvciB8fCAnJzsgLy8gdmVuZG9yIGlzIHVuZGVmaW5lZCBmb3IgYXQgbGVhc3QgSUU5XG4gICAgICAgIGlmIChvcGVyYSB8fCBfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICcgT1BSLycpKSB7XG4gICAgICAgICAgICBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnTWluaScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdPcGVyYSBNaW5pJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnT3BlcmEnO1xuICAgICAgICB9IGVsc2UgaWYgKC8oQmxhY2tCZXJyeXxQbGF5Qm9va3xCQjEwKS9pLnRlc3QodXNlcl9hZ2VudCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnQmxhY2tCZXJyeSc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnSUVNb2JpbGUnKSB8fCBfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdXUERlc2t0b3AnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdJbnRlcm5ldCBFeHBsb3JlciBNb2JpbGUnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ1NhbXN1bmdCcm93c2VyLycpKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5zYW1zdW5nLmNvbS9pbnRlcm5ldC91c2VyLWFnZW50LXN0cmluZy1mb3JtYXRcbiAgICAgICAgICAgIHJldHVybiAnU2Ftc3VuZyBJbnRlcm5ldCc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnRWRnZScpIHx8IF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0VkZy8nKSkge1xuICAgICAgICAgICAgcmV0dXJuICdNaWNyb3NvZnQgRWRnZSc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnRkJJT1MnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdGYWNlYm9vayBNb2JpbGUnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ1doYWxlLycpKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3VzZXItYWdlbnRzLm5ldC9icm93c2Vycy93aGFsZS1icm93c2VyXG4gICAgICAgICAgICByZXR1cm4gJ1doYWxlIEJyb3dzZXInO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0Nocm9tZScpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0Nocm9tZSc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnQ3JpT1MnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdDaHJvbWUgaU9TJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdVQ1dFQicpIHx8IF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ1VDQnJvd3NlcicpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1VDIEJyb3dzZXInO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0Z4aU9TJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnRmlyZWZveCBpT1MnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModmVuZG9yLCAnQXBwbGUnKSkge1xuICAgICAgICAgICAgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ01vYmlsZScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdNb2JpbGUgU2FmYXJpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnU2FmYXJpJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdBbmRyb2lkJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnQW5kcm9pZCBNb2JpbGUnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0tvbnF1ZXJvcicpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0tvbnF1ZXJvcic7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnRmlyZWZveCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0ZpcmVmb3gnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ01TSUUnKSB8fCBfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdUcmlkZW50LycpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0ludGVybmV0IEV4cGxvcmVyJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdHZWNrbycpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ01vemlsbGEnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gZGV0ZWN0cyB3aGljaCBicm93c2VyIHZlcnNpb24gaXMgcnVubmluZyB0aGlzIHNjcmlwdCxcbiAgICAgKiBwYXJzaW5nIG1ham9yIGFuZCBtaW5vciB2ZXJzaW9uIChlLmcuLCA0Mi4xKS4gVXNlciBhZ2VudCBzdHJpbmdzIGZyb206XG4gICAgICogaHR0cDovL3d3dy51c2VyYWdlbnRzdHJpbmcuY29tL3BhZ2VzL3VzZXJhZ2VudHN0cmluZy5waHBcbiAgICAgKi9cbiAgICBicm93c2VyVmVyc2lvbjogZnVuY3Rpb24odXNlckFnZW50LCB2ZW5kb3IsIG9wZXJhKSB7XG4gICAgICAgIHZhciBicm93c2VyID0gXy5pbmZvLmJyb3dzZXIodXNlckFnZW50LCB2ZW5kb3IsIG9wZXJhKTtcbiAgICAgICAgdmFyIHZlcnNpb25SZWdleHMgPSB7XG4gICAgICAgICAgICAnSW50ZXJuZXQgRXhwbG9yZXIgTW9iaWxlJzogL3J2OihcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ01pY3Jvc29mdCBFZGdlJzogL0VkZ2U/XFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnQ2hyb21lJzogL0Nocm9tZVxcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ0Nocm9tZSBpT1MnOiAvQ3JpT1NcXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdVQyBCcm93c2VyJyA6IC8oVUNCcm93c2VyfFVDV0VCKVxcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ1NhZmFyaSc6IC9WZXJzaW9uXFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnTW9iaWxlIFNhZmFyaSc6IC9WZXJzaW9uXFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnT3BlcmEnOiAvKE9wZXJhfE9QUilcXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdGaXJlZm94JzogL0ZpcmVmb3hcXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdGaXJlZm94IGlPUyc6IC9GeGlPU1xcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ0tvbnF1ZXJvcic6IC9Lb25xdWVyb3I6KFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnQmxhY2tCZXJyeSc6IC9CbGFja0JlcnJ5IChcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ0FuZHJvaWQgTW9iaWxlJzogL2FuZHJvaWRcXHMoXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdTYW1zdW5nIEludGVybmV0JzogL1NhbXN1bmdCcm93c2VyXFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnSW50ZXJuZXQgRXhwbG9yZXInOiAvKHJ2OnxNU0lFICkoXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdNb3ppbGxhJzogL3J2OihcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ1doYWxlIEJyb3dzZXInOiAvV2hhbGVcXC8oXFxkKyhcXC5cXGQrKT8pL1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVnZXggPSB2ZXJzaW9uUmVnZXhzW2Jyb3dzZXJdO1xuICAgICAgICBpZiAocmVnZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hdGNoZXMgPSB1c2VyQWdlbnQubWF0Y2gocmVnZXgpO1xuICAgICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAyXSk7XG4gICAgfSxcblxuICAgIG9zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGEgPSB1c2VyQWdlbnQ7XG4gICAgICAgIGlmICgvV2luZG93cy9pLnRlc3QoYSkpIHtcbiAgICAgICAgICAgIGlmICgvUGhvbmUvLnRlc3QoYSkgfHwgL1dQRGVza3RvcC8udGVzdChhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnV2luZG93cyBQaG9uZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ1dpbmRvd3MnO1xuICAgICAgICB9IGVsc2UgaWYgKC8oaVBob25lfGlQYWR8aVBvZCkvLnRlc3QoYSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnaU9TJztcbiAgICAgICAgfSBlbHNlIGlmICgvQW5kcm9pZC8udGVzdChhKSkge1xuICAgICAgICAgICAgcmV0dXJuICdBbmRyb2lkJztcbiAgICAgICAgfSBlbHNlIGlmICgvKEJsYWNrQmVycnl8UGxheUJvb2t8QkIxMCkvaS50ZXN0KGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0JsYWNrQmVycnknO1xuICAgICAgICB9IGVsc2UgaWYgKC9NYWMvaS50ZXN0KGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ01hYyBPUyBYJztcbiAgICAgICAgfSBlbHNlIGlmICgvTGludXgvLnRlc3QoYSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnTGludXgnO1xuICAgICAgICB9IGVsc2UgaWYgKC9Dck9TLy50ZXN0KGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0Nocm9tZSBPUyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGV2aWNlOiBmdW5jdGlvbih1c2VyX2FnZW50KSB7XG4gICAgICAgIGlmICgvV2luZG93cyBQaG9uZS9pLnRlc3QodXNlcl9hZ2VudCkgfHwgL1dQRGVza3RvcC8udGVzdCh1c2VyX2FnZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuICdXaW5kb3dzIFBob25lJztcbiAgICAgICAgfSBlbHNlIGlmICgvaVBhZC8udGVzdCh1c2VyX2FnZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuICdpUGFkJztcbiAgICAgICAgfSBlbHNlIGlmICgvaVBvZC8udGVzdCh1c2VyX2FnZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuICdpUG9kIFRvdWNoJztcbiAgICAgICAgfSBlbHNlIGlmICgvaVBob25lLy50ZXN0KHVzZXJfYWdlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2lQaG9uZSc7XG4gICAgICAgIH0gZWxzZSBpZiAoLyhCbGFja0JlcnJ5fFBsYXlCb29rfEJCMTApL2kudGVzdCh1c2VyX2FnZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuICdCbGFja0JlcnJ5JztcbiAgICAgICAgfSBlbHNlIGlmICgvQW5kcm9pZC8udGVzdCh1c2VyX2FnZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuICdBbmRyb2lkJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZWZlcnJpbmdEb21haW46IGZ1bmN0aW9uKHJlZmVycmVyKSB7XG4gICAgICAgIHZhciBzcGxpdCA9IHJlZmVycmVyLnNwbGl0KCcvJyk7XG4gICAgICAgIGlmIChzcGxpdC5sZW5ndGggPj0gMykge1xuICAgICAgICAgICAgcmV0dXJuIHNwbGl0WzJdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9LFxuXG4gICAgY3VycmVudFVybDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB3aW4ubG9jYXRpb24uaHJlZjtcbiAgICB9LFxuXG4gICAgcHJvcGVydGllczogZnVuY3Rpb24oZXh0cmFfcHJvcHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBleHRyYV9wcm9wcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGV4dHJhX3Byb3BzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKF8uc3RyaXBfZW1wdHlfcHJvcGVydGllcyh7XG4gICAgICAgICAgICAnJG9zJzogXy5pbmZvLm9zKCksXG4gICAgICAgICAgICAnJGJyb3dzZXInOiBfLmluZm8uYnJvd3Nlcih1c2VyQWdlbnQsIG5hdmlnYXRvci52ZW5kb3IsIHdpbmRvd09wZXJhKSxcbiAgICAgICAgICAgICckcmVmZXJyZXInOiBkb2N1bWVudCQxLnJlZmVycmVyLFxuICAgICAgICAgICAgJyRyZWZlcnJpbmdfZG9tYWluJzogXy5pbmZvLnJlZmVycmluZ0RvbWFpbihkb2N1bWVudCQxLnJlZmVycmVyKSxcbiAgICAgICAgICAgICckZGV2aWNlJzogXy5pbmZvLmRldmljZSh1c2VyQWdlbnQpXG4gICAgICAgIH0pLCB7XG4gICAgICAgICAgICAnJGN1cnJlbnRfdXJsJzogXy5pbmZvLmN1cnJlbnRVcmwoKSxcbiAgICAgICAgICAgICckYnJvd3Nlcl92ZXJzaW9uJzogXy5pbmZvLmJyb3dzZXJWZXJzaW9uKHVzZXJBZ2VudCwgbmF2aWdhdG9yLnZlbmRvciwgd2luZG93T3BlcmEpLFxuICAgICAgICAgICAgJyRzY3JlZW5faGVpZ2h0Jzogc2NyZWVuLmhlaWdodCxcbiAgICAgICAgICAgICckc2NyZWVuX3dpZHRoJzogc2NyZWVuLndpZHRoLFxuICAgICAgICAgICAgJ21wX2xpYic6ICd3ZWInLFxuICAgICAgICAgICAgJyRsaWJfdmVyc2lvbic6IENvbmZpZy5MSUJfVkVSU0lPTixcbiAgICAgICAgICAgICckaW5zZXJ0X2lkJzogY2hlYXBfZ3VpZCgpLFxuICAgICAgICAgICAgJ3RpbWUnOiBfLnRpbWVzdGFtcCgpIC8gMTAwMCAvLyBlcG9jaCB0aW1lIGluIHNlY29uZHNcbiAgICAgICAgfSwgXy5zdHJpcF9lbXB0eV9wcm9wZXJ0aWVzKGV4dHJhX3Byb3BzKSk7XG4gICAgfSxcblxuICAgIHBlb3BsZV9wcm9wZXJ0aWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKF8uc3RyaXBfZW1wdHlfcHJvcGVydGllcyh7XG4gICAgICAgICAgICAnJG9zJzogXy5pbmZvLm9zKCksXG4gICAgICAgICAgICAnJGJyb3dzZXInOiBfLmluZm8uYnJvd3Nlcih1c2VyQWdlbnQsIG5hdmlnYXRvci52ZW5kb3IsIHdpbmRvd09wZXJhKVxuICAgICAgICB9KSwge1xuICAgICAgICAgICAgJyRicm93c2VyX3ZlcnNpb24nOiBfLmluZm8uYnJvd3NlclZlcnNpb24odXNlckFnZW50LCBuYXZpZ2F0b3IudmVuZG9yLCB3aW5kb3dPcGVyYSlcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIG1wUGFnZVZpZXdQcm9wZXJ0aWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF8uc3RyaXBfZW1wdHlfcHJvcGVydGllcyh7XG4gICAgICAgICAgICAnY3VycmVudF9wYWdlX3RpdGxlJzogZG9jdW1lbnQkMS50aXRsZSxcbiAgICAgICAgICAgICdjdXJyZW50X2RvbWFpbic6IHdpbi5sb2NhdGlvbi5ob3N0bmFtZSxcbiAgICAgICAgICAgICdjdXJyZW50X3VybF9wYXRoJzogd2luLmxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICAgICAgJ2N1cnJlbnRfdXJsX3Byb3RvY29sJzogd2luLmxvY2F0aW9uLnByb3RvY29sLFxuICAgICAgICAgICAgJ2N1cnJlbnRfdXJsX3NlYXJjaCc6IHdpbi5sb2NhdGlvbi5zZWFyY2hcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IHJ1biBhdCBtb3N0IGV2ZXJ5IGB3YWl0TXNgIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIG5leHQgaW52b2NhdGlvbi5cbiAqIFRocm90dGxlZCBjYWxscyB3aWxsIGJ1aWxkIHVwIGEgYmF0Y2ggb2YgYXJncyBhbmQgaW52b2tlIHRoZSBjYWxsYmFjayB3aXRoIGFsbCBhcmdzIHNpbmNlIHRoZSBsYXN0IGludm9jYXRpb24uXG4gKi9cbnZhciBiYXRjaGVkVGhyb3R0bGUgPSBmdW5jdGlvbiAoZm4sIHdhaXRNcykge1xuICAgIHZhciB0aW1lb3V0UHJvbWlzZSA9IG51bGw7XG4gICAgdmFyIHRocm90dGxlZEl0ZW1zID0gW107XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhyb3R0bGVkSXRlbXMucHVzaChpdGVtKTtcblxuICAgICAgICBpZiAoIXRpbWVvdXRQcm9taXNlKSB7XG4gICAgICAgICAgICB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldHVyblZhbHVlID0gZm4uYXBwbHkoc2VsZiwgW3Rocm90dGxlZEl0ZW1zXSk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3R0bGVkSXRlbXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgfSwgd2FpdE1zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aW1lb3V0UHJvbWlzZTtcbiAgICB9O1xufTtcblxudmFyIGNoZWFwX2d1aWQgPSBmdW5jdGlvbihtYXhsZW4pIHtcbiAgICB2YXIgZ3VpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxMCkgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTApO1xuICAgIHJldHVybiBtYXhsZW4gPyBndWlkLnN1YnN0cmluZygwLCBtYXhsZW4pIDogZ3VpZDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgVzNDIHRyYWNlcGFyZW50IGhlYWRlciBmb3IgZWFzeSBpbnRlcm9wIHdpdGggZGlzdHJpYnV0ZWQgdHJhY2luZyBzeXN0ZW1zIGkuZSBPcGVuIFRlbGVtZXRyeVxuICogaHR0cHM6Ly93d3cudzMub3JnL1RSL3RyYWNlLWNvbnRleHQvI3RyYWNlcGFyZW50LWhlYWRlclxuKi9cbnZhciBnZW5lcmF0ZVRyYWNlcGFyZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRyYWNlSUQgPSBfLlVVSUQoKS5yZXBsYWNlKC8tL2csICcnKTtcbiAgICB2YXIgcGFyZW50SUQgPSBfLlVVSUQoKS5yZXBsYWNlKC8tL2csICcnKS5zdWJzdHJpbmcoMCwgMTYpO1xuXG4gICAgLy8gU2FtcGxlZCB0cmFjZVxuICAgIHZhciB0cmFjZUZsYWdzID0gJzAxJztcblxuICAgIHJldHVybiAnMDAtJyArIHRyYWNlSUQgKyAnLScgKyBwYXJlbnRJRCArICctJyArIHRyYWNlRmxhZ3M7XG59O1xuXG4vLyBuYWl2ZSB3YXkgdG8gZXh0cmFjdCBkb21haW4gbmFtZSAoZXhhbXBsZS5jb20pIGZyb20gZnVsbCBob3N0bmFtZSAobXkuc3ViLmV4YW1wbGUuY29tKVxudmFyIFNJTVBMRV9ET01BSU5fTUFUQ0hfUkVHRVggPSAvW2EtejAtOV1bYS16MC05LV0qXFwuW2Etel0rJC9pO1xuLy8gdGhpcyBuZXh0IG9uZSBhdHRlbXB0cyB0byBhY2NvdW50IGZvciBzb21lIGNjU0xEcywgZS5nLiBleHRyYWN0aW5nIG94Zm9yZC5hYy51ayBmcm9tIHd3dy5veGZvcmQuYWMudWtcbnZhciBET01BSU5fTUFUQ0hfUkVHRVggPSAvW2EtejAtOV1bYS16MC05LV0rXFwuW2Etei5dezIsNn0kL2k7XG4vKipcbiAqIEF0dGVtcHRzIHRvIGV4dHJhY3QgbWFpbiBkb21haW4gbmFtZSBmcm9tIGZ1bGwgaG9zdG5hbWUsIHVzaW5nIGEgZmV3IGJsdW50IGhldXJpc3RpY3MuIEZvclxuICogY29tbW9uIFRMRHMgbGlrZSAuY29tLy5vcmcgdGhhdCBhbHdheXMgaGF2ZSBhIHNpbXBsZSBTTEQuVExEIHN0cnVjdHVyZSAoZXhhbXBsZS5jb20pLCB3ZVxuICogc2ltcGx5IGV4dHJhY3QgdGhlIGxhc3QgdHdvIC4tc2VwYXJhdGVkIHBhcnRzIG9mIHRoZSBob3N0bmFtZSAoU0lNUExFX0RPTUFJTl9NQVRDSF9SRUdFWCkuXG4gKiBGb3Igb3RoZXJzLCB3ZSBhdHRlbXB0IHRvIGFjY291bnQgZm9yIHNob3J0IGNjU0xEK1RMRCBjb21ib3MgKC5hYy51aykgd2l0aCB0aGUgbGVnYWN5XG4gKiBET01BSU5fTUFUQ0hfUkVHRVggKGtlcHQgdG8gbWFpbnRhaW4gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBleGlzdGluZyBNaXhwYW5lbFxuICogaW50ZWdyYXRpb25zKS4gVGhlIG9ubHkgX3JlbGlhYmxlXyB3YXkgdG8gZXh0cmFjdCBkb21haW4gZnJvbSBob3N0bmFtZSBpcyB3aXRoIGFuIHVwLXRvLWRhdGVcbiAqIGxpc3QgbGlrZSBhdCBodHRwczovL3B1YmxpY3N1ZmZpeC5vcmcvIHNvIGZvciBjYXNlcyB0aGF0IHRoaXMgaGVscGVyIGZhaWxzIGF0LCB0aGUgU0RLXG4gKiBvZmZlcnMgdGhlICdjb29raWVfZG9tYWluJyBjb25maWcgb3B0aW9uIHRvIHNldCBpdCBleHBsaWNpdGx5LlxuICogQGV4YW1wbGVcbiAqIGV4dHJhY3RfZG9tYWluKCdteS5zdWIuZXhhbXBsZS5jb20nKVxuICogLy8gJ2V4YW1wbGUuY29tJ1xuICovXG52YXIgZXh0cmFjdF9kb21haW4gPSBmdW5jdGlvbihob3N0bmFtZSkge1xuICAgIHZhciBkb21haW5fcmVnZXggPSBET01BSU5fTUFUQ0hfUkVHRVg7XG4gICAgdmFyIHBhcnRzID0gaG9zdG5hbWUuc3BsaXQoJy4nKTtcbiAgICB2YXIgdGxkID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHRsZC5sZW5ndGggPiA0IHx8IHRsZCA9PT0gJ2NvbScgfHwgdGxkID09PSAnb3JnJykge1xuICAgICAgICBkb21haW5fcmVnZXggPSBTSU1QTEVfRE9NQUlOX01BVENIX1JFR0VYO1xuICAgIH1cbiAgICB2YXIgbWF0Y2hlcyA9IGhvc3RuYW1lLm1hdGNoKGRvbWFpbl9yZWdleCk7XG4gICAgcmV0dXJuIG1hdGNoZXMgPyBtYXRjaGVzWzBdIDogJyc7XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgd2UgaGF2ZSBuZXR3b3JrIGNvbm5lY3Rpb24uIGRlZmF1bHQgdG8gdHJ1ZSBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IG5hdmlnYXRvci5vbkxpbmUgKElFKVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbnZhciBpc09ubGluZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbkxpbmUgPSB3aW4ubmF2aWdhdG9yWydvbkxpbmUnXTtcbiAgICByZXR1cm4gXy5pc1VuZGVmaW5lZChvbkxpbmUpIHx8IG9uTGluZTtcbn07XG5cbnZhciBOT09QX0ZVTkMgPSBmdW5jdGlvbiAoKSB7fTtcblxudmFyIEpTT05TdHJpbmdpZnkgPSBudWxsLCBKU09OUGFyc2UgPSBudWxsO1xuaWYgKHR5cGVvZiBKU09OICE9PSAndW5kZWZpbmVkJykge1xuICAgIEpTT05TdHJpbmdpZnkgPSBKU09OLnN0cmluZ2lmeTtcbiAgICBKU09OUGFyc2UgPSBKU09OLnBhcnNlO1xufVxuSlNPTlN0cmluZ2lmeSA9IEpTT05TdHJpbmdpZnkgfHwgXy5KU09ORW5jb2RlO1xuSlNPTlBhcnNlID0gSlNPTlBhcnNlIHx8IF8uSlNPTkRlY29kZTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIENvbXByZXNzaW9uU3RyZWFtIEFQSSBzaG91bGQgYmUgdXNlZC5cbiAqIFJldHVybnMgZmFsc2UgZm9yIFNhZmFyaSAxNi40IGFuZCAxNi41IHdoaWNoIGhhdmUgYnJlYWtpbmcgQ29tcHJlc3Npb25TdHJlYW0gYnVncy5cbiAqIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yNTQwMjFcbiAqIGZpeGVkIGluIDE2LjYgaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2RvY3VtZW50YXRpb24vc2FmYXJpLXJlbGVhc2Utbm90ZXMvc2FmYXJpLTE2XzYtcmVsZWFzZS1ub3Rlc1xuICovXG52YXIgY2FuVXNlQ29tcHJlc3Npb25TdHJlYW0gPSBmdW5jdGlvbih1c2VyQWdlbnQsIHZlbmRvciwgb3BlcmEpIHtcbiAgICBpZiAoIXdpbi5Db21wcmVzc2lvblN0cmVhbSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGJyb3dzZXIgPSBfLmluZm8uYnJvd3Nlcih1c2VyQWdlbnQsIHZlbmRvciwgb3BlcmEpO1xuICAgIHZhciB2ZXJzaW9uID0gXy5pbmZvLmJyb3dzZXJWZXJzaW9uKHVzZXJBZ2VudCwgdmVuZG9yLCBvcGVyYSk7XG4gICAgaWYgKGJyb3dzZXIgPT09ICdTYWZhcmknIHx8IGJyb3dzZXIgPT09ICdNb2JpbGUgU2FmYXJpJykge1xuICAgICAgICBpZiAodmVyc2lvbiA+PSAxNi40ICYmIHZlcnNpb24gPCAxNi42KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIFVOTUlOSUZJRUQgRVhQT1JUUyAoZm9yIGNsb3N1cmUgY29tcGlsZXIpXG5fWydpbmZvJ10gICAgICAgICAgICAgICAgICAgPSBfLmluZm87XG5fWydpbmZvJ11bJ2Jyb3dzZXInXSAgICAgICAgPSBfLmluZm8uYnJvd3Nlcjtcbl9bJ2luZm8nXVsnYnJvd3NlclZlcnNpb24nXSA9IF8uaW5mby5icm93c2VyVmVyc2lvbjtcbl9bJ2luZm8nXVsnZGV2aWNlJ10gICAgICAgICA9IF8uaW5mby5kZXZpY2U7XG5fWydpbmZvJ11bJ3Byb3BlcnRpZXMnXSAgICAgPSBfLmluZm8ucHJvcGVydGllcztcbl9bJ2lzQmxvY2tlZFVBJ10gICAgICAgICAgICA9IF8uaXNCbG9ja2VkVUE7XG5fWydpc0VtcHR5T2JqZWN0J10gICAgICAgICAgPSBfLmlzRW1wdHlPYmplY3Q7XG5fWydpc09iamVjdCddICAgICAgICAgICAgICAgPSBfLmlzT2JqZWN0O1xuX1snSlNPTkRlY29kZSddICAgICAgICAgICAgID0gXy5KU09ORGVjb2RlO1xuX1snSlNPTkVuY29kZSddICAgICAgICAgICAgID0gXy5KU09ORW5jb2RlO1xuX1sndG9BcnJheSddICAgICAgICAgICAgICAgID0gXy50b0FycmF5O1xuX1snTlBPJ10gICAgICAgICAgICAgICAgICAgID0gTnBvUHJvbWlzZTtcblxudmFyIE1JWFBBTkVMX0RCX05BTUUgPSAnbWl4cGFuZWxCcm93c2VyRGInO1xuXG52YXIgUkVDT1JESU5HX0VWRU5UU19TVE9SRV9OQU1FID0gJ21peHBhbmVsUmVjb3JkaW5nRXZlbnRzJztcbnZhciBSRUNPUkRJTkdfUkVHSVNUUllfU1RPUkVfTkFNRSA9ICdtaXhwYW5lbFJlY29yZGluZ1JlZ2lzdHJ5JztcblxuLy8gbm90ZTogaW5jcmVtZW50IHRoZSB2ZXJzaW9uIG51bWJlciB3aGVuIGFkZGluZyBuZXcgb2JqZWN0IHN0b3Jlc1xudmFyIERCX1ZFUlNJT04gPSAxO1xudmFyIE9CSkVDVF9TVE9SRVMgPSBbUkVDT1JESU5HX0VWRU5UU19TVE9SRV9OQU1FLCBSRUNPUkRJTkdfUkVHSVNUUllfU1RPUkVfTkFNRV07XG5cbi8qKlxuICogQHR5cGUge2ltcG9ydCgnLi93cmFwcGVyJykuU3RvcmFnZVdyYXBwZXJ9XG4gKi9cbnZhciBJREJTdG9yYWdlV3JhcHBlciA9IGZ1bmN0aW9uIChzdG9yZU5hbWUpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7UHJvbWlzZTxJREJEYXRhYmFzZT58bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmRiUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5zdG9yZU5hbWUgPSBzdG9yZU5hbWU7XG59O1xuXG5JREJTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuX29wZW5EYiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBvcGVuUmVxdWVzdCA9IHdpbi5pbmRleGVkREIub3BlbihNSVhQQU5FTF9EQl9OQU1FLCBEQl9WRVJTSU9OKTtcbiAgICAgICAgb3BlblJlcXVlc3RbJ29uZXJyb3InXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlamVjdChvcGVuUmVxdWVzdC5lcnJvcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgb3BlblJlcXVlc3RbJ29uc3VjY2VzcyddID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzb2x2ZShvcGVuUmVxdWVzdC5yZXN1bHQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIG9wZW5SZXF1ZXN0WydvbnVwZ3JhZGVuZWVkZWQnXSA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIGRiID0gZXYudGFyZ2V0LnJlc3VsdDtcblxuICAgICAgICAgICAgT0JKRUNUX1NUT1JFUy5mb3JFYWNoKGZ1bmN0aW9uIChzdG9yZU5hbWUpIHtcbiAgICAgICAgICAgICAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfSk7XG59O1xuXG5JREJTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXdpbi5pbmRleGVkREIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZWplY3QoJ2luZGV4ZWREQiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5kYlByb21pc2UpIHtcbiAgICAgICAgdGhpcy5kYlByb21pc2UgPSB0aGlzLl9vcGVuRGIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kYlByb21pc2VcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGRiT3JFcnJvcikge1xuICAgICAgICAgICAgaWYgKGRiT3JFcnJvciBpbnN0YW5jZW9mIHdpblsnSURCRGF0YWJhc2UnXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlamVjdChkYk9yRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbn07XG5cbklEQlN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5pc0luaXRpYWxpemVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXRoaXMuZGJQcm9taXNlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0lEQlRyYW5zYWN0aW9uTW9kZX0gbW9kZVxuICogQHBhcmFtIHtmdW5jdGlvbihJREJPYmplY3RTdG9yZSk6IHZvaWR9IHN0b3JlQ2JcbiAqL1xuSURCU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLm1ha2VUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uIChtb2RlLCBzdG9yZUNiKSB7XG4gICAgdmFyIHN0b3JlTmFtZSA9IHRoaXMuc3RvcmVOYW1lO1xuICAgIHZhciBkb1RyYW5zYWN0aW9uID0gZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKHN0b3JlTmFtZSwgbW9kZSk7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLm9uYWJvcnQgPSB0cmFuc2FjdGlvbi5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlamVjdCh0cmFuc2FjdGlvbi5lcnJvcik7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzdG9yZUNiKHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHN0b3JlTmFtZSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMuZGJQcm9taXNlXG4gICAgICAgIC50aGVuKGRvVHJhbnNhY3Rpb24pXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyICYmIGVyclsnbmFtZSddID09PSAnSW52YWxpZFN0YXRlRXJyb3InKSB7XG4gICAgICAgICAgICAgICAgLy8gdHJ5IHJlb3BlbmluZyB0aGUgREIgaWYgdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2VkXG4gICAgICAgICAgICAgICAgdGhpcy5kYlByb21pc2UgPSB0aGlzLl9vcGVuRGIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYlByb21pc2UudGhlbihkb1RyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbn07XG5cbklEQlN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5zZXRJdGVtID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYWtlVHJhbnNhY3Rpb24oJ3JlYWR3cml0ZScsIGZ1bmN0aW9uIChvYmplY3RTdG9yZSkge1xuICAgICAgICBvYmplY3RTdG9yZS5wdXQodmFsdWUsIGtleSk7XG4gICAgfSk7XG59O1xuXG5JREJTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuZ2V0SXRlbSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcmVxO1xuICAgIHJldHVybiB0aGlzLm1ha2VUcmFuc2FjdGlvbigncmVhZG9ubHknLCBmdW5jdGlvbiAob2JqZWN0U3RvcmUpIHtcbiAgICAgICAgcmVxID0gb2JqZWN0U3RvcmUuZ2V0KGtleSk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXEucmVzdWx0O1xuICAgIH0pO1xufTtcblxuSURCU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLnJlbW92ZUl0ZW0gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMubWFrZVRyYW5zYWN0aW9uKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAob2JqZWN0U3RvcmUpIHtcbiAgICAgICAgb2JqZWN0U3RvcmUuZGVsZXRlKGtleSk7XG4gICAgfSk7XG59O1xuXG5JREJTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuZ2V0QWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXE7XG4gICAgcmV0dXJuIHRoaXMubWFrZVRyYW5zYWN0aW9uKCdyZWFkb25seScsIGZ1bmN0aW9uIChvYmplY3RTdG9yZSkge1xuICAgICAgICByZXEgPSBvYmplY3RTdG9yZS5nZXRBbGwoKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlcS5yZXN1bHQ7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEdEUFIgdXRpbHNcbiAqXG4gKiBUaGUgR2VuZXJhbCBEYXRhIFByb3RlY3Rpb24gUmVndWxhdGlvbiAoR0RQUikgaXMgYSByZWd1bGF0aW9uIGluIEVVIGxhdyBvbiBkYXRhIHByb3RlY3Rpb25cbiAqIGFuZCBwcml2YWN5IGZvciBhbGwgaW5kaXZpZHVhbHMgd2l0aGluIHRoZSBFdXJvcGVhbiBVbmlvbi4gSXQgYWRkcmVzc2VzIHRoZSBleHBvcnQgb2YgcGVyc29uYWxcbiAqIGRhdGEgb3V0c2lkZSB0aGUgRVUuIFRoZSBHRFBSIGFpbXMgcHJpbWFyaWx5IHRvIGdpdmUgY29udHJvbCBiYWNrIHRvIGNpdGl6ZW5zIGFuZCByZXNpZGVudHNcbiAqIG92ZXIgdGhlaXIgcGVyc29uYWwgZGF0YSBhbmQgdG8gc2ltcGxpZnkgdGhlIHJlZ3VsYXRvcnkgZW52aXJvbm1lbnQgZm9yIGludGVybmF0aW9uYWwgYnVzaW5lc3NcbiAqIGJ5IHVuaWZ5aW5nIHRoZSByZWd1bGF0aW9uIHdpdGhpbiB0aGUgRVUuXG4gKlxuICogVGhpcyBzZXQgb2YgdXRpbGl0aWVzIGlzIGludGVuZGVkIHRvIGVuYWJsZSBvcHQgaW4vb3V0IGZ1bmN0aW9uYWxpdHkgaW4gdGhlIE1peHBhbmVsIEpTIFNESy5cbiAqIFRoZXNlIGZ1bmN0aW9ucyBhcmUgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBTREsgYW5kIGFyZSBub3QgaW50ZW5kZWQgdG8gYmUgcHVibGljbHkgZXhwb3NlZC5cbiAqL1xuXG5cbi8qKlxuICogQSBmdW5jdGlvbiB1c2VkIHRvIHRyYWNrIGEgTWl4cGFuZWwgZXZlbnQgKGUuZy4gTWl4cGFuZWxMaWIudHJhY2spXG4gKiBAY2FsbGJhY2sgdHJhY2tGdW5jdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50X25hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LiBUaGlzIGNhbiBiZSBhbnl0aGluZyB0aGUgdXNlciBkb2VzIC0gJ0J1dHRvbiBDbGljaycsICdTaWduIFVwJywgJ0l0ZW0gUHVyY2hhc2VkJywgZXRjLlxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBBIHNldCBvZiBwcm9wZXJ0aWVzIHRvIGluY2x1ZGUgd2l0aCB0aGUgZXZlbnQgeW91J3JlIHNlbmRpbmcuIFRoZXNlIGRlc2NyaWJlIHRoZSB1c2VyIHdobyBkaWQgdGhlIGV2ZW50IG9yIGRldGFpbHMgYWJvdXQgdGhlIGV2ZW50IGl0c2VsZi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4gKi9cblxuLyoqIFB1YmxpYyAqKi9cblxudmFyIEdEUFJfREVGQVVMVF9QRVJTSVNURU5DRV9QUkVGSVggPSAnX19tcF9vcHRfaW5fb3V0Xyc7XG5cbi8qKlxuICogT3B0IHRoZSB1c2VyIGluIHRvIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIE1peHBhbmVsIHByb2plY3QgdHJhY2tpbmcgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7dHJhY2tGdW5jdGlvbn0gW29wdGlvbnMudHJhY2tdIC0gZnVuY3Rpb24gdXNlZCBmb3IgdHJhY2tpbmcgYSBNaXhwYW5lbCBldmVudCB0byByZWNvcmQgdGhlIG9wdC1pbiBhY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50cmFja0V2ZW50TmFtZV0gLSBldmVudCBuYW1lIHRvIGJlIHVzZWQgZm9yIHRyYWNraW5nIHRoZSBvcHQtaW4gYWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMudHJhY2tQcm9wZXJ0aWVzXSAtIHNldCBvZiBwcm9wZXJ0aWVzIHRvIGJlIHRyYWNrZWQgYWxvbmcgd2l0aCB0aGUgb3B0LWluIGFjdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlVHlwZV0gUGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgLSBjb29raWUgb3IgbG9jYWxTdG9yYWdlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VQcmVmaXg9X19tcF9vcHRfaW5fb3V0XSAtIGN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29va2llRXhwaXJhdGlvbl0gLSBudW1iZXIgb2YgZGF5cyB1bnRpbCB0aGUgb3B0LWluIGNvb2tpZSBleHBpcmVzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llRG9tYWluXSAtIGN1c3RvbSBjb29raWUgZG9tYWluXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzU2l0ZUNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zaXRlLWVuYWJsZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NTdWJkb21haW5Db29raWVdIC0gd2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc3ViZG9tYWluIG9yIG5vdFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWN1cmVDb29raWVdIC0gd2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgc2VjdXJlIG9yIG5vdFxuICovXG5mdW5jdGlvbiBvcHRJbih0b2tlbiwgb3B0aW9ucykge1xuICAgIF9vcHRJbk91dCh0cnVlLCB0b2tlbiwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogT3B0IHRoZSB1c2VyIG91dCBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhlIGdpdmVuIHRva2VuXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gLSBNaXhwYW5lbCBwcm9qZWN0IHRyYWNraW5nIHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VUeXBlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVByZWZpeD1fX21wX29wdF9pbl9vdXRdIC0gY3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29raWVFeHBpcmF0aW9uXSAtIG51bWJlciBvZiBkYXlzIHVudGlsIHRoZSBvcHQtb3V0IGNvb2tpZSBleHBpcmVzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llRG9tYWluXSAtIGN1c3RvbSBjb29raWUgZG9tYWluXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzU2l0ZUNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zaXRlLWVuYWJsZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NTdWJkb21haW5Db29raWVdIC0gd2hldGhlciB0aGUgb3B0LW91dCBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXN1YmRvbWFpbiBvciBub3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VjdXJlQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1vdXQgY29va2llIGlzIHNldCBhcyBzZWN1cmUgb3Igbm90XG4gKi9cbmZ1bmN0aW9uIG9wdE91dCh0b2tlbiwgb3B0aW9ucykge1xuICAgIF9vcHRJbk91dChmYWxzZSwgdG9rZW4sIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIHVzZXIgaGFzIG9wdGVkIGluIHRvIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIE1peHBhbmVsIHByb2plY3QgdHJhY2tpbmcgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVR5cGVdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4PV9fbXBfb3B0X2luX291dF0gLSBjdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIHVzZXIgaGFzIG9wdGVkIGluIHRvIHRoZSBnaXZlbiBvcHQgdHlwZVxuICovXG5mdW5jdGlvbiBoYXNPcHRlZEluKHRva2VuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9nZXRTdG9yYWdlVmFsdWUodG9rZW4sIG9wdGlvbnMpID09PSAnMSc7XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0IG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIE1peHBhbmVsIHByb2plY3QgdHJhY2tpbmcgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVR5cGVdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4PV9fbXBfb3B0X2luX291dF0gLSBjdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pZ25vcmVEbnRdIC0gZmxhZyB0byBpZ25vcmUgYnJvd3NlciBETlQgc2V0dGluZ3MgYW5kIGFsd2F5cyByZXR1cm4gZmFsc2VcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXQgb2YgdGhlIGdpdmVuIG9wdCB0eXBlXG4gKi9cbmZ1bmN0aW9uIGhhc09wdGVkT3V0KHRva2VuLCBvcHRpb25zKSB7XG4gICAgaWYgKF9oYXNEb05vdFRyYWNrRmxhZ09uKG9wdGlvbnMpKSB7XG4gICAgICAgIGNvbnNvbGUkMS53YXJuKCdUaGlzIGJyb3dzZXIgaGFzIFwiRG8gTm90IFRyYWNrXCIgZW5hYmxlZC4gVGhpcyB3aWxsIHByZXZlbnQgdGhlIE1peHBhbmVsIFNESyBmcm9tIHNlbmRpbmcgYW55IGRhdGEuIFRvIGlnbm9yZSB0aGUgXCJEbyBOb3QgVHJhY2tcIiBicm93c2VyIHNldHRpbmcsIGluaXRpYWxpemUgdGhlIE1peHBhbmVsIGluc3RhbmNlIHdpdGggdGhlIGNvbmZpZyBcImlnbm9yZV9kbnQ6IHRydWVcIicpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIG9wdGVkT3V0ID0gX2dldFN0b3JhZ2VWYWx1ZSh0b2tlbiwgb3B0aW9ucykgPT09ICcwJztcbiAgICBpZiAob3B0ZWRPdXQpIHtcbiAgICAgICAgY29uc29sZSQxLndhcm4oJ1lvdSBhcmUgb3B0ZWQgb3V0IG9mIE1peHBhbmVsIHRyYWNraW5nLiBUaGlzIHdpbGwgcHJldmVudCB0aGUgTWl4cGFuZWwgU0RLIGZyb20gc2VuZGluZyBhbnkgZGF0YS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGVkT3V0O1xufVxuXG4vKipcbiAqIFdyYXAgYSBNaXhwYW5lbExpYiBtZXRob2Qgd2l0aCBhIGNoZWNrIGZvciB3aGV0aGVyIHRoZSB1c2VyIGlzIG9wdGVkIG91dCBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhlIGdpdmVuIHRva2VuXG4gKiBJZiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0LCByZXR1cm4gZWFybHkgaW5zdGVhZCBvZiBleGVjdXRpbmcgdGhlIG1ldGhvZC5cbiAqIElmIGEgY2FsbGJhY2sgYXJndW1lbnQgd2FzIHByb3ZpZGVkLCBleGVjdXRlIGl0IHBhc3NpbmcgdGhlIDAgZXJyb3IgY29kZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCAtIHdyYXBwZWQgbWV0aG9kIHRvIGJlIGV4ZWN1dGVkIGlmIHRoZSB1c2VyIGhhcyBub3Qgb3B0ZWQgb3V0XG4gKiBAcmV0dXJucyB7Kn0gdGhlIHJlc3VsdCBvZiBleGVjdXRpbmcgbWV0aG9kIE9SIHVuZGVmaW5lZCBpZiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0XG4gKi9cbmZ1bmN0aW9uIGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIobWV0aG9kKSB7XG4gICAgcmV0dXJuIF9hZGRPcHRPdXRDaGVjayhtZXRob2QsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0X2NvbmZpZyhuYW1lKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBXcmFwIGEgTWl4cGFuZWxQZW9wbGUgbWV0aG9kIHdpdGggYSBjaGVjayBmb3Igd2hldGhlciB0aGUgdXNlciBpcyBvcHRlZCBvdXQgb2YgZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoZSBnaXZlbiB0b2tlblxuICogSWYgdGhlIHVzZXIgaGFzIG9wdGVkIG91dCwgcmV0dXJuIGVhcmx5IGluc3RlYWQgb2YgZXhlY3V0aW5nIHRoZSBtZXRob2QuXG4gKiBJZiBhIGNhbGxiYWNrIGFyZ3VtZW50IHdhcyBwcm92aWRlZCwgZXhlY3V0ZSBpdCBwYXNzaW5nIHRoZSAwIGVycm9yIGNvZGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgLSB3cmFwcGVkIG1ldGhvZCB0byBiZSBleGVjdXRlZCBpZiB0aGUgdXNlciBoYXMgbm90IG9wdGVkIG91dFxuICogQHJldHVybnMgeyp9IHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIG1ldGhvZCBPUiB1bmRlZmluZWQgaWYgdGhlIHVzZXIgaGFzIG9wdGVkIG91dFxuICovXG5mdW5jdGlvbiBhZGRPcHRPdXRDaGVja01peHBhbmVsUGVvcGxlKG1ldGhvZCkge1xuICAgIHJldHVybiBfYWRkT3B0T3V0Q2hlY2sobWV0aG9kLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRfY29uZmlnKG5hbWUpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFdyYXAgYSBNaXhwYW5lbEdyb3VwIG1ldGhvZCB3aXRoIGEgY2hlY2sgZm9yIHdoZXRoZXIgdGhlIHVzZXIgaXMgb3B0ZWQgb3V0IG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIElmIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXQsIHJldHVybiBlYXJseSBpbnN0ZWFkIG9mIGV4ZWN1dGluZyB0aGUgbWV0aG9kLlxuICogSWYgYSBjYWxsYmFjayBhcmd1bWVudCB3YXMgcHJvdmlkZWQsIGV4ZWN1dGUgaXQgcGFzc2luZyB0aGUgMCBlcnJvciBjb2RlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIC0gd3JhcHBlZCBtZXRob2QgdG8gYmUgZXhlY3V0ZWQgaWYgdGhlIHVzZXIgaGFzIG5vdCBvcHRlZCBvdXRcbiAqIEByZXR1cm5zIHsqfSB0aGUgcmVzdWx0IG9mIGV4ZWN1dGluZyBtZXRob2QgT1IgdW5kZWZpbmVkIGlmIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXRcbiAqL1xuZnVuY3Rpb24gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbEdyb3VwKG1ldGhvZCkge1xuICAgIHJldHVybiBfYWRkT3B0T3V0Q2hlY2sobWV0aG9kLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRfY29uZmlnKG5hbWUpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIENsZWFyIHRoZSB1c2VyJ3Mgb3B0IGluL291dCBzdGF0dXMgb2YgZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoZSBnaXZlbiB0b2tlblxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gTWl4cGFuZWwgcHJvamVjdCB0cmFja2luZyB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlVHlwZV0gUGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgLSBjb29raWUgb3IgbG9jYWxTdG9yYWdlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VQcmVmaXg9X19tcF9vcHRfaW5fb3V0XSAtIGN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29va2llRXhwaXJhdGlvbl0gLSBudW1iZXIgb2YgZGF5cyB1bnRpbCB0aGUgb3B0LWluIGNvb2tpZSBleHBpcmVzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llRG9tYWluXSAtIGN1c3RvbSBjb29raWUgZG9tYWluXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzU2l0ZUNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zaXRlLWVuYWJsZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NTdWJkb21haW5Db29raWVdIC0gd2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc3ViZG9tYWluIG9yIG5vdFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWN1cmVDb29raWVdIC0gd2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgc2VjdXJlIG9yIG5vdFxuICovXG5mdW5jdGlvbiBjbGVhck9wdEluT3V0KHRva2VuLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgX2dldFN0b3JhZ2Uob3B0aW9ucykucmVtb3ZlKFxuICAgICAgICBfZ2V0U3RvcmFnZUtleSh0b2tlbiwgb3B0aW9ucyksICEhb3B0aW9ucy5jcm9zc1N1YmRvbWFpbkNvb2tpZSwgb3B0aW9ucy5jb29raWVEb21haW5cbiAgICApO1xufVxuXG4vKiogUHJpdmF0ZSAqKi9cblxuLyoqXG4gKiBHZXQgc3RvcmFnZSB1dGlsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VUeXBlXVxuICogQHJldHVybnMge29iamVjdH0gZWl0aGVyIF8uY29va2llIG9yIF8ubG9jYWxzdG9yYWdlXG4gKi9cbmZ1bmN0aW9uIF9nZXRTdG9yYWdlKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gb3B0aW9ucy5wZXJzaXN0ZW5jZVR5cGUgPT09ICdsb2NhbFN0b3JhZ2UnID8gXy5sb2NhbFN0b3JhZ2UgOiBfLmNvb2tpZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG5hbWUgb2YgdGhlIGNvb2tpZSB0aGF0IGlzIHVzZWQgZm9yIHRoZSBnaXZlbiBvcHQgdHlwZSAodHJhY2tpbmcsIGNvb2tpZSwgZXRjLilcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIE1peHBhbmVsIHByb2plY3QgdHJhY2tpbmcgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVByZWZpeD1fX21wX29wdF9pbl9vdXRdIC0gY3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBuYW1lIG9mIHRoZSBjb29raWUgZm9yIHRoZSBnaXZlbiBvcHQgdHlwZVxuICovXG5mdW5jdGlvbiBfZ2V0U3RvcmFnZUtleSh0b2tlbiwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiAob3B0aW9ucy5wZXJzaXN0ZW5jZVByZWZpeCB8fCBHRFBSX0RFRkFVTFRfUEVSU0lTVEVOQ0VfUFJFRklYKSArIHRva2VuO1xufVxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgdGhlIGNvb2tpZSB0aGF0IGlzIHVzZWQgZm9yIHRoZSBnaXZlbiBvcHQgdHlwZSAodHJhY2tpbmcsIGNvb2tpZSwgZXRjLilcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIE1peHBhbmVsIHByb2plY3QgdHJhY2tpbmcgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVByZWZpeD1fX21wX29wdF9pbl9vdXRdIC0gY3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSB2YWx1ZSBvZiB0aGUgY29va2llIGZvciB0aGUgZ2l2ZW4gb3B0IHR5cGVcbiAqL1xuZnVuY3Rpb24gX2dldFN0b3JhZ2VWYWx1ZSh0b2tlbiwgb3B0aW9ucykge1xuICAgIHJldHVybiBfZ2V0U3RvcmFnZShvcHRpb25zKS5nZXQoX2dldFN0b3JhZ2VLZXkodG9rZW4sIG9wdGlvbnMpKTtcbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSB1c2VyIGhhcyBzZXQgdGhlIEROVC9kb05vdFRyYWNrIHNldHRpbmcgdG8gdHJ1ZSBpbiB0aGVpciBicm93c2VyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMud2luZG93XSAtIGFsdGVybmF0ZSB3aW5kb3cgb2JqZWN0IHRvIGNoZWNrOyB1c2VkIHRvIGZvcmNlIHZhcmlvdXMgRE5UIHNldHRpbmdzIGluIGJyb3dzZXIgdGVzdHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaWdub3JlRG50XSAtIGZsYWcgdG8gaWdub3JlIGJyb3dzZXIgRE5UIHNldHRpbmdzIGFuZCBhbHdheXMgcmV0dXJuIGZhbHNlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgRE5UIHNldHRpbmcgaXMgdHJ1ZVxuICovXG5mdW5jdGlvbiBfaGFzRG9Ob3RUcmFja0ZsYWdPbihvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pZ25vcmVEbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgd2luJDEgPSAob3B0aW9ucyAmJiBvcHRpb25zLndpbmRvdykgfHwgd2luO1xuICAgIHZhciBuYXYgPSB3aW4kMVsnbmF2aWdhdG9yJ10gfHwge307XG4gICAgdmFyIGhhc0RudE9uID0gZmFsc2U7XG5cbiAgICBfLmVhY2goW1xuICAgICAgICBuYXZbJ2RvTm90VHJhY2snXSwgLy8gc3RhbmRhcmRcbiAgICAgICAgbmF2Wydtc0RvTm90VHJhY2snXSxcbiAgICAgICAgd2luJDFbJ2RvTm90VHJhY2snXVxuICAgIF0sIGZ1bmN0aW9uKGRudFZhbHVlKSB7XG4gICAgICAgIGlmIChfLmluY2x1ZGVzKFt0cnVlLCAxLCAnMScsICd5ZXMnXSwgZG50VmFsdWUpKSB7XG4gICAgICAgICAgICBoYXNEbnRPbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBoYXNEbnRPbjtcbn1cblxuLyoqXG4gKiBTZXQgY29va2llL2xvY2Fsc3RvcmFnZSBmb3IgdGhlIHVzZXIgaW5kaWNhdGluZyB0aGF0IHRoZXkgYXJlIG9wdGVkIGluIG9yIG91dCBmb3IgdGhlIGdpdmVuIG9wdCB0eXBlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdFZhbHVlIC0gd2hldGhlciB0byBvcHQgdGhlIHVzZXIgaW4gb3Igb3V0IGZvciB0aGUgZ2l2ZW4gb3B0IHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIE1peHBhbmVsIHByb2plY3QgdHJhY2tpbmcgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7dHJhY2tGdW5jdGlvbn0gW29wdGlvbnMudHJhY2tdIC0gZnVuY3Rpb24gdXNlZCBmb3IgdHJhY2tpbmcgYSBNaXhwYW5lbCBldmVudCB0byByZWNvcmQgdGhlIG9wdC1pbiBhY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50cmFja0V2ZW50TmFtZV0gLSBldmVudCBuYW1lIHRvIGJlIHVzZWQgZm9yIHRyYWNraW5nIHRoZSBvcHQtaW4gYWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMudHJhY2tQcm9wZXJ0aWVzXSAtIHNldCBvZiBwcm9wZXJ0aWVzIHRvIGJlIHRyYWNrZWQgYWxvbmcgd2l0aCB0aGUgb3B0LWluIGFjdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4PV9fbXBfb3B0X2luX291dF0gLSBjdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb2tpZUV4cGlyYXRpb25dIC0gbnVtYmVyIG9mIGRheXMgdW50aWwgdGhlIG9wdC1pbiBjb29raWUgZXhwaXJlc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZURvbWFpbl0gLSBjdXN0b20gY29va2llIGRvbWFpblxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc1NpdGVDb29raWVdIC0gd2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc2l0ZS1lbmFibGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzU3ViZG9tYWluQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXN1YmRvbWFpbiBvciBub3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VjdXJlQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIHNlY3VyZSBvciBub3RcbiAqL1xuZnVuY3Rpb24gX29wdEluT3V0KG9wdFZhbHVlLCB0b2tlbiwgb3B0aW9ucykge1xuICAgIGlmICghXy5pc1N0cmluZyh0b2tlbikgfHwgIXRva2VuLmxlbmd0aCkge1xuICAgICAgICBjb25zb2xlJDEuZXJyb3IoJ2dkcHIuJyArIChvcHRWYWx1ZSA/ICdvcHRJbicgOiAnb3B0T3V0JykgKyAnIGNhbGxlZCB3aXRoIGFuIGludmFsaWQgdG9rZW4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgX2dldFN0b3JhZ2Uob3B0aW9ucykuc2V0KFxuICAgICAgICBfZ2V0U3RvcmFnZUtleSh0b2tlbiwgb3B0aW9ucyksXG4gICAgICAgIG9wdFZhbHVlID8gMSA6IDAsXG4gICAgICAgIF8uaXNOdW1iZXIob3B0aW9ucy5jb29raWVFeHBpcmF0aW9uKSA/IG9wdGlvbnMuY29va2llRXhwaXJhdGlvbiA6IG51bGwsXG4gICAgICAgICEhb3B0aW9ucy5jcm9zc1N1YmRvbWFpbkNvb2tpZSxcbiAgICAgICAgISFvcHRpb25zLnNlY3VyZUNvb2tpZSxcbiAgICAgICAgISFvcHRpb25zLmNyb3NzU2l0ZUNvb2tpZSxcbiAgICAgICAgb3B0aW9ucy5jb29raWVEb21haW5cbiAgICApO1xuXG4gICAgaWYgKG9wdGlvbnMudHJhY2sgJiYgb3B0VmFsdWUpIHsgLy8gb25seSB0cmFjayBldmVudCBpZiBvcHRpbmcgaW4gKG9wdFZhbHVlPXRydWUpXG4gICAgICAgIG9wdGlvbnMudHJhY2sob3B0aW9ucy50cmFja0V2ZW50TmFtZSB8fCAnJG9wdF9pbicsIG9wdGlvbnMudHJhY2tQcm9wZXJ0aWVzLCB7XG4gICAgICAgICAgICAnc2VuZF9pbW1lZGlhdGVseSc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFdyYXAgYSBtZXRob2Qgd2l0aCBhIGNoZWNrIGZvciB3aGV0aGVyIHRoZSB1c2VyIGlzIG9wdGVkIG91dCBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhlIGdpdmVuIHRva2VuXG4gKiBJZiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0LCByZXR1cm4gZWFybHkgaW5zdGVhZCBvZiBleGVjdXRpbmcgdGhlIG1ldGhvZC5cbiAqIElmIGEgY2FsbGJhY2sgYXJndW1lbnQgd2FzIHByb3ZpZGVkLCBleGVjdXRlIGl0IHBhc3NpbmcgdGhlIDAgZXJyb3IgY29kZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCAtIHdyYXBwZWQgbWV0aG9kIHRvIGJlIGV4ZWN1dGVkIGlmIHRoZSB1c2VyIGhhcyBub3Qgb3B0ZWQgb3V0XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBnZXRDb25maWdWYWx1ZSAtIGdldHRlciBmdW5jdGlvbiBmb3IgdGhlIE1peHBhbmVsIEFQSSB0b2tlbiBhbmQgb3RoZXIgb3B0aW9ucyB0byBiZSB1c2VkIHdpdGggb3B0LW91dCBjaGVja1xuICogQHJldHVybnMgeyp9IHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIG1ldGhvZCBPUiB1bmRlZmluZWQgaWYgdGhlIHVzZXIgaGFzIG9wdGVkIG91dFxuICovXG5mdW5jdGlvbiBfYWRkT3B0T3V0Q2hlY2sobWV0aG9kLCBnZXRDb25maWdWYWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9wdGVkT3V0ID0gZmFsc2U7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IGdldENvbmZpZ1ZhbHVlLmNhbGwodGhpcywgJ3Rva2VuJyk7XG4gICAgICAgICAgICB2YXIgaWdub3JlRG50ID0gZ2V0Q29uZmlnVmFsdWUuY2FsbCh0aGlzLCAnaWdub3JlX2RudCcpO1xuICAgICAgICAgICAgdmFyIHBlcnNpc3RlbmNlVHlwZSA9IGdldENvbmZpZ1ZhbHVlLmNhbGwodGhpcywgJ29wdF9vdXRfdHJhY2tpbmdfcGVyc2lzdGVuY2VfdHlwZScpO1xuICAgICAgICAgICAgdmFyIHBlcnNpc3RlbmNlUHJlZml4ID0gZ2V0Q29uZmlnVmFsdWUuY2FsbCh0aGlzLCAnb3B0X291dF90cmFja2luZ19jb29raWVfcHJlZml4Jyk7XG4gICAgICAgICAgICB2YXIgd2luID0gZ2V0Q29uZmlnVmFsdWUuY2FsbCh0aGlzLCAnd2luZG93Jyk7IC8vIHVzZWQgdG8gb3ZlcnJpZGUgd2luZG93IGR1cmluZyBicm93c2VyIHRlc3RzXG5cbiAgICAgICAgICAgIGlmICh0b2tlbikgeyAvLyBpZiB0aGVyZSB3YXMgYW4gaXNzdWUgZ2V0dGluZyB0aGUgdG9rZW4sIGNvbnRpbnVlIG1ldGhvZCBleGVjdXRpb24gYXMgbm9ybWFsXG4gICAgICAgICAgICAgICAgb3B0ZWRPdXQgPSBoYXNPcHRlZE91dCh0b2tlbiwge1xuICAgICAgICAgICAgICAgICAgICBpZ25vcmVEbnQ6IGlnbm9yZURudCxcbiAgICAgICAgICAgICAgICAgICAgcGVyc2lzdGVuY2VUeXBlOiBwZXJzaXN0ZW5jZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RlbmNlUHJlZml4OiBwZXJzaXN0ZW5jZVByZWZpeCxcbiAgICAgICAgICAgICAgICAgICAgd2luZG93OiB3aW5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUkMS5lcnJvcignVW5leHBlY3RlZCBlcnJvciB3aGVuIGNoZWNraW5nIHRyYWNraW5nIG9wdC1vdXQgc3RhdHVzOiAnICsgZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0ZWRPdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0eXBlb2YoY2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICB9O1xufVxuXG52YXIgbG9nZ2VyJDYgPSBjb25zb2xlX3dpdGhfcHJlZml4KCdsb2NrJyk7XG5cbi8qKlxuICogU2hhcmVkTG9jazogYSBtdXRleCBidWlsdCBvbiBIVE1MNSBsb2NhbFN0b3JhZ2UsIHRvIGVuc3VyZSB0aGF0IG9ubHkgb25lIGJyb3dzZXJcbiAqIHdpbmRvdy90YWIgYXQgYSB0aW1lIHdpbGwgYmUgYWJsZSB0byBhY2Nlc3Mgc2hhcmVkIHJlc291cmNlcy5cbiAqXG4gKiBCYXNlZCBvbiB0aGUgQWx1ciBhbmQgVGF1YmVuZmVsZCBmYXN0IGxvY2tcbiAqIChodHRwOi8vd3d3LmNzLnJvY2hlc3Rlci5lZHUvcmVzZWFyY2gvc3luY2hyb25pemF0aW9uL3BzZXVkb2NvZGUvZmFzdGxvY2suaHRtbClcbiAqIHdpdGggYW4gYWRkZWQgdGltZW91dCB0byBlbnN1cmUgdGhlcmUgd2lsbCBiZSBldmVudHVhbCBwcm9ncmVzcyBpbiB0aGUgZXZlbnRcbiAqIHRoYXQgYSB3aW5kb3cgaXMgY2xvc2VkIGluIHRoZSBtaWRkbGUgb2YgdGhlIGNhbGxiYWNrLlxuICpcbiAqIEltcGxlbWVudGF0aW9uIGJhc2VkIG9uIHRoZSBvcmlnaW5hbCB2ZXJzaW9uIGJ5IERhdmlkIFdvbGV2ZXIgKGh0dHBzOi8vZ2l0aHViLmNvbS93b2xldmVyKVxuICogYXQgaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vd29sZXZlci81ZmQ3NTczZDFlZjYxNjZlOGY4YzRhZjI4NmE2OTQzMi5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgbXlMb2NrID0gbmV3IFNoYXJlZExvY2soJ3NvbWUta2V5Jyk7XG4gKiBteUxvY2sud2l0aExvY2soZnVuY3Rpb24oKSB7XG4gKiAgIGNvbnNvbGUubG9nKCdJIGhvbGQgdGhlIG11dGV4IScpO1xuICogfSk7XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBTaGFyZWRMb2NrID0gZnVuY3Rpb24oa2V5LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB0aGlzLnN0b3JhZ2VLZXkgPSBrZXk7XG4gICAgdGhpcy5zdG9yYWdlID0gb3B0aW9ucy5zdG9yYWdlIHx8IHdpbi5sb2NhbFN0b3JhZ2U7XG4gICAgdGhpcy5wb2xsSW50ZXJ2YWxNUyA9IG9wdGlvbnMucG9sbEludGVydmFsTVMgfHwgMTAwO1xuICAgIHRoaXMudGltZW91dE1TID0gb3B0aW9ucy50aW1lb3V0TVMgfHwgMjAwMDtcblxuICAgIC8vIGRlcGVuZGVuY3ktaW5qZWN0IHByb21pc2UgaW1wbGVtZW50YXRpb24gZm9yIHRlc3RpbmcgcHVycG9zZXNcbiAgICB0aGlzLnByb21pc2VJbXBsID0gb3B0aW9ucy5wcm9taXNlSW1wbCB8fCBQcm9taXNlUG9seWZpbGw7XG59O1xuXG4vLyBwYXNzIGluIGEgc3BlY2lmaWMgcGlkIHRvIHRlc3QgY29udGVudGlvbiBzY2VuYXJpb3M7IG90aGVyd2lzZVxuLy8gaXQgaXMgY2hvc2VuIHJhbmRvbWx5IGZvciBlYWNoIGFjcXVpc2l0aW9uIGF0dGVtcHRcblNoYXJlZExvY2sucHJvdG90eXBlLndpdGhMb2NrID0gZnVuY3Rpb24obG9ja2VkQ0IsIHBpZCkge1xuICAgIHZhciBQcm9taXNlID0gdGhpcy5wcm9taXNlSW1wbDtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoXy5iaW5kKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGkgPSBwaWQgfHwgKG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgJ3wnICsgTWF0aC5yYW5kb20oKSk7XG4gICAgICAgIHZhciBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuc3RvcmFnZUtleTtcbiAgICAgICAgdmFyIHBvbGxJbnRlcnZhbE1TID0gdGhpcy5wb2xsSW50ZXJ2YWxNUztcbiAgICAgICAgdmFyIHRpbWVvdXRNUyA9IHRoaXMudGltZW91dE1TO1xuICAgICAgICB2YXIgc3RvcmFnZSA9IHRoaXMuc3RvcmFnZTtcblxuICAgICAgICB2YXIga2V5WCA9IGtleSArICc6WCc7XG4gICAgICAgIHZhciBrZXlZID0ga2V5ICsgJzpZJztcbiAgICAgICAgdmFyIGtleVogPSBrZXkgKyAnOlonO1xuXG4gICAgICAgIHZhciBkZWxheSA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgICAgICBpZiAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydFRpbWUgPiB0aW1lb3V0TVMpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkNi5lcnJvcignVGltZW91dCB3YWl0aW5nIGZvciBtdXRleCBvbiAnICsga2V5ICsgJzsgY2xlYXJpbmcgbG9jay4gWycgKyBpICsgJ10nKTtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5Wik7XG4gICAgICAgICAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKGtleVkpO1xuICAgICAgICAgICAgICAgIGxvb3AoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcG9sbEludGVydmFsTVMgKiAoTWF0aC5yYW5kb20oKSArIDAuMSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB3YWl0Rm9yID0gZnVuY3Rpb24ocHJlZGljYXRlLCBjYikge1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZSgpKSB7XG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsYXkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhaXRGb3IocHJlZGljYXRlLCBjYik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldFNldFkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB2YWxZID0gc3RvcmFnZS5nZXRJdGVtKGtleVkpO1xuICAgICAgICAgICAgaWYgKHZhbFkgJiYgdmFsWSAhPT0gaSkgeyAvLyBpZiBZID09IGkgdGhlbiB0aGlzIHByb2Nlc3MgYWxyZWFkeSBoYXMgdGhlIGxvY2sgKHVzZWZ1bCBmb3IgdGVzdCBjYXNlcylcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0SXRlbShrZXlZLCBpKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZS5nZXRJdGVtKGtleVkpID09PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbG9jYWxTdG9yYWdlU3VwcG9ydGVkKHN0b3JhZ2UsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdsb2NhbFN0b3JhZ2Ugc3VwcG9ydCBkcm9wcGVkIHdoaWxlIGFjcXVpcmluZyBsb2NrJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0SXRlbShrZXlYLCBpKTtcblxuICAgICAgICAgICAgd2FpdEZvcihnZXRTZXRZLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZS5nZXRJdGVtKGtleVgpID09PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNyaXRpY2FsU2VjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVsYXkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlLmdldEl0ZW0oa2V5WSkgIT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3YWl0Rm9yKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFzdG9yYWdlLmdldEl0ZW0oa2V5Wik7XG4gICAgICAgICAgICAgICAgICAgIH0sIGNyaXRpY2FsU2VjdGlvbik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY3JpdGljYWxTZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzdG9yYWdlLnNldEl0ZW0oa2V5WiwgJzEnKTtcbiAgICAgICAgICAgIHZhciByZW1vdmVMb2NrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShrZXlaKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZS5nZXRJdGVtKGtleVkpID09PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShrZXlZKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2UuZ2V0SXRlbShrZXlYKSA9PT0gaSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5WCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgbG9ja2VkQ0IoKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTG9jaygpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJldCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVMb2NrKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAobG9jYWxTdG9yYWdlU3VwcG9ydGVkKHN0b3JhZ2UsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgbG9vcCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xvY2FsU3RvcmFnZSBzdXBwb3J0IGNoZWNrIGZhaWxlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKSk7XG59O1xuXG4vKipcbiAqIEB0eXBlIHtpbXBvcnQoJy4vd3JhcHBlcicpLlN0b3JhZ2VXcmFwcGVyfVxuICovXG52YXIgTG9jYWxTdG9yYWdlV3JhcHBlciA9IGZ1bmN0aW9uIChzdG9yYWdlT3ZlcnJpZGUpIHtcbiAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlT3ZlcnJpZGUgfHwgd2luLmxvY2FsU3RvcmFnZTtcbn07XG5cbkxvY2FsU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG59O1xuXG5Mb2NhbFN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5pc0luaXRpYWxpemVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuTG9jYWxTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuc2V0SXRlbSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoXy5iaW5kKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTlN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgIH0sIHRoaXMpKTtcbn07XG5cbkxvY2FsU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLmdldEl0ZW0gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoXy5iaW5kKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpdGVtID0gSlNPTlBhcnNlKHRoaXMuc3RvcmFnZS5nZXRJdGVtKGtleSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShpdGVtKTtcbiAgICB9LCB0aGlzKSk7XG59O1xuXG5Mb2NhbFN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5yZW1vdmVJdGVtID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKF8uYmluZChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgIH0sIHRoaXMpKTtcbn07XG5cbnZhciBsb2dnZXIkNSA9IGNvbnNvbGVfd2l0aF9wcmVmaXgoJ2JhdGNoJyk7XG5cbi8qKlxuICogUmVxdWVzdFF1ZXVlOiBxdWV1ZSBmb3IgYmF0Y2hpbmcgQVBJIHJlcXVlc3RzIHdpdGggbG9jYWxTdG9yYWdlIGJhY2t1cCBmb3IgcmV0cmllcy5cbiAqIE1haW50YWlucyBhbiBpbi1tZW1vcnkgcXVldWUgd2hpY2ggcmVwcmVzZW50cyB0aGUgc291cmNlIG9mIHRydXRoIGZvciB0aGUgY3VycmVudFxuICogcGFnZSwgYnV0IGFsc28gd3JpdGVzIGFsbCBpdGVtcyBvdXQgdG8gYSBjb3B5IGluIHRoZSBicm93c2VyJ3MgbG9jYWxTdG9yYWdlLCB3aGljaFxuICogY2FuIGJlIHJlYWQgb24gc3Vic2VxdWVudCBwYWdlbG9hZHMgYW5kIHJldHJpZWQuIEZvciBiYXRjaGFiaWxpdHksIGFsbCB0aGUgcmVxdWVzdFxuICogaXRlbXMgaW4gdGhlIHF1ZXVlIHNob3VsZCBiZSBvZiB0aGUgc2FtZSB0eXBlIChldmVudHMsIHBlb3BsZSB1cGRhdGVzLCBncm91cCB1cGRhdGVzKVxuICogc28gdGhleSBjYW4gYmUgc2VudCBpbiBhIHNpbmdsZSByZXF1ZXN0IHRvIHRoZSBzYW1lIEFQSSBlbmRwb2ludC5cbiAqXG4gKiBMb2NhbFN0b3JhZ2Uga2V5aW5nIGFuZCBsb2NraW5nOiBJbiBvcmRlciBmb3IgcmVsb2FkcyBhbmQgc3Vic2VxdWVudCBwYWdlbG9hZHMgb2ZcbiAqIHRoZSBzYW1lIHNpdGUgdG8gYWNjZXNzIHRoZSBzYW1lIHBlcnNpc3RlZCBkYXRhLCB0aGV5IG11c3Qgc2hhcmUgdGhlIHNhbWUgbG9jYWxTdG9yYWdlXG4gKiBrZXkgKGZvciBpbnN0YW5jZSBiYXNlZCBvbiBwcm9qZWN0IHRva2VuIGFuZCBxdWV1ZSB0eXBlKS4gVGhlcmVmb3JlIGFjY2VzcyB0byB0aGVcbiAqIGxvY2FsU3RvcmFnZSBlbnRyeSBpcyBndWFyZGVkIGJ5IGFuIGFzeW5jaHJvbm91cyBtdXRleCAoU2hhcmVkTG9jaykgdG8gcHJldmVudFxuICogc2ltdWx0YW5lb3VzbHkgb3BlbiB3aW5kb3dzL3RhYnMgZnJvbSBvdmVyd3JpdGluZyBlYWNoIG90aGVyJ3MgZGF0YSAod2hpY2ggd291bGQgbGVhZFxuICogdG8gZGF0YSBsb3NzIGluIHNvbWUgc2l0dWF0aW9ucykuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFJlcXVlc3RRdWV1ZSA9IGZ1bmN0aW9uIChzdG9yYWdlS2V5LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5zdG9yYWdlS2V5ID0gc3RvcmFnZUtleTtcbiAgICB0aGlzLnVzZVBlcnNpc3RlbmNlID0gb3B0aW9ucy51c2VQZXJzaXN0ZW5jZTtcbiAgICBpZiAodGhpcy51c2VQZXJzaXN0ZW5jZSkge1xuICAgICAgICB0aGlzLnF1ZXVlU3RvcmFnZSA9IG9wdGlvbnMucXVldWVTdG9yYWdlIHx8IG5ldyBMb2NhbFN0b3JhZ2VXcmFwcGVyKCk7XG4gICAgICAgIHRoaXMubG9jayA9IG5ldyBTaGFyZWRMb2NrKHN0b3JhZ2VLZXksIHtcbiAgICAgICAgICAgIHN0b3JhZ2U6IG9wdGlvbnMuc2hhcmVkTG9ja1N0b3JhZ2UgfHwgd2luLmxvY2FsU3RvcmFnZSxcbiAgICAgICAgICAgIHRpbWVvdXRNUzogb3B0aW9ucy5zaGFyZWRMb2NrVGltZW91dE1TLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5yZXBvcnRFcnJvciA9IG9wdGlvbnMuZXJyb3JSZXBvcnRlciB8fCBfLmJpbmQobG9nZ2VyJDUuZXJyb3IsIGxvZ2dlciQ1KTtcblxuICAgIHRoaXMucGlkID0gb3B0aW9ucy5waWQgfHwgbnVsbDsgLy8gcGFzcyBwaWQgdG8gdGVzdCBvdXQgc3RvcmFnZSBsb2NrIGNvbnRlbnRpb24gc2NlbmFyaW9zXG5cbiAgICB0aGlzLm1lbVF1ZXVlID0gW107XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuXG4gICAgaWYgKG9wdGlvbnMuZW5xdWV1ZVRocm90dGxlTXMpIHtcbiAgICAgICAgdGhpcy5lbnF1ZXVlUGVyc2lzdGVkID0gYmF0Y2hlZFRocm90dGxlKF8uYmluZCh0aGlzLl9lbnF1ZXVlUGVyc2lzdGVkLCB0aGlzKSwgb3B0aW9ucy5lbnF1ZXVlVGhyb3R0bGVNcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbnF1ZXVlUGVyc2lzdGVkID0gXy5iaW5kKGZ1bmN0aW9uIChxdWV1ZUVudHJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZW5xdWV1ZVBlcnNpc3RlZChbcXVldWVFbnRyeV0pO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG59O1xuXG5SZXF1ZXN0UXVldWUucHJvdG90eXBlLmVuc3VyZUluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQgfHwgIXRoaXMudXNlUGVyc2lzdGVuY2UpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucXVldWVTdG9yYWdlXG4gICAgICAgIC5pbml0KClcbiAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciBpbml0aWFsaXppbmcgcXVldWUgcGVyc2lzdGVuY2UuIERpc2FibGluZyBwZXJzaXN0ZW5jZScsIGVycik7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudXNlUGVyc2lzdGVuY2UgPSBmYWxzZTtcbiAgICAgICAgfSwgdGhpcykpO1xufTtcblxuLyoqXG4gKiBBZGQgb25lIGl0ZW0gdG8gcXVldWVzIChtZW1vcnkgYW5kIGxvY2FsU3RvcmFnZSkuIFRoZSBxdWV1ZWQgZW50cnkgaW5jbHVkZXNcbiAqIHRoZSBnaXZlbiBpdGVtIGFsb25nIHdpdGggYW4gYXV0by1nZW5lcmF0ZWQgSUQgYW5kIGEgXCJmbHVzaC1hZnRlclwiIHRpbWVzdGFtcC5cbiAqIEl0IGlzIGV4cGVjdGVkIHRoYXQgdGhlIGl0ZW0gd2lsbCBiZSBzZW50IG92ZXIgdGhlIG5ldHdvcmsgYW5kIGRlcXVldWVkXG4gKiBiZWZvcmUgdGhlIGZsdXNoLWFmdGVyIHRpbWU7IGlmIHRoaXMgZG9lc24ndCBoYXBwZW4gaXQgaXMgY29uc2lkZXJlZCBvcnBoYW5lZFxuICogKGUuZy4sIHRoZSBvcmlnaW5hbCB0YWIgd2hlcmUgaXQgd2FzIGVucXVldWVkIGdvdCBjbG9zZWQgYmVmb3JlIGl0IGNvdWxkIGJlXG4gKiBzZW50KSBhbmQgdGhlIGl0ZW0gY2FuIGJlIHNlbnQgYnkgYW55IHRhYiB0aGF0IGZpbmRzIGl0IGluIGxvY2FsU3RvcmFnZS5cbiAqXG4gKiBUaGUgZmluYWwgY2FsbGJhY2sgcGFyYW0gaXMgY2FsbGVkIHdpdGggYSBwYXJhbSBpbmRpY2F0aW5nIHN1Y2Nlc3Mgb3JcbiAqIGZhaWx1cmUgb2YgdGhlIGVucXVldWUgb3BlcmF0aW9uOyBpdCBpcyBhc3luY2hyb25vdXMgYmVjYXVzZSB0aGUgbG9jYWxTdG9yYWdlXG4gKiBsb2NrIGlzIGFzeW5jaHJvbm91cy5cbiAqL1xuUmVxdWVzdFF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24gKGl0ZW0sIGZsdXNoSW50ZXJ2YWwpIHtcbiAgICB2YXIgcXVldWVFbnRyeSA9IHtcbiAgICAgICAgJ2lkJzogY2hlYXBfZ3VpZCgpLFxuICAgICAgICAnZmx1c2hBZnRlcic6IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgZmx1c2hJbnRlcnZhbCAqIDIsXG4gICAgICAgICdwYXlsb2FkJzogaXRlbVxuICAgIH07XG5cbiAgICBpZiAoIXRoaXMudXNlUGVyc2lzdGVuY2UpIHtcbiAgICAgICAgdGhpcy5tZW1RdWV1ZS5wdXNoKHF1ZXVlRW50cnkpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5xdWV1ZVBlcnNpc3RlZChxdWV1ZUVudHJ5KTtcbiAgICB9XG59O1xuXG5SZXF1ZXN0UXVldWUucHJvdG90eXBlLl9lbnF1ZXVlUGVyc2lzdGVkID0gZnVuY3Rpb24gKHF1ZXVlRW50cmllcykge1xuICAgIHZhciBlbnF1ZXVlSXRlbSA9IF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuc3VyZUluaXQoKVxuICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkRnJvbVN0b3JhZ2UoKTtcbiAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uIChzdG9yZWRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNhdmVUb1N0b3JhZ2Uoc3RvcmVkUXVldWUuY29uY2F0KHF1ZXVlRW50cmllcykpO1xuICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKHN1Y2NlZWRlZCkge1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgYWRkIHRvIGluLW1lbW9yeSBxdWV1ZSB3aGVuIHN0b3JhZ2Ugc3VjY2VlZHNcbiAgICAgICAgICAgICAgICBpZiAoc3VjY2VlZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVtUXVldWUgPSB0aGlzLm1lbVF1ZXVlLmNvbmNhdChxdWV1ZUVudHJpZXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBzdWNjZWVkZWQ7XG4gICAgICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIGVucXVldWVpbmcgaXRlbXMnLCBlcnIsIHF1ZXVlRW50cmllcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXMubG9ja1xuICAgICAgICAud2l0aExvY2soZW5xdWV1ZUl0ZW0sIHRoaXMucGlkKVxuICAgICAgICAuY2F0Y2goXy5iaW5kKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIGFjcXVpcmluZyBzdG9yYWdlIGxvY2snLCBlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LCB0aGlzKSk7XG59O1xuXG4vKipcbiAqIFJlYWQgb3V0IHRoZSBnaXZlbiBudW1iZXIgb2YgcXVldWUgZW50cmllcy4gSWYgdGhpcy5tZW1RdWV1ZVxuICogaGFzIGZld2VyIHRoYW4gYmF0Y2hTaXplIGl0ZW1zLCB0aGVuIGxvb2sgZm9yIFwib3JwaGFuZWRcIiBpdGVtc1xuICogaW4gdGhlIHBlcnNpc3RlZCBxdWV1ZSAoaXRlbXMgd2hlcmUgdGhlICdmbHVzaEFmdGVyJyB0aW1lIGhhc1xuICogYWxyZWFkeSBwYXNzZWQpLlxuICovXG5SZXF1ZXN0UXVldWUucHJvdG90eXBlLmZpbGxCYXRjaCA9IGZ1bmN0aW9uIChiYXRjaFNpemUpIHtcbiAgICB2YXIgYmF0Y2ggPSB0aGlzLm1lbVF1ZXVlLnNsaWNlKDAsIGJhdGNoU2l6ZSk7XG4gICAgaWYgKHRoaXMudXNlUGVyc2lzdGVuY2UgJiYgYmF0Y2gubGVuZ3RoIDwgYmF0Y2hTaXplKSB7XG4gICAgICAgIC8vIGRvbid0IG5lZWQgbG9jayBqdXN0IHRvIHJlYWQgZXZlbnRzOyBsb2NhbFN0b3JhZ2UgaXMgdGhyZWFkLXNhZmVcbiAgICAgICAgLy8gYW5kIHRoZSB3b3JzdCB0aGF0IGNvdWxkIGhhcHBlbiBpcyBhIGR1cGxpY2F0ZSBzZW5kIG9mIHNvbWVcbiAgICAgICAgLy8gb3JwaGFuZWQgZXZlbnRzLCB3aGljaCB3aWxsIGJlIGRlZHVwbGljYXRlZCBvbiB0aGUgc2VydmVyIHNpZGVcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlSW5pdCgpXG4gICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRGcm9tU3RvcmFnZSgpO1xuICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKHN0b3JlZFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JlZFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpdGVtIElEcyBhbHJlYWR5IGluIGJhdGNoOyBkb24ndCBkdXBsaWNhdGUgb3V0IG9mIHN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkc0luQmF0Y2ggPSB7fTsgLy8gcG9vciBtYW4ncyBTZXRcbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKGJhdGNoLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWRzSW5CYXRjaFtpdGVtWydpZCddXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcmVkUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gc3RvcmVkUXVldWVbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3IERhdGUoKS5nZXRUaW1lKCkgPiBpdGVtWydmbHVzaEFmdGVyJ10gJiYgIWlkc0luQmF0Y2hbaXRlbVsnaWQnXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLm9ycGhhbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXRjaC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXRjaC5sZW5ndGggPj0gYmF0Y2hTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBiYXRjaDtcbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoYmF0Y2gpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGl0ZW1zIHdpdGggbWF0Y2hpbmcgJ2lkJyBmcm9tIGFycmF5IChpbW11dGFibHkpXG4gKiBhbHNvIHJlbW92ZSBhbnkgaXRlbSB3aXRob3V0IGEgdmFsaWQgaWQgKGUuZy4sIG1hbGZvcm1lZFxuICogc3RvcmFnZSBlbnRyaWVzKS5cbiAqL1xudmFyIGZpbHRlck91dElEc0FuZEludmFsaWQgPSBmdW5jdGlvbiAoaXRlbXMsIGlkU2V0KSB7XG4gICAgdmFyIGZpbHRlcmVkSXRlbXMgPSBbXTtcbiAgICBfLmVhY2goaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtWydpZCddICYmICFpZFNldFtpdGVtWydpZCddXSkge1xuICAgICAgICAgICAgZmlsdGVyZWRJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZpbHRlcmVkSXRlbXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBpdGVtcyB3aXRoIG1hdGNoaW5nIElEcyBmcm9tIGJvdGggaW4tbWVtb3J5IHF1ZXVlXG4gKiBhbmQgcGVyc2lzdGVkIHF1ZXVlXG4gKi9cblJlcXVlc3RRdWV1ZS5wcm90b3R5cGUucmVtb3ZlSXRlbXNCeUlEID0gZnVuY3Rpb24gKGlkcykge1xuICAgIHZhciBpZFNldCA9IHt9OyAvLyBwb29yIG1hbidzIFNldFxuICAgIF8uZWFjaChpZHMsIGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZFNldFtpZF0gPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgdGhpcy5tZW1RdWV1ZSA9IGZpbHRlck91dElEc0FuZEludmFsaWQodGhpcy5tZW1RdWV1ZSwgaWRTZXQpO1xuICAgIGlmICghdGhpcy51c2VQZXJzaXN0ZW5jZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlbW92ZUZyb21TdG9yYWdlID0gXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuc3VyZUluaXQoKVxuICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRGcm9tU3RvcmFnZSgpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoc3RvcmVkUXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmVkUXVldWUgPSBmaWx0ZXJPdXRJRHNBbmRJbnZhbGlkKHN0b3JlZFF1ZXVlLCBpZFNldCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNhdmVUb1N0b3JhZ2Uoc3RvcmVkUXVldWUpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRGcm9tU3RvcmFnZSgpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoc3RvcmVkUXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYW4gZXh0cmEgY2hlY2s6IGRpZCBzdG9yYWdlIHJlcG9ydCBzdWNjZXNzIGJ1dCBzb21laG93XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBpdGVtcyBhcmUgc3RpbGwgdGhlcmU/XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcmVkUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gc3RvcmVkUXVldWVbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbVsnaWQnXSAmJiAhIWlkU2V0W2l0ZW1bJ2lkJ11dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJdGVtIG5vdCByZW1vdmVkIGZyb20gc3RvcmFnZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciByZW1vdmluZyBpdGVtcycsIGVyciwgaWRzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubG9ja1xuICAgICAgICAgICAgLndpdGhMb2NrKHJlbW92ZUZyb21TdG9yYWdlLCB0aGlzLnBpZClcbiAgICAgICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIGFjcXVpcmluZyBzdG9yYWdlIGxvY2snLCBlcnIpO1xuICAgICAgICAgICAgICAgIGlmICghbG9jYWxTdG9yYWdlU3VwcG9ydGVkKHRoaXMubG9jay5zdG9yYWdlLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBMb29rcyBsaWtlIGxvY2FsU3RvcmFnZSB3cml0ZXMgaGF2ZSBzdG9wcGVkIHdvcmtpbmcgc29tZXRpbWUgYWZ0ZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6YXRpb24gKHByb2JhYmx5IGZ1bGwpLCBhbmQgc28gbm9ib2R5IGNhbiBhY3F1aXJlIGxvY2tzXG4gICAgICAgICAgICAgICAgICAgIC8vIGFueW1vcmUuIENvbnNpZGVyIGl0IHRlbXBvcmFyaWx5IHNhZmUgdG8gcmVtb3ZlIGl0ZW1zIHdpdGhvdXQgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGxvY2ssIHNpbmNlIG5vYm9keSdzIHdyaXRpbmcgc3VjY2Vzc2Z1bGx5IGFueXdheS5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUZyb21TdG9yYWdlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPSywgd2UgY291bGRuJ3QgZXZlbiB3cml0ZSBvdXQgdGhlIHNtYWxsZXIgcXVldWUuIFRyeSBjbGVhcmluZyBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWVTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5zdG9yYWdlS2V5KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIGNsZWFyaW5nIHF1ZXVlJywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICB9XG59O1xuXG4vLyBpbnRlcm5hbCBoZWxwZXIgZm9yIFJlcXVlc3RRdWV1ZS51cGRhdGVQYXlsb2Fkc1xudmFyIHVwZGF0ZVBheWxvYWRzID0gZnVuY3Rpb24gKGV4aXN0aW5nSXRlbXMsIGl0ZW1zVG9VcGRhdGUpIHtcbiAgICB2YXIgbmV3SXRlbXMgPSBbXTtcbiAgICBfLmVhY2goZXhpc3RpbmdJdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIGlkID0gaXRlbVsnaWQnXTtcbiAgICAgICAgaWYgKGlkIGluIGl0ZW1zVG9VcGRhdGUpIHtcbiAgICAgICAgICAgIHZhciBuZXdQYXlsb2FkID0gaXRlbXNUb1VwZGF0ZVtpZF07XG4gICAgICAgICAgICBpZiAobmV3UGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGl0ZW1bJ3BheWxvYWQnXSA9IG5ld1BheWxvYWQ7XG4gICAgICAgICAgICAgICAgbmV3SXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vIHVwZGF0ZVxuICAgICAgICAgICAgbmV3SXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXdJdGVtcztcbn07XG5cbi8qKlxuICogVXBkYXRlIHBheWxvYWRzIG9mIGdpdmVuIGl0ZW1zIGluIGJvdGggaW4tbWVtb3J5IHF1ZXVlIGFuZFxuICogcGVyc2lzdGVkIHF1ZXVlLiBJdGVtcyBzZXQgdG8gbnVsbCBhcmUgcmVtb3ZlZCBmcm9tIHF1ZXVlcy5cbiAqL1xuUmVxdWVzdFF1ZXVlLnByb3RvdHlwZS51cGRhdGVQYXlsb2FkcyA9IGZ1bmN0aW9uIChpdGVtc1RvVXBkYXRlKSB7XG4gICAgdGhpcy5tZW1RdWV1ZSA9IHVwZGF0ZVBheWxvYWRzKHRoaXMubWVtUXVldWUsIGl0ZW1zVG9VcGRhdGUpO1xuICAgIGlmICghdGhpcy51c2VQZXJzaXN0ZW5jZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9ja1xuICAgICAgICAgICAgLndpdGhMb2NrKF8uYmluZChmdW5jdGlvbiBsb2NrQWNxdWlyZWQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlSW5pdCgpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkRnJvbVN0b3JhZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoc3RvcmVkUXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZFF1ZXVlID0gdXBkYXRlUGF5bG9hZHMoc3RvcmVkUXVldWUsIGl0ZW1zVG9VcGRhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2F2ZVRvU3RvcmFnZShzdG9yZWRRdWV1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goXy5iaW5kKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIHVwZGF0aW5nIGl0ZW1zJywgaXRlbXNUb1VwZGF0ZSwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICAgICAgfSwgdGhpcyksIHRoaXMucGlkKVxuICAgICAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgYWNxdWlyaW5nIHN0b3JhZ2UgbG9jaycsIGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVhZCBhbmQgcGFyc2UgaXRlbXMgYXJyYXkgZnJvbSBsb2NhbFN0b3JhZ2UgZW50cnksIGhhbmRsaW5nXG4gKiBtYWxmb3JtZWQvbWlzc2luZyBkYXRhIGlmIG5lY2Vzc2FyeS5cbiAqL1xuUmVxdWVzdFF1ZXVlLnByb3RvdHlwZS5yZWFkRnJvbVN0b3JhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5zdXJlSW5pdCgpXG4gICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZVN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uIChzdG9yYWdlRW50cnkpIHtcbiAgICAgICAgICAgIGlmIChzdG9yYWdlRW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV8uaXNBcnJheShzdG9yYWdlRW50cnkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0ludmFsaWQgc3RvcmFnZSBlbnRyeTonLCBzdG9yYWdlRW50cnkpO1xuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlRW50cnkgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdG9yYWdlRW50cnkgfHwgW107XG4gICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAuY2F0Y2goXy5iaW5kKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIHJldHJpZXZpbmcgcXVldWUnLCBlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9LCB0aGlzKSk7XG59O1xuXG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgZ2l2ZW4gaXRlbXMgYXJyYXkgdG8gbG9jYWxTdG9yYWdlLlxuICovXG5SZXF1ZXN0UXVldWUucHJvdG90eXBlLnNhdmVUb1N0b3JhZ2UgPSBmdW5jdGlvbiAocXVldWUpIHtcbiAgICByZXR1cm4gdGhpcy5lbnN1cmVJbml0KClcbiAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlU3RvcmFnZS5zZXRJdGVtKHRoaXMuc3RvcmFnZUtleSwgcXVldWUpO1xuICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3Igc2F2aW5nIHF1ZXVlJywgZXJyKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSwgdGhpcykpO1xufTtcblxuLyoqXG4gKiBDbGVhciBvdXQgcXVldWVzIChtZW1vcnkgYW5kIGxvY2FsU3RvcmFnZSkuXG4gKi9cblJlcXVlc3RRdWV1ZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5tZW1RdWV1ZSA9IFtdO1xuXG4gICAgaWYgKHRoaXMudXNlUGVyc2lzdGVuY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlSW5pdCgpXG4gICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG4gICAgfVxufTtcblxuLy8gbWF4aW11bSBpbnRlcnZhbCBiZXR3ZWVuIHJlcXVlc3QgcmV0cmllcyBhZnRlciBleHBvbmVudGlhbCBiYWNrb2ZmXG52YXIgTUFYX1JFVFJZX0lOVEVSVkFMX01TID0gMTAgKiA2MCAqIDEwMDA7IC8vIDEwIG1pbnV0ZXNcblxudmFyIGxvZ2dlciQ0ID0gY29uc29sZV93aXRoX3ByZWZpeCgnYmF0Y2gnKTtcblxuLyoqXG4gKiBSZXF1ZXN0QmF0Y2hlcjogbWFuYWdlcyB0aGUgcXVldWVpbmcsIGZsdXNoaW5nLCByZXRyeSBldGMgb2YgcmVxdWVzdHMgb2Ygb25lXG4gKiB0eXBlIChldmVudHMsIHBlb3BsZSwgZ3JvdXBzKS5cbiAqIFVzZXMgUmVxdWVzdFF1ZXVlIHRvIG1hbmFnZSB0aGUgYmFja2luZyBzdG9yZS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgUmVxdWVzdEJhdGNoZXIgPSBmdW5jdGlvbihzdG9yYWdlS2V5LCBvcHRpb25zKSB7XG4gICAgdGhpcy5lcnJvclJlcG9ydGVyID0gb3B0aW9ucy5lcnJvclJlcG9ydGVyO1xuICAgIHRoaXMucXVldWUgPSBuZXcgUmVxdWVzdFF1ZXVlKHN0b3JhZ2VLZXksIHtcbiAgICAgICAgZXJyb3JSZXBvcnRlcjogXy5iaW5kKHRoaXMucmVwb3J0RXJyb3IsIHRoaXMpLFxuICAgICAgICBxdWV1ZVN0b3JhZ2U6IG9wdGlvbnMucXVldWVTdG9yYWdlLFxuICAgICAgICBzaGFyZWRMb2NrU3RvcmFnZTogb3B0aW9ucy5zaGFyZWRMb2NrU3RvcmFnZSxcbiAgICAgICAgc2hhcmVkTG9ja1RpbWVvdXRNUzogb3B0aW9ucy5zaGFyZWRMb2NrVGltZW91dE1TLFxuICAgICAgICB1c2VQZXJzaXN0ZW5jZTogb3B0aW9ucy51c2VQZXJzaXN0ZW5jZSxcbiAgICAgICAgZW5xdWV1ZVRocm90dGxlTXM6IG9wdGlvbnMuZW5xdWV1ZVRocm90dGxlTXNcbiAgICB9KTtcblxuICAgIHRoaXMubGliQ29uZmlnID0gb3B0aW9ucy5saWJDb25maWc7XG4gICAgdGhpcy5zZW5kUmVxdWVzdCA9IG9wdGlvbnMuc2VuZFJlcXVlc3RGdW5jO1xuICAgIHRoaXMuYmVmb3JlU2VuZEhvb2sgPSBvcHRpb25zLmJlZm9yZVNlbmRIb29rO1xuICAgIHRoaXMuc3RvcEFsbEJhdGNoaW5nID0gb3B0aW9ucy5zdG9wQWxsQmF0Y2hpbmdGdW5jO1xuXG4gICAgLy8gc2VlZCB2YXJpYWJsZSBiYXRjaCBzaXplICsgZmx1c2ggaW50ZXJ2YWwgd2l0aCBjb25maWd1cmVkIHZhbHVlc1xuICAgIHRoaXMuYmF0Y2hTaXplID0gdGhpcy5saWJDb25maWdbJ2JhdGNoX3NpemUnXTtcbiAgICB0aGlzLmZsdXNoSW50ZXJ2YWwgPSB0aGlzLmxpYkNvbmZpZ1snYmF0Y2hfZmx1c2hfaW50ZXJ2YWxfbXMnXTtcblxuICAgIHRoaXMuc3RvcHBlZCA9ICF0aGlzLmxpYkNvbmZpZ1snYmF0Y2hfYXV0b3N0YXJ0J107XG4gICAgdGhpcy5jb25zZWN1dGl2ZVJlbW92YWxGYWlsdXJlcyA9IDA7XG5cbiAgICAvLyBleHRyYSBjbGllbnQtc2lkZSBkZWR1cGVcbiAgICB0aGlzLml0ZW1JZHNTZW50U3VjY2Vzc2Z1bGx5ID0ge307XG5cbiAgICAvLyBNYWtlIHRoZSBmbHVzaCBvY2N1ciBhdCB0aGUgaW50ZXJ2YWwgc3BlY2lmaWVkIGJ5IGZsdXNoSW50ZXJ2YWxNcywgZGVmYXVsdCBiZWhhdmlvciB3aWxsIGF0dGVtcHQgY29uc2VjdXRpdmUgZmx1c2hlc1xuICAgIC8vIGFzIGxvbmcgYXMgdGhlIHF1ZXVlIGlzIG5vdCBlbXB0eS4gVGhpcyBpcyB1c2VmdWwgZm9yIGhpZ2gtZnJlcXVlbmN5IGV2ZW50cyBsaWtlIFNlc3Npb24gUmVwbGF5IHdoZXJlIHdlIG1pZ2h0IGVuZCB1cFxuICAgIC8vIGluIGEgcmVxdWVzdCBsb29wIGFuZCBnZXQgcmF0ZWxpbWl0ZWQgYnkgdGhlIHNlcnZlci5cbiAgICB0aGlzLmZsdXNoT25seU9uSW50ZXJ2YWwgPSBvcHRpb25zLmZsdXNoT25seU9uSW50ZXJ2YWwgfHwgZmFsc2U7XG5cbiAgICB0aGlzLl9mbHVzaFByb21pc2UgPSBudWxsO1xufTtcblxuLyoqXG4gKiBBZGQgb25lIGl0ZW0gdG8gcXVldWUuXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiB0aGlzLnF1ZXVlLmVucXVldWUoaXRlbSwgdGhpcy5mbHVzaEludGVydmFsKTtcbn07XG5cbi8qKlxuICogU3RhcnQgZmx1c2hpbmcgYmF0Y2hlcyBhdCB0aGUgY29uZmlndXJlZCB0aW1lIGludGVydmFsLiBNdXN0IGNhbGxcbiAqIHRoaXMgbWV0aG9kIHVwb24gU0RLIGluaXQgaW4gb3JkZXIgdG8gc2VuZCBhbnl0aGluZyBvdmVyIHRoZSBuZXR3b3JrLlxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0b3BwZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNvbnNlY3V0aXZlUmVtb3ZhbEZhaWx1cmVzID0gMDtcbiAgICByZXR1cm4gdGhpcy5mbHVzaCgpO1xufTtcblxuLyoqXG4gKiBTdG9wIGZsdXNoaW5nIGJhdGNoZXMuIENhbiBiZSByZXN0YXJ0ZWQgYnkgY2FsbGluZyBzdGFydCgpLlxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMudGltZW91dElEKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJRCk7XG4gICAgICAgIHRoaXMudGltZW91dElEID0gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIENsZWFyIG91dCBxdWV1ZS5cbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucXVldWUuY2xlYXIoKTtcbn07XG5cbi8qKlxuICogUmVzdG9yZSBiYXRjaCBzaXplIGNvbmZpZ3VyYXRpb24gdG8gd2hhdGV2ZXIgaXMgc2V0IGluIHRoZSBtYWluIFNESy5cbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLnJlc2V0QmF0Y2hTaXplID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5iYXRjaFNpemUgPSB0aGlzLmxpYkNvbmZpZ1snYmF0Y2hfc2l6ZSddO1xufTtcblxuLyoqXG4gKiBSZXN0b3JlIGZsdXNoIGludGVydmFsIHRpbWUgY29uZmlndXJhdGlvbiB0byB3aGF0ZXZlciBpcyBzZXQgaW4gdGhlIG1haW4gU0RLLlxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUucmVzZXRGbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2NoZWR1bGVGbHVzaCh0aGlzLmxpYkNvbmZpZ1snYmF0Y2hfZmx1c2hfaW50ZXJ2YWxfbXMnXSk7XG59O1xuXG4vKipcbiAqIFNjaGVkdWxlIHRoZSBuZXh0IGZsdXNoIGluIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUuc2NoZWR1bGVGbHVzaCA9IGZ1bmN0aW9uKGZsdXNoTVMpIHtcbiAgICB0aGlzLmZsdXNoSW50ZXJ2YWwgPSBmbHVzaE1TO1xuICAgIGlmICghdGhpcy5zdG9wcGVkKSB7IC8vIGRvbid0IHNjaGVkdWxlIGFueW1vcmUgaWYgYmF0Y2hpbmcgaGFzIGJlZW4gc3RvcHBlZFxuICAgICAgICB0aGlzLnRpbWVvdXRJRCA9IHNldFRpbWVvdXQoXy5iaW5kKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mbHVzaFByb21pc2UgPSB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpLCB0aGlzLmZsdXNoSW50ZXJ2YWwpO1xuICAgIH1cbn07XG5cbi8qKlxuICogU2VuZCBhIHJlcXVlc3QgdXNpbmcgdGhlIHNlbmRSZXF1ZXN0IGNhbGxiYWNrLCBidXQgcHJvbWlzaWZpZWQuXG4gKiBUT0RPOiBzZW5kUmVxdWVzdCBzaG91bGQgYmUgcHJvbWlzaWZpZWQgaW4gdGhlIGZpcnN0IHBsYWNlLlxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUuc2VuZFJlcXVlc3RQcm9taXNlID0gZnVuY3Rpb24oZGF0YSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKF8uYmluZChmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoZGF0YSwgb3B0aW9ucywgcmVzb2x2ZSk7XG4gICAgfSwgdGhpcykpO1xufTtcblxuXG4vKipcbiAqIEZsdXNoIG9uZSBiYXRjaCB0byBuZXR3b3JrLiBEZXBlbmRpbmcgb24gc3VjY2Vzcy9mYWlsdXJlIG1vZGVzLCBpdCB3aWxsIGVpdGhlclxuICogcmVtb3ZlIHRoZSBiYXRjaCBmcm9tIHRoZSBxdWV1ZSBvciBsZWF2ZSBpdCBpbiBmb3IgcmV0cnksIGFuZCBzY2hlZHVsZSB0aGUgbmV4dFxuICogZmx1c2guIEluIGNhc2VzIG9mIG1vc3QgbmV0d29yayBvciBBUEkgZmFpbHVyZXMsIGl0IHdpbGwgYmFjayBvZmYgZXhwb25lbnRpYWxseVxuICogd2hlbiByZXRyeWluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VuZEJlYWNvbl0gLSB3aGV0aGVyIHRvIHNlbmQgYmF0Y2ggd2l0aFxuICogbmF2aWdhdG9yLnNlbmRCZWFjb24gKG9ubHkgdXNlZnVsIGZvciBzZW5kaW5nIGJhdGNoZXMgYmVmb3JlIHBhZ2UgdW5sb2FkcywgYXNcbiAqIHNlbmRCZWFjb24gb2ZmZXJzIG5vIGNhbGxiYWNrcyBvciBzdGF0dXMgaW5kaWNhdGlvbnMpXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5yZXF1ZXN0SW5Qcm9ncmVzcykge1xuICAgICAgICBsb2dnZXIkNC5sb2coJ0ZsdXNoOiBSZXF1ZXN0IGFscmVhZHkgaW4gcHJvZ3Jlc3MnKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5yZXF1ZXN0SW5Qcm9ncmVzcyA9IHRydWU7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgdGltZW91dE1TID0gdGhpcy5saWJDb25maWdbJ2JhdGNoX3JlcXVlc3RfdGltZW91dF9tcyddO1xuICAgIHZhciBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB2YXIgY3VycmVudEJhdGNoU2l6ZSA9IHRoaXMuYmF0Y2hTaXplO1xuXG4gICAgcmV0dXJuIHRoaXMucXVldWUuZmlsbEJhdGNoKGN1cnJlbnRCYXRjaFNpemUpXG4gICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbihiYXRjaCkge1xuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSdzIG1vcmUgaXRlbXMgaW4gdGhlIHF1ZXVlIHRoYW4gdGhlIGJhdGNoIHNpemUsIGF0dGVtcHRcbiAgICAgICAgICAgIC8vIHRvIGZsdXNoIGFnYWluIGFmdGVyIHRoZSBjdXJyZW50IGJhdGNoIGlzIGRvbmUuXG4gICAgICAgICAgICB2YXIgYXR0ZW1wdFNlY29uZGFyeUZsdXNoID0gYmF0Y2gubGVuZ3RoID09PSBjdXJyZW50QmF0Y2hTaXplO1xuICAgICAgICAgICAgdmFyIGRhdGFGb3JSZXF1ZXN0ID0gW107XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRJdGVtcyA9IHt9O1xuICAgICAgICAgICAgXy5lYWNoKGJhdGNoLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBpdGVtWydwYXlsb2FkJ107XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYmVmb3JlU2VuZEhvb2sgJiYgIWl0ZW0ub3JwaGFuZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCA9IHRoaXMuYmVmb3JlU2VuZEhvb2socGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1wX3NlbnRfYnlfbGliX3ZlcnNpb24gcHJvcCBjYXB0dXJlcyB3aGljaCBsaWIgdmVyc2lvbiBhY3R1YWxseVxuICAgICAgICAgICAgICAgICAgICAvLyBzZW5kcyBlYWNoIGV2ZW50IChyZWdhcmRsZXNzIG9mIHdoaWNoIHZlcnNpb24gb3JpZ2luYWxseSBxdWV1ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgZm9yIHNlbmRpbmcpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkWydldmVudCddICYmIHBheWxvYWRbJ3Byb3BlcnRpZXMnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZFsncHJvcGVydGllcyddID0gXy5leHRlbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZFsncHJvcGVydGllcyddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsnbXBfc2VudF9ieV9saWJfdmVyc2lvbic6IENvbmZpZy5MSUJfVkVSU0lPTn1cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFkZFBheWxvYWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbUlkID0gaXRlbVsnaWQnXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1JZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0aGlzLml0ZW1JZHNTZW50U3VjY2Vzc2Z1bGx5W2l0ZW1JZF0gfHwgMCkgPiA1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignW2R1cGVdIGl0ZW0gSUQgc2VudCB0b28gbWFueSB0aW1lcywgbm90IHNlbmRpbmcnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhdGNoU2l6ZTogYmF0Y2gubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc1NlbnQ6IHRoaXMuaXRlbUlkc1NlbnRTdWNjZXNzZnVsbHlbaXRlbUlkXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFBheWxvYWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ1tkdXBlXSBmb3VuZCBpdGVtIHdpdGggbm8gSUQnLCB7aXRlbTogaXRlbX0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZFBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFGb3JSZXF1ZXN0LnB1c2gocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRJdGVtc1tpdGVtWydpZCddXSA9IHBheWxvYWQ7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgaWYgKGRhdGFGb3JSZXF1ZXN0Lmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldEZsdXNoKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7IC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlbW92ZUl0ZW1zRnJvbVF1ZXVlID0gXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZVxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlSXRlbXNCeUlEKFxuICAgICAgICAgICAgICAgICAgICAgICAgXy5tYXAoYmF0Y2gsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1bJ2lkJ107XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoc3VjY2VlZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjbGllbnQtc2lkZSBkZWR1cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uZWFjaChiYXRjaCwgXy5iaW5kKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbUlkID0gaXRlbVsnaWQnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbUlkc1NlbnRTdWNjZXNzZnVsbHlbaXRlbUlkXSA9IHRoaXMuaXRlbUlkc1NlbnRTdWNjZXNzZnVsbHlbaXRlbUlkXSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW1JZHNTZW50U3VjY2Vzc2Z1bGx5W2l0ZW1JZF0rKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXRlbUlkc1NlbnRTdWNjZXNzZnVsbHlbaXRlbUlkXSA+IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ1tkdXBlXSBpdGVtIElEIHNlbnQgdG9vIG1hbnkgdGltZXMnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXRjaFNpemU6IGJhdGNoLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc1NlbnQ6IHRoaXMuaXRlbUlkc1NlbnRTdWNjZXNzZnVsbHlbaXRlbUlkXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdbZHVwZV0gZm91bmQgaXRlbSB3aXRoIG5vIElEIHdoaWxlIHJlbW92aW5nJywge2l0ZW06IGl0ZW19KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWNjZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnNlY3V0aXZlUmVtb3ZhbEZhaWx1cmVzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5mbHVzaE9ubHlPbkludGVydmFsICYmICFhdHRlbXB0U2Vjb25kYXJ5Rmx1c2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldEZsdXNoKCk7IC8vIHNjaGVkdWxlIG5leHQgYmF0Y2ggd2l0aCBhIGRlbGF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZsdXNoKCk7IC8vIGhhbmRsZSBuZXh0IGJhdGNoIGlmIHRoZSBxdWV1ZSBpc24ndCBlbXB0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCsrdGhpcy5jb25zZWN1dGl2ZVJlbW92YWxGYWlsdXJlcyA+IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignVG9vIG1hbnkgcXVldWUgZmFpbHVyZXM7IGRpc2FibGluZyBiYXRjaGluZyBzeXN0ZW0uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcEFsbEJhdGNoaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldEZsdXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgdmFyIGJhdGNoU2VuZENhbGxiYWNrID0gXy5iaW5kKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdEluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIEFQSSByZXNwb25zZSBpbiBhIHRyeS1jYXRjaCB0byBtYWtlIHN1cmUgd2UgY2FuIHJlc2V0IHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBmbHVzaCBvcGVyYXRpb24gaWYgc29tZXRoaW5nIGdvZXMgd3JvbmdcblxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy51bmxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBwZXJzaXN0ZWQgZGF0YSB0byBpbmNsdWRlIGhvb2sgdHJhbnNmb3JtYXRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZS51cGRhdGVQYXlsb2Fkcyh0cmFuc2Zvcm1lZEl0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uaXNPYmplY3QocmVzKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5lcnJvciA9PT0gJ3RpbWVvdXQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydFRpbWUgPj0gdGltZW91dE1TXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignTmV0d29yayB0aW1lb3V0OyByZXRyeWluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmx1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uaXNPYmplY3QocmVzKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLmh0dHBTdGF0dXNDb2RlID49IDUwMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCByZXMuaHR0cFN0YXR1c0NvZGUgPT09IDQyOVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAocmVzLmh0dHBTdGF0dXNDb2RlIDw9IDAgJiYgIWlzT25saW5lKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHJlcy5lcnJvciA9PT0gJ3RpbWVvdXQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5ldHdvcmsgb3IgQVBJIGVycm9yLCBvciA0MjkgVG9vIE1hbnkgUmVxdWVzdHMsIHJldHJ5XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0cnlNUyA9IHRoaXMuZmx1c2hJbnRlcnZhbCAqIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzLnJldHJ5QWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyeU1TID0gKHBhcnNlSW50KHJlcy5yZXRyeUFmdGVyLCAxMCkgKiAxMDAwKSB8fCByZXRyeU1TO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlNUyA9IE1hdGgubWluKE1BWF9SRVRSWV9JTlRFUlZBTF9NUywgcmV0cnlNUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvcjsgcmV0cnkgaW4gJyArIHJldHJ5TVMgKyAnIG1zJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlRmx1c2gocmV0cnlNUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KHJlcykgJiYgcmVzLmh0dHBTdGF0dXNDb2RlID09PSA0MTMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDQxMyBQYXlsb2FkIFRvbyBMYXJnZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJhdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFsdmVkQmF0Y2hTaXplID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihjdXJyZW50QmF0Y2hTaXplIC8gMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmF0Y2hTaXplID0gTWF0aC5taW4odGhpcy5iYXRjaFNpemUsIGhhbHZlZEJhdGNoU2l6ZSwgYmF0Y2gubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignNDEzIHJlc3BvbnNlOyByZWR1Y2luZyBiYXRjaCBzaXplIHRvICcgKyB0aGlzLmJhdGNoU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldEZsdXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ1NpbmdsZS1ldmVudCByZXF1ZXN0IHRvbyBsYXJnZTsgZHJvcHBpbmcnLCBiYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldEJhdGNoU2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVJdGVtc0Zyb21RdWV1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3VjY2Vzc2Z1bCBuZXR3b3JrIHJlcXVlc3QrcmVzcG9uc2U7IHJlbW92ZSBlYWNoIGl0ZW0gaW4gYmF0Y2ggZnJvbSBxdWV1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGV2ZW4gaWYgaXQgd2FzIGUuZy4gYSA0MDAsIGluIHdoaWNoIGNhc2UgcmV0cnlpbmcgd29uJ3QgaGVscClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVJdGVtc0Zyb21RdWV1ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgaGFuZGxpbmcgQVBJIHJlc3BvbnNlJywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldEZsdXNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgdmVyYm9zZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpZ25vcmVfanNvbl9lcnJvcnM6IHRydWUsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG4gICAgICAgICAgICAgICAgdGltZW91dF9tczogdGltZW91dE1TIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMudW5sb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMudHJhbnNwb3J0ID0gJ3NlbmRCZWFjb24nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyJDQubG9nKCdNSVhQQU5FTCBSRVFVRVNUOicsIGRhdGFGb3JSZXF1ZXN0KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0UHJvbWlzZShkYXRhRm9yUmVxdWVzdCwgcmVxdWVzdE9wdGlvbnMpLnRoZW4oYmF0Y2hTZW5kQ2FsbGJhY2spO1xuICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIGZsdXNoaW5nIHJlcXVlc3QgcXVldWUnLCBlcnIpO1xuICAgICAgICAgICAgdGhpcy5yZXNldEZsdXNoKCk7XG4gICAgICAgIH0sIHRoaXMpKTtcbn07XG5cbi8qKlxuICogTG9nIGVycm9yIHRvIGdsb2JhbCBsb2dnZXIgYW5kIG9wdGlvbmFsIHVzZXItZGVmaW5lZCBsb2dnZXIuXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5yZXBvcnRFcnJvciA9IGZ1bmN0aW9uKG1zZywgZXJyKSB7XG4gICAgbG9nZ2VyJDQuZXJyb3IuYXBwbHkobG9nZ2VyJDQuZXJyb3IsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHRoaXMuZXJyb3JSZXBvcnRlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVycm9yUmVwb3J0ZXIobXNnLCBlcnIpO1xuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyJDQuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vc2Vzc2lvbi1yZWNvcmRpbmcnKS5TZXJpYWxpemVkUmVjb3JkaW5nfSBzZXJpYWxpemVkUmVjb3JkaW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xudmFyIGlzUmVjb3JkaW5nRXhwaXJlZCA9IGZ1bmN0aW9uKHNlcmlhbGl6ZWRSZWNvcmRpbmcpIHtcbiAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICByZXR1cm4gIXNlcmlhbGl6ZWRSZWNvcmRpbmcgfHwgbm93ID4gc2VyaWFsaXplZFJlY29yZGluZ1snbWF4RXhwaXJlcyddIHx8IG5vdyA+IHNlcmlhbGl6ZWRSZWNvcmRpbmdbJ2lkbGVFeHBpcmVzJ107XG59O1xuXG52YXIgUkVDT1JEX0VOUVVFVUVfVEhST1RUTEVfTVMgPSAyNTA7XG5cbnZhciBsb2dnZXIkMyA9IGNvbnNvbGVfd2l0aF9wcmVmaXgoJ3JlY29yZGVyJyk7XG52YXIgQ29tcHJlc3Npb25TdHJlYW0gPSB3aW5bJ0NvbXByZXNzaW9uU3RyZWFtJ107XG5cbnZhciBSRUNPUkRFUl9CQVRDSEVSX0xJQl9DT05GSUcgPSB7XG4gICAgJ2JhdGNoX3NpemUnOiAxMDAwLFxuICAgICdiYXRjaF9mbHVzaF9pbnRlcnZhbF9tcyc6IDEwICogMTAwMCxcbiAgICAnYmF0Y2hfcmVxdWVzdF90aW1lb3V0X21zJzogOTAgKiAxMDAwLFxuICAgICdiYXRjaF9hdXRvc3RhcnQnOiB0cnVlXG59O1xuXG52YXIgQUNUSVZFX1NPVVJDRVMgPSBuZXcgU2V0KFtcbiAgICBJbmNyZW1lbnRhbFNvdXJjZS5Nb3VzZU1vdmUsXG4gICAgSW5jcmVtZW50YWxTb3VyY2UuTW91c2VJbnRlcmFjdGlvbixcbiAgICBJbmNyZW1lbnRhbFNvdXJjZS5TY3JvbGwsXG4gICAgSW5jcmVtZW50YWxTb3VyY2UuVmlld3BvcnRSZXNpemUsXG4gICAgSW5jcmVtZW50YWxTb3VyY2UuSW5wdXQsXG4gICAgSW5jcmVtZW50YWxTb3VyY2UuVG91Y2hNb3ZlLFxuICAgIEluY3JlbWVudGFsU291cmNlLk1lZGlhSW50ZXJhY3Rpb24sXG4gICAgSW5jcmVtZW50YWxTb3VyY2UuRHJhZyxcbiAgICBJbmNyZW1lbnRhbFNvdXJjZS5TZWxlY3Rpb24sXG5dKTtcblxuZnVuY3Rpb24gaXNVc2VyRXZlbnQoZXYpIHtcbiAgICByZXR1cm4gZXYudHlwZSA9PT0gRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QgJiYgQUNUSVZFX1NPVVJDRVMuaGFzKGV2LmRhdGEuc291cmNlKTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTZXJpYWxpemVkUmVjb3JkaW5nXG4gKiBAcHJvcGVydHkge251bWJlcn0gaWRsZUV4cGlyZXNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhFeHBpcmVzXG4gKiBAcHJvcGVydHkge251bWJlcn0gcmVwbGF5U3RhcnRUaW1lXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGFzdEV2ZW50VGltZXN0YW1wXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2VxTm9cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBiYXRjaFN0YXJ0VXJsXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcmVwbGF5SWRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0YWJJZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJlcGxheVN0YXJ0VXJsXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTZXNzaW9uUmVjb3JkaW5nT3B0aW9uc1xuICogQHByb3BlcnR5IHtPYmplY3R9IFtvcHRpb25zLm1peHBhbmVsSW5zdGFuY2VdIC0gcmVmZXJlbmNlIHRvIHRoZSBjb3JlIE1peHBhbmVsTGliXG4gKiBAcHJvcGVydHkge1N0cmluZ30gW29wdGlvbnMucmVwbGF5SWRdIC0gdW5pcXVlIHV1aWQgZm9yIGEgc2luZ2xlIHJlcGxheVxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW29wdGlvbnMub25JZGxlVGltZW91dF0gLSBjYWxsYmFjayB3aGVuIGEgcmVjb3JkaW5nIHJlYWNoZXMgaWRsZSB0aW1lb3V0XG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbk1heExlbmd0aFJlYWNoZWRdIC0gY2FsbGJhY2sgd2hlbiBhIHJlY29yZGluZyByZWFjaGVzIGl0cyBtYXhpbXVtIGxlbmd0aFxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW29wdGlvbnMucnJ3ZWJSZWNvcmRdIC0gcnJ3ZWIncyBgcmVjb3JkYCBmdW5jdGlvblxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW29wdGlvbnMub25CYXRjaFNlbnRdIC0gY2FsbGJhY2sgd2hlbiBhIGJhdGNoIG9mIGV2ZW50cyBpcyBzZW50IHRvIHRoZSBzZXJ2ZXJcbiAqIEBwcm9wZXJ0eSB7U3RvcmFnZX0gW29wdGlvbnMuc2hhcmVkTG9ja1N0b3JhZ2VdIC0gb3B0aW9uYWwgc3RvcmFnZSBmb3Igc2hhcmVkIGxvY2ssIHVzZWQgZm9yIHRlc3QgZGVwZW5kZW5jeSBpbmplY3Rpb25cbiAqIG9wdGlvbmFsIHByb3BlcnRpZXMgZm9yIGRlc2VyaWFsaXphdGlvbjpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpZGxlRXhwaXJlc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IG1heEV4cGlyZXNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZXBsYXlTdGFydFRpbWVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsYXN0RXZlbnRUaW1lc3RhbXAgLSB0aGUgdW5peCB0aW1lc3RhbXAgb2YgdGhlIGxhc3QgcmVjb3JkZWQgZXZlbnQgZnJvbSBycndlYlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNlcU5vXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYmF0Y2hTdGFydFVybFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJlcGxheVN0YXJ0VXJsXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBVc2VySWRJbmZvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGlzdGluY3RfaWRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1c2VyX2lkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGV2aWNlX2lkXG4gKi9cblxuXG4vKipcbiAqIFRoaXMgY2xhc3MgZW5jYXBzdWxhdGVzIGEgc2luZ2xlIHNlc3Npb24gcmVjb3JkaW5nIGFuZCBpdHMgbGlmZWN5Y2xlLlxuICogQHBhcmFtIHtTZXNzaW9uUmVjb3JkaW5nT3B0aW9uc30gb3B0aW9uc1xuICovXG52YXIgU2Vzc2lvblJlY29yZGluZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9taXhwYW5lbCA9IG9wdGlvbnMubWl4cGFuZWxJbnN0YW5jZTtcbiAgICB0aGlzLl9vbklkbGVUaW1lb3V0ID0gb3B0aW9ucy5vbklkbGVUaW1lb3V0IHx8IE5PT1BfRlVOQztcbiAgICB0aGlzLl9vbk1heExlbmd0aFJlYWNoZWQgPSBvcHRpb25zLm9uTWF4TGVuZ3RoUmVhY2hlZCB8fCBOT09QX0ZVTkM7XG4gICAgdGhpcy5fb25CYXRjaFNlbnQgPSBvcHRpb25zLm9uQmF0Y2hTZW50IHx8IE5PT1BfRlVOQztcbiAgICB0aGlzLl9ycndlYlJlY29yZCA9IG9wdGlvbnMucnJ3ZWJSZWNvcmQgfHwgbnVsbDtcblxuICAgIC8vIGludGVybmFsIHJyd2ViIHN0b3BSZWNvcmRpbmcgZnVuY3Rpb25cbiAgICB0aGlzLl9zdG9wUmVjb3JkaW5nID0gbnVsbDtcbiAgICB0aGlzLnJlcGxheUlkID0gb3B0aW9ucy5yZXBsYXlJZDtcblxuICAgIHRoaXMuYmF0Y2hTdGFydFVybCA9IG9wdGlvbnMuYmF0Y2hTdGFydFVybCB8fCBudWxsO1xuICAgIHRoaXMucmVwbGF5U3RhcnRVcmwgPSBvcHRpb25zLnJlcGxheVN0YXJ0VXJsIHx8IG51bGw7XG4gICAgdGhpcy5pZGxlRXhwaXJlcyA9IG9wdGlvbnMuaWRsZUV4cGlyZXMgfHwgbnVsbDtcbiAgICB0aGlzLm1heEV4cGlyZXMgPSBvcHRpb25zLm1heEV4cGlyZXMgfHwgbnVsbDtcbiAgICB0aGlzLnJlcGxheVN0YXJ0VGltZSA9IG9wdGlvbnMucmVwbGF5U3RhcnRUaW1lIHx8IG51bGw7XG4gICAgdGhpcy5sYXN0RXZlbnRUaW1lc3RhbXAgPSBvcHRpb25zLmxhc3RFdmVudFRpbWVzdGFtcCB8fCBudWxsO1xuICAgIHRoaXMuc2VxTm8gPSBvcHRpb25zLnNlcU5vIHx8IDA7XG5cbiAgICB0aGlzLmlkbGVUaW1lb3V0SWQgPSBudWxsO1xuICAgIHRoaXMubWF4VGltZW91dElkID0gbnVsbDtcblxuICAgIHRoaXMucmVjb3JkTWF4TXMgPSBNQVhfUkVDT1JESU5HX01TO1xuICAgIHRoaXMucmVjb3JkTWluTXMgPSAwO1xuXG4gICAgLy8gZGlzYWJsZSBwZXJzaXN0ZW5jZSBpZiBsb2NhbFN0b3JhZ2UgaXMgbm90IHN1cHBvcnRlZFxuICAgIC8vIHJlcXVlc3QtcXVldWUgd2lsbCBhdXRvbWF0aWNhbGx5IGRpc2FibGUgcGVyc2lzdGVuY2UgaWYgaW5kZXhlZERCIGZhaWxzIHRvIGluaXRpYWxpemVcbiAgICB2YXIgdXNlUGVyc2lzdGVuY2UgPSBsb2NhbFN0b3JhZ2VTdXBwb3J0ZWQob3B0aW9ucy5zaGFyZWRMb2NrU3RvcmFnZSwgdHJ1ZSkgJiYgIXRoaXMuZ2V0Q29uZmlnKCdkaXNhYmxlX3BlcnNpc3RlbmNlJyk7XG5cbiAgICAvLyBlYWNoIHJlcGxheSBoYXMgaXRzIG93biBiYXRjaGVyIGtleSB0byBhdm9pZCBjb25mbGljdHMgYmV0d2VlbiBycndlYiBldmVudHMgb2YgZGlmZmVyZW50IHJlY29yZGluZ3NcbiAgICB0aGlzLmJhdGNoZXJLZXkgPSAnX19tcHJlY18nICsgdGhpcy5nZXRDb25maWcoJ25hbWUnKSArICdfJyArIHRoaXMuZ2V0Q29uZmlnKCd0b2tlbicpICsgJ18nICsgdGhpcy5yZXBsYXlJZDtcbiAgICB0aGlzLnF1ZXVlU3RvcmFnZSA9IG5ldyBJREJTdG9yYWdlV3JhcHBlcihSRUNPUkRJTkdfRVZFTlRTX1NUT1JFX05BTUUpO1xuICAgIHRoaXMuYmF0Y2hlciA9IG5ldyBSZXF1ZXN0QmF0Y2hlcih0aGlzLmJhdGNoZXJLZXksIHtcbiAgICAgICAgZXJyb3JSZXBvcnRlcjogdGhpcy5yZXBvcnRFcnJvci5iaW5kKHRoaXMpLFxuICAgICAgICBmbHVzaE9ubHlPbkludGVydmFsOiB0cnVlLFxuICAgICAgICBsaWJDb25maWc6IFJFQ09SREVSX0JBVENIRVJfTElCX0NPTkZJRyxcbiAgICAgICAgc2VuZFJlcXVlc3RGdW5jOiB0aGlzLmZsdXNoRXZlbnRzV2l0aE9wdE91dC5iaW5kKHRoaXMpLFxuICAgICAgICBxdWV1ZVN0b3JhZ2U6IHRoaXMucXVldWVTdG9yYWdlLFxuICAgICAgICBzaGFyZWRMb2NrU3RvcmFnZTogb3B0aW9ucy5zaGFyZWRMb2NrU3RvcmFnZSxcbiAgICAgICAgdXNlUGVyc2lzdGVuY2U6IHVzZVBlcnNpc3RlbmNlLFxuICAgICAgICBzdG9wQWxsQmF0Y2hpbmdGdW5jOiB0aGlzLnN0b3BSZWNvcmRpbmcuYmluZCh0aGlzKSxcblxuICAgICAgICAvLyBpbmNyZWFzZWQgdGhyb3R0bGUgYW5kIHNoYXJlZCBsb2NrIHRpbWVvdXQgYmVjYXVzZSByZWNvcmRpbmcgZXZlbnRzIGFyZSB2ZXJ5IGhpZ2ggZnJlcXVlbmN5LlxuICAgICAgICAvLyB0aGlzIHdpbGwgbWluaW1pemUgdGhlIGFtb3VudCBvZiBsb2NrIGNvbnRlbnRpb24gYmV0d2VlbiBlbnF1ZXVlZCBldmVudHMuXG4gICAgICAgIC8vIGZvciBzZXNzaW9uIHJlY29yZGluZ3MgdGhlcmUgaXMgYSBsb2NrIGZvciBlYWNoIHRhYiBhbnl3YXksIHNvIHRoZXJlJ3Mgbm8gcmlzayBvZiBkZWFkbG9jayBiZXR3ZWVuIHRhYnMuXG4gICAgICAgIGVucXVldWVUaHJvdHRsZU1zOiBSRUNPUkRfRU5RVUVVRV9USFJPVFRMRV9NUyxcbiAgICAgICAgc2hhcmVkTG9ja1RpbWVvdXRNUzogMTAgKiAxMDAwLFxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7VXNlcklkSW5mb31cbiAqL1xuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUuZ2V0VXNlcklkSW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5maW5hbEZsdXNoVXNlcklkSW5mbykge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5hbEZsdXNoVXNlcklkSW5mbztcbiAgICB9XG5cbiAgICB2YXIgdXNlcklkSW5mbyA9IHtcbiAgICAgICAgJ2Rpc3RpbmN0X2lkJzogU3RyaW5nKHRoaXMuX21peHBhbmVsLmdldF9kaXN0aW5jdF9pZCgpKSxcbiAgICB9O1xuXG4gICAgLy8gc2VuZCBJRCBtYW5hZ2VtZW50IHByb3BzIGlmIHRoZXkgZXhpc3RcbiAgICB2YXIgZGV2aWNlSWQgPSB0aGlzLl9taXhwYW5lbC5nZXRfcHJvcGVydHkoJyRkZXZpY2VfaWQnKTtcbiAgICBpZiAoZGV2aWNlSWQpIHtcbiAgICAgICAgdXNlcklkSW5mb1snJGRldmljZV9pZCddID0gZGV2aWNlSWQ7XG4gICAgfVxuICAgIHZhciB1c2VySWQgPSB0aGlzLl9taXhwYW5lbC5nZXRfcHJvcGVydHkoJyR1c2VyX2lkJyk7XG4gICAgaWYgKHVzZXJJZCkge1xuICAgICAgICB1c2VySWRJbmZvWyckdXNlcl9pZCddID0gdXNlcklkO1xuICAgIH1cbiAgICByZXR1cm4gdXNlcklkSW5mbztcbn07XG5cblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLnVubG9hZFBlcnNpc3RlZERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5iYXRjaGVyLnN0b3AoKTtcblxuICAgIHJldHVybiB0aGlzLnF1ZXVlU3RvcmFnZS5pbml0KCkuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciBpbml0aWFsaXppbmcgSW5kZXhlZERCIHN0b3JhZ2UgZm9yIHVubG9hZGluZyBwZXJzaXN0ZWQgZGF0YS4nKTtcbiAgICB9LmJpbmQodGhpcykpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBpZiB0aGUgcmVjb3JkaW5nIGlzIHRvbyBzaG9ydCwganVzdCBkZWxldGUgYW55IHN0b3JlZCBldmVudHMgd2l0aG91dCBmbHVzaGluZ1xuICAgICAgICBpZiAodGhpcy5nZXREdXJhdGlvbk1zKCkgPCB0aGlzLl9nZXRSZWNvcmRNaW5NcygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZVN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLmJhdGNoZXJLZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYmF0Y2hlci5mbHVzaCgpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWVTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5iYXRjaGVyS2V5KTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbn07XG5cblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uKGNvbmZpZ1Zhcikge1xuICAgIHJldHVybiB0aGlzLl9taXhwYW5lbC5nZXRfY29uZmlnKGNvbmZpZ1Zhcik7XG59O1xuXG4vLyBBbGlhcyBmb3IgZ2V0Q29uZmlnLCB1c2VkIGJ5IHRoZSBjb21tb24gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYiBmdW5jdGlvbiB3aGljaFxuLy8gcmVhY2hlcyBpbnRvIHRoaXMgY2xhc3MgaW5zdGFuY2UgYW5kIGV4cGVjdHMgdGhlIHNuYWtlIGNhc2UgdmVyc2lvbiBvZiB0aGUgZnVuY3Rpb24uXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5nZXRfY29uZmlnID0gZnVuY3Rpb24oY29uZmlnVmFyKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29uZmlnKGNvbmZpZ1Zhcik7XG59O1xuXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5zdGFydFJlY29yZGluZyA9IGZ1bmN0aW9uIChzaG91bGRTdG9wQmF0Y2hlcikge1xuICAgIGlmICh0aGlzLl9ycndlYlJlY29yZCA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdycndlYiByZWNvcmQgZnVuY3Rpb24gbm90IHByb3ZpZGVkLiAnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zdG9wUmVjb3JkaW5nICE9PSBudWxsKSB7XG4gICAgICAgIGxvZ2dlciQzLmxvZygnUmVjb3JkaW5nIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHNraXBwaW5nIHN0YXJ0UmVjb3JkaW5nLicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5yZWNvcmRNYXhNcyA9IHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfbWF4X21zJyk7XG4gICAgaWYgKHRoaXMucmVjb3JkTWF4TXMgPiBNQVhfUkVDT1JESU5HX01TKSB7XG4gICAgICAgIHRoaXMucmVjb3JkTWF4TXMgPSBNQVhfUkVDT1JESU5HX01TO1xuICAgICAgICBsb2dnZXIkMy5jcml0aWNhbCgncmVjb3JkX21heF9tcyBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuICcgKyBNQVhfUkVDT1JESU5HX01TICsgJ21zLiBDYXBwaW5nIHZhbHVlLicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5tYXhFeHBpcmVzKSB7XG4gICAgICAgIHRoaXMubWF4RXhwaXJlcyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgdGhpcy5yZWNvcmRNYXhNcztcbiAgICB9XG5cbiAgICB0aGlzLnJlY29yZE1pbk1zID0gdGhpcy5fZ2V0UmVjb3JkTWluTXMoKTtcblxuICAgIGlmICghdGhpcy5yZXBsYXlTdGFydFRpbWUpIHtcbiAgICAgICAgdGhpcy5yZXBsYXlTdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgdGhpcy5iYXRjaFN0YXJ0VXJsID0gXy5pbmZvLmN1cnJlbnRVcmwoKTtcbiAgICAgICAgdGhpcy5yZXBsYXlTdGFydFVybCA9IF8uaW5mby5jdXJyZW50VXJsKCk7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFN0b3BCYXRjaGVyIHx8IHRoaXMucmVjb3JkTWluTXMgPiAwKSB7XG4gICAgICAgIC8vIHRoZSBwcmltYXJ5IGNhc2UgZm9yIHNob3VsZFN0b3BCYXRjaGVyIGlzIHdoZW4gd2UncmUgc3RhcnRpbmcgcmVjb3JkaW5nIGFmdGVyIGEgcmVzZXRcbiAgICAgICAgLy8gYW5kIGRvbid0IHdhbnQgdG8gc2VuZCBhbnl0aGluZyBvdmVyIHRoZSBuZXR3b3JrIHVudGlsIHRoZXJlJ3NcbiAgICAgICAgLy8gYWN0dWFsIHVzZXIgYWN0aXZpdHlcbiAgICAgICAgLy8gdGhpcyBhbHNvIGFwcGxpZXMgaWYgdGhlIG1pbmltdW0gcmVjb3JkaW5nIGxlbmd0aCBoYXMgbm90IGJlZW4gaGl0IHlldFxuICAgICAgICAvLyBzbyB0aGF0IHdlIGRvbid0IHNlbmQgZGF0YSB1bnRpbCB3ZSBrbm93IHRoZSByZWNvcmRpbmcgd2lsbCBiZSBsb25nIGVub3VnaFxuICAgICAgICB0aGlzLmJhdGNoZXIuc3RvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYmF0Y2hlci5zdGFydCgpO1xuICAgIH1cblxuICAgIHZhciByZXNldElkbGVUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5pZGxlVGltZW91dElkKTtcbiAgICAgICAgdmFyIGlkbGVUaW1lb3V0TXMgPSB0aGlzLmdldENvbmZpZygncmVjb3JkX2lkbGVfdGltZW91dF9tcycpO1xuICAgICAgICB0aGlzLmlkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KHRoaXMuX29uSWRsZVRpbWVvdXQsIGlkbGVUaW1lb3V0TXMpO1xuICAgICAgICB0aGlzLmlkbGVFeHBpcmVzID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBpZGxlVGltZW91dE1zO1xuICAgIH0uYmluZCh0aGlzKTtcbiAgICByZXNldElkbGVUaW1lb3V0KCk7XG5cbiAgICB2YXIgYmxvY2tTZWxlY3RvciA9IHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfYmxvY2tfc2VsZWN0b3InKTtcbiAgICBpZiAoYmxvY2tTZWxlY3RvciA9PT0gJycgfHwgYmxvY2tTZWxlY3RvciA9PT0gbnVsbCkge1xuICAgICAgICBibG9ja1NlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX3N0b3BSZWNvcmRpbmcgPSB0aGlzLl9ycndlYlJlY29yZCh7XG4gICAgICAgICAgICAnZW1pdCc6IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkbGVFeHBpcmVzICYmIHRoaXMuaWRsZUV4cGlyZXMgPCBldi50aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25JZGxlVGltZW91dCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1VzZXJFdmVudChldikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYmF0Y2hlci5zdG9wcGVkICYmIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5yZXBsYXlTdGFydFRpbWUgPj0gdGhpcy5yZWNvcmRNaW5Ncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnQgZmx1c2hpbmcgYWdhaW4gYWZ0ZXIgdXNlciBhY3Rpdml0eVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iYXRjaGVyLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzZXRJZGxlVGltZW91dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBwcm9taXNlIG9ubHkgdXNlZCB0byBhd2FpdCBkdXJpbmcgdGVzdHNcbiAgICAgICAgICAgICAgICB0aGlzLl9fZW5xdWV1ZVByb21pc2UgPSB0aGlzLmJhdGNoZXIuZW5xdWV1ZShldik7XG5cbiAgICAgICAgICAgICAgICAvLyBDYXB0dXJlIHRoZSB0aW1lc3RhbXAgb2YgdGhlIGxhc3QgZXZlbnQgZm9yIGR1cmF0aW9uIGNhbGN1bGF0aW9uLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhc3RFdmVudFRpbWVzdGFtcCA9PT0gbnVsbCB8fCBldi50aW1lc3RhbXAgPiB0aGlzLmxhc3RFdmVudFRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RFdmVudFRpbWVzdGFtcCA9IGV2LnRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcyksXG4gICAgICAgICAgICAnYmxvY2tDbGFzcyc6IHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfYmxvY2tfY2xhc3MnKSxcbiAgICAgICAgICAgICdibG9ja1NlbGVjdG9yJzogYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICAgICdjb2xsZWN0Rm9udHMnOiB0aGlzLmdldENvbmZpZygncmVjb3JkX2NvbGxlY3RfZm9udHMnKSxcbiAgICAgICAgICAgICdkYXRhVVJMT3B0aW9ucyc6IHsgLy8gY2FudmFzIGltYWdlIG9wdGlvbnMgKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MQ2FudmFzRWxlbWVudC90b0RhdGFVUkwpXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnaW1hZ2Uvd2VicCcsXG4gICAgICAgICAgICAgICAgJ3F1YWxpdHknOiAwLjZcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWFza0FsbElucHV0cyc6IHRydWUsXG4gICAgICAgICAgICAnbWFza1RleHRDbGFzcyc6IHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfbWFza190ZXh0X2NsYXNzJyksXG4gICAgICAgICAgICAnbWFza1RleHRTZWxlY3Rvcic6IHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfbWFza190ZXh0X3NlbGVjdG9yJyksXG4gICAgICAgICAgICAncmVjb3JkQ2FudmFzJzogdGhpcy5nZXRDb25maWcoJ3JlY29yZF9jYW52YXMnKSxcbiAgICAgICAgICAgICdzYW1wbGluZyc6IHtcbiAgICAgICAgICAgICAgICAnY2FudmFzJzogMTVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncGx1Z2lucyc6IHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfY29uc29sZScpID8gW1xuICAgICAgICAgICAgICAgIGdldFJlY29yZENvbnNvbGVQbHVnaW4oe1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdpZnlPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmdMZW5ndGhMaW1pdDogMTAwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bU9mS2V5c0xpbWl0OiA1MCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoT2ZMaW1pdDogMlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF0gOiBbXVxuICAgICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignVW5leHBlY3RlZCBlcnJvciB3aGVuIHN0YXJ0aW5nIHJyd2ViIHJlY29yZGluZy4nLCBlcnIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5fc3RvcFJlY29yZGluZyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdycndlYiBmYWlsZWQgdG8gc3RhcnQsIHNraXBwaW5nIHRoaXMgcmVjb3JkaW5nLicpO1xuICAgICAgICB0aGlzLl9zdG9wUmVjb3JkaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdG9wUmVjb3JkaW5nKCk7IC8vIHN0b3AgYmF0Y2hlciBsb29waW5nIGFuZCBhbnkgdGltZW91dHNcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtYXhUaW1lb3V0TXMgPSB0aGlzLm1heEV4cGlyZXMgLSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB0aGlzLm1heFRpbWVvdXRJZCA9IHNldFRpbWVvdXQodGhpcy5fb25NYXhMZW5ndGhSZWFjaGVkLmJpbmQodGhpcyksIG1heFRpbWVvdXRNcyk7XG59O1xuXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5zdG9wUmVjb3JkaW5nID0gZnVuY3Rpb24gKHNraXBGbHVzaCkge1xuICAgIC8vIHN0b3JlIHRoZSB1c2VyIElEIGluZm8gaW4gY2FzZSB0aGlzIGlzIGdldHRpbmcgY2FsbGVkIGluIG1peHBhbmVsLnJlc2V0KClcbiAgICB0aGlzLmZpbmFsRmx1c2hVc2VySWRJbmZvID0gdGhpcy5nZXRVc2VySWRJbmZvKCk7XG5cbiAgICBpZiAoIXRoaXMuaXNScndlYlN0b3BwZWQoKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fc3RvcFJlY29yZGluZygpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIHdpdGggcnJ3ZWIgc3RvcFJlY29yZGluZycsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RvcFJlY29yZGluZyA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGZsdXNoUHJvbWlzZTtcbiAgICBpZiAodGhpcy5iYXRjaGVyLnN0b3BwZWQpIHtcbiAgICAgICAgLy8gbmV2ZXIgZ290IHVzZXIgYWN0aXZpdHkgdG8gZmx1c2ggYWZ0ZXIgcmVzZXQsIHNvIGp1c3QgY2xlYXIgdGhlIGJhdGNoZXJcbiAgICAgICAgZmx1c2hQcm9taXNlID0gdGhpcy5iYXRjaGVyLmNsZWFyKCk7XG4gICAgfSBlbHNlIGlmICghc2tpcEZsdXNoKSB7XG4gICAgICAgIC8vIGZsdXNoIGFueSByZW1haW5pbmcgZXZlbnRzIGZyb20gcnVubmluZyBiYXRjaGVyXG4gICAgICAgIGZsdXNoUHJvbWlzZSA9IHRoaXMuYmF0Y2hlci5mbHVzaCgpO1xuICAgIH1cbiAgICB0aGlzLmJhdGNoZXIuc3RvcCgpO1xuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuaWRsZVRpbWVvdXRJZCk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubWF4VGltZW91dElkKTtcbiAgICByZXR1cm4gZmx1c2hQcm9taXNlO1xufTtcblxuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUuaXNScndlYlN0b3BwZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3BSZWNvcmRpbmcgPT09IG51bGw7XG59O1xuXG5cbi8qKlxuICogRmx1c2hlcyB0aGUgY3VycmVudCBiYXRjaCBvZiBldmVudHMgdG8gdGhlIHNlcnZlciwgYnV0IHBhc3NlcyBhbiBvcHQtb3V0IGNhbGxiYWNrIHRvIG1ha2Ugc3VyZVxuICogd2Ugc3RvcCByZWNvcmRpbmcgYW5kIGR1bXAgYW55IHF1ZXVlZCBldmVudHMgaWYgdGhlIHVzZXIgaGFzIG9wdGVkIG91dC5cbiAqL1xuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUuZmx1c2hFdmVudHNXaXRoT3B0T3V0ID0gZnVuY3Rpb24gKGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgdmFyIG9uT3B0T3V0ID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgLy8gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYiBpbnZva2VzIHRoaXMgZnVuY3Rpb24gd2l0aCBjb2RlPTAgd2hlbiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0XG4gICAgICAgIGlmIChjb2RlID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BSZWNvcmRpbmcoKTtcbiAgICAgICAgICAgIGNiKHtlcnJvcjogJ1RyYWNraW5nIGhhcyBiZWVuIG9wdGVkIG91dCwgc3RvcHBpbmcgcmVjb3JkaW5nLid9KTtcbiAgICAgICAgfVxuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX2ZsdXNoRXZlbnRzKGRhdGEsIG9wdGlvbnMsIGNiLCBvbk9wdE91dCk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtTZXJpYWxpemVkUmVjb3JkaW5nfVxuICovXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gZG9uJ3QgYnJlYWsgaWYgbWl4cGFuZWwgaW5zdGFuY2Ugd2FzIGRlc3Ryb3llZCBhdCBzb21lIHBvaW50XG4gICAgdmFyIHRhYklkO1xuICAgIHRyeSB7XG4gICAgICAgIHRhYklkID0gdGhpcy5fbWl4cGFuZWwuZ2V0X3RhYl9pZCgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgZ2V0dGluZyB0YWIgSUQgZm9yIHNlcmlhbGl6YXRpb24gJywgZSk7XG4gICAgICAgIHRhYklkID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAncmVwbGF5SWQnOiB0aGlzLnJlcGxheUlkLFxuICAgICAgICAnc2VxTm8nOiB0aGlzLnNlcU5vLFxuICAgICAgICAncmVwbGF5U3RhcnRUaW1lJzogdGhpcy5yZXBsYXlTdGFydFRpbWUsXG4gICAgICAgICdiYXRjaFN0YXJ0VXJsJzogdGhpcy5iYXRjaFN0YXJ0VXJsLFxuICAgICAgICAncmVwbGF5U3RhcnRVcmwnOiB0aGlzLnJlcGxheVN0YXJ0VXJsLFxuICAgICAgICAnbGFzdEV2ZW50VGltZXN0YW1wJzogdGhpcy5sYXN0RXZlbnRUaW1lc3RhbXAsXG4gICAgICAgICdpZGxlRXhwaXJlcyc6IHRoaXMuaWRsZUV4cGlyZXMsXG4gICAgICAgICdtYXhFeHBpcmVzJzogdGhpcy5tYXhFeHBpcmVzLFxuICAgICAgICAndGFiSWQnOiB0YWJJZCxcbiAgICB9O1xufTtcblxuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7U2VyaWFsaXplZFJlY29yZGluZ30gc2VyaWFsaXplZFJlY29yZGluZ1xuICogQHBhcmFtIHtTZXNzaW9uUmVjb3JkaW5nT3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge1Nlc3Npb25SZWNvcmRpbmd9XG4gKi9cblNlc3Npb25SZWNvcmRpbmcuZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoc2VyaWFsaXplZFJlY29yZGluZywgb3B0aW9ucykge1xuICAgIHZhciByZWNvcmRpbmcgPSBuZXcgU2Vzc2lvblJlY29yZGluZyhfLmV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgICByZXBsYXlJZDogc2VyaWFsaXplZFJlY29yZGluZ1sncmVwbGF5SWQnXSxcbiAgICAgICAgYmF0Y2hTdGFydFVybDogc2VyaWFsaXplZFJlY29yZGluZ1snYmF0Y2hTdGFydFVybCddLFxuICAgICAgICByZXBsYXlTdGFydFVybDogc2VyaWFsaXplZFJlY29yZGluZ1sncmVwbGF5U3RhcnRVcmwnXSxcbiAgICAgICAgaWRsZUV4cGlyZXM6IHNlcmlhbGl6ZWRSZWNvcmRpbmdbJ2lkbGVFeHBpcmVzJ10sXG4gICAgICAgIG1heEV4cGlyZXM6IHNlcmlhbGl6ZWRSZWNvcmRpbmdbJ21heEV4cGlyZXMnXSxcbiAgICAgICAgcmVwbGF5U3RhcnRUaW1lOiBzZXJpYWxpemVkUmVjb3JkaW5nWydyZXBsYXlTdGFydFRpbWUnXSxcbiAgICAgICAgbGFzdEV2ZW50VGltZXN0YW1wOiBzZXJpYWxpemVkUmVjb3JkaW5nWydsYXN0RXZlbnRUaW1lc3RhbXAnXSxcbiAgICAgICAgc2VxTm86IHNlcmlhbGl6ZWRSZWNvcmRpbmdbJ3NlcU5vJ10sXG4gICAgICAgIHNoYXJlZExvY2tTdG9yYWdlOiBvcHRpb25zLnNoYXJlZExvY2tTdG9yYWdlLFxuICAgIH0pKTtcblxuICAgIHJldHVybiByZWNvcmRpbmc7XG59O1xuXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5fc2VuZFJlcXVlc3QgPSBmdW5jdGlvbihjdXJyZW50UmVwbGF5SWQsIHJlcVBhcmFtcywgcmVxQm9keSwgY2FsbGJhY2spIHtcbiAgICB2YXIgb25TdWNjZXNzID0gZnVuY3Rpb24gKHJlc3BvbnNlLCByZXNwb25zZUJvZHkpIHtcbiAgICAgICAgLy8gVXBkYXRlIGJhdGNoIHNwZWNpZmljIHByb3BzIG9ubHkgaWYgdGhlIHJlcXVlc3Qgd2FzIHN1Y2Nlc3NmdWwgdG8gZ3VhcmFudGVlIG9yZGVyaW5nLlxuICAgICAgICAvLyBSZXF1ZXN0QmF0Y2hlciB3aWxsIGFsd2F5cyBmbHVzaCB0aGUgbmV4dCBiYXRjaCBhZnRlciB0aGUgcHJldmlvdXMgb25lIHN1Y2NlZWRzLlxuICAgICAgICAvLyBleHRyYSBjaGVjayB0byBzZWUgaWYgdGhlIHJlcGxheSBJRCBoYXMgY2hhbmdlZCBzbyB0aGF0IHdlIGRvbid0IGluY3JlbWVudCB0aGUgc2VxTm8gb24gdGhlIHdyb25nIHJlcGxheVxuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDAgJiYgdGhpcy5yZXBsYXlJZCA9PT0gY3VycmVudFJlcGxheUlkKSB7XG4gICAgICAgICAgICB0aGlzLnNlcU5vKys7XG4gICAgICAgICAgICB0aGlzLmJhdGNoU3RhcnRVcmwgPSBfLmluZm8uY3VycmVudFVybCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fb25CYXRjaFNlbnQoKTtcbiAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgc3RhdHVzOiAwLFxuICAgICAgICAgICAgaHR0cFN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgIHJlc3BvbnNlQm9keTogcmVzcG9uc2VCb2R5LFxuICAgICAgICAgICAgcmV0cnlBZnRlcjogcmVzcG9uc2UuaGVhZGVycy5nZXQoJ1JldHJ5LUFmdGVyJylcbiAgICAgICAgfSk7XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIHZhciBhcGlIb3N0ID0gKHRoaXMuX21peHBhbmVsLmdldF9hcGlfaG9zdCAmJiB0aGlzLl9taXhwYW5lbC5nZXRfYXBpX2hvc3QoJ3JlY29yZCcpKSB8fCB0aGlzLmdldENvbmZpZygnYXBpX2hvc3QnKTtcbiAgICB3aW5bJ2ZldGNoJ10oYXBpSG9zdCArICcvJyArIHRoaXMuZ2V0Q29uZmlnKCdhcGlfcm91dGVzJylbJ3JlY29yZCddICsgJz8nICsgbmV3IFVSTFNlYXJjaFBhcmFtcyhyZXFQYXJhbXMpLCB7XG4gICAgICAgICdtZXRob2QnOiAnUE9TVCcsXG4gICAgICAgICdoZWFkZXJzJzoge1xuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiAnQmFzaWMgJyArIGJ0b2EodGhpcy5nZXRDb25maWcoJ3Rva2VuJykgKyAnOicpLFxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nXG4gICAgICAgIH0sXG4gICAgICAgICdib2R5JzogcmVxQm9keSxcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICByZXNwb25zZS5qc29uKCkudGhlbihmdW5jdGlvbiAocmVzcG9uc2VCb2R5KSB7XG4gICAgICAgICAgICBvblN1Y2Nlc3MocmVzcG9uc2UsIHJlc3BvbnNlQm9keSk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgY2FsbGJhY2soe2Vycm9yOiBlcnJvcn0pO1xuICAgICAgICB9KTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgY2FsbGJhY2soe2Vycm9yOiBlcnJvciwgaHR0cFN0YXR1c0NvZGU6IDB9KTtcbiAgICB9KTtcbn07XG5cblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLl9mbHVzaEV2ZW50cyA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIoZnVuY3Rpb24gKGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG51bUV2ZW50cyA9IGRhdGEubGVuZ3RoO1xuXG4gICAgaWYgKG51bUV2ZW50cyA+IDApIHtcbiAgICAgICAgdmFyIHJlcGxheUlkID0gdGhpcy5yZXBsYXlJZDtcblxuICAgICAgICAvLyBlYWNoIHJyd2ViIGV2ZW50IGhhcyBhIHRpbWVzdGFtcCAtIGxldmVyYWdlIHRob3NlIHRvIGdldCB0aW1lIHByb3BlcnRpZXNcbiAgICAgICAgdmFyIGJhdGNoU3RhcnRUaW1lID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBiYXRjaEVuZFRpbWUgPSAtSW5maW5pdHk7XG4gICAgICAgIHZhciBoYXNGdWxsU25hcHNob3QgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1FdmVudHM7IGkrKykge1xuICAgICAgICAgICAgYmF0Y2hTdGFydFRpbWUgPSBNYXRoLm1pbihiYXRjaFN0YXJ0VGltZSwgZGF0YVtpXS50aW1lc3RhbXApO1xuICAgICAgICAgICAgYmF0Y2hFbmRUaW1lID0gTWF0aC5tYXgoYmF0Y2hFbmRUaW1lLCBkYXRhW2ldLnRpbWVzdGFtcCk7XG4gICAgICAgICAgICBpZiAoZGF0YVtpXS50eXBlID09PSBFdmVudFR5cGUuRnVsbFNuYXBzaG90KSB7XG4gICAgICAgICAgICAgICAgaGFzRnVsbFNuYXBzaG90ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNlcU5vID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoIWhhc0Z1bGxTbmFwc2hvdCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHtlcnJvcjogJ0ZpcnN0IGJhdGNoIGRvZXMgbm90IGNvbnRhaW4gYSBmdWxsIHNuYXBzaG90LiBBYm9ydGluZyByZWNvcmRpbmcuJ30pO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcFJlY29yZGluZyh0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlcGxheVN0YXJ0VGltZSA9IGJhdGNoU3RhcnRUaW1lO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLnJlcGxheVN0YXJ0VGltZSkge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignUmVwbGF5IHN0YXJ0IHRpbWUgbm90IHNldCBidXQgc2VxTm8gaXMgbm90IDAuIFVzaW5nIGN1cnJlbnQgYmF0Y2ggc3RhcnQgdGltZSBhcyBhIGZhbGxiYWNrLicpO1xuICAgICAgICAgICAgdGhpcy5yZXBsYXlTdGFydFRpbWUgPSBiYXRjaFN0YXJ0VGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXBsYXlMZW5ndGhNcyA9IGJhdGNoRW5kVGltZSAtIHRoaXMucmVwbGF5U3RhcnRUaW1lO1xuXG4gICAgICAgIHZhciByZXFQYXJhbXMgPSB7XG4gICAgICAgICAgICAnJGN1cnJlbnRfdXJsJzogdGhpcy5iYXRjaFN0YXJ0VXJsLFxuICAgICAgICAgICAgJyRsaWJfdmVyc2lvbic6IENvbmZpZy5MSUJfVkVSU0lPTixcbiAgICAgICAgICAgICdiYXRjaF9zdGFydF90aW1lJzogYmF0Y2hTdGFydFRpbWUgLyAxMDAwLFxuICAgICAgICAgICAgJ21wX2xpYic6ICd3ZWInLFxuICAgICAgICAgICAgJ3JlcGxheV9pZCc6IHJlcGxheUlkLFxuICAgICAgICAgICAgJ3JlcGxheV9sZW5ndGhfbXMnOiByZXBsYXlMZW5ndGhNcyxcbiAgICAgICAgICAgICdyZXBsYXlfc3RhcnRfdGltZSc6IHRoaXMucmVwbGF5U3RhcnRUaW1lIC8gMTAwMCxcbiAgICAgICAgICAgICdyZXBsYXlfc3RhcnRfdXJsJzogdGhpcy5yZXBsYXlTdGFydFVybCxcbiAgICAgICAgICAgICdzZXEnOiB0aGlzLnNlcU5vXG4gICAgICAgIH07XG4gICAgICAgIHZhciBldmVudHNKc29uID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocmVxUGFyYW1zLCB0aGlzLmdldFVzZXJJZEluZm8oKSk7XG5cbiAgICAgICAgaWYgKGNhblVzZUNvbXByZXNzaW9uU3RyZWFtKHVzZXJBZ2VudCwgbmF2aWdhdG9yLnZlbmRvciwgd2luZG93T3BlcmEpKSB7XG4gICAgICAgICAgICB2YXIganNvblN0cmVhbSA9IG5ldyBCbG9iKFtldmVudHNKc29uXSwge3R5cGU6ICdhcHBsaWNhdGlvbi9qc29uJ30pLnN0cmVhbSgpO1xuICAgICAgICAgICAgdmFyIGd6aXBTdHJlYW0gPSBqc29uU3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBDb21wcmVzc2lvblN0cmVhbSgnZ3ppcCcpKTtcbiAgICAgICAgICAgIG5ldyBSZXNwb25zZShnemlwU3RyZWFtKVxuICAgICAgICAgICAgICAgIC5ibG9iKClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihjb21wcmVzc2VkQmxvYikge1xuICAgICAgICAgICAgICAgICAgICByZXFQYXJhbXNbJ2Zvcm1hdCddID0gJ2d6aXAnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZW5kUmVxdWVzdChyZXBsYXlJZCwgcmVxUGFyYW1zLCBjb21wcmVzc2VkQmxvYiwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXFQYXJhbXNbJ2Zvcm1hdCddID0gJ2JvZHknO1xuICAgICAgICAgICAgdGhpcy5fc2VuZFJlcXVlc3QocmVwbGF5SWQsIHJlcVBhcmFtcywgZXZlbnRzSnNvbiwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUucmVwb3J0RXJyb3IgPSBmdW5jdGlvbihtc2csIGVycikge1xuICAgIGxvZ2dlciQzLmVycm9yLmFwcGx5KGxvZ2dlciQzLmVycm9yLCBhcmd1bWVudHMpO1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghZXJyICYmICEobXNnIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgICBtc2cgPSBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdldENvbmZpZygnZXJyb3JfcmVwb3J0ZXInKShtc2csIGVycik7XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgbG9nZ2VyJDMuZXJyb3IoZXJyKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGR1cmF0aW9uIG9mIHRoZSByZWNvcmRpbmcgaW4gbWlsbGlzZWNvbmRzLCBiYXNlZCBvbiB0aGUgc3RhcnQgdGltZSBhbmQgdGltZSBvZiBsYXN0IHJlY29yZGVkIGV2ZW50LlxuICogQHJldHVybnMge251bWJlcn0gVGhlIGR1cmF0aW9uIG9mIHRoZSByZWNvcmRpbmcgaW4gbWlsbGlzZWNvbmRzLiBSZXR1cm5zIDAgaWYgcmVjb3JkaW5nIGhhc24ndCBzdGFydGVkLlxuICovXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5nZXREdXJhdGlvbk1zID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucmVwbGF5U3RhcnRUaW1lID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSByZWNvcmRpbmcgaGFzIG5vIGV2ZW50cywgYXNzdW1lIGl0IGlzIGluIHByb2dyZXNzIGFuZCB1c2UgdGhlIGN1cnJlbnQgdGltZSBhcyB0aGUgZW5kIHRpbWUuXG4gICAgaWYgKHRoaXMubGFzdEV2ZW50VGltZXN0YW1wID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMucmVwbGF5U3RhcnRUaW1lO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmxhc3RFdmVudFRpbWVzdGFtcCAtIHRoaXMucmVwbGF5U3RhcnRUaW1lO1xufTtcblxuLyoqXG4gKiBMYXppbHkgbG9hZHMgdGhlIG1pbmltdW0gcmVjb3JkaW5nIGxlbmd0aCBjb25maWcgaW4gbWlsbGlzZWNvbmRzLCByZXNwZWN0aW5nIHRoZSBtYXhpbXVtIGxpbWl0LlxuICogQHJldHVybnMge251bWJlcn0gVGhlIG1pbmltdW0gcmVjb3JkaW5nIGxlbmd0aCBpbiBtaWxsaXNlY29uZHMuXG4gKi9cblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLl9nZXRSZWNvcmRNaW5NcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb25maWdWYWx1ZSA9IHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfbWluX21zJyk7XG5cbiAgICBpZiAoY29uZmlnVmFsdWUgPiBNQVhfVkFMVUVfRk9SX01JTl9SRUNPUkRJTkdfTVMpIHtcbiAgICAgICAgbG9nZ2VyJDMuY3JpdGljYWwoJ3JlY29yZF9taW5fbXMgY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiAnICsgTUFYX1ZBTFVFX0ZPUl9NSU5fUkVDT1JESU5HX01TICsgJ21zLiBDYXBwaW5nIHZhbHVlLicpO1xuICAgICAgICByZXR1cm4gTUFYX1ZBTFVFX0ZPUl9NSU5fUkVDT1JESU5HX01TO1xuICAgIH1cblxuICAgIHJldHVybiBjb25maWdWYWx1ZTtcbn07XG5cbi8qKlxuICogTW9kdWxlIGZvciBoYW5kbGluZyB0aGUgc3RvcmFnZSBhbmQgcmV0cmlldmFsIG9mIHJlY29yZGluZyBtZXRhZGF0YSBhcyB3ZWxsIGFzIGFueSBhY3RpdmUgcmVjb3JkaW5ncy5cbiAqIE1ha2VzIHN1cmUgdGhhdCBvbmx5IG9uZSB0YWIgY2FuIGJlIHJlY29yZGluZyBhdCBhIHRpbWUuXG4gKi9cbnZhciBSZWNvcmRpbmdSZWdpc3RyeSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLyoqIEB0eXBlIHtJREJTdG9yYWdlV3JhcHBlcn0gKi9cbiAgICB0aGlzLmlkYiA9IG5ldyBJREJTdG9yYWdlV3JhcHBlcihSRUNPUkRJTkdfUkVHSVNUUllfU1RPUkVfTkFNRSk7XG4gICAgdGhpcy5lcnJvclJlcG9ydGVyID0gb3B0aW9ucy5lcnJvclJlcG9ydGVyO1xuICAgIHRoaXMubWl4cGFuZWxJbnN0YW5jZSA9IG9wdGlvbnMubWl4cGFuZWxJbnN0YW5jZTtcbiAgICB0aGlzLnNoYXJlZExvY2tTdG9yYWdlID0gb3B0aW9ucy5zaGFyZWRMb2NrU3RvcmFnZTtcbn07XG5cblJlY29yZGluZ1JlZ2lzdHJ5LnByb3RvdHlwZS5pc1BlcnNpc3RlbmNlRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhdGhpcy5taXhwYW5lbEluc3RhbmNlLmdldF9jb25maWcoJ2Rpc2FibGVfcGVyc2lzdGVuY2UnKTtcbn07XG5cblJlY29yZGluZ1JlZ2lzdHJ5LnByb3RvdHlwZS5oYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICB0aGlzLmVycm9yUmVwb3J0ZXIoJ0luZGV4ZWREQiBlcnJvcjogJywgZXJyKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vc2Vzc2lvbi1yZWNvcmRpbmcnKS5TZXJpYWxpemVkUmVjb3JkaW5nfSBzZXJpYWxpemVkUmVjb3JkaW5nXG4gKi9cblJlY29yZGluZ1JlZ2lzdHJ5LnByb3RvdHlwZS5zZXRBY3RpdmVSZWNvcmRpbmcgPSBmdW5jdGlvbiAoc2VyaWFsaXplZFJlY29yZGluZykge1xuICAgIGlmICghdGhpcy5pc1BlcnNpc3RlbmNlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIHZhciB0YWJJZCA9IHNlcmlhbGl6ZWRSZWNvcmRpbmdbJ3RhYklkJ107XG4gICAgaWYgKCF0YWJJZCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ05vIHRhYiBJRCBpcyBzZXQsIGNhbm5vdCBwZXJzaXN0IHJlY29yZGluZyBtZXRhZGF0YS4nKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuaWRiLmluaXQoKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pZGIuc2V0SXRlbSh0YWJJZCwgc2VyaWFsaXplZFJlY29yZGluZyk7XG4gICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgLmNhdGNoKHRoaXMuaGFuZGxlRXJyb3IuYmluZCh0aGlzKSk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtQcm9taXNlPGltcG9ydCgnLi9zZXNzaW9uLXJlY29yZGluZycpLlNlcmlhbGl6ZWRSZWNvcmRpbmc+fVxuICovXG5SZWNvcmRpbmdSZWdpc3RyeS5wcm90b3R5cGUuZ2V0QWN0aXZlUmVjb3JkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc1BlcnNpc3RlbmNlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZShudWxsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5pZGIuaW5pdCgpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlkYi5nZXRJdGVtKHRoaXMubWl4cGFuZWxJbnN0YW5jZS5nZXRfdGFiX2lkKCkpO1xuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChzZXJpYWxpemVkUmVjb3JkaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNSZWNvcmRpbmdFeHBpcmVkKHNlcmlhbGl6ZWRSZWNvcmRpbmcpID8gbnVsbCA6IHNlcmlhbGl6ZWRSZWNvcmRpbmc7XG4gICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgLmNhdGNoKHRoaXMuaGFuZGxlRXJyb3IuYmluZCh0aGlzKSk7XG59O1xuXG5SZWNvcmRpbmdSZWdpc3RyeS5wcm90b3R5cGUuY2xlYXJBY3RpdmVSZWNvcmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaXNQZXJzaXN0ZW5jZUVuYWJsZWQoKSkge1xuICAgICAgICAvLyBtYXJrIHJlY29yZGluZyBhcyBleHBpcmVkIGluc3RlYWQgb2YgZGVsZXRpbmcgaXQgaW4gY2FzZSB0aGUgcGFnZSB1bmxvYWRzIG1pZC1mbHVzaCBhbmQgZG9lc24ndCBtYWtlIGl0IHRvIGluZ2VzdGlvbi5cbiAgICAgICAgLy8gdGhpcyB3aWxsIGVuc3VyZSB0aGUgbmV4dCBwYWdlbG9hZCB3aWxsIGZsdXNoIHRoZSByZW1haW5pbmcgZXZlbnRzLCBidXQgbm90IHRyeSB0byBjb250aW51ZSB0aGUgcmVjb3JkaW5nLlxuICAgICAgICByZXR1cm4gdGhpcy5tYXJrQWN0aXZlUmVjb3JkaW5nRXhwaXJlZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGV0ZUFjdGl2ZVJlY29yZGluZygpO1xuICAgIH1cbn07XG5cblJlY29yZGluZ1JlZ2lzdHJ5LnByb3RvdHlwZS5tYXJrQWN0aXZlUmVjb3JkaW5nRXhwaXJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBY3RpdmVSZWNvcmRpbmcoKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoc2VyaWFsaXplZFJlY29yZGluZykge1xuICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZWRSZWNvcmRpbmcpIHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkUmVjb3JkaW5nWydtYXhFeHBpcmVzJ10gPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldEFjdGl2ZVJlY29yZGluZyhzZXJpYWxpemVkUmVjb3JkaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAuY2F0Y2godGhpcy5oYW5kbGVFcnJvci5iaW5kKHRoaXMpKTtcbn07XG5cblJlY29yZGluZ1JlZ2lzdHJ5LnByb3RvdHlwZS5kZWxldGVBY3RpdmVSZWNvcmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gYXZvaWQgaW5pdGlhbGl6aW5nIElEQiBpZiB0aGlzIHJlZ2lzdHJ5IGluc3RhbmNlIGhhc24ndCBhbHJlYWR5IHdyaXR0ZW4gYSByZWNvcmRpbmdcbiAgICBpZiAodGhpcy5pZGIuaXNJbml0aWFsaXplZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkYi5yZW1vdmVJdGVtKHRoaXMubWl4cGFuZWxJbnN0YW5jZS5nZXRfdGFiX2lkKCkpXG4gICAgICAgICAgICAuY2F0Y2godGhpcy5oYW5kbGVFcnJvci5iaW5kKHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEZsdXNoIGFueSBpbmFjdGl2ZSByZWNvcmRpbmdzIGZyb20gdGhlIHJlZ2lzdHJ5IHRvIG1pbmltaXplIGRhdGEgbG9zcy5cbiAqIFRoZSBtYWluIGlkZWEgaGVyZSBpcyB0aGF0IHdlIGNhbiBmbHVzaCByZW1haW5pbmcgcnJ3ZWIgZXZlbnRzIG9uIHRoZSBuZXh0IHBhZ2UgbG9hZCBpZiBhIHRhYiBpcyBjbG9zZWQgbWlkLWJhdGNoLlxuICovXG5SZWNvcmRpbmdSZWdpc3RyeS5wcm90b3R5cGUuZmx1c2hJbmFjdGl2ZVJlY29yZGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzUGVyc2lzdGVuY2VFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKFtdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5pZGIuaW5pdCgpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWRiLmdldEFsbCgpO1xuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChzZXJpYWxpemVkUmVjb3JkaW5ncykge1xuICAgICAgICAgICAgLy8gY2xlYW4gdXAgYW55IGV4cGlyZWQgcmVjb3JkaW5ncyBmcm9tIHRoZSByZWdpc3RyeSwgbm9uLWV4cGlyZWQgb25lcyBtYXkgYmUgYWN0aXZlIGluIG90aGVyIHRhYnNcbiAgICAgICAgICAgIHZhciB1bmxvYWRQcm9taXNlcyA9IHNlcmlhbGl6ZWRSZWNvcmRpbmdzXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoc2VyaWFsaXplZFJlY29yZGluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNSZWNvcmRpbmdFeHBpcmVkKHNlcmlhbGl6ZWRSZWNvcmRpbmcpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoc2VyaWFsaXplZFJlY29yZGluZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2Vzc2lvblJlY29yZGluZyA9IFNlc3Npb25SZWNvcmRpbmcuZGVzZXJpYWxpemUoc2VyaWFsaXplZFJlY29yZGluZywge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWl4cGFuZWxJbnN0YW5jZTogdGhpcy5taXhwYW5lbEluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVkTG9ja1N0b3JhZ2U6IHRoaXMuc2hhcmVkTG9ja1N0b3JhZ2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXNzaW9uUmVjb3JkaW5nLnVubG9hZFBlcnNpc3RlZERhdGEoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4cGlyZWQgcmVjb3JkaW5nIHdhcyBzdWNjZXNzZnVsbHkgZmx1c2hlZCwgd2UgY2FuIGNsZWFuIGl0IHVwIGZyb20gdGhlIHJlZ2lzdHJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWRiLnJlbW92ZUl0ZW0oc2VyaWFsaXplZFJlY29yZGluZ1sndGFiSWQnXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2godGhpcy5oYW5kbGVFcnJvci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLmFsbCh1bmxvYWRQcm9taXNlcyk7XG4gICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgLmNhdGNoKHRoaXMuaGFuZGxlRXJyb3IuYmluZCh0aGlzKSk7XG59O1xuXG52YXIgbG9nZ2VyJDIgPSBjb25zb2xlX3dpdGhfcHJlZml4KCdyZWNvcmRlcicpO1xuXG4vKipcbiAqIFJlY29yZGVyIEFQSTogYnVuZGxlcyBycndlYiBhbmQgYW5kIGV4cG9zZXMgbWV0aG9kcyB0byBzdGFydCBhbmQgc3RvcCByZWNvcmRpbmdzLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm1peHBhbmVsSW5zdGFuY2VdIC0gcmVmZXJlbmNlIHRvIHRoZSBjb3JlIE1peHBhbmVsTGliXG4qL1xudmFyIE1peHBhbmVsUmVjb3JkZXIgPSBmdW5jdGlvbihtaXhwYW5lbEluc3RhbmNlLCBycndlYlJlY29yZCwgc2hhcmVkTG9ja1N0b3JhZ2UpIHtcbiAgICB0aGlzLm1peHBhbmVsSW5zdGFuY2UgPSBtaXhwYW5lbEluc3RhbmNlO1xuICAgIHRoaXMucnJ3ZWJSZWNvcmQgPSBycndlYlJlY29yZCB8fCByZWNvcmQ7XG4gICAgdGhpcy5zaGFyZWRMb2NrU3RvcmFnZSA9IHNoYXJlZExvY2tTdG9yYWdlO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7aW1wb3J0KCcuL3JlZ2lzdHJ5JykuUmVjb3JkaW5nUmVnaXN0cnl9XG4gICAgICovXG4gICAgdGhpcy5yZWNvcmRpbmdSZWdpc3RyeSA9IG5ldyBSZWNvcmRpbmdSZWdpc3RyeSh7XG4gICAgICAgIG1peHBhbmVsSW5zdGFuY2U6IHRoaXMubWl4cGFuZWxJbnN0YW5jZSxcbiAgICAgICAgZXJyb3JSZXBvcnRlcjogbG9nZ2VyJDIuZXJyb3IsXG4gICAgICAgIHNoYXJlZExvY2tTdG9yYWdlOiBzaGFyZWRMb2NrU3RvcmFnZVxuICAgIH0pO1xuICAgIHRoaXMuX2ZsdXNoSW5hY3RpdmVQcm9taXNlID0gdGhpcy5yZWNvcmRpbmdSZWdpc3RyeS5mbHVzaEluYWN0aXZlUmVjb3JkaW5ncygpO1xuXG4gICAgdGhpcy5hY3RpdmVSZWNvcmRpbmcgPSBudWxsO1xuICAgIHRoaXMuc3RvcFJlY29yZGluZ0luUHJvZ3Jlc3MgPSBmYWxzZTtcbn07XG5cbk1peHBhbmVsUmVjb3JkZXIucHJvdG90eXBlLnN0YXJ0UmVjb3JkaW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICh0aGlzLmFjdGl2ZVJlY29yZGluZyAmJiAhdGhpcy5hY3RpdmVSZWNvcmRpbmcuaXNScndlYlN0b3BwZWQoKSkge1xuICAgICAgICBsb2dnZXIkMi5sb2coJ1JlY29yZGluZyBhbHJlYWR5IGluIHByb2dyZXNzLCBza2lwcGluZyBzdGFydFJlY29yZGluZy4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvbklkbGVUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXIkMi5sb2coJ0lkbGUgdGltZW91dCByZWFjaGVkLCByZXN0YXJ0aW5nIHJlY29yZGluZy4nKTtcbiAgICAgICAgdGhpcy5yZXNldFJlY29yZGluZygpO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHZhciBvbk1heExlbmd0aFJlYWNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlciQyLmxvZygnTWF4IHJlY29yZGluZyBsZW5ndGggcmVhY2hlZCwgc3RvcHBpbmcgcmVjb3JkaW5nLicpO1xuICAgICAgICB0aGlzLnJlc2V0UmVjb3JkaW5nKCk7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgdmFyIG9uQmF0Y2hTZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlY29yZGluZ1JlZ2lzdHJ5LnNldEFjdGl2ZVJlY29yZGluZyh0aGlzLmFjdGl2ZVJlY29yZGluZy5zZXJpYWxpemUoKSk7XG4gICAgICAgIHRoaXNbJ19fZmx1c2hQcm9taXNlJ10gPSB0aGlzLmFjdGl2ZVJlY29yZGluZy5iYXRjaGVyLl9mbHVzaFByb21pc2U7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydCgnLi9zZXNzaW9uLXJlY29yZGluZycpLlNlc3Npb25SZWNvcmRpbmdPcHRpb25zfVxuICAgICAqL1xuICAgIHZhciBzZXNzaW9uUmVjb3JkaW5nT3B0aW9ucyA9IHtcbiAgICAgICAgbWl4cGFuZWxJbnN0YW5jZTogdGhpcy5taXhwYW5lbEluc3RhbmNlLFxuICAgICAgICBvbkJhdGNoU2VudDogb25CYXRjaFNlbnQsXG4gICAgICAgIG9uSWRsZVRpbWVvdXQ6IG9uSWRsZVRpbWVvdXQsXG4gICAgICAgIG9uTWF4TGVuZ3RoUmVhY2hlZDogb25NYXhMZW5ndGhSZWFjaGVkLFxuICAgICAgICByZXBsYXlJZDogXy5VVUlEKCksXG4gICAgICAgIHJyd2ViUmVjb3JkOiB0aGlzLnJyd2ViUmVjb3JkLFxuICAgICAgICBzaGFyZWRMb2NrU3RvcmFnZTogdGhpcy5zaGFyZWRMb2NrU3RvcmFnZVxuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy5hY3RpdmVTZXJpYWxpemVkUmVjb3JkaW5nKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlUmVjb3JkaW5nID0gU2Vzc2lvblJlY29yZGluZy5kZXNlcmlhbGl6ZShvcHRpb25zLmFjdGl2ZVNlcmlhbGl6ZWRSZWNvcmRpbmcsIHNlc3Npb25SZWNvcmRpbmdPcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFjdGl2ZVJlY29yZGluZyA9IG5ldyBTZXNzaW9uUmVjb3JkaW5nKHNlc3Npb25SZWNvcmRpbmdPcHRpb25zKTtcbiAgICB9XG5cbiAgICB0aGlzLmFjdGl2ZVJlY29yZGluZy5zdGFydFJlY29yZGluZyhvcHRpb25zLnNob3VsZFN0b3BCYXRjaGVyKTtcbiAgICByZXR1cm4gdGhpcy5yZWNvcmRpbmdSZWdpc3RyeS5zZXRBY3RpdmVSZWNvcmRpbmcodGhpcy5hY3RpdmVSZWNvcmRpbmcuc2VyaWFsaXplKCkpO1xufTtcblxuTWl4cGFuZWxSZWNvcmRlci5wcm90b3R5cGUuc3RvcFJlY29yZGluZyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFByZXZlbnRzIGFjdGl2ZVNlcmlhbGl6ZWRSZWNvcmRpbmcgZnJvbSBiZWluZyByZXVzZWQgd2hlbiBzdG9wcGluZyB0aGUgcmVjb3JkaW5nLlxuICAgIHRoaXMuc3RvcFJlY29yZGluZ0luUHJvZ3Jlc3MgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLl9zdG9wQ3VycmVudFJlY29yZGluZyhmYWxzZSwgdHJ1ZSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjb3JkaW5nUmVnaXN0cnkuY2xlYXJBY3RpdmVSZWNvcmRpbmcoKTtcbiAgICB9LmJpbmQodGhpcykpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc3RvcFJlY29yZGluZ0luUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICB9LmJpbmQodGhpcykpO1xufTtcblxuTWl4cGFuZWxSZWNvcmRlci5wcm90b3R5cGUucGF1c2VSZWNvcmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RvcEN1cnJlbnRSZWNvcmRpbmcoZmFsc2UpO1xufTtcblxuTWl4cGFuZWxSZWNvcmRlci5wcm90b3R5cGUuX3N0b3BDdXJyZW50UmVjb3JkaW5nID0gZnVuY3Rpb24oc2tpcEZsdXNoLCBkaXNhYmxlQWN0aXZlUmVjb3JkaW5nKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlUmVjb3JkaW5nKSB7XG4gICAgICAgIHZhciBzdG9wUmVjb3JkaW5nUHJvbWlzZSA9IHRoaXMuYWN0aXZlUmVjb3JkaW5nLnN0b3BSZWNvcmRpbmcoc2tpcEZsdXNoKTtcbiAgICAgICAgaWYgKGRpc2FibGVBY3RpdmVSZWNvcmRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlUmVjb3JkaW5nID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RvcFJlY29yZGluZ1Byb21pc2U7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSgpO1xufTtcblxuTWl4cGFuZWxSZWNvcmRlci5wcm90b3R5cGUucmVzdW1lUmVjb3JkaW5nID0gZnVuY3Rpb24gKHN0YXJ0TmV3SWZJbmFjdGl2ZSkge1xuICAgIGlmICh0aGlzLmFjdGl2ZVJlY29yZGluZyAmJiB0aGlzLmFjdGl2ZVJlY29yZGluZy5pc1Jyd2ViU3RvcHBlZCgpKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlUmVjb3JkaW5nLnN0YXJ0UmVjb3JkaW5nKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKG51bGwpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJlY29yZGluZ1JlZ2lzdHJ5LmdldEFjdGl2ZVJlY29yZGluZygpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChhY3RpdmVTZXJpYWxpemVkUmVjb3JkaW5nKSB7XG4gICAgICAgICAgICBpZiAoYWN0aXZlU2VyaWFsaXplZFJlY29yZGluZyAmJiAhdGhpcy5zdG9wUmVjb3JkaW5nSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0UmVjb3JkaW5nKHthY3RpdmVTZXJpYWxpemVkUmVjb3JkaW5nOiBhY3RpdmVTZXJpYWxpemVkUmVjb3JkaW5nfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0TmV3SWZJbmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0UmVjb3JkaW5nKHtzaG91bGRTdG9wQmF0Y2hlcjogZmFsc2V9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDIubG9nKCdObyByZXN1bWFibGUgcmVjb3JkaW5nIGZvdW5kLicpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpO1xufTtcblxuXG5NaXhwYW5lbFJlY29yZGVyLnByb3RvdHlwZS5yZXNldFJlY29yZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnN0b3BSZWNvcmRpbmcoKTtcbiAgICB0aGlzLnN0YXJ0UmVjb3JkaW5nKHtzaG91bGRTdG9wQmF0Y2hlcjogdHJ1ZX0pO1xufTtcblxuTWl4cGFuZWxSZWNvcmRlci5wcm90b3R5cGUuZ2V0QWN0aXZlUmVwbGF5SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlUmVjb3JkaW5nICYmICF0aGlzLmFjdGl2ZVJlY29yZGluZy5pc1Jyd2ViU3RvcHBlZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVJlY29yZGluZy5yZXBsYXlJZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG4vLyBnZXR0ZXIgc28gdGhhdCBvbGRlciBtaXhwYW5lbC1jb3JlIHZlcnNpb25zIGNhbiBzdGlsbCByZXRyaWV2ZSB0aGUgcmVwbGF5IElEXG4vLyB3aGVuIHB1bGxpbmcgdGhlIGxhdGVzdCByZWNvcmRlciBidW5kbGUgZnJvbSB0aGUgQ0ROXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWl4cGFuZWxSZWNvcmRlci5wcm90b3R5cGUsICdyZXBsYXlJZCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWN0aXZlUmVwbGF5SWQoKTtcbiAgICB9XG59KTtcblxud2luWydfX21wX3JlY29yZGVyJ10gPSBNaXhwYW5lbFJlY29yZGVyO1xuXG4vLyBzdGF0ZWxlc3MgdXRpbHNcbi8vIG1vc3RseSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9taXhwYW5lbC9taXhwYW5lbC1qcy9ibG9iLzk4OWFkYTUwZjUxOGVkYWI0N2I5YzRmZDk1MzVmOWZiZDVlYzVmYzAvc3JjL2F1dG90cmFjay11dGlscy5qc1xuXG5cbnZhciBFVl9DSEFOR0UgPSAnY2hhbmdlJztcbnZhciBFVl9DTElDSyA9ICdjbGljayc7XG52YXIgRVZfSEFTSENIQU5HRSA9ICdoYXNoY2hhbmdlJztcbnZhciBFVl9JTlBVVCA9ICdpbnB1dCc7XG52YXIgRVZfTE9BRCA9ICdsb2FkJztcbnZhciBFVl9NUF9MT0NBVElPTl9DSEFOR0UgPSAnbXBfbG9jYXRpb25jaGFuZ2UnO1xudmFyIEVWX1BPUFNUQVRFID0gJ3BvcHN0YXRlJztcbi8vIFRPRE8gc2Nyb2xsZW5kIGlzbid0IGF2YWlsYWJsZSBpbiBTYWZhcmk6IGRvY3VtZW50IG9yIHBvbHlmaWxsP1xudmFyIEVWX1NDUk9MTEVORCA9ICdzY3JvbGxlbmQnO1xudmFyIEVWX1NDUk9MTCA9ICdzY3JvbGwnO1xudmFyIEVWX1NFTEVDVCA9ICdzZWxlY3QnO1xudmFyIEVWX1NVQk1JVCA9ICdzdWJtaXQnO1xudmFyIEVWX1RPR0dMRSA9ICd0b2dnbGUnO1xudmFyIEVWX1ZJU0lCSUxJVFlDSEFOR0UgPSAndmlzaWJpbGl0eWNoYW5nZSc7XG5cbnZhciBDTElDS19FVkVOVF9QUk9QUyA9IFtcbiAgICAnY2xpZW50WCcsICdjbGllbnRZJyxcbiAgICAnb2Zmc2V0WCcsICdvZmZzZXRZJyxcbiAgICAncGFnZVgnLCAncGFnZVknLFxuICAgICdzY3JlZW5YJywgJ3NjcmVlblknLFxuICAgICd4JywgJ3knXG5dO1xudmFyIE9QVF9JTl9DTEFTU0VTID0gWydtcC1pbmNsdWRlJ107XG52YXIgT1BUX09VVF9DTEFTU0VTID0gWydtcC1uby10cmFjayddO1xudmFyIFNFTlNJVElWRV9EQVRBX0NMQVNTRVMgPSBPUFRfT1VUX0NMQVNTRVMuY29uY2F0KFsnbXAtc2Vuc2l0aXZlJ10pO1xudmFyIFRSQUNLRURfQVRUUlMgPSBbXG4gICAgJ2FyaWEtbGFiZWwnLCAnYXJpYS1sYWJlbGxlZGJ5JywgJ2FyaWEtZGVzY3JpYmVkYnknLFxuICAgICdocmVmJywgJ25hbWUnLCAncm9sZScsICd0aXRsZScsICd0eXBlJ1xuXTtcblxudmFyIElOVEVSQUNUSVZFX0FSSUFfUk9MRVMgPSB7XG4gICAgJ2J1dHRvbic6IHRydWUsXG4gICAgJ2NoZWNrYm94JzogdHJ1ZSxcbiAgICAnY29tYm9ib3gnOiB0cnVlLFxuICAgICdncmlkJzogdHJ1ZSxcbiAgICAnbGluayc6IHRydWUsXG4gICAgJ2xpc3Rib3gnOiB0cnVlLFxuICAgICdtZW51JzogdHJ1ZSxcbiAgICAnbWVudWJhcic6IHRydWUsXG4gICAgJ21lbnVpdGVtJzogdHJ1ZSxcbiAgICAnbWVudWl0ZW1jaGVja2JveCc6IHRydWUsXG4gICAgJ21lbnVpdGVtcmFkaW8nOiB0cnVlLFxuICAgICduYXZpZ2F0aW9uJzogdHJ1ZSxcbiAgICAnb3B0aW9uJzogdHJ1ZSxcbiAgICAncmFkaW8nOiB0cnVlLFxuICAgICdyYWRpb2dyb3VwJzogdHJ1ZSxcbiAgICAnc2VhcmNoYm94JzogdHJ1ZSxcbiAgICAnc2xpZGVyJzogdHJ1ZSxcbiAgICAnc3BpbmJ1dHRvbic6IHRydWUsXG4gICAgJ3N3aXRjaCc6IHRydWUsXG4gICAgJ3RhYic6IHRydWUsXG4gICAgJ3RhYmxpc3QnOiB0cnVlLFxuICAgICd0ZXh0Ym94JzogdHJ1ZSxcbiAgICAndHJlZSc6IHRydWUsXG4gICAgJ3RyZWVncmlkJzogdHJ1ZSxcbiAgICAndHJlZWl0ZW0nOiB0cnVlXG59O1xuXG52YXIgQUxXQVlTX05PTl9JTlRFUkFDVElWRV9UQUdTID0ge1xuICAgIC8vIERvY3VtZW50IG1ldGFkYXRhXG4gICAgJ2Jhc2UnOiB0cnVlLFxuICAgICdoZWFkJzogdHJ1ZSxcbiAgICAnaHRtbCc6IHRydWUsXG4gICAgJ2xpbmsnOiB0cnVlLFxuICAgICdtZXRhJzogdHJ1ZSxcbiAgICAnc2NyaXB0JzogdHJ1ZSxcbiAgICAnc3R5bGUnOiB0cnVlLFxuICAgICd0aXRsZSc6IHRydWUsXG4gICAgLy8gVGV4dCBmb3JtYXR0aW5nXG4gICAgJ2JyJzogdHJ1ZSxcbiAgICAnaHInOiB0cnVlLFxuICAgICd3YnInOiB0cnVlLFxuICAgIC8vIE90aGVyXG4gICAgJ25vc2NyaXB0JzogdHJ1ZSxcbiAgICAncGljdHVyZSc6IHRydWUsXG4gICAgJ3NvdXJjZSc6IHRydWUsXG4gICAgJ3RlbXBsYXRlJzogdHJ1ZSxcbiAgICAndHJhY2snOiB0cnVlXG59O1xuXG4vLyBDb21tb24gY29udGFpbmVyIHRhZ3MgdGhhdCBuZWVkIGFkZGl0aW9uYWwgY2hlY2tzXG52YXIgVEVYVF9DT05UQUlORVJfVEFHUyA9IHtcbiAgICAnYXJ0aWNsZSc6IHRydWUsXG4gICAgJ2Rpdic6IHRydWUsXG4gICAgJ2gxJzogdHJ1ZSxcbiAgICAnaDInOiB0cnVlLFxuICAgICdoMyc6IHRydWUsXG4gICAgJ2g0JzogdHJ1ZSxcbiAgICAnaDUnOiB0cnVlLFxuICAgICdoNic6IHRydWUsXG4gICAgJ3AnOiB0cnVlLFxuICAgICdzZWN0aW9uJzogdHJ1ZSxcbiAgICAnc3Bhbic6IHRydWVcbn07XG5cbnZhciBFVkVOVF9IQU5ETEVSX0FUVFJJQlVURVMgPSBbXG4gICAgJ29uY2xpY2snLCAnb25tb3VzZWRvd24nLCAnb25tb3VzZXVwJywgJ29ucG9pbnRlcmRvd24nLCAnb25wb2ludGVydXAnLCAnb250b3VjaGVuZCcsICdvbnRvdWNoc3RhcnQnXG5dO1xuXG52YXIgTUFYX0RFUFRIID0gNTtcblxudmFyIGxvZ2dlciQxID0gY29uc29sZV93aXRoX3ByZWZpeCgnYXV0b2NhcHR1cmUnKTtcblxuXG5mdW5jdGlvbiBnZXRDbGFzc2VzKGVsKSB7XG4gICAgdmFyIGNsYXNzZXMgPSB7fTtcbiAgICB2YXIgY2xhc3NMaXN0ID0gZ2V0Q2xhc3NOYW1lKGVsKS5zcGxpdCgnICcpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xhc3NMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjbHMgPSBjbGFzc0xpc3RbaV07XG4gICAgICAgIGlmIChjbHMpIHtcbiAgICAgICAgICAgIGNsYXNzZXNbY2xzXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzZXM7XG59XG5cbi8qXG4gKiBHZXQgdGhlIGNsYXNzTmFtZSBvZiBhbiBlbGVtZW50LCBhY2NvdW50aW5nIGZvciBlZGdlIGNhc2VzIHdoZXJlIGVsZW1lbnQuY2xhc3NOYW1lIGlzIGFuIG9iamVjdFxuICogQHBhcmFtIHtFbGVtZW50fSBlbCAtIGVsZW1lbnQgdG8gZ2V0IHRoZSBjbGFzc05hbWUgb2ZcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBlbGVtZW50J3MgY2xhc3NcbiAqL1xuZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKGVsKSB7XG4gICAgc3dpdGNoKHR5cGVvZiBlbC5jbGFzc05hbWUpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIHJldHVybiBlbC5jbGFzc05hbWU7XG4gICAgICAgIGNhc2UgJ29iamVjdCc6IC8vIGhhbmRsZSBjYXNlcyB3aGVyZSBjbGFzc05hbWUgbWlnaHQgYmUgU1ZHQW5pbWF0ZWRTdHJpbmcgb3Igc29tZSBvdGhlciB0eXBlXG4gICAgICAgICAgICByZXR1cm4gZWwuY2xhc3NOYW1lLmJhc2VWYWwgfHwgZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnO1xuICAgICAgICBkZWZhdWx0OiAvLyBmdXR1cmUgcHJvb2ZcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldFByZXZpb3VzRWxlbWVudFNpYmxpbmcoZWwpIHtcbiAgICBpZiAoZWwucHJldmlvdXNFbGVtZW50U2libGluZykge1xuICAgICAgICByZXR1cm4gZWwucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBlbCA9IGVsLnByZXZpb3VzU2libGluZztcbiAgICAgICAgfSB3aGlsZSAoZWwgJiYgIWlzRWxlbWVudE5vZGUoZWwpKTtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0UHJvcGVydGllc0Zyb21FbGVtZW50KGVsLCBldiwgYmxvY2tBdHRyc1NldCwgZXh0cmFBdHRycywgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKSB7XG4gICAgdmFyIHByb3BzID0ge1xuICAgICAgICAnJGNsYXNzZXMnOiBnZXRDbGFzc05hbWUoZWwpLnNwbGl0KCcgJyksXG4gICAgICAgICckdGFnX25hbWUnOiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKClcbiAgICB9O1xuICAgIHZhciBlbElkID0gZWwuaWQ7XG4gICAgaWYgKGVsSWQpIHtcbiAgICAgICAgcHJvcHNbJyRpZCddID0gZWxJZDtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVHJhY2tFbGVtZW50RGV0YWlscyhlbCwgZXYsIGFsbG93RWxlbWVudENhbGxiYWNrLCBhbGxvd1NlbGVjdG9ycykpIHtcbiAgICAgICAgXy5lYWNoKFRSQUNLRURfQVRUUlMuY29uY2F0KGV4dHJhQXR0cnMpLCBmdW5jdGlvbihhdHRyKSB7XG4gICAgICAgICAgICBpZiAoZWwuaGFzQXR0cmlidXRlKGF0dHIpICYmICFibG9ja0F0dHJzU2V0W2F0dHJdKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJWYWwgPSBlbC5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFRyYWNrVmFsdWUoYXR0clZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNbJyRhdHRyLScgKyBhdHRyXSA9IGF0dHJWYWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgbnRoQ2hpbGQgPSAxO1xuICAgIHZhciBudGhPZlR5cGUgPSAxO1xuICAgIHZhciBjdXJyZW50RWxlbSA9IGVsO1xuICAgIHdoaWxlIChjdXJyZW50RWxlbSA9IGdldFByZXZpb3VzRWxlbWVudFNpYmxpbmcoY3VycmVudEVsZW0pKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICAgICAgbnRoQ2hpbGQrKztcbiAgICAgICAgaWYgKGN1cnJlbnRFbGVtLnRhZ05hbWUgPT09IGVsLnRhZ05hbWUpIHtcbiAgICAgICAgICAgIG50aE9mVHlwZSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb3BzWyckbnRoX2NoaWxkJ10gPSBudGhDaGlsZDtcbiAgICBwcm9wc1snJG50aF9vZl90eXBlJ10gPSBudGhPZlR5cGU7XG5cbiAgICByZXR1cm4gcHJvcHM7XG59XG5cbmZ1bmN0aW9uIGdldFByb3BzRm9yRE9NRXZlbnQoZXYsIGNvbmZpZykge1xuICAgIHZhciBhbGxvd0VsZW1lbnRDYWxsYmFjayA9IGNvbmZpZy5hbGxvd0VsZW1lbnRDYWxsYmFjaztcbiAgICB2YXIgYWxsb3dTZWxlY3RvcnMgPSBjb25maWcuYWxsb3dTZWxlY3RvcnMgfHwgW107XG4gICAgdmFyIGJsb2NrQXR0cnMgPSBjb25maWcuYmxvY2tBdHRycyB8fCBbXTtcbiAgICB2YXIgYmxvY2tFbGVtZW50Q2FsbGJhY2sgPSBjb25maWcuYmxvY2tFbGVtZW50Q2FsbGJhY2s7XG4gICAgdmFyIGJsb2NrU2VsZWN0b3JzID0gY29uZmlnLmJsb2NrU2VsZWN0b3JzIHx8IFtdO1xuICAgIHZhciBjYXB0dXJlVGV4dENvbnRlbnQgPSBjb25maWcuY2FwdHVyZVRleHRDb250ZW50IHx8IGZhbHNlO1xuICAgIHZhciBjYXB0dXJlRXh0cmFBdHRycyA9IGNvbmZpZy5jYXB0dXJlRXh0cmFBdHRycyB8fCBbXTtcbiAgICB2YXIgY2FwdHVyZWRGb3JIZWF0TWFwID0gY29uZmlnLmNhcHR1cmVkRm9ySGVhdE1hcCB8fCBmYWxzZTtcblxuICAgIC8vIGNvbnZlcnQgYXJyYXkgdG8gc2V0IGV2ZXJ5IHRpbWUsIGFzIHRoZSBjb25maWcgbWF5IGhhdmUgY2hhbmdlZFxuICAgIHZhciBibG9ja0F0dHJzU2V0ID0ge307XG4gICAgXy5lYWNoKGJsb2NrQXR0cnMsIGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgYmxvY2tBdHRyc1NldFthdHRyXSA9IHRydWU7XG4gICAgfSk7XG5cbiAgICB2YXIgcHJvcHMgPSBudWxsO1xuXG4gICAgdmFyIHRhcmdldCA9IHR5cGVvZiBldi50YXJnZXQgPT09ICd1bmRlZmluZWQnID8gZXYuc3JjRWxlbWVudCA6IGV2LnRhcmdldDtcbiAgICBpZiAoaXNUZXh0Tm9kZSh0YXJnZXQpKSB7IC8vIGRlZmVhdCBTYWZhcmkgYnVnIChzZWU6IGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbClcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgICBzaG91bGRUcmFja0RvbUV2ZW50KHRhcmdldCwgZXYpICYmXG4gICAgICAgIGlzRWxlbWVudEFsbG93ZWQodGFyZ2V0LCBldiwgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKSAmJlxuICAgICAgICAhaXNFbGVtZW50QmxvY2tlZCh0YXJnZXQsIGV2LCBibG9ja0VsZW1lbnRDYWxsYmFjaywgYmxvY2tTZWxlY3RvcnMpXG4gICAgKSB7XG4gICAgICAgIHZhciB0YXJnZXRFbGVtZW50TGlzdCA9IFt0YXJnZXRdO1xuICAgICAgICB2YXIgY3VyRWwgPSB0YXJnZXQ7XG4gICAgICAgIHdoaWxlIChjdXJFbC5wYXJlbnROb2RlICYmICFpc1RhZyhjdXJFbCwgJ2JvZHknKSkge1xuICAgICAgICAgICAgdGFyZ2V0RWxlbWVudExpc3QucHVzaChjdXJFbC5wYXJlbnROb2RlKTtcbiAgICAgICAgICAgIGN1ckVsID0gY3VyRWwucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbGVtZW50c0pzb24gPSBbXTtcbiAgICAgICAgdmFyIGhyZWYsIGV4cGxpY2l0Tm9UcmFjayA9IGZhbHNlO1xuICAgICAgICBfLmVhY2godGFyZ2V0RWxlbWVudExpc3QsIGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICB2YXIgc2hvdWxkVHJhY2tEZXRhaWxzID0gc2hvdWxkVHJhY2tFbGVtZW50RGV0YWlscyhlbCwgZXYsIGFsbG93RWxlbWVudENhbGxiYWNrLCBhbGxvd1NlbGVjdG9ycyk7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBlbGVtZW50IG9yIGEgcGFyZW50IGVsZW1lbnQgaXMgYW4gYW5jaG9yIHRhZ1xuICAgICAgICAgICAgLy8gaW5jbHVkZSB0aGUgaHJlZiBhcyBhIHByb3BlcnR5XG4gICAgICAgICAgICBpZiAoIWJsb2NrQXR0cnNTZXRbJ2hyZWYnXSAmJiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhJykge1xuICAgICAgICAgICAgICAgIGhyZWYgPSBlbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICAgICAgICAgICAgICBocmVmID0gc2hvdWxkVHJhY2tEZXRhaWxzICYmIHNob3VsZFRyYWNrVmFsdWUoaHJlZikgJiYgaHJlZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzRWxlbWVudEJsb2NrZWQoZWwsIGV2LCBibG9ja0VsZW1lbnRDYWxsYmFjaywgYmxvY2tTZWxlY3RvcnMpKSB7XG4gICAgICAgICAgICAgICAgZXhwbGljaXROb1RyYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxlbWVudHNKc29uLnB1c2goZ2V0UHJvcGVydGllc0Zyb21FbGVtZW50KGVsLCBldiwgYmxvY2tBdHRyc1NldCwgY2FwdHVyZUV4dHJhQXR0cnMsIGFsbG93RWxlbWVudENhbGxiYWNrLCBhbGxvd1NlbGVjdG9ycykpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBpZiAoIWV4cGxpY2l0Tm9UcmFjaykge1xuICAgICAgICAgICAgdmFyIGRvY0VsZW1lbnQgPSBkb2N1bWVudCQxWydkb2N1bWVudEVsZW1lbnQnXTtcbiAgICAgICAgICAgIHByb3BzID0ge1xuICAgICAgICAgICAgICAgICckZXZlbnRfdHlwZSc6IGV2LnR5cGUsXG4gICAgICAgICAgICAgICAgJyRob3N0Jzogd2luLmxvY2F0aW9uLmhvc3QsXG4gICAgICAgICAgICAgICAgJyRwYXRobmFtZSc6IHdpbi5sb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgICAgICAgICAnJGVsZW1lbnRzJzogIGVsZW1lbnRzSnNvbixcbiAgICAgICAgICAgICAgICAnJGVsX2F0dHJfX2hyZWYnOiBocmVmLFxuICAgICAgICAgICAgICAgICckdmlld3BvcnRIZWlnaHQnOiBNYXRoLm1heChkb2NFbGVtZW50WydjbGllbnRIZWlnaHQnXSwgd2luWydpbm5lckhlaWdodCddIHx8IDApLFxuICAgICAgICAgICAgICAgICckdmlld3BvcnRXaWR0aCc6IE1hdGgubWF4KGRvY0VsZW1lbnRbJ2NsaWVudFdpZHRoJ10sIHdpblsnaW5uZXJXaWR0aCddIHx8IDApLFxuICAgICAgICAgICAgICAgICckcGFnZUhlaWdodCc6IGRvY3VtZW50JDFbJ2JvZHknXVsnb2Zmc2V0SGVpZ2h0J10gfHwgMCxcbiAgICAgICAgICAgICAgICAnJHBhZ2VXaWR0aCc6IGRvY3VtZW50JDFbJ2JvZHknXVsnb2Zmc2V0V2lkdGgnXSB8fCAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF8uZWFjaChjYXB0dXJlRXh0cmFBdHRycywgZnVuY3Rpb24oYXR0cikge1xuICAgICAgICAgICAgICAgIGlmICghYmxvY2tBdHRyc1NldFthdHRyXSAmJiB0YXJnZXQuaGFzQXR0cmlidXRlKGF0dHIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRyVmFsID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFRyYWNrVmFsdWUoYXR0clZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzWyckZWxfYXR0cl9fJyArIGF0dHJdID0gYXR0clZhbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoY2FwdHVyZVRleHRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudFRleHQgPSBnZXRTYWZlVGV4dCh0YXJnZXQsIGV2LCBhbGxvd0VsZW1lbnRDYWxsYmFjaywgYWxsb3dTZWxlY3RvcnMpO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50VGV4dCAmJiBlbGVtZW50VGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNbJyRlbF90ZXh0J10gPSBlbGVtZW50VGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChldi50eXBlID09PSBFVl9DTElDSykge1xuICAgICAgICAgICAgICAgIF8uZWFjaChDTElDS19FVkVOVF9QUk9QUywgZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcCBpbiBldikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbJyQnICsgcHJvcF0gPSBldltwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChjYXB0dXJlZEZvckhlYXRNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNbJyRjYXB0dXJlZF9mb3JfaGVhdG1hcCddID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gZ3Vlc3NSZWFsQ2xpY2tUYXJnZXQoZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcHJpb3JpdGl6ZSB0ZXh0IGNvbnRlbnQgZnJvbSBcInJlYWxcIiBjbGljayB0YXJnZXQgaWYgZGlmZmVyZW50IGZyb20gb3JpZ2luYWwgdGFyZ2V0XG4gICAgICAgICAgICBpZiAoY2FwdHVyZVRleHRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRUZXh0ID0gZ2V0U2FmZVRleHQodGFyZ2V0LCBldiwgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudFRleHQgJiYgZWxlbWVudFRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzWyckZWxfdGV4dCddID0gZWxlbWVudFRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgLy8gdGFyZ2V0IG1heSBoYXZlIGJlZW4gcmVjYWxjdWxhdGVkOyBjaGVjayBhbGxvd2xpc3RzIGFuZCBibG9ja2xpc3RzIGFnYWluXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAhaXNFbGVtZW50QWxsb3dlZCh0YXJnZXQsIGV2LCBhbGxvd0VsZW1lbnRDYWxsYmFjaywgYWxsb3dTZWxlY3RvcnMpIHx8XG4gICAgICAgICAgICAgICAgICAgIGlzRWxlbWVudEJsb2NrZWQodGFyZ2V0LCBldiwgYmxvY2tFbGVtZW50Q2FsbGJhY2ssIGJsb2NrU2VsZWN0b3JzKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0UHJvcHMgPSBnZXRQcm9wZXJ0aWVzRnJvbUVsZW1lbnQodGFyZ2V0LCBldiwgYmxvY2tBdHRyc1NldCwgY2FwdHVyZUV4dHJhQXR0cnMsIGFsbG93RWxlbWVudENhbGxiYWNrLCBhbGxvd1NlbGVjdG9ycyk7XG4gICAgICAgICAgICAgICAgcHJvcHNbJyR0YXJnZXQnXSA9IHRhcmdldFByb3BzO1xuICAgICAgICAgICAgICAgIC8vIHB1bGwgdXAgbW9yZSBwcm9wcyBvbnRvIG1haW4gZXZlbnQgcHJvcHNcbiAgICAgICAgICAgICAgICBwcm9wc1snJGVsX2NsYXNzZXMnXSA9IHRhcmdldFByb3BzWyckY2xhc3NlcyddO1xuICAgICAgICAgICAgICAgIF8uZXh0ZW5kKHByb3BzLCBfLnN0cmlwX2VtcHR5X3Byb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgICAgICAnJGVsX2lkJzogdGFyZ2V0UHJvcHNbJyRpZCddLFxuICAgICAgICAgICAgICAgICAgICAnJGVsX3RhZ19uYW1lJzogdGFyZ2V0UHJvcHNbJyR0YWdfbmFtZSddXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3BzO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBkaXJlY3QgdGV4dCBjb250ZW50IG9mIGFuIGVsZW1lbnQsIHByb3RlY3RpbmcgYWdhaW5zdCBzZW5zaXRpdmUgZGF0YSBjb2xsZWN0aW9uLlxuICogQ29uY2F0cyB0ZXh0Q29udGVudCBvZiBlYWNoIG9mIHRoZSBlbGVtZW50J3MgdGV4dCBub2RlIGNoaWxkcmVuOyB0aGlzIGF2b2lkcyBwb3RlbnRpYWxcbiAqIGNvbGxlY3Rpb24gb2Ygc2Vuc2l0aXZlIGRhdGEgdGhhdCBjb3VsZCBoYXBwZW4gaWYgd2UgdXNlZCBlbGVtZW50LnRleHRDb250ZW50IGFuZCB0aGVcbiAqIGVsZW1lbnQgaGFkIHNlbnNpdGl2ZSBjaGlsZCBlbGVtZW50cywgc2luY2UgZWxlbWVudC50ZXh0Q29udGVudCBpbmNsdWRlcyBjaGlsZCBjb250ZW50LlxuICogU2NydWJzIHZhbHVlcyB0aGF0IGxvb2sgbGlrZSB0aGV5IGNvdWxkIGJlIHNlbnNpdGl2ZSAoaS5lLiBjYyBvciBzc24gbnVtYmVyKS5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWwgLSBlbGVtZW50IHRvIGdldCB0aGUgdGV4dCBvZlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhbGxvd1NlbGVjdG9ycyAtIENTUyBzZWxlY3RvcnMgZm9yIGVsZW1lbnRzIHRoYXQgc2hvdWxkIGJlIGluY2x1ZGVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgZWxlbWVudCdzIGRpcmVjdCB0ZXh0IGNvbnRlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0U2FmZVRleHQoZWwsIGV2LCBhbGxvd0VsZW1lbnRDYWxsYmFjaywgYWxsb3dTZWxlY3RvcnMpIHtcbiAgICB2YXIgZWxUZXh0ID0gJyc7XG5cbiAgICBpZiAoc2hvdWxkVHJhY2tFbGVtZW50RGV0YWlscyhlbCwgZXYsIGFsbG93RWxlbWVudENhbGxiYWNrLCBhbGxvd1NlbGVjdG9ycykgJiYgZWwuY2hpbGROb2RlcyAmJiBlbC5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICBfLmVhY2goZWwuY2hpbGROb2RlcywgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChpc1RleHROb2RlKGNoaWxkKSAmJiBjaGlsZC50ZXh0Q29udGVudCkge1xuICAgICAgICAgICAgICAgIGVsVGV4dCArPSBfLnRyaW0oY2hpbGQudGV4dENvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgIC8vIHNjcnViIHBvdGVudGlhbGx5IHNlbnNpdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgLnNwbGl0KC8oXFxzKykvKS5maWx0ZXIoc2hvdWxkVHJhY2tWYWx1ZSkuam9pbignJylcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9ybWFsaXplIHdoaXRlc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHJcXG5dL2csICcgJykucmVwbGFjZSgvWyBdKy9nLCAnICcpXG4gICAgICAgICAgICAgICAgICAgIC8vIHRydW5jYXRlXG4gICAgICAgICAgICAgICAgICAgIC5zdWJzdHJpbmcoMCwgMjU1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF8udHJpbShlbFRleHQpO1xufVxuXG5mdW5jdGlvbiBndWVzc1JlYWxDbGlja1RhcmdldChldikge1xuICAgIHZhciB0YXJnZXQgPSBldi50YXJnZXQ7XG4gICAgdmFyIGNvbXBvc2VkUGF0aCA9IGV2Wydjb21wb3NlZFBhdGgnXSgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9zZWRQYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gY29tcG9zZWRQYXRoW2ldO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBpc1RhZyhub2RlLCAnYScpIHx8XG4gICAgICAgICAgICBpc1RhZyhub2RlLCAnYnV0dG9uJykgfHxcbiAgICAgICAgICAgIGlzVGFnKG5vZGUsICdpbnB1dCcpIHx8XG4gICAgICAgICAgICBpc1RhZyhub2RlLCAnc2VsZWN0JykgfHxcbiAgICAgICAgICAgIChub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZSgncm9sZScpID09PSAnYnV0dG9uJylcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBub2RlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgPT09IHRhcmdldCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gaXNFbGVtZW50QWxsb3dlZChlbCwgZXYsIGFsbG93RWxlbWVudENhbGxiYWNrLCBhbGxvd1NlbGVjdG9ycykge1xuICAgIGlmIChhbGxvd0VsZW1lbnRDYWxsYmFjaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFhbGxvd0VsZW1lbnRDYWxsYmFjayhlbCwgZXYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGxvZ2dlciQxLmNyaXRpY2FsKCdFcnJvciB3aGlsZSBjaGVja2luZyBlbGVtZW50IGluIGFsbG93RWxlbWVudENhbGxiYWNrJywgZXJyKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghYWxsb3dTZWxlY3RvcnMubGVuZ3RoKSB7XG4gICAgICAgIC8vIG5vIGFsbG93bGlzdDsgYWxsIGVsZW1lbnRzIGFyZSBmYWlyIGdhbWVcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxvd1NlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2VsID0gYWxsb3dTZWxlY3RvcnNbaV07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoZWxbJ21hdGNoZXMnXShzZWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyJDEuY3JpdGljYWwoJ0Vycm9yIHdoaWxlIGNoZWNraW5nIHNlbGVjdG9yOiAnICsgc2VsLCBlcnIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFbGVtZW50QmxvY2tlZChlbCwgZXYsIGJsb2NrRWxlbWVudENhbGxiYWNrLCBibG9ja1NlbGVjdG9ycykge1xuICAgIHZhciBpO1xuXG4gICAgaWYgKGJsb2NrRWxlbWVudENhbGxiYWNrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoYmxvY2tFbGVtZW50Q2FsbGJhY2soZWwsIGV2KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGxvZ2dlciQxLmNyaXRpY2FsKCdFcnJvciB3aGlsZSBjaGVja2luZyBlbGVtZW50IGluIGJsb2NrRWxlbWVudENhbGxiYWNrJywgZXJyKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJsb2NrU2VsZWN0b3JzICYmIGJsb2NrU2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgICAvLyBwcm9ncmFtbWF0aWNhbGx5IHByZXZlbnQgdHJhY2tpbmcgb2YgZWxlbWVudHMgdGhhdCBtYXRjaCBDU1Mgc2VsZWN0b3JzXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBibG9ja1NlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHNlbCA9IGJsb2NrU2VsZWN0b3JzW2ldO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoZWxbJ21hdGNoZXMnXShzZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGxvZ2dlciQxLmNyaXRpY2FsKCdFcnJvciB3aGlsZSBjaGVja2luZyBzZWxlY3RvcjogJyArIHNlbCwgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFsbG93IHVzZXJzIHRvIHByb2dyYW1tYXRpY2FsbHkgcHJldmVudCB0cmFja2luZyBvZiBlbGVtZW50cyBieSBhZGRpbmcgZGVmYXVsdCBjbGFzc2VzIHN1Y2ggYXMgJ21wLW5vLXRyYWNrJ1xuICAgIHZhciBjbGFzc2VzID0gZ2V0Q2xhc3NlcyhlbCk7XG4gICAgZm9yIChpID0gMDsgaSA8IE9QVF9PVVRfQ0xBU1NFUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoY2xhc3Nlc1tPUFRfT1VUX0NMQVNTRVNbaV1dKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLypcbiAqIENoZWNrIHdoZXRoZXIgYSBET00gbm9kZSBoYXMgbm9kZVR5cGUgTm9kZS5FTEVNRU5UX05PREVcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIG5vZGUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIG5vZGUgaXMgb2YgdGhlIGNvcnJlY3Qgbm9kZVR5cGVcbiAqL1xuZnVuY3Rpb24gaXNFbGVtZW50Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMTsgLy8gTm9kZS5FTEVNRU5UX05PREUgLSB1c2UgaW50ZWdlciBjb25zdGFudCBmb3IgYnJvd3NlciBwb3J0YWJpbGl0eVxufVxuXG4vKlxuICogQ2hlY2sgd2hldGhlciBhbiBlbGVtZW50IGlzIG9mIGEgZ2l2ZW4gdGFnIHR5cGUuXG4gKiBEdWUgdG8gcG90ZW50aWFsIHJlZmVyZW5jZSBkaXNjcmVwYW5jaWVzIChzdWNoIGFzIHRoZSB3ZWJjb21wb25lbnRzLmpzIHBvbHlmaWxsKSxcbiAqIHdlIHdhbnQgdG8gbWF0Y2ggdGFnTmFtZXMgaW5zdGVhZCBvZiBzcGVjaWZpYyByZWZlcmVuY2VzIGJlY2F1c2Ugc29tZXRoaW5nIGxpa2VcbiAqIGVsZW1lbnQgPT09IGRvY3VtZW50LmJvZHkgd29uJ3QgYWx3YXlzIHdvcmsgYmVjYXVzZSBlbGVtZW50IG1pZ2h0IG5vdCBiZSBhIG5hdGl2ZVxuICogZWxlbWVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWwgLSBlbGVtZW50IHRvIGNoZWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIC0gdGFnIG5hbWUgKGUuZy4sIFwiZGl2XCIpXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBlbCBpcyBvZiB0aGUgZ2l2ZW4gdGFnIHR5cGVcbiAqL1xuZnVuY3Rpb24gaXNUYWcoZWwsIHRhZykge1xuICAgIHJldHVybiBlbCAmJiBlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gdGFnLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8qXG4gKiBDaGVjayB3aGV0aGVyIGEgRE9NIG5vZGUgaXMgYSBURVhUX05PREVcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIG5vZGUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIG5vZGUgaXMgb2YgdHlwZSBOb2RlLlRFWFRfTk9ERVxuICovXG5mdW5jdGlvbiBpc1RleHROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAmJiBub2RlLm5vZGVUeXBlID09PSAzOyAvLyBOb2RlLlRFWFRfTk9ERSAtIHVzZSBpbnRlZ2VyIGNvbnN0YW50IGZvciBicm93c2VyIHBvcnRhYmlsaXR5XG59XG5cbmZ1bmN0aW9uIG1pbkRPTUFwaXNTdXBwb3J0ZWQoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIHRlc3RFbCA9IGRvY3VtZW50JDEuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHJldHVybiAhIXRlc3RFbFsnbWF0Y2hlcyddO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB3ZWFrU2V0U3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0eXBlb2YgV2Vha1NldCAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qXG4gKiBDaGVjayB3aGV0aGVyIGEgRE9NIGV2ZW50IHNob3VsZCBiZSBcInRyYWNrZWRcIiBvciBpZiBpdCBtYXkgY29udGFpbiBzZW5zaXRpdmUgZGF0YVxuICogdXNpbmcgYSB2YXJpZXR5IG9mIGhldXJpc3RpY3MuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsIC0gZWxlbWVudCB0byBjaGVja1xuICogQHBhcmFtIHtFdmVudH0gZXYgLSBldmVudCB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIGV2ZW50IHNob3VsZCBiZSB0cmFja2VkXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFRyYWNrRG9tRXZlbnQoZWwsIGV2KSB7XG4gICAgaWYgKCFlbCB8fCBpc1RhZyhlbCwgJ2h0bWwnKSB8fCAhaXNFbGVtZW50Tm9kZShlbCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgdGFnID0gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgICAgICAgcmV0dXJuIGV2LnR5cGUgPT09IEVWX1NVQk1JVDtcbiAgICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICAgICAgaWYgKFsnYnV0dG9uJywgJ3N1Ym1pdCddLmluZGV4T2YoZWwuZ2V0QXR0cmlidXRlKCd0eXBlJykpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBldi50eXBlID09PSBFVl9DSEFOR0U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBldi50eXBlID09PSBFVl9DTElDSztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICAgICAgcmV0dXJuIGV2LnR5cGUgPT09IEVWX0NIQU5HRTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBldi50eXBlID09PSBFVl9DTElDSztcbiAgICB9XG59XG5cbi8qXG4gKiBDaGVjayB3aGV0aGVyIGEgRE9NIGVsZW1lbnQgc2hvdWxkIGJlIFwidHJhY2tlZFwiIG9yIGlmIGl0IG1heSBjb250YWluIHNlbnNpdGl2ZSBkYXRhXG4gKiB1c2luZyBhIHZhcmlldHkgb2YgaGV1cmlzdGljcy5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWwgLSBlbGVtZW50IHRvIGNoZWNrXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGFsbG93U2VsZWN0b3JzIC0gQ1NTIHNlbGVjdG9ycyBmb3IgZWxlbWVudHMgdGhhdCBzaG91bGQgYmUgaW5jbHVkZWRcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSBlbGVtZW50IHNob3VsZCBiZSB0cmFja2VkXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFRyYWNrRWxlbWVudERldGFpbHMoZWwsIGV2LCBhbGxvd0VsZW1lbnRDYWxsYmFjaywgYWxsb3dTZWxlY3RvcnMpIHtcbiAgICB2YXIgaTtcblxuICAgIGlmICghaXNFbGVtZW50QWxsb3dlZChlbCwgZXYsIGFsbG93RWxlbWVudENhbGxiYWNrLCBhbGxvd1NlbGVjdG9ycykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGN1ckVsID0gZWw7IGN1ckVsLnBhcmVudE5vZGUgJiYgIWlzVGFnKGN1ckVsLCAnYm9keScpOyBjdXJFbCA9IGN1ckVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBnZXRDbGFzc2VzKGN1ckVsKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IFNFTlNJVElWRV9EQVRBX0NMQVNTRVMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjbGFzc2VzW1NFTlNJVElWRV9EQVRBX0NMQVNTRVNbaV1dKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVsQ2xhc3NlcyA9IGdldENsYXNzZXMoZWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBPUFRfSU5fQ0xBU1NFUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZWxDbGFzc2VzW09QVF9JTl9DTEFTU0VTW2ldXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkb24ndCBzZW5kIGRhdGEgZnJvbSBpbnB1dHMgb3Igc2ltaWxhciBlbGVtZW50cyBzaW5jZSB0aGVyZSB3aWxsIGFsd2F5cyBiZVxuICAgIC8vIGEgcmlzayBvZiBjbGllbnRzaWRlIGphdmFzY3JpcHQgcGxhY2luZyBzZW5zaXRpdmUgZGF0YSBpbiBhdHRyaWJ1dGVzXG4gICAgaWYgKFxuICAgICAgICBpc1RhZyhlbCwgJ2lucHV0JykgfHxcbiAgICAgICAgaXNUYWcoZWwsICdzZWxlY3QnKSB8fFxuICAgICAgICBpc1RhZyhlbCwgJ3RleHRhcmVhJykgfHxcbiAgICAgICAgZWwuZ2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSA9PT0gJ3RydWUnXG4gICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBkb24ndCBpbmNsdWRlIGhpZGRlbiBvciBwYXNzd29yZCBmaWVsZHNcbiAgICB2YXIgdHlwZSA9IGVsLnR5cGUgfHwgJyc7XG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykgeyAvLyBpdCdzIHBvc3NpYmxlIGZvciBlbC50eXBlIHRvIGJlIGEgRE9NIGVsZW1lbnQgaWYgZWwgaXMgYSBmb3JtIHdpdGggYSBjaGlsZCBpbnB1dFtuYW1lPVwidHlwZVwiXVxuICAgICAgICBzd2l0Y2godHlwZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlICdoaWRkZW4nOlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgJ3Bhc3N3b3JkJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgb3V0IGRhdGEgZnJvbSBmaWVsZHMgdGhhdCBsb29rIGxpa2Ugc2Vuc2l0aXZlIGZpZWxkc1xuICAgIHZhciBuYW1lID0gZWwubmFtZSB8fCBlbC5pZCB8fCAnJztcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7IC8vIGl0J3MgcG9zc2libGUgZm9yIGVsLm5hbWUgb3IgZWwuaWQgdG8gYmUgYSBET00gZWxlbWVudCBpZiBlbCBpcyBhIGZvcm0gd2l0aCBhIGNoaWxkIGlucHV0W25hbWU9XCJuYW1lXCJdXG4gICAgICAgIHZhciBzZW5zaXRpdmVOYW1lUmVnZXggPSAvXmNjfGNhcmRudW18Y2NudW18Y3JlZGl0Y2FyZHxjc2N8Y3ZjfGN2dnxleHB8cGFzc3xwd2R8cm91dGluZ3xzZWNjb2RlfHNlY3VyaXR5Y29kZXxzZWN1cml0eW51bXxzb2NpYWxzZWN8c29jc2VjfHNzbi9pO1xuICAgICAgICBpZiAoc2Vuc2l0aXZlTmFtZVJlZ2V4LnRlc3QobmFtZS5yZXBsYWNlKC9bXmEtekEtWjAtOV0vZywgJycpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cblxuLypcbiAqIENoZWNrIHdoZXRoZXIgYSBzdHJpbmcgdmFsdWUgc2hvdWxkIGJlIFwidHJhY2tlZFwiIG9yIGlmIGl0IG1heSBjb250YWluIHNlbnNpdGl2ZSBkYXRhXG4gKiB1c2luZyBhIHZhcmlldHkgb2YgaGV1cmlzdGljcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIHN0cmluZyB2YWx1ZSB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIGVsZW1lbnQgc2hvdWxkIGJlIHRyYWNrZWRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVHJhY2tWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCBfLmlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFsdWUgPSBfLnRyaW0odmFsdWUpO1xuXG4gICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiBpbnB1dCB2YWx1ZSBsb29rcyBsaWtlIGEgY3JlZGl0IGNhcmQgbnVtYmVyXG4gICAgICAgIC8vIHNlZTogaHR0cHM6Ly93d3cuc2FmYXJpYm9va3NvbmxpbmUuY29tL2xpYnJhcnkvdmlldy9yZWd1bGFyLWV4cHJlc3Npb25zLWNvb2tib29rLzk3ODE0NDkzMjc0NTMvY2gwNHMyMC5odG1sXG4gICAgICAgIHZhciBjY1JlZ2V4ID0gL14oPzooNFswLTldezEyfSg/OlswLTldezN9KT8pfCg1WzEtNV1bMC05XXsxNH0pfCg2KD86MDExfDVbMC05XXsyfSlbMC05XXsxMn0pfCgzWzQ3XVswLTldezEzfSl8KDMoPzowWzAtNV18WzY4XVswLTldKVswLTldezExfSl8KCg/OjIxMzF8MTgwMHwzNVswLTldezN9KVswLTldezExfSkpJC87XG4gICAgICAgIGlmIChjY1JlZ2V4LnRlc3QoKHZhbHVlIHx8ICcnKS5yZXBsYWNlKC9bLSBdL2csICcnKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiBpbnB1dCB2YWx1ZSBsb29rcyBsaWtlIGEgc29jaWFsIHNlY3VyaXR5IG51bWJlclxuICAgICAgICB2YXIgc3NuUmVnZXggPSAvKF5cXGR7M30tP1xcZHsyfS0/XFxkezR9JCkvO1xuICAgICAgICBpZiAoc3NuUmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjcm9zcy1icm93c2VyIGNvbXBhdGlibGUgc2Nyb2xsIGVuZCBmdW5jdGlvbiB3aXRoIGFwcHJvcHJpYXRlIGV2ZW50IGxpc3RlbmVyLlxuICogRm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBzY3JvbGxlbmQsIHJldHVybnMgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIHdpdGggc2Nyb2xsZW5kIGV2ZW50LlxuICogRm9yIGJyb3dzZXJzIHdpdGhvdXQgc2Nyb2xsZW5kIHN1cHBvcnQsIHJldHVybnMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCB0cmlnZ2Vyc1xuICogMTAwbXMgYWZ0ZXIgdGhlIGxhc3Qgc2Nyb2xsIGV2ZW50IHRvIHNpbXVsYXRlIHNjcm9sbGVuZCBiZWhhdmlvci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9yaWdpbmFsRnVuY3Rpb24gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHNjcm9sbGluZyBlbmRzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBPYmplY3QgY29udGFpbmluZyBsaXN0ZW5lciBmdW5jdGlvbiBhbmQgZXZlbnRUeXBlIHN0cmluZ1xuICogQHJldHVybnMge0Z1bmN0aW9ufSByZXR1cm5zLmxpc3RlbmVyIC0gVGhlIHdyYXBwZWQgZnVuY3Rpb24gdG8gdXNlIGFzIGV2ZW50IGxpc3RlbmVyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSByZXR1cm5zLmV2ZW50VHlwZSAtIFRoZSBldmVudCB0eXBlIHRvIGxpc3RlbiBmb3IgKCdzY3JvbGxlbmQnIG9yICdzY3JvbGwnKVxuICovXG5mdW5jdGlvbiBnZXRQb2x5ZmlsbFNjcm9sbEVuZEZ1bmN0aW9uKG9yaWdpbmFsRnVuY3Rpb24pIHtcbiAgICB2YXIgc3VwcG9ydHNTY3JvbGxFbmQgPSAnb25zY3JvbGxlbmQnIGluIHdpbjtcbiAgICB2YXIgcG9seWZpbGxGdW5jdGlvbiA9IHNhZmV3cmFwKG9yaWdpbmFsRnVuY3Rpb24pO1xuICAgIHZhciBwb2x5ZmlsbEV2ZW50ID0gRVZfU0NST0xMRU5EO1xuICAgIGlmICghc3VwcG9ydHNTY3JvbGxFbmQpIHtcbiAgICAgICAgLy8gUG9seWZpbGwgZm9yIGJyb3dzZXJzIHdpdGhvdXQgc2Nyb2xsZW5kIHN1cHBvcnQ6IHdhaXQgMTAwbXMgYWZ0ZXIgdGhlIGxhc3Qgc2Nyb2xsIGV2ZW50XG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vYmxvZy9zY3JvbGxlbmQtYS1uZXctamF2YXNjcmlwdC1ldmVudFxuICAgICAgICB2YXIgc2Nyb2xsVGltZXIgPSBudWxsO1xuICAgICAgICB2YXIgc2Nyb2xsRGVsYXlNcyA9IDEwMDtcblxuICAgICAgICBwb2x5ZmlsbEZ1bmN0aW9uID0gc2FmZXdyYXAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoc2Nyb2xsVGltZXIpO1xuICAgICAgICAgICAgc2Nyb2xsVGltZXIgPSBzZXRUaW1lb3V0KG9yaWdpbmFsRnVuY3Rpb24sIHNjcm9sbERlbGF5TXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICBwb2x5ZmlsbEV2ZW50ID0gRVZfU0NST0xMO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGxpc3RlbmVyOiBwb2x5ZmlsbEZ1bmN0aW9uLFxuICAgICAgICBldmVudFR5cGU6IHBvbHlmaWxsRXZlbnRcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBoYXNJbmxpbmVFdmVudEhhbmRsZXJzKGVsZW1lbnQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IEVWRU5UX0hBTkRMRVJfQVRUUklCVVRFUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoRVZFTlRfSEFORExFUl9BVFRSSUJVVEVTW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBoYXNJbnRlcmFjdGl2ZUFyaWFSb2xlKGVsZW1lbnQpIHtcbiAgICB2YXIgcm9sZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyb2xlJyk7XG4gICAgaWYgKCFyb2xlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBIYW5kbGUgaW52YWxpZCBtYXJrdXAgd2hlcmUgbXVsdGlwbGUgcm9sZXMgbWlnaHQgYmUgc3BlY2lmaWVkXG4gICAgLy8gT25seSB0aGUgZmlyc3QgdG9rZW4gaXMgcmVjb2duaXplZCBwZXIgQVJJQSBzcGVjXG4gICAgdmFyIHByaW1hcnlSb2xlID0gcm9sZS50cmltKCkuc3BsaXQoL1xccysvKVswXS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgcmV0dXJuIElOVEVSQUNUSVZFX0FSSUFfUk9MRVNbcHJpbWFyeVJvbGVdO1xufVxuXG5mdW5jdGlvbiBoYXNBbnlJbnRlcmFjdGl2aXR5SW5kaWNhdG9ycyhlbGVtZW50KSB7XG4gICAgdmFyIHRhZ05hbWUgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIENoZWNrIGZvciBpbnRlcmFjdGl2ZSBIVE1MIGVsZW1lbnRzXG4gICAgaWYgKHRhZ05hbWUgPT09ICdidXR0b24nIHx8XG4gICAgICAgIHRhZ05hbWUgPT09ICdpbnB1dCcgfHxcbiAgICAgICAgdGFnTmFtZSA9PT0gJ3NlbGVjdCcgfHxcbiAgICAgICAgdGFnTmFtZSA9PT0gJ3RleHRhcmVhJyB8fFxuICAgICAgICB0YWdOYW1lID09PSAnZGV0YWlscycgfHxcbiAgICAgICAgdGFnTmFtZSA9PT0gJ2RpYWxvZycpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQuaXNDb250ZW50RWRpdGFibGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQub25jbGljayB8fCBlbGVtZW50Lm9ubW91c2Vkb3duIHx8IGVsZW1lbnQub25tb3VzZXVwIHx8IGVsZW1lbnQub250b3VjaHN0YXJ0IHx8IGVsZW1lbnQub250b3VjaGVuZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaGFzSW5saW5lRXZlbnRIYW5kbGVycyhlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaGFzSW50ZXJhY3RpdmVBcmlhUm9sZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGFnTmFtZSA9PT0gJ2EnICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdocmVmJykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuXG5mdW5jdGlvbiBpc0RlZmluaXRlbHlOb25JbnRlcmFjdGl2ZShlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50LnRhZ05hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHRhZ05hbWUgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIFRoZXNlIHRhZ3MgYXJlIGRlZmluaXRlbHkgbm9uLWludGVyYWN0aXZlXG4gICAgaWYgKEFMV0FZU19OT05fSU5URVJBQ1RJVkVfVEFHU1t0YWdOYW1lXSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGb3IgYWxsIG90aGVyIGVsZW1lbnRzLCB3ZSBjYW4gb25seSBiZSBjZXJ0YWluIHRoZXkncmUgbm9uLWludGVyYWN0aXZlIGlmIHRoZXkgbGFjayBBTEwgaW5kaWNhdG9ycyBvZiBpbnRlcmFjdGl2aXR5XG4gICAgLy8gQ2hlY2sgZm9yIGFueSBzaWducyBvZiBpbnRlcmFjdGl2aXR5XG4gICAgaWYgKGhhc0FueUludGVyYWN0aXZpdHlJbmRpY2F0b3JzKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBwYXJlbnQgY2hhaW4gZm9yIGludGVyYWN0aXZlIGNvbnRleHRcbiAgICB2YXIgcGFyZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgIHZhciBkZXB0aCA9IDA7XG5cbiAgICB3aGlsZSAocGFyZW50ICYmIGRlcHRoIDwgTUFYX0RFUFRIKSB7XG4gICAgICAgIGlmIChoYXNBbnlJbnRlcmFjdGl2aXR5SW5kaWNhdG9ycyhwYXJlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEVsZW1lbnQgaXMgaW5zaWRlIGFuIGludGVyYWN0aXZlIHBhcmVudFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmVudC5nZXRSb290Tm9kZSAmJiBwYXJlbnQuZ2V0Um9vdE5vZGUoKSAhPT0gZG9jdW1lbnQkMSkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBwYXJlbnQuZ2V0Um9vdE5vZGUoKTtcbiAgICAgICAgICAgIGlmIChyb290Lmhvc3QgJiYgaGFzQW55SW50ZXJhY3Rpdml0eUluZGljYXRvcnMocm9vdC5ob3N0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gSW5zaWRlIGFuIGludGVyYWN0aXZlIHNoYWRvdyBob3N0XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgZGVwdGgrKztcbiAgICB9XG5cbiAgICAvLyBQdXJlIHRleHQgY29udGFpbmVycyB3aXRob3V0IGFueSBpbnRlcmFjdGl2ZSBjb250ZXh0XG4gICAgaWYgKFRFWFRfQ09OVEFJTkVSX1RBR1NbdGFnTmFtZV0pIHtcbiAgICAgICAgLy8gVGhlc2UgYXJlIG5vbi1pbnRlcmFjdGl2ZSBPTkxZIGlmIHRoZXkgaGF2ZSBubyBpbnRlcmFjdGl2ZSBpbmRpY2F0b3JzIChhbHJlYWR5IGNoZWNrZWQgYXMgcGFydCBvZiBoYXNBbnlJbnRlcmFjdGl2aXR5SW5kaWNhdG9ycylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdDogd2UgY2FuJ3QgYmUgY2VydGFpbiBpdCdzIG5vbi1pbnRlcmFjdGl2ZVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvbXBvc2VkIHBhdGggb2YgYSBjbGljayBldmVudCBmb3IgZWxlbWVudHMgZW1iZWRkZWQgaW4gc2hhZG93IERPTS5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gZXZlbnQgdG8gZ2V0IHRoZSBjb21wb3NlZCBwYXRoIGZyb21cbiAqIEByZXR1cm5zIHtBcnJheX0gdGhlIGNvbXBvc2VkIHBhdGggb2YgdGhlIGNsaWNrIGV2ZW50XG4qL1xuZnVuY3Rpb24gZ2V0Q2xpY2tFdmVudENvbXBvc2VkUGF0aChldmVudCkge1xuICAgIGlmICgnY29tcG9zZWRQYXRoJyBpbiBldmVudCkge1xuICAgICAgICByZXR1cm4gZXZlbnRbJ2NvbXBvc2VkUGF0aCddKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdO1xufVxuXG4vKipcbiAqIEdldCB0aGUgZWxlbWVudCBmcm9tIGEgY2xpY2sgZXZlbnQsIGFjY291bnRpbmcgZm9yIGVsZW1lbnRzIGVtYmVkZGVkIGluIHNoYWRvdyBET00uXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIGV2ZW50IHRvIGdldCB0aGUgdGFyZ2V0IGZyb21cbiAqIEByZXR1cm5zIHtFbGVtZW50IHwgbnVsbH0gdGhlIGVsZW1lbnQgdGhhdCB3YXMgdGhlIHRhcmdldCBvZiB0aGUgY2xpY2sgZXZlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0Q2xpY2tFdmVudFRhcmdldEVsZW1lbnQoZXZlbnQpIHtcbiAgICB2YXIgcGF0aCA9IGdldENsaWNrRXZlbnRDb21wb3NlZFBhdGgoZXZlbnQpO1xuXG4gICAgaWYgKHBhdGggJiYgcGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBwYXRoWzBdO1xuICAgIH1cblxuICAgIHJldHVybiBldmVudFsndGFyZ2V0J10gfHwgZXZlbnRbJ3NyY0VsZW1lbnQnXTtcbn1cblxuLyoqIEBjb25zdCAqLyB2YXIgREVGQVVMVF9SQUdFX0NMSUNLX1RIUkVTSE9MRF9QWCA9IDMwO1xuLyoqIEBjb25zdCAqLyB2YXIgREVGQVVMVF9SQUdFX0NMSUNLX1RJTUVPVVRfTVMgPSAxMDAwO1xuLyoqIEBjb25zdCAqLyB2YXIgREVGQVVMVF9SQUdFX0NMSUNLX0NMSUNLX0NPVU5UID0gNDtcbi8qKiBAY29uc3QgKi8gdmFyIERFRkFVTFRfUkFHRV9DTElDS19JTlRFUkFDVElWRV9FTEVNRU5UU19PTkxZID0gZmFsc2U7XG5cbmZ1bmN0aW9uIFJhZ2VDbGlja1RyYWNrZXIoKSB7XG4gICAgdGhpcy5jbGlja3MgPSBbXTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgY2xpY2sgZXZlbnQgaXMgcGFydCBvZiBhIHJhZ2UgY2xpY2sgc2VxdWVuY2UuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIHRoZSBvcmlnaW5hbCBjbGljayBldmVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbmRleC5kLnRzJykuUmFnZUNsaWNrQ29uZmlnfSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciByYWdlIGNsaWNrIGRldGVjdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSAtIHRydWUgaWYgdGhlIGNsaWNrIGlzIGNvbnNpZGVyZWQgYSByYWdlIGNsaWNrLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblJhZ2VDbGlja1RyYWNrZXIucHJvdG90eXBlLmlzUmFnZUNsaWNrID0gZnVuY3Rpb24oZXZlbnQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgdGhyZXNob2xkUHggPSBvcHRpb25zWyd0aHJlc2hvbGRfcHgnXSB8fCBERUZBVUxUX1JBR0VfQ0xJQ0tfVEhSRVNIT0xEX1BYO1xuICAgIHZhciB0aW1lb3V0TXMgPSBvcHRpb25zWyd0aW1lb3V0X21zJ10gfHwgREVGQVVMVF9SQUdFX0NMSUNLX1RJTUVPVVRfTVM7XG4gICAgdmFyIGNsaWNrQ291bnQgPSBvcHRpb25zWydjbGlja19jb3VudCddIHx8IERFRkFVTFRfUkFHRV9DTElDS19DTElDS19DT1VOVDtcbiAgICB2YXIgaW50ZXJhY3RpdmVFbGVtZW50c09ubHkgPSBvcHRpb25zWydpbnRlcmFjdGl2ZV9lbGVtZW50c19vbmx5J10gfHwgREVGQVVMVF9SQUdFX0NMSUNLX0lOVEVSQUNUSVZFX0VMRU1FTlRTX09OTFk7XG5cbiAgICBpZiAoaW50ZXJhY3RpdmVFbGVtZW50c09ubHkpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGdldENsaWNrRXZlbnRUYXJnZXRFbGVtZW50KGV2ZW50KTtcbiAgICAgICAgaWYgKCF0YXJnZXQgfHwgaXNEZWZpbml0ZWx5Tm9uSW50ZXJhY3RpdmUodGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgdmFyIHggPSBldmVudFsncGFnZVgnXSwgeSA9IGV2ZW50WydwYWdlWSddO1xuXG4gICAgdmFyIGxhc3RDbGljayA9IHRoaXMuY2xpY2tzW3RoaXMuY2xpY2tzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChcbiAgICAgICAgbGFzdENsaWNrICYmXG4gICAgICAgIHRpbWVzdGFtcCAtIGxhc3RDbGljay50aW1lc3RhbXAgPCB0aW1lb3V0TXMgJiZcbiAgICAgICAgTWF0aC5zcXJ0KE1hdGgucG93KHggLSBsYXN0Q2xpY2sueCwgMikgKyBNYXRoLnBvdyh5IC0gbGFzdENsaWNrLnksIDIpKSA8IHRocmVzaG9sZFB4XG4gICAgKSB7XG4gICAgICAgIHRoaXMuY2xpY2tzLnB1c2goeyB4OiB4LCB5OiB5LCB0aW1lc3RhbXA6IHRpbWVzdGFtcCB9KTtcbiAgICAgICAgaWYgKHRoaXMuY2xpY2tzLmxlbmd0aCA+PSBjbGlja0NvdW50KSB7XG4gICAgICAgICAgICB0aGlzLmNsaWNrcyA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNsaWNrcyA9IFt7IHg6IHgsIHk6IHksIHRpbWVzdGFtcDogdGltZXN0YW1wIH1dO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiBTaGFkb3dET01PYnNlcnZlcihjaGFuZ2VDYWxsYmFjaywgb2JzZXJ2ZXJDb25maWcpIHtcbiAgICB0aGlzLmNoYW5nZUNhbGxiYWNrID0gY2hhbmdlQ2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcbiAgICB0aGlzLm9ic2VydmVyQ29uZmlnID0gb2JzZXJ2ZXJDb25maWc7XG5cbiAgICB0aGlzLm9ic2VydmVkU2hhZG93Um9vdHMgPSBudWxsO1xuICAgIHRoaXMuc2hhZG93T2JzZXJ2ZXJzID0gW107XG59XG5cblNoYWRvd0RPTU9ic2VydmVyLnByb3RvdHlwZS5nZXRFdmVudFRhcmdldCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLm9ic2VydmVkU2hhZG93Um9vdHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRDbGlja0V2ZW50VGFyZ2V0RWxlbWVudChldmVudCk7XG59O1xuXG5TaGFkb3dET01PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUZyb21FdmVudCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLm9ic2VydmVkU2hhZG93Um9vdHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXRoID0gZ2V0Q2xpY2tFdmVudENvbXBvc2VkUGF0aChldmVudCk7XG5cbiAgICAvLyBDaGVjayBlYWNoIGVsZW1lbnQgaW4gcGF0aCBmb3Igc2hhZG93IHJvb3RzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gcGF0aFtpXTtcblxuICAgICAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZVNoYWRvd1Jvb3QoZWxlbWVudC5zaGFkb3dSb290KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuU2hhZG93RE9NT2JzZXJ2ZXIucHJvdG90eXBlLm9ic2VydmVTaGFkb3dSb290ID0gZnVuY3Rpb24oc2hhZG93Um9vdCkge1xuICAgIGlmICghdGhpcy5vYnNlcnZlZFNoYWRvd1Jvb3RzIHx8IHRoaXMub2JzZXJ2ZWRTaGFkb3dSb290cy5oYXMoc2hhZG93Um9vdCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRyeSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZWRTaGFkb3dSb290cy5hZGQoc2hhZG93Um9vdCk7XG5cbiAgICAgICAgdmFyIG9ic2VydmVyID0gbmV3IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5jaGFuZ2VDYWxsYmFjaygpO1xuICAgICAgICB9KTtcblxuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHNoYWRvd1Jvb3QsIHRoaXMub2JzZXJ2ZXJDb25maWcpO1xuICAgICAgICB0aGlzLnNoYWRvd09ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ2dlciQxLmNyaXRpY2FsKCdFcnJvciB3aGlsZSBvYnNlcnZpbmcgc2hhZG93IHJvb3QnLCBlKTtcbiAgICB9XG59O1xuXG5cblNoYWRvd0RPTU9ic2VydmVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm9ic2VydmVkU2hhZG93Um9vdHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghd2Vha1NldFN1cHBvcnRlZCgpKSB7XG4gICAgICAgIGxvZ2dlciQxLmNyaXRpY2FsKCdTaGFkb3cgRE9NIG9ic2VydmF0aW9uIHVuYXZhaWxhYmxlOiBXZWFrU2V0IG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMub2JzZXJ2ZWRTaGFkb3dSb290cyA9IG5ldyBXZWFrU2V0KCk7XG59O1xuXG5TaGFkb3dET01PYnNlcnZlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5vYnNlcnZlZFNoYWRvd1Jvb3RzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2hhZG93T2JzZXJ2ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnNoYWRvd09ic2VydmVyc1tpXS5kaXNjb25uZWN0KCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlciQxLmNyaXRpY2FsKCdFcnJvciB3aGlsZSBkaXNjb25uZWN0aW5nIHNoYWRvdyBET00gb2JzZXJ2ZXInLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNoYWRvd09ic2VydmVycyA9IFtdO1xuICAgIHRoaXMub2JzZXJ2ZWRTaGFkb3dSb290cyA9IG51bGw7XG59O1xuXG4vKiogQGNvbnN0ICovIHZhciBERUZBVUxUX0RFQURfQ0xJQ0tfVElNRU9VVF9NUyA9IDUwMDtcbi8qKiBAY29uc3QgKi8gdmFyIElOVEVSQUNUSU9OX0VWRU5UUyA9IFtFVl9DSEFOR0UsIEVWX0lOUFVULCBFVl9TVUJNSVQsIEVWX1NFTEVDVCwgRVZfVE9HR0xFXTtcbi8qKiBAY29uc3QgKi8gdmFyIExBWU9VVF9FVkVOVFMgPSBbRVZfU0NST0xMRU5EXTtcbi8qKiBAY29uc3QgKi8gdmFyIE5BVklHQVRJT05fRVZFTlRTID0gW0VWX0hBU0hDSEFOR0VdO1xuLyoqIEBjb25zdCAqLyB2YXIgTVVUQVRJT05fT0JTRVJWRVJfQ09ORklHID0ge1xuICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgIHN1YnRyZWU6IHRydWUsXG4gICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVGaWx0ZXI6IFsnc3R5bGUnLCAnY2xhc3MnLCAnaGlkZGVuJywgJ2NoZWNrZWQnLCAnc2VsZWN0ZWQnLCAndmFsdWUnLCAnZGlzcGxheScsICd2aXNpYmlsaXR5J11cbn07XG5cblxuZnVuY3Rpb24gRGVhZENsaWNrVHJhY2tlcihvbkRlYWRDbGlja0NhbGxiYWNrKSB7XG4gICAgdGhpcy5ldmVudExpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMubXV0YXRpb25PYnNlcnZlciA9IG51bGw7XG4gICAgdGhpcy5zaGFkb3dET01PYnNlcnZlciA9IG51bGw7XG5cbiAgICB0aGlzLmlzVHJhY2tpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmxhc3RDaGFuZ2VFdmVudFRpbWVzdGFtcCA9IDA7XG4gICAgdGhpcy5wZW5kaW5nQ2xpY2tzID0gW107XG4gICAgdGhpcy5vbkRlYWRDbGlja0NhbGxiYWNrID0gb25EZWFkQ2xpY2tDYWxsYmFjaztcbiAgICB0aGlzLnByb2Nlc3NpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLnByb2Nlc3NpbmdUaW1lb3V0ID0gbnVsbDtcbn1cblxuXG5EZWFkQ2xpY2tUcmFja2VyLnByb3RvdHlwZS5hZGRDbGljayA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLnNoYWRvd0RPTU9ic2VydmVyICYmIHRoaXMuc2hhZG93RE9NT2JzZXJ2ZXIuZ2V0RXZlbnRUYXJnZXQoZXZlbnQpO1xuXG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQgPSBldmVudFsndGFyZ2V0J10gfHwgZXZlbnRbJ3NyY0VsZW1lbnQnXTtcbiAgICB9XG5cbiAgICBpZiAoIWVsZW1lbnQgfHwgaXNEZWZpbml0ZWx5Tm9uSW50ZXJhY3RpdmUoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNoYWRvd0RPTU9ic2VydmVyKSB7XG4gICAgICAgIHRoaXMuc2hhZG93RE9NT2JzZXJ2ZXIub2JzZXJ2ZUZyb21FdmVudChldmVudCk7XG4gICAgfVxuICAgIHRoaXMucGVuZGluZ0NsaWNrcy5wdXNoKHtcbiAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbkRlYWRDbGlja1RyYWNrZXIucHJvdG90eXBlLnRyYWNrQ2xpY2sgPSBmdW5jdGlvbihldmVudCwgY29uZmlnKSB7XG4gICAgaWYgKCF0aGlzLmlzVHJhY2tpbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBhZGRlZCA9IHRoaXMuYWRkQ2xpY2soZXZlbnQpO1xuICAgIGlmIChhZGRlZCkge1xuICAgICAgICB0aGlzLnRyaWdnZXJQcm9jZXNzaW5nKGNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiBhZGRlZDtcbn07XG5cbkRlYWRDbGlja1RyYWNrZXIucHJvdG90eXBlLmdldERlYWRDbGlja3MgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICBpZiAodGhpcy5wZW5kaW5nQ2xpY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIHRpbWVvdXRNcyA9IGNvbmZpZ1sndGltZW91dF9tcyddO1xuICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgIHZhciBjbGlja3NUb0V2YWx1YXRlID0gdGhpcy5wZW5kaW5nQ2xpY2tzLnNsaWNlKCk7IC8vIENvcHkgYXJyYXlcbiAgICB0aGlzLnBlbmRpbmdDbGlja3MgPSBbXTsgLy8gQ2xlYXIgb3JpZ2luYWxcblxuICAgIHZhciBkZWFkQ2xpY2tzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaWNrc1RvRXZhbHVhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNsaWNrID0gY2xpY2tzVG9FdmFsdWF0ZVtpXTtcblxuICAgICAgICBpZiAobm93IC0gY2xpY2sudGltZXN0YW1wID49IHRpbWVvdXRNcykge1xuICAgICAgICAgICAgLy8gQ2xpY2sgaGFzIGV4Y2VlZGVkIHRpbWVvdXQsIGNoZWNrIGlmIGl0J3MgZGVhZCBieSBsb29raW5nIGZvciBjaGFuZ2VzIGFmdGVyIHRoaXMgc3BlY2lmaWMgY2xpY2tcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNDaGFuZ2VzQWZ0ZXIoY2xpY2sudGltZXN0YW1wKSkge1xuICAgICAgICAgICAgICAgIGRlYWRDbGlja3MucHVzaChjbGljayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTdGlsbCBwZW5kaW5nIC0gYWRkIGJhY2tcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0NsaWNrcy5wdXNoKGNsaWNrKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkZWFkQ2xpY2tzO1xufTtcblxuRGVhZENsaWNrVHJhY2tlci5wcm90b3R5cGUuaGFzQ2hhbmdlc0FmdGVyID0gZnVuY3Rpb24odGltZXN0YW1wKSB7XG4gICAgLy8gMTAwbXMgdG9sZXJhbmNlIGZvciByYWNlIGNvbmRpdGlvbiBiZXR3ZWVuIHdoZW4gd2UgcmVjb3JkIHRoZSBjbGljayBhbmQgdGhlIGNoYW5nZSBldmVudFxuICAgIHJldHVybiB0aGlzLmxhc3RDaGFuZ2VFdmVudFRpbWVzdGFtcCA+PSAodGltZXN0YW1wIC0gMTAwKTtcbn07XG5cbkRlYWRDbGlja1RyYWNrZXIucHJvdG90eXBlLnJlY29yZENoYW5nZUV2ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5sYXN0Q2hhbmdlRXZlbnRUaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xufTtcblxuRGVhZENsaWNrVHJhY2tlci5wcm90b3R5cGUudHJpZ2dlclByb2Nlc3NpbmcgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAvLyBQcmV2ZW50IG11bHRpcGxlIGNvbmN1cnJlbnQgcHJvY2Vzc2luZyBjaGFpbnNcbiAgICBpZiAodGhpcy5wcm9jZXNzaW5nQWN0aXZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wcm9jZXNzaW5nQWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLnByb2Nlc3NSZWN1cnNpdmVseShjb25maWcpO1xufTtcblxuRGVhZENsaWNrVHJhY2tlci5wcm90b3R5cGUucHJvY2Vzc1JlY3Vyc2l2ZWx5ID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgaWYgKCF0aGlzLmlzVHJhY2tpbmcgfHwgIXRoaXMub25EZWFkQ2xpY2tDYWxsYmFjaykge1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0aW1lb3V0TXMgPSBjb25maWdbJ3RpbWVvdXRfbXMnXTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLnByb2Nlc3NpbmdUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFzZWxmLnByb2Nlc3NpbmdBY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWFkQ2xpY2tzID0gc2VsZi5nZXREZWFkQ2xpY2tzKGNvbmZpZyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWFkQ2xpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzZWxmLm9uRGVhZENsaWNrQ2FsbGJhY2soZGVhZENsaWNrc1tpXS5ldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi5wZW5kaW5nQ2xpY2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHNlbGYucHJvY2Vzc1JlY3Vyc2l2ZWx5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnByb2Nlc3NpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sIHRpbWVvdXRNcyk7XG59O1xuXG5EZWFkQ2xpY2tUcmFja2VyLnByb3RvdHlwZS5zdGFydFRyYWNraW5nID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuaXNUcmFja2luZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5pc1RyYWNraW5nID0gdHJ1ZTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIElOVEVSQUNUSU9OX0VWRU5UUy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnJlY29yZENoYW5nZUV2ZW50KCk7XG4gICAgICAgIH07XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIHsgY2FwdHVyZTogdHJ1ZSwgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgc2VsZi5ldmVudExpc3RlbmVycy5wdXNoKHsgdGFyZ2V0OiBkb2N1bWVudCwgZXZlbnQ6IGV2ZW50LCBoYW5kbGVyOiBoYW5kbGVyLCBvcHRpb25zOiB7IGNhcHR1cmU6IHRydWUsIHBhc3NpdmU6IHRydWUgfSB9KTtcbiAgICB9KTtcbiAgICBOQVZJR0FUSU9OX0VWRU5UUy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnJlY29yZENoYW5nZUV2ZW50KCk7XG4gICAgICAgIH07XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyKTtcbiAgICAgICAgc2VsZi5ldmVudExpc3RlbmVycy5wdXNoKHsgdGFyZ2V0OiB3aW5kb3csIGV2ZW50OiBldmVudCwgaGFuZGxlcjogaGFuZGxlciB9KTtcbiAgICB9KTtcbiAgICBMQVlPVVRfRVZFTlRTLmZvckVhY2goZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYucmVjb3JkQ2hhbmdlRXZlbnQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgc2VsZi5ldmVudExpc3RlbmVycy5wdXNoKHsgdGFyZ2V0OiB3aW5kb3csIGV2ZW50OiBldmVudCwgaGFuZGxlcjogaGFuZGxlciwgb3B0aW9uczogeyBwYXNzaXZlOiB0cnVlIH0gfSk7XG4gICAgfSk7XG4gICAgdmFyIHNlbGVjdGlvbkhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5yZWNvcmRDaGFuZ2VFdmVudCgpO1xuICAgIH07XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgc2VsZWN0aW9uSGFuZGxlcik7XG4gICAgc2VsZi5ldmVudExpc3RlbmVycy5wdXNoKHsgdGFyZ2V0OiBkb2N1bWVudCwgZXZlbnQ6ICdzZWxlY3Rpb25jaGFuZ2UnLCBoYW5kbGVyOiBzZWxlY3Rpb25IYW5kbGVyIH0pO1xuXG4gICAgLy8gU2V0IHVwIE11dGF0aW9uT2JzZXJ2ZXJcbiAgICBpZiAod2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25PYnNlcnZlciA9IG5ldyB3aW5kb3cuTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJlY29yZENoYW5nZUV2ZW50KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIE1VVEFUSU9OX09CU0VSVkVSX0NPTkZJRyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlciQxLmNyaXRpY2FsKCdFcnJvciB3aGlsZSBzZXR0aW5nIHVwIG11dGF0aW9uIG9ic2VydmVyJywgZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXQgdXAgU2hhZG93IERPTSBvYnNlcnZlclxuICAgIGlmICh3aW5kb3cuY3VzdG9tRWxlbWVudHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc2hhZG93RE9NT2JzZXJ2ZXIgPSBuZXcgU2hhZG93RE9NT2JzZXJ2ZXIoXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVjb3JkQ2hhbmdlRXZlbnQoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIE1VVEFUSU9OX09CU0VSVkVSX0NPTkZJR1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuc2hhZG93RE9NT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nZ2VyJDEuY3JpdGljYWwoJ0Vycm9yIHdoaWxlIHNldHRpbmcgdXAgc2hhZG93IERPTSBvYnNlcnZlcicsIGUpO1xuICAgICAgICAgICAgdGhpcy5zaGFkb3dET01PYnNlcnZlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5EZWFkQ2xpY2tUcmFja2VyLnByb3RvdHlwZS5zdG9wVHJhY2tpbmcgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuaXNUcmFja2luZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5pc1RyYWNraW5nID0gZmFsc2U7XG4gICAgdGhpcy5wZW5kaW5nQ2xpY2tzID0gW107XG4gICAgdGhpcy5sYXN0Q2hhbmdlRXZlbnRUaW1lc3RhbXAgPSAwO1xuICAgIHRoaXMucHJvY2Vzc2luZ0FjdGl2ZSA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMucHJvY2Vzc2luZ1RpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucHJvY2Vzc2luZ1RpbWVvdXQpO1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdUaW1lb3V0ID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgYWxsIGV2ZW50IGxpc3RlbmVyc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ldmVudExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLmV2ZW50TGlzdGVuZXJzW2ldO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGlzdGVuZXIudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIobGlzdGVuZXIuZXZlbnQsIGxpc3RlbmVyLmhhbmRsZXIsIGxpc3RlbmVyLm9wdGlvbnMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dnZXIkMS5jcml0aWNhbCgnRXJyb3Igd2hpbGUgcmVtb3ZpbmcgZXZlbnQgbGlzdGVuZXInLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmV2ZW50TGlzdGVuZXJzID0gW107XG5cbiAgICBpZiAodGhpcy5tdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dnZXIkMS5jcml0aWNhbCgnRXJyb3Igd2hpbGUgZGlzY29ubmVjdGluZyBtdXRhdGlvbiBvYnNlcnZlcicsIGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubXV0YXRpb25PYnNlcnZlciA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2hhZG93RE9NT2JzZXJ2ZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc2hhZG93RE9NT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dnZXIkMS5jcml0aWNhbCgnRXJyb3Igd2hpbGUgc3RvcHBpbmcgc2hhZG93IERPTSBvYnNlcnZlcicsIGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hhZG93RE9NT2JzZXJ2ZXIgPSBudWxsO1xuICAgIH1cbn07XG5cbnZhciBBVVRPQ0FQVFVSRV9DT05GSUdfS0VZID0gJ2F1dG9jYXB0dXJlJztcbnZhciBMRUdBQ1lfUEFHRVZJRVdfQ09ORklHX0tFWSA9ICd0cmFja19wYWdldmlldyc7XG5cbnZhciBQQUdFVklFV19PUFRJT05fRlVMTF9VUkwgPSAnZnVsbC11cmwnO1xudmFyIFBBR0VWSUVXX09QVElPTl9VUkxfV0lUSF9QQVRIX0FORF9RVUVSWV9TVFJJTkcgPSAndXJsLXdpdGgtcGF0aC1hbmQtcXVlcnktc3RyaW5nJztcbnZhciBQQUdFVklFV19PUFRJT05fVVJMX1dJVEhfUEFUSCA9ICd1cmwtd2l0aC1wYXRoJztcblxudmFyIENPTkZJR19BTExPV19FTEVNRU5UX0NBTExCQUNLID0gJ2FsbG93X2VsZW1lbnRfY2FsbGJhY2snO1xudmFyIENPTkZJR19BTExPV19TRUxFQ1RPUlMgPSAnYWxsb3dfc2VsZWN0b3JzJztcbnZhciBDT05GSUdfQUxMT1dfVVJMX1JFR0VYRVMgPSAnYWxsb3dfdXJsX3JlZ2V4ZXMnO1xudmFyIENPTkZJR19CTE9DS19BVFRSUyA9ICdibG9ja19hdHRycyc7XG52YXIgQ09ORklHX0JMT0NLX0VMRU1FTlRfQ0FMTEJBQ0sgPSAnYmxvY2tfZWxlbWVudF9jYWxsYmFjayc7XG52YXIgQ09ORklHX0JMT0NLX1NFTEVDVE9SUyA9ICdibG9ja19zZWxlY3RvcnMnO1xudmFyIENPTkZJR19CTE9DS19VUkxfUkVHRVhFUyA9ICdibG9ja191cmxfcmVnZXhlcyc7XG52YXIgQ09ORklHX0NBUFRVUkVfRVhUUkFfQVRUUlMgPSAnY2FwdHVyZV9leHRyYV9hdHRycyc7XG52YXIgQ09ORklHX0NBUFRVUkVfVEVYVF9DT05URU5UID0gJ2NhcHR1cmVfdGV4dF9jb250ZW50JztcbnZhciBDT05GSUdfU0NST0xMX0NBUFRVUkVfQUxMID0gJ3Njcm9sbF9jYXB0dXJlX2FsbCc7XG52YXIgQ09ORklHX1NDUk9MTF9DSEVDS1BPSU5UUyA9ICdzY3JvbGxfZGVwdGhfcGVyY2VudF9jaGVja3BvaW50cyc7XG52YXIgQ09ORklHX1RSQUNLX0NMSUNLID0gJ2NsaWNrJztcbnZhciBDT05GSUdfVFJBQ0tfREVBRF9DTElDSyA9ICdkZWFkX2NsaWNrJztcbnZhciBDT05GSUdfVFJBQ0tfSU5QVVQgPSAnaW5wdXQnO1xudmFyIENPTkZJR19UUkFDS19QQUdFVklFVyA9ICdwYWdldmlldyc7XG52YXIgQ09ORklHX1RSQUNLX1JBR0VfQ0xJQ0sgPSAncmFnZV9jbGljayc7XG52YXIgQ09ORklHX1RSQUNLX1NDUk9MTCA9ICdzY3JvbGwnO1xudmFyIENPTkZJR19UUkFDS19QQUdFX0xFQVZFID0gJ3BhZ2VfbGVhdmUnO1xudmFyIENPTkZJR19UUkFDS19TVUJNSVQgPSAnc3VibWl0JztcblxudmFyIENPTkZJR19ERUZBVUxUUyQxID0ge307XG5DT05GSUdfREVGQVVMVFMkMVtDT05GSUdfQUxMT1dfU0VMRUNUT1JTXSA9IFtdO1xuQ09ORklHX0RFRkFVTFRTJDFbQ09ORklHX0FMTE9XX1VSTF9SRUdFWEVTXSA9IFtdO1xuQ09ORklHX0RFRkFVTFRTJDFbQ09ORklHX0JMT0NLX0FUVFJTXSA9IFtdO1xuQ09ORklHX0RFRkFVTFRTJDFbQ09ORklHX0JMT0NLX0VMRU1FTlRfQ0FMTEJBQ0tdID0gbnVsbDtcbkNPTkZJR19ERUZBVUxUUyQxW0NPTkZJR19CTE9DS19TRUxFQ1RPUlNdID0gW107XG5DT05GSUdfREVGQVVMVFMkMVtDT05GSUdfQkxPQ0tfVVJMX1JFR0VYRVNdID0gW107XG5DT05GSUdfREVGQVVMVFMkMVtDT05GSUdfQ0FQVFVSRV9FWFRSQV9BVFRSU10gPSBbXTtcbkNPTkZJR19ERUZBVUxUUyQxW0NPTkZJR19DQVBUVVJFX1RFWFRfQ09OVEVOVF0gPSBmYWxzZTtcbkNPTkZJR19ERUZBVUxUUyQxW0NPTkZJR19TQ1JPTExfQ0FQVFVSRV9BTExdID0gZmFsc2U7XG5DT05GSUdfREVGQVVMVFMkMVtDT05GSUdfU0NST0xMX0NIRUNLUE9JTlRTXSA9IFsyNSwgNTAsIDc1LCAxMDBdO1xuQ09ORklHX0RFRkFVTFRTJDFbQ09ORklHX1RSQUNLX0NMSUNLXSA9IHRydWU7XG5DT05GSUdfREVGQVVMVFMkMVtDT05GSUdfVFJBQ0tfREVBRF9DTElDS10gPSB0cnVlO1xuQ09ORklHX0RFRkFVTFRTJDFbQ09ORklHX1RSQUNLX0lOUFVUXSA9IHRydWU7XG5DT05GSUdfREVGQVVMVFMkMVtDT05GSUdfVFJBQ0tfUEFHRVZJRVddID0gUEFHRVZJRVdfT1BUSU9OX0ZVTExfVVJMO1xuQ09ORklHX0RFRkFVTFRTJDFbQ09ORklHX1RSQUNLX1JBR0VfQ0xJQ0tdID0gdHJ1ZTtcbkNPTkZJR19ERUZBVUxUUyQxW0NPTkZJR19UUkFDS19TQ1JPTExdID0gdHJ1ZTtcbkNPTkZJR19ERUZBVUxUUyQxW0NPTkZJR19UUkFDS19QQUdFX0xFQVZFXSA9IGZhbHNlO1xuQ09ORklHX0RFRkFVTFRTJDFbQ09ORklHX1RSQUNLX1NVQk1JVF0gPSB0cnVlO1xuXG52YXIgREVGQVVMVF9QUk9QUyA9IHtcbiAgICAnJG1wX2F1dG9jYXB0dXJlJzogdHJ1ZVxufTtcblxudmFyIE1QX0VWX0NMSUNLID0gJyRtcF9jbGljayc7XG52YXIgTVBfRVZfREVBRF9DTElDSyA9ICckbXBfZGVhZF9jbGljayc7XG52YXIgTVBfRVZfSU5QVVQgPSAnJG1wX2lucHV0X2NoYW5nZSc7XG52YXIgTVBfRVZfUkFHRV9DTElDSyA9ICckbXBfcmFnZV9jbGljayc7XG52YXIgTVBfRVZfU0NST0xMID0gJyRtcF9zY3JvbGwnO1xudmFyIE1QX0VWX1NVQk1JVCA9ICckbXBfc3VibWl0JztcbnZhciBNUF9FVl9QQUdFX0xFQVZFID0gJyRtcF9wYWdlX2xlYXZlJztcblxuLyoqXG4gKiBBdXRvY2FwdHVyZTogbWFuYWdlcyBhdXRvbWF0aWMgZXZlbnQgdHJhY2tpbmdcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQXV0b2NhcHR1cmUgPSBmdW5jdGlvbihtcCkge1xuICAgIHRoaXMubXAgPSBtcDtcbiAgICB0aGlzLm1heFNjcm9sbFZpZXdEZXB0aCA9IDA7XG4gICAgdGhpcy5oYXNUcmFja2VkU2Nyb2xsU2Vzc2lvbiA9IGZhbHNlO1xuICAgIHRoaXMucHJldmlvdXNTY3JvbGxIZWlnaHQgPSAwO1xufTtcblxuQXV0b2NhcHR1cmUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIW1pbkRPTUFwaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICBsb2dnZXIkMS5jcml0aWNhbCgnQXV0b2NhcHR1cmUgdW5hdmFpbGFibGU6IG1pc3NpbmcgcmVxdWlyZWQgRE9NIEFQSXMnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmluaXRQYWdlTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5pbml0UGFnZXZpZXdUcmFja2luZygpO1xuICAgIHRoaXMuaW5pdENsaWNrVHJhY2tpbmcoKTtcbiAgICB0aGlzLmluaXREZWFkQ2xpY2tUcmFja2luZygpO1xuICAgIHRoaXMuaW5pdElucHV0VHJhY2tpbmcoKTtcbiAgICB0aGlzLmluaXRTY3JvbGxUcmFja2luZygpO1xuICAgIHRoaXMuaW5pdFN1Ym1pdFRyYWNraW5nKCk7XG4gICAgdGhpcy5pbml0UmFnZUNsaWNrVHJhY2tpbmcoKTtcbiAgICB0aGlzLmluaXRQYWdlTGVhdmVUcmFja2luZygpO1xufTtcblxuQXV0b2NhcHR1cmUucHJvdG90eXBlLmdldEZ1bGxDb25maWcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXV0b2NhcHR1cmVDb25maWcgPSB0aGlzLm1wLmdldF9jb25maWcoQVVUT0NBUFRVUkVfQ09ORklHX0tFWSk7XG4gICAgaWYgKCFhdXRvY2FwdHVyZUNvbmZpZykge1xuICAgICAgICAvLyBBdXRvY2FwdHVyZSBpcyBjb21wbGV0ZWx5IG9mZlxuICAgICAgICByZXR1cm4ge307XG4gICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KGF1dG9jYXB0dXJlQ29uZmlnKSkge1xuICAgICAgICByZXR1cm4gXy5leHRlbmQoe30sIENPTkZJR19ERUZBVUxUUyQxLCBhdXRvY2FwdHVyZUNvbmZpZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXV0b2NhcHR1cmUgY29uZmlnIGlzIG5vbi1vYmplY3QgdHJ1dGh5IHZhbHVlLCByZXR1cm4gZGVmYXVsdFxuICAgICAgICByZXR1cm4gQ09ORklHX0RFRkFVTFRTJDE7XG4gICAgfVxufTtcblxuQXV0b2NhcHR1cmUucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiB0aGlzLmdldEZ1bGxDb25maWcoKVtrZXldO1xufTtcblxuQXV0b2NhcHR1cmUucHJvdG90eXBlLmN1cnJlbnRVcmxCbG9ja2VkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGN1cnJlbnRVcmwgPSBfLmluZm8uY3VycmVudFVybCgpO1xuXG4gICAgdmFyIGFsbG93VXJsUmVnZXhlcyA9IHRoaXMuZ2V0Q29uZmlnKENPTkZJR19BTExPV19VUkxfUkVHRVhFUykgfHwgW107XG4gICAgaWYgKGFsbG93VXJsUmVnZXhlcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gd2UncmUgdXNpbmcgYW4gYWxsb3dsaXN0LCBvbmx5IHRyYWNrIGlmIGN1cnJlbnQgVVJMIG1hdGNoZXNcbiAgICAgICAgdmFyIGFsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFsbG93VXJsUmVnZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGFsbG93UmVnZXggPSBhbGxvd1VybFJlZ2V4ZXNbaV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VXJsLm1hdGNoKGFsbG93UmVnZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkMS5jcml0aWNhbCgnRXJyb3Igd2hpbGUgY2hlY2tpbmcgYmxvY2sgVVJMIHJlZ2V4OiAnICsgYWxsb3dSZWdleCwgZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFsbG93ZWQpIHtcbiAgICAgICAgICAgIC8vIHdhc24ndCBhbGxvd2VkIGJ5IGFueSByZWdleFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYmxvY2tVcmxSZWdleGVzID0gdGhpcy5nZXRDb25maWcoQ09ORklHX0JMT0NLX1VSTF9SRUdFWEVTKSB8fCBbXTtcbiAgICBpZiAoIWJsb2NrVXJsUmVnZXhlcyB8fCAhYmxvY2tVcmxSZWdleGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGJsb2NrVXJsUmVnZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRVcmwubWF0Y2goYmxvY2tVcmxSZWdleGVzW2ldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGxvZ2dlciQxLmNyaXRpY2FsKCdFcnJvciB3aGlsZSBjaGVja2luZyBibG9jayBVUkwgcmVnZXg6ICcgKyBibG9ja1VybFJlZ2V4ZXNbaV0sIGVycik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUucGFnZXZpZXdUcmFja2luZ0NvbmZpZyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIHN1cHBvcnRzIGJvdGggYXV0b2NhcHR1cmUgY29uZmlnIGFuZCBvbGQgdHJhY2tfcGFnZXZpZXcgY29uZmlnXG4gICAgaWYgKHRoaXMubXAuZ2V0X2NvbmZpZyhBVVRPQ0FQVFVSRV9DT05GSUdfS0VZKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb25maWcoQ09ORklHX1RSQUNLX1BBR0VWSUVXKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5tcC5nZXRfY29uZmlnKExFR0FDWV9QQUdFVklFV19DT05GSUdfS0VZKTtcbiAgICB9XG59O1xuXG4vLyBoZWxwZXIgZm9yIGV2ZW50IGhhbmRsZXJzXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUudHJhY2tEb21FdmVudCA9IGZ1bmN0aW9uKGV2LCBtcEV2ZW50TmFtZSkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRVcmxCbG9ja2VkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpc0NhcHR1cmVkRm9ySGVhdE1hcCA9IHRoaXMubXAuaXNfcmVjb3JkaW5nX2hlYXRtYXBfZGF0YSgpICYmIChcbiAgICAgICAgKG1wRXZlbnROYW1lID09PSBNUF9FVl9DTElDSyAmJiAhdGhpcy5nZXRDb25maWcoQ09ORklHX1RSQUNLX0NMSUNLKSkgfHxcbiAgICAgICAgKG1wRXZlbnROYW1lID09PSBNUF9FVl9SQUdFX0NMSUNLICYmICF0aGlzLl9nZXRDbGlja1RyYWNraW5nQ29uZmlnKENPTkZJR19UUkFDS19SQUdFX0NMSUNLKSkgfHxcbiAgICAgICAgKG1wRXZlbnROYW1lID09PSBNUF9FVl9ERUFEX0NMSUNLICYmICF0aGlzLl9nZXRDbGlja1RyYWNraW5nQ29uZmlnKENPTkZJR19UUkFDS19ERUFEX0NMSUNLKSlcbiAgICApO1xuXG4gICAgdmFyIHByb3BzID0gZ2V0UHJvcHNGb3JET01FdmVudChldiwge1xuICAgICAgICBhbGxvd0VsZW1lbnRDYWxsYmFjazogdGhpcy5nZXRDb25maWcoQ09ORklHX0FMTE9XX0VMRU1FTlRfQ0FMTEJBQ0spLFxuICAgICAgICBhbGxvd1NlbGVjdG9yczogdGhpcy5nZXRDb25maWcoQ09ORklHX0FMTE9XX1NFTEVDVE9SUyksXG4gICAgICAgIGJsb2NrQXR0cnM6IHRoaXMuZ2V0Q29uZmlnKENPTkZJR19CTE9DS19BVFRSUyksXG4gICAgICAgIGJsb2NrRWxlbWVudENhbGxiYWNrOiB0aGlzLmdldENvbmZpZyhDT05GSUdfQkxPQ0tfRUxFTUVOVF9DQUxMQkFDSyksXG4gICAgICAgIGJsb2NrU2VsZWN0b3JzOiB0aGlzLmdldENvbmZpZyhDT05GSUdfQkxPQ0tfU0VMRUNUT1JTKSxcbiAgICAgICAgY2FwdHVyZUV4dHJhQXR0cnM6IHRoaXMuZ2V0Q29uZmlnKENPTkZJR19DQVBUVVJFX0VYVFJBX0FUVFJTKSxcbiAgICAgICAgY2FwdHVyZVRleHRDb250ZW50OiB0aGlzLmdldENvbmZpZyhDT05GSUdfQ0FQVFVSRV9URVhUX0NPTlRFTlQpLFxuICAgICAgICBjYXB0dXJlZEZvckhlYXRNYXA6IGlzQ2FwdHVyZWRGb3JIZWF0TWFwLFxuICAgIH0pO1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICBfLmV4dGVuZChwcm9wcywgREVGQVVMVF9QUk9QUyk7XG4gICAgICAgIHRoaXMubXAudHJhY2sobXBFdmVudE5hbWUsIHByb3BzKTtcbiAgICB9XG59O1xuXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUuaW5pdFBhZ2VMaXN0ZW5lcnMgPSBmdW5jdGlvbigpIHtcbiAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVl9QT1BTVEFURSwgdGhpcy5saXN0ZW5lclBvcHN0YXRlKTtcbiAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVl9IQVNIQ0hBTkdFLCB0aGlzLmxpc3RlbmVySGFzaGNoYW5nZSk7XG5cbiAgICBpZiAoIXRoaXMucGFnZXZpZXdUcmFja2luZ0NvbmZpZygpICYmICF0aGlzLmdldENvbmZpZyhDT05GSUdfVFJBQ0tfUEFHRV9MRUFWRSkgJiYgIXRoaXMubXAuZ2V0X2NvbmZpZygncmVjb3JkX2hlYXRtYXBfZGF0YScpKSB7XG4gICAgICAgIC8vIFRoZXNlIGFyZSBhbGwgdGhlIGNvbmZpZ3MgdGhhdCB1c2UgdGhlc2UgbGlzdGVuZXJzXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmxpc3RlbmVyUG9wc3RhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgd2luLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWX01QX0xPQ0FUSU9OX0NIQU5HRSkpO1xuICAgIH07XG4gICAgdGhpcy5saXN0ZW5lckhhc2hjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgd2luLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWX01QX0xPQ0FUSU9OX0NIQU5HRSkpO1xuICAgIH07XG5cbiAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihFVl9QT1BTVEFURSwgdGhpcy5saXN0ZW5lclBvcHN0YXRlKTtcbiAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihFVl9IQVNIQ0hBTkdFLCB0aGlzLmxpc3RlbmVySGFzaGNoYW5nZSk7XG4gICAgdmFyIG5hdGl2ZVB1c2hTdGF0ZSA9IHdpbi5oaXN0b3J5LnB1c2hTdGF0ZTtcbiAgICBpZiAodHlwZW9mIG5hdGl2ZVB1c2hTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3aW4uaGlzdG9yeS5wdXNoU3RhdGUgPSBmdW5jdGlvbihzdGF0ZSwgdW51c2VkLCB1cmwpIHtcbiAgICAgICAgICAgIG5hdGl2ZVB1c2hTdGF0ZS5jYWxsKHdpbi5oaXN0b3J5LCBzdGF0ZSwgdW51c2VkLCB1cmwpO1xuICAgICAgICAgICAgd2luLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWX01QX0xPQ0FUSU9OX0NIQU5HRSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgbmF0aXZlUmVwbGFjZVN0YXRlID0gd2luLmhpc3RvcnkucmVwbGFjZVN0YXRlO1xuICAgIGlmICh0eXBlb2YgbmF0aXZlUmVwbGFjZVN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdpbi5oaXN0b3J5LnJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlLCB1bnVzZWQsIHVybCkge1xuICAgICAgICAgICAgbmF0aXZlUmVwbGFjZVN0YXRlLmNhbGwod2luLmhpc3RvcnksIHN0YXRlLCB1bnVzZWQsIHVybCk7XG4gICAgICAgICAgICB3aW4uZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZfTVBfTE9DQVRJT05fQ0hBTkdFKSk7XG4gICAgICAgIH07XG4gICAgfVxufTtcblxuQXV0b2NhcHR1cmUucHJvdG90eXBlLl9nZXRDbGlja1RyYWNraW5nQ29uZmlnID0gZnVuY3Rpb24oY29uZmlnS2V5KSB7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuZ2V0Q29uZmlnKGNvbmZpZ0tleSk7XG5cbiAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICByZXR1cm4gbnVsbDsgLy8gY2xpY2sgdHJhY2tpbmcgZGlzYWJsZWRcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB7fTsgLy8gdXNlIGRlZmF1bHRzXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBjb25maWc7IC8vIHVzZSBjdXN0b20gY29uZmlndXJhdGlvblxuICAgIH1cblxuICAgIHJldHVybiB7fTsgLy8gZmFsbGJhY2sgdG8gZGVmYXVsdHMgZm9yIGFueSBvdGhlciB0cnV0aHkgdmFsdWVcbn07XG5cbkF1dG9jYXB0dXJlLnByb3RvdHlwZS5fdHJhY2tQYWdlTGVhdmUgPSBmdW5jdGlvbihldiwgY3VycmVudFVybCwgY3VycmVudFNjcm9sbEhlaWdodCkge1xuICAgIGlmICh0aGlzLmhhc1RyYWNrZWRTY3JvbGxTZXNzaW9uKSB7XG4gICAgICAgIC8vIFVzZXIgaGFzIG5hdmlnYXRlZCBhd2F5IGFscmVhZHkgZW5kaW5nIHRoZWlyIGltcHJlc3Npb24uXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZ2V0Q29uZmlnKENPTkZJR19UUkFDS19QQUdFX0xFQVZFKSAmJiAhdGhpcy5tcC5pc19yZWNvcmRpbmdfaGVhdG1hcF9kYXRhKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaGFzVHJhY2tlZFNjcm9sbFNlc3Npb24gPSB0cnVlO1xuICAgIHZhciB2aWV3cG9ydEhlaWdodCA9IE1hdGgubWF4KGRvY3VtZW50JDEuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCwgd2luLmlubmVySGVpZ2h0IHx8IDApO1xuICAgIHZhciBzY3JvbGxQZXJjZW50YWdlID0gTWF0aC5yb3VuZChNYXRoLm1heCh0aGlzLm1heFNjcm9sbFZpZXdEZXB0aCAtIHZpZXdwb3J0SGVpZ2h0LCAwKSAvIChjdXJyZW50U2Nyb2xsSGVpZ2h0IC0gdmlld3BvcnRIZWlnaHQpICogMTAwKTtcbiAgICB2YXIgZm9sZExpbmVQZXJjZW50YWdlID0gTWF0aC5yb3VuZCgodmlld3BvcnRIZWlnaHQgLyBjdXJyZW50U2Nyb2xsSGVpZ2h0KSAqIDEwMCk7XG4gICAgaWYgKGN1cnJlbnRTY3JvbGxIZWlnaHQgPD0gdmlld3BvcnRIZWlnaHQpIHtcbiAgICAgICAgLy8gSWYgdGhlIGNvbnRlbnQgZml0cyB3aXRoaW4gdGhlIHZpZXdwb3J0LCBjb25zaWRlciBpdCBmdWxseSBzY3JvbGxlZFxuICAgICAgICBzY3JvbGxQZXJjZW50YWdlID0gMTAwO1xuICAgICAgICBmb2xkTGluZVBlcmNlbnRhZ2UgPSAxMDA7XG4gICAgfVxuXG4gICAgdmFyIHByb3BzID0gXy5leHRlbmQoe1xuICAgICAgICAnJG1heF9zY3JvbGxfdmlld19kZXB0aCc6IHRoaXMubWF4U2Nyb2xsVmlld0RlcHRoLFxuICAgICAgICAnJG1heF9zY3JvbGxfcGVyY2VudGFnZSc6IHNjcm9sbFBlcmNlbnRhZ2UsXG4gICAgICAgICckZm9sZF9saW5lX3BlcmNlbnRhZ2UnOiBmb2xkTGluZVBlcmNlbnRhZ2UsXG4gICAgICAgICckc2Nyb2xsX2hlaWdodCc6ICBjdXJyZW50U2Nyb2xsSGVpZ2h0LFxuICAgICAgICAnJGV2ZW50X3R5cGUnOiBldi50eXBlLFxuICAgICAgICAnJGN1cnJlbnRfdXJsJzogY3VycmVudFVybCB8fCBfLmluZm8uY3VycmVudFVybCgpLFxuICAgICAgICAnJHZpZXdwb3J0SGVpZ2h0Jzogdmlld3BvcnRIZWlnaHQsIC8vIFRoaXMgaXMgdGhlIGZvbGQgbGluZVxuICAgICAgICAnJHZpZXdwb3J0V2lkdGgnOiAgTWF0aC5tYXgoZG9jdW1lbnQkMS5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsIHdpbi5pbm5lcldpZHRoIHx8IDApLFxuICAgICAgICAnJGNhcHR1cmVkX2Zvcl9oZWF0bWFwJzogdGhpcy5tcC5pc19yZWNvcmRpbmdfaGVhdG1hcF9kYXRhKClcbiAgICB9LCBERUZBVUxUX1BST1BTKTtcblxuICAgIC8vIFNlbmQgd2l0aCBiZWFjb24gdHJhbnNwb3J0IHRvIGVuc3VyZSBldmVudCBpcyBzZW50IGJlZm9yZSB1bmxvYWRcbiAgICB0aGlzLm1wLnRyYWNrKE1QX0VWX1BBR0VfTEVBVkUsIHByb3BzLCB7dHJhbnNwb3J0OiAnc2VuZEJlYWNvbid9KTtcbn07XG5cbkF1dG9jYXB0dXJlLnByb3RvdHlwZS5faW5pdFNjcm9sbERlcHRoVHJhY2tpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVl9TQ1JPTEwsIHRoaXMubGlzdGVuZXJTY3JvbGxEZXB0aCk7XG4gICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZfU0NST0xMRU5ELCB0aGlzLmxpc3RlbmVyU2Nyb2xsRGVwdGgpO1xuXG4gICAgaWYgKCF0aGlzLm1wLmdldF9jb25maWcoJ3JlY29yZF9oZWF0bWFwX2RhdGEnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbG9nZ2VyJDEubG9nKCdJbml0aWFsaXppbmcgc2Nyb2xsIGRlcHRoIHRyYWNraW5nJyk7XG5cbiAgICB0aGlzLm1heFNjcm9sbFZpZXdEZXB0aCA9IE1hdGgubWF4KGRvY3VtZW50JDEuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCwgd2luLmlubmVySGVpZ2h0IHx8IDApO1xuXG4gICAgdmFyIHVwZGF0ZVNjcm9sbERlcHRoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRVcmxCbG9ja2VkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2Nyb2xsVmlld0hlaWdodCA9IE1hdGgubWF4KGRvY3VtZW50JDEuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCwgd2luLmlubmVySGVpZ2h0IHx8IDApICsgd2luLnNjcm9sbFk7XG4gICAgICAgIGlmIChzY3JvbGxWaWV3SGVpZ2h0ID4gdGhpcy5tYXhTY3JvbGxWaWV3RGVwdGgpIHtcbiAgICAgICAgICAgIHRoaXMubWF4U2Nyb2xsVmlld0RlcHRoID0gc2Nyb2xsVmlld0hlaWdodDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXZpb3VzU2Nyb2xsSGVpZ2h0ID0gZG9jdW1lbnQkMS5ib2R5LnNjcm9sbEhlaWdodDtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB2YXIgc2Nyb2xsRW5kUG9seWZpbGwgPSBnZXRQb2x5ZmlsbFNjcm9sbEVuZEZ1bmN0aW9uKHVwZGF0ZVNjcm9sbERlcHRoKTtcbiAgICB0aGlzLmxpc3RlbmVyU2Nyb2xsRGVwdGggPSBzY3JvbGxFbmRQb2x5ZmlsbC5saXN0ZW5lcjtcbiAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihzY3JvbGxFbmRQb2x5ZmlsbC5ldmVudFR5cGUsIHRoaXMubGlzdGVuZXJTY3JvbGxEZXB0aCk7XG59O1xuXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUuaW5pdENsaWNrVHJhY2tpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVl9DTElDSywgdGhpcy5saXN0ZW5lckNsaWNrKTtcblxuICAgIGlmICghdGhpcy5nZXRDb25maWcoQ09ORklHX1RSQUNLX0NMSUNLKSAmJiAhdGhpcy5tcC5nZXRfY29uZmlnKCdyZWNvcmRfaGVhdG1hcF9kYXRhJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsb2dnZXIkMS5sb2coJ0luaXRpYWxpemluZyBjbGljayB0cmFja2luZycpO1xuXG4gICAgdGhpcy5saXN0ZW5lckNsaWNrID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdldENvbmZpZyhDT05GSUdfVFJBQ0tfQ0xJQ0spICYmICF0aGlzLm1wLmlzX3JlY29yZGluZ19oZWF0bWFwX2RhdGEoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2tEb21FdmVudChldiwgTVBfRVZfQ0xJQ0spO1xuICAgIH0uYmluZCh0aGlzKTtcbiAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihFVl9DTElDSywgdGhpcy5saXN0ZW5lckNsaWNrKTtcbn07XG5cbkF1dG9jYXB0dXJlLnByb3RvdHlwZS5pbml0RGVhZENsaWNrVHJhY2tpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGVhZENsaWNrQ29uZmlnID0gdGhpcy5fZ2V0Q2xpY2tUcmFja2luZ0NvbmZpZyhDT05GSUdfVFJBQ0tfREVBRF9DTElDSyk7XG5cbiAgICBpZiAoIWRlYWRDbGlja0NvbmZpZyAmJiAhdGhpcy5tcC5nZXRfY29uZmlnKCdyZWNvcmRfaGVhdG1hcF9kYXRhJykpIHtcbiAgICAgICAgdGhpcy5zdG9wRGVhZENsaWNrVHJhY2tpbmcoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxvZ2dlciQxLmxvZygnSW5pdGlhbGl6aW5nIGRlYWQgY2xpY2sgdHJhY2tpbmcnKTtcbiAgICBpZiAoIXRoaXMuX2RlYWRDbGlja1RyYWNrZXIpIHtcbiAgICAgICAgdGhpcy5fZGVhZENsaWNrVHJhY2tlciA9IG5ldyBEZWFkQ2xpY2tUcmFja2VyKGZ1bmN0aW9uKGRlYWRDbGlja0V2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNrRG9tRXZlbnQoZGVhZENsaWNrRXZlbnQsIE1QX0VWX0RFQURfQ0xJQ0spO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9kZWFkQ2xpY2tUcmFja2VyLnN0YXJ0VHJhY2tpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMubGlzdGVuZXJEZWFkQ2xpY2spIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lckRlYWRDbGljayA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudERlYWRDbGlja0NvbmZpZyA9IHRoaXMuX2dldENsaWNrVHJhY2tpbmdDb25maWcoQ09ORklHX1RSQUNLX0RFQURfQ0xJQ0spO1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50RGVhZENsaWNrQ29uZmlnICYmICF0aGlzLm1wLmlzX3JlY29yZGluZ19oZWF0bWFwX2RhdGEoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRVcmxCbG9ja2VkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgY29uZmlnIHRvIGVuc3VyZSB0aW1lb3V0X21zIGlzIGFsd2F5cyBzZXRcbiAgICAgICAgICAgIHZhciBub3JtYWxpemVkQ29uZmlnID0gY3VycmVudERlYWRDbGlja0NvbmZpZyB8fCB7fTtcbiAgICAgICAgICAgIGlmICghbm9ybWFsaXplZENvbmZpZ1sndGltZW91dF9tcyddKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZENvbmZpZ1sndGltZW91dF9tcyddID0gREVGQVVMVF9ERUFEX0NMSUNLX1RJTUVPVVRfTVM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kZWFkQ2xpY2tUcmFja2VyLnRyYWNrQ2xpY2soZXYsIG5vcm1hbGl6ZWRDb25maWcpO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG4gICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKEVWX0NMSUNLLCB0aGlzLmxpc3RlbmVyRGVhZENsaWNrKTtcbiAgICB9XG59O1xuXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUuaW5pdElucHV0VHJhY2tpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVl9DSEFOR0UsIHRoaXMubGlzdGVuZXJDaGFuZ2UpO1xuXG4gICAgaWYgKCF0aGlzLmdldENvbmZpZyhDT05GSUdfVFJBQ0tfSU5QVVQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9nZ2VyJDEubG9nKCdJbml0aWFsaXppbmcgaW5wdXQgdHJhY2tpbmcnKTtcblxuICAgIHRoaXMubGlzdGVuZXJDaGFuZ2UgPSBmdW5jdGlvbihldikge1xuICAgICAgICBpZiAoIXRoaXMuZ2V0Q29uZmlnKENPTkZJR19UUkFDS19JTlBVVCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNrRG9tRXZlbnQoZXYsIE1QX0VWX0lOUFVUKTtcbiAgICB9LmJpbmQodGhpcyk7XG4gICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoRVZfQ0hBTkdFLCB0aGlzLmxpc3RlbmVyQ2hhbmdlKTtcbn07XG5cbkF1dG9jYXB0dXJlLnByb3RvdHlwZS5pbml0UGFnZXZpZXdUcmFja2luZyA9IGZ1bmN0aW9uKCkge1xuICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKEVWX01QX0xPQ0FUSU9OX0NIQU5HRSwgdGhpcy5saXN0ZW5lckxvY2F0aW9uY2hhbmdlKTtcblxuICAgIGlmICghdGhpcy5wYWdldmlld1RyYWNraW5nQ29uZmlnKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsb2dnZXIkMS5sb2coJ0luaXRpYWxpemluZyBwYWdldmlldyB0cmFja2luZycpO1xuXG4gICAgdmFyIHByZXZpb3VzVHJhY2tlZFVybCA9ICcnO1xuICAgIHZhciB0cmFja2VkID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnRVcmxCbG9ja2VkKCkpIHtcbiAgICAgICAgdHJhY2tlZCA9IHRoaXMubXAudHJhY2tfcGFnZXZpZXcoREVGQVVMVF9QUk9QUyk7XG4gICAgfVxuICAgIGlmICh0cmFja2VkKSB7XG4gICAgICAgIHByZXZpb3VzVHJhY2tlZFVybCA9IF8uaW5mby5jdXJyZW50VXJsKCk7XG4gICAgfVxuXG4gICAgdGhpcy5saXN0ZW5lckxvY2F0aW9uY2hhbmdlID0gc2FmZXdyYXAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRVcmxCbG9ja2VkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdXJyZW50VXJsID0gXy5pbmZvLmN1cnJlbnRVcmwoKTtcbiAgICAgICAgdmFyIHNob3VsZFRyYWNrID0gZmFsc2U7XG4gICAgICAgIHZhciBkaWRQYXRoQ2hhbmdlID0gY3VycmVudFVybC5zcGxpdCgnIycpWzBdLnNwbGl0KCc/JylbMF0gIT09IHByZXZpb3VzVHJhY2tlZFVybC5zcGxpdCgnIycpWzBdLnNwbGl0KCc/JylbMF07XG4gICAgICAgIHZhciB0cmFja1BhZ2V2aWV3T3B0aW9uID0gdGhpcy5wYWdldmlld1RyYWNraW5nQ29uZmlnKCk7XG4gICAgICAgIGlmICh0cmFja1BhZ2V2aWV3T3B0aW9uID09PSBQQUdFVklFV19PUFRJT05fRlVMTF9VUkwpIHtcbiAgICAgICAgICAgIHNob3VsZFRyYWNrID0gY3VycmVudFVybCAhPT0gcHJldmlvdXNUcmFja2VkVXJsO1xuICAgICAgICB9IGVsc2UgaWYgKHRyYWNrUGFnZXZpZXdPcHRpb24gPT09IFBBR0VWSUVXX09QVElPTl9VUkxfV0lUSF9QQVRIX0FORF9RVUVSWV9TVFJJTkcpIHtcbiAgICAgICAgICAgIHNob3VsZFRyYWNrID0gY3VycmVudFVybC5zcGxpdCgnIycpWzBdICE9PSBwcmV2aW91c1RyYWNrZWRVcmwuc3BsaXQoJyMnKVswXTtcbiAgICAgICAgfSBlbHNlIGlmICh0cmFja1BhZ2V2aWV3T3B0aW9uID09PSBQQUdFVklFV19PUFRJT05fVVJMX1dJVEhfUEFUSCkge1xuICAgICAgICAgICAgc2hvdWxkVHJhY2sgPSBkaWRQYXRoQ2hhbmdlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3VsZFRyYWNrKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2tlZCA9IHRoaXMubXAudHJhY2tfcGFnZXZpZXcoREVGQVVMVF9QUk9QUyk7XG4gICAgICAgICAgICBpZiAodHJhY2tlZCkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzVHJhY2tlZFVybCA9IGN1cnJlbnRVcmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlkUGF0aENoYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdFNjcm9sbENoZWNrcG9pbnQgPSAwO1xuICAgICAgICAgICAgICAgIGxvZ2dlciQxLmxvZygnUGF0aCBjaGFuZ2U6IHJlLWluaXRpYWxpemluZyBzY3JvbGwgZGVwdGggY2hlY2twb2ludHMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSk7XG4gICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoRVZfTVBfTE9DQVRJT05fQ0hBTkdFLCB0aGlzLmxpc3RlbmVyTG9jYXRpb25jaGFuZ2UpO1xufTtcblxuQXV0b2NhcHR1cmUucHJvdG90eXBlLmluaXRSYWdlQ2xpY2tUcmFja2luZyA9IGZ1bmN0aW9uKCkge1xuICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKEVWX0NMSUNLLCB0aGlzLmxpc3RlbmVyUmFnZUNsaWNrKTtcblxuICAgIHZhciByYWdlQ2xpY2tDb25maWcgPSB0aGlzLl9nZXRDbGlja1RyYWNraW5nQ29uZmlnKENPTkZJR19UUkFDS19SQUdFX0NMSUNLKTtcbiAgICBpZiAoIXJhZ2VDbGlja0NvbmZpZyAmJiAhdGhpcy5tcC5nZXRfY29uZmlnKCdyZWNvcmRfaGVhdG1hcF9kYXRhJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxvZ2dlciQxLmxvZygnSW5pdGlhbGl6aW5nIHJhZ2UgY2xpY2sgdHJhY2tpbmcnKTtcbiAgICBpZiAoIXRoaXMuX3JhZ2VDbGlja1RyYWNrZXIpIHtcbiAgICAgICAgdGhpcy5fcmFnZUNsaWNrVHJhY2tlciA9IG5ldyBSYWdlQ2xpY2tUcmFja2VyKCk7XG4gICAgfVxuXG4gICAgdGhpcy5saXN0ZW5lclJhZ2VDbGljayA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIHZhciBjdXJyZW50UmFnZUNsaWNrQ29uZmlnID0gdGhpcy5fZ2V0Q2xpY2tUcmFja2luZ0NvbmZpZyhDT05GSUdfVFJBQ0tfUkFHRV9DTElDSyk7XG4gICAgICAgIGlmICghY3VycmVudFJhZ2VDbGlja0NvbmZpZyAmJiAhdGhpcy5tcC5pc19yZWNvcmRpbmdfaGVhdG1hcF9kYXRhKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRVcmxCbG9ja2VkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9yYWdlQ2xpY2tUcmFja2VyLmlzUmFnZUNsaWNrKGV2LCBjdXJyZW50UmFnZUNsaWNrQ29uZmlnKSkge1xuICAgICAgICAgICAgdGhpcy50cmFja0RvbUV2ZW50KGV2LCBNUF9FVl9SQUdFX0NMSUNLKTtcbiAgICAgICAgfVxuICAgIH0uYmluZCh0aGlzKTtcbiAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihFVl9DTElDSywgdGhpcy5saXN0ZW5lclJhZ2VDbGljayk7XG59O1xuXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUuaW5pdFNjcm9sbFRyYWNraW5nID0gZnVuY3Rpb24oKSB7XG4gICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZfU0NST0xMRU5ELCB0aGlzLmxpc3RlbmVyU2Nyb2xsKTtcbiAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVl9TQ1JPTEwsIHRoaXMubGlzdGVuZXJTY3JvbGwpO1xuXG5cbiAgICBpZiAoIXRoaXMuZ2V0Q29uZmlnKENPTkZJR19UUkFDS19TQ1JPTEwpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9nZ2VyJDEubG9nKCdJbml0aWFsaXppbmcgc2Nyb2xsIHRyYWNraW5nJyk7XG4gICAgdGhpcy5sYXN0U2Nyb2xsQ2hlY2twb2ludCA9IDA7XG5cbiAgICB2YXIgc2Nyb2xsVHJhY2tGdW5jdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuZ2V0Q29uZmlnKENPTkZJR19UUkFDS19TQ1JPTEwpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFVybEJsb2NrZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNob3VsZFRyYWNrID0gdGhpcy5nZXRDb25maWcoQ09ORklHX1NDUk9MTF9DQVBUVVJFX0FMTCk7XG4gICAgICAgIHZhciBzY3JvbGxDaGVja3BvaW50cyA9ICh0aGlzLmdldENvbmZpZyhDT05GSUdfU0NST0xMX0NIRUNLUE9JTlRTKSB8fCBbXSlcbiAgICAgICAgICAgIC5zbGljZSgpXG4gICAgICAgICAgICAuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XG5cbiAgICAgICAgdmFyIHNjcm9sbFRvcCA9IHdpbi5zY3JvbGxZO1xuICAgICAgICB2YXIgcHJvcHMgPSBfLmV4dGVuZCh7JyRzY3JvbGxfdG9wJzogc2Nyb2xsVG9wfSwgREVGQVVMVF9QUk9QUyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsSGVpZ2h0ID0gZG9jdW1lbnQkMS5ib2R5LnNjcm9sbEhlaWdodDtcbiAgICAgICAgICAgIHZhciBzY3JvbGxQZXJjZW50YWdlID0gTWF0aC5yb3VuZCgoc2Nyb2xsVG9wIC8gKHNjcm9sbEhlaWdodCAtIHdpbi5pbm5lckhlaWdodCkpICogMTAwKTtcbiAgICAgICAgICAgIHByb3BzWyckc2Nyb2xsX2hlaWdodCddID0gc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgICAgcHJvcHNbJyRzY3JvbGxfcGVyY2VudGFnZSddID0gc2Nyb2xsUGVyY2VudGFnZTtcbiAgICAgICAgICAgIGlmIChzY3JvbGxQZXJjZW50YWdlID4gdGhpcy5sYXN0U2Nyb2xsQ2hlY2twb2ludCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2Nyb2xsQ2hlY2twb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoZWNrcG9pbnQgPSBzY3JvbGxDaGVja3BvaW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsUGVyY2VudGFnZSA+PSBjaGVja3BvaW50ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RTY3JvbGxDaGVja3BvaW50IDwgY2hlY2twb2ludFxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzWyckc2Nyb2xsX2NoZWNrcG9pbnQnXSA9IGNoZWNrcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RTY3JvbGxDaGVja3BvaW50ID0gY2hlY2twb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFRyYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBsb2dnZXIkMS5jcml0aWNhbCgnRXJyb3Igd2hpbGUgY2FsY3VsYXRpbmcgc2Nyb2xsIHBlcmNlbnRhZ2UnLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRUcmFjaykge1xuICAgICAgICAgICAgdGhpcy5tcC50cmFjayhNUF9FVl9TQ1JPTEwsIHByb3BzKTtcbiAgICAgICAgfVxuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHZhciBzY3JvbGxFbmRQb2x5ZmlsbCA9IGdldFBvbHlmaWxsU2Nyb2xsRW5kRnVuY3Rpb24oc2Nyb2xsVHJhY2tGdW5jdGlvbik7XG4gICAgdGhpcy5saXN0ZW5lclNjcm9sbCA9IHNjcm9sbEVuZFBvbHlmaWxsLmxpc3RlbmVyO1xuICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKHNjcm9sbEVuZFBvbHlmaWxsLmV2ZW50VHlwZSwgdGhpcy5saXN0ZW5lclNjcm9sbCk7XG59O1xuXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUuaW5pdFN1Ym1pdFRyYWNraW5nID0gZnVuY3Rpb24oKSB7XG4gICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZfU1VCTUlULCB0aGlzLmxpc3RlbmVyU3VibWl0KTtcblxuICAgIGlmICghdGhpcy5nZXRDb25maWcoQ09ORklHX1RSQUNLX1NVQk1JVCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsb2dnZXIkMS5sb2coJ0luaXRpYWxpemluZyBzdWJtaXQgdHJhY2tpbmcnKTtcblxuICAgIHRoaXMubGlzdGVuZXJTdWJtaXQgPSBmdW5jdGlvbihldikge1xuICAgICAgICBpZiAoIXRoaXMuZ2V0Q29uZmlnKENPTkZJR19UUkFDS19TVUJNSVQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFja0RvbUV2ZW50KGV2LCBNUF9FVl9TVUJNSVQpO1xuICAgIH0uYmluZCh0aGlzKTtcbiAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihFVl9TVUJNSVQsIHRoaXMubGlzdGVuZXJTdWJtaXQpO1xufTtcblxuQXV0b2NhcHR1cmUucHJvdG90eXBlLmluaXRQYWdlTGVhdmVUcmFja2luZyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIENhcHR1cmUgcGFnZV9sZWF2ZSBib3RoIHdoZW4gdGhlIHVzZXIgbmF2aWdhdGVzIGF3YXkgZnJvbSB0aGUgcGFnZSAodmlzaWJpbGl0eWNoYW5nZSkgYXMgd2VsbFxuICAgIC8vIGFzIHdoZW4gdGhleSBuYXZpZ2F0ZSB0byBhIGRpZmZlcmVudCBwYWdlIHdpdGhpbiB0aGUgU1BBIChwb3BzdGF0ZS9wdXNoc3RhdGUvaGFzaGNoYW5nZSkuXG4gICAgZG9jdW1lbnQkMS5yZW1vdmVFdmVudExpc3RlbmVyKEVWX1ZJU0lCSUxJVFlDSEFOR0UsIHRoaXMubGlzdGVuZXJQYWdlTGVhdmVWaXNpYmlsaXR5Y2hhbmdlKTtcbiAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVl9NUF9MT0NBVElPTl9DSEFOR0UsIHRoaXMubGlzdGVuZXJQYWdlTGVhdmVMb2NhdGlvbmNoYW5nZSk7XG4gICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZfTE9BRCwgdGhpcy5saXN0ZW5lclBhZ2VMb2FkKTtcblxuICAgIGlmICghdGhpcy5nZXRDb25maWcoQ09ORklHX1RSQUNLX1BBR0VfTEVBVkUpICYmICF0aGlzLm1wLmdldF9jb25maWcoJ3JlY29yZF9oZWF0bWFwX2RhdGEnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbG9nZ2VyJDEubG9nKCdJbml0aWFsaXppbmcgcGFnZSB2aXNpYmlsaXR5IHRyYWNraW5nLicpO1xuICAgIHRoaXMuX2luaXRTY3JvbGxEZXB0aFRyYWNraW5nKCk7XG4gICAgdmFyIHByZXZpb3VzVHJhY2tlZFVybCA9IF8uaW5mby5jdXJyZW50VXJsKCk7XG5cbiAgICAvLyBJbml0aWFsaXplIHByZXZpb3VzU2Nyb2xsSGVpZ2h0IG9uIGBsb2FkYCB3aGljaCBoYW5kbGVzIGFzeW5jIGxvYWRpbmdcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L2xvYWRfZXZlbnRcbiAgICB0aGlzLmxpc3RlbmVyUGFnZUxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5wcmV2aW91c1Njcm9sbEhlaWdodCA9IGRvY3VtZW50JDEuYm9keS5zY3JvbGxIZWlnaHQ7XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKEVWX0xPQUQsIHRoaXMubGlzdGVuZXJQYWdlTG9hZCk7XG5cbiAgICAvLyBUcmFjayBwYWdlIG5hdmlnYXRpb24gZXZlbnRzIHNpbWlsYXIgdG8gaG93IGluaXRQYWdldmlld1RyYWNraW5nIGRvZXMgaXRcbiAgICB0aGlzLmxpc3RlbmVyUGFnZUxlYXZlTG9jYXRpb25jaGFuZ2UgPSBzYWZld3JhcChmdW5jdGlvbihldikge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50VXJsQmxvY2tlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3VycmVudFVybCA9IF8uaW5mby5jdXJyZW50VXJsKCk7XG4gICAgICAgIC8vIFRyYWNrIGFsbCBVUkwgY2hhbmdlcyBpbmNsdWRpbmcgcXVlcnkgc3RyaW5nIG9yIGZyYWdtZW50IGNoYW5nZXMgYXMgc2VwYXJhdGUgc2Nyb2xsIHNlc3Npb25zXG4gICAgICAgIHZhciBzaG91bGRUcmFjayA9IGN1cnJlbnRVcmwgIT09IHByZXZpb3VzVHJhY2tlZFVybDtcblxuICAgICAgICBpZiAoc2hvdWxkVHJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrUGFnZUxlYXZlKGV2LCBwcmV2aW91c1RyYWNrZWRVcmwsIHRoaXMucHJldmlvdXNTY3JvbGxIZWlnaHQpO1xuICAgICAgICAgICAgcHJldmlvdXNUcmFja2VkVXJsID0gY3VycmVudFVybDtcbiAgICAgICAgICAgIC8vIEZyYWdtZW50IG5hdmlnYXRpb24gc2hvdWxkIGNhbGwgc2Nyb2xsKGVuZCkgYW5kIHRyaWdnZXIgbGlzdGVuZXIsIGRvbid0IGFkZCB3aW5kb3cuc2Nyb2xsWSBoZXJlLlxuICAgICAgICAgICAgdGhpcy5tYXhTY3JvbGxWaWV3RGVwdGggPSBNYXRoLm1heChkb2N1bWVudCQxLmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQsIHdpbi5pbm5lckhlaWdodCB8fCAwKTtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNTY3JvbGxIZWlnaHQgPSBkb2N1bWVudCQxLmJvZHkuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5oYXNUcmFja2VkU2Nyb2xsU2Vzc2lvbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihFVl9NUF9MT0NBVElPTl9DSEFOR0UsIHRoaXMubGlzdGVuZXJQYWdlTGVhdmVMb2NhdGlvbmNoYW5nZSk7XG5cbiAgICB0aGlzLmxpc3RlbmVyUGFnZUxlYXZlVmlzaWJpbGl0eWNoYW5nZSA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGlmIChkb2N1bWVudCQxLmhpZGRlbikge1xuICAgICAgICAgICAgdGhpcy5fdHJhY2tQYWdlTGVhdmUoZXYsIHByZXZpb3VzVHJhY2tlZFVybCwgdGhpcy5wcmV2aW91c1Njcm9sbEhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9LmJpbmQodGhpcyk7XG4gICAgZG9jdW1lbnQkMS5hZGRFdmVudExpc3RlbmVyKEVWX1ZJU0lCSUxJVFlDSEFOR0UsIHRoaXMubGlzdGVuZXJQYWdlTGVhdmVWaXNpYmlsaXR5Y2hhbmdlKTtcbn07XG5cbkF1dG9jYXB0dXJlLnByb3RvdHlwZS5zdG9wRGVhZENsaWNrVHJhY2tpbmcgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5saXN0ZW5lckRlYWRDbGljaykge1xuICAgICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVl9DTElDSywgdGhpcy5saXN0ZW5lckRlYWRDbGljayk7XG4gICAgICAgIHRoaXMubGlzdGVuZXJEZWFkQ2xpY2sgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9kZWFkQ2xpY2tUcmFja2VyKSB7XG4gICAgICAgIHRoaXMuX2RlYWRDbGlja1RyYWNrZXIuc3RvcFRyYWNraW5nKCk7XG4gICAgICAgIHRoaXMuX2RlYWRDbGlja1RyYWNrZXIgPSBudWxsO1xuICAgIH1cbn07XG5cbi8vIFRPRE8gaW50ZWdyYXRlIGVycm9yX3JlcG9ydGVyIGZyb20gbWl4cGFuZWwgaW5zdGFuY2VcbnNhZmV3cmFwQ2xhc3MoQXV0b2NhcHR1cmUpO1xuXG52YXIgbG9nZ2VyID0gY29uc29sZV93aXRoX3ByZWZpeCgnZmxhZ3MnKTtcblxudmFyIEZMQUdTX0NPTkZJR19LRVkgPSAnZmxhZ3MnO1xuXG52YXIgQ09ORklHX0NPTlRFWFQgPSAnY29udGV4dCc7XG52YXIgQ09ORklHX0RFRkFVTFRTID0ge307XG5DT05GSUdfREVGQVVMVFNbQ09ORklHX0NPTlRFWFRdID0ge307XG5cbi8qKlxuICogRmVhdHVyZUZsYWdNYW5hZ2VyOiBzdXBwb3J0IGZvciBNaXhwYW5lbCdzIGZlYXR1cmUgZmxhZ2dpbmcgcHJvZHVjdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBGZWF0dXJlRmxhZ01hbmFnZXIgPSBmdW5jdGlvbihpbml0T3B0aW9ucykge1xuICAgIHRoaXMuZmV0Y2ggPSB3aW5bJ2ZldGNoJ107XG4gICAgdGhpcy5nZXRGdWxsQXBpUm91dGUgPSBpbml0T3B0aW9ucy5nZXRGdWxsQXBpUm91dGU7XG4gICAgdGhpcy5nZXRNcENvbmZpZyA9IGluaXRPcHRpb25zLmdldENvbmZpZ0Z1bmM7XG4gICAgdGhpcy5zZXRNcENvbmZpZyA9IGluaXRPcHRpb25zLnNldENvbmZpZ0Z1bmM7XG4gICAgdGhpcy5nZXRNcFByb3BlcnR5ID0gaW5pdE9wdGlvbnMuZ2V0UHJvcGVydHlGdW5jO1xuICAgIHRoaXMudHJhY2sgPSBpbml0T3B0aW9ucy50cmFja2luZ0Z1bmM7XG59O1xuXG5GZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMubWluQXBpc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgIGxvZ2dlci5jcml0aWNhbCgnRmVhdHVyZSBGbGFncyB1bmF2YWlsYWJsZTogbWlzc2luZyBtaW5pbXVtIHJlcXVpcmVkIEFQSXMnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSBudWxsO1xuICAgIHRoaXMuZmV0Y2hGbGFncygpO1xuXG4gICAgdGhpcy50cmFja2VkRmVhdHVyZXMgPSBuZXcgU2V0KCk7XG59O1xuXG5GZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlLmdldEZ1bGxDb25maWcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZmZDb25maWcgPSB0aGlzLmdldE1wQ29uZmlnKEZMQUdTX0NPTkZJR19LRVkpO1xuICAgIGlmICghZmZDb25maWcpIHtcbiAgICAgICAgLy8gZmxhZ3MgYXJlIGNvbXBsZXRlbHkgb2ZmXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QoZmZDb25maWcpKSB7XG4gICAgICAgIHJldHVybiBfLmV4dGVuZCh7fSwgQ09ORklHX0RFRkFVTFRTLCBmZkNvbmZpZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29uZmlnIGlzIG5vbi1vYmplY3QgdHJ1dGh5IHZhbHVlLCByZXR1cm4gZGVmYXVsdFxuICAgICAgICByZXR1cm4gQ09ORklHX0RFRkFVTFRTO1xuICAgIH1cbn07XG5cbkZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RnVsbENvbmZpZygpW2tleV07XG59O1xuXG5GZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlLmlzU3lzdGVtRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhIXRoaXMuZ2V0TXBDb25maWcoRkxBR1NfQ09ORklHX0tFWSk7XG59O1xuXG5GZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihuZXdDb250ZXh0LCBvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmlzU3lzdGVtRW5hYmxlZCgpKSB7XG4gICAgICAgIGxvZ2dlci5jcml0aWNhbCgnRmVhdHVyZSBGbGFncyBub3QgZW5hYmxlZCwgY2Fubm90IHVwZGF0ZSBjb250ZXh0Jyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICB2YXIgZmZDb25maWcgPSB0aGlzLmdldE1wQ29uZmlnKEZMQUdTX0NPTkZJR19LRVkpO1xuICAgIGlmICghXy5pc09iamVjdChmZkNvbmZpZykpIHtcbiAgICAgICAgZmZDb25maWcgPSB7fTtcbiAgICB9XG4gICAgdmFyIG9sZENvbnRleHQgPSAob3B0aW9ucyAmJiBvcHRpb25zWydyZXBsYWNlJ10pID8ge30gOiB0aGlzLmdldENvbmZpZyhDT05GSUdfQ09OVEVYVCk7XG4gICAgZmZDb25maWdbQ09ORklHX0NPTlRFWFRdID0gXy5leHRlbmQoe30sIG9sZENvbnRleHQsIG5ld0NvbnRleHQpO1xuXG4gICAgdGhpcy5zZXRNcENvbmZpZyhGTEFHU19DT05GSUdfS0VZLCBmZkNvbmZpZyk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hGbGFncygpO1xufTtcblxuRmVhdHVyZUZsYWdNYW5hZ2VyLnByb3RvdHlwZS5hcmVGbGFnc1JlYWR5ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmlzU3lzdGVtRW5hYmxlZCgpKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcignRmVhdHVyZSBGbGFncyBub3QgZW5hYmxlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gISF0aGlzLmZsYWdzO1xufTtcblxuRmVhdHVyZUZsYWdNYW5hZ2VyLnByb3RvdHlwZS5mZXRjaEZsYWdzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmlzU3lzdGVtRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICB2YXIgZGlzdGluY3RJZCA9IHRoaXMuZ2V0TXBQcm9wZXJ0eSgnZGlzdGluY3RfaWQnKTtcbiAgICB2YXIgZGV2aWNlSWQgPSB0aGlzLmdldE1wUHJvcGVydHkoJyRkZXZpY2VfaWQnKTtcbiAgICB2YXIgdHJhY2VwYXJlbnQgPSBnZW5lcmF0ZVRyYWNlcGFyZW50KCk7XG4gICAgbG9nZ2VyLmxvZygnRmV0Y2hpbmcgZmxhZ3MgZm9yIGRpc3RpbmN0IElEOiAnICsgZGlzdGluY3RJZCk7XG5cbiAgICB2YXIgY29udGV4dCA9IF8uZXh0ZW5kKHsnZGlzdGluY3RfaWQnOiBkaXN0aW5jdElkLCAnZGV2aWNlX2lkJzogZGV2aWNlSWR9LCB0aGlzLmdldENvbmZpZyhDT05GSUdfQ09OVEVYVCkpO1xuICAgIHZhciBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgc2VhcmNoUGFyYW1zLnNldCgnY29udGV4dCcsIEpTT04uc3RyaW5naWZ5KGNvbnRleHQpKTtcbiAgICBzZWFyY2hQYXJhbXMuc2V0KCd0b2tlbicsIHRoaXMuZ2V0TXBDb25maWcoJ3Rva2VuJykpO1xuICAgIHNlYXJjaFBhcmFtcy5zZXQoJ21wX2xpYicsICd3ZWInKTtcbiAgICBzZWFyY2hQYXJhbXMuc2V0KCckbGliX3ZlcnNpb24nLCBDb25maWcuTElCX1ZFUlNJT04pO1xuICAgIHZhciB1cmwgPSB0aGlzLmdldEZ1bGxBcGlSb3V0ZSgpICsgJz8nICsgc2VhcmNoUGFyYW1zLnRvU3RyaW5nKCk7XG5cbiAgICB0aGlzLl9mZXRjaEluUHJvZ3Jlc3NTdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuZmV0Y2hQcm9taXNlID0gdGhpcy5mZXRjaC5jYWxsKHdpbiwgdXJsLCB7XG4gICAgICAgICdtZXRob2QnOiAnR0VUJyxcbiAgICAgICAgJ2hlYWRlcnMnOiB7XG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6ICdCYXNpYyAnICsgYnRvYSh0aGlzLmdldE1wQ29uZmlnKCd0b2tlbicpICsgJzonKSxcbiAgICAgICAgICAgICd0cmFjZXBhcmVudCc6IHRyYWNlcGFyZW50XG4gICAgICAgIH1cbiAgICB9KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIHRoaXMubWFya0ZldGNoQ29tcGxldGUoKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlQm9keSkge1xuICAgICAgICAgICAgdmFyIHJlc3BvbnNlRmxhZ3MgPSByZXNwb25zZUJvZHlbJ2ZsYWdzJ107XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlRmxhZ3MpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGZsYWdzIGluIEFQSSByZXNwb25zZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZsYWdzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgXy5lYWNoKHJlc3BvbnNlRmxhZ3MsIGZ1bmN0aW9uKGRhdGEsIGtleSkge1xuICAgICAgICAgICAgICAgIGZsYWdzLnNldChrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgJ2tleSc6IGRhdGFbJ3ZhcmlhbnRfa2V5J10sXG4gICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IGRhdGFbJ3ZhcmlhbnRfdmFsdWUnXSxcbiAgICAgICAgICAgICAgICAgICAgJ2V4cGVyaW1lbnRfaWQnOiBkYXRhWydleHBlcmltZW50X2lkJ10sXG4gICAgICAgICAgICAgICAgICAgICdpc19leHBlcmltZW50X2FjdGl2ZSc6IGRhdGFbJ2lzX2V4cGVyaW1lbnRfYWN0aXZlJ10sXG4gICAgICAgICAgICAgICAgICAgICdpc19xYV90ZXN0ZXInOiBkYXRhWydpc19xYV90ZXN0ZXInXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgICAgICAgICB0aGlzLl90cmFjZXBhcmVudCA9IHRyYWNlcGFyZW50O1xuICAgICAgICB9LmJpbmQodGhpcykpLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLm1hcmtGZXRjaENvbXBsZXRlKCk7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0uYmluZCh0aGlzKSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgdGhpcy5tYXJrRmV0Y2hDb21wbGV0ZSgpO1xuICAgICAgICBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICByZXR1cm4gdGhpcy5mZXRjaFByb21pc2U7XG59O1xuXG5GZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlLm1hcmtGZXRjaENvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9mZXRjaEluUHJvZ3Jlc3NTdGFydFRpbWUpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdGZXRjaCBpbiBwcm9ncmVzcyBzdGFydGVkIHRpbWUgbm90IHNldCwgY2Fubm90IG1hcmsgZmV0Y2ggY29tcGxldGUnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9mZXRjaFN0YXJ0VGltZSA9IHRoaXMuX2ZldGNoSW5Qcm9ncmVzc1N0YXJ0VGltZTtcbiAgICB0aGlzLl9mZXRjaENvbXBsZXRlVGltZSA9IERhdGUubm93KCk7XG4gICAgdGhpcy5fZmV0Y2hMYXRlbmN5ID0gdGhpcy5fZmV0Y2hDb21wbGV0ZVRpbWUgLSB0aGlzLl9mZXRjaFN0YXJ0VGltZTtcbiAgICB0aGlzLl9mZXRjaEluUHJvZ3Jlc3NTdGFydFRpbWUgPSBudWxsO1xufTtcblxuRmVhdHVyZUZsYWdNYW5hZ2VyLnByb3RvdHlwZS5nZXRWYXJpYW50ID0gZnVuY3Rpb24oZmVhdHVyZU5hbWUsIGZhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLmZldGNoUHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgbG9nZ2VyLmNyaXRpY2FsKCdGZWF0dXJlIEZsYWdzIG5vdCBpbml0aWFsaXplZCcpO1xuICAgICAgICAgICAgcmVzb2x2ZShmYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZldGNoUHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRWYXJpYW50U3luYyhmZWF0dXJlTmFtZSwgZmFsbGJhY2spO1xuICAgIH0uYmluZCh0aGlzKSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgIH0pO1xufTtcblxuRmVhdHVyZUZsYWdNYW5hZ2VyLnByb3RvdHlwZS5nZXRWYXJpYW50U3luYyA9IGZ1bmN0aW9uKGZlYXR1cmVOYW1lLCBmYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5hcmVGbGFnc1JlYWR5KCkpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnRmxhZ3Mgbm90IGxvYWRlZCB5ZXQnKTtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgIH1cbiAgICB2YXIgZmVhdHVyZSA9IHRoaXMuZmxhZ3MuZ2V0KGZlYXR1cmVOYW1lKTtcbiAgICBpZiAoIWZlYXR1cmUpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnTm8gZmxhZyBmb3VuZDogXCInICsgZmVhdHVyZU5hbWUgKyAnXCInKTtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgIH1cbiAgICB0aGlzLnRyYWNrRmVhdHVyZUNoZWNrKGZlYXR1cmVOYW1lLCBmZWF0dXJlKTtcbiAgICByZXR1cm4gZmVhdHVyZTtcbn07XG5cbkZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGUuZ2V0VmFyaWFudFZhbHVlID0gZnVuY3Rpb24oZmVhdHVyZU5hbWUsIGZhbGxiYWNrVmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRWYXJpYW50KGZlYXR1cmVOYW1lLCB7J3ZhbHVlJzogZmFsbGJhY2tWYWx1ZX0pLnRoZW4oZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgICByZXR1cm4gZmVhdHVyZVsndmFsdWUnXTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tWYWx1ZTtcbiAgICB9KTtcbn07XG5cbi8vIFRPRE8gcmVtb3ZlIGRlcHJlY2F0ZWQgbWV0aG9kXG5GZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlLmdldEZlYXR1cmVEYXRhID0gZnVuY3Rpb24oZmVhdHVyZU5hbWUsIGZhbGxiYWNrVmFsdWUpIHtcbiAgICBsb2dnZXIuY3JpdGljYWwoJ21peHBhbmVsLmZsYWdzLmdldF9mZWF0dXJlX2RhdGEoKSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS4gVXNlIG1peHBhbmVsLmZsYWdzLmdldF92YXJpYW50X3ZhbHVlKCkgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gdGhpcy5nZXRWYXJpYW50VmFsdWUoZmVhdHVyZU5hbWUsIGZhbGxiYWNrVmFsdWUpO1xufTtcblxuRmVhdHVyZUZsYWdNYW5hZ2VyLnByb3RvdHlwZS5nZXRWYXJpYW50VmFsdWVTeW5jID0gZnVuY3Rpb24oZmVhdHVyZU5hbWUsIGZhbGxiYWNrVmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRWYXJpYW50U3luYyhmZWF0dXJlTmFtZSwgeyd2YWx1ZSc6IGZhbGxiYWNrVmFsdWV9KVsndmFsdWUnXTtcbn07XG5cbkZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGUuaXNFbmFibGVkID0gZnVuY3Rpb24oZmVhdHVyZU5hbWUsIGZhbGxiYWNrVmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRWYXJpYW50VmFsdWUoZmVhdHVyZU5hbWUpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRW5hYmxlZFN5bmMoZmVhdHVyZU5hbWUsIGZhbGxiYWNrVmFsdWUpO1xuICAgIH0uYmluZCh0aGlzKSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrVmFsdWU7XG4gICAgfSk7XG59O1xuXG5GZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlLmlzRW5hYmxlZFN5bmMgPSBmdW5jdGlvbihmZWF0dXJlTmFtZSwgZmFsbGJhY2tWYWx1ZSkge1xuICAgIGZhbGxiYWNrVmFsdWUgPSBmYWxsYmFja1ZhbHVlIHx8IGZhbHNlO1xuICAgIHZhciB2YWwgPSB0aGlzLmdldFZhcmlhbnRWYWx1ZVN5bmMoZmVhdHVyZU5hbWUsIGZhbGxiYWNrVmFsdWUpO1xuICAgIGlmICh2YWwgIT09IHRydWUgJiYgdmFsICE9PSBmYWxzZSkge1xuICAgICAgICBsb2dnZXIuZXJyb3IoJ0ZlYXR1cmUgZmxhZyBcIicgKyBmZWF0dXJlTmFtZSArICdcIiB2YWx1ZTogJyArIHZhbCArICcgaXMgbm90IGEgYm9vbGVhbjsgcmV0dXJuaW5nIGZhbGxiYWNrIHZhbHVlOiAnICsgZmFsbGJhY2tWYWx1ZSk7XG4gICAgICAgIHZhbCA9IGZhbGxiYWNrVmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59O1xuXG5GZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlLnRyYWNrRmVhdHVyZUNoZWNrID0gZnVuY3Rpb24oZmVhdHVyZU5hbWUsIGZlYXR1cmUpIHtcbiAgICBpZiAodGhpcy50cmFja2VkRmVhdHVyZXMuaGFzKGZlYXR1cmVOYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudHJhY2tlZEZlYXR1cmVzLmFkZChmZWF0dXJlTmFtZSk7XG5cbiAgICB2YXIgdHJhY2tpbmdQcm9wZXJ0aWVzID0ge1xuICAgICAgICAnRXhwZXJpbWVudCBuYW1lJzogZmVhdHVyZU5hbWUsXG4gICAgICAgICdWYXJpYW50IG5hbWUnOiBmZWF0dXJlWydrZXknXSxcbiAgICAgICAgJyRleHBlcmltZW50X3R5cGUnOiAnZmVhdHVyZV9mbGFnJyxcbiAgICAgICAgJ1ZhcmlhbnQgZmV0Y2ggc3RhcnQgdGltZSc6IG5ldyBEYXRlKHRoaXMuX2ZldGNoU3RhcnRUaW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICAnVmFyaWFudCBmZXRjaCBjb21wbGV0ZSB0aW1lJzogbmV3IERhdGUodGhpcy5fZmV0Y2hDb21wbGV0ZVRpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICdWYXJpYW50IGZldGNoIGxhdGVuY3kgKG1zKSc6IHRoaXMuX2ZldGNoTGF0ZW5jeSxcbiAgICAgICAgJ1ZhcmlhbnQgZmV0Y2ggdHJhY2VwYXJlbnQnOiB0aGlzLl90cmFjZXBhcmVudCxcbiAgICB9O1xuXG4gICAgaWYgKGZlYXR1cmVbJ2V4cGVyaW1lbnRfaWQnXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdHJhY2tpbmdQcm9wZXJ0aWVzWyckZXhwZXJpbWVudF9pZCddID0gZmVhdHVyZVsnZXhwZXJpbWVudF9pZCddO1xuICAgIH1cbiAgICBpZiAoZmVhdHVyZVsnaXNfZXhwZXJpbWVudF9hY3RpdmUnXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdHJhY2tpbmdQcm9wZXJ0aWVzWyckaXNfZXhwZXJpbWVudF9hY3RpdmUnXSA9IGZlYXR1cmVbJ2lzX2V4cGVyaW1lbnRfYWN0aXZlJ107XG4gICAgfVxuICAgIGlmIChmZWF0dXJlWydpc19xYV90ZXN0ZXInXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdHJhY2tpbmdQcm9wZXJ0aWVzWyckaXNfcWFfdGVzdGVyJ10gPSBmZWF0dXJlWydpc19xYV90ZXN0ZXInXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyYWNrKCckZXhwZXJpbWVudF9zdGFydGVkJywgdHJhY2tpbmdQcm9wZXJ0aWVzKTtcbn07XG5cbkZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGUubWluQXBpc1N1cHBvcnRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhIXRoaXMuZmV0Y2ggJiZcbiAgICAgIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgdHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnO1xufTtcblxuc2FmZXdyYXBDbGFzcyhGZWF0dXJlRmxhZ01hbmFnZXIpO1xuXG5GZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlWydhcmVfZmxhZ3NfcmVhZHknXSA9IEZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGUuYXJlRmxhZ3NSZWFkeTtcbkZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGVbJ2dldF92YXJpYW50J10gPSBGZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlLmdldFZhcmlhbnQ7XG5GZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlWydnZXRfdmFyaWFudF9zeW5jJ10gPSBGZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlLmdldFZhcmlhbnRTeW5jO1xuRmVhdHVyZUZsYWdNYW5hZ2VyLnByb3RvdHlwZVsnZ2V0X3ZhcmlhbnRfdmFsdWUnXSA9IEZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGUuZ2V0VmFyaWFudFZhbHVlO1xuRmVhdHVyZUZsYWdNYW5hZ2VyLnByb3RvdHlwZVsnZ2V0X3ZhcmlhbnRfdmFsdWVfc3luYyddID0gRmVhdHVyZUZsYWdNYW5hZ2VyLnByb3RvdHlwZS5nZXRWYXJpYW50VmFsdWVTeW5jO1xuRmVhdHVyZUZsYWdNYW5hZ2VyLnByb3RvdHlwZVsnaXNfZW5hYmxlZCddID0gRmVhdHVyZUZsYWdNYW5hZ2VyLnByb3RvdHlwZS5pc0VuYWJsZWQ7XG5GZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlWydpc19lbmFibGVkX3N5bmMnXSA9IEZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGUuaXNFbmFibGVkU3luYztcbkZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGVbJ3VwZGF0ZV9jb250ZXh0J10gPSBGZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlLnVwZGF0ZUNvbnRleHQ7XG5cbi8vIERlcHJlY2F0ZWQgbWV0aG9kXG5GZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlWydnZXRfZmVhdHVyZV9kYXRhJ10gPSBGZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlLmdldEZlYXR1cmVEYXRhO1xuXG4vKiBlc2xpbnQgY2FtZWxjYXNlOiBcIm9mZlwiICovXG5cblxuLyoqXG4gKiBEb21UcmFja2VyIE9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEb21UcmFja2VyID0gZnVuY3Rpb24oKSB7fTtcblxuXG4vLyBpbnRlcmZhY2VcbkRvbVRyYWNrZXIucHJvdG90eXBlLmNyZWF0ZV9wcm9wZXJ0aWVzID0gZnVuY3Rpb24oKSB7fTtcbkRvbVRyYWNrZXIucHJvdG90eXBlLmV2ZW50X2hhbmRsZXIgPSBmdW5jdGlvbigpIHt9O1xuRG9tVHJhY2tlci5wcm90b3R5cGUuYWZ0ZXJfdHJhY2tfaGFuZGxlciA9IGZ1bmN0aW9uKCkge307XG5cbkRvbVRyYWNrZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihtaXhwYW5lbF9pbnN0YW5jZSkge1xuICAgIHRoaXMubXAgPSBtaXhwYW5lbF9pbnN0YW5jZTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBxdWVyeVxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50X25hbWVcbiAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllc1xuICogQHBhcmFtIHtmdW5jdGlvbj19IHVzZXJfY2FsbGJhY2tcbiAqL1xuRG9tVHJhY2tlci5wcm90b3R5cGUudHJhY2sgPSBmdW5jdGlvbihxdWVyeSwgZXZlbnRfbmFtZSwgcHJvcGVydGllcywgdXNlcl9jYWxsYmFjaykge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB2YXIgZWxlbWVudHMgPSBfLmRvbV9xdWVyeShxdWVyeSk7XG5cbiAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUkMS5lcnJvcignVGhlIERPTSBxdWVyeSAoJyArIHF1ZXJ5ICsgJykgcmV0dXJuZWQgMCBlbGVtZW50cycpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgXy5lYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIF8ucmVnaXN0ZXJfZXZlbnQoZWxlbWVudCwgdGhpcy5vdmVycmlkZV9ldmVudCwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IHRoYXQuY3JlYXRlX3Byb3BlcnRpZXMocHJvcGVydGllcywgdGhpcyk7XG4gICAgICAgICAgICB2YXIgdGltZW91dCA9IHRoYXQubXAuZ2V0X2NvbmZpZygndHJhY2tfbGlua3NfdGltZW91dCcpO1xuXG4gICAgICAgICAgICB0aGF0LmV2ZW50X2hhbmRsZXIoZSwgdGhpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlIG1peHBhbmVsIHNlcnZlcnMgZG9uJ3QgZ2V0IGJhY2sgdG8gdXMgaW4gdGltZVxuICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQodGhhdC50cmFja19jYWxsYmFjayh1c2VyX2NhbGxiYWNrLCBwcm9wcywgb3B0aW9ucywgdHJ1ZSksIHRpbWVvdXQpO1xuXG4gICAgICAgICAgICAvLyBmaXJlIHRoZSB0cmFja2luZyBldmVudFxuICAgICAgICAgICAgdGhhdC5tcC50cmFjayhldmVudF9uYW1lLCBwcm9wcywgdGhhdC50cmFja19jYWxsYmFjayh1c2VyX2NhbGxiYWNrLCBwcm9wcywgb3B0aW9ucykpO1xuICAgICAgICB9KTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB1c2VyX2NhbGxiYWNrXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHRpbWVvdXRfb2NjdXJlZFxuICovXG5Eb21UcmFja2VyLnByb3RvdHlwZS50cmFja19jYWxsYmFjayA9IGZ1bmN0aW9uKHVzZXJfY2FsbGJhY2ssIHByb3BzLCBvcHRpb25zLCB0aW1lb3V0X29jY3VyZWQpIHtcbiAgICB0aW1lb3V0X29jY3VyZWQgPSB0aW1lb3V0X29jY3VyZWQgfHwgZmFsc2U7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBvcHRpb25zIGlzIHJlZmVyZW5jZWQgZnJvbSBib3RoIGNhbGxiYWNrcywgc28gd2UgY2FuIGhhdmVcbiAgICAgICAgLy8gYSAnbG9jaycgb2Ygc29ydHMgdG8gZW5zdXJlIG9ubHkgb25lIGZpcmVzXG4gICAgICAgIGlmIChvcHRpb25zLmNhbGxiYWNrX2ZpcmVkKSB7IHJldHVybjsgfVxuICAgICAgICBvcHRpb25zLmNhbGxiYWNrX2ZpcmVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAodXNlcl9jYWxsYmFjayAmJiB1c2VyX2NhbGxiYWNrKHRpbWVvdXRfb2NjdXJlZCwgcHJvcHMpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gdXNlciBjYW4gcHJldmVudCB0aGUgZGVmYXVsdCBmdW5jdGlvbmFsaXR5IGJ5XG4gICAgICAgICAgICAvLyByZXR1cm5pbmcgZmFsc2UgZnJvbSB0aGVpciBjYWxsYmFja1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhhdC5hZnRlcl90cmFja19oYW5kbGVyKHByb3BzLCBvcHRpb25zLCB0aW1lb3V0X29jY3VyZWQpO1xuICAgIH07XG59O1xuXG5Eb21UcmFja2VyLnByb3RvdHlwZS5jcmVhdGVfcHJvcGVydGllcyA9IGZ1bmN0aW9uKHByb3BlcnRpZXMsIGVsZW1lbnQpIHtcbiAgICB2YXIgcHJvcHM7XG5cbiAgICBpZiAodHlwZW9mKHByb3BlcnRpZXMpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByb3BzID0gcHJvcGVydGllcyhlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wcyA9IF8uZXh0ZW5kKHt9LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcHM7XG59O1xuXG4vKipcbiAqIExpbmtUcmFja2VyIE9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBEb21UcmFja2VyXG4gKi9cbnZhciBMaW5rVHJhY2tlciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMub3ZlcnJpZGVfZXZlbnQgPSAnY2xpY2snO1xufTtcbl8uaW5oZXJpdChMaW5rVHJhY2tlciwgRG9tVHJhY2tlcik7XG5cbkxpbmtUcmFja2VyLnByb3RvdHlwZS5jcmVhdGVfcHJvcGVydGllcyA9IGZ1bmN0aW9uKHByb3BlcnRpZXMsIGVsZW1lbnQpIHtcbiAgICB2YXIgcHJvcHMgPSBMaW5rVHJhY2tlci5zdXBlcmNsYXNzLmNyZWF0ZV9wcm9wZXJ0aWVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBpZiAoZWxlbWVudC5ocmVmKSB7IHByb3BzWyd1cmwnXSA9IGVsZW1lbnQuaHJlZjsgfVxuXG4gICAgcmV0dXJuIHByb3BzO1xufTtcblxuTGlua1RyYWNrZXIucHJvdG90eXBlLmV2ZW50X2hhbmRsZXIgPSBmdW5jdGlvbihldnQsIGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLm5ld190YWIgPSAoXG4gICAgICAgIGV2dC53aGljaCA9PT0gMiB8fFxuICAgICAgICBldnQubWV0YUtleSB8fFxuICAgICAgICBldnQuY3RybEtleSB8fFxuICAgICAgICBlbGVtZW50LnRhcmdldCA9PT0gJ19ibGFuaydcbiAgICApO1xuICAgIG9wdGlvbnMuaHJlZiA9IGVsZW1lbnQuaHJlZjtcblxuICAgIGlmICghb3B0aW9ucy5uZXdfdGFiKSB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn07XG5cbkxpbmtUcmFja2VyLnByb3RvdHlwZS5hZnRlcl90cmFja19oYW5kbGVyID0gZnVuY3Rpb24ocHJvcHMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5uZXdfdGFiKSB7IHJldHVybjsgfVxuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uID0gb3B0aW9ucy5ocmVmO1xuICAgIH0sIDApO1xufTtcblxuLyoqXG4gKiBGb3JtVHJhY2tlciBPYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRG9tVHJhY2tlclxuICovXG52YXIgRm9ybVRyYWNrZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm92ZXJyaWRlX2V2ZW50ID0gJ3N1Ym1pdCc7XG59O1xuXy5pbmhlcml0KEZvcm1UcmFja2VyLCBEb21UcmFja2VyKTtcblxuRm9ybVRyYWNrZXIucHJvdG90eXBlLmV2ZW50X2hhbmRsZXIgPSBmdW5jdGlvbihldnQsIGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xufTtcblxuRm9ybVRyYWNrZXIucHJvdG90eXBlLmFmdGVyX3RyYWNrX2hhbmRsZXIgPSBmdW5jdGlvbihwcm9wcywgb3B0aW9ucykge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIG9wdGlvbnMuZWxlbWVudC5zdWJtaXQoKTtcbiAgICB9LCAwKTtcbn07XG5cbi8qIGVzbGludCBjYW1lbGNhc2U6IFwib2ZmXCIgKi9cblxuXG4vKiogQGNvbnN0ICovIHZhciBTRVRfQUNUSU9OICAgICAgPSAnJHNldCc7XG4vKiogQGNvbnN0ICovIHZhciBTRVRfT05DRV9BQ1RJT04gPSAnJHNldF9vbmNlJztcbi8qKiBAY29uc3QgKi8gdmFyIFVOU0VUX0FDVElPTiAgICA9ICckdW5zZXQnO1xuLyoqIEBjb25zdCAqLyB2YXIgQUREX0FDVElPTiAgICAgID0gJyRhZGQnO1xuLyoqIEBjb25zdCAqLyB2YXIgQVBQRU5EX0FDVElPTiAgID0gJyRhcHBlbmQnO1xuLyoqIEBjb25zdCAqLyB2YXIgVU5JT05fQUNUSU9OICAgID0gJyR1bmlvbic7XG4vKiogQGNvbnN0ICovIHZhciBSRU1PVkVfQUNUSU9OICAgPSAnJHJlbW92ZSc7XG4vKiogQGNvbnN0ICovIHZhciBERUxFVEVfQUNUSU9OICAgPSAnJGRlbGV0ZSc7XG5cbi8vIENvbW1vbiBpbnRlcm5hbCBtZXRob2RzIGZvciBtaXhwYW5lbC5wZW9wbGUgYW5kIG1peHBhbmVsLmdyb3VwIEFQSXMuXG4vLyBUaGVzZSBtZXRob2RzIHNob3VsZG4ndCBpbnZvbHZlIG5ldHdvcmsgSS9PLlxudmFyIGFwaUFjdGlvbnMgPSB7XG4gICAgc2V0X2FjdGlvbjogZnVuY3Rpb24ocHJvcCwgdG8pIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgdmFyICRzZXQgPSB7fTtcbiAgICAgICAgaWYgKF8uaXNPYmplY3QocHJvcCkpIHtcbiAgICAgICAgICAgIF8uZWFjaChwcm9wLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc19yZXNlcnZlZF9wcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICAkc2V0W2tdID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRzZXRbcHJvcF0gPSB0bztcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGFbU0VUX0FDVElPTl0gPSAkc2V0O1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgdW5zZXRfYWN0aW9uOiBmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgIHZhciAkdW5zZXQgPSBbXTtcbiAgICAgICAgaWYgKCFfLmlzQXJyYXkocHJvcCkpIHtcbiAgICAgICAgICAgIHByb3AgPSBbcHJvcF07XG4gICAgICAgIH1cblxuICAgICAgICBfLmVhY2gocHJvcCwgZnVuY3Rpb24oaykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc19yZXNlcnZlZF9wcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICR1bnNldC5wdXNoKGspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBkYXRhW1VOU0VUX0FDVElPTl0gPSAkdW5zZXQ7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICBzZXRfb25jZV9hY3Rpb246IGZ1bmN0aW9uKHByb3AsIHRvKSB7XG4gICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgIHZhciAkc2V0X29uY2UgPSB7fTtcbiAgICAgICAgaWYgKF8uaXNPYmplY3QocHJvcCkpIHtcbiAgICAgICAgICAgIF8uZWFjaChwcm9wLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc19yZXNlcnZlZF9wcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICAkc2V0X29uY2Vba10gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHNldF9vbmNlW3Byb3BdID0gdG87XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtTRVRfT05DRV9BQ1RJT05dID0gJHNldF9vbmNlO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgdW5pb25fYWN0aW9uOiBmdW5jdGlvbihsaXN0X25hbWUsIHZhbHVlcykge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICB2YXIgJHVuaW9uID0ge307XG4gICAgICAgIGlmIChfLmlzT2JqZWN0KGxpc3RfbmFtZSkpIHtcbiAgICAgICAgICAgIF8uZWFjaChsaXN0X25hbWUsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzX3Jlc2VydmVkX3Byb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgICAgICR1bmlvbltrXSA9IF8uaXNBcnJheSh2KSA/IHYgOiBbdl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkdW5pb25bbGlzdF9uYW1lXSA9IF8uaXNBcnJheSh2YWx1ZXMpID8gdmFsdWVzIDogW3ZhbHVlc107XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtVTklPTl9BQ1RJT05dID0gJHVuaW9uO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgYXBwZW5kX2FjdGlvbjogZnVuY3Rpb24obGlzdF9uYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICB2YXIgJGFwcGVuZCA9IHt9O1xuICAgICAgICBpZiAoXy5pc09iamVjdChsaXN0X25hbWUpKSB7XG4gICAgICAgICAgICBfLmVhY2gobGlzdF9uYW1lLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc19yZXNlcnZlZF9wcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICAkYXBwZW5kW2tdID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRhcHBlbmRbbGlzdF9uYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbQVBQRU5EX0FDVElPTl0gPSAkYXBwZW5kO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlX2FjdGlvbjogZnVuY3Rpb24obGlzdF9uYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICB2YXIgJHJlbW92ZSA9IHt9O1xuICAgICAgICBpZiAoXy5pc09iamVjdChsaXN0X25hbWUpKSB7XG4gICAgICAgICAgICBfLmVhY2gobGlzdF9uYW1lLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc19yZXNlcnZlZF9wcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICAkcmVtb3ZlW2tdID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRyZW1vdmVbbGlzdF9uYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbUkVNT1ZFX0FDVElPTl0gPSAkcmVtb3ZlO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgZGVsZXRlX2FjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgIGRhdGFbREVMRVRFX0FDVElPTl0gPSAnJztcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxufTtcblxuLyogZXNsaW50IGNhbWVsY2FzZTogXCJvZmZcIiAqL1xuXG4vKipcbiAqIE1peHBhbmVsIEdyb3VwIE9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBNaXhwYW5lbEdyb3VwID0gZnVuY3Rpb24oKSB7fTtcblxuXy5leHRlbmQoTWl4cGFuZWxHcm91cC5wcm90b3R5cGUsIGFwaUFjdGlvbnMpO1xuXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKG1peHBhbmVsX2luc3RhbmNlLCBncm91cF9rZXksIGdyb3VwX2lkKSB7XG4gICAgdGhpcy5fbWl4cGFuZWwgPSBtaXhwYW5lbF9pbnN0YW5jZTtcbiAgICB0aGlzLl9ncm91cF9rZXkgPSBncm91cF9rZXk7XG4gICAgdGhpcy5fZ3JvdXBfaWQgPSBncm91cF9pZDtcbn07XG5cbi8qKlxuICogU2V0IHByb3BlcnRpZXMgb24gYSBncm91cC5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIG1peHBhbmVsLmdldF9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpLnNldCgnTG9jYXRpb24nLCAnNDA1IEhvd2FyZCcpO1xuICpcbiAqICAgICAvLyBvciBzZXQgbXVsdGlwbGUgcHJvcGVydGllcyBhdCBvbmNlXG4gKiAgICAgbWl4cGFuZWwuZ2V0X2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJykuc2V0KHtcbiAqICAgICAgICAgICdMb2NhdGlvbic6ICc0MDUgSG93YXJkJyxcbiAqICAgICAgICAgICdGb3VuZGVkJyA6IDIwMDksXG4gKiAgICAgfSk7XG4gKiAgICAgLy8gcHJvcGVydGllcyBjYW4gYmUgc3RyaW5ncywgaW50ZWdlcnMsIGRhdGVzLCBvciBsaXN0c1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcHJvcCBJZiBhIHN0cmluZywgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuIElmIGFuIG9iamVjdCwgdGhpcyBpcyBhbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBuYW1lcyBhbmQgdmFsdWVzLlxuICogQHBhcmFtIHsqfSBbdG9dIEEgdmFsdWUgdG8gc2V0IG9uIHRoZSBnaXZlbiBwcm9wZXJ0eSBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIHRyYWNraW5nIGV2ZW50XG4gKi9cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLnNldCA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxHcm91cChmdW5jdGlvbihwcm9wLCB0bywgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuc2V0X2FjdGlvbihwcm9wLCB0byk7XG4gICAgaWYgKF8uaXNPYmplY3QocHJvcCkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSB0bztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLyoqXG4gKiBTZXQgcHJvcGVydGllcyBvbiBhIGdyb3VwLCBvbmx5IGlmIHRoZXkgZG8gbm90IHlldCBleGlzdC5cbiAqIFRoaXMgd2lsbCBub3Qgb3ZlcndyaXRlIHByZXZpb3VzIGdyb3VwIHByb3BlcnR5IHZhbHVlcywgdW5saWtlXG4gKiBncm91cC5zZXQoKS5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIG1peHBhbmVsLmdldF9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpLnNldF9vbmNlKCdMb2NhdGlvbicsICc0MDUgSG93YXJkJyk7XG4gKlxuICogICAgIC8vIG9yIHNldCBtdWx0aXBsZSBwcm9wZXJ0aWVzIGF0IG9uY2VcbiAqICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKS5zZXRfb25jZSh7XG4gKiAgICAgICAgICAnTG9jYXRpb24nOiAnNDA1IEhvd2FyZCcsXG4gKiAgICAgICAgICAnRm91bmRlZCcgOiAyMDA5LFxuICogICAgIH0pO1xuICogICAgIC8vIHByb3BlcnRpZXMgY2FuIGJlIHN0cmluZ3MsIGludGVnZXJzLCBsaXN0cyBvciBkYXRlc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcHJvcCBJZiBhIHN0cmluZywgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuIElmIGFuIG9iamVjdCwgdGhpcyBpcyBhbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBuYW1lcyBhbmQgdmFsdWVzLlxuICogQHBhcmFtIHsqfSBbdG9dIEEgdmFsdWUgdG8gc2V0IG9uIHRoZSBnaXZlbiBwcm9wZXJ0eSBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIHRyYWNraW5nIGV2ZW50XG4gKi9cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLnNldF9vbmNlID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbEdyb3VwKGZ1bmN0aW9uKHByb3AsIHRvLCBjYWxsYmFjaykge1xuICAgIHZhciBkYXRhID0gdGhpcy5zZXRfb25jZV9hY3Rpb24ocHJvcCwgdG8pO1xuICAgIGlmIChfLmlzT2JqZWN0KHByb3ApKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdG87XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qKlxuICogVW5zZXQgcHJvcGVydGllcyBvbiBhIGdyb3VwIHBlcm1hbmVudGx5LlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgbWl4cGFuZWwuZ2V0X2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJykudW5zZXQoJ0ZvdW5kZWQnKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIHRyYWNraW5nIGV2ZW50XG4gKi9cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLnVuc2V0ID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbEdyb3VwKGZ1bmN0aW9uKHByb3AsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnVuc2V0X2FjdGlvbihwcm9wKTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKipcbiAqIE1lcmdlIGEgZ2l2ZW4gbGlzdCB3aXRoIGEgbGlzdC12YWx1ZWQgZ3JvdXAgcHJvcGVydHksIGV4Y2x1ZGluZyBkdXBsaWNhdGUgdmFsdWVzLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gbWVyZ2UgYSB2YWx1ZSB0byBhIGxpc3QsIGNyZWF0aW5nIGl0IGlmIG5lZWRlZFxuICogICAgIG1peHBhbmVsLmdldF9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpLnVuaW9uKCdMb2NhdGlvbicsIFsnU2FuIEZyYW5jaXNjbycsICdMb25kb24nXSk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGxpc3RfbmFtZSBOYW1lIG9mIHRoZSBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBWYWx1ZXMgdG8gbWVyZ2Ugd2l0aCB0aGUgZ2l2ZW4gcHJvcGVydHlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgdHJhY2tpbmcgZXZlbnRcbiAqL1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUudW5pb24gPSBhZGRPcHRPdXRDaGVja01peHBhbmVsR3JvdXAoZnVuY3Rpb24obGlzdF9uYW1lLCB2YWx1ZXMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKF8uaXNPYmplY3QobGlzdF9uYW1lKSkge1xuICAgICAgICBjYWxsYmFjayA9IHZhbHVlcztcbiAgICB9XG4gICAgdmFyIGRhdGEgPSB0aGlzLnVuaW9uX2FjdGlvbihsaXN0X25hbWUsIHZhbHVlcyk7XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLyoqXG4gKiBQZXJtYW5lbnRseSBkZWxldGUgYSBncm91cC5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIG1peHBhbmVsLmdldF9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpLmRlbGV0ZSgpO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgdHJhY2tpbmcgZXZlbnRcbiAqL1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbEdyb3VwKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgLy8gYnJhY2tldCBub3RhdGlvbiBhYm92ZSBwcmV2ZW50cyBhIG1pbmlmaWNhdGlvbiBlcnJvciByZWxhdGVkIHRvIHJlc2VydmVkIHdvcmRzXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRlbGV0ZV9hY3Rpb24oKTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKipcbiAqIFJlbW92ZSBhIHByb3BlcnR5IGZyb20gYSBncm91cC4gVGhlIHZhbHVlIHdpbGwgYmUgaWdub3JlZCBpZiBkb2Vzbid0IGV4aXN0LlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgbWl4cGFuZWwuZ2V0X2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJykucmVtb3ZlKCdMb2NhdGlvbicsICdMb25kb24nKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbGlzdF9uYW1lIE5hbWUgb2YgdGhlIHByb3BlcnR5LlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIFZhbHVlIHRvIHJlbW92ZSBmcm9tIHRoZSBnaXZlbiBncm91cCBwcm9wZXJ0eVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSB0cmFja2luZyBldmVudFxuICovXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS5yZW1vdmUgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsR3JvdXAoZnVuY3Rpb24obGlzdF9uYW1lLCB2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMucmVtb3ZlX2FjdGlvbihsaXN0X25hbWUsIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS5fc2VuZF9yZXF1ZXN0ID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcbiAgICBkYXRhWyckZ3JvdXBfa2V5J10gPSB0aGlzLl9ncm91cF9rZXk7XG4gICAgZGF0YVsnJGdyb3VwX2lkJ10gPSB0aGlzLl9ncm91cF9pZDtcbiAgICBkYXRhWyckdG9rZW4nXSA9IHRoaXMuX2dldF9jb25maWcoJ3Rva2VuJyk7XG5cbiAgICB2YXIgZGF0ZV9lbmNvZGVkX2RhdGEgPSBfLmVuY29kZURhdGVzKGRhdGEpO1xuICAgIHJldHVybiB0aGlzLl9taXhwYW5lbC5fdHJhY2tfb3JfYmF0Y2goe1xuICAgICAgICB0eXBlOiAnZ3JvdXBzJyxcbiAgICAgICAgZGF0YTogZGF0ZV9lbmNvZGVkX2RhdGEsXG4gICAgICAgIGVuZHBvaW50OiB0aGlzLl9taXhwYW5lbC5nZXRfYXBpX2hvc3QoJ2dyb3VwcycpICsgJy8nICsgIHRoaXMuX2dldF9jb25maWcoJ2FwaV9yb3V0ZXMnKVsnZ3JvdXBzJ10sXG4gICAgICAgIGJhdGNoZXI6IHRoaXMuX21peHBhbmVsLnJlcXVlc3RfYmF0Y2hlcnMuZ3JvdXBzXG4gICAgfSwgY2FsbGJhY2spO1xufTtcblxuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUuX2lzX3Jlc2VydmVkX3Byb3BlcnR5ID0gZnVuY3Rpb24ocHJvcCkge1xuICAgIHJldHVybiBwcm9wID09PSAnJGdyb3VwX2tleScgfHwgcHJvcCA9PT0gJyRncm91cF9pZCc7XG59O1xuXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS5fZ2V0X2NvbmZpZyA9IGZ1bmN0aW9uKGNvbmYpIHtcbiAgICByZXR1cm4gdGhpcy5fbWl4cGFuZWwuZ2V0X2NvbmZpZyhjb25mKTtcbn07XG5cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21peHBhbmVsLnRvU3RyaW5nKCkgKyAnLmdyb3VwLicgKyB0aGlzLl9ncm91cF9rZXkgKyAnLicgKyB0aGlzLl9ncm91cF9pZDtcbn07XG5cbi8vIE1peHBhbmVsR3JvdXAgRXhwb3J0c1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGVbJ3JlbW92ZSddICAgPSBNaXhwYW5lbEdyb3VwLnByb3RvdHlwZS5yZW1vdmU7XG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZVsnc2V0J10gICAgICA9IE1peHBhbmVsR3JvdXAucHJvdG90eXBlLnNldDtcbk1peHBhbmVsR3JvdXAucHJvdG90eXBlWydzZXRfb25jZSddID0gTWl4cGFuZWxHcm91cC5wcm90b3R5cGUuc2V0X29uY2U7XG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZVsndW5pb24nXSAgICA9IE1peHBhbmVsR3JvdXAucHJvdG90eXBlLnVuaW9uO1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGVbJ3Vuc2V0J10gICAgPSBNaXhwYW5lbEdyb3VwLnByb3RvdHlwZS51bnNldDtcbk1peHBhbmVsR3JvdXAucHJvdG90eXBlWyd0b1N0cmluZyddID0gTWl4cGFuZWxHcm91cC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qIGVzbGludCBjYW1lbGNhc2U6IFwib2ZmXCIgKi9cblxuLyoqXG4gKiBNaXhwYW5lbCBQZW9wbGUgT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE1peHBhbmVsUGVvcGxlID0gZnVuY3Rpb24oKSB7fTtcblxuXy5leHRlbmQoTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLCBhcGlBY3Rpb25zKTtcblxuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24obWl4cGFuZWxfaW5zdGFuY2UpIHtcbiAgICB0aGlzLl9taXhwYW5lbCA9IG1peHBhbmVsX2luc3RhbmNlO1xufTtcblxuLypcbiogU2V0IHByb3BlcnRpZXMgb24gYSB1c2VyIHJlY29yZC5cbipcbiogIyMjIFVzYWdlOlxuKlxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnNldCgnZ2VuZGVyJywgJ20nKTtcbipcbiogICAgIC8vIG9yIHNldCBtdWx0aXBsZSBwcm9wZXJ0aWVzIGF0IG9uY2VcbiogICAgIG1peHBhbmVsLnBlb3BsZS5zZXQoe1xuKiAgICAgICAgICdDb21wYW55JzogJ0FjbWUnLFxuKiAgICAgICAgICdQbGFuJzogJ1ByZW1pdW0nLFxuKiAgICAgICAgICdVcGdyYWRlIGRhdGUnOiBuZXcgRGF0ZSgpXG4qICAgICB9KTtcbiogICAgIC8vIHByb3BlcnRpZXMgY2FuIGJlIHN0cmluZ3MsIGludGVnZXJzLCBkYXRlcywgb3IgbGlzdHNcbipcbiogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBwcm9wIElmIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS4gSWYgYW4gb2JqZWN0LCB0aGlzIGlzIGFuIGFzc29jaWF0aXZlIGFycmF5IG9mIG5hbWVzIGFuZCB2YWx1ZXMuXG4qIEBwYXJhbSB7Kn0gW3RvXSBBIHZhbHVlIHRvIHNldCBvbiB0aGUgZ2l2ZW4gcHJvcGVydHkgbmFtZVxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5zZXQgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsUGVvcGxlKGZ1bmN0aW9uKHByb3AsIHRvLCBjYWxsYmFjaykge1xuICAgIHZhciBkYXRhID0gdGhpcy5zZXRfYWN0aW9uKHByb3AsIHRvKTtcbiAgICBpZiAoXy5pc09iamVjdChwcm9wKSkge1xuICAgICAgICBjYWxsYmFjayA9IHRvO1xuICAgIH1cbiAgICAvLyBtYWtlIHN1cmUgdGhhdCB0aGUgcmVmZXJyZXIgaW5mbyBoYXMgYmVlbiB1cGRhdGVkIGFuZCBzYXZlZFxuICAgIGlmICh0aGlzLl9nZXRfY29uZmlnKCdzYXZlX3JlZmVycmVyJykpIHtcbiAgICAgICAgdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10udXBkYXRlX3JlZmVycmVyX2luZm8oZG9jdW1lbnQucmVmZXJyZXIpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSAkc2V0IG9iamVjdCB3aXRoIGRlZmF1bHQgcGVvcGxlIHByb3BlcnRpZXNcbiAgICBkYXRhW1NFVF9BQ1RJT05dID0gXy5leHRlbmQoXG4gICAgICAgIHt9LFxuICAgICAgICBfLmluZm8ucGVvcGxlX3Byb3BlcnRpZXMoKSxcbiAgICAgICAgZGF0YVtTRVRfQUNUSU9OXVxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLypcbiogU2V0IHByb3BlcnRpZXMgb24gYSB1c2VyIHJlY29yZCwgb25seSBpZiB0aGV5IGRvIG5vdCB5ZXQgZXhpc3QuXG4qIFRoaXMgd2lsbCBub3Qgb3ZlcndyaXRlIHByZXZpb3VzIHBlb3BsZSBwcm9wZXJ0eSB2YWx1ZXMsIHVubGlrZVxuKiBwZW9wbGUuc2V0KCkuXG4qXG4qICMjIyBVc2FnZTpcbipcbiogICAgIG1peHBhbmVsLnBlb3BsZS5zZXRfb25jZSgnRmlyc3QgTG9naW4gRGF0ZScsIG5ldyBEYXRlKCkpO1xuKlxuKiAgICAgLy8gb3Igc2V0IG11bHRpcGxlIHByb3BlcnRpZXMgYXQgb25jZVxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnNldF9vbmNlKHtcbiogICAgICAgICAnRmlyc3QgTG9naW4gRGF0ZSc6IG5ldyBEYXRlKCksXG4qICAgICAgICAgJ1N0YXJ0aW5nIFBsYW4nOiAnUHJlbWl1bSdcbiogICAgIH0pO1xuKlxuKiAgICAgLy8gcHJvcGVydGllcyBjYW4gYmUgc3RyaW5ncywgaW50ZWdlcnMgb3IgZGF0ZXNcbipcbiogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBwcm9wIElmIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS4gSWYgYW4gb2JqZWN0LCB0aGlzIGlzIGFuIGFzc29jaWF0aXZlIGFycmF5IG9mIG5hbWVzIGFuZCB2YWx1ZXMuXG4qIEBwYXJhbSB7Kn0gW3RvXSBBIHZhbHVlIHRvIHNldCBvbiB0aGUgZ2l2ZW4gcHJvcGVydHkgbmFtZVxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5zZXRfb25jZSA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUoZnVuY3Rpb24ocHJvcCwgdG8sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnNldF9vbmNlX2FjdGlvbihwcm9wLCB0byk7XG4gICAgaWYgKF8uaXNPYmplY3QocHJvcCkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSB0bztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLypcbiogVW5zZXQgcHJvcGVydGllcyBvbiBhIHVzZXIgcmVjb3JkIChwZXJtYW5lbnRseSByZW1vdmVzIHRoZSBwcm9wZXJ0aWVzIGFuZCB0aGVpciB2YWx1ZXMgZnJvbSBhIHByb2ZpbGUpLlxuKlxuKiAjIyMgVXNhZ2U6XG4qXG4qICAgICBtaXhwYW5lbC5wZW9wbGUudW5zZXQoJ2dlbmRlcicpO1xuKlxuKiAgICAgLy8gb3IgdW5zZXQgbXVsdGlwbGUgcHJvcGVydGllcyBhdCBvbmNlXG4qICAgICBtaXhwYW5lbC5wZW9wbGUudW5zZXQoWydnZW5kZXInLCAnQ29tcGFueSddKTtcbipcbiogQHBhcmFtIHtBcnJheXxTdHJpbmd9IHByb3AgSWYgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBJZiBhbiBhcnJheSwgdGhpcyBpcyBhIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMuXG4qIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4qL1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnVuc2V0ID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbFBlb3BsZShmdW5jdGlvbihwcm9wLCBjYWxsYmFjaykge1xuICAgIHZhciBkYXRhID0gdGhpcy51bnNldF9hY3Rpb24ocHJvcCk7XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLypcbiogSW5jcmVtZW50L2RlY3JlbWVudCBudW1lcmljIHBlb3BsZSBhbmFseXRpY3MgcHJvcGVydGllcy5cbipcbiogIyMjIFVzYWdlOlxuKlxuKiAgICAgbWl4cGFuZWwucGVvcGxlLmluY3JlbWVudCgncGFnZV92aWV3cycsIDEpO1xuKlxuKiAgICAgLy8gb3IsIGZvciBjb252ZW5pZW5jZSwgaWYgeW91J3JlIGp1c3QgaW5jcmVtZW50aW5nIGEgY291bnRlciBieVxuKiAgICAgLy8gMSwgeW91IGNhbiBzaW1wbHkgZG9cbiogICAgIG1peHBhbmVsLnBlb3BsZS5pbmNyZW1lbnQoJ3BhZ2Vfdmlld3MnKTtcbipcbiogICAgIC8vIHRvIGRlY3JlbWVudCBhIGNvdW50ZXIsIHBhc3MgYSBuZWdhdGl2ZSBudW1iZXJcbiogICAgIG1peHBhbmVsLnBlb3BsZS5pbmNyZW1lbnQoJ2NyZWRpdHNfbGVmdCcsIC0xKTtcbipcbiogICAgIC8vIGxpa2UgbWl4cGFuZWwucGVvcGxlLnNldCgpLCB5b3UgY2FuIGluY3JlbWVudCBtdWx0aXBsZVxuKiAgICAgLy8gcHJvcGVydGllcyBhdCBvbmNlOlxuKiAgICAgbWl4cGFuZWwucGVvcGxlLmluY3JlbWVudCh7XG4qICAgICAgICAgY291bnRlcjE6IDEsXG4qICAgICAgICAgY291bnRlcjI6IDZcbiogICAgIH0pO1xuKlxuKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHByb3AgSWYgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBJZiBhbiBvYmplY3QsIHRoaXMgaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbmFtZXMgYW5kIG51bWVyaWMgdmFsdWVzLlxuKiBAcGFyYW0ge051bWJlcn0gW2J5XSBBbiBhbW91bnQgdG8gaW5jcmVtZW50IHRoZSBnaXZlbiBwcm9wZXJ0eVxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5pbmNyZW1lbnQgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsUGVvcGxlKGZ1bmN0aW9uKHByb3AsIGJ5LCBjYWxsYmFjaykge1xuICAgIHZhciBkYXRhID0ge307XG4gICAgdmFyICRhZGQgPSB7fTtcbiAgICBpZiAoXy5pc09iamVjdChwcm9wKSkge1xuICAgICAgICBfLmVhY2gocHJvcCwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc19yZXNlcnZlZF9wcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihwYXJzZUZsb2F0KHYpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlJDEuZXJyb3IoJ0ludmFsaWQgaW5jcmVtZW50IHZhbHVlIHBhc3NlZCB0byBtaXhwYW5lbC5wZW9wbGUuaW5jcmVtZW50IC0gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJGFkZFtrXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgY2FsbGJhY2sgPSBieTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb252ZW5pZW5jZTogbWl4cGFuZWwucGVvcGxlLmluY3JlbWVudCgncHJvcGVydHknKTsgd2lsbFxuICAgICAgICAvLyBpbmNyZW1lbnQgJ3Byb3BlcnR5JyBieSAxXG4gICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKGJ5KSkge1xuICAgICAgICAgICAgYnkgPSAxO1xuICAgICAgICB9XG4gICAgICAgICRhZGRbcHJvcF0gPSBieTtcbiAgICB9XG4gICAgZGF0YVtBRERfQUNUSU9OXSA9ICRhZGQ7XG5cbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKlxuKiBBcHBlbmQgYSB2YWx1ZSB0byBhIGxpc3QtdmFsdWVkIHBlb3BsZSBhbmFseXRpY3MgcHJvcGVydHkuXG4qXG4qICMjIyBVc2FnZTpcbipcbiogICAgIC8vIGFwcGVuZCBhIHZhbHVlIHRvIGEgbGlzdCwgY3JlYXRpbmcgaXQgaWYgbmVlZGVkXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuYXBwZW5kKCdwYWdlc192aXNpdGVkJywgJ2hvbWVwYWdlJyk7XG4qXG4qICAgICAvLyBsaWtlIG1peHBhbmVsLnBlb3BsZS5zZXQoKSwgeW91IGNhbiBhcHBlbmQgbXVsdGlwbGVcbiogICAgIC8vIHByb3BlcnRpZXMgYXQgb25jZTpcbiogICAgIG1peHBhbmVsLnBlb3BsZS5hcHBlbmQoe1xuKiAgICAgICAgIGxpc3QxOiAnYm9iJyxcbiogICAgICAgICBsaXN0MjogMTIzXG4qICAgICB9KTtcbipcbiogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsaXN0X25hbWUgSWYgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBJZiBhbiBvYmplY3QsIHRoaXMgaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbmFtZXMgYW5kIHZhbHVlcy5cbiogQHBhcmFtIHsqfSBbdmFsdWVdIHZhbHVlIEFuIGl0ZW0gdG8gYXBwZW5kIHRvIHRoZSBsaXN0XG4qIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4qL1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLmFwcGVuZCA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUoZnVuY3Rpb24obGlzdF9uYW1lLCB2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoXy5pc09iamVjdChsaXN0X25hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdmFsdWU7XG4gICAgfVxuICAgIHZhciBkYXRhID0gdGhpcy5hcHBlbmRfYWN0aW9uKGxpc3RfbmFtZSwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qXG4qIFJlbW92ZSBhIHZhbHVlIGZyb20gYSBsaXN0LXZhbHVlZCBwZW9wbGUgYW5hbHl0aWNzIHByb3BlcnR5LlxuKlxuKiAjIyMgVXNhZ2U6XG4qXG4qICAgICBtaXhwYW5lbC5wZW9wbGUucmVtb3ZlKCdTY2hvb2wnLCAnVUNCJyk7XG4qXG4qIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbGlzdF9uYW1lIElmIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS4gSWYgYW4gb2JqZWN0LCB0aGlzIGlzIGFuIGFzc29jaWF0aXZlIGFycmF5IG9mIG5hbWVzIGFuZCB2YWx1ZXMuXG4qIEBwYXJhbSB7Kn0gW3ZhbHVlXSB2YWx1ZSBJdGVtIHRvIHJlbW92ZSBmcm9tIHRoZSBsaXN0XG4qIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4qL1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnJlbW92ZSA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUoZnVuY3Rpb24obGlzdF9uYW1lLCB2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoXy5pc09iamVjdChsaXN0X25hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdmFsdWU7XG4gICAgfVxuICAgIHZhciBkYXRhID0gdGhpcy5yZW1vdmVfYWN0aW9uKGxpc3RfbmFtZSwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qXG4qIE1lcmdlIGEgZ2l2ZW4gbGlzdCB3aXRoIGEgbGlzdC12YWx1ZWQgcGVvcGxlIGFuYWx5dGljcyBwcm9wZXJ0eSxcbiogZXhjbHVkaW5nIGR1cGxpY2F0ZSB2YWx1ZXMuXG4qXG4qICMjIyBVc2FnZTpcbipcbiogICAgIC8vIG1lcmdlIGEgdmFsdWUgdG8gYSBsaXN0LCBjcmVhdGluZyBpdCBpZiBuZWVkZWRcbiogICAgIG1peHBhbmVsLnBlb3BsZS51bmlvbigncGFnZXNfdmlzaXRlZCcsICdob21lcGFnZScpO1xuKlxuKiAgICAgLy8gbGlrZSBtaXhwYW5lbC5wZW9wbGUuc2V0KCksIHlvdSBjYW4gYXBwZW5kIG11bHRpcGxlXG4qICAgICAvLyBwcm9wZXJ0aWVzIGF0IG9uY2U6XG4qICAgICBtaXhwYW5lbC5wZW9wbGUudW5pb24oe1xuKiAgICAgICAgIGxpc3QxOiAnYm9iJyxcbiogICAgICAgICBsaXN0MjogMTIzXG4qICAgICB9KTtcbipcbiogICAgIC8vIGxpa2UgbWl4cGFuZWwucGVvcGxlLmFwcGVuZCgpLCB5b3UgY2FuIGFwcGVuZCBtdWx0aXBsZVxuKiAgICAgLy8gdmFsdWVzIHRvIHRoZSBzYW1lIGxpc3Q6XG4qICAgICBtaXhwYW5lbC5wZW9wbGUudW5pb24oe1xuKiAgICAgICAgIGxpc3QxOiBbJ2JvYicsICdiaWxseSddXG4qICAgICB9KTtcbipcbiogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsaXN0X25hbWUgSWYgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBJZiBhbiBvYmplY3QsIHRoaXMgaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbmFtZXMgYW5kIHZhbHVlcy5cbiogQHBhcmFtIHsqfSBbdmFsdWVdIFZhbHVlIC8gdmFsdWVzIHRvIG1lcmdlIHdpdGggdGhlIGdpdmVuIHByb3BlcnR5XG4qIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4qL1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnVuaW9uID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbFBlb3BsZShmdW5jdGlvbihsaXN0X25hbWUsIHZhbHVlcywgY2FsbGJhY2spIHtcbiAgICBpZiAoXy5pc09iamVjdChsaXN0X25hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdmFsdWVzO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHRoaXMudW5pb25fYWN0aW9uKGxpc3RfbmFtZSwgdmFsdWVzKTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKlxuICogUmVjb3JkIHRoYXQgeW91IGhhdmUgY2hhcmdlZCB0aGUgY3VycmVudCB1c2VyIGEgY2VydGFpbiBhbW91bnRcbiAqIG9mIG1vbmV5LiBDaGFyZ2VzIHJlY29yZGVkIHdpdGggdHJhY2tfY2hhcmdlKCkgd2lsbCBhcHBlYXIgaW4gdGhlXG4gKiBNaXhwYW5lbCByZXZlbnVlIHJlcG9ydC5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIGNoYXJnZSBhIHVzZXIgJDUwXG4gKiAgICAgbWl4cGFuZWwucGVvcGxlLnRyYWNrX2NoYXJnZSg1MCk7XG4gKlxuICogICAgIC8vIGNoYXJnZSBhIHVzZXIgJDMwLjUwIG9uIHRoZSAybmQgb2YgamFudWFyeVxuICogICAgIG1peHBhbmVsLnBlb3BsZS50cmFja19jaGFyZ2UoMzAuNTAsIHtcbiAqICAgICAgICAgJyR0aW1lJzogbmV3IERhdGUoJ2phbiAxIDIwMTInKVxuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgVGhlIGFtb3VudCBvZiBtb25leSBjaGFyZ2VkIHRvIHRoZSBjdXJyZW50IHVzZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc10gQW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgcHJvcGVydGllcyBhc3NvY2lhdGVkIHdpdGggdGhlIGNoYXJnZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIHNlcnZlciByZXNwb25kc1xuICogQGRlcHJlY2F0ZWRcbiAqL1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnRyYWNrX2NoYXJnZSA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUoZnVuY3Rpb24oKSB7XG4gICAgY29uc29sZSQxLmVycm9yKCdtaXhwYW5lbC5wZW9wbGUudHJhY2tfY2hhcmdlKCkgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGhhcyBhbnkgZWZmZWN0LicpO1xufSk7XG5cbi8qXG4gKiBQZXJtYW5lbnRseSBjbGVhciBhbGwgcmV2ZW51ZSByZXBvcnQgdHJhbnNhY3Rpb25zIGZyb20gdGhlXG4gKiBjdXJyZW50IHVzZXIncyBwZW9wbGUgYW5hbHl0aWNzIHByb2ZpbGUuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICBtaXhwYW5lbC5wZW9wbGUuY2xlYXJfY2hhcmdlcygpO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4gKiBAZGVwcmVjYXRlZFxuICovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuY2xlYXJfY2hhcmdlcyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0KCckdHJhbnNhY3Rpb25zJywgW10sIGNhbGxiYWNrKTtcbn07XG5cbi8qXG4qIFBlcm1hbmVudGx5IGRlbGV0ZXMgdGhlIGN1cnJlbnQgcGVvcGxlIGFuYWx5dGljcyBwcm9maWxlIGZyb21cbiogTWl4cGFuZWwgKHVzaW5nIHRoZSBjdXJyZW50IGRpc3RpbmN0X2lkKS5cbipcbiogIyMjIFVzYWdlOlxuKlxuKiAgICAgLy8gcmVtb3ZlIHRoZSBhbGwgZGF0YSB5b3UgaGF2ZSBzdG9yZWQgYWJvdXQgdGhlIGN1cnJlbnQgdXNlclxuKiAgICAgbWl4cGFuZWwucGVvcGxlLmRlbGV0ZV91c2VyKCk7XG4qXG4qL1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLmRlbGV0ZV91c2VyID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9pZGVudGlmeV9jYWxsZWQoKSkge1xuICAgICAgICBjb25zb2xlJDEuZXJyb3IoJ21peHBhbmVsLnBlb3BsZS5kZWxldGVfdXNlcigpIHJlcXVpcmVzIHlvdSB0byBjYWxsIGlkZW50aWZ5KCkgZmlyc3QnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHsnJGRlbGV0ZSc6IHRoaXMuX21peHBhbmVsLmdldF9kaXN0aW5jdF9pZCgpfTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEpO1xufTtcblxuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21peHBhbmVsLnRvU3RyaW5nKCkgKyAnLnBlb3BsZSc7XG59O1xuXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuX3NlbmRfcmVxdWVzdCA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgZGF0YVsnJHRva2VuJ10gPSB0aGlzLl9nZXRfY29uZmlnKCd0b2tlbicpO1xuICAgIGRhdGFbJyRkaXN0aW5jdF9pZCddID0gdGhpcy5fbWl4cGFuZWwuZ2V0X2Rpc3RpbmN0X2lkKCk7XG4gICAgdmFyIGRldmljZV9pZCA9IHRoaXMuX21peHBhbmVsLmdldF9wcm9wZXJ0eSgnJGRldmljZV9pZCcpO1xuICAgIHZhciB1c2VyX2lkID0gdGhpcy5fbWl4cGFuZWwuZ2V0X3Byb3BlcnR5KCckdXNlcl9pZCcpO1xuICAgIHZhciBoYWRfcGVyc2lzdGVkX2Rpc3RpbmN0X2lkID0gdGhpcy5fbWl4cGFuZWwuZ2V0X3Byb3BlcnR5KCckaGFkX3BlcnNpc3RlZF9kaXN0aW5jdF9pZCcpO1xuICAgIGlmIChkZXZpY2VfaWQpIHtcbiAgICAgICAgZGF0YVsnJGRldmljZV9pZCddID0gZGV2aWNlX2lkO1xuICAgIH1cbiAgICBpZiAodXNlcl9pZCkge1xuICAgICAgICBkYXRhWyckdXNlcl9pZCddID0gdXNlcl9pZDtcbiAgICB9XG4gICAgaWYgKGhhZF9wZXJzaXN0ZWRfZGlzdGluY3RfaWQpIHtcbiAgICAgICAgZGF0YVsnJGhhZF9wZXJzaXN0ZWRfZGlzdGluY3RfaWQnXSA9IGhhZF9wZXJzaXN0ZWRfZGlzdGluY3RfaWQ7XG4gICAgfVxuXG4gICAgdmFyIGRhdGVfZW5jb2RlZF9kYXRhID0gXy5lbmNvZGVEYXRlcyhkYXRhKTtcblxuICAgIGlmICghdGhpcy5faWRlbnRpZnlfY2FsbGVkKCkpIHtcbiAgICAgICAgdGhpcy5fZW5xdWV1ZShkYXRhKTtcbiAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2dldF9jb25maWcoJ3ZlcmJvc2UnKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHtzdGF0dXM6IC0xLCBlcnJvcjogbnVsbH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF8udHJ1bmNhdGUoZGF0ZV9lbmNvZGVkX2RhdGEsIDI1NSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX21peHBhbmVsLl90cmFja19vcl9iYXRjaCh7XG4gICAgICAgIHR5cGU6ICdwZW9wbGUnLFxuICAgICAgICBkYXRhOiBkYXRlX2VuY29kZWRfZGF0YSxcbiAgICAgICAgZW5kcG9pbnQ6IHRoaXMuX21peHBhbmVsLmdldF9hcGlfaG9zdCgncGVvcGxlJykgKyAnLycgKyAgdGhpcy5fZ2V0X2NvbmZpZygnYXBpX3JvdXRlcycpWydlbmdhZ2UnXSxcbiAgICAgICAgYmF0Y2hlcjogdGhpcy5fbWl4cGFuZWwucmVxdWVzdF9iYXRjaGVycy5wZW9wbGVcbiAgICB9LCBjYWxsYmFjayk7XG59O1xuXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuX2dldF9jb25maWcgPSBmdW5jdGlvbihjb25mX3Zhcikge1xuICAgIHJldHVybiB0aGlzLl9taXhwYW5lbC5nZXRfY29uZmlnKGNvbmZfdmFyKTtcbn07XG5cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5faWRlbnRpZnlfY2FsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21peHBhbmVsLl9mbGFncy5pZGVudGlmeV9jYWxsZWQgPT09IHRydWU7XG59O1xuXG4vLyBRdWV1ZSB1cCBlbmdhZ2Ugb3BlcmF0aW9ucyBpZiBpZGVudGlmeSBoYXNuJ3QgYmVlbiBjYWxsZWQgeWV0LlxuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLl9lbnF1ZXVlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIGlmIChTRVRfQUNUSU9OIGluIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoU0VUX0FDVElPTiwgZGF0YSk7XG4gICAgfSBlbHNlIGlmIChTRVRfT05DRV9BQ1RJT04gaW4gZGF0YSkge1xuICAgICAgICB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fYWRkX3RvX3Blb3BsZV9xdWV1ZShTRVRfT05DRV9BQ1RJT04sIGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoVU5TRVRfQUNUSU9OIGluIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoVU5TRVRfQUNUSU9OLCBkYXRhKTtcbiAgICB9IGVsc2UgaWYgKEFERF9BQ1RJT04gaW4gZGF0YSkge1xuICAgICAgICB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fYWRkX3RvX3Blb3BsZV9xdWV1ZShBRERfQUNUSU9OLCBkYXRhKTtcbiAgICB9IGVsc2UgaWYgKEFQUEVORF9BQ1RJT04gaW4gZGF0YSkge1xuICAgICAgICB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fYWRkX3RvX3Blb3BsZV9xdWV1ZShBUFBFTkRfQUNUSU9OLCBkYXRhKTtcbiAgICB9IGVsc2UgaWYgKFJFTU9WRV9BQ1RJT04gaW4gZGF0YSkge1xuICAgICAgICB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fYWRkX3RvX3Blb3BsZV9xdWV1ZShSRU1PVkVfQUNUSU9OLCBkYXRhKTtcbiAgICB9IGVsc2UgaWYgKFVOSU9OX0FDVElPTiBpbiBkYXRhKSB7XG4gICAgICAgIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKFVOSU9OX0FDVElPTiwgZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZSQxLmVycm9yKCdJbnZhbGlkIGNhbGwgdG8gX2VucXVldWUoKTonLCBkYXRhKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuX2ZsdXNoX29uZV9xdWV1ZSA9IGZ1bmN0aW9uKGFjdGlvbiwgYWN0aW9uX21ldGhvZCwgY2FsbGJhY2ssIHF1ZXVlX3RvX3BhcmFtc19mbikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIHF1ZXVlZF9kYXRhID0gXy5leHRlbmQoe30sIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLmxvYWRfcXVldWUoYWN0aW9uKSk7XG4gICAgdmFyIGFjdGlvbl9wYXJhbXMgPSBxdWV1ZWRfZGF0YTtcblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChxdWV1ZWRfZGF0YSkgJiYgXy5pc09iamVjdChxdWV1ZWRfZGF0YSkgJiYgIV8uaXNFbXB0eU9iamVjdChxdWV1ZWRfZGF0YSkpIHtcbiAgICAgICAgX3RoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUoYWN0aW9uLCBxdWV1ZWRfZGF0YSk7XG4gICAgICAgIF90aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5zYXZlKCk7XG4gICAgICAgIGlmIChxdWV1ZV90b19wYXJhbXNfZm4pIHtcbiAgICAgICAgICAgIGFjdGlvbl9wYXJhbXMgPSBxdWV1ZV90b19wYXJhbXNfZm4ocXVldWVkX2RhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGFjdGlvbl9tZXRob2QuY2FsbChfdGhpcywgYWN0aW9uX3BhcmFtcywgZnVuY3Rpb24ocmVzcG9uc2UsIGRhdGEpIHtcbiAgICAgICAgICAgIC8vIG9uIGJhZCByZXNwb25zZSwgd2Ugd2FudCB0byBhZGQgaXQgYmFjayB0byB0aGUgcXVldWVcbiAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fYWRkX3RvX3Blb3BsZV9xdWV1ZShhY3Rpb24sIHF1ZXVlZF9kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChjYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZSwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8vIEZsdXNoIHF1ZXVlZCBlbmdhZ2Ugb3BlcmF0aW9ucyAtIG9yZGVyIGRvZXMgbm90IG1hdHRlcixcbi8vIGFuZCB0aGVyZSBhcmUgbmV0d29yayBsZXZlbCByYWNlIGNvbmRpdGlvbnMgYW55d2F5XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24oXG4gICAgX3NldF9jYWxsYmFjaywgX2FkZF9jYWxsYmFjaywgX2FwcGVuZF9jYWxsYmFjaywgX3NldF9vbmNlX2NhbGxiYWNrLCBfdW5pb25fY2FsbGJhY2ssIF91bnNldF9jYWxsYmFjaywgX3JlbW92ZV9jYWxsYmFja1xuKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuX2ZsdXNoX29uZV9xdWV1ZShTRVRfQUNUSU9OLCB0aGlzLnNldCwgX3NldF9jYWxsYmFjayk7XG4gICAgdGhpcy5fZmx1c2hfb25lX3F1ZXVlKFNFVF9PTkNFX0FDVElPTiwgdGhpcy5zZXRfb25jZSwgX3NldF9vbmNlX2NhbGxiYWNrKTtcbiAgICB0aGlzLl9mbHVzaF9vbmVfcXVldWUoVU5TRVRfQUNUSU9OLCB0aGlzLnVuc2V0LCBfdW5zZXRfY2FsbGJhY2ssIGZ1bmN0aW9uKHF1ZXVlKSB7IHJldHVybiBfLmtleXMocXVldWUpOyB9KTtcbiAgICB0aGlzLl9mbHVzaF9vbmVfcXVldWUoQUREX0FDVElPTiwgdGhpcy5pbmNyZW1lbnQsIF9hZGRfY2FsbGJhY2spO1xuICAgIHRoaXMuX2ZsdXNoX29uZV9xdWV1ZShVTklPTl9BQ1RJT04sIHRoaXMudW5pb24sIF91bmlvbl9jYWxsYmFjayk7XG5cbiAgICAvLyB3ZSBoYXZlIHRvIGZpcmUgb2ZmIGVhY2ggJGFwcGVuZCBpbmRpdmlkdWFsbHkgc2luY2UgdGhlcmUgaXNcbiAgICAvLyBubyBjb25jYXQgbWV0aG9kIHNlcnZlciBzaWRlXG4gICAgdmFyICRhcHBlbmRfcXVldWUgPSB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5sb2FkX3F1ZXVlKEFQUEVORF9BQ1RJT04pO1xuICAgIGlmICghXy5pc1VuZGVmaW5lZCgkYXBwZW5kX3F1ZXVlKSAmJiBfLmlzQXJyYXkoJGFwcGVuZF9xdWV1ZSkgJiYgJGFwcGVuZF9xdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyICRhcHBlbmRfaXRlbTtcbiAgICAgICAgdmFyIGFwcGVuZF9jYWxsYmFjayA9IGZ1bmN0aW9uKHJlc3BvbnNlLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UgPT09IDApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoQVBQRU5EX0FDVElPTiwgJGFwcGVuZF9pdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChfYXBwZW5kX2NhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgIF9hcHBlbmRfY2FsbGJhY2socmVzcG9uc2UsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBpID0gJGFwcGVuZF9xdWV1ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgJGFwcGVuZF9xdWV1ZSA9IHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLmxvYWRfcXVldWUoQVBQRU5EX0FDVElPTik7XG4gICAgICAgICAgICAkYXBwZW5kX2l0ZW0gPSAkYXBwZW5kX3F1ZXVlLnBvcCgpO1xuICAgICAgICAgICAgX3RoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLnNhdmUoKTtcbiAgICAgICAgICAgIGlmICghXy5pc0VtcHR5T2JqZWN0KCRhcHBlbmRfaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hcHBlbmQoJGFwcGVuZF9pdGVtLCBhcHBlbmRfY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2FtZSBmb3IgJHJlbW92ZVxuICAgIHZhciAkcmVtb3ZlX3F1ZXVlID0gdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10ubG9hZF9xdWV1ZShSRU1PVkVfQUNUSU9OKTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoJHJlbW92ZV9xdWV1ZSkgJiYgXy5pc0FycmF5KCRyZW1vdmVfcXVldWUpICYmICRyZW1vdmVfcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciAkcmVtb3ZlX2l0ZW07XG4gICAgICAgIHZhciByZW1vdmVfY2FsbGJhY2sgPSBmdW5jdGlvbihyZXNwb25zZSwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKFJFTU9WRV9BQ1RJT04sICRyZW1vdmVfaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQoX3JlbW92ZV9jYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICBfcmVtb3ZlX2NhbGxiYWNrKHJlc3BvbnNlLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgaiA9ICRyZW1vdmVfcXVldWUubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICRyZW1vdmVfcXVldWUgPSB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5sb2FkX3F1ZXVlKFJFTU9WRV9BQ1RJT04pO1xuICAgICAgICAgICAgJHJlbW92ZV9pdGVtID0gJHJlbW92ZV9xdWV1ZS5wb3AoKTtcbiAgICAgICAgICAgIF90aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5zYXZlKCk7XG4gICAgICAgICAgICBpZiAoIV8uaXNFbXB0eU9iamVjdCgkcmVtb3ZlX2l0ZW0pKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVtb3ZlKCRyZW1vdmVfaXRlbSwgcmVtb3ZlX2NhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5faXNfcmVzZXJ2ZWRfcHJvcGVydHkgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgcmV0dXJuIHByb3AgPT09ICckZGlzdGluY3RfaWQnIHx8IHByb3AgPT09ICckdG9rZW4nIHx8IHByb3AgPT09ICckZGV2aWNlX2lkJyB8fCBwcm9wID09PSAnJHVzZXJfaWQnIHx8IHByb3AgPT09ICckaGFkX3BlcnNpc3RlZF9kaXN0aW5jdF9pZCc7XG59O1xuXG4vLyBNaXhwYW5lbFBlb3BsZSBFeHBvcnRzXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ3NldCddICAgICAgICAgICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5zZXQ7XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ3NldF9vbmNlJ10gICAgICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5zZXRfb25jZTtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsndW5zZXQnXSAgICAgICAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnVuc2V0O1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWydpbmNyZW1lbnQnXSAgICAgPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuaW5jcmVtZW50O1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWydhcHBlbmQnXSAgICAgICAgPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuYXBwZW5kO1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWydyZW1vdmUnXSAgICAgICAgPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUucmVtb3ZlO1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWyd1bmlvbiddICAgICAgICAgPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUudW5pb247XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ3RyYWNrX2NoYXJnZSddICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS50cmFja19jaGFyZ2U7XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ2NsZWFyX2NoYXJnZXMnXSA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5jbGVhcl9jaGFyZ2VzO1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWydkZWxldGVfdXNlciddICAgPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuZGVsZXRlX3VzZXI7XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ3RvU3RyaW5nJ10gICAgICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS50b1N0cmluZztcblxuLyogZXNsaW50IGNhbWVsY2FzZTogXCJvZmZcIiAqL1xuXG5cbi8qXG4gKiBDb25zdGFudHNcbiAqL1xuLyoqIEBjb25zdCAqLyB2YXIgU0VUX1FVRVVFX0tFWSAgICAgICAgICA9ICdfX21wcyc7XG4vKiogQGNvbnN0ICovIHZhciBTRVRfT05DRV9RVUVVRV9LRVkgICAgID0gJ19fbXBzbyc7XG4vKiogQGNvbnN0ICovIHZhciBVTlNFVF9RVUVVRV9LRVkgICAgICAgID0gJ19fbXB1cyc7XG4vKiogQGNvbnN0ICovIHZhciBBRERfUVVFVUVfS0VZICAgICAgICAgID0gJ19fbXBhJztcbi8qKiBAY29uc3QgKi8gdmFyIEFQUEVORF9RVUVVRV9LRVkgICAgICAgPSAnX19tcGFwJztcbi8qKiBAY29uc3QgKi8gdmFyIFJFTU9WRV9RVUVVRV9LRVkgICAgICAgPSAnX19tcHInO1xuLyoqIEBjb25zdCAqLyB2YXIgVU5JT05fUVVFVUVfS0VZICAgICAgICA9ICdfX21wdSc7XG4vLyBUaGlzIGtleSBpcyBkZXByZWNhdGVkLCBidXQgd2Ugd2FudCB0byBjaGVjayBmb3IgaXQgdG8gc2VlIHdoZXRoZXIgYWxpYXNpbmcgaXMgYWxsb3dlZC5cbi8qKiBAY29uc3QgKi8gdmFyIFBFT1BMRV9ESVNUSU5DVF9JRF9LRVkgPSAnJHBlb3BsZV9kaXN0aW5jdF9pZCc7XG4vKiogQGNvbnN0ICovIHZhciBBTElBU19JRF9LRVkgICAgICAgICAgID0gJ19fYWxpYXMnO1xuLyoqIEBjb25zdCAqLyB2YXIgRVZFTlRfVElNRVJTX0tFWSAgICAgICA9ICdfX3RpbWVycyc7XG4vKiogQGNvbnN0ICovIHZhciBSRVNFUlZFRF9QUk9QRVJUSUVTID0gW1xuICAgIFNFVF9RVUVVRV9LRVksXG4gICAgU0VUX09OQ0VfUVVFVUVfS0VZLFxuICAgIFVOU0VUX1FVRVVFX0tFWSxcbiAgICBBRERfUVVFVUVfS0VZLFxuICAgIEFQUEVORF9RVUVVRV9LRVksXG4gICAgUkVNT1ZFX1FVRVVFX0tFWSxcbiAgICBVTklPTl9RVUVVRV9LRVksXG4gICAgUEVPUExFX0RJU1RJTkNUX0lEX0tFWSxcbiAgICBBTElBU19JRF9LRVksXG4gICAgRVZFTlRfVElNRVJTX0tFWVxuXTtcblxuLyoqXG4gKiBNaXhwYW5lbCBQZXJzaXN0ZW5jZSBPYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTWl4cGFuZWxQZXJzaXN0ZW5jZSA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXNbJ3Byb3BzJ10gPSB7fTtcbiAgICB0aGlzLmNhbXBhaWduX3BhcmFtc19zYXZlZCA9IGZhbHNlO1xuXG4gICAgaWYgKGNvbmZpZ1sncGVyc2lzdGVuY2VfbmFtZSddKSB7XG4gICAgICAgIHRoaXMubmFtZSA9ICdtcF8nICsgY29uZmlnWydwZXJzaXN0ZW5jZV9uYW1lJ107XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5uYW1lID0gJ21wXycgKyBjb25maWdbJ3Rva2VuJ10gKyAnX21peHBhbmVsJztcbiAgICB9XG5cbiAgICB2YXIgc3RvcmFnZV90eXBlID0gY29uZmlnWydwZXJzaXN0ZW5jZSddO1xuICAgIGlmIChzdG9yYWdlX3R5cGUgIT09ICdjb29raWUnICYmIHN0b3JhZ2VfdHlwZSAhPT0gJ2xvY2FsU3RvcmFnZScpIHtcbiAgICAgICAgY29uc29sZSQxLmNyaXRpY2FsKCdVbmtub3duIHBlcnNpc3RlbmNlIHR5cGUgJyArIHN0b3JhZ2VfdHlwZSArICc7IGZhbGxpbmcgYmFjayB0byBjb29raWUnKTtcbiAgICAgICAgc3RvcmFnZV90eXBlID0gY29uZmlnWydwZXJzaXN0ZW5jZSddID0gJ2Nvb2tpZSc7XG4gICAgfVxuXG4gICAgaWYgKHN0b3JhZ2VfdHlwZSA9PT0gJ2xvY2FsU3RvcmFnZScgJiYgXy5sb2NhbFN0b3JhZ2UuaXNfc3VwcG9ydGVkKCkpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gXy5sb2NhbFN0b3JhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gXy5jb29raWU7XG4gICAgfVxuXG4gICAgdGhpcy5sb2FkKCk7XG4gICAgdGhpcy51cGRhdGVfY29uZmlnKGNvbmZpZyk7XG4gICAgdGhpcy51cGdyYWRlKCk7XG4gICAgdGhpcy5zYXZlKCk7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5wcm9wZXJ0aWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHAgPSB7fTtcblxuICAgIHRoaXMubG9hZCgpO1xuXG4gICAgLy8gRmlsdGVyIG91dCByZXNlcnZlZCBwcm9wZXJ0aWVzXG4gICAgXy5lYWNoKHRoaXNbJ3Byb3BzJ10sIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgaWYgKCFfLmluY2x1ZGUoUkVTRVJWRURfUFJPUEVSVElFUywgaykpIHtcbiAgICAgICAgICAgIHBba10gPSB2O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHA7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHsgcmV0dXJuOyB9XG5cbiAgICB2YXIgZW50cnkgPSB0aGlzLnN0b3JhZ2UucGFyc2UodGhpcy5uYW1lKTtcblxuICAgIGlmIChlbnRyeSkge1xuICAgICAgICB0aGlzWydwcm9wcyddID0gXy5leHRlbmQoe30sIGVudHJ5KTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS51cGdyYWRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9sZF9jb29raWUsXG4gICAgICAgIG9sZF9sb2NhbHN0b3JhZ2U7XG5cbiAgICAvLyBpZiB0cmFuc2ZlcnJpbmcgZnJvbSBjb29raWUgdG8gbG9jYWxTdG9yYWdlIG9yIHZpY2UtdmVyc2EsIGNvcHkgZXhpc3RpbmdcbiAgICAvLyBzdXBlciBwcm9wZXJ0aWVzIG92ZXIgdG8gbmV3IHN0b3JhZ2UgbW9kZVxuICAgIGlmICh0aGlzLnN0b3JhZ2UgPT09IF8ubG9jYWxTdG9yYWdlKSB7XG4gICAgICAgIG9sZF9jb29raWUgPSBfLmNvb2tpZS5wYXJzZSh0aGlzLm5hbWUpO1xuXG4gICAgICAgIF8uY29va2llLnJlbW92ZSh0aGlzLm5hbWUpO1xuICAgICAgICBfLmNvb2tpZS5yZW1vdmUodGhpcy5uYW1lLCB0cnVlKTtcblxuICAgICAgICBpZiAob2xkX2Nvb2tpZSkge1xuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlcl9vbmNlKG9sZF9jb29raWUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0b3JhZ2UgPT09IF8uY29va2llKSB7XG4gICAgICAgIG9sZF9sb2NhbHN0b3JhZ2UgPSBfLmxvY2FsU3RvcmFnZS5wYXJzZSh0aGlzLm5hbWUpO1xuXG4gICAgICAgIF8ubG9jYWxTdG9yYWdlLnJlbW92ZSh0aGlzLm5hbWUpO1xuXG4gICAgICAgIGlmIChvbGRfbG9jYWxzdG9yYWdlKSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyX29uY2Uob2xkX2xvY2Fsc3RvcmFnZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHsgcmV0dXJuOyB9XG5cbiAgICB0aGlzLnN0b3JhZ2Uuc2V0KFxuICAgICAgICB0aGlzLm5hbWUsXG4gICAgICAgIEpTT05TdHJpbmdpZnkodGhpc1sncHJvcHMnXSksXG4gICAgICAgIHRoaXMuZXhwaXJlX2RheXMsXG4gICAgICAgIHRoaXMuY3Jvc3Nfc3ViZG9tYWluLFxuICAgICAgICB0aGlzLnNlY3VyZSxcbiAgICAgICAgdGhpcy5jcm9zc19zaXRlLFxuICAgICAgICB0aGlzLmNvb2tpZV9kb21haW5cbiAgICApO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUubG9hZF9wcm9wID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgdGhpcy5sb2FkKCk7XG4gICAgcmV0dXJuIHRoaXNbJ3Byb3BzJ11ba2V5XTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIHJlbW92ZSBib3RoIGRvbWFpbiBhbmQgc3ViZG9tYWluIGNvb2tpZXNcbiAgICB0aGlzLnN0b3JhZ2UucmVtb3ZlKHRoaXMubmFtZSwgZmFsc2UsIHRoaXMuY29va2llX2RvbWFpbik7XG4gICAgdGhpcy5zdG9yYWdlLnJlbW92ZSh0aGlzLm5hbWUsIHRydWUsIHRoaXMuY29va2llX2RvbWFpbik7XG59O1xuXG4vLyByZW1vdmVzIHRoZSBzdG9yYWdlIGVudHJ5IGFuZCBkZWxldGVzIGFsbCBsb2FkZWQgZGF0YVxuLy8gZm9yY2VkIG5hbWUgZm9yIHRlc3RzXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgdGhpc1sncHJvcHMnXSA9IHt9O1xufTtcblxuLyoqXG4qIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuKiBAcGFyYW0geyo9fSBkZWZhdWx0X3ZhbHVlXG4qIEBwYXJhbSB7bnVtYmVyPX0gZGF5c1xuKi9cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnJlZ2lzdGVyX29uY2UgPSBmdW5jdGlvbihwcm9wcywgZGVmYXVsdF92YWx1ZSwgZGF5cykge1xuICAgIGlmIChfLmlzT2JqZWN0KHByb3BzKSkge1xuICAgICAgICBpZiAodHlwZW9mKGRlZmF1bHRfdmFsdWUpID09PSAndW5kZWZpbmVkJykgeyBkZWZhdWx0X3ZhbHVlID0gJ05vbmUnOyB9XG4gICAgICAgIHRoaXMuZXhwaXJlX2RheXMgPSAodHlwZW9mKGRheXMpID09PSAndW5kZWZpbmVkJykgPyB0aGlzLmRlZmF1bHRfZXhwaXJ5IDogZGF5cztcblxuICAgICAgICB0aGlzLmxvYWQoKTtcblxuICAgICAgICBfLmVhY2gocHJvcHMsIGZ1bmN0aW9uKHZhbCwgcHJvcCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzWydwcm9wcyddLmhhc093blByb3BlcnR5KHByb3ApIHx8IHRoaXNbJ3Byb3BzJ11bcHJvcF0gPT09IGRlZmF1bHRfdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzWydwcm9wcyddW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICB0aGlzLnNhdmUoKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4qIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuKiBAcGFyYW0ge251bWJlcj19IGRheXNcbiovXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uKHByb3BzLCBkYXlzKSB7XG4gICAgaWYgKF8uaXNPYmplY3QocHJvcHMpKSB7XG4gICAgICAgIHRoaXMuZXhwaXJlX2RheXMgPSAodHlwZW9mKGRheXMpID09PSAndW5kZWZpbmVkJykgPyB0aGlzLmRlZmF1bHRfZXhwaXJ5IDogZGF5cztcblxuICAgICAgICB0aGlzLmxvYWQoKTtcbiAgICAgICAgXy5leHRlbmQodGhpc1sncHJvcHMnXSwgcHJvcHMpO1xuICAgICAgICB0aGlzLnNhdmUoKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgICB0aGlzLmxvYWQoKTtcbiAgICBpZiAocHJvcCBpbiB0aGlzWydwcm9wcyddKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzWydwcm9wcyddW3Byb3BdO1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS51cGRhdGVfc2VhcmNoX2tleXdvcmQgPSBmdW5jdGlvbihyZWZlcnJlcikge1xuICAgIHRoaXMucmVnaXN0ZXIoXy5pbmZvLnNlYXJjaEluZm8ocmVmZXJyZXIpKTtcbn07XG5cbi8vIEVYUE9SVEVEIE1FVEhPRCwgd2UgdGVzdCB0aGlzIGRpcmVjdGx5LlxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUudXBkYXRlX3JlZmVycmVyX2luZm8gPSBmdW5jdGlvbihyZWZlcnJlcikge1xuICAgIC8vIElmIHJlZmVycmVyIGRvZXNuJ3QgZXhpc3QsIHdlIHdhbnQgdG8gbm90ZSB0aGUgZmFjdCB0aGF0IGl0IHdhcyB0eXBlLWluIHRyYWZmaWMuXG4gICAgdGhpcy5yZWdpc3Rlcl9vbmNlKHtcbiAgICAgICAgJyRpbml0aWFsX3JlZmVycmVyJzogcmVmZXJyZXIgfHwgJyRkaXJlY3QnLFxuICAgICAgICAnJGluaXRpYWxfcmVmZXJyaW5nX2RvbWFpbic6IF8uaW5mby5yZWZlcnJpbmdEb21haW4ocmVmZXJyZXIpIHx8ICckZGlyZWN0J1xuICAgIH0sICcnKTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLmdldF9yZWZlcnJlcl9pbmZvID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8uc3RyaXBfZW1wdHlfcHJvcGVydGllcyh7XG4gICAgICAgICckaW5pdGlhbF9yZWZlcnJlcic6IHRoaXNbJ3Byb3BzJ11bJyRpbml0aWFsX3JlZmVycmVyJ10sXG4gICAgICAgICckaW5pdGlhbF9yZWZlcnJpbmdfZG9tYWluJzogdGhpc1sncHJvcHMnXVsnJGluaXRpYWxfcmVmZXJyaW5nX2RvbWFpbiddXG4gICAgfSk7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS51cGRhdGVfY29uZmlnID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5kZWZhdWx0X2V4cGlyeSA9IHRoaXMuZXhwaXJlX2RheXMgPSBjb25maWdbJ2Nvb2tpZV9leHBpcmF0aW9uJ107XG4gICAgdGhpcy5zZXRfZGlzYWJsZWQoY29uZmlnWydkaXNhYmxlX3BlcnNpc3RlbmNlJ10pO1xuICAgIHRoaXMuc2V0X2Nvb2tpZV9kb21haW4oY29uZmlnWydjb29raWVfZG9tYWluJ10pO1xuICAgIHRoaXMuc2V0X2Nyb3NzX3NpdGUoY29uZmlnWydjcm9zc19zaXRlX2Nvb2tpZSddKTtcbiAgICB0aGlzLnNldF9jcm9zc19zdWJkb21haW4oY29uZmlnWydjcm9zc19zdWJkb21haW5fY29va2llJ10pO1xuICAgIHRoaXMuc2V0X3NlY3VyZShjb25maWdbJ3NlY3VyZV9jb29raWUnXSk7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5zZXRfZGlzYWJsZWQgPSBmdW5jdGlvbihkaXNhYmxlZCkge1xuICAgIHRoaXMuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnNldF9jb29raWVfZG9tYWluID0gZnVuY3Rpb24oY29va2llX2RvbWFpbikge1xuICAgIGlmIChjb29raWVfZG9tYWluICE9PSB0aGlzLmNvb2tpZV9kb21haW4pIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5jb29raWVfZG9tYWluID0gY29va2llX2RvbWFpbjtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuc2V0X2Nyb3NzX3NpdGUgPSBmdW5jdGlvbihjcm9zc19zaXRlKSB7XG4gICAgaWYgKGNyb3NzX3NpdGUgIT09IHRoaXMuY3Jvc3Nfc2l0ZSkge1xuICAgICAgICB0aGlzLmNyb3NzX3NpdGUgPSBjcm9zc19zaXRlO1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5zZXRfY3Jvc3Nfc3ViZG9tYWluID0gZnVuY3Rpb24oY3Jvc3Nfc3ViZG9tYWluKSB7XG4gICAgaWYgKGNyb3NzX3N1YmRvbWFpbiAhPT0gdGhpcy5jcm9zc19zdWJkb21haW4pIHtcbiAgICAgICAgdGhpcy5jcm9zc19zdWJkb21haW4gPSBjcm9zc19zdWJkb21haW47XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLmdldF9jcm9zc19zdWJkb21haW4gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jcm9zc19zdWJkb21haW47XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5zZXRfc2VjdXJlID0gZnVuY3Rpb24oc2VjdXJlKSB7XG4gICAgaWYgKHNlY3VyZSAhPT0gdGhpcy5zZWN1cmUpIHtcbiAgICAgICAgdGhpcy5zZWN1cmUgPSBzZWN1cmUgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLl9hZGRfdG9fcGVvcGxlX3F1ZXVlID0gZnVuY3Rpb24ocXVldWUsIGRhdGEpIHtcbiAgICB2YXIgcV9rZXkgPSB0aGlzLl9nZXRfcXVldWVfa2V5KHF1ZXVlKSxcbiAgICAgICAgcV9kYXRhID0gZGF0YVtxdWV1ZV0sXG4gICAgICAgIHNldF9xID0gdGhpcy5fZ2V0X29yX2NyZWF0ZV9xdWV1ZShTRVRfQUNUSU9OKSxcbiAgICAgICAgc2V0X29uY2VfcSA9IHRoaXMuX2dldF9vcl9jcmVhdGVfcXVldWUoU0VUX09OQ0VfQUNUSU9OKSxcbiAgICAgICAgdW5zZXRfcSA9IHRoaXMuX2dldF9vcl9jcmVhdGVfcXVldWUoVU5TRVRfQUNUSU9OKSxcbiAgICAgICAgYWRkX3EgPSB0aGlzLl9nZXRfb3JfY3JlYXRlX3F1ZXVlKEFERF9BQ1RJT04pLFxuICAgICAgICB1bmlvbl9xID0gdGhpcy5fZ2V0X29yX2NyZWF0ZV9xdWV1ZShVTklPTl9BQ1RJT04pLFxuICAgICAgICByZW1vdmVfcSA9IHRoaXMuX2dldF9vcl9jcmVhdGVfcXVldWUoUkVNT1ZFX0FDVElPTiwgW10pLFxuICAgICAgICBhcHBlbmRfcSA9IHRoaXMuX2dldF9vcl9jcmVhdGVfcXVldWUoQVBQRU5EX0FDVElPTiwgW10pO1xuXG4gICAgaWYgKHFfa2V5ID09PSBTRVRfUVVFVUVfS0VZKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgc2V0IHF1ZXVlIC0gd2UgY2FuIG92ZXJyaWRlIGFueSBleGlzdGluZyB2YWx1ZXNcbiAgICAgICAgXy5leHRlbmQoc2V0X3EsIHFfZGF0YSk7XG4gICAgICAgIC8vIGlmIHRoZXJlIHdhcyBhIHBlbmRpbmcgaW5jcmVtZW50LCBvdmVycmlkZSBpdFxuICAgICAgICAvLyB3aXRoIHRoZSBzZXQuXG4gICAgICAgIHRoaXMuX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZShBRERfQUNUSU9OLCBxX2RhdGEpO1xuICAgICAgICAvLyBpZiB0aGVyZSB3YXMgYSBwZW5kaW5nIHVuaW9uLCBvdmVycmlkZSBpdFxuICAgICAgICAvLyB3aXRoIHRoZSBzZXQuXG4gICAgICAgIHRoaXMuX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZShVTklPTl9BQ1RJT04sIHFfZGF0YSk7XG4gICAgICAgIHRoaXMuX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZShVTlNFVF9BQ1RJT04sIHFfZGF0YSk7XG4gICAgfSBlbHNlIGlmIChxX2tleSA9PT0gU0VUX09OQ0VfUVVFVUVfS0VZKSB7XG4gICAgICAgIC8vIG9ubHkgcXVldWUgdGhlIGRhdGEgaWYgdGhlcmUgaXMgbm90IGFscmVhZHkgYSBzZXRfb25jZSBjYWxsIGZvciBpdC5cbiAgICAgICAgXy5lYWNoKHFfZGF0YSwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgaWYgKCEoayBpbiBzZXRfb25jZV9xKSkge1xuICAgICAgICAgICAgICAgIHNldF9vbmNlX3Fba10gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlKFVOU0VUX0FDVElPTiwgcV9kYXRhKTtcbiAgICB9IGVsc2UgaWYgKHFfa2V5ID09PSBVTlNFVF9RVUVVRV9LRVkpIHtcbiAgICAgICAgXy5lYWNoKHFfZGF0YSwgZnVuY3Rpb24ocHJvcCkge1xuXG4gICAgICAgICAgICAvLyB1bmRvIHByZXZpb3VzbHktcXVldWVkIGFjdGlvbnMgb24gdGhpcyBrZXlcbiAgICAgICAgICAgIF8uZWFjaChbc2V0X3EsIHNldF9vbmNlX3EsIGFkZF9xLCB1bmlvbl9xXSwgZnVuY3Rpb24oZW5xdWV1ZWRfb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgaW4gZW5xdWV1ZWRfb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlbnF1ZXVlZF9vYmpbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfLmVhY2goYXBwZW5kX3EsIGZ1bmN0aW9uKGFwcGVuZF9vYmopIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCBpbiBhcHBlbmRfb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhcHBlbmRfb2JqW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB1bnNldF9xW3Byb3BdID0gdHJ1ZTtcblxuICAgICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHFfa2V5ID09PSBBRERfUVVFVUVfS0VZKSB7XG4gICAgICAgIF8uZWFjaChxX2RhdGEsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgIC8vIElmIGl0IGV4aXN0cyBpbiB0aGUgc2V0IHF1ZXVlLCBpbmNyZW1lbnRcbiAgICAgICAgICAgIC8vIHRoZSB2YWx1ZVxuICAgICAgICAgICAgaWYgKGsgaW4gc2V0X3EpIHtcbiAgICAgICAgICAgICAgICBzZXRfcVtrXSArPSB2O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCBkb2Vzbid0IGV4aXN0LCB1cGRhdGUgdGhlIGFkZFxuICAgICAgICAgICAgICAgIC8vIHF1ZXVlXG4gICAgICAgICAgICAgICAgaWYgKCEoayBpbiBhZGRfcSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkX3Fba10gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRfcVtrXSArPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgdGhpcy5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlKFVOU0VUX0FDVElPTiwgcV9kYXRhKTtcbiAgICB9IGVsc2UgaWYgKHFfa2V5ID09PSBVTklPTl9RVUVVRV9LRVkpIHtcbiAgICAgICAgXy5lYWNoKHFfZGF0YSwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgaWYgKF8uaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgICAgIGlmICghKGsgaW4gdW5pb25fcSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pb25fcVtrXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGR1cGxpY2F0ZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICBfLmVhY2godiwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV8uaW5jbHVkZSh1bmlvbl9xW2tdLCBpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5pb25fcVtrXS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUoVU5TRVRfQUNUSU9OLCBxX2RhdGEpO1xuICAgIH0gZWxzZSBpZiAocV9rZXkgPT09IFJFTU9WRV9RVUVVRV9LRVkpIHtcbiAgICAgICAgcmVtb3ZlX3EucHVzaChxX2RhdGEpO1xuICAgICAgICB0aGlzLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUoQVBQRU5EX0FDVElPTiwgcV9kYXRhKTtcbiAgICB9IGVsc2UgaWYgKHFfa2V5ID09PSBBUFBFTkRfUVVFVUVfS0VZKSB7XG4gICAgICAgIGFwcGVuZF9xLnB1c2gocV9kYXRhKTtcbiAgICAgICAgdGhpcy5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlKFVOU0VUX0FDVElPTiwgcV9kYXRhKTtcbiAgICB9XG5cbiAgICBjb25zb2xlJDEubG9nKCdNSVhQQU5FTCBQRU9QTEUgUkVRVUVTVCAoUVVFVUVELCBQRU5ESU5HIElERU5USUZZKTonKTtcbiAgICBjb25zb2xlJDEubG9nKGRhdGEpO1xuXG4gICAgdGhpcy5zYXZlKCk7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlID0gZnVuY3Rpb24ocXVldWUsIGRhdGEpIHtcbiAgICB2YXIgcSA9IHRoaXNbJ3Byb3BzJ11bdGhpcy5fZ2V0X3F1ZXVlX2tleShxdWV1ZSldO1xuICAgIGlmICghXy5pc1VuZGVmaW5lZChxKSkge1xuICAgICAgICBfLmVhY2goZGF0YSwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgaWYgKHF1ZXVlID09PSBBUFBFTkRfQUNUSU9OIHx8IHF1ZXVlID09PSBSRU1PVkVfQUNUSU9OKSB7XG4gICAgICAgICAgICAgICAgLy8gbGlzdCBhY3Rpb25zOiBvbmx5IHJlbW92ZSBpZiBib3RoIGsrdiBtYXRjaFxuICAgICAgICAgICAgICAgIC8vIGUuZy4gcmVtb3ZlIHNob3VsZCBub3Qgb3ZlcnJpZGUgYXBwZW5kIGluIGEgY2FzZSBsaWtlXG4gICAgICAgICAgICAgICAgLy8gYXBwZW5kKHtmb286ICdiYXInfSk7IHJlbW92ZSh7Zm9vOiAncXV4J30pXG4gICAgICAgICAgICAgICAgXy5lYWNoKHEsIGZ1bmN0aW9uKHF1ZXVlZF9hY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHF1ZXVlZF9hY3Rpb25ba10gPT09IHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBxdWV1ZWRfYWN0aW9uW2tdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBxW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5sb2FkX3F1ZXVlID0gZnVuY3Rpb24ocXVldWUpIHtcbiAgICByZXR1cm4gdGhpcy5sb2FkX3Byb3AodGhpcy5fZ2V0X3F1ZXVlX2tleShxdWV1ZSkpO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuX2dldF9xdWV1ZV9rZXkgPSBmdW5jdGlvbihxdWV1ZSkge1xuICAgIGlmIChxdWV1ZSA9PT0gU0VUX0FDVElPTikge1xuICAgICAgICByZXR1cm4gU0VUX1FVRVVFX0tFWTtcbiAgICB9IGVsc2UgaWYgKHF1ZXVlID09PSBTRVRfT05DRV9BQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIFNFVF9PTkNFX1FVRVVFX0tFWTtcbiAgICB9IGVsc2UgaWYgKHF1ZXVlID09PSBVTlNFVF9BQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIFVOU0VUX1FVRVVFX0tFWTtcbiAgICB9IGVsc2UgaWYgKHF1ZXVlID09PSBBRERfQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBBRERfUVVFVUVfS0VZO1xuICAgIH0gZWxzZSBpZiAocXVldWUgPT09IEFQUEVORF9BQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIEFQUEVORF9RVUVVRV9LRVk7XG4gICAgfSBlbHNlIGlmIChxdWV1ZSA9PT0gUkVNT1ZFX0FDVElPTikge1xuICAgICAgICByZXR1cm4gUkVNT1ZFX1FVRVVFX0tFWTtcbiAgICB9IGVsc2UgaWYgKHF1ZXVlID09PSBVTklPTl9BQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIFVOSU9OX1FVRVVFX0tFWTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlJDEuZXJyb3IoJ0ludmFsaWQgcXVldWU6JywgcXVldWUpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLl9nZXRfb3JfY3JlYXRlX3F1ZXVlID0gZnVuY3Rpb24ocXVldWUsIGRlZmF1bHRfdmFsKSB7XG4gICAgdmFyIGtleSA9IHRoaXMuX2dldF9xdWV1ZV9rZXkocXVldWUpO1xuICAgIGRlZmF1bHRfdmFsID0gXy5pc1VuZGVmaW5lZChkZWZhdWx0X3ZhbCkgPyB7fSA6IGRlZmF1bHRfdmFsO1xuICAgIHJldHVybiB0aGlzWydwcm9wcyddW2tleV0gfHwgKHRoaXNbJ3Byb3BzJ11ba2V5XSA9IGRlZmF1bHRfdmFsKTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnNldF9ldmVudF90aW1lciA9IGZ1bmN0aW9uKGV2ZW50X25hbWUsIHRpbWVzdGFtcCkge1xuICAgIHZhciB0aW1lcnMgPSB0aGlzLmxvYWRfcHJvcChFVkVOVF9USU1FUlNfS0VZKSB8fCB7fTtcbiAgICB0aW1lcnNbZXZlbnRfbmFtZV0gPSB0aW1lc3RhbXA7XG4gICAgdGhpc1sncHJvcHMnXVtFVkVOVF9USU1FUlNfS0VZXSA9IHRpbWVycztcbiAgICB0aGlzLnNhdmUoKTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnJlbW92ZV9ldmVudF90aW1lciA9IGZ1bmN0aW9uKGV2ZW50X25hbWUpIHtcbiAgICB2YXIgdGltZXJzID0gdGhpcy5sb2FkX3Byb3AoRVZFTlRfVElNRVJTX0tFWSkgfHwge307XG4gICAgdmFyIHRpbWVzdGFtcCA9IHRpbWVyc1tldmVudF9uYW1lXTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQodGltZXN0YW1wKSkge1xuICAgICAgICBkZWxldGUgdGhpc1sncHJvcHMnXVtFVkVOVF9USU1FUlNfS0VZXVtldmVudF9uYW1lXTtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aW1lc3RhbXA7XG59O1xuXG4vKiBlc2xpbnQgY2FtZWxjYXNlOiBcIm9mZlwiICovXG5cbi8qXG4gKiBNaXhwYW5lbCBKUyBMaWJyYXJ5XG4gKlxuICogQ29weXJpZ2h0IDIwMTIsIE1peHBhbmVsLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWRcbiAqIGh0dHA6Ly9taXhwYW5lbC5jb20vXG4gKlxuICogSW5jbHVkZXMgcG9ydGlvbnMgb2YgVW5kZXJzY29yZS5qc1xuICogaHR0cDovL2RvY3VtZW50Y2xvdWQuZ2l0aHViLmNvbS91bmRlcnNjb3JlL1xuICogKGMpIDIwMTEgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIEluYy5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4vKlxuU0lNUExFIFNUWUxFIEdVSURFOlxuXG50aGlzLnggPT09IHB1YmxpYyBmdW5jdGlvblxudGhpcy5feCA9PT0gaW50ZXJuYWwgLSBvbmx5IHVzZSB3aXRoaW4gdGhpcyBmaWxlXG50aGlzLl9feCA9PT0gcHJpdmF0ZSAtIG9ubHkgdXNlIHdpdGhpbiB0aGUgY2xhc3NcblxuR2xvYmFscyBzaG91bGQgYmUgYWxsIGNhcHNcbiovXG5cbnZhciBpbml0X3R5cGU7ICAgICAgIC8vIE1PRFVMRSBvciBTTklQUEVUIGxvYWRlclxuLy8gYWxsb3cgYnVuZGxlcnMgdG8gc3BlY2lmeSBob3cgZXh0cmEgY29kZSAocmVjb3JkZXIgYnVuZGxlKSBzaG91bGQgYmUgbG9hZGVkXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbnZhciBsb2FkX2V4dHJhX2J1bmRsZSA9IGZ1bmN0aW9uKHNyYywgX29ubG9hZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihzcmMgKyAnIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBidWlsZC4nKTtcbn07XG5cbnZhciBtaXhwYW5lbF9tYXN0ZXI7IC8vIG1haW4gbWl4cGFuZWwgaW5zdGFuY2UgLyBvYmplY3RcbnZhciBJTklUX01PRFVMRSAgPSAwO1xudmFyIElOSVRfU05JUFBFVCA9IDE7XG5cbnZhciBJREVOVElUWV9GVU5DID0gZnVuY3Rpb24oeCkge3JldHVybiB4O307XG5cbi8qKiBAY29uc3QgKi8gdmFyIFBSSU1BUllfSU5TVEFOQ0VfTkFNRSA9ICdtaXhwYW5lbCc7XG4vKiogQGNvbnN0ICovIHZhciBQQVlMT0FEX1RZUEVfQkFTRTY0ICAgPSAnYmFzZTY0Jztcbi8qKiBAY29uc3QgKi8gdmFyIFBBWUxPQURfVFlQRV9KU09OICAgICA9ICdqc29uJztcbi8qKiBAY29uc3QgKi8gdmFyIERFVklDRV9JRF9QUkVGSVggICAgICA9ICckZGV2aWNlOic7XG5cblxuLypcbiAqIER5bmFtaWMuLi4gY29uc3RhbnRzPyBJcyB0aGF0IGFuIG94eW1vcm9uP1xuICovXG4vLyBodHRwOi8vaGFja3MubW96aWxsYS5vcmcvMjAwOS8wNy9jcm9zcy1zaXRlLXhtbGh0dHByZXF1ZXN0LXdpdGgtY29ycy9cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvRE9NL1hNTEh0dHBSZXF1ZXN0I3dpdGhDcmVkZW50aWFsc1xudmFyIFVTRV9YSFIgPSAod2luLlhNTEh0dHBSZXF1ZXN0ICYmICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpKTtcblxuLy8gSUU8MTAgZG9lcyBub3Qgc3VwcG9ydCBjcm9zcy1vcmlnaW4gWEhSJ3MgYnV0IHNjcmlwdCB0YWdzXG4vLyB3aXRoIGRlZmVyIHdvbid0IGJsb2NrIHdpbmRvdy5vbmxvYWQ7IEVOUVVFVUVfUkVRVUVTVFNcbi8vIHNob3VsZCBvbmx5IGJlIHRydWUgZm9yIE9wZXJhPDEyXG52YXIgRU5RVUVVRV9SRVFVRVNUUyA9ICFVU0VfWEhSICYmICh1c2VyQWdlbnQuaW5kZXhPZignTVNJRScpID09PSAtMSkgJiYgKHVzZXJBZ2VudC5pbmRleE9mKCdNb3ppbGxhJykgPT09IC0xKTtcblxuLy8gc2F2ZSByZWZlcmVuY2UgdG8gbmF2aWdhdG9yLnNlbmRCZWFjb24gc28gaXQgY2FuIGJlIG1pbmlmaWVkXG52YXIgc2VuZEJlYWNvbiA9IG51bGw7XG5pZiAobmF2aWdhdG9yWydzZW5kQmVhY29uJ10pIHtcbiAgICBzZW5kQmVhY29uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGxhdGUgcmVmZXJlbmNlIHRvIG5hdmlnYXRvci5zZW5kQmVhY29uIHRvIGFsbG93IHBhdGNoaW5nL3NweWluZ1xuICAgICAgICByZXR1cm4gbmF2aWdhdG9yWydzZW5kQmVhY29uJ10uYXBwbHkobmF2aWdhdG9yLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbnZhciBERUZBVUxUX0FQSV9ST1VURVMgPSB7XG4gICAgJ3RyYWNrJzogICd0cmFjay8nLFxuICAgICdlbmdhZ2UnOiAnZW5nYWdlLycsXG4gICAgJ2dyb3Vwcyc6ICdncm91cHMvJyxcbiAgICAncmVjb3JkJzogJ3JlY29yZC8nLFxuICAgICdmbGFncyc6ICAnZmxhZ3MvJ1xufTtcblxuLypcbiAqIE1vZHVsZS1sZXZlbCBnbG9iYWxzXG4gKi9cbnZhciBERUZBVUxUX0NPTkZJRyA9IHtcbiAgICAnYXBpX2hvc3QnOiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vYXBpLWpzLm1peHBhbmVsLmNvbScsXG4gICAgJ2FwaV9ob3N0cyc6ICAgICAgICAgICAgICAgICAgICAgICAgIHt9LFxuICAgICdhcGlfcm91dGVzJzogICAgICAgICAgICAgICAgICAgICAgICBERUZBVUxUX0FQSV9ST1VURVMsXG4gICAgJ2FwaV9leHRyYV9xdWVyeV9wYXJhbXMnOiAgICAgICAgICAgIHt9LFxuICAgICdhcGlfbWV0aG9kJzogICAgICAgICAgICAgICAgICAgICAgICAnUE9TVCcsXG4gICAgJ2FwaV90cmFuc3BvcnQnOiAgICAgICAgICAgICAgICAgICAgICdYSFInLFxuICAgICdhcGlfcGF5bG9hZF9mb3JtYXQnOiAgICAgICAgICAgICAgICBQQVlMT0FEX1RZUEVfQkFTRTY0LFxuICAgICdhcHBfaG9zdCc6ICAgICAgICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9taXhwYW5lbC5jb20nLFxuICAgICdhdXRvY2FwdHVyZSc6ICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnY2RuJzogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vY2RuLm14cG5sLmNvbScsXG4gICAgJ2Nyb3NzX3NpdGVfY29va2llJzogICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdjcm9zc19zdWJkb21haW5fY29va2llJzogICAgICAgICAgICB0cnVlLFxuICAgICdlcnJvcl9yZXBvcnRlcic6ICAgICAgICAgICAgICAgICAgICBOT09QX0ZVTkMsXG4gICAgJ2ZsYWdzJzogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdwZXJzaXN0ZW5jZSc6ICAgICAgICAgICAgICAgICAgICAgICAnY29va2llJyxcbiAgICAncGVyc2lzdGVuY2VfbmFtZSc6ICAgICAgICAgICAgICAgICAgJycsXG4gICAgJ2Nvb2tpZV9kb21haW4nOiAgICAgICAgICAgICAgICAgICAgICcnLFxuICAgICdjb29raWVfbmFtZSc6ICAgICAgICAgICAgICAgICAgICAgICAnJyxcbiAgICAnbG9hZGVkJzogICAgICAgICAgICAgICAgICAgICAgICAgICAgTk9PUF9GVU5DLFxuICAgICdtcF9sb2FkZXInOiAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICd0cmFja19tYXJrZXRpbmcnOiAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICd0cmFja19wYWdldmlldyc6ICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnc2tpcF9maXJzdF90b3VjaF9tYXJrZXRpbmcnOiAgICAgICAgZmFsc2UsXG4gICAgJ3N0b3JlX2dvb2dsZSc6ICAgICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgJ3N0b3BfdXRtX3BlcnNpc3RlbmNlJzogICAgICAgICAgICAgIGZhbHNlLFxuICAgICdzYXZlX3JlZmVycmVyJzogICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICd0ZXN0JzogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAndmVyYm9zZSc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ2ltZyc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdkZWJ1Zyc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAndHJhY2tfbGlua3NfdGltZW91dCc6ICAgICAgICAgICAgICAgMzAwLFxuICAgICdjb29raWVfZXhwaXJhdGlvbic6ICAgICAgICAgICAgICAgICAzNjUsXG4gICAgJ3VwZ3JhZGUnOiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdkaXNhYmxlX3BlcnNpc3RlbmNlJzogICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnZGlzYWJsZV9jb29raWUnOiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ3NlY3VyZV9jb29raWUnOiAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdpcCc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICdvcHRfb3V0X3RyYWNraW5nX2J5X2RlZmF1bHQnOiAgICAgICBmYWxzZSxcbiAgICAnb3B0X291dF9wZXJzaXN0ZW5jZV9ieV9kZWZhdWx0JzogICAgZmFsc2UsXG4gICAgJ29wdF9vdXRfdHJhY2tpbmdfcGVyc2lzdGVuY2VfdHlwZSc6ICdsb2NhbFN0b3JhZ2UnLFxuICAgICdvcHRfb3V0X3RyYWNraW5nX2Nvb2tpZV9wcmVmaXgnOiAgICBudWxsLFxuICAgICdwcm9wZXJ0eV9ibGFja2xpc3QnOiAgICAgICAgICAgICAgICBbXSxcbiAgICAneGhyX2hlYWRlcnMnOiAgICAgICAgICAgICAgICAgICAgICAge30sIC8vIHsgaGVhZGVyOiB2YWx1ZSwgaGVhZGVyMjogdmFsdWUgfVxuICAgICdpZ25vcmVfZG50JzogICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnYmF0Y2hfcmVxdWVzdHMnOiAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAnYmF0Y2hfc2l6ZSc6ICAgICAgICAgICAgICAgICAgICAgICAgNTAsXG4gICAgJ2JhdGNoX2ZsdXNoX2ludGVydmFsX21zJzogICAgICAgICAgIDUwMDAsXG4gICAgJ2JhdGNoX3JlcXVlc3RfdGltZW91dF9tcyc6ICAgICAgICAgIDkwMDAwLFxuICAgICdiYXRjaF9hdXRvc3RhcnQnOiAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICdob29rcyc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7fSxcbiAgICAncmVjb3JkX2Jsb2NrX2NsYXNzJzogICAgICAgICAgICAgICAgbmV3IFJlZ0V4cCgnXihtcC1ibG9ja3xmcy1leGNsdWRlfGFtcC1ibG9ja3xyci1ibG9ja3xwaC1uby1jYXB0dXJlKSQnKSxcbiAgICAncmVjb3JkX2Jsb2NrX3NlbGVjdG9yJzogICAgICAgICAgICAgJ2ltZywgdmlkZW8sIGF1ZGlvJyxcbiAgICAncmVjb3JkX2NhbnZhcyc6ICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ3JlY29yZF9jb2xsZWN0X2ZvbnRzJzogICAgICAgICAgICAgIGZhbHNlLFxuICAgICdyZWNvcmRfY29uc29sZSc6ICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICdyZWNvcmRfaGVhdG1hcF9kYXRhJzogICAgICAgICAgICAgICBmYWxzZSxcbiAgICAncmVjb3JkX2lkbGVfdGltZW91dF9tcyc6ICAgICAgICAgICAgMzAgKiA2MCAqIDEwMDAsIC8vIDMwIG1pbnV0ZXNcbiAgICAncmVjb3JkX21hc2tfdGV4dF9jbGFzcyc6ICAgICAgICAgICAgbmV3IFJlZ0V4cCgnXihtcC1tYXNrfGZzLW1hc2t8YW1wLW1hc2t8cnItbWFza3xwaC1tYXNrKSQnKSxcbiAgICAncmVjb3JkX21hc2tfdGV4dF9zZWxlY3Rvcic6ICAgICAgICAgJyonLFxuICAgICdyZWNvcmRfbWF4X21zJzogICAgICAgICAgICAgICAgICAgICBNQVhfUkVDT1JESU5HX01TLFxuICAgICdyZWNvcmRfbWluX21zJzogICAgICAgICAgICAgICAgICAgICAwLFxuICAgICdyZWNvcmRfc2Vzc2lvbnNfcGVyY2VudCc6ICAgICAgICAgICAwLFxuICAgICdyZWNvcmRlcl9zcmMnOiAgICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9jZG4ubXhwbmwuY29tL2xpYnMvbWl4cGFuZWwtcmVjb3JkZXIubWluLmpzJ1xufTtcblxudmFyIERPTV9MT0FERUQgPSBmYWxzZTtcblxuLyoqXG4gKiBNaXhwYW5lbCBMaWJyYXJ5IE9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBNaXhwYW5lbExpYiA9IGZ1bmN0aW9uKCkge307XG5cblxuLyoqXG4gKiBjcmVhdGVfbXBsaWIodG9rZW46c3RyaW5nLCBjb25maWc6b2JqZWN0LCBuYW1lOnN0cmluZylcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYnkgdGhlIGluaXQgbWV0aG9kIG9mIE1peHBhbmVsTGliIG9iamVjdHNcbiAqIGFzIHdlbGwgYXMgdGhlIG1haW4gaW5pdGlhbGl6ZXIgYXQgdGhlIGVuZCBvZiB0aGUgSlNMaWIgKHRoYXRcbiAqIGluaXRpYWxpemVzIGRvY3VtZW50Lm1peHBhbmVsIGFzIHdlbGwgYXMgYW55IGFkZGl0aW9uYWwgaW5zdGFuY2VzXG4gKiBkZWNsYXJlZCBiZWZvcmUgdGhpcyBmaWxlIGhhcyBsb2FkZWQpLlxuICovXG52YXIgY3JlYXRlX21wbGliID0gZnVuY3Rpb24odG9rZW4sIGNvbmZpZywgbmFtZSkge1xuICAgIHZhciBpbnN0YW5jZSxcbiAgICAgICAgdGFyZ2V0ID0gKG5hbWUgPT09IFBSSU1BUllfSU5TVEFOQ0VfTkFNRSkgPyBtaXhwYW5lbF9tYXN0ZXIgOiBtaXhwYW5lbF9tYXN0ZXJbbmFtZV07XG5cbiAgICBpZiAodGFyZ2V0ICYmIGluaXRfdHlwZSA9PT0gSU5JVF9NT0RVTEUpIHtcbiAgICAgICAgaW5zdGFuY2UgPSB0YXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRhcmdldCAmJiAhXy5pc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUkMS5lcnJvcignWW91IGhhdmUgYWxyZWFkeSBpbml0aWFsaXplZCAnICsgbmFtZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UgPSBuZXcgTWl4cGFuZWxMaWIoKTtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5fY2FjaGVkX2dyb3VwcyA9IHt9OyAvLyBjYWNoZSBncm91cHMgaW4gYSBwb29sXG5cbiAgICBpbnN0YW5jZS5faW5pdCh0b2tlbiwgY29uZmlnLCBuYW1lKTtcblxuICAgIGluc3RhbmNlWydwZW9wbGUnXSA9IG5ldyBNaXhwYW5lbFBlb3BsZSgpO1xuICAgIGluc3RhbmNlWydwZW9wbGUnXS5faW5pdChpbnN0YW5jZSk7XG5cbiAgICBpZiAoIWluc3RhbmNlLmdldF9jb25maWcoJ3NraXBfZmlyc3RfdG91Y2hfbWFya2V0aW5nJykpIHtcbiAgICAgICAgLy8gV2UgbmVlZCBudWxsIFVUTSBwYXJhbXMgaW4gdGhlIG9iamVjdCBiZWNhdXNlXG4gICAgICAgIC8vIFVUTSBwYXJhbWV0ZXJzIGFjdCBhcyBhIHR1cGxlLiBJZiBhbnkgVVRNIHBhcmFtXG4gICAgICAgIC8vIGlzIHByZXNlbnQsIHRoZW4gd2Ugc2V0IGFsbCBVVE0gcGFyYW1zIGluY2x1ZGluZ1xuICAgICAgICAvLyBlbXB0eSBvbmVzIHRvZ2V0aGVyXG4gICAgICAgIHZhciB1dG1fcGFyYW1zID0gXy5pbmZvLmNhbXBhaWduUGFyYW1zKG51bGwpO1xuICAgICAgICB2YXIgaW5pdGlhbF91dG1fcGFyYW1zID0ge307XG4gICAgICAgIHZhciBoYXNfdXRtID0gZmFsc2U7XG4gICAgICAgIF8uZWFjaCh1dG1fcGFyYW1zLCBmdW5jdGlvbih1dG1fdmFsdWUsIHV0bV9rZXkpIHtcbiAgICAgICAgICAgIGluaXRpYWxfdXRtX3BhcmFtc1snaW5pdGlhbF8nICsgdXRtX2tleV0gPSB1dG1fdmFsdWU7XG4gICAgICAgICAgICBpZiAodXRtX3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaGFzX3V0bSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaGFzX3V0bSkge1xuICAgICAgICAgICAgaW5zdGFuY2VbJ3Blb3BsZSddLnNldF9vbmNlKGluaXRpYWxfdXRtX3BhcmFtcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBhbnkgaW5zdGFuY2Ugb24gdGhlIHBhZ2UgaGFzIGRlYnVnID0gdHJ1ZSwgd2Ugc2V0IHRoZVxuICAgIC8vIGdsb2JhbCBkZWJ1ZyB0byBiZSB0cnVlXG4gICAgQ29uZmlnLkRFQlVHID0gQ29uZmlnLkRFQlVHIHx8IGluc3RhbmNlLmdldF9jb25maWcoJ2RlYnVnJyk7XG5cbiAgICAvLyBpZiB0YXJnZXQgaXMgbm90IGRlZmluZWQsIHdlIGNhbGxlZCBpbml0IGFmdGVyIHRoZSBsaWIgYWxyZWFkeVxuICAgIC8vIGxvYWRlZCwgc28gdGhlcmUgd29uJ3QgYmUgYW4gYXJyYXkgb2YgdGhpbmdzIHRvIGV4ZWN1dGVcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQodGFyZ2V0KSAmJiBfLmlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICAvLyBDcnVuY2ggdGhyb3VnaCB0aGUgcGVvcGxlIHF1ZXVlIGZpcnN0IC0gd2UgcXVldWUgdGhpcyBkYXRhIHVwICZcbiAgICAgICAgLy8gZmx1c2ggb24gaWRlbnRpZnksIHNvIGl0J3MgYmV0dGVyIHRvIGRvIGFsbCB0aGVzZSBvcGVyYXRpb25zIGZpcnN0XG4gICAgICAgIGluc3RhbmNlLl9leGVjdXRlX2FycmF5LmNhbGwoaW5zdGFuY2VbJ3Blb3BsZSddLCB0YXJnZXRbJ3Blb3BsZSddKTtcbiAgICAgICAgaW5zdGFuY2UuX2V4ZWN1dGVfYXJyYXkodGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG59O1xuXG4vLyBJbml0aWFsaXphdGlvbiBtZXRob2RzXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgTWl4cGFuZWwgdHJhY2tpbmcgb2JqZWN0LlxuICogQWxsIG5ldyBpbnN0YW5jZXMgYXJlIGFkZGVkIHRvIHRoZSBtYWluIG1peHBhbmVsIG9iamVjdCBhcyBzdWIgcHJvcGVydGllcyAoc3VjaCBhc1xuICogbWl4cGFuZWwubGlicmFyeV9uYW1lKSBhbmQgYWxzbyByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uLiBUbyBkZWZpbmUgYVxuICogc2Vjb25kIGluc3RhbmNlIG9uIHRoZSBwYWdlLCB5b3Ugd291bGQgY2FsbDpcbiAqXG4gKiAgICAgbWl4cGFuZWwuaW5pdCgnbmV3IHRva2VuJywgeyB5b3VyOiAnY29uZmlnJyB9LCAnbGlicmFyeV9uYW1lJyk7XG4gKlxuICogYW5kIHVzZSBpdCBsaWtlIHNvOlxuICpcbiAqICAgICBtaXhwYW5lbC5saWJyYXJ5X25hbWUudHJhY2soLi4uKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9rZW4gICBZb3VyIE1peHBhbmVsIEFQSSB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddICBBIGRpY3Rpb25hcnkgb2YgY29uZmlnIG9wdGlvbnMgdG8gb3ZlcnJpZGUuIDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vbWl4cGFuZWwvbWl4cGFuZWwtanMvYmxvYi92Mi40Ni4wL3NyYy9taXhwYW5lbC1jb3JlLmpzI0w4OC1MMTI3XCI+U2VlIGEgbGlzdCBvZiBkZWZhdWx0IGNvbmZpZyBvcHRpb25zPC9hPi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZV0gICAgVGhlIG5hbWUgZm9yIHRoZSBuZXcgbWl4cGFuZWwgaW5zdGFuY2UgdGhhdCB5b3Ugd2FudCBjcmVhdGVkXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKHRva2VuLCBjb25maWcsIG5hbWUpIHtcbiAgICBpZiAoXy5pc1VuZGVmaW5lZChuYW1lKSkge1xuICAgICAgICB0aGlzLnJlcG9ydF9lcnJvcignWW91IG11c3QgbmFtZSB5b3VyIG5ldyBsaWJyYXJ5OiBpbml0KHRva2VuLCBjb25maWcsIG5hbWUpJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09IFBSSU1BUllfSU5TVEFOQ0VfTkFNRSkge1xuICAgICAgICB0aGlzLnJlcG9ydF9lcnJvcignWW91IG11c3QgaW5pdGlhbGl6ZSB0aGUgbWFpbiBtaXhwYW5lbCBvYmplY3QgcmlnaHQgYWZ0ZXIgeW91IGluY2x1ZGUgdGhlIE1peHBhbmVsIGpzIHNuaXBwZXQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZV9tcGxpYih0b2tlbiwgY29uZmlnLCBuYW1lKTtcbiAgICBtaXhwYW5lbF9tYXN0ZXJbbmFtZV0gPSBpbnN0YW5jZTtcbiAgICBpbnN0YW5jZS5fbG9hZGVkKCk7XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG59O1xuXG4vLyBtaXhwYW5lbC5faW5pdCh0b2tlbjpzdHJpbmcsIGNvbmZpZzpvYmplY3QsIG5hbWU6c3RyaW5nKVxuLy9cbi8vIFRoaXMgZnVuY3Rpb24gc2V0cyB1cCB0aGUgY3VycmVudCBpbnN0YW5jZSBvZiB0aGUgbWl4cGFuZWxcbi8vIGxpYnJhcnkuICBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoaXMgbWV0aG9kIGFuZCB0aGUgaW5pdCguLi4pXG4vLyBtZXRob2QgaXMgdGhpcyBvbmUgaW5pdGlhbGl6ZXMgdGhlIGFjdHVhbCBpbnN0YW5jZSwgd2hlcmVhcyB0aGVcbi8vIGluaXQoLi4uKSBtZXRob2Qgc2V0cyB1cCBhIG5ldyBsaWJyYXJ5IGFuZCBjYWxscyBfaW5pdCBvbiBpdC5cbi8vXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbih0b2tlbiwgY29uZmlnLCBuYW1lKSB7XG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG4gICAgdGhpc1snX19sb2FkZWQnXSA9IHRydWU7XG4gICAgdGhpc1snY29uZmlnJ10gPSB7fTtcblxuICAgIHZhciB2YXJpYWJsZV9mZWF0dXJlcyA9IHt9O1xuXG4gICAgLy8gZGVmYXVsdCB0byBKU09OIHBheWxvYWQgZm9yIHN0YW5kYXJkIG1peHBhbmVsLmNvbSBBUEkgaG9zdHNcbiAgICBpZiAoISgnYXBpX3BheWxvYWRfZm9ybWF0JyBpbiBjb25maWcpKSB7XG4gICAgICAgIHZhciBhcGlfaG9zdCA9IGNvbmZpZ1snYXBpX2hvc3QnXSB8fCBERUZBVUxUX0NPTkZJR1snYXBpX2hvc3QnXTtcbiAgICAgICAgaWYgKGFwaV9ob3N0Lm1hdGNoKC9cXC5taXhwYW5lbFxcLmNvbS8pKSB7XG4gICAgICAgICAgICB2YXJpYWJsZV9mZWF0dXJlc1snYXBpX3BheWxvYWRfZm9ybWF0J10gPSBQQVlMT0FEX1RZUEVfSlNPTjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2V0X2NvbmZpZyhfLmV4dGVuZCh7fSwgREVGQVVMVF9DT05GSUcsIHZhcmlhYmxlX2ZlYXR1cmVzLCBjb25maWcsIHtcbiAgICAgICAgJ25hbWUnOiBuYW1lLFxuICAgICAgICAndG9rZW4nOiB0b2tlbixcbiAgICAgICAgJ2NhbGxiYWNrX2ZuJzogKChuYW1lID09PSBQUklNQVJZX0lOU1RBTkNFX05BTUUpID8gbmFtZSA6IFBSSU1BUllfSU5TVEFOQ0VfTkFNRSArICcuJyArIG5hbWUpICsgJy5fanNjJ1xuICAgIH0pKTtcblxuICAgIHRoaXNbJ19qc2MnXSA9IE5PT1BfRlVOQztcblxuICAgIHRoaXMuX19kb21fbG9hZGVkX3F1ZXVlID0gW107XG4gICAgdGhpcy5fX3JlcXVlc3RfcXVldWUgPSBbXTtcbiAgICB0aGlzLl9fZGlzYWJsZWRfZXZlbnRzID0gW107XG4gICAgdGhpcy5fZmxhZ3MgPSB7XG4gICAgICAgICdkaXNhYmxlX2FsbF9ldmVudHMnOiBmYWxzZSxcbiAgICAgICAgJ2lkZW50aWZ5X2NhbGxlZCc6IGZhbHNlXG4gICAgfTtcblxuICAgIC8vIHNldCB1cCByZXF1ZXN0IHF1ZXVlaW5nL2JhdGNoaW5nXG4gICAgdGhpcy5yZXF1ZXN0X2JhdGNoZXJzID0ge307XG4gICAgdGhpcy5fYmF0Y2hfcmVxdWVzdHMgPSB0aGlzLmdldF9jb25maWcoJ2JhdGNoX3JlcXVlc3RzJyk7XG4gICAgaWYgKHRoaXMuX2JhdGNoX3JlcXVlc3RzKSB7XG4gICAgICAgIGlmICghXy5sb2NhbFN0b3JhZ2UuaXNfc3VwcG9ydGVkKHRydWUpIHx8ICFVU0VfWEhSKSB7XG4gICAgICAgICAgICB0aGlzLl9iYXRjaF9yZXF1ZXN0cyA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc29sZSQxLmxvZygnVHVybmluZyBvZmYgTWl4cGFuZWwgcmVxdWVzdC1xdWV1ZWluZzsgbmVlZHMgWEhSIGFuZCBsb2NhbFN0b3JhZ2Ugc3VwcG9ydCcpO1xuICAgICAgICAgICAgXy5lYWNoKHRoaXMuZ2V0X2JhdGNoZXJfY29uZmlncygpLCBmdW5jdGlvbihiYXRjaGVyX2NvbmZpZykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUkMS5sb2coJ0NsZWFyaW5nIGJhdGNoIHF1ZXVlICcgKyBiYXRjaGVyX2NvbmZpZy5xdWV1ZV9rZXkpO1xuICAgICAgICAgICAgICAgIF8ubG9jYWxTdG9yYWdlLnJlbW92ZShiYXRjaGVyX2NvbmZpZy5xdWV1ZV9rZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmluaXRfYmF0Y2hlcnMoKTtcbiAgICAgICAgICAgIGlmIChzZW5kQmVhY29uICYmIHdpbi5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgLy8gQmVmb3JlIHBhZ2UgY2xvc2VzIG9yIGhpZGVzICh1c2VyIHRhYnMgYXdheSBldGMpLCBhdHRlbXB0IHRvIGZsdXNoIGFueSBldmVudHNcbiAgICAgICAgICAgICAgICAvLyBxdWV1ZWQgdXAgdmlhIG5hdmlnYXRvci5zZW5kQmVhY29uLiBTaW5jZSBzZW5kQmVhY29uIGRvZXNuJ3QgcmVwb3J0IHN1Y2Nlc3MvZmFpbHVyZSxcbiAgICAgICAgICAgICAgICAvLyBldmVudHMgd2lsbCBub3QgYmUgcmVtb3ZlZCBmcm9tIHRoZSBwZXJzaXN0ZW50IHN0b3JlOyBpZiB0aGUgc2l0ZSBpcyBsb2FkZWQgYWdhaW4sXG4gICAgICAgICAgICAgICAgLy8gdGhlIGV2ZW50cyB3aWxsIGJlIGZsdXNoZWQgYWdhaW4gb24gc3RhcnR1cCBhbmQgZGVkdXBsaWNhdGVkIG9uIHRoZSBNaXhwYW5lbCBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAvLyBzaWRlLlxuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIHJlbGlhYmxlIHdheSB0byBjYXB0dXJlIG9ubHkgcGFnZSBjbG9zZSBldmVudHMsIHNvIHdlIGxlYW4gb24gdGhlXG4gICAgICAgICAgICAgICAgLy8gdmlzaWJpbGl0eWNoYW5nZSBhbmQgcGFnZWhpZGUgZXZlbnRzIGFzIHJlY29tbWVuZGVkIGF0XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy91bmxvYWRfZXZlbnQjdXNhZ2Vfbm90ZXMuXG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgZXZlbnRzIGZpcmUgd2hlbiB0aGUgdXNlciBjbGlja3MgYXdheSBmcm9tIHRoZSBjdXJyZW50IHBhZ2UvdGFiLCBzbyB3aWxsIG9jY3VyXG4gICAgICAgICAgICAgICAgLy8gbW9yZSBmcmVxdWVudGx5IHRoYW4gcGFnZSB1bmxvYWQsIGJ1dCBhcmUgdGhlIG9ubHkgbWVjaGFuaXNtIGN1cnJlbnRseSBmb3IgY2FwdHVyaW5nXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBzY2VuYXJpbyBzb21ld2hhdCByZWxpYWJseS5cbiAgICAgICAgICAgICAgICB2YXIgZmx1c2hfb25fdW5sb2FkID0gXy5iaW5kKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucmVxdWVzdF9iYXRjaGVycy5ldmVudHMuc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0X2JhdGNoZXJzLmV2ZW50cy5mbHVzaCh7dW5sb2FkaW5nOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZbJ3BlcnNpc3RlZCddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbHVzaF9vbl91bmxvYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudCQxWyd2aXNpYmlsaXR5U3RhdGUnXSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsdXNoX29uX3VubG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzWydwZXJzaXN0ZW5jZSddID0gdGhpc1snY29va2llJ10gPSBuZXcgTWl4cGFuZWxQZXJzaXN0ZW5jZSh0aGlzWydjb25maWcnXSk7XG4gICAgdGhpcy51bnBlcnNpc3RlZF9zdXBlcnByb3BzID0ge307XG4gICAgdGhpcy5fZ2Rwcl9pbml0KCk7XG5cbiAgICB2YXIgdXVpZCA9IF8uVVVJRCgpO1xuICAgIGlmICghdGhpcy5nZXRfZGlzdGluY3RfaWQoKSkge1xuICAgICAgICAvLyBUaGVyZSBpcyBubyBuZWVkIHRvIHNldCB0aGUgZGlzdGluY3QgaWRcbiAgICAgICAgLy8gb3IgdGhlIGRldmljZSBpZCBpZiBzb21ldGhpbmcgd2FzIGFscmVhZHkgc3RvcmVkXG4gICAgICAgIC8vIGluIHRoZSBwZXJzaXRlbmNlXG4gICAgICAgIHRoaXMucmVnaXN0ZXJfb25jZSh7XG4gICAgICAgICAgICAnZGlzdGluY3RfaWQnOiBERVZJQ0VfSURfUFJFRklYICsgdXVpZCxcbiAgICAgICAgICAgICckZGV2aWNlX2lkJzogdXVpZFxuICAgICAgICB9LCAnJyk7XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IG5ldyBGZWF0dXJlRmxhZ01hbmFnZXIoe1xuICAgICAgICBnZXRGdWxsQXBpUm91dGU6IF8uYmluZChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldF9hcGlfaG9zdCgnZmxhZ3MnKSArICcvJyArIHRoaXMuZ2V0X2NvbmZpZygnYXBpX3JvdXRlcycpWydmbGFncyddO1xuICAgICAgICB9LCB0aGlzKSxcbiAgICAgICAgZ2V0Q29uZmlnRnVuYzogXy5iaW5kKHRoaXMuZ2V0X2NvbmZpZywgdGhpcyksXG4gICAgICAgIHNldENvbmZpZ0Z1bmM6IF8uYmluZCh0aGlzLnNldF9jb25maWcsIHRoaXMpLFxuICAgICAgICBnZXRQcm9wZXJ0eUZ1bmM6IF8uYmluZCh0aGlzLmdldF9wcm9wZXJ0eSwgdGhpcyksXG4gICAgICAgIHRyYWNraW5nRnVuYzogXy5iaW5kKHRoaXMudHJhY2ssIHRoaXMpXG4gICAgfSk7XG4gICAgdGhpcy5mbGFncy5pbml0KCk7XG4gICAgdGhpc1snZmxhZ3MnXSA9IHRoaXMuZmxhZ3M7XG5cbiAgICB0aGlzLmF1dG9jYXB0dXJlID0gbmV3IEF1dG9jYXB0dXJlKHRoaXMpO1xuICAgIHRoaXMuYXV0b2NhcHR1cmUuaW5pdCgpO1xuXG4gICAgdGhpcy5faW5pdF90YWJfaWQoKTtcbiAgICB0aGlzLl9jaGVja19hbmRfc3RhcnRfc2Vzc2lvbl9yZWNvcmRpbmcoKTtcbn07XG5cbi8qKlxuICogQXNzaWducyBhIHVuaXF1ZSBVVUlEIHRvIHRoaXMgdGFiIC8gd2luZG93IGJ5IGxldmVyYWdpbmcgc2Vzc2lvblN0b3JhZ2UuXG4gKiBUaGlzIGlzIHByaW1hcmlseSB1c2VkIGZvciBzZXNzaW9uIHJlY29yZGluZywgd2hlcmUgZGF0YSBtdXN0IGJlIGlzb2xhdGVkIHRvIHRoZSBjdXJyZW50IHRhYi5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9pbml0X3RhYl9pZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmdldF9jb25maWcoJ2Rpc2FibGVfcGVyc2lzdGVuY2UnKSkge1xuICAgICAgICBjb25zb2xlJDEubG9nKCdUYWIgSUQgaW5pdGlhbGl6YXRpb24gc2tpcHBlZCBkdWUgdG8gZGlzYWJsZV9wZXJzaXN0ZW5jZSBjb25maWcnKTtcbiAgICB9IGVsc2UgaWYgKF8uc2Vzc2lvblN0b3JhZ2UuaXNfc3VwcG9ydGVkKCkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBrZXlfc3VmZml4ID0gdGhpcy5nZXRfY29uZmlnKCduYW1lJykgKyAnXycgKyB0aGlzLmdldF9jb25maWcoJ3Rva2VuJyk7XG4gICAgICAgICAgICB2YXIgdGFiX2lkX2tleSA9ICdtcF90YWJfaWRfJyArIGtleV9zdWZmaXg7XG5cbiAgICAgICAgICAgIC8vIEEgZmxhZyBpcyB1c2VkIHRvIGRldGVybWluZSBpZiBzZXNzaW9uU3RvcmFnZSBpcyBjb3BpZWQgb3ZlciBhbmQgd2UgbmVlZCB0byBnZW5lcmF0ZSBhIG5ldyB0YWIgSUQuXG4gICAgICAgICAgICAvLyBUaGlzIGVuZm9yY2VzIGEgdW5pcXVlIElEIGluIHRoZSBjYXNlcyBsaWtlIGR1cGxpY2F0ZWQgdGFiLCB3aW5kb3cub3BlbiguLi4pXG4gICAgICAgICAgICB2YXIgc2hvdWxkX2dlbmVyYXRlX25ld190YWJfaWRfa2V5ID0gJ21wX2dlbl9uZXdfdGFiX2lkXycgKyBrZXlfc3VmZml4O1xuICAgICAgICAgICAgaWYgKF8uc2Vzc2lvblN0b3JhZ2UuZ2V0KHNob3VsZF9nZW5lcmF0ZV9uZXdfdGFiX2lkX2tleSkgfHwgIV8uc2Vzc2lvblN0b3JhZ2UuZ2V0KHRhYl9pZF9rZXkpKSB7XG4gICAgICAgICAgICAgICAgXy5zZXNzaW9uU3RvcmFnZS5zZXQodGFiX2lkX2tleSwgJyR0YWItJyArIF8uVVVJRCgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgXy5zZXNzaW9uU3RvcmFnZS5zZXQoc2hvdWxkX2dlbmVyYXRlX25ld190YWJfaWRfa2V5LCAnMScpO1xuICAgICAgICAgICAgdGhpcy50YWJfaWQgPSBfLnNlc3Npb25TdG9yYWdlLmdldCh0YWJfaWRfa2V5KTtcblxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBmbGFnIHdoZW4gdGhlIHRhYiBpcyB1bmxvYWRlZCB0byBpbmRpY2F0ZSB0aGUgc3RvcmVkIHRhYiBJRCBjYW4gYmUgcmV1c2VkLiBUaGlzIGV2ZW50IGlzIG5vdCByZWxpYWJsZSB0byBkZXRlY3QgYWxsIHBhZ2UgdW5sb2FkcyxcbiAgICAgICAgICAgIC8vIGJ1dCByZWxpYWJsZSBpbiBjYXNlcyB3aGVyZSB0aGUgdXNlciByZW1haW5zIGluIHRoZSB0YWIgZS5nLiBhIHJlZnJlc2ggb3IgaHJlZiBuYXZpZ2F0aW9uLlxuICAgICAgICAgICAgLy8gSWYgdGhlIGZsYWcgaXMgYWJzZW50LCB0aGlzIGluZGljYXRlcyB0byB0aGUgbmV4dCBTREsgaW5zdGFuY2UgdGhhdCB3ZSBjYW4gcmV1c2UgdGhlIHN0b3JlZCB0YWJfaWQuXG4gICAgICAgICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF8uc2Vzc2lvblN0b3JhZ2UucmVtb3ZlKHNob3VsZF9nZW5lcmF0ZV9uZXdfdGFiX2lkX2tleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdFcnJvciBpbml0aWFsaXppbmcgdGFiIGlkJywgZXJyKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdTZXNzaW9uIHN0b3JhZ2UgaXMgbm90IHN1cHBvcnRlZCwgY2Fubm90IGtlZXAgdHJhY2sgb2YgdW5pcXVlIHRhYiBJRC4nKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X3RhYl9pZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50YWJfaWQgfHwgbnVsbDtcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fc2hvdWxkX2xvYWRfcmVjb3JkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygnZGlzYWJsZV9wZXJzaXN0ZW5jZScpKSB7XG4gICAgICAgIGNvbnNvbGUkMS5sb2coJ0xvYWQgcmVjb3JkZXIgY2hlY2sgc2tpcHBlZCBkdWUgdG8gZGlzYWJsZV9wZXJzaXN0ZW5jZSBjb25maWcnKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZGluZ19yZWdpc3RyeV9pZGIgPSBuZXcgSURCU3RvcmFnZVdyYXBwZXIoUkVDT1JESU5HX1JFR0lTVFJZX1NUT1JFX05BTUUpO1xuICAgIHZhciB0YWJfaWQgPSB0aGlzLmdldF90YWJfaWQoKTtcbiAgICByZXR1cm4gcmVjb3JkaW5nX3JlZ2lzdHJ5X2lkYi5pbml0KClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlY29yZGluZ19yZWdpc3RyeV9pZGIuZ2V0QWxsKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZWNvcmRpbmdzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlY29yZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgZXhwaXJlZCByZWNvcmRpbmdzIGluIHRoZSByZWdpc3RyeSwgd2Ugc2hvdWxkIGxvYWQgdGhlIHJlY29yZGVyIHRvIGZsdXNoIHRoZW1cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSdzIGEgcmVjb3JkaW5nIGZvciB0aGlzIHRhYiBpZCwgd2Ugc2hvdWxkIGxvYWQgdGhlIHJlY29yZGVyIHRvIGNvbnRpbnVlIHRoZSByZWNvcmRpbmdcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWNvcmRpbmdFeHBpcmVkKHJlY29yZGluZ3NbaV0pIHx8IHJlY29yZGluZ3NbaV1bJ3RhYklkJ10gPT09IHRhYl9pZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoJ0Vycm9yIGNoZWNraW5nIHJlY29yZGluZyByZWdpc3RyeScsIGVycik7XG4gICAgICAgIH0sIHRoaXMpKTtcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fY2hlY2tfYW5kX3N0YXJ0X3Nlc3Npb25fcmVjb3JkaW5nID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYihmdW5jdGlvbihmb3JjZV9zdGFydCkge1xuICAgIGlmICghd2luWydNdXRhdGlvbk9ic2VydmVyJ10pIHtcbiAgICAgICAgY29uc29sZSQxLmNyaXRpY2FsKCdCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgTXV0YXRpb25PYnNlcnZlcjsgc2tpcHBpbmcgc2Vzc2lvbiByZWNvcmRpbmcnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsb2FkUmVjb3JkZXIgPSBfLmJpbmQoZnVuY3Rpb24oc3RhcnROZXdJZkluYWN0aXZlKSB7XG4gICAgICAgIHZhciBoYW5kbGVMb2FkZWRSZWNvcmRlciA9IF8uYmluZChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlY29yZGVyID0gdGhpcy5fcmVjb3JkZXIgfHwgbmV3IHdpblsnX19tcF9yZWNvcmRlciddKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcmVjb3JkZXJbJ3Jlc3VtZVJlY29yZGluZyddKHN0YXJ0TmV3SWZJbmFjdGl2ZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHdpblsnX19tcF9yZWNvcmRlciddKSkge1xuICAgICAgICAgICAgbG9hZF9leHRyYV9idW5kbGUodGhpcy5nZXRfY29uZmlnKCdyZWNvcmRlcl9zcmMnKSwgaGFuZGxlTG9hZGVkUmVjb3JkZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlTG9hZGVkUmVjb3JkZXIoKTtcbiAgICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIHVzZXIgaXMgc2FtcGxlZCBvciBzdGFydF9zZXNzaW9uX3JlY29yZGluZyBpcyBjYWxsZWQsIHdlIGFsd2F5cyBsb2FkIHRoZSByZWNvcmRlciBzaW5jZSBpdCdzIGd1YXJhbnRlZWQgYSByZWNvcmRpbmcgc2hvdWxkIHN0YXJ0LlxuICAgICAqIE90aGVyd2lzZSwgaWYgdGhlIHJlY29yZGluZyByZWdpc3RyeSBoYXMgYW55IHJlY29yZHMgdGhlbiBpdCdzIGxpa2VseSB0aGVyZSdzIGEgcmVjb3JkaW5nIGluIHByb2dyZXNzIG9yIG9ycGhhbmVkIGRhdGEgdGhhdCBuZWVkcyB0byBiZSBmbHVzaGVkLlxuICAgICAqL1xuICAgIHZhciBpc19zYW1wbGVkID0gdGhpcy5nZXRfY29uZmlnKCdyZWNvcmRfc2Vzc2lvbnNfcGVyY2VudCcpID4gMCAmJiBNYXRoLnJhbmRvbSgpICogMTAwIDw9IHRoaXMuZ2V0X2NvbmZpZygncmVjb3JkX3Nlc3Npb25zX3BlcmNlbnQnKTtcbiAgICBpZiAoZm9yY2Vfc3RhcnQgfHwgaXNfc2FtcGxlZCkge1xuICAgICAgICBsb2FkUmVjb3JkZXIodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2hvdWxkX2xvYWRfcmVjb3JkZXIoKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHNob3VsZExvYWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkTG9hZCkge1xuICAgICAgICAgICAgICAgICAgICBsb2FkUmVjb3JkZXIoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuc3RhcnRfc2Vzc2lvbl9yZWNvcmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2hlY2tfYW5kX3N0YXJ0X3Nlc3Npb25fcmVjb3JkaW5nKHRydWUpO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLnN0b3Bfc2Vzc2lvbl9yZWNvcmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlY29yZGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWNvcmRlclsnc3RvcFJlY29yZGluZyddKCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5wYXVzZV9zZXNzaW9uX3JlY29yZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVjb3JkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlY29yZGVyWydwYXVzZVJlY29yZGluZyddKCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5yZXN1bWVfc2Vzc2lvbl9yZWNvcmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlY29yZGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWNvcmRlclsncmVzdW1lUmVjb3JkaW5nJ10oKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLmlzX3JlY29yZGluZ19oZWF0bWFwX2RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldF9zZXNzaW9uX3JlcGxheV9pZCgpICYmIHRoaXMuZ2V0X2NvbmZpZygncmVjb3JkX2hlYXRtYXBfZGF0YScpO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9zZXNzaW9uX3JlY29yZGluZ19wcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciByZXBsYXlfaWQgPSB0aGlzLl9nZXRfc2Vzc2lvbl9yZXBsYXlfaWQoKTtcbiAgICBpZiAocmVwbGF5X2lkKSB7XG4gICAgICAgIHByb3BzWyckbXBfcmVwbGF5X2lkJ10gPSByZXBsYXlfaWQ7XG4gICAgfVxuICAgIHJldHVybiBwcm9wcztcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfc2Vzc2lvbl9yZXBsYXlfdXJsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXBsYXlfdXJsID0gbnVsbDtcbiAgICB2YXIgcmVwbGF5X2lkID0gdGhpcy5fZ2V0X3Nlc3Npb25fcmVwbGF5X2lkKCk7XG4gICAgaWYgKHJlcGxheV9pZCkge1xuICAgICAgICB2YXIgcXVlcnlfcGFyYW1zID0gXy5IVFRQQnVpbGRRdWVyeSh7XG4gICAgICAgICAgICAncmVwbGF5X2lkJzogcmVwbGF5X2lkLFxuICAgICAgICAgICAgJ2Rpc3RpbmN0X2lkJzogdGhpcy5nZXRfZGlzdGluY3RfaWQoKSxcbiAgICAgICAgICAgICd0b2tlbic6IHRoaXMuZ2V0X2NvbmZpZygndG9rZW4nKVxuICAgICAgICB9KTtcbiAgICAgICAgcmVwbGF5X3VybCA9ICdodHRwczovL21peHBhbmVsLmNvbS9wcm9qZWN0cy9yZXBsYXktcmVkaXJlY3Q/JyArIHF1ZXJ5X3BhcmFtcztcbiAgICB9XG4gICAgcmV0dXJuIHJlcGxheV91cmw7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2dldF9zZXNzaW9uX3JlcGxheV9pZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVwbGF5X2lkID0gbnVsbDtcbiAgICBpZiAodGhpcy5fcmVjb3JkZXIpIHtcbiAgICAgICAgcmVwbGF5X2lkID0gdGhpcy5fcmVjb3JkZXJbJ3JlcGxheUlkJ107XG4gICAgfVxuICAgIHJldHVybiByZXBsYXlfaWQgfHwgbnVsbDtcbn07XG5cbi8vIFwicHJpdmF0ZVwiIHB1YmxpYyBtZXRob2QgdG8gcmVhY2ggaW50byB0aGUgcmVjb3JkZXIgaW4gdGVzdCBjYXNlc1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9fZ2V0X3JlY29yZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWNvcmRlcjtcbn07XG5cbi8vIFByaXZhdGUgbWV0aG9kc1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2xvYWRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZ2V0X2NvbmZpZygnbG9hZGVkJykodGhpcyk7XG4gICAgdGhpcy5fc2V0X2RlZmF1bHRfc3VwZXJwcm9wcygpO1xuICAgIHRoaXNbJ3Blb3BsZSddLnNldF9vbmNlKHRoaXNbJ3BlcnNpc3RlbmNlJ10uZ2V0X3JlZmVycmVyX2luZm8oKSk7XG5cbiAgICAvLyBgc3RvcmVfZ29vZ2xlYCBpcyBub3cgZGVwcmVjYXRlZCBhbmQgcHJldmlvdXNseSBzdG9yZWQgVVRNIHBhcmFtZXRlcnMgYXJlIGNsZWFyZWRcbiAgICAvLyBmcm9tIHBlcnNpc3RlbmNlIGJ5IGRlZmF1bHQuXG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygnc3RvcmVfZ29vZ2xlJykgJiYgdGhpcy5nZXRfY29uZmlnKCdzdG9wX3V0bV9wZXJzaXN0ZW5jZScpKSB7XG4gICAgICAgIHZhciB1dG1fcGFyYW1zID0gXy5pbmZvLmNhbXBhaWduUGFyYW1zKG51bGwpO1xuICAgICAgICBfLmVhY2godXRtX3BhcmFtcywgZnVuY3Rpb24oX3V0bV92YWx1ZSwgdXRtX2tleSkge1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byB1bnJlZ2lzdGVyIHBlcnNpc3RlZCBVVE0gcGFyYW1ldGVycyBzbyBvbGQgdmFsdWVzXG4gICAgICAgICAgICAvLyBhcmUgbm90IG1peGVkIHdpdGggdGhlIG5ldyBVVE0gcGFyYW1ldGVyc1xuICAgICAgICAgICAgdGhpcy51bnJlZ2lzdGVyKHV0bV9rZXkpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cbn07XG5cbi8vIHVwZGF0ZSBwZXJzaXN0ZW5jZSB3aXRoIGluZm8gb24gcmVmZXJyZXIsIFVUTSBwYXJhbXMsIGV0Y1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9zZXRfZGVmYXVsdF9zdXBlcnByb3BzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpc1sncGVyc2lzdGVuY2UnXS51cGRhdGVfc2VhcmNoX2tleXdvcmQoZG9jdW1lbnQkMS5yZWZlcnJlcik7XG4gICAgLy8gUmVnaXN0ZXJpbmcgc3VwZXIgcHJvcGVydGllcyBmb3IgVVRNIHBlcnNpc3RlbmNlIGJ5ICdzdG9yZV9nb29nbGUnIGlzIGRlcHJlY2F0ZWQuXG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygnc3RvcmVfZ29vZ2xlJykgJiYgIXRoaXMuZ2V0X2NvbmZpZygnc3RvcF91dG1fcGVyc2lzdGVuY2UnKSkge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKF8uaW5mby5jYW1wYWlnblBhcmFtcygpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygnc2F2ZV9yZWZlcnJlcicpKSB7XG4gICAgICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10udXBkYXRlX3JlZmVycmVyX2luZm8oZG9jdW1lbnQkMS5yZWZlcnJlcik7XG4gICAgfVxufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9kb21fbG9hZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgXy5lYWNoKHRoaXMuX19kb21fbG9hZGVkX3F1ZXVlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHRoaXMuX3RyYWNrX2RvbS5hcHBseSh0aGlzLCBpdGVtKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIGlmICghdGhpcy5oYXNfb3B0ZWRfb3V0X3RyYWNraW5nKCkpIHtcbiAgICAgICAgXy5lYWNoKHRoaXMuX19yZXF1ZXN0X3F1ZXVlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICB0aGlzLl9zZW5kX3JlcXVlc3QuYXBwbHkodGhpcywgaXRlbSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLl9fZG9tX2xvYWRlZF9xdWV1ZTtcbiAgICBkZWxldGUgdGhpcy5fX3JlcXVlc3RfcXVldWU7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX3RyYWNrX2RvbSA9IGZ1bmN0aW9uKERvbUNsYXNzLCBhcmdzKSB7XG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygnaW1nJykpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoJ1lvdSBjYW5cXCd0IHVzZSBET00gdHJhY2tpbmcgZnVuY3Rpb25zIHdpdGggaW1nID0gdHJ1ZS4nKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghRE9NX0xPQURFRCkge1xuICAgICAgICB0aGlzLl9fZG9tX2xvYWRlZF9xdWV1ZS5wdXNoKFtEb21DbGFzcywgYXJnc10pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGR0ID0gbmV3IERvbUNsYXNzKCkuaW5pdCh0aGlzKTtcbiAgICByZXR1cm4gZHQudHJhY2suYXBwbHkoZHQsIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBfcHJlcGFyZV9jYWxsYmFjaygpIHNob3VsZCBiZSBjYWxsZWQgYnkgY2FsbGVycyBvZiBfc2VuZF9yZXF1ZXN0IGZvciB1c2VcbiAqIGFzIHRoZSBjYWxsYmFjayBhcmd1bWVudC5cbiAqXG4gKiBJZiB0aGVyZSBpcyBubyBjYWxsYmFjaywgdGhpcyByZXR1cm5zIG51bGwuXG4gKiBJZiB3ZSBhcmUgZ29pbmcgdG8gbWFrZSBYSFIvWERSIHJlcXVlc3RzLCB0aGlzIHJldHVybnMgYSBmdW5jdGlvbi5cbiAqIElmIHdlIGFyZSBnb2luZyB0byB1c2Ugc2NyaXB0IHRhZ3MsIHRoaXMgcmV0dXJucyBhIHN0cmluZyB0byB1c2UgYXMgdGhlXG4gKiBjYWxsYmFjayBHRVQgcGFyYW0uXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fcHJlcGFyZV9jYWxsYmFjayA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBkYXRhKSB7XG4gICAgaWYgKF8uaXNVbmRlZmluZWQoY2FsbGJhY2spKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChVU0VfWEhSKSB7XG4gICAgICAgIHZhciBjYWxsYmFja19mdW5jdGlvbiA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZSwgZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjYWxsYmFja19mdW5jdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiB0aGUgdXNlciBnaXZlcyB1cyBhIGNhbGxiYWNrLCB3ZSBzdG9yZSBhcyBhIHJhbmRvbVxuICAgICAgICAvLyBwcm9wZXJ0eSBvbiB0aGlzIGluc3RhbmNlcyBqc2MgZnVuY3Rpb24gYW5kIHVwZGF0ZSBvdXJcbiAgICAgICAgLy8gY2FsbGJhY2sgc3RyaW5nIHRvIHJlZmxlY3QgdGhhdC5cbiAgICAgICAgdmFyIGpzYyA9IHRoaXNbJ19qc2MnXTtcbiAgICAgICAgdmFyIHJhbmRvbWl6ZWRfY2IgPSAnJyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMCk7XG4gICAgICAgIHZhciBjYWxsYmFja19zdHJpbmcgPSB0aGlzLmdldF9jb25maWcoJ2NhbGxiYWNrX2ZuJykgKyAnWycgKyByYW5kb21pemVkX2NiICsgJ10nO1xuICAgICAgICBqc2NbcmFuZG9taXplZF9jYl0gPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgZGVsZXRlIGpzY1tyYW5kb21pemVkX2NiXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlLCBkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrX3N0cmluZztcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX3NlbmRfcmVxdWVzdCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICB2YXIgc3VjY2VlZGVkID0gdHJ1ZTtcblxuICAgIGlmIChFTlFVRVVFX1JFUVVFU1RTKSB7XG4gICAgICAgIHRoaXMuX19yZXF1ZXN0X3F1ZXVlLnB1c2goYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHN1Y2NlZWRlZDtcbiAgICB9XG5cbiAgICB2YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgICAgICBtZXRob2Q6IHRoaXMuZ2V0X2NvbmZpZygnYXBpX21ldGhvZCcpLFxuICAgICAgICB0cmFuc3BvcnQ6IHRoaXMuZ2V0X2NvbmZpZygnYXBpX3RyYW5zcG9ydCcpLFxuICAgICAgICB2ZXJib3NlOiB0aGlzLmdldF9jb25maWcoJ3ZlcmJvc2UnKVxuICAgIH07XG4gICAgdmFyIGJvZHlfZGF0YSA9IG51bGw7XG5cbiAgICBpZiAoIWNhbGxiYWNrICYmIChfLmlzRnVuY3Rpb24ob3B0aW9ucykgfHwgdHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgIH1cbiAgICBvcHRpb25zID0gXy5leHRlbmQoREVGQVVMVF9PUFRJT05TLCBvcHRpb25zIHx8IHt9KTtcbiAgICBpZiAoIVVTRV9YSFIpIHtcbiAgICAgICAgb3B0aW9ucy5tZXRob2QgPSAnR0VUJztcbiAgICB9XG4gICAgdmFyIHVzZV9wb3N0ID0gb3B0aW9ucy5tZXRob2QgPT09ICdQT1NUJztcbiAgICB2YXIgdXNlX3NlbmRCZWFjb24gPSBzZW5kQmVhY29uICYmIHVzZV9wb3N0ICYmIG9wdGlvbnMudHJhbnNwb3J0LnRvTG93ZXJDYXNlKCkgPT09ICdzZW5kYmVhY29uJztcblxuICAgIC8vIG5lZWRlZCB0byBjb3JyZWN0bHkgZm9ybWF0IHJlc3BvbnNlc1xuICAgIHZhciB2ZXJib3NlX21vZGUgPSBvcHRpb25zLnZlcmJvc2U7XG4gICAgaWYgKGRhdGFbJ3ZlcmJvc2UnXSkgeyB2ZXJib3NlX21vZGUgPSB0cnVlOyB9XG5cbiAgICBpZiAodGhpcy5nZXRfY29uZmlnKCd0ZXN0JykpIHsgZGF0YVsndGVzdCddID0gMTsgfVxuICAgIGlmICh2ZXJib3NlX21vZGUpIHsgZGF0YVsndmVyYm9zZSddID0gMTsgfVxuICAgIGlmICh0aGlzLmdldF9jb25maWcoJ2ltZycpKSB7IGRhdGFbJ2ltZyddID0gMTsgfVxuICAgIGlmICghVVNFX1hIUikge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGRhdGFbJ2NhbGxiYWNrJ10gPSBjYWxsYmFjaztcbiAgICAgICAgfSBlbHNlIGlmICh2ZXJib3NlX21vZGUgfHwgdGhpcy5nZXRfY29uZmlnKCd0ZXN0JykpIHtcbiAgICAgICAgICAgIC8vIFZlcmJvc2Ugb3V0cHV0IChmcm9tIHZlcmJvc2UgbW9kZSwgb3IgYW4gZXJyb3IgaW4gdGVzdCBtb2RlKSBpcyBhIGpzb24gYmxvYixcbiAgICAgICAgICAgIC8vIHdoaWNoIGJ5IGl0c2VsZiBpcyBub3QgdmFsaWQgamF2YXNjcmlwdC4gV2l0aG91dCBhIGNhbGxiYWNrLCB0aGlzIHZlcmJvc2Ugb3V0cHV0IHdpbGxcbiAgICAgICAgICAgIC8vIGNhdXNlIGFuIGVycm9yIHdoZW4gcmV0dXJuZWQgdmlhIGpzb25wLCBzbyB3ZSBmb3JjZSBhIG5vLW9wIGNhbGxiYWNrIHBhcmFtLlxuICAgICAgICAgICAgLy8gU2VlIHRoZSBFQ01BIHNjcmlwdCBzcGVjOiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtMTIuNFxuICAgICAgICAgICAgZGF0YVsnY2FsbGJhY2snXSA9ICcoZnVuY3Rpb24oKXt9KSc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkYXRhWydpcCddID0gdGhpcy5nZXRfY29uZmlnKCdpcCcpPzE6MDtcbiAgICBkYXRhWydfJ10gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKS50b1N0cmluZygpO1xuXG4gICAgaWYgKHVzZV9wb3N0KSB7XG4gICAgICAgIGJvZHlfZGF0YSA9ICdkYXRhPScgKyBlbmNvZGVVUklDb21wb25lbnQoZGF0YVsnZGF0YSddKTtcbiAgICAgICAgZGVsZXRlIGRhdGFbJ2RhdGEnXTtcbiAgICB9XG5cbiAgICBfLmV4dGVuZChkYXRhLCB0aGlzLmdldF9jb25maWcoJ2FwaV9leHRyYV9xdWVyeV9wYXJhbXMnKSk7XG5cbiAgICB1cmwgKz0gJz8nICsgXy5IVFRQQnVpbGRRdWVyeShkYXRhKTtcblxuICAgIHZhciBsaWIgPSB0aGlzO1xuICAgIGlmICgnaW1nJyBpbiBkYXRhKSB7XG4gICAgICAgIHZhciBpbWcgPSBkb2N1bWVudCQxLmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgICBpbWcuc3JjID0gdXJsO1xuICAgICAgICBkb2N1bWVudCQxLmJvZHkuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICB9IGVsc2UgaWYgKHVzZV9zZW5kQmVhY29uKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdWNjZWVkZWQgPSBzZW5kQmVhY29uKHVybCwgYm9keV9kYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbGliLnJlcG9ydF9lcnJvcihlKTtcbiAgICAgICAgICAgIHN1Y2NlZWRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhzdWNjZWVkZWQgPyAxIDogMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxpYi5yZXBvcnRfZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFVTRV9YSFIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHJlcS5vcGVuKG9wdGlvbnMubWV0aG9kLCB1cmwsIHRydWUpO1xuXG4gICAgICAgICAgICB2YXIgaGVhZGVycyA9IHRoaXMuZ2V0X2NvbmZpZygneGhyX2hlYWRlcnMnKTtcbiAgICAgICAgICAgIGlmICh1c2VfcG9zdCkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfLmVhY2goaGVhZGVycywgZnVuY3Rpb24oaGVhZGVyVmFsdWUsIGhlYWRlck5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXJOYW1lLCBoZWFkZXJWYWx1ZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudGltZW91dF9tcyAmJiB0eXBlb2YgcmVxLnRpbWVvdXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmVxLnRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXRfbXM7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0X3RpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2VuZCB0aGUgbXBfb3B0b3V0IGNvb2tpZVxuICAgICAgICAgICAgLy8gd2l0aENyZWRlbnRpYWxzIGNhbm5vdCBiZSBtb2RpZmllZCB1bnRpbCBhZnRlciBjYWxsaW5nIC5vcGVuIG9uIEFuZHJvaWQgYW5kIE1vYmlsZSBTYWZhcmlcbiAgICAgICAgICAgIHJlcS53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgICAgICAgcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxLnJlYWR5U3RhdGUgPT09IDQpIHsgLy8gWE1MSHR0cFJlcXVlc3QuRE9ORSA9PSA0LCBleGNlcHQgaW4gc2FmYXJpIDRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcmJvc2VfbW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF8uSlNPTkRlY29kZShyZXEucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGliLnJlcG9ydF9lcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmlnbm9yZV9qc29uX2Vycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gcmVxLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhOdW1iZXIocmVxLnJlc3BvbnNlVGV4dCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEudGltZW91dCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFyZXEuc3RhdHVzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydF90aW1lID49IHJlcS50aW1lb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9ICd0aW1lb3V0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSAnQmFkIEhUVFAgc3RhdHVzOiAnICsgcmVxLnN0YXR1cyArICcgJyArIHJlcS5zdGF0dXNUZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGliLnJlcG9ydF9lcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmVyYm9zZV9tb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZV9oZWFkZXJzID0gcmVxWydyZXNwb25zZUhlYWRlcnMnXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soe3N0YXR1czogMCwgaHR0cFN0YXR1c0NvZGU6IHJlcVsnc3RhdHVzJ10sIGVycm9yOiBlcnJvciwgcmV0cnlBZnRlcjogcmVzcG9uc2VfaGVhZGVyc1snUmV0cnktQWZ0ZXInXX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXEuc2VuZChib2R5X2RhdGEpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsaWIucmVwb3J0X2Vycm9yKGUpO1xuICAgICAgICAgICAgc3VjY2VlZGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQkMS5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgc2NyaXB0LmRlZmVyID0gdHJ1ZTtcbiAgICAgICAgc2NyaXB0LnNyYyA9IHVybDtcbiAgICAgICAgdmFyIHMgPSBkb2N1bWVudCQxLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXTtcbiAgICAgICAgcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzY3JpcHQsIHMpO1xuICAgIH1cblxuICAgIHJldHVybiBzdWNjZWVkZWQ7XG59O1xuXG4vKipcbiAqIF9leGVjdXRlX2FycmF5KCkgZGVhbHMgd2l0aCBwcm9jZXNzaW5nIGFueSBtaXhwYW5lbCBmdW5jdGlvblxuICogY2FsbHMgdGhhdCB3ZXJlIGNhbGxlZCBiZWZvcmUgdGhlIE1peHBhbmVsIGxpYnJhcnkgd2VyZSBsb2FkZWRcbiAqIChhbmQgYXJlIHRodXMgc3RvcmVkIGluIGFuIGFycmF5IHNvIHRoZXkgY2FuIGJlIGNhbGxlZCBsYXRlcilcbiAqXG4gKiBOb3RlOiB3ZSBmaXJlIG9mZiBhbGwgdGhlIG1peHBhbmVsIGZ1bmN0aW9uIGNhbGxzICYmIHVzZXIgZGVmaW5lZFxuICogZnVuY3Rpb25zIEJFRk9SRSB3ZSBmaXJlIG9mZiBtaXhwYW5lbCB0cmFja2luZyBjYWxscy4gVGhpcyBpcyBzb1xuICogaWRlbnRpZnkvcmVnaXN0ZXIvc2V0X2NvbmZpZyBjYWxscyBjYW4gcHJvcGVybHkgbW9kaWZ5IGVhcmx5XG4gKiB0cmFja2luZyBjYWxscy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2V4ZWN1dGVfYXJyYXkgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciBmbl9uYW1lLCBhbGlhc19jYWxscyA9IFtdLCBvdGhlcl9jYWxscyA9IFtdLCB0cmFja2luZ19jYWxscyA9IFtdO1xuICAgIF8uZWFjaChhcnJheSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgZm5fbmFtZSA9IGl0ZW1bMF07XG4gICAgICAgICAgICBpZiAoXy5pc0FycmF5KGZuX25hbWUpKSB7XG4gICAgICAgICAgICAgICAgdHJhY2tpbmdfY2FsbHMucHVzaChpdGVtKTsgLy8gY2hhaW5lZCBjYWxsIGUuZy4gbWl4cGFuZWwuZ2V0X2dyb3VwKCkuc2V0KClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKGl0ZW0pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChfLmlzQXJyYXkoaXRlbSkgJiYgZm5fbmFtZSA9PT0gJ2FsaWFzJykge1xuICAgICAgICAgICAgICAgIGFsaWFzX2NhbGxzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF8uaXNBcnJheShpdGVtKSAmJiBmbl9uYW1lLmluZGV4T2YoJ3RyYWNrJykgIT09IC0xICYmIHR5cGVvZih0aGlzW2ZuX25hbWVdKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRyYWNraW5nX2NhbGxzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG90aGVyX2NhbGxzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIHZhciBleGVjdXRlID0gZnVuY3Rpb24oY2FsbHMsIGNvbnRleHQpIHtcbiAgICAgICAgXy5lYWNoKGNhbGxzLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICBpZiAoXy5pc0FycmF5KGl0ZW1bMF0pKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hhaW5lZCBjYWxsXG4gICAgICAgICAgICAgICAgdmFyIGNhbGxlciA9IGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgXy5lYWNoKGl0ZW0sIGZ1bmN0aW9uKGNhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGVyID0gY2FsbGVyW2NhbGxbMF1dLmFwcGx5KGNhbGxlciwgY2FsbC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbaXRlbVswXV0uYXBwbHkodGhpcywgaXRlbS5zbGljZSgxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGNvbnRleHQpO1xuICAgIH07XG5cbiAgICBleGVjdXRlKGFsaWFzX2NhbGxzLCB0aGlzKTtcbiAgICBleGVjdXRlKG90aGVyX2NhbGxzLCB0aGlzKTtcbiAgICBleGVjdXRlKHRyYWNraW5nX2NhbGxzLCB0aGlzKTtcbn07XG5cbi8vIHJlcXVlc3QgcXVldWVpbmcgdXRpbHNcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLmFyZV9iYXRjaGVyc19pbml0aWFsaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhIXRoaXMucmVxdWVzdF9iYXRjaGVycy5ldmVudHM7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X2JhdGNoZXJfY29uZmlncyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBxdWV1ZV9wcmVmaXggPSAnX19tcHFfJyArIHRoaXMuZ2V0X2NvbmZpZygndG9rZW4nKTtcbiAgICB0aGlzLl9iYXRjaGVyX2NvbmZpZ3MgPSB0aGlzLl9iYXRjaGVyX2NvbmZpZ3MgfHwge1xuICAgICAgICBldmVudHM6IHt0eXBlOiAnZXZlbnRzJywgYXBpX25hbWU6ICd0cmFjaycsIHF1ZXVlX2tleTogcXVldWVfcHJlZml4ICsgJ19ldid9LFxuICAgICAgICBwZW9wbGU6IHt0eXBlOiAncGVvcGxlJywgYXBpX25hbWU6ICdlbmdhZ2UnLCBxdWV1ZV9rZXk6IHF1ZXVlX3ByZWZpeCArICdfcHAnfSxcbiAgICAgICAgZ3JvdXBzOiB7dHlwZTogJ2dyb3VwcycsIGFwaV9uYW1lOiAnZ3JvdXBzJywgcXVldWVfa2V5OiBxdWV1ZV9wcmVmaXggKyAnX2dyJ31cbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9iYXRjaGVyX2NvbmZpZ3M7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuaW5pdF9iYXRjaGVycyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5hcmVfYmF0Y2hlcnNfaW5pdGlhbGl6ZWQoKSkge1xuICAgICAgICB2YXIgYmF0Y2hlcl9mb3IgPSBfLmJpbmQoZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVxdWVzdEJhdGNoZXIoXG4gICAgICAgICAgICAgICAgYXR0cnMucXVldWVfa2V5LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGliQ29uZmlnOiB0aGlzWydjb25maWcnXSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JSZXBvcnRlcjogdGhpcy5nZXRfY29uZmlnKCdlcnJvcl9yZXBvcnRlcicpLFxuICAgICAgICAgICAgICAgICAgICBzZW5kUmVxdWVzdEZ1bmM6IF8uYmluZChmdW5jdGlvbihkYXRhLCBvcHRpb25zLCBjYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFwaV9yb3V0ZXMgPSB0aGlzLmdldF9jb25maWcoJ2FwaV9yb3V0ZXMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbmRfcmVxdWVzdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldF9hcGlfaG9zdChhdHRycy5hcGlfbmFtZSkgKyAnLycgKyBhcGlfcm91dGVzW2F0dHJzLmFwaV9uYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbmNvZGVfZGF0YV9mb3JfcmVxdWVzdChkYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByZXBhcmVfY2FsbGJhY2soY2IsIGRhdGEpXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlU2VuZEhvb2s6IF8uYmluZChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcnVuX2hvb2soJ2JlZm9yZV9zZW5kXycgKyBhdHRycy50eXBlLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyksXG4gICAgICAgICAgICAgICAgICAgIHN0b3BBbGxCYXRjaGluZ0Z1bmM6IF8uYmluZCh0aGlzLnN0b3BfYmF0Y2hfc2VuZGVycywgdGhpcyksXG4gICAgICAgICAgICAgICAgICAgIHVzZVBlcnNpc3RlbmNlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB2YXIgYmF0Y2hlcl9jb25maWdzID0gdGhpcy5nZXRfYmF0Y2hlcl9jb25maWdzKCk7XG4gICAgICAgIHRoaXMucmVxdWVzdF9iYXRjaGVycyA9IHtcbiAgICAgICAgICAgIGV2ZW50czogYmF0Y2hlcl9mb3IoYmF0Y2hlcl9jb25maWdzLmV2ZW50cyksXG4gICAgICAgICAgICBwZW9wbGU6IGJhdGNoZXJfZm9yKGJhdGNoZXJfY29uZmlncy5wZW9wbGUpLFxuICAgICAgICAgICAgZ3JvdXBzOiBiYXRjaGVyX2ZvcihiYXRjaGVyX2NvbmZpZ3MuZ3JvdXBzKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5nZXRfY29uZmlnKCdiYXRjaF9hdXRvc3RhcnQnKSkge1xuICAgICAgICB0aGlzLnN0YXJ0X2JhdGNoX3NlbmRlcnMoKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuc3RhcnRfYmF0Y2hfc2VuZGVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2JhdGNoZXJzX3dlcmVfc3RhcnRlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMuYXJlX2JhdGNoZXJzX2luaXRpYWxpemVkKCkpIHtcbiAgICAgICAgdGhpcy5fYmF0Y2hfcmVxdWVzdHMgPSB0cnVlO1xuICAgICAgICBfLmVhY2godGhpcy5yZXF1ZXN0X2JhdGNoZXJzLCBmdW5jdGlvbihiYXRjaGVyKSB7XG4gICAgICAgICAgICBiYXRjaGVyLnN0YXJ0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5zdG9wX2JhdGNoX3NlbmRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9iYXRjaF9yZXF1ZXN0cyA9IGZhbHNlO1xuICAgIF8uZWFjaCh0aGlzLnJlcXVlc3RfYmF0Y2hlcnMsIGZ1bmN0aW9uKGJhdGNoZXIpIHtcbiAgICAgICAgYmF0Y2hlci5zdG9wKCk7XG4gICAgICAgIGJhdGNoZXIuY2xlYXIoKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogcHVzaCgpIGtlZXBzIHRoZSBzdGFuZGFyZCBhc3luYy1hcnJheS1wdXNoXG4gKiBiZWhhdmlvciBhcm91bmQgYWZ0ZXIgdGhlIGxpYiBpcyBsb2FkZWQuXG4gKiBUaGlzIGlzIG9ubHkgdXNlZnVsIGZvciBleHRlcm5hbCBpbnRlZ3JhdGlvbnMgdGhhdFxuICogZG8gbm90IHdpc2ggdG8gcmVseSBvbiBvdXIgY29udmVuaWVuY2UgbWV0aG9kc1xuICogKGNyZWF0ZWQgaW4gdGhlIHNuaXBwZXQpLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqICAgICBtaXhwYW5lbC5wdXNoKFsncmVnaXN0ZXInLCB7IGE6ICdiJyB9XSk7XG4gKlxuICogQHBhcmFtIHtBcnJheX0gaXRlbSBBIFtmdW5jdGlvbl9uYW1lLCBhcmdzLi4uXSBhcnJheSB0byBiZSBleGVjdXRlZFxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICB0aGlzLl9leGVjdXRlX2FycmF5KFtpdGVtXSk7XG59O1xuXG4vKipcbiAqIERpc2FibGUgZXZlbnRzIG9uIHRoZSBNaXhwYW5lbCBvYmplY3QuIElmIHBhc3NlZCBubyBhcmd1bWVudHMsXG4gKiB0aGlzIGZ1bmN0aW9uIGRpc2FibGVzIHRyYWNraW5nIG9mIGFueSBldmVudC4gSWYgcGFzc2VkIGFuXG4gKiBhcnJheSBvZiBldmVudCBuYW1lcywgdGhvc2UgZXZlbnRzIHdpbGwgYmUgZGlzYWJsZWQsIGJ1dCBvdGhlclxuICogZXZlbnRzIHdpbGwgY29udGludWUgdG8gYmUgdHJhY2tlZC5cbiAqXG4gKiBOb3RlOiB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IHN0b3Agb3RoZXIgbWl4cGFuZWwgZnVuY3Rpb25zIGZyb21cbiAqIGZpcmluZywgc3VjaCBhcyByZWdpc3RlcigpIG9yIHBlb3BsZS5zZXQoKS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBbZXZlbnRzXSBBbiBhcnJheSBvZiBldmVudCBuYW1lcyB0byBkaXNhYmxlXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24oZXZlbnRzKSB7XG4gICAgaWYgKHR5cGVvZihldmVudHMpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLl9mbGFncy5kaXNhYmxlX2FsbF9ldmVudHMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX19kaXNhYmxlZF9ldmVudHMgPSB0aGlzLl9fZGlzYWJsZWRfZXZlbnRzLmNvbmNhdChldmVudHMpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fZW5jb2RlX2RhdGFfZm9yX3JlcXVlc3QgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIGVuY29kZWRfZGF0YSA9IEpTT05TdHJpbmdpZnkoZGF0YSk7XG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygnYXBpX3BheWxvYWRfZm9ybWF0JykgPT09IFBBWUxPQURfVFlQRV9CQVNFNjQpIHtcbiAgICAgICAgZW5jb2RlZF9kYXRhID0gXy5iYXNlNjRFbmNvZGUoZW5jb2RlZF9kYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHsnZGF0YSc6IGVuY29kZWRfZGF0YX07XG59O1xuXG4vLyBpbnRlcm5hbCBtZXRob2QgZm9yIGhhbmRsaW5nIHRyYWNrIHZzIGJhdGNoLWVucXVldWUgbG9naWNcbk1peHBhbmVsTGliLnByb3RvdHlwZS5fdHJhY2tfb3JfYmF0Y2ggPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHZhciB0cnVuY2F0ZWRfZGF0YSA9IF8udHJ1bmNhdGUob3B0aW9ucy5kYXRhLCAyNTUpO1xuICAgIHZhciBlbmRwb2ludCA9IG9wdGlvbnMuZW5kcG9pbnQ7XG4gICAgdmFyIGJhdGNoZXIgPSBvcHRpb25zLmJhdGNoZXI7XG4gICAgdmFyIHNob3VsZF9zZW5kX2ltbWVkaWF0ZWx5ID0gb3B0aW9ucy5zaG91bGRfc2VuZF9pbW1lZGlhdGVseTtcbiAgICB2YXIgc2VuZF9yZXF1ZXN0X29wdGlvbnMgPSBvcHRpb25zLnNlbmRfcmVxdWVzdF9vcHRpb25zIHx8IHt9O1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgTk9PUF9GVU5DO1xuXG4gICAgdmFyIHJlcXVlc3RfZW5xdWV1ZWRfb3JfaW5pdGlhdGVkID0gdHJ1ZTtcbiAgICB2YXIgc2VuZF9yZXF1ZXN0X2ltbWVkaWF0ZWx5ID0gXy5iaW5kKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXNlbmRfcmVxdWVzdF9vcHRpb25zLnNraXBfaG9va3MpIHtcbiAgICAgICAgICAgIHRydW5jYXRlZF9kYXRhID0gdGhpcy5fcnVuX2hvb2soJ2JlZm9yZV9zZW5kXycgKyBvcHRpb25zLnR5cGUsIHRydW5jYXRlZF9kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJ1bmNhdGVkX2RhdGEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUkMS5sb2coJ01JWFBBTkVMIFJFUVVFU1Q6Jyk7XG4gICAgICAgICAgICBjb25zb2xlJDEubG9nKHRydW5jYXRlZF9kYXRhKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoXG4gICAgICAgICAgICAgICAgZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgdGhpcy5fZW5jb2RlX2RhdGFfZm9yX3JlcXVlc3QodHJ1bmNhdGVkX2RhdGEpLFxuICAgICAgICAgICAgICAgIHNlbmRfcmVxdWVzdF9vcHRpb25zLFxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXBhcmVfY2FsbGJhY2soY2FsbGJhY2ssIHRydW5jYXRlZF9kYXRhKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICBpZiAodGhpcy5fYmF0Y2hfcmVxdWVzdHMgJiYgIXNob3VsZF9zZW5kX2ltbWVkaWF0ZWx5KSB7XG4gICAgICAgIGJhdGNoZXIuZW5xdWV1ZSh0cnVuY2F0ZWRfZGF0YSkudGhlbihmdW5jdGlvbihzdWNjZWVkZWQpIHtcbiAgICAgICAgICAgIGlmIChzdWNjZWVkZWQpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygxLCB0cnVuY2F0ZWRfZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbmRfcmVxdWVzdF9pbW1lZGlhdGVseSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0X2VucXVldWVkX29yX2luaXRpYXRlZCA9IHNlbmRfcmVxdWVzdF9pbW1lZGlhdGVseSgpO1xuICAgIH1cblxuICAgIHJldHVybiByZXF1ZXN0X2VucXVldWVkX29yX2luaXRpYXRlZCAmJiB0cnVuY2F0ZWRfZGF0YTtcbn07XG5cbi8qKlxuICogVHJhY2sgYW4gZXZlbnQuIFRoaXMgaXMgdGhlIG1vc3QgaW1wb3J0YW50IGFuZFxuICogZnJlcXVlbnRseSB1c2VkIE1peHBhbmVsIGZ1bmN0aW9uLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gdHJhY2sgYW4gZXZlbnQgbmFtZWQgJ1JlZ2lzdGVyZWQnXG4gKiAgICAgbWl4cGFuZWwudHJhY2soJ1JlZ2lzdGVyZWQnLCB7J0dlbmRlcic6ICdNYWxlJywgJ0FnZSc6IDIxfSk7XG4gKlxuICogICAgIC8vIHRyYWNrIGFuIGV2ZW50IHVzaW5nIG5hdmlnYXRvci5zZW5kQmVhY29uXG4gKiAgICAgbWl4cGFuZWwudHJhY2soJ0xlZnQgcGFnZScsIHsnZHVyYXRpb25fc2Vjb25kcyc6IDM1fSwge3RyYW5zcG9ydDogJ3NlbmRCZWFjb24nfSk7XG4gKlxuICogVG8gdHJhY2sgbGluayBjbGlja3Mgb3IgZm9ybSBzdWJtaXNzaW9ucywgc2VlIHRyYWNrX2xpbmtzKCkgb3IgdHJhY2tfZm9ybXMoKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRfbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuIFRoaXMgY2FuIGJlIGFueXRoaW5nIHRoZSB1c2VyIGRvZXMgLSAnQnV0dG9uIENsaWNrJywgJ1NpZ24gVXAnLCAnSXRlbSBQdXJjaGFzZWQnLCBldGMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIEEgc2V0IG9mIHByb3BlcnRpZXMgdG8gaW5jbHVkZSB3aXRoIHRoZSBldmVudCB5b3UncmUgc2VuZGluZy4gVGhlc2UgZGVzY3JpYmUgdGhlIHVzZXIgd2hvIGRpZCB0aGUgZXZlbnQgb3IgZGV0YWlscyBhYm91dCB0aGUgZXZlbnQgaXRzZWxmLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25hbCBjb25maWd1cmF0aW9uIGZvciB0aGlzIHRyYWNrIHJlcXVlc3QuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudHJhbnNwb3J0XSBUcmFuc3BvcnQgbWV0aG9kIGZvciBuZXR3b3JrIHJlcXVlc3QgKCd4aHInIG9yICdzZW5kQmVhY29uJykuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNlbmRfaW1tZWRpYXRlbHldIFdoZXRoZXIgdG8gYnlwYXNzIGJhdGNoaW5nL3F1ZXVlaW5nIGFuZCBzZW5kIHRyYWNrIHJlcXVlc3QgaW1tZWRpYXRlbHkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuICogQHJldHVybnMge0Jvb2xlYW58T2JqZWN0fSBJZiB0aGUgdHJhY2tpbmcgcmVxdWVzdCB3YXMgc3VjY2Vzc2Z1bGx5IGluaXRpYXRlZC9xdWV1ZWQsIGFuIG9iamVjdFxuICogd2l0aCB0aGUgdHJhY2tpbmcgcGF5bG9hZCBzZW50IHRvIHRoZSBBUEkgc2VydmVyIGlzIHJldHVybmVkOyBvdGhlcndpc2UgZmFsc2UuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS50cmFjayA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIoZnVuY3Rpb24oZXZlbnRfbmFtZSwgcHJvcGVydGllcywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIWNhbGxiYWNrICYmIHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciB0cmFuc3BvcnQgPSBvcHRpb25zWyd0cmFuc3BvcnQnXTsgLy8gZXh0ZXJuYWwgQVBJLCBkb24ndCBtaW5pZnkgJ3RyYW5zcG9ydCcgcHJvcFxuICAgIGlmICh0cmFuc3BvcnQpIHtcbiAgICAgICAgb3B0aW9ucy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7IC8vICd0cmFuc3BvcnQnIHByb3AgbmFtZSBjYW4gYmUgbWluaWZpZWQgaW50ZXJuYWxseVxuICAgIH1cbiAgICB2YXIgc2hvdWxkX3NlbmRfaW1tZWRpYXRlbHkgPSBvcHRpb25zWydzZW5kX2ltbWVkaWF0ZWx5J107XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IE5PT1BfRlVOQztcbiAgICB9XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChldmVudF9uYW1lKSkge1xuICAgICAgICB0aGlzLnJlcG9ydF9lcnJvcignTm8gZXZlbnQgbmFtZSBwcm92aWRlZCB0byBtaXhwYW5lbC50cmFjaycpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50X2lzX2Rpc2FibGVkKGV2ZW50X25hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrKDApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc2V0IGRlZmF1bHRzXG4gICAgcHJvcGVydGllcyA9IF8uZXh0ZW5kKHt9LCBwcm9wZXJ0aWVzKTtcbiAgICBwcm9wZXJ0aWVzWyd0b2tlbiddID0gdGhpcy5nZXRfY29uZmlnKCd0b2tlbicpO1xuXG4gICAgLy8gc2V0ICRkdXJhdGlvbiBpZiB0aW1lX2V2ZW50IHdhcyBwcmV2aW91c2x5IGNhbGxlZCBmb3IgdGhpcyBldmVudFxuICAgIHZhciBzdGFydF90aW1lc3RhbXAgPSB0aGlzWydwZXJzaXN0ZW5jZSddLnJlbW92ZV9ldmVudF90aW1lcihldmVudF9uYW1lKTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoc3RhcnRfdGltZXN0YW1wKSkge1xuICAgICAgICB2YXIgZHVyYXRpb25faW5fbXMgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0X3RpbWVzdGFtcDtcbiAgICAgICAgcHJvcGVydGllc1snJGR1cmF0aW9uJ10gPSBwYXJzZUZsb2F0KChkdXJhdGlvbl9pbl9tcyAvIDEwMDApLnRvRml4ZWQoMykpO1xuICAgIH1cblxuICAgIHRoaXMuX3NldF9kZWZhdWx0X3N1cGVycHJvcHMoKTtcblxuICAgIHZhciBtYXJrZXRpbmdfcHJvcGVydGllcyA9IHRoaXMuZ2V0X2NvbmZpZygndHJhY2tfbWFya2V0aW5nJylcbiAgICAgICAgPyBfLmluZm8ubWFya2V0aW5nUGFyYW1zKClcbiAgICAgICAgOiB7fTtcblxuICAgIC8vIG5vdGU6IGV4dGVuZCB3cml0ZXMgdG8gdGhlIGZpcnN0IG9iamVjdCwgc28gbGV0cyBtYWtlIHN1cmUgd2VcbiAgICAvLyBkb24ndCB3cml0ZSB0byB0aGUgcGVyc2lzdGVuY2UgcHJvcGVydGllcyBvYmplY3QgYW5kIGluZm9cbiAgICAvLyBwcm9wZXJ0aWVzIG9iamVjdCBieSBwYXNzaW5nIGluIGEgbmV3IG9iamVjdFxuXG4gICAgLy8gdXBkYXRlIHByb3BlcnRpZXMgd2l0aCBwYWdldmlldyBpbmZvIGFuZCBzdXBlci1wcm9wZXJ0aWVzXG4gICAgcHJvcGVydGllcyA9IF8uZXh0ZW5kKFxuICAgICAgICB7fSxcbiAgICAgICAgXy5pbmZvLnByb3BlcnRpZXMoeydtcF9sb2FkZXInOiB0aGlzLmdldF9jb25maWcoJ21wX2xvYWRlcicpfSksXG4gICAgICAgIG1hcmtldGluZ19wcm9wZXJ0aWVzLFxuICAgICAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnByb3BlcnRpZXMoKSxcbiAgICAgICAgdGhpcy51bnBlcnNpc3RlZF9zdXBlcnByb3BzLFxuICAgICAgICB0aGlzLmdldF9zZXNzaW9uX3JlY29yZGluZ19wcm9wZXJ0aWVzKCksXG4gICAgICAgIHByb3BlcnRpZXNcbiAgICApO1xuXG4gICAgdmFyIHByb3BlcnR5X2JsYWNrbGlzdCA9IHRoaXMuZ2V0X2NvbmZpZygncHJvcGVydHlfYmxhY2tsaXN0Jyk7XG4gICAgaWYgKF8uaXNBcnJheShwcm9wZXJ0eV9ibGFja2xpc3QpKSB7XG4gICAgICAgIF8uZWFjaChwcm9wZXJ0eV9ibGFja2xpc3QsIGZ1bmN0aW9uKGJsYWNrbGlzdGVkX3Byb3ApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBwcm9wZXJ0aWVzW2JsYWNrbGlzdGVkX3Byb3BdO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlcG9ydF9lcnJvcignSW52YWxpZCB2YWx1ZSBmb3IgcHJvcGVydHlfYmxhY2tsaXN0IGNvbmZpZzogJyArIHByb3BlcnR5X2JsYWNrbGlzdCk7XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICdldmVudCc6IGV2ZW50X25hbWUsXG4gICAgICAgICdwcm9wZXJ0aWVzJzogcHJvcGVydGllc1xuICAgIH07XG4gICAgdmFyIHJldCA9IHRoaXMuX3RyYWNrX29yX2JhdGNoKHtcbiAgICAgICAgdHlwZTogJ2V2ZW50cycsXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGVuZHBvaW50OiB0aGlzLmdldF9hcGlfaG9zdCgnZXZlbnRzJykgKyAnLycgKyB0aGlzLmdldF9jb25maWcoJ2FwaV9yb3V0ZXMnKVsndHJhY2snXSxcbiAgICAgICAgYmF0Y2hlcjogdGhpcy5yZXF1ZXN0X2JhdGNoZXJzLmV2ZW50cyxcbiAgICAgICAgc2hvdWxkX3NlbmRfaW1tZWRpYXRlbHk6IHNob3VsZF9zZW5kX2ltbWVkaWF0ZWx5LFxuICAgICAgICBzZW5kX3JlcXVlc3Rfb3B0aW9uczogb3B0aW9uc1xuICAgIH0sIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiByZXQ7XG59KTtcblxuLyoqXG4gKiBSZWdpc3RlciB0aGUgY3VycmVudCB1c2VyIGludG8gb25lL21hbnkgZ3JvdXBzLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgIG1peHBhbmVsLnNldF9ncm91cCgnY29tcGFueScsIFsnbWl4cGFuZWwnLCAnZ29vZ2xlJ10pIC8vIGFuIGFycmF5IG9mIElEc1xuICogICAgICBtaXhwYW5lbC5zZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKVxuICogICAgICBtaXhwYW5lbC5zZXRfZ3JvdXAoJ2NvbXBhbnknLCAxMjg3NDYzMTIpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwX2tleSBHcm91cCBrZXlcbiAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfE51bWJlcn0gZ3JvdXBfaWRzIEFuIGFycmF5IG9mIGdyb3VwIElEcywgb3IgYSBzaW5ndWxhciBncm91cCBJRFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiAqXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5zZXRfZ3JvdXAgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliKGZ1bmN0aW9uKGdyb3VwX2tleSwgZ3JvdXBfaWRzLCBjYWxsYmFjaykge1xuICAgIGlmICghXy5pc0FycmF5KGdyb3VwX2lkcykpIHtcbiAgICAgICAgZ3JvdXBfaWRzID0gW2dyb3VwX2lkc107XG4gICAgfVxuICAgIHZhciBwcm9wID0ge307XG4gICAgcHJvcFtncm91cF9rZXldID0gZ3JvdXBfaWRzO1xuICAgIHRoaXMucmVnaXN0ZXIocHJvcCk7XG4gICAgcmV0dXJuIHRoaXNbJ3Blb3BsZSddLnNldChncm91cF9rZXksIGdyb3VwX2lkcywgY2FsbGJhY2spO1xufSk7XG5cbi8qKlxuICogQWRkIGEgbmV3IGdyb3VwIGZvciB0aGlzIHVzZXIuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAgbWl4cGFuZWwuYWRkX2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBfa2V5IEdyb3VwIGtleVxuICogQHBhcmFtIHsqfSBncm91cF9pZCBBIHZhbGlkIE1peHBhbmVsIHByb3BlcnR5IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5hZGRfZ3JvdXAgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliKGZ1bmN0aW9uKGdyb3VwX2tleSwgZ3JvdXBfaWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9sZF92YWx1ZXMgPSB0aGlzLmdldF9wcm9wZXJ0eShncm91cF9rZXkpO1xuICAgIHZhciBwcm9wID0ge307XG4gICAgaWYgKG9sZF92YWx1ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wW2dyb3VwX2tleV0gPSBbZ3JvdXBfaWRdO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHByb3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvbGRfdmFsdWVzLmluZGV4T2YoZ3JvdXBfaWQpID09PSAtMSkge1xuICAgICAgICAgICAgb2xkX3ZhbHVlcy5wdXNoKGdyb3VwX2lkKTtcbiAgICAgICAgICAgIHByb3BbZ3JvdXBfa2V5XSA9IG9sZF92YWx1ZXM7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyKHByb3ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzWydwZW9wbGUnXS51bmlvbihncm91cF9rZXksIGdyb3VwX2lkLCBjYWxsYmFjayk7XG59KTtcblxuLyoqXG4gKiBSZW1vdmUgYSBncm91cCBmcm9tIHRoaXMgdXNlci5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgICBtaXhwYW5lbC5yZW1vdmVfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBncm91cF9rZXkgR3JvdXAga2V5XG4gKiBAcGFyYW0geyp9IGdyb3VwX2lkIEEgdmFsaWQgTWl4cGFuZWwgcHJvcGVydHkgdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlbW92ZV9ncm91cCA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIoZnVuY3Rpb24oZ3JvdXBfa2V5LCBncm91cF9pZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgb2xkX3ZhbHVlID0gdGhpcy5nZXRfcHJvcGVydHkoZ3JvdXBfa2V5KTtcbiAgICAvLyBpZiB0aGUgdmFsdWUgZG9lc24ndCBleGlzdCwgdGhlIHBlcnNpc3RlbnQgc3RvcmUgaXMgdW5jaGFuZ2VkXG4gICAgaWYgKG9sZF92YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBpZHggPSBvbGRfdmFsdWUuaW5kZXhPZihncm91cF9pZCk7XG4gICAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICAgICAgb2xkX3ZhbHVlLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlcih7Z3JvdXBfa2V5OiBvbGRfdmFsdWV9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkX3ZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy51bnJlZ2lzdGVyKGdyb3VwX2tleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXNbJ3Blb3BsZSddLnJlbW92ZShncm91cF9rZXksIGdyb3VwX2lkLCBjYWxsYmFjayk7XG59KTtcblxuLyoqXG4gKiBUcmFjayBhbiBldmVudCB3aXRoIHNwZWNpZmljIGdyb3Vwcy5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgICBtaXhwYW5lbC50cmFja193aXRoX2dyb3VwcygncHVyY2hhc2UnLCB7J3Byb2R1Y3QnOiAnaXBob25lJ30sIHsnVW5pdmVyc2l0eSc6IFsnVUNCJywgJ1VDTEEnXX0pXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50X25hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChzZWUgYG1peHBhbmVsLnRyYWNrKClgKVxuICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzIEEgc2V0IG9mIHByb3BlcnRpZXMgdG8gaW5jbHVkZSB3aXRoIHRoZSBldmVudCB5b3UncmUgc2VuZGluZyAoc2VlIGBtaXhwYW5lbC50cmFjaygpYClcbiAqIEBwYXJhbSB7T2JqZWN0PX0gZ3JvdXBzIEFuIG9iamVjdCBtYXBwaW5nIGdyb3VwIG5hbWUga2V5cyB0byBvbmUgb3IgbW9yZSB2YWx1ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS50cmFja193aXRoX2dyb3VwcyA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIoZnVuY3Rpb24oZXZlbnRfbmFtZSwgcHJvcGVydGllcywgZ3JvdXBzLCBjYWxsYmFjaykge1xuICAgIHZhciB0cmFja2luZ19wcm9wcyA9IF8uZXh0ZW5kKHt9LCBwcm9wZXJ0aWVzIHx8IHt9KTtcbiAgICBfLmVhY2goZ3JvdXBzLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgIGlmICh2ICE9PSBudWxsICYmIHYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJhY2tpbmdfcHJvcHNba10gPSB2O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMudHJhY2soZXZlbnRfbmFtZSwgdHJhY2tpbmdfcHJvcHMsIGNhbGxiYWNrKTtcbn0pO1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2NyZWF0ZV9tYXBfa2V5ID0gZnVuY3Rpb24gKGdyb3VwX2tleSwgZ3JvdXBfaWQpIHtcbiAgICByZXR1cm4gZ3JvdXBfa2V5ICsgJ18nICsgSlNPTi5zdHJpbmdpZnkoZ3JvdXBfaWQpO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9yZW1vdmVfZ3JvdXBfZnJvbV9jYWNoZSA9IGZ1bmN0aW9uIChncm91cF9rZXksIGdyb3VwX2lkKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhY2hlZF9ncm91cHNbdGhpcy5fY3JlYXRlX21hcF9rZXkoZ3JvdXBfa2V5LCBncm91cF9pZCldO1xufTtcblxuLyoqXG4gKiBMb29rIHVwIHJlZmVyZW5jZSB0byBhIE1peHBhbmVsIGdyb3VwXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAgIG1peHBhbmVsLmdldF9ncm91cChncm91cF9rZXksIGdyb3VwX2lkKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBncm91cF9rZXkgR3JvdXAga2V5XG4gKiBAcGFyYW0ge09iamVjdH0gZ3JvdXBfaWQgQSB2YWxpZCBNaXhwYW5lbCBwcm9wZXJ0eSB0eXBlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBIE1peHBhbmVsR3JvdXAgaWRlbnRpZmllclxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X2dyb3VwID0gZnVuY3Rpb24gKGdyb3VwX2tleSwgZ3JvdXBfaWQpIHtcbiAgICB2YXIgbWFwX2tleSA9IHRoaXMuX2NyZWF0ZV9tYXBfa2V5KGdyb3VwX2tleSwgZ3JvdXBfaWQpO1xuICAgIHZhciBncm91cCA9IHRoaXMuX2NhY2hlZF9ncm91cHNbbWFwX2tleV07XG4gICAgaWYgKGdyb3VwID09PSB1bmRlZmluZWQgfHwgZ3JvdXAuX2dyb3VwX2tleSAhPT0gZ3JvdXBfa2V5IHx8IGdyb3VwLl9ncm91cF9pZCAhPT0gZ3JvdXBfaWQpIHtcbiAgICAgICAgZ3JvdXAgPSBuZXcgTWl4cGFuZWxHcm91cCgpO1xuICAgICAgICBncm91cC5faW5pdCh0aGlzLCBncm91cF9rZXksIGdyb3VwX2lkKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkX2dyb3Vwc1ttYXBfa2V5XSA9IGdyb3VwO1xuICAgIH1cbiAgICByZXR1cm4gZ3JvdXA7XG59O1xuXG4vKipcbiAqIFRyYWNrIGEgZGVmYXVsdCBNaXhwYW5lbCBwYWdlIHZpZXcgZXZlbnQsIHdoaWNoIGluY2x1ZGVzIGV4dHJhIGRlZmF1bHQgZXZlbnQgcHJvcGVydGllcyB0b1xuICogaW1wcm92ZSBwYWdlIHZpZXcgZGF0YS5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIHRyYWNrIGEgZGVmYXVsdCAkbXBfd2ViX3BhZ2VfdmlldyBldmVudFxuICogICAgIG1peHBhbmVsLnRyYWNrX3BhZ2V2aWV3KCk7XG4gKlxuICogICAgIC8vIHRyYWNrIGEgcGFnZSB2aWV3IGV2ZW50IHdpdGggYWRkaXRpb25hbCBldmVudCBwcm9wZXJ0aWVzXG4gKiAgICAgbWl4cGFuZWwudHJhY2tfcGFnZXZpZXcoeydhYl90ZXN0X3ZhcmlhbnQnOiAnY2FyZC1sYXlvdXQtYid9KTtcbiAqXG4gKiAgICAgLy8gZXhhbXBsZSBhcHByb2FjaCB0byB0cmFjayBwYWdlIHZpZXdzIG9uIGRpZmZlcmVudCBwYWdlIHR5cGVzIGFzIGV2ZW50IHByb3BlcnRpZXNcbiAqICAgICBtaXhwYW5lbC50cmFja19wYWdldmlldyh7J3BhZ2UnOiAncHJpY2luZyd9KTtcbiAqICAgICBtaXhwYW5lbC50cmFja19wYWdldmlldyh7J3BhZ2UnOiAnaG9tZXBhZ2UnfSk7XG4gKlxuICogICAgIC8vIFVOQ09NTU9OOiBUcmFja2luZyBhIHBhZ2UgdmlldyBldmVudCB3aXRoIGEgY3VzdG9tIGV2ZW50X25hbWUgb3B0aW9uLiBOT1QgZXhwZWN0ZWQgdG8gYmUgdXNlZCBmb3JcbiAqICAgICAvLyBpbmRpdmlkdWFsIHBhZ2VzIG9uIHRoZSBzYW1lIHNpdGUgb3IgcHJvZHVjdC4gVXNlIGNhc2VzIGZvciBjdXN0b20gZXZlbnRfbmFtZSBtYXkgYmUgcGFnZVxuICogICAgIC8vIHZpZXdzIG9uIGRpZmZlcmVudCBwcm9kdWN0cyBvciBpbnRlcm5hbCBhcHBsaWNhdGlvbnMgdGhhdCBhcmUgY29uc2lkZXJlZCBjb21wbGV0ZWx5IHNlcGFyYXRlXG4gKiAgICAgbWl4cGFuZWwudHJhY2tfcGFnZXZpZXcoeydwYWdlJzogJ2N1c3RvbWVyLXNlYXJjaCd9LCB7J2V2ZW50X25hbWUnOiAnW2ludGVybmFsXSBBZG1pbiBQYWdlIFZpZXcnfSk7XG4gKlxuICogIyMjIE5vdGVzOlxuICpcbiAqIFRoZSBgY29uZmlnLnRyYWNrX3BhZ2V2aWV3YCBvcHRpb24gZm9yIDxhIGhyZWY9XCIjbWl4cGFuZWxpbml0XCI+bWl4cGFuZWwuaW5pdCgpPC9hPlxuICogbWF5IGJlIHR1cm5lZCBvbiBmb3IgdHJhY2tpbmcgcGFnZSBsb2FkcyBhdXRvbWF0aWNhbGx5LlxuICpcbiAqICAgICAvLyB0cmFjayBvbmx5IHBhZ2UgbG9hZHNcbiAqICAgICBtaXhwYW5lbC5pbml0KFBST0pFQ1RfVE9LRU4sIHt0cmFja19wYWdldmlldzogdHJ1ZX0pO1xuICpcbiAqICAgICAvLyB0cmFjayB3aGVuIHRoZSBVUkwgY2hhbmdlcyBpbiBhbnkgbWFubmVyXG4gKiAgICAgbWl4cGFuZWwuaW5pdChQUk9KRUNUX1RPS0VOLCB7dHJhY2tfcGFnZXZpZXc6ICdmdWxsLXVybCd9KTtcbiAqXG4gKiAgICAgLy8gdHJhY2sgd2hlbiB0aGUgVVJMIGNoYW5nZXMsIGlnbm9yaW5nIGFueSBjaGFuZ2VzIGluIHRoZSBoYXNoIHBhcnRcbiAqICAgICBtaXhwYW5lbC5pbml0KFBST0pFQ1RfVE9LRU4sIHt0cmFja19wYWdldmlldzogJ3VybC13aXRoLXBhdGgtYW5kLXF1ZXJ5LXN0cmluZyd9KTtcbiAqXG4gKiAgICAgLy8gdHJhY2sgd2hlbiB0aGUgcGF0aCBjaGFuZ2VzLCBpZ25vcmluZyBhbnkgcXVlcnkgcGFyYW1ldGVyIG9yIGhhc2ggY2hhbmdlc1xuICogICAgIG1peHBhbmVsLmluaXQoUFJPSkVDVF9UT0tFTiwge3RyYWNrX3BhZ2V2aWV3OiAndXJsLXdpdGgtcGF0aCd9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIEFuIG9wdGlvbmFsIHNldCBvZiBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gc2VuZCB3aXRoIHRoZSBwYWdlIHZpZXcgZXZlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gUGFnZSB2aWV3IHRyYWNraW5nIG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5ldmVudF9uYW1lXSAtIEFsdGVybmF0ZSBuYW1lIGZvciB0aGUgdHJhY2tpbmcgZXZlbnRcbiAqIEByZXR1cm5zIHtCb29sZWFufE9iamVjdH0gSWYgdGhlIHRyYWNraW5nIHJlcXVlc3Qgd2FzIHN1Y2Nlc3NmdWxseSBpbml0aWF0ZWQvcXVldWVkLCBhbiBvYmplY3RcbiAqIHdpdGggdGhlIHRyYWNraW5nIHBheWxvYWQgc2VudCB0byB0aGUgQVBJIHNlcnZlciBpcyByZXR1cm5lZDsgb3RoZXJ3aXNlIGZhbHNlLlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2tfcGFnZXZpZXcgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliKGZ1bmN0aW9uKHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHByb3BlcnRpZXMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSB7fTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGV2ZW50X25hbWUgPSBvcHRpb25zWydldmVudF9uYW1lJ10gfHwgJyRtcF93ZWJfcGFnZV92aWV3JztcblxuICAgIHZhciBkZWZhdWx0X3BhZ2VfcHJvcGVydGllcyA9IF8uZXh0ZW5kKFxuICAgICAgICBfLmluZm8ubXBQYWdlVmlld1Byb3BlcnRpZXMoKSxcbiAgICAgICAgXy5pbmZvLmNhbXBhaWduUGFyYW1zKCksXG4gICAgICAgIF8uaW5mby5jbGlja1BhcmFtcygpXG4gICAgKTtcblxuICAgIHZhciBldmVudF9wcm9wZXJ0aWVzID0gXy5leHRlbmQoXG4gICAgICAgIHt9LFxuICAgICAgICBkZWZhdWx0X3BhZ2VfcHJvcGVydGllcyxcbiAgICAgICAgcHJvcGVydGllc1xuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcy50cmFjayhldmVudF9uYW1lLCBldmVudF9wcm9wZXJ0aWVzKTtcbn0pO1xuXG4vKipcbiAqIFRyYWNrIGNsaWNrcyBvbiBhIHNldCBvZiBkb2N1bWVudCBlbGVtZW50cy4gU2VsZWN0b3IgbXVzdCBiZSBhXG4gKiB2YWxpZCBxdWVyeS4gRWxlbWVudHMgbXVzdCBleGlzdCBvbiB0aGUgcGFnZSBhdCB0aGUgdGltZSB0cmFja19saW5rcyBpcyBjYWxsZWQuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyB0cmFjayBjbGljayBmb3IgbGluayBpZCAjbmF2XG4gKiAgICAgbWl4cGFuZWwudHJhY2tfbGlua3MoJyNuYXYnLCAnQ2xpY2tlZCBOYXYgTGluaycpO1xuICpcbiAqICMjIyBOb3RlczpcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgd2FpdCB1cCB0byAzMDAgbXMgZm9yIHRoZSBNaXhwYW5lbFxuICogc2VydmVycyB0byByZXNwb25kLiBJZiB0aGV5IGhhdmUgbm90IHJlc3BvbmRlZCBieSB0aGF0IHRpbWVcbiAqIGl0IHdpbGwgaGVhZCB0byB0aGUgbGluayB3aXRob3V0IGVuc3VyaW5nIHRoYXQgeW91ciBldmVudFxuICogaGFzIGJlZW4gdHJhY2tlZC4gIFRvIGNvbmZpZ3VyZSB0aGlzIHRpbWVvdXQgcGxlYXNlIHNlZSB0aGVcbiAqIHNldF9jb25maWcoKSBkb2N1bWVudGF0aW9uIGJlbG93LlxuICpcbiAqIElmIHlvdSBwYXNzIGEgZnVuY3Rpb24gaW4gYXMgdGhlIHByb3BlcnRpZXMgYXJndW1lbnQsIHRoZVxuICogZnVuY3Rpb24gd2lsbCByZWNlaXZlIHRoZSBET01FbGVtZW50IHRoYXQgdHJpZ2dlcmVkIHRoZVxuICogZXZlbnQgYXMgYW4gYXJndW1lbnQuICBZb3UgYXJlIGV4cGVjdGVkIHRvIHJldHVybiBhbiBvYmplY3RcbiAqIGZyb20gdGhlIGZ1bmN0aW9uOyBhbnkgcHJvcGVydGllcyBkZWZpbmVkIG9uIHRoaXMgb2JqZWN0XG4gKiB3aWxsIGJlIHNlbnQgdG8gbWl4cGFuZWwgYXMgZXZlbnQgcHJvcGVydGllcy5cbiAqXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHF1ZXJ5IEEgdmFsaWQgRE9NIHF1ZXJ5LCBlbGVtZW50IG9yIGpRdWVyeS1lc3F1ZSBsaXN0XG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRfbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gdHJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBbcHJvcGVydGllc10gQSBwcm9wZXJ0aWVzIG9iamVjdCBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBkaWN0aW9uYXJ5IG9mIHByb3BlcnRpZXMgd2hlbiBwYXNzZWQgYSBET01FbGVtZW50XG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS50cmFja19saW5rcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFja19kb20uY2FsbCh0aGlzLCBMaW5rVHJhY2tlciwgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogVHJhY2sgZm9ybSBzdWJtaXNzaW9ucy4gU2VsZWN0b3IgbXVzdCBiZSBhIHZhbGlkIHF1ZXJ5LlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gdHJhY2sgc3VibWlzc2lvbiBmb3IgZm9ybSBpZCAncmVnaXN0ZXInXG4gKiAgICAgbWl4cGFuZWwudHJhY2tfZm9ybXMoJyNyZWdpc3RlcicsICdDcmVhdGVkIEFjY291bnQnKTtcbiAqXG4gKiAjIyMgTm90ZXM6XG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIHdhaXQgdXAgdG8gMzAwIG1zIGZvciB0aGUgbWl4cGFuZWxcbiAqIHNlcnZlcnMgdG8gcmVzcG9uZCwgaWYgdGhleSBoYXZlIG5vdCByZXNwb25kZWQgYnkgdGhhdCB0aW1lXG4gKiBpdCB3aWxsIGhlYWQgdG8gdGhlIGxpbmsgd2l0aG91dCBlbnN1cmluZyB0aGF0IHlvdXIgZXZlbnRcbiAqIGhhcyBiZWVuIHRyYWNrZWQuICBUbyBjb25maWd1cmUgdGhpcyB0aW1lb3V0IHBsZWFzZSBzZWUgdGhlXG4gKiBzZXRfY29uZmlnKCkgZG9jdW1lbnRhdGlvbiBiZWxvdy5cbiAqXG4gKiBJZiB5b3UgcGFzcyBhIGZ1bmN0aW9uIGluIGFzIHRoZSBwcm9wZXJ0aWVzIGFyZ3VtZW50LCB0aGVcbiAqIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSB0aGUgRE9NRWxlbWVudCB0aGF0IHRyaWdnZXJlZCB0aGVcbiAqIGV2ZW50IGFzIGFuIGFyZ3VtZW50LiAgWW91IGFyZSBleHBlY3RlZCB0byByZXR1cm4gYW4gb2JqZWN0XG4gKiBmcm9tIHRoZSBmdW5jdGlvbjsgYW55IHByb3BlcnRpZXMgZGVmaW5lZCBvbiB0aGlzIG9iamVjdFxuICogd2lsbCBiZSBzZW50IHRvIG1peHBhbmVsIGFzIGV2ZW50IHByb3BlcnRpZXMuXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBxdWVyeSBBIHZhbGlkIERPTSBxdWVyeSwgZWxlbWVudCBvciBqUXVlcnktZXNxdWUgbGlzdFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50X25hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHRyYWNrXG4gKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gW3Byb3BlcnRpZXNdIFRoaXMgY2FuIGJlIGEgc2V0IG9mIHByb3BlcnRpZXMsIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc2V0IG9mIHByb3BlcnRpZXMgYWZ0ZXIgYmVpbmcgcGFzc2VkIGEgRE9NRWxlbWVudFxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2tfZm9ybXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhY2tfZG9tLmNhbGwodGhpcywgRm9ybVRyYWNrZXIsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIFRpbWUgYW4gZXZlbnQgYnkgaW5jbHVkaW5nIHRoZSB0aW1lIGJldHdlZW4gdGhpcyBjYWxsIGFuZCBhXG4gKiBsYXRlciAndHJhY2snIGNhbGwgZm9yIHRoZSBzYW1lIGV2ZW50IGluIHRoZSBwcm9wZXJ0aWVzIHNlbnRcbiAqIHdpdGggdGhlIGV2ZW50LlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gdGltZSBhbiBldmVudCBuYW1lZCAnUmVnaXN0ZXJlZCdcbiAqICAgICBtaXhwYW5lbC50aW1lX2V2ZW50KCdSZWdpc3RlcmVkJyk7XG4gKiAgICAgbWl4cGFuZWwudHJhY2soJ1JlZ2lzdGVyZWQnLCB7J0dlbmRlcic6ICdNYWxlJywgJ0FnZSc6IDIxfSk7XG4gKlxuICogV2hlbiBjYWxsZWQgZm9yIGEgcGFydGljdWxhciBldmVudCBuYW1lLCB0aGUgbmV4dCB0cmFjayBjYWxsIGZvciB0aGF0IGV2ZW50XG4gKiBuYW1lIHdpbGwgaW5jbHVkZSB0aGUgZWxhcHNlZCB0aW1lIGJldHdlZW4gdGhlICd0aW1lX2V2ZW50JyBhbmQgJ3RyYWNrJ1xuICogY2FsbHMuIFRoaXMgdmFsdWUgaXMgc3RvcmVkIGFzIHNlY29uZHMgaW4gdGhlICckZHVyYXRpb24nIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudF9uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnRpbWVfZXZlbnQgPSBmdW5jdGlvbihldmVudF9uYW1lKSB7XG4gICAgaWYgKF8uaXNVbmRlZmluZWQoZXZlbnRfbmFtZSkpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoJ05vIGV2ZW50IG5hbWUgcHJvdmlkZWQgdG8gbWl4cGFuZWwudGltZV9ldmVudCcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50X2lzX2Rpc2FibGVkKGV2ZW50X25hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnNldF9ldmVudF90aW1lcihldmVudF9uYW1lLCAgbmV3IERhdGUoKS5nZXRUaW1lKCkpO1xufTtcblxudmFyIFJFR0lTVEVSX0RFRkFVTFRTID0ge1xuICAgICdwZXJzaXN0ZW50JzogdHJ1ZVxufTtcbi8qKlxuICogSGVscGVyIHRvIHBhcnNlIG9wdGlvbnMgcGFyYW0gZm9yIHJlZ2lzdGVyIG1ldGhvZHMsIG1haW50YWluaW5nXG4gKiBsZWdhY3kgc3VwcG9ydCBmb3IgcGxhaW4gXCJkYXlzXCIgcGFyYW0gaW5zdGVhZCBvZiBvcHRpb25zIG9iamVjdFxuICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBbZGF5c19vcl9vcHRpb25zXSAnZGF5cycgb3B0aW9uIChOdW1iZXIpLCBvciBPcHRpb25zIG9iamVjdCBmb3IgcmVnaXN0ZXIgbWV0aG9kc1xuICogQHJldHVybnMge09iamVjdH0gb3B0aW9ucyBvYmplY3RcbiAqL1xudmFyIG9wdGlvbnNfZm9yX3JlZ2lzdGVyID0gZnVuY3Rpb24oZGF5c19vcl9vcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnM7XG4gICAgaWYgKF8uaXNPYmplY3QoZGF5c19vcl9vcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0gZGF5c19vcl9vcHRpb25zO1xuICAgIH0gZWxzZSBpZiAoIV8uaXNVbmRlZmluZWQoZGF5c19vcl9vcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0geydkYXlzJzogZGF5c19vcl9vcHRpb25zfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIHJldHVybiBfLmV4dGVuZCh7fSwgUkVHSVNURVJfREVGQVVMVFMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIHNldCBvZiBzdXBlciBwcm9wZXJ0aWVzLCB3aGljaCBhcmUgaW5jbHVkZWQgd2l0aCBhbGxcbiAqIGV2ZW50cy4gVGhpcyB3aWxsIG92ZXJ3cml0ZSBwcmV2aW91cyBzdXBlciBwcm9wZXJ0eSB2YWx1ZXMuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyByZWdpc3RlciAnR2VuZGVyJyBhcyBhIHN1cGVyIHByb3BlcnR5XG4gKiAgICAgbWl4cGFuZWwucmVnaXN0ZXIoeydHZW5kZXInOiAnRmVtYWxlJ30pO1xuICpcbiAqICAgICAvLyByZWdpc3RlciBzZXZlcmFsIHN1cGVyIHByb3BlcnRpZXMgd2hlbiBhIHVzZXIgc2lnbnMgdXBcbiAqICAgICBtaXhwYW5lbC5yZWdpc3Rlcih7XG4gKiAgICAgICAgICdFbWFpbCc6ICdqZG9lQGV4YW1wbGUuY29tJyxcbiAqICAgICAgICAgJ0FjY291bnQgVHlwZSc6ICdGcmVlJ1xuICogICAgIH0pO1xuICpcbiAqICAgICAvLyByZWdpc3RlciBvbmx5IGZvciB0aGUgY3VycmVudCBwYWdlbG9hZFxuICogICAgIG1peHBhbmVsLnJlZ2lzdGVyKHsnTmFtZSc6ICdQYXQnfSwge3BlcnNpc3RlbnQ6IGZhbHNlfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgQW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgcHJvcGVydGllcyB0byBzdG9yZSBhYm91dCB0aGUgdXNlclxuICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBbZGF5c19vcl9vcHRpb25zXSBPcHRpb25zIG9iamVjdCBvciBudW1iZXIgb2YgZGF5cyBzaW5jZSB0aGUgdXNlcidzIGxhc3QgdmlzaXQgdG8gc3RvcmUgdGhlIHN1cGVyIHByb3BlcnRpZXMgKG9ubHkgdmFsaWQgZm9yIHBlcnNpc3RlZCBwcm9wcylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RheXNfb3Jfb3B0aW9ucy5kYXlzXSAtIG51bWJlciBvZiBkYXlzIHNpbmNlIHRoZSB1c2VyJ3MgbGFzdCB2aXNpdCB0byBzdG9yZSB0aGUgc3VwZXIgcHJvcGVydGllcyAob25seSB2YWxpZCBmb3IgcGVyc2lzdGVkIHByb3BzKVxuICogQHBhcmFtIHtib29sZWFufSBbZGF5c19vcl9vcHRpb25zLnBlcnNpc3RlbnQ9dHJ1ZV0gLSB3aGV0aGVyIHRvIHB1dCBpbiBwZXJzaXN0ZW50IHN0b3JhZ2UgKGNvb2tpZS9sb2NhbFN0b3JhZ2UpXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uKHByb3BzLCBkYXlzX29yX29wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdGlvbnNfZm9yX3JlZ2lzdGVyKGRheXNfb3Jfb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnNbJ3BlcnNpc3RlbnQnXSkge1xuICAgICAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnJlZ2lzdGVyKHByb3BzLCBvcHRpb25zWydkYXlzJ10pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF8uZXh0ZW5kKHRoaXMudW5wZXJzaXN0ZWRfc3VwZXJwcm9wcywgcHJvcHMpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBzZXQgb2Ygc3VwZXIgcHJvcGVydGllcyBvbmx5IG9uY2UuIFRoaXMgd2lsbCBub3RcbiAqIG92ZXJ3cml0ZSBwcmV2aW91cyBzdXBlciBwcm9wZXJ0eSB2YWx1ZXMsIHVubGlrZSByZWdpc3RlcigpLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gcmVnaXN0ZXIgYSBzdXBlciBwcm9wZXJ0eSBmb3IgdGhlIGZpcnN0IHRpbWUgb25seVxuICogICAgIG1peHBhbmVsLnJlZ2lzdGVyX29uY2Uoe1xuICogICAgICAgICAnRmlyc3QgTG9naW4gRGF0ZSc6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICogICAgIH0pO1xuICpcbiAqICAgICAvLyByZWdpc3RlciBvbmNlLCBvbmx5IGZvciB0aGUgY3VycmVudCBwYWdlbG9hZFxuICogICAgIG1peHBhbmVsLnJlZ2lzdGVyX29uY2Uoe1xuICogICAgICAgICAnRmlyc3QgaW50ZXJhY3Rpb24gdGltZSc6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICogICAgIH0sICdOb25lJywge3BlcnNpc3RlbnQ6IGZhbHNlfSk7XG4gKlxuICogIyMjIE5vdGVzOlxuICpcbiAqIElmIGRlZmF1bHRfdmFsdWUgaXMgc3BlY2lmaWVkLCBjdXJyZW50IHN1cGVyIHByb3BlcnRpZXNcbiAqIHdpdGggdGhhdCB2YWx1ZSB3aWxsIGJlIG92ZXJ3cml0dGVuLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIEFuIGFzc29jaWF0aXZlIGFycmF5IG9mIHByb3BlcnRpZXMgdG8gc3RvcmUgYWJvdXQgdGhlIHVzZXJcbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRfdmFsdWVdIFZhbHVlIHRvIG92ZXJyaWRlIGlmIGFscmVhZHkgc2V0IGluIHN1cGVyIHByb3BlcnRpZXMgKGV4OiAnRmFsc2UnKSBEZWZhdWx0OiAnTm9uZSdcbiAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gW2RheXNfb3Jfb3B0aW9uc10gT3B0aW9ucyBvYmplY3Qgb3IgbnVtYmVyIG9mIGRheXMgc2luY2UgdGhlIHVzZXIncyBsYXN0IHZpc2l0IHRvIHN0b3JlIHRoZSBzdXBlciBwcm9wZXJ0aWVzIChvbmx5IHZhbGlkIGZvciBwZXJzaXN0ZWQgcHJvcHMpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtkYXlzX29yX29wdGlvbnMuZGF5c10gLSBudW1iZXIgb2YgZGF5cyBzaW5jZSB0aGUgdXNlcidzIGxhc3QgdmlzaXQgdG8gc3RvcmUgdGhlIHN1cGVyIHByb3BlcnRpZXMgKG9ubHkgdmFsaWQgZm9yIHBlcnNpc3RlZCBwcm9wcylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RheXNfb3Jfb3B0aW9ucy5wZXJzaXN0ZW50PXRydWVdIC0gd2hldGhlciB0byBwdXQgaW4gcGVyc2lzdGVudCBzdG9yYWdlIChjb29raWUvbG9jYWxTdG9yYWdlKVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUucmVnaXN0ZXJfb25jZSA9IGZ1bmN0aW9uKHByb3BzLCBkZWZhdWx0X3ZhbHVlLCBkYXlzX29yX29wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdGlvbnNfZm9yX3JlZ2lzdGVyKGRheXNfb3Jfb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnNbJ3BlcnNpc3RlbnQnXSkge1xuICAgICAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnJlZ2lzdGVyX29uY2UocHJvcHMsIGRlZmF1bHRfdmFsdWUsIG9wdGlvbnNbJ2RheXMnXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZihkZWZhdWx0X3ZhbHVlKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGRlZmF1bHRfdmFsdWUgPSAnTm9uZSc7XG4gICAgICAgIH1cbiAgICAgICAgXy5lYWNoKHByb3BzLCBmdW5jdGlvbih2YWwsIHByb3ApIHtcbiAgICAgICAgICAgIGlmICghdGhpcy51bnBlcnNpc3RlZF9zdXBlcnByb3BzLmhhc093blByb3BlcnR5KHByb3ApIHx8IHRoaXMudW5wZXJzaXN0ZWRfc3VwZXJwcm9wc1twcm9wXSA9PT0gZGVmYXVsdF92YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5wZXJzaXN0ZWRfc3VwZXJwcm9wc1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBEZWxldGUgYSBzdXBlciBwcm9wZXJ0eSBzdG9yZWQgd2l0aCB0aGUgY3VycmVudCB1c2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgc3VwZXIgcHJvcGVydHkgdG8gcmVtb3ZlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnBlcnNpc3RlbnQ9dHJ1ZV0gLSB3aGV0aGVyIHRvIGxvb2sgaW4gcGVyc2lzdGVudCBzdG9yYWdlIChjb29raWUvbG9jYWxTdG9yYWdlKVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uKHByb3BlcnR5LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnNfZm9yX3JlZ2lzdGVyKG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zWydwZXJzaXN0ZW50J10pIHtcbiAgICAgICAgdGhpc1sncGVyc2lzdGVuY2UnXS51bnJlZ2lzdGVyKHByb3BlcnR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy51bnBlcnNpc3RlZF9zdXBlcnByb3BzW3Byb3BlcnR5XTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX3JlZ2lzdGVyX3NpbmdsZSA9IGZ1bmN0aW9uKHByb3AsIHZhbHVlKSB7XG4gICAgdmFyIHByb3BzID0ge307XG4gICAgcHJvcHNbcHJvcF0gPSB2YWx1ZTtcbiAgICB0aGlzLnJlZ2lzdGVyKHByb3BzKTtcbn07XG5cbi8qKlxuICogSWRlbnRpZnkgYSB1c2VyIHdpdGggYSB1bmlxdWUgSUQgdG8gdHJhY2sgdXNlciBhY3Rpdml0eSBhY3Jvc3NcbiAqIGRldmljZXMsIHRpZSBhIHVzZXIgdG8gdGhlaXIgZXZlbnRzLCBhbmQgY3JlYXRlIGEgdXNlciBwcm9maWxlLlxuICogSWYgeW91IG5ldmVyIGNhbGwgdGhpcyBtZXRob2QsIHVuaXF1ZSB2aXNpdG9ycyBhcmUgdHJhY2tlZCB1c2luZ1xuICogYSBVVUlEIGdlbmVyYXRlZCB0aGUgZmlyc3QgdGltZSB0aGV5IHZpc2l0IHRoZSBzaXRlLlxuICpcbiAqIENhbGwgaWRlbnRpZnkgd2hlbiB5b3Uga25vdyB0aGUgaWRlbnRpdHkgb2YgdGhlIGN1cnJlbnQgdXNlcixcbiAqIHR5cGljYWxseSBhZnRlciBsb2dpbiBvciBzaWdudXAuIFdlIHJlY29tbWVuZCBhZ2FpbnN0IHVzaW5nXG4gKiBpZGVudGlmeSBmb3IgYW5vbnltb3VzIHZpc2l0b3JzIHRvIHlvdXIgc2l0ZS5cbiAqXG4gKiAjIyMgTm90ZXM6XG4gKiBJZiB5b3VyIHByb2plY3QgaGFzXG4gKiA8YSBocmVmPVwiaHR0cHM6Ly9oZWxwLm1peHBhbmVsLmNvbS9oYy9lbi11cy9hcnRpY2xlcy8zNjAwMzkxMzM4NTFcIj5JRCBNZXJnZTwvYT5cbiAqIGVuYWJsZWQsIHRoZSBpZGVudGlmeSBtZXRob2Qgd2lsbCBjb25uZWN0IHByZS0gYW5kXG4gKiBwb3N0LWF1dGhlbnRpY2F0aW9uIGV2ZW50cyB3aGVuIGFwcHJvcHJpYXRlLlxuICpcbiAqIElmIHlvdXIgcHJvamVjdCBkb2VzIG5vdCBoYXZlIElEIE1lcmdlIGVuYWJsZWQsIGlkZW50aWZ5IHdpbGxcbiAqIGNoYW5nZSB0aGUgdXNlcidzIGxvY2FsIGRpc3RpbmN0X2lkIHRvIHRoZSB1bmlxdWUgSUQgeW91IHBhc3MuXG4gKiBFdmVudHMgdHJhY2tlZCBwcmlvciB0byBhdXRoZW50aWNhdGlvbiB3aWxsIG5vdCBiZSBjb25uZWN0ZWRcbiAqIHRvIHRoZSBzYW1lIHVzZXIgaWRlbnRpdHkuIElmIElEIE1lcmdlIGlzIGRpc2FibGVkLCBhbGlhcyBjYW5cbiAqIGJlIHVzZWQgdG8gY29ubmVjdCBwcmUtIGFuZCBwb3N0LXJlZ2lzdHJhdGlvbiBldmVudHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFt1bmlxdWVfaWRdIEEgc3RyaW5nIHRoYXQgdW5pcXVlbHkgaWRlbnRpZmllcyBhIHVzZXIuIElmIG5vdCBwcm92aWRlZCwgdGhlIGRpc3RpbmN0X2lkIGN1cnJlbnRseSBpbiB0aGUgcGVyc2lzdGVudCBzdG9yZSAoY29va2llIG9yIGxvY2FsU3RvcmFnZSkgd2lsbCBiZSB1c2VkLlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuaWRlbnRpZnkgPSBmdW5jdGlvbihcbiAgICBuZXdfZGlzdGluY3RfaWQsIF9zZXRfY2FsbGJhY2ssIF9hZGRfY2FsbGJhY2ssIF9hcHBlbmRfY2FsbGJhY2ssIF9zZXRfb25jZV9jYWxsYmFjaywgX3VuaW9uX2NhbGxiYWNrLCBfdW5zZXRfY2FsbGJhY2ssIF9yZW1vdmVfY2FsbGJhY2tcbikge1xuICAgIC8vIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAgICAvLyAgX3NldF9jYWxsYmFjazpmdW5jdGlvbiAgQSBjYWxsYmFjayB0byBiZSBydW4gaWYgYW5kIHdoZW4gdGhlIFBlb3BsZSBzZXQgcXVldWUgaXMgZmx1c2hlZFxuICAgIC8vICBfYWRkX2NhbGxiYWNrOmZ1bmN0aW9uICBBIGNhbGxiYWNrIHRvIGJlIHJ1biBpZiBhbmQgd2hlbiB0aGUgUGVvcGxlIGFkZCBxdWV1ZSBpcyBmbHVzaGVkXG4gICAgLy8gIF9hcHBlbmRfY2FsbGJhY2s6ZnVuY3Rpb24gIEEgY2FsbGJhY2sgdG8gYmUgcnVuIGlmIGFuZCB3aGVuIHRoZSBQZW9wbGUgYXBwZW5kIHF1ZXVlIGlzIGZsdXNoZWRcbiAgICAvLyAgX3NldF9vbmNlX2NhbGxiYWNrOmZ1bmN0aW9uICBBIGNhbGxiYWNrIHRvIGJlIHJ1biBpZiBhbmQgd2hlbiB0aGUgUGVvcGxlIHNldF9vbmNlIHF1ZXVlIGlzIGZsdXNoZWRcbiAgICAvLyAgX3VuaW9uX2NhbGxiYWNrOmZ1bmN0aW9uICBBIGNhbGxiYWNrIHRvIGJlIHJ1biBpZiBhbmQgd2hlbiB0aGUgUGVvcGxlIHVuaW9uIHF1ZXVlIGlzIGZsdXNoZWRcbiAgICAvLyAgX3Vuc2V0X2NhbGxiYWNrOmZ1bmN0aW9uICBBIGNhbGxiYWNrIHRvIGJlIHJ1biBpZiBhbmQgd2hlbiB0aGUgUGVvcGxlIHVuc2V0IHF1ZXVlIGlzIGZsdXNoZWRcblxuICAgIHZhciBwcmV2aW91c19kaXN0aW5jdF9pZCA9IHRoaXMuZ2V0X2Rpc3RpbmN0X2lkKCk7XG4gICAgaWYgKG5ld19kaXN0aW5jdF9pZCAmJiBwcmV2aW91c19kaXN0aW5jdF9pZCAhPT0gbmV3X2Rpc3RpbmN0X2lkKSB7XG4gICAgICAgIC8vIHdlIGFsbG93IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uIGlmIHByZXZpb3VzIGRpc3RpbmN0X2lkIGlzIHNhbWUgYXMgbmV3X2Rpc3RpbmN0X2lkXG4gICAgICAgIC8vIHNvIHRoYXQgeW91IGNhbiBmb3JjZSBmbHVzaCBwZW9wbGUgdXBkYXRlcyBmb3IgYW5vbnltb3VzIHByb2ZpbGVzLlxuICAgICAgICBpZiAodHlwZW9mIG5ld19kaXN0aW5jdF9pZCA9PT0gJ3N0cmluZycgJiYgbmV3X2Rpc3RpbmN0X2lkLmluZGV4T2YoREVWSUNFX0lEX1BSRUZJWCkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdkaXN0aW5jdF9pZCBjYW5ub3QgaGF2ZSAkZGV2aWNlOiBwcmVmaXgnKTtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZ2lzdGVyKHsnJHVzZXJfaWQnOiBuZXdfZGlzdGluY3RfaWR9KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZ2V0X3Byb3BlcnR5KCckZGV2aWNlX2lkJykpIHtcbiAgICAgICAgLy8gVGhlIHBlcnNpc3RlZCBkaXN0aW5jdCBpZCBtaWdodCBub3QgYWN0dWFsbHkgYmUgYSBkZXZpY2UgaWQgYXQgYWxsXG4gICAgICAgIC8vIGl0IG1pZ2h0IGJlIGEgZGlzdGluY3QgaWQgb2YgdGhlIHVzZXIgZnJvbSBiZWZvcmVcbiAgICAgICAgdmFyIGRldmljZV9pZCA9IHByZXZpb3VzX2Rpc3RpbmN0X2lkO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyX29uY2Uoe1xuICAgICAgICAgICAgJyRoYWRfcGVyc2lzdGVkX2Rpc3RpbmN0X2lkJzogdHJ1ZSxcbiAgICAgICAgICAgICckZGV2aWNlX2lkJzogZGV2aWNlX2lkXG4gICAgICAgIH0sICcnKTtcbiAgICB9XG5cbiAgICAvLyBpZGVudGlmeSBvbmx5IGNoYW5nZXMgdGhlIGRpc3RpbmN0IGlkIGlmIGl0IGRvZXNuJ3QgbWF0Y2ggZWl0aGVyIHRoZSBleGlzdGluZyBvciB0aGUgYWxpYXM7XG4gICAgLy8gaWYgaXQncyBuZXcsIGJsb3cgYXdheSB0aGUgYWxpYXMgYXMgd2VsbC5cbiAgICBpZiAobmV3X2Rpc3RpbmN0X2lkICE9PSBwcmV2aW91c19kaXN0aW5jdF9pZCAmJiBuZXdfZGlzdGluY3RfaWQgIT09IHRoaXMuZ2V0X3Byb3BlcnR5KEFMSUFTX0lEX0tFWSkpIHtcbiAgICAgICAgdGhpcy51bnJlZ2lzdGVyKEFMSUFTX0lEX0tFWSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoeydkaXN0aW5jdF9pZCc6IG5ld19kaXN0aW5jdF9pZH0pO1xuICAgIH1cbiAgICB0aGlzLl9mbGFncy5pZGVudGlmeV9jYWxsZWQgPSB0cnVlO1xuICAgIC8vIEZsdXNoIGFueSBxdWV1ZWQgdXAgcGVvcGxlIHJlcXVlc3RzXG4gICAgdGhpc1sncGVvcGxlJ10uX2ZsdXNoKF9zZXRfY2FsbGJhY2ssIF9hZGRfY2FsbGJhY2ssIF9hcHBlbmRfY2FsbGJhY2ssIF9zZXRfb25jZV9jYWxsYmFjaywgX3VuaW9uX2NhbGxiYWNrLCBfdW5zZXRfY2FsbGJhY2ssIF9yZW1vdmVfY2FsbGJhY2spO1xuXG4gICAgLy8gc2VuZCBhbiAkaWRlbnRpZnkgZXZlbnQgYW55IHRpbWUgdGhlIGRpc3RpbmN0X2lkIGlzIGNoYW5naW5nIC0gbG9naWMgb24gdGhlIHNlcnZlclxuICAgIC8vIHdpbGwgZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRvIGRvIGFueXRoaW5nIHdpdGggaXQuXG4gICAgaWYgKG5ld19kaXN0aW5jdF9pZCAhPT0gcHJldmlvdXNfZGlzdGluY3RfaWQpIHtcbiAgICAgICAgdGhpcy50cmFjaygnJGlkZW50aWZ5Jywge1xuICAgICAgICAgICAgJ2Rpc3RpbmN0X2lkJzogbmV3X2Rpc3RpbmN0X2lkLFxuICAgICAgICAgICAgJyRhbm9uX2Rpc3RpbmN0X2lkJzogcHJldmlvdXNfZGlzdGluY3RfaWRcbiAgICAgICAgfSwge3NraXBfaG9va3M6IHRydWV9KTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmZWF0dXJlIGZsYWdzIGFnYWluIGlmIGRpc3RpbmN0IGlkIGhhcyBjaGFuZ2VkXG4gICAgaWYgKG5ld19kaXN0aW5jdF9pZCAhPT0gcHJldmlvdXNfZGlzdGluY3RfaWQpIHtcbiAgICAgICAgdGhpcy5mbGFncy5mZXRjaEZsYWdzKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDbGVhcnMgc3VwZXIgcHJvcGVydGllcyBhbmQgZ2VuZXJhdGVzIGEgbmV3IHJhbmRvbSBkaXN0aW5jdF9pZCBmb3IgdGhpcyBpbnN0YW5jZS5cbiAqIFVzZWZ1bCBmb3IgY2xlYXJpbmcgZGF0YSB3aGVuIGEgdXNlciBsb2dzIG91dC5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdG9wX3Nlc3Npb25fcmVjb3JkaW5nKCk7XG4gICAgdGhpc1sncGVyc2lzdGVuY2UnXS5jbGVhcigpO1xuICAgIHRoaXMuX2ZsYWdzLmlkZW50aWZ5X2NhbGxlZCA9IGZhbHNlO1xuICAgIHZhciB1dWlkID0gXy5VVUlEKCk7XG4gICAgdGhpcy5yZWdpc3Rlcl9vbmNlKHtcbiAgICAgICAgJ2Rpc3RpbmN0X2lkJzogREVWSUNFX0lEX1BSRUZJWCArIHV1aWQsXG4gICAgICAgICckZGV2aWNlX2lkJzogdXVpZFxuICAgIH0sICcnKTtcbiAgICB0aGlzLl9jaGVja19hbmRfc3RhcnRfc2Vzc2lvbl9yZWNvcmRpbmcoKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBkaXN0aW5jdCBpZCBvZiB0aGUgdXNlci4gVGhpcyBpcyBlaXRoZXIgdGhlIGlkIGF1dG9tYXRpY2FsbHlcbiAqIGdlbmVyYXRlZCBieSB0aGUgbGlicmFyeSBvciB0aGUgaWQgdGhhdCBoYXMgYmVlbiBwYXNzZWQgYnkgYSBjYWxsIHRvIGlkZW50aWZ5KCkuXG4gKlxuICogIyMjIE5vdGVzOlxuICpcbiAqIGdldF9kaXN0aW5jdF9pZCgpIGNhbiBvbmx5IGJlIGNhbGxlZCBhZnRlciB0aGUgTWl4cGFuZWwgbGlicmFyeSBoYXMgZmluaXNoZWQgbG9hZGluZy5cbiAqIGluaXQoKSBoYXMgYSBsb2FkZWQgZnVuY3Rpb24gYXZhaWxhYmxlIHRvIGhhbmRsZSB0aGlzIGF1dG9tYXRpY2FsbHkuIEZvciBleGFtcGxlOlxuICpcbiAqICAgICAvLyBzZXQgZGlzdGluY3RfaWQgYWZ0ZXIgdGhlIG1peHBhbmVsIGxpYnJhcnkgaGFzIGxvYWRlZFxuICogICAgIG1peHBhbmVsLmluaXQoJ1lPVVIgUFJPSkVDVCBUT0tFTicsIHtcbiAqICAgICAgICAgbG9hZGVkOiBmdW5jdGlvbihtaXhwYW5lbCkge1xuICogICAgICAgICAgICAgZGlzdGluY3RfaWQgPSBtaXhwYW5lbC5nZXRfZGlzdGluY3RfaWQoKTtcbiAqICAgICAgICAgfVxuICogICAgIH0pO1xuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X2Rpc3RpbmN0X2lkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0X3Byb3BlcnR5KCdkaXN0aW5jdF9pZCcpO1xufTtcblxuLyoqXG4gKiBUaGUgYWxpYXMgbWV0aG9kIGNyZWF0ZXMgYW4gYWxpYXMgd2hpY2ggTWl4cGFuZWwgd2lsbCB1c2UgdG9cbiAqIHJlbWFwIG9uZSBpZCB0byBhbm90aGVyLiBNdWx0aXBsZSBhbGlhc2VzIGNhbiBwb2ludCB0byB0aGVcbiAqIHNhbWUgaWRlbnRpZmllci5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIGlzIGEgdmFsaWQgdXNlIG9mIGFsaWFzOlxuICpcbiAqICAgICBtaXhwYW5lbC5hbGlhcygnbmV3X2lkJywgJ2V4aXN0aW5nX2lkJyk7XG4gKiAgICAgLy8gWW91IGNhbiBhZGQgbXVsdGlwbGUgaWQgYWxpYXNlcyB0byB0aGUgZXhpc3RpbmcgSURcbiAqICAgICBtaXhwYW5lbC5hbGlhcygnbmV3ZXJfaWQnLCAnZXhpc3RpbmdfaWQnKTtcbiAqXG4gKiBBbGlhc2VzIGNhbiBhbHNvIGJlIGNoYWluZWQgLSB0aGUgZm9sbG93aW5nIGlzIGEgdmFsaWQgZXhhbXBsZTpcbiAqXG4gKiAgICAgbWl4cGFuZWwuYWxpYXMoJ25ld19pZCcsICdleGlzdGluZ19pZCcpO1xuICogICAgIC8vIGNoYWluIG5ld2VyX2lkIC0gbmV3X2lkIC0gZXhpc3RpbmdfaWRcbiAqICAgICBtaXhwYW5lbC5hbGlhcygnbmV3ZXJfaWQnLCAnbmV3X2lkJyk7XG4gKlxuICogQWxpYXNlcyBjYW5ub3QgcG9pbnQgdG8gbXVsdGlwbGUgaWRlbnRpZmllcnMgLSB0aGUgZm9sbG93aW5nXG4gKiBleGFtcGxlIHdpbGwgbm90IHdvcms6XG4gKlxuICogICAgIG1peHBhbmVsLmFsaWFzKCduZXdfaWQnLCAnZXhpc3RpbmdfaWQnKTtcbiAqICAgICAvLyB0aGlzIGlzIGludmFsaWQgYXMgJ25ld19pZCcgYWxyZWFkeSBwb2ludHMgdG8gJ2V4aXN0aW5nX2lkJ1xuICogICAgIG1peHBhbmVsLmFsaWFzKCduZXdfaWQnLCAnbmV3ZXJfaWQnKTtcbiAqXG4gKiAjIyMgTm90ZXM6XG4gKlxuICogSWYgeW91ciBwcm9qZWN0IGRvZXMgbm90IGhhdmVcbiAqIDxhIGhyZWY9XCJodHRwczovL2hlbHAubWl4cGFuZWwuY29tL2hjL2VuLXVzL2FydGljbGVzLzM2MDAzOTEzMzg1MVwiPklEIE1lcmdlPC9hPlxuICogZW5hYmxlZCwgdGhlIGJlc3QgcHJhY3RpY2UgaXMgdG8gY2FsbCBhbGlhcyBvbmNlIHdoZW4gYSB1bmlxdWVcbiAqIElEIGlzIGZpcnN0IGNyZWF0ZWQgZm9yIGEgdXNlciAoZS5nLiwgd2hlbiBhIHVzZXIgZmlyc3QgcmVnaXN0ZXJzXG4gKiBmb3IgYW4gYWNjb3VudCkuIERvIG5vdCB1c2UgYWxpYXMgbXVsdGlwbGUgdGltZXMgZm9yIGEgc2luZ2xlXG4gKiB1c2VyIHdpdGhvdXQgSUQgTWVyZ2UgZW5hYmxlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWxpYXMgQSB1bmlxdWUgaWRlbnRpZmllciB0aGF0IHlvdSB3YW50IHRvIHVzZSBmb3IgdGhpcyB1c2VyIGluIHRoZSBmdXR1cmUuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29yaWdpbmFsXSBUaGUgY3VycmVudCBpZGVudGlmaWVyIGJlaW5nIHVzZWQgZm9yIHRoaXMgdXNlci5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmFsaWFzID0gZnVuY3Rpb24oYWxpYXMsIG9yaWdpbmFsKSB7XG4gICAgLy8gSWYgdGhlICRwZW9wbGVfZGlzdGluY3RfaWQga2V5IGV4aXN0cyBpbiBwZXJzaXN0ZW5jZSwgdGhlcmUgaGFzIGJlZW4gYSBwcmV2aW91c1xuICAgIC8vIG1peHBhbmVsLnBlb3BsZS5pZGVudGlmeSgpIGNhbGwgbWFkZSBmb3IgdGhpcyB1c2VyLiBJdCBpcyBWRVJZIEJBRCB0byBtYWtlIGFuIGFsaWFzIHdpdGhcbiAgICAvLyB0aGlzIElELCBhcyBpdCB3aWxsIGR1cGxpY2F0ZSB1c2Vycy5cbiAgICBpZiAoYWxpYXMgPT09IHRoaXMuZ2V0X3Byb3BlcnR5KFBFT1BMRV9ESVNUSU5DVF9JRF9LRVkpKSB7XG4gICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdBdHRlbXB0aW5nIHRvIGNyZWF0ZSBhbGlhcyBmb3IgZXhpc3RpbmcgUGVvcGxlIHVzZXIgLSBhYm9ydGluZy4nKTtcbiAgICAgICAgcmV0dXJuIC0yO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKF8uaXNVbmRlZmluZWQob3JpZ2luYWwpKSB7XG4gICAgICAgIG9yaWdpbmFsID0gdGhpcy5nZXRfZGlzdGluY3RfaWQoKTtcbiAgICB9XG4gICAgaWYgKGFsaWFzICE9PSBvcmlnaW5hbCkge1xuICAgICAgICB0aGlzLl9yZWdpc3Rlcl9zaW5nbGUoQUxJQVNfSURfS0VZLCBhbGlhcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNrKCckY3JlYXRlX2FsaWFzJywge1xuICAgICAgICAgICAgJ2FsaWFzJzogYWxpYXMsXG4gICAgICAgICAgICAnZGlzdGluY3RfaWQnOiBvcmlnaW5hbFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBza2lwX2hvb2tzOiB0cnVlXG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gRmx1c2ggdGhlIHBlb3BsZSBxdWV1ZVxuICAgICAgICAgICAgX3RoaXMuaWRlbnRpZnkoYWxpYXMpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlcG9ydF9lcnJvcignYWxpYXMgbWF0Y2hlcyBjdXJyZW50IGRpc3RpbmN0X2lkIC0gc2tpcHBpbmcgYXBpIGNhbGwuJyk7XG4gICAgICAgIHRoaXMuaWRlbnRpZnkoYWxpYXMpO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxufTtcblxuLyoqXG4gKiBQcm92aWRlIGEgc3RyaW5nIHRvIHJlY29nbml6ZSB0aGUgdXNlciBieS4gVGhlIHN0cmluZyBwYXNzZWQgdG9cbiAqIHRoaXMgbWV0aG9kIHdpbGwgYXBwZWFyIGluIHRoZSBNaXhwYW5lbCBTdHJlYW1zIHByb2R1Y3QgcmF0aGVyXG4gKiB0aGFuIGFuIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIG5hbWUuIE5hbWUgdGFncyBkbyBub3QgaGF2ZSB0b1xuICogYmUgdW5pcXVlLlxuICpcbiAqIFRoaXMgdmFsdWUgd2lsbCBvbmx5IGJlIGluY2x1ZGVkIGluIFN0cmVhbXMgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZV90YWcgQSBodW1hbiByZWFkYWJsZSBuYW1lIGZvciB0aGUgdXNlclxuICogQGRlcHJlY2F0ZWRcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLm5hbWVfdGFnID0gZnVuY3Rpb24obmFtZV90YWcpIHtcbiAgICB0aGlzLl9yZWdpc3Rlcl9zaW5nbGUoJ21wX25hbWVfdGFnJywgbmFtZV90YWcpO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGNvbmZpZ3VyYXRpb24gb2YgYSBtaXhwYW5lbCBsaWJyYXJ5IGluc3RhbmNlLlxuICpcbiAqIFRoZSBkZWZhdWx0IGNvbmZpZyBpczpcbiAqXG4gKiAgICAge1xuICogICAgICAgLy8gaG9zdCBmb3IgcmVxdWVzdHMgKGN1c3RvbWl6YWJsZSBmb3IgZS5nLiBhIGxvY2FsIHByb3h5KVxuICogICAgICAgYXBpX2hvc3Q6ICdodHRwczovL2FwaS1qcy5taXhwYW5lbC5jb20nLFxuICpcbiAqICAgICAgIC8vIGVuZHBvaW50cyBmb3IgZGlmZmVyZW50IHR5cGVzIG9mIHJlcXVlc3RzXG4gKiAgICAgICBhcGlfcm91dGVzOiB7XG4gKiAgICAgICAgIHRyYWNrOiAndHJhY2svJyxcbiAqICAgICAgICAgZW5nYWdlOiAnZW5nYWdlLycsXG4gKiAgICAgICAgIGdyb3VwczogJ2dyb3Vwcy8nLFxuICogICAgICAgfVxuICpcbiAqICAgICAgIC8vIEhUVFAgbWV0aG9kIGZvciB0cmFja2luZyByZXF1ZXN0c1xuICogICAgICAgYXBpX21ldGhvZDogJ1BPU1QnXG4gKlxuICogICAgICAgLy8gdHJhbnNwb3J0IGZvciBzZW5kaW5nIHJlcXVlc3RzICgnWEhSJyBvciAnc2VuZEJlYWNvbicpXG4gKiAgICAgICAvLyBOQjogc2VuZEJlYWNvbiBzaG91bGQgb25seSBiZSB1c2VkIGZvciBzY2VuYXJpb3Mgc3VjaCBhc1xuICogICAgICAgLy8gcGFnZSB1bmxvYWQgd2hlcmUgYSBcImJlc3QtZWZmb3J0XCIgYXR0ZW1wdCB0byBzZW5kIGlzXG4gKiAgICAgICAvLyBhY2NlcHRhYmxlOyB0aGUgc2VuZEJlYWNvbiBBUEkgZG9lcyBub3Qgc3VwcG9ydCBjYWxsYmFja3NcbiAqICAgICAgIC8vIG9yIGFueSB3YXkgdG8ga25vdyB0aGUgcmVzdWx0IG9mIHRoZSByZXF1ZXN0LiBNaXhwYW5lbFxuICogICAgICAgLy8gdHJhY2tpbmcgdmlhIHNlbmRCZWFjb24gd2lsbCBub3Qgc3VwcG9ydCBhbnkgZXZlbnQtXG4gKiAgICAgICAvLyBiYXRjaGluZyBvciByZXRyeSBtZWNoYW5pc21zLlxuICogICAgICAgYXBpX3RyYW5zcG9ydDogJ1hIUidcbiAqXG4gKiAgICAgICAvLyByZXF1ZXN0LWJhdGNoaW5nL3F1ZXVlaW5nL3JldHJ5XG4gKiAgICAgICBiYXRjaF9yZXF1ZXN0czogdHJ1ZSxcbiAqXG4gKiAgICAgICAvLyBtYXhpbXVtIG51bWJlciBvZiBldmVudHMvdXBkYXRlcyB0byBzZW5kIGluIGEgc2luZ2xlXG4gKiAgICAgICAvLyBuZXR3b3JrIHJlcXVlc3RcbiAqICAgICAgIGJhdGNoX3NpemU6IDUwLFxuICpcbiAqICAgICAgIC8vIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJldHdlZW4gc2VuZGluZyBiYXRjaCByZXF1ZXN0c1xuICogICAgICAgYmF0Y2hfZmx1c2hfaW50ZXJ2YWxfbXM6IDUwMDAsXG4gKlxuICogICAgICAgLy8gbWlsbGlzZWNvbmRzIHRvIHdhaXQgZm9yIG5ldHdvcmsgcmVzcG9uc2VzIHRvIGJhdGNoIHJlcXVlc3RzXG4gKiAgICAgICAvLyBiZWZvcmUgdGhleSBhcmUgY29uc2lkZXJlZCB0aW1lZC1vdXQgYW5kIHJldHJpZWRcbiAqICAgICAgIGJhdGNoX3JlcXVlc3RfdGltZW91dF9tczogOTAwMDAsXG4gKlxuICogICAgICAgLy8gb3ZlcnJpZGUgdmFsdWUgZm9yIGNvb2tpZSBkb21haW4sIG9ubHkgdXNlZnVsIGZvciBlbnN1cmluZ1xuICogICAgICAgLy8gY29ycmVjdCBjcm9zcy1zdWJkb21haW4gY29va2llcyBvbiB1bnVzdWFsIGRvbWFpbnMgbGlrZVxuICogICAgICAgLy8gc3ViZG9tYWluLm1haW5zaXRlLmF2b2NhdC5mcjsgTkIgdGhpcyBjYW5ub3QgYmUgdXNlZCB0b1xuICogICAgICAgLy8gc2V0IGNvb2tpZXMgb24gYSBkaWZmZXJlbnQgZG9tYWluIHRoYW4gdGhlIGN1cnJlbnQgb3JpZ2luXG4gKiAgICAgICBjb29raWVfZG9tYWluOiAnJ1xuICpcbiAqICAgICAgIC8vIHN1cGVyIHByb3BlcnRpZXMgY29va2llIGV4cGlyYXRpb24gKGluIGRheXMpXG4gKiAgICAgICBjb29raWVfZXhwaXJhdGlvbjogMzY1XG4gKlxuICogICAgICAgLy8gaWYgdHJ1ZSwgY29va2llIHdpbGwgYmUgc2V0IHdpdGggU2FtZVNpdGU9Tm9uZTsgU2VjdXJlXG4gKiAgICAgICAvLyB0aGlzIGlzIG9ubHkgdXNlZnVsIGluIHNwZWNpYWwgc2l0dWF0aW9ucywgbGlrZSBlbWJlZGRlZFxuICogICAgICAgLy8gM3JkLXBhcnR5IGlmcmFtZXMgdGhhdCBzZXQgdXAgYSBNaXhwYW5lbCBpbnN0YW5jZVxuICogICAgICAgY3Jvc3Nfc2l0ZV9jb29raWU6IGZhbHNlXG4gKlxuICogICAgICAgLy8gc3VwZXIgcHJvcGVydGllcyBzcGFuIHN1YmRvbWFpbnNcbiAqICAgICAgIGNyb3NzX3N1YmRvbWFpbl9jb29raWU6IHRydWVcbiAqXG4gKiAgICAgICAvLyBkZWJ1ZyBtb2RlXG4gKiAgICAgICBkZWJ1ZzogZmFsc2VcbiAqXG4gKiAgICAgICAvLyBpZiB0aGlzIGlzIHRydWUsIHRoZSBtaXhwYW5lbCBjb29raWUgb3IgbG9jYWxTdG9yYWdlIGVudHJ5XG4gKiAgICAgICAvLyB3aWxsIGJlIGRlbGV0ZWQsIGFuZCBubyB1c2VyIHBlcnNpc3RlbmNlIHdpbGwgdGFrZSBwbGFjZVxuICogICAgICAgZGlzYWJsZV9wZXJzaXN0ZW5jZTogZmFsc2VcbiAqXG4gKiAgICAgICAvLyBpZiB0aGlzIGlzIHRydWUsIE1peHBhbmVsIHdpbGwgYXV0b21hdGljYWxseSBkZXRlcm1pbmVcbiAqICAgICAgIC8vIENpdHksIFJlZ2lvbiBhbmQgQ291bnRyeSBkYXRhIHVzaW5nIHRoZSBJUCBhZGRyZXNzIG9mXG4gKiAgICAgICAvL3RoZSBjbGllbnRcbiAqICAgICAgIGlwOiB0cnVlXG4gKlxuICogICAgICAgLy8gb3B0IHVzZXJzIG91dCBvZiB0cmFja2luZyBieSB0aGlzIE1peHBhbmVsIGluc3RhbmNlIGJ5IGRlZmF1bHRcbiAqICAgICAgIG9wdF9vdXRfdHJhY2tpbmdfYnlfZGVmYXVsdDogZmFsc2VcbiAqXG4gKiAgICAgICAvLyBvcHQgdXNlcnMgb3V0IG9mIGJyb3dzZXIgZGF0YSBzdG9yYWdlIGJ5IHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UgYnkgZGVmYXVsdFxuICogICAgICAgb3B0X291dF9wZXJzaXN0ZW5jZV9ieV9kZWZhdWx0OiBmYWxzZVxuICpcbiAqICAgICAgIC8vIHBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIGJ5IG9wdC1pbi9vcHQtb3V0IG1ldGhvZHMgLSBjb29raWVcbiAqICAgICAgIC8vIG9yIGxvY2FsU3RvcmFnZSAtIGZhbGxzIGJhY2sgdG8gY29va2llIGlmIGxvY2FsU3RvcmFnZSBpcyB1bmF2YWlsYWJsZVxuICogICAgICAgb3B0X291dF90cmFja2luZ19wZXJzaXN0ZW5jZV90eXBlOiAnbG9jYWxTdG9yYWdlJ1xuICpcbiAqICAgICAgIC8vIGN1c3RvbWl6ZSB0aGUgbmFtZSBvZiBjb29raWUvbG9jYWxTdG9yYWdlIHNldCBieSBvcHQtaW4vb3B0LW91dCBtZXRob2RzXG4gKiAgICAgICBvcHRfb3V0X3RyYWNraW5nX2Nvb2tpZV9wcmVmaXg6IG51bGxcbiAqXG4gKiAgICAgICAvLyB0eXBlIG9mIHBlcnNpc3RlbnQgc3RvcmUgZm9yIHN1cGVyIHByb3BlcnRpZXMgKGNvb2tpZS9cbiAqICAgICAgIC8vIGxvY2FsU3RvcmFnZSkgaWYgc2V0IHRvICdsb2NhbFN0b3JhZ2UnLCBhbnkgZXhpc3RpbmdcbiAqICAgICAgIC8vIG1peHBhbmVsIGNvb2tpZSB2YWx1ZSB3aXRoIHRoZSBzYW1lIHBlcnNpc3RlbmNlX25hbWVcbiAqICAgICAgIC8vIHdpbGwgYmUgdHJhbnNmZXJyZWQgdG8gbG9jYWxTdG9yYWdlIGFuZCBkZWxldGVkXG4gKiAgICAgICBwZXJzaXN0ZW5jZTogJ2Nvb2tpZSdcbiAqXG4gKiAgICAgICAvLyBuYW1lIGZvciBzdXBlciBwcm9wZXJ0aWVzIHBlcnNpc3RlbnQgc3RvcmVcbiAqICAgICAgIHBlcnNpc3RlbmNlX25hbWU6ICcnXG4gKlxuICogICAgICAgLy8gbmFtZXMgb2YgcHJvcGVydGllcy9zdXBlcnByb3BlcnRpZXMgd2hpY2ggc2hvdWxkIG5ldmVyXG4gKiAgICAgICAvLyBiZSBzZW50IHdpdGggdHJhY2soKSBjYWxsc1xuICogICAgICAgcHJvcGVydHlfYmxhY2tsaXN0OiBbXVxuICpcbiAqICAgICAgIC8vIGlmIHRoaXMgaXMgdHJ1ZSwgbWl4cGFuZWwgY29va2llcyB3aWxsIGJlIG1hcmtlZCBhc1xuICogICAgICAgLy8gc2VjdXJlLCBtZWFuaW5nIHRoZXkgd2lsbCBvbmx5IGJlIHRyYW5zbWl0dGVkIG92ZXIgaHR0cHNcbiAqICAgICAgIHNlY3VyZV9jb29raWU6IGZhbHNlXG4gKlxuICogICAgICAgLy8gZGlzYWJsZXMgZW5yaWNoaW5nIHVzZXIgcHJvZmlsZXMgd2l0aCBmaXJzdCB0b3VjaCBtYXJrZXRpbmcgZGF0YVxuICogICAgICAgc2tpcF9maXJzdF90b3VjaF9tYXJrZXRpbmc6IGZhbHNlXG4gKlxuICogICAgICAgLy8gdGhlIGFtb3VudCBvZiB0aW1lIHRyYWNrX2xpbmtzIHdpbGxcbiAqICAgICAgIC8vIHdhaXQgZm9yIE1peHBhbmVsJ3Mgc2VydmVycyB0byByZXNwb25kXG4gKiAgICAgICB0cmFja19saW5rc190aW1lb3V0OiAzMDBcbiAqXG4gKiAgICAgICAvLyBhZGRzIGFueSBVVE0gcGFyYW1ldGVycyBhbmQgY2xpY2sgSURzIHByZXNlbnQgb24gdGhlIHBhZ2UgdG8gYW55IGV2ZW50cyBmaXJlZFxuICogICAgICAgdHJhY2tfbWFya2V0aW5nOiB0cnVlXG4gKlxuICogICAgICAgLy8gZW5hYmxlcyBhdXRvbWF0aWMgcGFnZSB2aWV3IHRyYWNraW5nIHVzaW5nIGRlZmF1bHQgcGFnZSB2aWV3IGV2ZW50cyB0aHJvdWdoXG4gKiAgICAgICAvLyB0aGUgdHJhY2tfcGFnZXZpZXcoKSBtZXRob2RcbiAqICAgICAgIHRyYWNrX3BhZ2V2aWV3OiBmYWxzZVxuICpcbiAqICAgICAgIC8vIGlmIHlvdSBzZXQgdXBncmFkZSB0byBiZSB0cnVlLCB0aGUgbGlicmFyeSB3aWxsIGNoZWNrIGZvclxuICogICAgICAgLy8gYSBjb29raWUgZnJvbSBvdXIgb2xkIGpzIGxpYnJhcnkgYW5kIGltcG9ydCBzdXBlclxuICogICAgICAgLy8gcHJvcGVydGllcyBmcm9tIGl0LCB0aGVuIHRoZSBvbGQgY29va2llIGlzIGRlbGV0ZWRcbiAqICAgICAgIC8vIFRoZSB1cGdyYWRlIGNvbmZpZyBvcHRpb24gb25seSB3b3JrcyBpbiB0aGUgaW5pdGlhbGl6YXRpb24sXG4gKiAgICAgICAvLyBzbyBtYWtlIHN1cmUgeW91IHNldCBpdCB3aGVuIHlvdSBjcmVhdGUgdGhlIGxpYnJhcnkuXG4gKiAgICAgICB1cGdyYWRlOiBmYWxzZVxuICpcbiAqICAgICAgIC8vIGV4dHJhIEhUVFAgcmVxdWVzdCBoZWFkZXJzIHRvIHNldCBmb3IgZWFjaCBBUEkgcmVxdWVzdCwgaW5cbiAqICAgICAgIC8vIHRoZSBmb3JtYXQgeydIZWFkZXItTmFtZSc6IHZhbHVlfVxuICogICAgICAgeGhyX2hlYWRlcnM6IHt9XG4gKlxuICogICAgICAgLy8gd2hldGhlciB0byBpZ25vcmUgb3IgcmVzcGVjdCB0aGUgd2ViIGJyb3dzZXIncyBEbyBOb3QgVHJhY2sgc2V0dGluZ1xuICogICAgICAgaWdub3JlX2RudDogZmFsc2VcbiAqICAgICB9XG4gKlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQSBkaWN0aW9uYXJ5IG9mIG5ldyBjb25maWd1cmF0aW9uIHZhbHVlcyB0byB1cGRhdGVcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnNldF9jb25maWcgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICBpZiAoXy5pc09iamVjdChjb25maWcpKSB7XG4gICAgICAgIF8uZXh0ZW5kKHRoaXNbJ2NvbmZpZyddLCBjb25maWcpO1xuXG4gICAgICAgIHZhciBuZXdfYmF0Y2hfc2l6ZSA9IGNvbmZpZ1snYmF0Y2hfc2l6ZSddO1xuICAgICAgICBpZiAobmV3X2JhdGNoX3NpemUpIHtcbiAgICAgICAgICAgIF8uZWFjaCh0aGlzLnJlcXVlc3RfYmF0Y2hlcnMsIGZ1bmN0aW9uKGJhdGNoZXIpIHtcbiAgICAgICAgICAgICAgICBiYXRjaGVyLnJlc2V0QmF0Y2hTaXplKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5nZXRfY29uZmlnKCdwZXJzaXN0ZW5jZV9uYW1lJykpIHtcbiAgICAgICAgICAgIHRoaXNbJ2NvbmZpZyddWydwZXJzaXN0ZW5jZV9uYW1lJ10gPSB0aGlzWydjb25maWcnXVsnY29va2llX25hbWUnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZ2V0X2NvbmZpZygnZGlzYWJsZV9wZXJzaXN0ZW5jZScpKSB7XG4gICAgICAgICAgICB0aGlzWydjb25maWcnXVsnZGlzYWJsZV9wZXJzaXN0ZW5jZSddID0gdGhpc1snY29uZmlnJ11bJ2Rpc2FibGVfY29va2llJ107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpc1sncGVyc2lzdGVuY2UnXSkge1xuICAgICAgICAgICAgdGhpc1sncGVyc2lzdGVuY2UnXS51cGRhdGVfY29uZmlnKHRoaXNbJ2NvbmZpZyddKTtcbiAgICAgICAgfVxuICAgICAgICBDb25maWcuREVCVUcgPSBDb25maWcuREVCVUcgfHwgdGhpcy5nZXRfY29uZmlnKCdkZWJ1ZycpO1xuXG4gICAgICAgIGlmICgoJ2F1dG9jYXB0dXJlJyBpbiBjb25maWcgfHwgJ3JlY29yZF9oZWF0bWFwX2RhdGEnIGluIGNvbmZpZykgJiYgdGhpcy5hdXRvY2FwdHVyZSkge1xuICAgICAgICAgICAgdGhpcy5hdXRvY2FwdHVyZS5pbml0KCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIHJldHVybnMgdGhlIGN1cnJlbnQgY29uZmlnIG9iamVjdCBmb3IgdGhlIGxpYnJhcnkuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfY29uZmlnID0gZnVuY3Rpb24ocHJvcF9uYW1lKSB7XG4gICAgcmV0dXJuIHRoaXNbJ2NvbmZpZyddW3Byb3BfbmFtZV07XG59O1xuXG4vKipcbiAqIEZldGNoIGEgaG9vayBmdW5jdGlvbiBmcm9tIGNvbmZpZywgd2l0aCBzYWZlIGRlZmF1bHQsIGFuZCBydW4gaXRcbiAqIGFnYWluc3QgdGhlIGdpdmVuIGFyZ3VtZW50c1xuICogQHBhcmFtIHtzdHJpbmd9IGhvb2tfbmFtZSB3aGljaCBob29rIHRvIHJldHJpZXZlXG4gKiBAcmV0dXJucyB7YW55fG51bGx9IHJldHVybiB2YWx1ZSBvZiB1c2VyLXByb3ZpZGVkIGhvb2ssIG9yIG51bGwgaWYgbm90aGluZyB3YXMgcmV0dXJuZWRcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9ydW5faG9vayA9IGZ1bmN0aW9uKGhvb2tfbmFtZSkge1xuICAgIHZhciByZXQgPSAodGhpc1snY29uZmlnJ11bJ2hvb2tzJ11baG9va19uYW1lXSB8fCBJREVOVElUWV9GVU5DKS5hcHBseSh0aGlzLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIGlmICh0eXBlb2YgcmV0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLnJlcG9ydF9lcnJvcihob29rX25hbWUgKyAnIGhvb2sgZGlkIG5vdCByZXR1cm4gYSB2YWx1ZScpO1xuICAgICAgICByZXQgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgc3VwZXIgcHJvcGVydHkgbmFtZWQgcHJvcGVydHlfbmFtZS4gSWYgbm8gc3VjaFxuICogcHJvcGVydHkgaXMgc2V0LCBnZXRfcHJvcGVydHkoKSB3aWxsIHJldHVybiB0aGUgdW5kZWZpbmVkIHZhbHVlLlxuICpcbiAqICMjIyBOb3RlczpcbiAqXG4gKiBnZXRfcHJvcGVydHkoKSBjYW4gb25seSBiZSBjYWxsZWQgYWZ0ZXIgdGhlIE1peHBhbmVsIGxpYnJhcnkgaGFzIGZpbmlzaGVkIGxvYWRpbmcuXG4gKiBpbml0KCkgaGFzIGEgbG9hZGVkIGZ1bmN0aW9uIGF2YWlsYWJsZSB0byBoYW5kbGUgdGhpcyBhdXRvbWF0aWNhbGx5LiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gZ3JhYiB2YWx1ZSBmb3IgJ3VzZXJfaWQnIGFmdGVyIHRoZSBtaXhwYW5lbCBsaWJyYXJ5IGhhcyBsb2FkZWRcbiAqICAgICBtaXhwYW5lbC5pbml0KCdZT1VSIFBST0pFQ1QgVE9LRU4nLCB7XG4gKiAgICAgICAgIGxvYWRlZDogZnVuY3Rpb24obWl4cGFuZWwpIHtcbiAqICAgICAgICAgICAgIHVzZXJfaWQgPSBtaXhwYW5lbC5nZXRfcHJvcGVydHkoJ3VzZXJfaWQnKTtcbiAqICAgICAgICAgfVxuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eV9uYW1lIFRoZSBuYW1lIG9mIHRoZSBzdXBlciBwcm9wZXJ0eSB5b3Ugd2FudCB0byByZXRyaWV2ZVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X3Byb3BlcnR5ID0gZnVuY3Rpb24ocHJvcGVydHlfbmFtZSkge1xuICAgIHJldHVybiB0aGlzWydwZXJzaXN0ZW5jZSddLmxvYWRfcHJvcChbcHJvcGVydHlfbmFtZV0pO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIEFQSSBob3N0IGZvciBhIHNwZWNpZmljIGVuZHBvaW50IHR5cGUsIGZhbGxpbmcgYmFjayB0byB0aGUgZGVmYXVsdCBhcGlfaG9zdCBpZiBub3Qgc3BlY2lmaWVkXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGVuZHBvaW50X3R5cGUgVGhlIHR5cGUgb2YgZW5kcG9pbnQgKGUuZy4sIFwiZXZlbnRzXCIsIFwicGVvcGxlXCIsIFwiZ3JvdXBzXCIpXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgQVBJIGhvc3QgdG8gdXNlIGZvciB0aGlzIGVuZHBvaW50XG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfYXBpX2hvc3QgPSBmdW5jdGlvbihlbmRwb2ludF90eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0X2NvbmZpZygnYXBpX2hvc3RzJylbZW5kcG9pbnRfdHlwZV0gfHwgdGhpcy5nZXRfY29uZmlnKCdhcGlfaG9zdCcpO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5hbWUgPSB0aGlzLmdldF9jb25maWcoJ25hbWUnKTtcbiAgICBpZiAobmFtZSAhPT0gUFJJTUFSWV9JTlNUQU5DRV9OQU1FKSB7XG4gICAgICAgIG5hbWUgPSBQUklNQVJZX0lOU1RBTkNFX05BTUUgKyAnLicgKyBuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fZXZlbnRfaXNfZGlzYWJsZWQgPSBmdW5jdGlvbihldmVudF9uYW1lKSB7XG4gICAgcmV0dXJuIF8uaXNCbG9ja2VkVUEodXNlckFnZW50KSB8fFxuICAgICAgICB0aGlzLl9mbGFncy5kaXNhYmxlX2FsbF9ldmVudHMgfHxcbiAgICAgICAgXy5pbmNsdWRlKHRoaXMuX19kaXNhYmxlZF9ldmVudHMsIGV2ZW50X25hbWUpO1xufTtcblxuLy8gcGVyZm9ybSBzb21lIGhvdXNla2VlcGluZyBhcm91bmQgR0RQUiBvcHQtaW4vb3V0IHN0YXRlXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2dkcHJfaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpc19sb2NhbFN0b3JhZ2VfcmVxdWVzdGVkID0gdGhpcy5nZXRfY29uZmlnKCdvcHRfb3V0X3RyYWNraW5nX3BlcnNpc3RlbmNlX3R5cGUnKSA9PT0gJ2xvY2FsU3RvcmFnZSc7XG5cbiAgICAvLyB0cnkgdG8gY29udmVydCBvcHQtaW4vb3V0IGNvb2tpZXMgdG8gbG9jYWxTdG9yYWdlIGlmIHBvc3NpYmxlXG4gICAgaWYgKGlzX2xvY2FsU3RvcmFnZV9yZXF1ZXN0ZWQgJiYgXy5sb2NhbFN0b3JhZ2UuaXNfc3VwcG9ydGVkKCkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc19vcHRlZF9pbl90cmFja2luZygpICYmIHRoaXMuaGFzX29wdGVkX2luX3RyYWNraW5nKHsncGVyc2lzdGVuY2VfdHlwZSc6ICdjb29raWUnfSkpIHtcbiAgICAgICAgICAgIHRoaXMub3B0X2luX3RyYWNraW5nKHsnZW5hYmxlX3BlcnNpc3RlbmNlJzogZmFsc2V9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaGFzX29wdGVkX291dF90cmFja2luZygpICYmIHRoaXMuaGFzX29wdGVkX291dF90cmFja2luZyh7J3BlcnNpc3RlbmNlX3R5cGUnOiAnY29va2llJ30pKSB7XG4gICAgICAgICAgICB0aGlzLm9wdF9vdXRfdHJhY2tpbmcoeydjbGVhcl9wZXJzaXN0ZW5jZSc6IGZhbHNlfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhcl9vcHRfaW5fb3V0X3RyYWNraW5nKHtcbiAgICAgICAgICAgICdwZXJzaXN0ZW5jZV90eXBlJzogJ2Nvb2tpZScsXG4gICAgICAgICAgICAnZW5hYmxlX3BlcnNpc3RlbmNlJzogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgd2hldGhlciB0aGUgdXNlciBoYXMgYWxyZWFkeSBvcHRlZCBvdXQgLSBpZiBzbywgY2xlYXIgJiBkaXNhYmxlIHBlcnNpc3RlbmNlXG4gICAgaWYgKHRoaXMuaGFzX29wdGVkX291dF90cmFja2luZygpKSB7XG4gICAgICAgIHRoaXMuX2dkcHJfdXBkYXRlX3BlcnNpc3RlbmNlKHsnY2xlYXJfcGVyc2lzdGVuY2UnOiB0cnVlfSk7XG5cbiAgICAvLyBjaGVjayB3aGV0aGVyIHdlIHNob3VsZCBvcHQgb3V0IGJ5IGRlZmF1bHRcbiAgICAvLyBub3RlOiB3ZSBkb24ndCBjbGVhciBwZXJzaXN0ZW5jZSBoZXJlIGJ5IGRlZmF1bHQgc2luY2Ugb3B0LW91dCBkZWZhdWx0IHN0YXRlIGlzIG9mdGVuXG4gICAgLy8gICAgICAgdXNlZCBhcyBhbiBpbml0aWFsIHN0YXRlIHdoaWxlIEdEUFIgaW5mb3JtYXRpb24gaXMgYmVpbmcgY29sbGVjdGVkXG4gICAgfSBlbHNlIGlmICghdGhpcy5oYXNfb3B0ZWRfaW5fdHJhY2tpbmcoKSAmJiAoXG4gICAgICAgIHRoaXMuZ2V0X2NvbmZpZygnb3B0X291dF90cmFja2luZ19ieV9kZWZhdWx0JykgfHwgXy5jb29raWUuZ2V0KCdtcF9vcHRvdXQnKVxuICAgICkpIHtcbiAgICAgICAgXy5jb29raWUucmVtb3ZlKCdtcF9vcHRvdXQnKTtcbiAgICAgICAgdGhpcy5vcHRfb3V0X3RyYWNraW5nKHtcbiAgICAgICAgICAgICdjbGVhcl9wZXJzaXN0ZW5jZSc6IHRoaXMuZ2V0X2NvbmZpZygnb3B0X291dF9wZXJzaXN0ZW5jZV9ieV9kZWZhdWx0JylcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBFbmFibGUgb3IgZGlzYWJsZSBwZXJzaXN0ZW5jZSBiYXNlZCBvbiBvcHRpb25zXG4gKiBvbmx5IGVuYWJsZS9kaXNhYmxlIGlmIHBlcnNpc3RlbmNlIGlzIG5vdCBhbHJlYWR5IGluIHRoaXMgc3RhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2xlYXJfcGVyc2lzdGVuY2VdIElmIHRydWUsIHdpbGwgZGVsZXRlIGFsbCBkYXRhIHN0b3JlZCBieSB0aGUgc2RrIGluIHBlcnNpc3RlbmNlIGFuZCBkaXNhYmxlIGl0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZV9wZXJzaXN0ZW5jZV0gSWYgdHJ1ZSwgd2lsbCByZS1lbmFibGUgc2RrIHBlcnNpc3RlbmNlXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fZ2Rwcl91cGRhdGVfcGVyc2lzdGVuY2UgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGRpc2FibGVkO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnNbJ2NsZWFyX3BlcnNpc3RlbmNlJ10pIHtcbiAgICAgICAgZGlzYWJsZWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucyAmJiBvcHRpb25zWydlbmFibGVfcGVyc2lzdGVuY2UnXSkge1xuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZ2V0X2NvbmZpZygnZGlzYWJsZV9wZXJzaXN0ZW5jZScpICYmIHRoaXNbJ3BlcnNpc3RlbmNlJ10uZGlzYWJsZWQgIT09IGRpc2FibGVkKSB7XG4gICAgICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10uc2V0X2Rpc2FibGVkKGRpc2FibGVkKTtcbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zdG9wX2JhdGNoX3NlbmRlcnMoKTtcbiAgICAgICAgdGhpcy5zdG9wX3Nlc3Npb25fcmVjb3JkaW5nKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb25seSBzdGFydCBiYXRjaGVycyBhZnRlciBvcHQtaW4gaWYgdGhleSBoYXZlIHByZXZpb3VzbHkgYmVlbiBzdGFydGVkXG4gICAgICAgIC8vIGluIG9yZGVyIHRvIGF2b2lkIHVuaW50ZW50aW9uYWxseSBzdGFydGluZyB1cCBiYXRjaGluZyBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgaWYgKHRoaXMuX2JhdGNoZXJzX3dlcmVfc3RhcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydF9iYXRjaF9zZW5kZXJzKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLyBjYWxsIGEgYmFzZSBnZHByIGZ1bmN0aW9uIGFmdGVyIGNvbnN0cnVjdGluZyB0aGUgYXBwcm9wcmlhdGUgdG9rZW4gYW5kIG9wdGlvbnMgYXJnc1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9nZHByX2NhbGxfZnVuYyA9IGZ1bmN0aW9uKGZ1bmMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gXy5leHRlbmQoe1xuICAgICAgICAndHJhY2snOiBfLmJpbmQodGhpcy50cmFjaywgdGhpcyksXG4gICAgICAgICdwZXJzaXN0ZW5jZV90eXBlJzogdGhpcy5nZXRfY29uZmlnKCdvcHRfb3V0X3RyYWNraW5nX3BlcnNpc3RlbmNlX3R5cGUnKSxcbiAgICAgICAgJ2Nvb2tpZV9wcmVmaXgnOiB0aGlzLmdldF9jb25maWcoJ29wdF9vdXRfdHJhY2tpbmdfY29va2llX3ByZWZpeCcpLFxuICAgICAgICAnY29va2llX2V4cGlyYXRpb24nOiB0aGlzLmdldF9jb25maWcoJ2Nvb2tpZV9leHBpcmF0aW9uJyksXG4gICAgICAgICdjcm9zc19zaXRlX2Nvb2tpZSc6IHRoaXMuZ2V0X2NvbmZpZygnY3Jvc3Nfc2l0ZV9jb29raWUnKSxcbiAgICAgICAgJ2Nyb3NzX3N1YmRvbWFpbl9jb29raWUnOiB0aGlzLmdldF9jb25maWcoJ2Nyb3NzX3N1YmRvbWFpbl9jb29raWUnKSxcbiAgICAgICAgJ2Nvb2tpZV9kb21haW4nOiB0aGlzLmdldF9jb25maWcoJ2Nvb2tpZV9kb21haW4nKSxcbiAgICAgICAgJ3NlY3VyZV9jb29raWUnOiB0aGlzLmdldF9jb25maWcoJ3NlY3VyZV9jb29raWUnKSxcbiAgICAgICAgJ2lnbm9yZV9kbnQnOiB0aGlzLmdldF9jb25maWcoJ2lnbm9yZV9kbnQnKVxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgLy8gY2hlY2sgaWYgbG9jYWxTdG9yYWdlIGNhbiBiZSB1c2VkIGZvciByZWNvcmRpbmcgb3B0IG91dCBzdGF0dXMsIGZhbGwgYmFjayB0byBjb29raWUgaWYgbm90XG4gICAgaWYgKCFfLmxvY2FsU3RvcmFnZS5pc19zdXBwb3J0ZWQoKSkge1xuICAgICAgICBvcHRpb25zWydwZXJzaXN0ZW5jZV90eXBlJ10gPSAnY29va2llJztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuYyh0aGlzLmdldF9jb25maWcoJ3Rva2VuJyksIHtcbiAgICAgICAgdHJhY2s6IG9wdGlvbnNbJ3RyYWNrJ10sXG4gICAgICAgIHRyYWNrRXZlbnROYW1lOiBvcHRpb25zWyd0cmFja19ldmVudF9uYW1lJ10sXG4gICAgICAgIHRyYWNrUHJvcGVydGllczogb3B0aW9uc1sndHJhY2tfcHJvcGVydGllcyddLFxuICAgICAgICBwZXJzaXN0ZW5jZVR5cGU6IG9wdGlvbnNbJ3BlcnNpc3RlbmNlX3R5cGUnXSxcbiAgICAgICAgcGVyc2lzdGVuY2VQcmVmaXg6IG9wdGlvbnNbJ2Nvb2tpZV9wcmVmaXgnXSxcbiAgICAgICAgY29va2llRG9tYWluOiBvcHRpb25zWydjb29raWVfZG9tYWluJ10sXG4gICAgICAgIGNvb2tpZUV4cGlyYXRpb246IG9wdGlvbnNbJ2Nvb2tpZV9leHBpcmF0aW9uJ10sXG4gICAgICAgIGNyb3NzU2l0ZUNvb2tpZTogb3B0aW9uc1snY3Jvc3Nfc2l0ZV9jb29raWUnXSxcbiAgICAgICAgY3Jvc3NTdWJkb21haW5Db29raWU6IG9wdGlvbnNbJ2Nyb3NzX3N1YmRvbWFpbl9jb29raWUnXSxcbiAgICAgICAgc2VjdXJlQ29va2llOiBvcHRpb25zWydzZWN1cmVfY29va2llJ10sXG4gICAgICAgIGlnbm9yZURudDogb3B0aW9uc1snaWdub3JlX2RudCddXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIE9wdCB0aGUgdXNlciBpbiB0byBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZVxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gb3B0IHVzZXIgaW5cbiAqICAgICBtaXhwYW5lbC5vcHRfaW5fdHJhY2tpbmcoKTtcbiAqXG4gKiAgICAgLy8gb3B0IHVzZXIgaW4gd2l0aCBzcGVjaWZpYyBldmVudCBuYW1lLCBwcm9wZXJ0aWVzLCBjb29raWUgY29uZmlndXJhdGlvblxuICogICAgIG1peHBhbmVsLm9wdF9pbl90cmFja2luZyh7XG4gKiAgICAgICAgIHRyYWNrX2V2ZW50X25hbWU6ICdVc2VyIG9wdGVkIGluJyxcbiAqICAgICAgICAgdHJhY2tfZXZlbnRfcHJvcGVydGllczoge1xuICogICAgICAgICAgICAgJ0VtYWlsJzogJ2pkb2VAZXhhbXBsZS5jb20nXG4gKiAgICAgICAgIH0sXG4gKiAgICAgICAgIGNvb2tpZV9leHBpcmF0aW9uOiAzMCxcbiAqICAgICAgICAgc2VjdXJlX2Nvb2tpZTogdHJ1ZVxuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9mIGNvbmZpZyBvcHRpb25zIHRvIG92ZXJyaWRlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy50cmFja10gRnVuY3Rpb24gdXNlZCBmb3IgdHJhY2tpbmcgYSBNaXhwYW5lbCBldmVudCB0byByZWNvcmQgdGhlIG9wdC1pbiBhY3Rpb24gKGRlZmF1bHQgaXMgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIHRyYWNrIG1ldGhvZClcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50cmFja19ldmVudF9uYW1lPSRvcHRfaW5dIEV2ZW50IG5hbWUgdG8gYmUgdXNlZCBmb3IgdHJhY2tpbmcgdGhlIG9wdC1pbiBhY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy50cmFja19wcm9wZXJ0aWVzXSBTZXQgb2YgcHJvcGVydGllcyB0byBiZSB0cmFja2VkIGFsb25nIHdpdGggdGhlIG9wdC1pbiBhY3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZW5hYmxlX3BlcnNpc3RlbmNlPXRydWVdIElmIHRydWUsIHdpbGwgcmUtZW5hYmxlIHNkayBwZXJzaXN0ZW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlX3R5cGU9bG9jYWxTdG9yYWdlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2UgLSBmYWxscyBiYWNrIHRvIGNvb2tpZSBpZiBsb2NhbFN0b3JhZ2UgaXMgdW5hdmFpbGFibGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVfcHJlZml4PV9fbXBfb3B0X2luX291dF0gQ3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29raWVfZXhwaXJhdGlvbl0gTnVtYmVyIG9mIGRheXMgdW50aWwgdGhlIG9wdC1pbiBjb29raWUgZXhwaXJlcyAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZV9kb21haW5dIEN1c3RvbSBjb29raWUgZG9tYWluIChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzX3NpdGVfY29va2llXSBXaGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zaXRlLWVuYWJsZWQgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3Nfc3ViZG9tYWluX2Nvb2tpZV0gV2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc3ViZG9tYWluIG9yIG5vdCAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWN1cmVfY29va2llXSBXaGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBzZWN1cmUgb3Igbm90IChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5vcHRfaW5fdHJhY2tpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHtcbiAgICAgICAgJ2VuYWJsZV9wZXJzaXN0ZW5jZSc6IHRydWVcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIHRoaXMuX2dkcHJfY2FsbF9mdW5jKG9wdEluLCBvcHRpb25zKTtcbiAgICB0aGlzLl9nZHByX3VwZGF0ZV9wZXJzaXN0ZW5jZShvcHRpb25zKTtcbn07XG5cbi8qKlxuICogT3B0IHRoZSB1c2VyIG91dCBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZVxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gb3B0IHVzZXIgb3V0XG4gKiAgICAgbWl4cGFuZWwub3B0X291dF90cmFja2luZygpO1xuICpcbiAqICAgICAvLyBvcHQgdXNlciBvdXQgd2l0aCBkaWZmZXJlbnQgY29va2llIGNvbmZpZ3VyYXRpb24gZnJvbSBNaXhwYW5lbCBpbnN0YW5jZVxuICogICAgIG1peHBhbmVsLm9wdF9vdXRfdHJhY2tpbmcoe1xuICogICAgICAgICBjb29raWVfZXhwaXJhdGlvbjogMzAsXG4gKiAgICAgICAgIHNlY3VyZV9jb29raWU6IHRydWVcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvZiBjb25maWcgb3B0aW9ucyB0byBvdmVycmlkZVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5kZWxldGVfdXNlcj10cnVlXSBJZiB0cnVlLCB3aWxsIGRlbGV0ZSB0aGUgY3VycmVudGx5IGlkZW50aWZpZWQgdXNlcidzIHByb2ZpbGUgYW5kIGNsZWFyIGFsbCBjaGFyZ2VzIGFmdGVyIG9wdGluZyB0aGUgdXNlciBvdXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2xlYXJfcGVyc2lzdGVuY2U9dHJ1ZV0gSWYgdHJ1ZSwgd2lsbCBkZWxldGUgYWxsIGRhdGEgc3RvcmVkIGJ5IHRoZSBzZGsgaW4gcGVyc2lzdGVuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZV90eXBlPWxvY2FsU3RvcmFnZV0gUGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgLSBjb29raWUgb3IgbG9jYWxTdG9yYWdlIC0gZmFsbHMgYmFjayB0byBjb29raWUgaWYgbG9jYWxTdG9yYWdlIGlzIHVuYXZhaWxhYmxlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llX3ByZWZpeD1fX21wX29wdF9pbl9vdXRdIEN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29va2llX2V4cGlyYXRpb25dIE51bWJlciBvZiBkYXlzIHVudGlsIHRoZSBvcHQtaW4gY29va2llIGV4cGlyZXMgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVfZG9tYWluXSBDdXN0b20gY29va2llIGRvbWFpbiAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc19zaXRlX2Nvb2tpZV0gV2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc2l0ZS1lbmFibGVkIChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzX3N1YmRvbWFpbl9jb29raWVdIFdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXN1YmRvbWFpbiBvciBub3QgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VjdXJlX2Nvb2tpZV0gV2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgc2VjdXJlIG9yIG5vdCAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUub3B0X291dF90cmFja2luZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gXy5leHRlbmQoe1xuICAgICAgICAnY2xlYXJfcGVyc2lzdGVuY2UnOiB0cnVlLFxuICAgICAgICAnZGVsZXRlX3VzZXInOiB0cnVlXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICAvLyBkZWxldGUgdXNlciBhbmQgY2xlYXIgY2hhcmdlcyBzaW5jZSB0aGVzZSBtZXRob2RzIG1heSBiZSBkaXNhYmxlZCBieSBvcHQtb3V0XG4gICAgaWYgKG9wdGlvbnNbJ2RlbGV0ZV91c2VyJ10gJiYgdGhpc1sncGVvcGxlJ10gJiYgdGhpc1sncGVvcGxlJ10uX2lkZW50aWZ5X2NhbGxlZCgpKSB7XG4gICAgICAgIHRoaXNbJ3Blb3BsZSddLmRlbGV0ZV91c2VyKCk7XG4gICAgICAgIHRoaXNbJ3Blb3BsZSddLmNsZWFyX2NoYXJnZXMoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9nZHByX2NhbGxfZnVuYyhvcHRPdXQsIG9wdGlvbnMpO1xuICAgIHRoaXMuX2dkcHJfdXBkYXRlX3BlcnNpc3RlbmNlKG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSB1c2VyIGhhcyBvcHRlZCBpbiB0byBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZVxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgdmFyIGhhc19vcHRlZF9pbiA9IG1peHBhbmVsLmhhc19vcHRlZF9pbl90cmFja2luZygpO1xuICogICAgIC8vIHVzZSBoYXNfb3B0ZWRfaW4gdmFsdWVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvZiBjb25maWcgb3B0aW9ucyB0byBvdmVycmlkZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlX3R5cGU9bG9jYWxTdG9yYWdlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2UgLSBmYWxscyBiYWNrIHRvIGNvb2tpZSBpZiBsb2NhbFN0b3JhZ2UgaXMgdW5hdmFpbGFibGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVfcHJlZml4PV9fbXBfb3B0X2luX291dF0gQ3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBjdXJyZW50IG9wdC1pbiBzdGF0dXNcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmhhc19vcHRlZF9pbl90cmFja2luZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2Rwcl9jYWxsX2Z1bmMoaGFzT3B0ZWRJbiwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIHVzZXIgaGFzIG9wdGVkIG91dCBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZVxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgdmFyIGhhc19vcHRlZF9vdXQgPSBtaXhwYW5lbC5oYXNfb3B0ZWRfb3V0X3RyYWNraW5nKCk7XG4gKiAgICAgLy8gdXNlIGhhc19vcHRlZF9vdXQgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvZiBjb25maWcgb3B0aW9ucyB0byBvdmVycmlkZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlX3R5cGU9bG9jYWxTdG9yYWdlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2UgLSBmYWxscyBiYWNrIHRvIGNvb2tpZSBpZiBsb2NhbFN0b3JhZ2UgaXMgdW5hdmFpbGFibGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVfcHJlZml4PV9fbXBfb3B0X2luX291dF0gQ3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBjdXJyZW50IG9wdC1vdXQgc3RhdHVzXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5oYXNfb3B0ZWRfb3V0X3RyYWNraW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9nZHByX2NhbGxfZnVuYyhoYXNPcHRlZE91dCwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIENsZWFyIHRoZSB1c2VyJ3Mgb3B0IGluL291dCBzdGF0dXMgb2YgZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2VcbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIGNsZWFyIHVzZXIncyBvcHQtaW4vb3V0IHN0YXR1c1xuICogICAgIG1peHBhbmVsLmNsZWFyX29wdF9pbl9vdXRfdHJhY2tpbmcoKTtcbiAqXG4gKiAgICAgLy8gY2xlYXIgdXNlcidzIG9wdC1pbi9vdXQgc3RhdHVzIHdpdGggc3BlY2lmaWMgY29va2llIGNvbmZpZ3VyYXRpb24gLSBzaG91bGQgbWF0Y2hcbiAqICAgICAvLyBjb25maWd1cmF0aW9uIHVzZWQgd2hlbiBvcHRfaW5fdHJhY2tpbmcvb3B0X291dF90cmFja2luZyBtZXRob2RzIHdlcmUgY2FsbGVkLlxuICogICAgIG1peHBhbmVsLmNsZWFyX29wdF9pbl9vdXRfdHJhY2tpbmcoe1xuICogICAgICAgICBjb29raWVfZXhwaXJhdGlvbjogMzAsXG4gKiAgICAgICAgIHNlY3VyZV9jb29raWU6IHRydWVcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvZiBjb25maWcgb3B0aW9ucyB0byBvdmVycmlkZVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5lbmFibGVfcGVyc2lzdGVuY2U9dHJ1ZV0gSWYgdHJ1ZSwgd2lsbCByZS1lbmFibGUgc2RrIHBlcnNpc3RlbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VfdHlwZT1sb2NhbFN0b3JhZ2VdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZSAtIGZhbGxzIGJhY2sgdG8gY29va2llIGlmIGxvY2FsU3RvcmFnZSBpcyB1bmF2YWlsYWJsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZV9wcmVmaXg9X19tcF9vcHRfaW5fb3V0XSBDdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb2tpZV9leHBpcmF0aW9uXSBOdW1iZXIgb2YgZGF5cyB1bnRpbCB0aGUgb3B0LWluIGNvb2tpZSBleHBpcmVzIChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llX2RvbWFpbl0gQ3VzdG9tIGNvb2tpZSBkb21haW4gKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3Nfc2l0ZV9jb29raWVdIFdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXNpdGUtZW5hYmxlZCAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc19zdWJkb21haW5fY29va2llXSBXaGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zdWJkb21haW4gb3Igbm90IChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlY3VyZV9jb29raWVdIFdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIHNlY3VyZSBvciBub3QgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmNsZWFyX29wdF9pbl9vdXRfdHJhY2tpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHtcbiAgICAgICAgJ2VuYWJsZV9wZXJzaXN0ZW5jZSc6IHRydWVcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIHRoaXMuX2dkcHJfY2FsbF9mdW5jKGNsZWFyT3B0SW5PdXQsIG9wdGlvbnMpO1xuICAgIHRoaXMuX2dkcHJfdXBkYXRlX3BlcnNpc3RlbmNlKG9wdGlvbnMpO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlcG9ydF9lcnJvciA9IGZ1bmN0aW9uKG1zZywgZXJyKSB7XG4gICAgY29uc29sZSQxLmVycm9yLmFwcGx5KGNvbnNvbGUkMS5lcnJvciwgYXJndW1lbnRzKTtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIWVyciAmJiAhKG1zZyBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgICAgbXNnID0gbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZXRfY29uZmlnKCdlcnJvcl9yZXBvcnRlcicpKG1zZywgZXJyKTtcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgICBjb25zb2xlJDEuZXJyb3IoZXJyKTtcbiAgICB9XG59O1xuXG4vLyBFWFBPUlRTIChmb3IgY2xvc3VyZSBjb21waWxlcilcblxuLy8gTWl4cGFuZWxMaWIgRXhwb3J0c1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydpbml0J10gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuaW5pdDtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsncmVzZXQnXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlc2V0O1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydkaXNhYmxlJ10gICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuZGlzYWJsZTtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsndGltZV9ldmVudCddICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnRpbWVfZXZlbnQ7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3RyYWNrJ10gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS50cmFjaztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsndHJhY2tfbGlua3MnXSAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnRyYWNrX2xpbmtzO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyd0cmFja19mb3JtcyddICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2tfZm9ybXM7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3RyYWNrX3BhZ2V2aWV3J10gICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS50cmFja19wYWdldmlldztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsncmVnaXN0ZXInXSAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlZ2lzdGVyO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydyZWdpc3Rlcl9vbmNlJ10gICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUucmVnaXN0ZXJfb25jZTtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsndW5yZWdpc3RlciddICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnVucmVnaXN0ZXI7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2lkZW50aWZ5J10gICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5pZGVudGlmeTtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnYWxpYXMnXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmFsaWFzO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyduYW1lX3RhZyddICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUubmFtZV90YWc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3NldF9jb25maWcnXSAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5zZXRfY29uZmlnO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydnZXRfY29uZmlnJ10gICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X2NvbmZpZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnZ2V0X2FwaV9ob3N0J10gICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9hcGlfaG9zdDtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnZ2V0X3Byb3BlcnR5J10gICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9wcm9wZXJ0eTtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnZ2V0X2Rpc3RpbmN0X2lkJ10gICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9kaXN0aW5jdF9pZDtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsndG9TdHJpbmcnXSAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnRvU3RyaW5nO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydvcHRfb3V0X3RyYWNraW5nJ10gICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUub3B0X291dF90cmFja2luZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnb3B0X2luX3RyYWNraW5nJ10gICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLm9wdF9pbl90cmFja2luZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnaGFzX29wdGVkX291dF90cmFja2luZyddICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmhhc19vcHRlZF9vdXRfdHJhY2tpbmc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2hhc19vcHRlZF9pbl90cmFja2luZyddICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5oYXNfb3B0ZWRfaW5fdHJhY2tpbmc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2NsZWFyX29wdF9pbl9vdXRfdHJhY2tpbmcnXSAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5jbGVhcl9vcHRfaW5fb3V0X3RyYWNraW5nO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydnZXRfZ3JvdXAnXSAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X2dyb3VwO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydzZXRfZ3JvdXAnXSAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuc2V0X2dyb3VwO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydhZGRfZ3JvdXAnXSAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuYWRkX2dyb3VwO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydyZW1vdmVfZ3JvdXAnXSAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUucmVtb3ZlX2dyb3VwO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyd0cmFja193aXRoX2dyb3VwcyddICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2tfd2l0aF9ncm91cHM7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3N0YXJ0X2JhdGNoX3NlbmRlcnMnXSAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5zdGFydF9iYXRjaF9zZW5kZXJzO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydzdG9wX2JhdGNoX3NlbmRlcnMnXSAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuc3RvcF9iYXRjaF9zZW5kZXJzO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydzdGFydF9zZXNzaW9uX3JlY29yZGluZyddICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuc3RhcnRfc2Vzc2lvbl9yZWNvcmRpbmc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3N0b3Bfc2Vzc2lvbl9yZWNvcmRpbmcnXSAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5zdG9wX3Nlc3Npb25fcmVjb3JkaW5nO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydwYXVzZV9zZXNzaW9uX3JlY29yZGluZyddICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUucGF1c2Vfc2Vzc2lvbl9yZWNvcmRpbmc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3Jlc3VtZV9zZXNzaW9uX3JlY29yZGluZyddICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5yZXN1bWVfc2Vzc2lvbl9yZWNvcmRpbmc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2dldF9zZXNzaW9uX3JlY29yZGluZ19wcm9wZXJ0aWVzJ10gICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfc2Vzc2lvbl9yZWNvcmRpbmdfcHJvcGVydGllcztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnZ2V0X3Nlc3Npb25fcmVwbGF5X3VybCddICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9zZXNzaW9uX3JlcGxheV91cmw7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2dldF90YWJfaWQnXSAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfdGFiX2lkO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydERUZBVUxUX0FQSV9ST1VURVMnXSAgICAgICAgICAgICAgICAgPSBERUZBVUxUX0FQSV9ST1VURVM7XG5cbi8vIEV4cG9ydHMgaW50ZW5kZWQgb25seSBmb3IgdGVzdGluZ1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydfX2dldF9yZWNvcmRlciddICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuX19nZXRfcmVjb3JkZXI7XG5cbi8vIE1peHBhbmVsUGVyc2lzdGVuY2UgRXhwb3J0c1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGVbJ3Byb3BlcnRpZXMnXSAgICAgICAgICAgID0gTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUucHJvcGVydGllcztcbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlWyd1cGRhdGVfc2VhcmNoX2tleXdvcmQnXSA9IE1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnVwZGF0ZV9zZWFyY2hfa2V5d29yZDtcbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlWyd1cGRhdGVfcmVmZXJyZXJfaW5mbyddICA9IE1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnVwZGF0ZV9yZWZlcnJlcl9pbmZvO1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGVbJ2dldF9jcm9zc19zdWJkb21haW4nXSAgID0gTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuZ2V0X2Nyb3NzX3N1YmRvbWFpbjtcbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlWydjbGVhciddICAgICAgICAgICAgICAgICA9IE1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLmNsZWFyO1xuXG5cbnZhciBpbnN0YW5jZXMgPSB7fTtcbnZhciBleHRlbmRfbXAgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBhZGQgYWxsIHRoZSBzdWIgbWl4cGFuZWwgaW5zdGFuY2VzXG4gICAgXy5lYWNoKGluc3RhbmNlcywgZnVuY3Rpb24oaW5zdGFuY2UsIG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUgIT09IFBSSU1BUllfSU5TVEFOQ0VfTkFNRSkgeyBtaXhwYW5lbF9tYXN0ZXJbbmFtZV0gPSBpbnN0YW5jZTsgfVxuICAgIH0pO1xuXG4gICAgLy8gYWRkIHByaXZhdGUgZnVuY3Rpb25zIGFzIF9cbiAgICBtaXhwYW5lbF9tYXN0ZXJbJ18nXSA9IF87XG59O1xuXG52YXIgb3ZlcnJpZGVfbXBfaW5pdF9mdW5jID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gd2Ugb3ZlcnJpZGUgdGhlIHNuaXBwZXRzIGluaXQgZnVuY3Rpb24gdG8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIGFcbiAgICAvLyB1c2VyIGluaXRpYWxpemVzIHRoZSBtaXhwYW5lbCBsaWJyYXJ5IGFmdGVyIHRoZSBzY3JpcHQgbG9hZHMgJiBydW5zXG4gICAgbWl4cGFuZWxfbWFzdGVyWydpbml0J10gPSBmdW5jdGlvbih0b2tlbiwgY29uZmlnLCBuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAvLyBpbml0aWFsaXplIGEgc3ViIGxpYnJhcnlcbiAgICAgICAgICAgIGlmICghbWl4cGFuZWxfbWFzdGVyW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgbWl4cGFuZWxfbWFzdGVyW25hbWVdID0gaW5zdGFuY2VzW25hbWVdID0gY3JlYXRlX21wbGliKHRva2VuLCBjb25maWcsIG5hbWUpO1xuICAgICAgICAgICAgICAgIG1peHBhbmVsX21hc3RlcltuYW1lXS5fbG9hZGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWl4cGFuZWxfbWFzdGVyW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gbWl4cGFuZWxfbWFzdGVyO1xuXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2VzW1BSSU1BUllfSU5TVEFOQ0VfTkFNRV0pIHtcbiAgICAgICAgICAgICAgICAvLyBtYWluIG1peHBhbmVsIGxpYiBhbHJlYWR5IGluaXRpYWxpemVkXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UgPSBpbnN0YW5jZXNbUFJJTUFSWV9JTlNUQU5DRV9OQU1FXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBpbnRpYWxpemUgdGhlIG1haW4gbWl4cGFuZWwgbGliXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UgPSBjcmVhdGVfbXBsaWIodG9rZW4sIGNvbmZpZywgUFJJTUFSWV9JTlNUQU5DRV9OQU1FKTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5fbG9hZGVkKCk7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VzW1BSSU1BUllfSU5TVEFOQ0VfTkFNRV0gPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWl4cGFuZWxfbWFzdGVyID0gaW5zdGFuY2U7XG4gICAgICAgICAgICBpZiAoaW5pdF90eXBlID09PSBJTklUX1NOSVBQRVQpIHtcbiAgICAgICAgICAgICAgICB3aW5bUFJJTUFSWV9JTlNUQU5DRV9OQU1FXSA9IG1peHBhbmVsX21hc3RlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4dGVuZF9tcCgpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbnZhciBhZGRfZG9tX2xvYWRlZF9oYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gQ3Jvc3MgYnJvd3NlciBET00gTG9hZGVkIHN1cHBvcnRcbiAgICBmdW5jdGlvbiBkb21fbG9hZGVkX2hhbmRsZXIoKSB7XG4gICAgICAgIC8vIGZ1bmN0aW9uIGZsYWcgc2luY2Ugd2Ugb25seSB3YW50IHRvIGV4ZWN1dGUgdGhpcyBvbmNlXG4gICAgICAgIGlmIChkb21fbG9hZGVkX2hhbmRsZXIuZG9uZSkgeyByZXR1cm47IH1cbiAgICAgICAgZG9tX2xvYWRlZF9oYW5kbGVyLmRvbmUgPSB0cnVlO1xuXG4gICAgICAgIERPTV9MT0FERUQgPSB0cnVlO1xuICAgICAgICBFTlFVRVVFX1JFUVVFU1RTID0gZmFsc2U7XG5cbiAgICAgICAgXy5lYWNoKGluc3RhbmNlcywgZnVuY3Rpb24oaW5zdCkge1xuICAgICAgICAgICAgaW5zdC5fZG9tX2xvYWRlZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkb19zY3JvbGxfY2hlY2soKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkb2N1bWVudCQxLmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCgnbGVmdCcpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZG9fc2Nyb2xsX2NoZWNrLCAxKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvbV9sb2FkZWRfaGFuZGxlcigpO1xuICAgIH1cblxuICAgIGlmIChkb2N1bWVudCQxLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50JDEucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgICAgLy8gc2FmYXJpIDQgY2FuIGZpcmUgdGhlIERPTUNvbnRlbnRMb2FkZWQgZXZlbnQgYmVmb3JlIGxvYWRpbmcgYWxsXG4gICAgICAgICAgICAvLyBleHRlcm5hbCBKUyAoaW5jbHVkaW5nIHRoaXMgZmlsZSkuIHlvdSB3aWxsIHNlZSBzb21lIGNvcHlwYXN0YVxuICAgICAgICAgICAgLy8gb24gdGhlIGludGVybmV0IHRoYXQgY2hlY2tzIGZvciAnY29tcGxldGUnIGFuZCAnbG9hZGVkJywgYnV0XG4gICAgICAgICAgICAvLyAnbG9hZGVkJyBpcyBhbiBJRSB0aGluZ1xuICAgICAgICAgICAgZG9tX2xvYWRlZF9oYW5kbGVyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb2N1bWVudCQxLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBkb21fbG9hZGVkX2hhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQkMS5hdHRhY2hFdmVudCkge1xuICAgICAgICAvLyBJRVxuICAgICAgICBkb2N1bWVudCQxLmF0dGFjaEV2ZW50KCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBkb21fbG9hZGVkX2hhbmRsZXIpO1xuXG4gICAgICAgIC8vIGNoZWNrIHRvIG1ha2Ugc3VyZSB3ZSBhcm4ndCBpbiBhIGZyYW1lXG4gICAgICAgIHZhciB0b3BsZXZlbCA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdG9wbGV2ZWwgPSB3aW4uZnJhbWVFbGVtZW50ID09PSBudWxsO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb2N1bWVudCQxLmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCAmJiB0b3BsZXZlbCkge1xuICAgICAgICAgICAgZG9fc2Nyb2xsX2NoZWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmYWxsYmFjayBoYW5kbGVyLCBhbHdheXMgd2lsbCB3b3JrXG4gICAgXy5yZWdpc3Rlcl9ldmVudCh3aW4sICdsb2FkJywgZG9tX2xvYWRlZF9oYW5kbGVyLCB0cnVlKTtcbn07XG5cbmZ1bmN0aW9uIGluaXRfYXNfbW9kdWxlKGJ1bmRsZV9sb2FkZXIpIHtcbiAgICBsb2FkX2V4dHJhX2J1bmRsZSA9IGJ1bmRsZV9sb2FkZXI7XG4gICAgaW5pdF90eXBlID0gSU5JVF9NT0RVTEU7XG4gICAgbWl4cGFuZWxfbWFzdGVyID0gbmV3IE1peHBhbmVsTGliKCk7XG5cbiAgICBvdmVycmlkZV9tcF9pbml0X2Z1bmMoKTtcbiAgICBtaXhwYW5lbF9tYXN0ZXJbJ2luaXQnXSgpO1xuICAgIGFkZF9kb21fbG9hZGVkX2hhbmRsZXIoKTtcblxuICAgIHJldHVybiBtaXhwYW5lbF9tYXN0ZXI7XG59XG5cbi8vIEZvciBsb2FkaW5nIHNlcGFyYXRlIGJ1bmRsZXMgYXN5bmNocm9ub3VzbHkgdmlhIHNjcmlwdCB0YWdcbi8vIHNvIHRoYXQgd2UgZG9uJ3QgbG9hZCB0aGVtIHVudGlsIHRoZXkgYXJlIG5lZWRlZCBhdCBydW50aW1lLlxuXG4vLyBGb3IgYnVpbGRzIHRoYXQgaGF2ZSBldmVyeXRoaW5nIGluIG9uZSBidW5kbGUsIG5vIGV4dHJhIHdvcmsuXG5mdW5jdGlvbiBsb2FkTm9vcCAoX3NyYywgb25sb2FkKSB7XG4gICAgb25sb2FkKCk7XG59XG5cbi8qIGVzbGludCBjYW1lbGNhc2U6IFwib2ZmXCIgKi9cblxudmFyIG1peHBhbmVsID0gaW5pdF9hc19tb2R1bGUobG9hZE5vb3ApO1xuXG5leHBvcnQgeyBtaXhwYW5lbCBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/mixpanel-browser/dist/mixpanel.module.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/base64-js/index.js":
/*!***************************************************!*\
  !*** ../../../../node_modules/base64-js/index.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcz9hZTJjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/base64-js/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/buffer/index.js":
/*!************************************************!*\
  !*** ../../../../node_modules/buffer/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"(app-pages-browser)/../../../../node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"(app-pages-browser)/../../../../node_modules/ieee754/index.js\")\nvar customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    var proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    var copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        Buffer.from(buf).copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (var i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nvar hexSliceLookupTable = (function () {\n  var alphabet = '0123456789abcdef'\n  var table = new Array(256)\n  for (var i = 0; i < 16; ++i) {\n    var i16 = i * 16\n    for (var j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVZOztBQUVaLGFBQWEsbUJBQU8sQ0FBQyxrRkFBVztBQUNoQyxjQUFjLG1CQUFPLENBQUMsOEVBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkLGtCQUFrQjtBQUNsQix5QkFBeUI7O0FBRXpCO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzPzJhNzkiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGN1c3RvbUluc3BlY3RTeW1ib2wgPVxuICAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sWydmb3InXSA9PT0gJ2Z1bmN0aW9uJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICA/IFN5bWJvbFsnZm9yJ10oJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICA6IG51bGxcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG52YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgdmFyIHByb3RvID0geyBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihwcm90bywgVWludDhBcnJheS5wcm90b3R5cGUpXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFyciwgcHJvdG8pXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlWaWV3KHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICAgIClcbiAgfVxuXG4gIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAoaXNJbnN0YW5jZSh2YWx1ZSwgU2hhcmVkQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIFNoYXJlZEFycmF5QnVmZmVyKSkpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB2YXIgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oXG4gICAgICB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoXG4gICAgKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIucHJvdG90eXBlLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIsIFVpbnQ4QXJyYXkpXG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheVZpZXcgKGFycmF5Vmlldykge1xuICBpZiAoaXNJbnN0YW5jZShhcnJheVZpZXcsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdmFyIGNvcHkgPSBuZXcgVWludDhBcnJheShhcnJheVZpZXcpXG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcihjb3B5LmJ1ZmZlciwgY29weS5ieXRlT2Zmc2V0LCBjb3B5LmJ5dGVMZW5ndGgpXG4gIH1cbiAgcmV0dXJuIGZyb21BcnJheUxpa2UoYXJyYXlWaWV3KVxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgdmFyIGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGlmIChwb3MgKyBidWYubGVuZ3RoID4gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICBCdWZmZXIuZnJvbShidWYpLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgYnVmLFxuICAgICAgICAgIHBvc1xuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIH1cbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZ1xuICAgIClcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBtdXN0TWF0Y2ggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlKVxuICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHtcbiAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcmNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpXG4gIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cbmlmIChjdXN0b21JbnNwZWN0U3ltYm9sKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGVbY3VzdG9tSW5zcGVjdFN5bWJvbF0gPSBCdWZmZXIucHJvdG90eXBlLmluc3BlY3Rcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xuICAgIHRhcmdldCA9IEJ1ZmZlci5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB0YXJnZXQpXG4gICAgKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbdmFsXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKVxuICAgICAgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKVxuICAgICAgICAgID8gM1xuICAgICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpXG4gICAgICAgICAgICAgID8gMlxuICAgICAgICAgICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gaGV4U2xpY2VMb29rdXBUYWJsZVtidWZbaV1dXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIC8vIElmIGJ5dGVzLmxlbmd0aCBpcyBvZGQsIHRoZSBsYXN0IDggYml0cyBtdXN0IGJlIGlnbm9yZWQgKHNhbWUgYXMgbm9kZS5qcylcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihuZXdCdWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludExFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDggPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTZCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludExFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDggPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTZMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdmFsID0gTnVtYmVyKHZhbClcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuLy8gQ3JlYXRlIGxvb2t1cCB0YWJsZSBmb3IgYHRvU3RyaW5nKCdoZXgnKWBcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzIxOVxudmFyIGhleFNsaWNlTG9va3VwVGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgYWxwaGFiZXQgPSAnMDEyMzQ1Njc4OWFiY2RlZidcbiAgdmFyIHRhYmxlID0gbmV3IEFycmF5KDI1NilcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgdmFyIGkxNiA9IGkgKiAxNlxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgMTY7ICsraikge1xuICAgICAgdGFibGVbaTE2ICsgal0gPSBhbHBoYWJldFtpXSArIGFscGhhYmV0W2pdXG4gICAgfVxuICB9XG4gIHJldHVybiB0YWJsZVxufSkoKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/ieee754/index.js":
/*!*************************************************!*\
  !*** ../../../../node_modules/ieee754/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsV0FBVzs7QUFFcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUyxXQUFXOztBQUVwQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFdBQVc7O0FBRXBCO0FBQ0E7QUFDQSxTQUFTLFVBQVU7O0FBRW5CO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzP2JjY2MiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/ieee754/index.js\n"));

/***/ })

}]);