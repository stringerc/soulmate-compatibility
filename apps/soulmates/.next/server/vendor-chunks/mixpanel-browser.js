"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mixpanel-browser";
exports.ids = ["vendor-chunks/mixpanel-browser"];
exports.modules = {

/***/ "(ssr)/../../node_modules/mixpanel-browser/dist/mixpanel.module.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/mixpanel-browser/dist/mixpanel.module.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ mixpanel)\n/* harmony export */ });\n// since es6 imports are static and we run unit tests from the console, window won't be defined when importing this file\nvar win;\nif (typeof(window) === 'undefined') {\n    var loc = {\n        hostname: ''\n    };\n    win = {\n        crypto: {randomUUID: function() {throw Error('unsupported');}},\n        navigator: { userAgent: '', onLine: true },\n        document: {\n            createElement: function() { return {}; },\n            location: loc,\n            referrer: ''\n        },\n        screen: { width: 0, height: 0 },\n        location: loc,\n        addEventListener: function() {},\n        removeEventListener: function() {}\n    };\n} else {\n    win = window;\n}\n\nfunction _array_like_to_array(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _async_to_generator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _construct(Parent, args, Class) {\n    if (_is_native_reflect_construct()) {\n        _construct = Reflect.construct;\n    } else {\n        _construct = function construct(Parent, args, Class) {\n            var a = [\n                null\n            ];\n            a.push.apply(a, args);\n            var Constructor = Function.bind.apply(Parent, a);\n            var instance = new Constructor();\n            if (Class) _set_prototype_of(instance, Class.prototype);\n            return instance;\n        };\n    }\n    return _construct.apply(null, arguments);\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _create_class(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    return Constructor;\n}\nfunction _extends() {\n    _extends = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _get_prototype_of(o) {\n    _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _get_prototype_of(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass) _set_prototype_of(subClass, superClass);\n}\nfunction _instanceof(left, right) {\n    if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n        return !!right[Symbol.hasInstance](left);\n    } else {\n        return left instanceof right;\n    }\n}\nfunction _is_native_function(fn) {\n    return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\nfunction _object_without_properties_loose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction _set_prototype_of(o, p) {\n    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _set_prototype_of(o, p);\n}\nfunction _type_of(obj) {\n    \"@swc/helpers - typeof\";\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n}\nfunction _unsupported_iterable_to_array(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);\n}\nfunction _wrap_native_super(Class) {\n    var _cache = typeof Map === \"function\" ? new Map() : undefined;\n    _wrap_native_super = function wrapNativeSuper(Class) {\n        if (Class === null || !_is_native_function(Class)) return Class;\n        if (typeof Class !== \"function\") {\n            throw new TypeError(\"Super expression must either be null or a function\");\n        }\n        if (typeof _cache !== \"undefined\") {\n            if (_cache.has(Class)) return _cache.get(Class);\n            _cache.set(Class, Wrapper);\n        }\n        function Wrapper() {\n            return _construct(Class, arguments, _get_prototype_of(this).constructor);\n        }\n        Wrapper.prototype = Object.create(Class.prototype, {\n            constructor: {\n                value: Wrapper,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n        return _set_prototype_of(Wrapper, Class);\n    };\n    return _wrap_native_super(Class);\n}\nfunction _is_native_reflect_construct() {\n    try {\n        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (_) {}\n    return (_is_native_reflect_construct = function() {\n        return !!result;\n    })();\n}\nfunction _create_for_of_iterator_helper_loose(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = _unsupported_iterable_to_array(o)) || allowArrayLike) {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) {\n                return {\n                    done: true\n                };\n            }\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _ts_generator(thisArg, body) {\n    var f, y, t, g, _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    };\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\nfunction _ts_values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = function(obj, key, value) {\n    return key in obj ? __defProp$1(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: value\n    }) : obj[key] = value;\n};\nvar __publicField$1 = function(obj, key, value) {\n    return __defNormalProp$1(obj, (typeof key === \"undefined\" ? \"undefined\" : _type_of(key)) !== \"symbol\" ? key + \"\" : key, value);\n};\nvar _a;\nvar __defProp$1$1 = Object.defineProperty;\nvar __defNormalProp$1$1 = function(obj, key, value) {\n    return key in obj ? __defProp$1$1(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: value\n    }) : obj[key] = value;\n};\nvar __publicField$1$1 = function(obj, key, value) {\n    return __defNormalProp$1$1(obj, (typeof key === \"undefined\" ? \"undefined\" : _type_of(key)) !== \"symbol\" ? key + \"\" : key, value);\n};\nvar NodeType$3 = /* @__PURE__ */ function(NodeType2) {\n    NodeType2[NodeType2[\"Document\"] = 0] = \"Document\";\n    NodeType2[NodeType2[\"DocumentType\"] = 1] = \"DocumentType\";\n    NodeType2[NodeType2[\"Element\"] = 2] = \"Element\";\n    NodeType2[NodeType2[\"Text\"] = 3] = \"Text\";\n    NodeType2[NodeType2[\"CDATA\"] = 4] = \"CDATA\";\n    NodeType2[NodeType2[\"Comment\"] = 5] = \"Comment\";\n    return NodeType2;\n}(NodeType$3 || {});\nvar testableAccessors$1 = {\n    Node: [\n        \"childNodes\",\n        \"parentNode\",\n        \"parentElement\",\n        \"textContent\"\n    ],\n    ShadowRoot: [\n        \"host\",\n        \"styleSheets\"\n    ],\n    Element: [\n        \"shadowRoot\",\n        \"querySelector\",\n        \"querySelectorAll\"\n    ],\n    MutationObserver: []\n};\nvar testableMethods$1 = {\n    Node: [\n        \"contains\",\n        \"getRootNode\"\n    ],\n    ShadowRoot: [\n        \"getSelection\"\n    ],\n    Element: [],\n    MutationObserver: [\n        \"constructor\"\n    ]\n};\nvar untaintedBasePrototype$1 = {};\nvar isAngularZonePresent$1 = function() {\n    return !!globalThis.Zone;\n};\nfunction getUntaintedPrototype$1(key) {\n    if (untaintedBasePrototype$1[key]) return untaintedBasePrototype$1[key];\n    var defaultObj = globalThis[key];\n    var defaultPrototype = defaultObj.prototype;\n    var accessorNames = key in testableAccessors$1 ? testableAccessors$1[key] : void 0;\n    var isUntaintedAccessors = Boolean(accessorNames && // @ts-expect-error 2345\n    accessorNames.every(function(accessor) {\n        var _a2, _b;\n        return Boolean((_b = (_a2 = Object.getOwnPropertyDescriptor(defaultPrototype, accessor)) == null ? void 0 : _a2.get) == null ? void 0 : _b.toString().includes(\"[native code]\"));\n    }));\n    var methodNames = key in testableMethods$1 ? testableMethods$1[key] : void 0;\n    var isUntaintedMethods = Boolean(methodNames && methodNames.every(// @ts-expect-error 2345\n    function(method) {\n        var _a2;\n        return typeof defaultPrototype[method] === \"function\" && ((_a2 = defaultPrototype[method]) == null ? void 0 : _a2.toString().includes(\"[native code]\"));\n    }));\n    if (isUntaintedAccessors && isUntaintedMethods && !isAngularZonePresent$1()) {\n        untaintedBasePrototype$1[key] = defaultObj.prototype;\n        return defaultObj.prototype;\n    }\n    try {\n        var iframeEl = document.createElement(\"iframe\");\n        document.body.appendChild(iframeEl);\n        var win = iframeEl.contentWindow;\n        if (!win) return defaultObj.prototype;\n        var untaintedObject = win[key].prototype;\n        document.body.removeChild(iframeEl);\n        if (!untaintedObject) return defaultPrototype;\n        return untaintedBasePrototype$1[key] = untaintedObject;\n    } catch (e) {\n        return defaultPrototype;\n    }\n}\nvar untaintedAccessorCache$1 = {};\nfunction getUntaintedAccessor$1(key, instance, accessor) {\n    var _a2;\n    var cacheKey = key + \".\" + String(accessor);\n    if (untaintedAccessorCache$1[cacheKey]) return untaintedAccessorCache$1[cacheKey].call(instance);\n    var untaintedPrototype = getUntaintedPrototype$1(key);\n    var untaintedAccessor = (_a2 = Object.getOwnPropertyDescriptor(untaintedPrototype, accessor)) == null ? void 0 : _a2.get;\n    if (!untaintedAccessor) return instance[accessor];\n    untaintedAccessorCache$1[cacheKey] = untaintedAccessor;\n    return untaintedAccessor.call(instance);\n}\nvar untaintedMethodCache$1 = {};\nfunction getUntaintedMethod$1(key, instance, method) {\n    var cacheKey = key + \".\" + String(method);\n    if (untaintedMethodCache$1[cacheKey]) return untaintedMethodCache$1[cacheKey].bind(instance);\n    var untaintedPrototype = getUntaintedPrototype$1(key);\n    var untaintedMethod = untaintedPrototype[method];\n    if (typeof untaintedMethod !== \"function\") return instance[method];\n    untaintedMethodCache$1[cacheKey] = untaintedMethod;\n    return untaintedMethod.bind(instance);\n}\nfunction childNodes$1(n2) {\n    return getUntaintedAccessor$1(\"Node\", n2, \"childNodes\");\n}\nfunction parentNode$1(n2) {\n    return getUntaintedAccessor$1(\"Node\", n2, \"parentNode\");\n}\nfunction parentElement$1(n2) {\n    return getUntaintedAccessor$1(\"Node\", n2, \"parentElement\");\n}\nfunction textContent$1(n2) {\n    return getUntaintedAccessor$1(\"Node\", n2, \"textContent\");\n}\nfunction contains$1(n2, other) {\n    return getUntaintedMethod$1(\"Node\", n2, \"contains\")(other);\n}\nfunction getRootNode$1(n2) {\n    return getUntaintedMethod$1(\"Node\", n2, \"getRootNode\")();\n}\nfunction host$1(n2) {\n    if (!n2 || !(\"host\" in n2)) return null;\n    return getUntaintedAccessor$1(\"ShadowRoot\", n2, \"host\");\n}\nfunction styleSheets$1(n2) {\n    return n2.styleSheets;\n}\nfunction shadowRoot$1(n2) {\n    if (!n2 || !(\"shadowRoot\" in n2)) return null;\n    return getUntaintedAccessor$1(\"Element\", n2, \"shadowRoot\");\n}\nfunction querySelector$1(n2, selectors) {\n    return getUntaintedAccessor$1(\"Element\", n2, \"querySelector\")(selectors);\n}\nfunction querySelectorAll$1(n2, selectors) {\n    return getUntaintedAccessor$1(\"Element\", n2, \"querySelectorAll\")(selectors);\n}\nfunction mutationObserverCtor$1() {\n    return getUntaintedPrototype$1(\"MutationObserver\").constructor;\n}\nfunction patch$1(source, name, replacement) {\n    try {\n        if (!(name in source)) {\n            return function() {};\n        }\n        var original = source[name];\n        var wrapped = replacement(original);\n        if (typeof wrapped === \"function\") {\n            wrapped.prototype = wrapped.prototype || {};\n            Object.defineProperties(wrapped, {\n                __rrweb_original__: {\n                    enumerable: false,\n                    value: original\n                }\n            });\n        }\n        source[name] = wrapped;\n        return function() {\n            source[name] = original;\n        };\n    } catch (e) {\n        return function() {};\n    }\n}\nvar index$1 = {\n    childNodes: childNodes$1,\n    parentNode: parentNode$1,\n    parentElement: parentElement$1,\n    textContent: textContent$1,\n    contains: contains$1,\n    getRootNode: getRootNode$1,\n    host: host$1,\n    styleSheets: styleSheets$1,\n    shadowRoot: shadowRoot$1,\n    querySelector: querySelector$1,\n    querySelectorAll: querySelectorAll$1,\n    mutationObserver: mutationObserverCtor$1,\n    patch: patch$1\n};\nfunction isElement(n2) {\n    return n2.nodeType === n2.ELEMENT_NODE;\n}\nfunction isShadowRoot(n2) {\n    var hostEl = // anchor and textarea elements also have a `host` property\n    // but only shadow roots have a `mode` property\n    n2 && \"host\" in n2 && \"mode\" in n2 && index$1.host(n2) || null;\n    return Boolean(hostEl && \"shadowRoot\" in hostEl && index$1.shadowRoot(hostEl) === n2);\n}\nfunction isNativeShadowDom(shadowRoot2) {\n    return Object.prototype.toString.call(shadowRoot2) === \"[object ShadowRoot]\";\n}\nfunction fixBrowserCompatibilityIssuesInCSS(cssText) {\n    if (cssText.includes(\" background-clip: text;\") && !cssText.includes(\" -webkit-background-clip: text;\")) {\n        cssText = cssText.replace(/\\sbackground-clip:\\s*text;/g, \" -webkit-background-clip: text; background-clip: text;\");\n    }\n    return cssText;\n}\nfunction escapeImportStatement(rule2) {\n    var cssText = rule2.cssText;\n    if (cssText.split('\"').length < 3) return cssText;\n    var statement = [\n        \"@import\",\n        \"url(\" + JSON.stringify(rule2.href) + \")\"\n    ];\n    if (rule2.layerName === \"\") {\n        statement.push(\"layer\");\n    } else if (rule2.layerName) {\n        statement.push(\"layer(\" + rule2.layerName + \")\");\n    }\n    if (rule2.supportsText) {\n        statement.push(\"supports(\" + rule2.supportsText + \")\");\n    }\n    if (rule2.media.length) {\n        statement.push(rule2.media.mediaText);\n    }\n    return statement.join(\" \") + \";\";\n}\nfunction stringifyStylesheet(s2) {\n    try {\n        var rules2 = s2.rules || s2.cssRules;\n        if (!rules2) {\n            return null;\n        }\n        var sheetHref = s2.href;\n        if (!sheetHref && s2.ownerNode && s2.ownerNode.ownerDocument) {\n            sheetHref = s2.ownerNode.ownerDocument.location.href;\n        }\n        var stringifiedRules = Array.from(rules2, function(rule2) {\n            return stringifyRule(rule2, sheetHref);\n        }).join(\"\");\n        return fixBrowserCompatibilityIssuesInCSS(stringifiedRules);\n    } catch (error) {\n        return null;\n    }\n}\nfunction stringifyRule(rule2, sheetHref) {\n    if (isCSSImportRule(rule2)) {\n        var importStringified;\n        try {\n            importStringified = // we can access the imported stylesheet rules directly\n            stringifyStylesheet(rule2.styleSheet) || // work around browser issues with the raw string `@import url(...)` statement\n            escapeImportStatement(rule2);\n        } catch (error) {\n            importStringified = rule2.cssText;\n        }\n        if (rule2.styleSheet.href) {\n            return absolutifyURLs(importStringified, rule2.styleSheet.href);\n        }\n        return importStringified;\n    } else {\n        var ruleStringified = rule2.cssText;\n        if (isCSSStyleRule(rule2) && rule2.selectorText.includes(\":\")) {\n            ruleStringified = fixSafariColons(ruleStringified);\n        }\n        if (sheetHref) {\n            return absolutifyURLs(ruleStringified, sheetHref);\n        }\n        return ruleStringified;\n    }\n}\nfunction fixSafariColons(cssStringified) {\n    var regex = /(\\[(?:[\\w-]+)[^\\\\])(:(?:[\\w-]+)\\])/gm;\n    return cssStringified.replace(regex, \"$1\\\\$2\");\n}\nfunction isCSSImportRule(rule2) {\n    return \"styleSheet\" in rule2;\n}\nfunction isCSSStyleRule(rule2) {\n    return \"selectorText\" in rule2;\n}\nvar Mirror = /*#__PURE__*/ function() {\n    function Mirror() {\n        __publicField$1$1(this, \"idNodeMap\", /* @__PURE__ */ new Map());\n        __publicField$1$1(this, \"nodeMetaMap\", /* @__PURE__ */ new WeakMap());\n    }\n    var _proto = Mirror.prototype;\n    _proto.getId = function getId(n2) {\n        var _a2;\n        if (!n2) return -1;\n        var id = (_a2 = this.getMeta(n2)) == null ? void 0 : _a2.id;\n        return id != null ? id : -1;\n    };\n    _proto.getNode = function getNode(id) {\n        return this.idNodeMap.get(id) || null;\n    };\n    _proto.getIds = function getIds() {\n        return Array.from(this.idNodeMap.keys());\n    };\n    _proto.getMeta = function getMeta(n2) {\n        return this.nodeMetaMap.get(n2) || null;\n    };\n    // removes the node from idNodeMap\n    // doesn't remove the node from nodeMetaMap\n    _proto.removeNodeFromMap = function removeNodeFromMap(n2) {\n        var _this = this;\n        var id = this.getId(n2);\n        this.idNodeMap.delete(id);\n        if (n2.childNodes) {\n            n2.childNodes.forEach(function(childNode) {\n                return _this.removeNodeFromMap(childNode);\n            });\n        }\n    };\n    _proto.has = function has(id) {\n        return this.idNodeMap.has(id);\n    };\n    _proto.hasNode = function hasNode(node2) {\n        return this.nodeMetaMap.has(node2);\n    };\n    _proto.add = function add(n2, meta) {\n        var id = meta.id;\n        this.idNodeMap.set(id, n2);\n        this.nodeMetaMap.set(n2, meta);\n    };\n    _proto.replace = function replace(id, n2) {\n        var oldNode = this.getNode(id);\n        if (oldNode) {\n            var meta = this.nodeMetaMap.get(oldNode);\n            if (meta) this.nodeMetaMap.set(n2, meta);\n        }\n        this.idNodeMap.set(id, n2);\n    };\n    _proto.reset = function reset() {\n        this.idNodeMap = /* @__PURE__ */ new Map();\n        this.nodeMetaMap = /* @__PURE__ */ new WeakMap();\n    };\n    return Mirror;\n}();\nfunction createMirror$2() {\n    return new Mirror();\n}\nfunction maskInputValue(param) {\n    var element = param.element, maskInputOptions = param.maskInputOptions, tagName = param.tagName, type = param.type, value = param.value, maskInputFn = param.maskInputFn;\n    var text = value || \"\";\n    var actualType = type && toLowerCase(type);\n    if (maskInputOptions[tagName.toLowerCase()] || actualType && maskInputOptions[actualType]) {\n        if (maskInputFn) {\n            text = maskInputFn(text, element);\n        } else {\n            text = \"*\".repeat(text.length);\n        }\n    }\n    return text;\n}\nfunction toLowerCase(str) {\n    return str.toLowerCase();\n}\nvar ORIGINAL_ATTRIBUTE_NAME = \"__rrweb_original__\";\nfunction is2DCanvasBlank(canvas) {\n    var ctx = canvas.getContext(\"2d\");\n    if (!ctx) return true;\n    var chunkSize = 50;\n    for(var x2 = 0; x2 < canvas.width; x2 += chunkSize){\n        for(var y = 0; y < canvas.height; y += chunkSize){\n            var getImageData = ctx.getImageData;\n            var originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData ? getImageData[ORIGINAL_ATTRIBUTE_NAME] : getImageData;\n            var pixelBuffer = new Uint32Array(// eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access\n            originalGetImageData.call(ctx, x2, y, Math.min(chunkSize, canvas.width - x2), Math.min(chunkSize, canvas.height - y)).data.buffer);\n            if (pixelBuffer.some(function(pixel) {\n                return pixel !== 0;\n            })) return false;\n        }\n    }\n    return true;\n}\nfunction getInputType(element) {\n    var type = element.type;\n    return element.hasAttribute(\"data-rr-is-password\") ? \"password\" : type ? // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    toLowerCase(type) : null;\n}\nfunction extractFileExtension(path, baseURL) {\n    var url;\n    try {\n        url = new URL(path, baseURL != null ? baseURL : window.location.href);\n    } catch (err) {\n        return null;\n    }\n    var regex = /\\.([0-9a-z]+)(?:$)/i;\n    var match = url.pathname.match(regex);\n    var _ref;\n    return (_ref = match == null ? void 0 : match[1]) != null ? _ref : null;\n}\nfunction extractOrigin(url) {\n    var origin = \"\";\n    if (url.indexOf(\"//\") > -1) {\n        origin = url.split(\"/\").slice(0, 3).join(\"/\");\n    } else {\n        origin = url.split(\"/\")[0];\n    }\n    origin = origin.split(\"?\")[0];\n    return origin;\n}\nvar URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\nvar URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\\/\\//i;\nvar URL_WWW_MATCH = /^www\\..*/i;\nvar DATA_URI = /^(data:)([^,]*),(.*)/i;\nfunction absolutifyURLs(cssText, href) {\n    return (cssText || \"\").replace(URL_IN_CSS_REF, function(origin, quote1, path1, quote2, path2, path3) {\n        var filePath = path1 || path2 || path3;\n        var maybeQuote = quote1 || quote2 || \"\";\n        if (!filePath) {\n            return origin;\n        }\n        if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {\n            return \"url(\" + maybeQuote + filePath + maybeQuote + \")\";\n        }\n        if (DATA_URI.test(filePath)) {\n            return \"url(\" + maybeQuote + filePath + maybeQuote + \")\";\n        }\n        if (filePath[0] === \"/\") {\n            return \"url(\" + maybeQuote + (extractOrigin(href) + filePath) + maybeQuote + \")\";\n        }\n        var stack = href.split(\"/\");\n        var parts = filePath.split(\"/\");\n        stack.pop();\n        for(var _iterator = _create_for_of_iterator_helper_loose(parts), _step; !(_step = _iterator()).done;){\n            var part = _step.value;\n            if (part === \".\") {\n                continue;\n            } else if (part === \"..\") {\n                stack.pop();\n            } else {\n                stack.push(part);\n            }\n        }\n        return \"url(\" + maybeQuote + stack.join(\"/\") + maybeQuote + \")\";\n    });\n}\nfunction normalizeCssString(cssText, _testNoPxNorm) {\n    if (_testNoPxNorm === void 0) _testNoPxNorm = false;\n    if (_testNoPxNorm) {\n        return cssText.replace(/(\\/\\*[^*]*\\*\\/)|[\\s;]/g, \"\");\n    } else {\n        return cssText.replace(/(\\/\\*[^*]*\\*\\/)|[\\s;]/g, \"\").replace(/0px/g, \"0\");\n    }\n}\nfunction splitCssText(cssText, style, _testNoPxNorm) {\n    if (_testNoPxNorm === void 0) _testNoPxNorm = false;\n    var childNodes2 = Array.from(style.childNodes);\n    var splits = [];\n    var iterCount = 0;\n    if (childNodes2.length > 1 && cssText && typeof cssText === \"string\") {\n        var cssTextNorm = normalizeCssString(cssText, _testNoPxNorm);\n        var normFactor = cssTextNorm.length / cssText.length;\n        for(var i2 = 1; i2 < childNodes2.length; i2++){\n            if (childNodes2[i2].textContent && typeof childNodes2[i2].textContent === \"string\") {\n                var textContentNorm = normalizeCssString(childNodes2[i2].textContent, _testNoPxNorm);\n                var jLimit = 100;\n                var j = 3;\n                for(; j < textContentNorm.length; j++){\n                    if (// keep consuming css identifiers (to get a decent chunk more quickly)\n                    textContentNorm[j].match(/[a-zA-Z0-9]/) || // substring needs to be unique to this section\n                    textContentNorm.indexOf(textContentNorm.substring(0, j), 1) !== -1) {\n                        continue;\n                    }\n                    break;\n                }\n                for(; j < textContentNorm.length; j++){\n                    var startSubstring = textContentNorm.substring(0, j);\n                    var cssNormSplits = cssTextNorm.split(startSubstring);\n                    var splitNorm = -1;\n                    if (cssNormSplits.length === 2) {\n                        splitNorm = cssNormSplits[0].length;\n                    } else if (cssNormSplits.length > 2 && cssNormSplits[0] === \"\" && childNodes2[i2 - 1].textContent !== \"\") {\n                        splitNorm = cssTextNorm.indexOf(startSubstring, 1);\n                    } else if (cssNormSplits.length === 1) {\n                        startSubstring = startSubstring.substring(0, startSubstring.length - 1);\n                        cssNormSplits = cssTextNorm.split(startSubstring);\n                        if (cssNormSplits.length <= 1) {\n                            splits.push(cssText);\n                            return splits;\n                        }\n                        j = jLimit + 1;\n                    } else if (j === textContentNorm.length - 1) {\n                        splitNorm = cssTextNorm.indexOf(startSubstring);\n                    }\n                    if (cssNormSplits.length >= 2 && j > jLimit) {\n                        var prevTextContent = childNodes2[i2 - 1].textContent;\n                        if (prevTextContent && typeof prevTextContent === \"string\") {\n                            var prevMinLength = normalizeCssString(prevTextContent).length;\n                            splitNorm = cssTextNorm.indexOf(startSubstring, prevMinLength);\n                        }\n                        if (splitNorm === -1) {\n                            splitNorm = cssNormSplits[0].length;\n                        }\n                    }\n                    if (splitNorm !== -1) {\n                        var k = Math.floor(splitNorm / normFactor);\n                        for(; k > 0 && k < cssText.length;){\n                            iterCount += 1;\n                            if (iterCount > 50 * childNodes2.length) {\n                                splits.push(cssText);\n                                return splits;\n                            }\n                            var normPart = normalizeCssString(cssText.substring(0, k), _testNoPxNorm);\n                            if (normPart.length === splitNorm) {\n                                splits.push(cssText.substring(0, k));\n                                cssText = cssText.substring(k);\n                                cssTextNorm = cssTextNorm.substring(splitNorm);\n                                break;\n                            } else if (normPart.length < splitNorm) {\n                                k += Math.max(1, Math.floor((splitNorm - normPart.length) / normFactor));\n                            } else {\n                                k -= Math.max(1, Math.floor((normPart.length - splitNorm) * normFactor));\n                            }\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    splits.push(cssText);\n    return splits;\n}\nfunction markCssSplits(cssText, style) {\n    return splitCssText(cssText, style).join(\"/* rr_split */\");\n}\nvar _id = 1;\nvar tagNameRegex = new RegExp(\"[^a-z0-9-_:]\");\nvar IGNORED_NODE = -2;\nfunction genId() {\n    return _id++;\n}\nfunction getValidTagName$1(element) {\n    if (_instanceof(element, HTMLFormElement)) {\n        return \"form\";\n    }\n    var processedTagName = toLowerCase(element.tagName);\n    if (tagNameRegex.test(processedTagName)) {\n        return \"div\";\n    }\n    return processedTagName;\n}\nvar canvasService;\nvar canvasCtx;\nvar SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/;\nvar SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\nfunction getAbsoluteSrcsetString(doc, attributeValue) {\n    if (attributeValue.trim() === \"\") {\n        return attributeValue;\n    }\n    var pos = 0;\n    function collectCharacters(regEx) {\n        var chars2;\n        var match = regEx.exec(attributeValue.substring(pos));\n        if (match) {\n            chars2 = match[0];\n            pos += chars2.length;\n            return chars2;\n        }\n        return \"\";\n    }\n    var output = [];\n    while(true){\n        collectCharacters(SRCSET_COMMAS_OR_SPACES);\n        if (pos >= attributeValue.length) {\n            break;\n        }\n        var url = collectCharacters(SRCSET_NOT_SPACES);\n        if (url.slice(-1) === \",\") {\n            url = absoluteToDoc(doc, url.substring(0, url.length - 1));\n            output.push(url);\n        } else {\n            var descriptorsStr = \"\";\n            url = absoluteToDoc(doc, url);\n            var inParens = false;\n            while(true){\n                var c2 = attributeValue.charAt(pos);\n                if (c2 === \"\") {\n                    output.push((url + descriptorsStr).trim());\n                    break;\n                } else if (!inParens) {\n                    if (c2 === \",\") {\n                        pos += 1;\n                        output.push((url + descriptorsStr).trim());\n                        break;\n                    } else if (c2 === \"(\") {\n                        inParens = true;\n                    }\n                } else {\n                    if (c2 === \")\") {\n                        inParens = false;\n                    }\n                }\n                descriptorsStr += c2;\n                pos += 1;\n            }\n        }\n    }\n    return output.join(\", \");\n}\nvar cachedDocument = /* @__PURE__ */ new WeakMap();\nfunction absoluteToDoc(doc, attributeValue) {\n    if (!attributeValue || attributeValue.trim() === \"\") {\n        return attributeValue;\n    }\n    return getHref(doc, attributeValue);\n}\nfunction isSVGElement(el) {\n    return Boolean(el.tagName === \"svg\" || el.ownerSVGElement);\n}\nfunction getHref(doc, customHref) {\n    var a2 = cachedDocument.get(doc);\n    if (!a2) {\n        a2 = doc.createElement(\"a\");\n        cachedDocument.set(doc, a2);\n    }\n    if (!customHref) {\n        customHref = \"\";\n    } else if (customHref.startsWith(\"blob:\") || customHref.startsWith(\"data:\")) {\n        return customHref;\n    }\n    a2.setAttribute(\"href\", customHref);\n    return a2.href;\n}\nfunction transformAttribute(doc, tagName, name, value) {\n    if (!value) {\n        return value;\n    }\n    if (name === \"src\" || name === \"href\" && !(tagName === \"use\" && value[0] === \"#\")) {\n        return absoluteToDoc(doc, value);\n    } else if (name === \"xlink:href\" && value[0] !== \"#\") {\n        return absoluteToDoc(doc, value);\n    } else if (name === \"background\" && (tagName === \"table\" || tagName === \"td\" || tagName === \"th\")) {\n        return absoluteToDoc(doc, value);\n    } else if (name === \"srcset\") {\n        return getAbsoluteSrcsetString(doc, value);\n    } else if (name === \"style\") {\n        return absolutifyURLs(value, getHref(doc));\n    } else if (tagName === \"object\" && name === \"data\") {\n        return absoluteToDoc(doc, value);\n    }\n    return value;\n}\nfunction ignoreAttribute(tagName, name, _value) {\n    return (tagName === \"video\" || tagName === \"audio\") && name === \"autoplay\";\n}\nfunction _isBlockedElement(element, blockClass, blockSelector) {\n    try {\n        if (typeof blockClass === \"string\") {\n            if (element.classList.contains(blockClass)) {\n                return true;\n            }\n        } else {\n            for(var eIndex = element.classList.length; eIndex--;){\n                var className = element.classList[eIndex];\n                if (blockClass.test(className)) {\n                    return true;\n                }\n            }\n        }\n        if (blockSelector) {\n            return element.matches(blockSelector);\n        }\n    } catch (e2) {}\n    return false;\n}\nfunction classMatchesRegex(node2, regex, checkAncestors) {\n    if (!node2) return false;\n    if (node2.nodeType !== node2.ELEMENT_NODE) {\n        if (!checkAncestors) return false;\n        return classMatchesRegex(index$1.parentNode(node2), regex, checkAncestors);\n    }\n    for(var eIndex = node2.classList.length; eIndex--;){\n        var className = node2.classList[eIndex];\n        if (regex.test(className)) {\n            return true;\n        }\n    }\n    if (!checkAncestors) return false;\n    return classMatchesRegex(index$1.parentNode(node2), regex, checkAncestors);\n}\nfunction needMaskingText(node2, maskTextClass, maskTextSelector, checkAncestors) {\n    var el;\n    if (isElement(node2)) {\n        el = node2;\n        if (!index$1.childNodes(el).length) {\n            return false;\n        }\n    } else if (index$1.parentElement(node2) === null) {\n        return false;\n    } else {\n        el = index$1.parentElement(node2);\n    }\n    try {\n        if (typeof maskTextClass === \"string\") {\n            if (checkAncestors) {\n                if (el.closest(\".\" + maskTextClass)) return true;\n            } else {\n                if (el.classList.contains(maskTextClass)) return true;\n            }\n        } else {\n            if (classMatchesRegex(el, maskTextClass, checkAncestors)) return true;\n        }\n        if (maskTextSelector) {\n            if (checkAncestors) {\n                if (el.closest(maskTextSelector)) return true;\n            } else {\n                if (el.matches(maskTextSelector)) return true;\n            }\n        }\n    } catch (e2) {}\n    return false;\n}\nfunction onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {\n    var win = iframeEl.contentWindow;\n    if (!win) {\n        return;\n    }\n    var fired = false;\n    var readyState;\n    try {\n        readyState = win.document.readyState;\n    } catch (error) {\n        return;\n    }\n    if (readyState !== \"complete\") {\n        var timer = setTimeout(function() {\n            if (!fired) {\n                listener();\n                fired = true;\n            }\n        }, iframeLoadTimeout);\n        iframeEl.addEventListener(\"load\", function() {\n            clearTimeout(timer);\n            fired = true;\n            listener();\n        });\n        return;\n    }\n    var blankUrl = \"about:blank\";\n    if (win.location.href !== blankUrl || iframeEl.src === blankUrl || iframeEl.src === \"\") {\n        setTimeout(listener, 0);\n        return iframeEl.addEventListener(\"load\", listener);\n    }\n    iframeEl.addEventListener(\"load\", listener);\n}\nfunction onceStylesheetLoaded(link, listener, styleSheetLoadTimeout) {\n    var fired = false;\n    var styleSheetLoaded;\n    try {\n        styleSheetLoaded = link.sheet;\n    } catch (error) {\n        return;\n    }\n    if (styleSheetLoaded) return;\n    var timer = setTimeout(function() {\n        if (!fired) {\n            listener();\n            fired = true;\n        }\n    }, styleSheetLoadTimeout);\n    link.addEventListener(\"load\", function() {\n        clearTimeout(timer);\n        fired = true;\n        listener();\n    });\n}\nfunction serializeNode(n2, options) {\n    var doc = options.doc, mirror2 = options.mirror, blockClass = options.blockClass, blockSelector = options.blockSelector, needsMask = options.needsMask, inlineStylesheet = options.inlineStylesheet, _options_maskInputOptions = options.maskInputOptions, maskInputOptions = _options_maskInputOptions === void 0 ? {} : _options_maskInputOptions, maskTextFn = options.maskTextFn, maskInputFn = options.maskInputFn, _options_dataURLOptions = options.dataURLOptions, dataURLOptions = _options_dataURLOptions === void 0 ? {} : _options_dataURLOptions, inlineImages = options.inlineImages, recordCanvas = options.recordCanvas, keepIframeSrcFn = options.keepIframeSrcFn, _options_newlyAddedElement = options.newlyAddedElement, newlyAddedElement = _options_newlyAddedElement === void 0 ? false : _options_newlyAddedElement, _options_cssCaptured = options.cssCaptured, cssCaptured = _options_cssCaptured === void 0 ? false : _options_cssCaptured;\n    var rootId = getRootId(doc, mirror2);\n    switch(n2.nodeType){\n        case n2.DOCUMENT_NODE:\n            if (n2.compatMode !== \"CSS1Compat\") {\n                return {\n                    type: NodeType$3.Document,\n                    childNodes: [],\n                    compatMode: n2.compatMode\n                };\n            } else {\n                return {\n                    type: NodeType$3.Document,\n                    childNodes: []\n                };\n            }\n        case n2.DOCUMENT_TYPE_NODE:\n            return {\n                type: NodeType$3.DocumentType,\n                name: n2.name,\n                publicId: n2.publicId,\n                systemId: n2.systemId,\n                rootId: rootId\n            };\n        case n2.ELEMENT_NODE:\n            return serializeElementNode(n2, {\n                doc: doc,\n                blockClass: blockClass,\n                blockSelector: blockSelector,\n                inlineStylesheet: inlineStylesheet,\n                maskInputOptions: maskInputOptions,\n                maskInputFn: maskInputFn,\n                dataURLOptions: dataURLOptions,\n                inlineImages: inlineImages,\n                recordCanvas: recordCanvas,\n                keepIframeSrcFn: keepIframeSrcFn,\n                newlyAddedElement: newlyAddedElement,\n                rootId: rootId\n            });\n        case n2.TEXT_NODE:\n            return serializeTextNode(n2, {\n                doc: doc,\n                needsMask: needsMask,\n                maskTextFn: maskTextFn,\n                rootId: rootId,\n                cssCaptured: cssCaptured\n            });\n        case n2.CDATA_SECTION_NODE:\n            return {\n                type: NodeType$3.CDATA,\n                textContent: \"\",\n                rootId: rootId\n            };\n        case n2.COMMENT_NODE:\n            return {\n                type: NodeType$3.Comment,\n                textContent: index$1.textContent(n2) || \"\",\n                rootId: rootId\n            };\n        default:\n            return false;\n    }\n}\nfunction getRootId(doc, mirror2) {\n    if (!mirror2.hasNode(doc)) return void 0;\n    var docId = mirror2.getId(doc);\n    return docId === 1 ? void 0 : docId;\n}\nfunction serializeTextNode(n2, options) {\n    var needsMask = options.needsMask, maskTextFn = options.maskTextFn, rootId = options.rootId, cssCaptured = options.cssCaptured;\n    var parent = index$1.parentNode(n2);\n    var parentTagName = parent && parent.tagName;\n    var textContent2 = \"\";\n    var isStyle = parentTagName === \"STYLE\" ? true : void 0;\n    var isScript = parentTagName === \"SCRIPT\" ? true : void 0;\n    if (isScript) {\n        textContent2 = \"SCRIPT_PLACEHOLDER\";\n    } else if (!cssCaptured) {\n        textContent2 = index$1.textContent(n2);\n        if (isStyle && textContent2) {\n            textContent2 = absolutifyURLs(textContent2, getHref(options.doc));\n        }\n    }\n    if (!isStyle && !isScript && textContent2 && needsMask) {\n        textContent2 = maskTextFn ? maskTextFn(textContent2, index$1.parentElement(n2)) : textContent2.replace(/[\\S]/g, \"*\");\n    }\n    return {\n        type: NodeType$3.Text,\n        textContent: textContent2 || \"\",\n        rootId: rootId\n    };\n}\nfunction serializeElementNode(n2, options) {\n    var doc = options.doc, blockClass = options.blockClass, blockSelector = options.blockSelector, inlineStylesheet = options.inlineStylesheet, _options_maskInputOptions = options.maskInputOptions, maskInputOptions = _options_maskInputOptions === void 0 ? {} : _options_maskInputOptions, maskInputFn = options.maskInputFn, _options_dataURLOptions = options.dataURLOptions, dataURLOptions = _options_dataURLOptions === void 0 ? {} : _options_dataURLOptions, inlineImages = options.inlineImages, recordCanvas = options.recordCanvas, keepIframeSrcFn = options.keepIframeSrcFn, _options_newlyAddedElement = options.newlyAddedElement, newlyAddedElement = _options_newlyAddedElement === void 0 ? false : _options_newlyAddedElement, rootId = options.rootId;\n    var needBlock = _isBlockedElement(n2, blockClass, blockSelector);\n    var tagName = getValidTagName$1(n2);\n    var attributes = {};\n    var len = n2.attributes.length;\n    for(var i2 = 0; i2 < len; i2++){\n        var attr = n2.attributes[i2];\n        if (!ignoreAttribute(tagName, attr.name, attr.value)) {\n            attributes[attr.name] = transformAttribute(doc, tagName, toLowerCase(attr.name), attr.value);\n        }\n    }\n    if (tagName === \"link\" && inlineStylesheet) {\n        var stylesheet = Array.from(doc.styleSheets).find(function(s2) {\n            return s2.href === n2.href;\n        });\n        var cssText = null;\n        if (stylesheet) {\n            cssText = stringifyStylesheet(stylesheet);\n        }\n        if (cssText) {\n            delete attributes.rel;\n            delete attributes.href;\n            attributes._cssText = cssText;\n        }\n    }\n    if (tagName === \"style\" && n2.sheet) {\n        var cssText1 = stringifyStylesheet(n2.sheet);\n        if (cssText1) {\n            if (n2.childNodes.length > 1) {\n                cssText1 = markCssSplits(cssText1, n2);\n            }\n            attributes._cssText = cssText1;\n        }\n    }\n    if (tagName === \"input\" || tagName === \"textarea\" || tagName === \"select\") {\n        var value = n2.value;\n        var checked = n2.checked;\n        if (attributes.type !== \"radio\" && attributes.type !== \"checkbox\" && attributes.type !== \"submit\" && attributes.type !== \"button\" && value) {\n            attributes.value = maskInputValue({\n                element: n2,\n                type: getInputType(n2),\n                tagName: tagName,\n                value: value,\n                maskInputOptions: maskInputOptions,\n                maskInputFn: maskInputFn\n            });\n        } else if (checked) {\n            attributes.checked = checked;\n        }\n    }\n    if (tagName === \"option\") {\n        if (n2.selected && !maskInputOptions[\"select\"]) {\n            attributes.selected = true;\n        } else {\n            delete attributes.selected;\n        }\n    }\n    if (tagName === \"dialog\" && n2.open) {\n        attributes.rr_open_mode = n2.matches(\"dialog:modal\") ? \"modal\" : \"non-modal\";\n    }\n    if (tagName === \"canvas\" && recordCanvas) {\n        if (n2.__context === \"2d\") {\n            if (!is2DCanvasBlank(n2)) {\n                attributes.rr_dataURL = n2.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n            }\n        } else if (!(\"__context\" in n2)) {\n            var canvasDataURL = n2.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n            var blankCanvas = doc.createElement(\"canvas\");\n            blankCanvas.width = n2.width;\n            blankCanvas.height = n2.height;\n            var blankCanvasDataURL = blankCanvas.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n            if (canvasDataURL !== blankCanvasDataURL) {\n                attributes.rr_dataURL = canvasDataURL;\n            }\n        }\n    }\n    if (tagName === \"img\" && inlineImages) {\n        if (!canvasService) {\n            canvasService = doc.createElement(\"canvas\");\n            canvasCtx = canvasService.getContext(\"2d\");\n        }\n        var image = n2;\n        var imageSrc = image.currentSrc || image.getAttribute(\"src\") || \"<unknown-src>\";\n        var priorCrossOrigin = image.crossOrigin;\n        var recordInlineImage = function() {\n            image.removeEventListener(\"load\", recordInlineImage);\n            try {\n                canvasService.width = image.naturalWidth;\n                canvasService.height = image.naturalHeight;\n                canvasCtx.drawImage(image, 0, 0);\n                attributes.rr_dataURL = canvasService.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n            } catch (err) {\n                if (image.crossOrigin !== \"anonymous\") {\n                    image.crossOrigin = \"anonymous\";\n                    if (image.complete && image.naturalWidth !== 0) recordInlineImage();\n                    else image.addEventListener(\"load\", recordInlineImage);\n                    return;\n                } else {\n                    console.warn(\"Cannot inline img src=\" + imageSrc + \"! Error: \" + err);\n                }\n            }\n            if (image.crossOrigin === \"anonymous\") {\n                priorCrossOrigin ? attributes.crossOrigin = priorCrossOrigin : image.removeAttribute(\"crossorigin\");\n            }\n        };\n        if (image.complete && image.naturalWidth !== 0) recordInlineImage();\n        else image.addEventListener(\"load\", recordInlineImage);\n    }\n    if (tagName === \"audio\" || tagName === \"video\") {\n        var mediaAttributes = attributes;\n        mediaAttributes.rr_mediaState = n2.paused ? \"paused\" : \"played\";\n        mediaAttributes.rr_mediaCurrentTime = n2.currentTime;\n        mediaAttributes.rr_mediaPlaybackRate = n2.playbackRate;\n        mediaAttributes.rr_mediaMuted = n2.muted;\n        mediaAttributes.rr_mediaLoop = n2.loop;\n        mediaAttributes.rr_mediaVolume = n2.volume;\n    }\n    if (!newlyAddedElement) {\n        if (n2.scrollLeft) {\n            attributes.rr_scrollLeft = n2.scrollLeft;\n        }\n        if (n2.scrollTop) {\n            attributes.rr_scrollTop = n2.scrollTop;\n        }\n    }\n    if (needBlock) {\n        var _n2_getBoundingClientRect = n2.getBoundingClientRect(), width = _n2_getBoundingClientRect.width, height = _n2_getBoundingClientRect.height;\n        attributes = {\n            class: attributes.class,\n            rr_width: \"\" + width + \"px\",\n            rr_height: \"\" + height + \"px\"\n        };\n    }\n    if (tagName === \"iframe\" && !keepIframeSrcFn(attributes.src)) {\n        if (!n2.contentDocument) {\n            attributes.rr_src = attributes.src;\n        }\n        delete attributes.src;\n    }\n    var isCustomElement;\n    try {\n        if (customElements.get(tagName)) isCustomElement = true;\n    } catch (e2) {}\n    return {\n        type: NodeType$3.Element,\n        tagName: tagName,\n        attributes: attributes,\n        childNodes: [],\n        isSVG: isSVGElement(n2) || void 0,\n        needBlock: needBlock,\n        rootId: rootId,\n        isCustom: isCustomElement\n    };\n}\nfunction lowerIfExists(maybeAttr) {\n    if (maybeAttr === void 0 || maybeAttr === null) {\n        return \"\";\n    } else {\n        return maybeAttr.toLowerCase();\n    }\n}\nfunction slimDOMExcluded(sn, slimDOMOptions) {\n    if (slimDOMOptions.comment && sn.type === NodeType$3.Comment) {\n        return true;\n    } else if (sn.type === NodeType$3.Element) {\n        if (slimDOMOptions.script && // script tag\n        (sn.tagName === \"script\" || // (module)preload link\n        sn.tagName === \"link\" && (sn.attributes.rel === \"preload\" && sn.attributes.as === \"script\" || sn.attributes.rel === \"modulepreload\") || // prefetch link\n        sn.tagName === \"link\" && sn.attributes.rel === \"prefetch\" && typeof sn.attributes.href === \"string\" && extractFileExtension(sn.attributes.href) === \"js\")) {\n            return true;\n        } else if (slimDOMOptions.headFavicon && (sn.tagName === \"link\" && sn.attributes.rel === \"shortcut icon\" || sn.tagName === \"meta\" && (lowerIfExists(sn.attributes.name).match(/^msapplication-tile(image|color)$/) || lowerIfExists(sn.attributes.name) === \"application-name\" || lowerIfExists(sn.attributes.rel) === \"icon\" || lowerIfExists(sn.attributes.rel) === \"apple-touch-icon\" || lowerIfExists(sn.attributes.rel) === \"shortcut icon\"))) {\n            return true;\n        } else if (sn.tagName === \"meta\") {\n            if (slimDOMOptions.headMetaDescKeywords && lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {\n                return true;\n            } else if (slimDOMOptions.headMetaSocial && (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || // og = opengraph (facebook)\n            lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) || lowerIfExists(sn.attributes.name) === \"pinterest\")) {\n                return true;\n            } else if (slimDOMOptions.headMetaRobots && (lowerIfExists(sn.attributes.name) === \"robots\" || lowerIfExists(sn.attributes.name) === \"googlebot\" || lowerIfExists(sn.attributes.name) === \"bingbot\")) {\n                return true;\n            } else if (slimDOMOptions.headMetaHttpEquiv && sn.attributes[\"http-equiv\"] !== void 0) {\n                return true;\n            } else if (slimDOMOptions.headMetaAuthorship && (lowerIfExists(sn.attributes.name) === \"author\" || lowerIfExists(sn.attributes.name) === \"generator\" || lowerIfExists(sn.attributes.name) === \"framework\" || lowerIfExists(sn.attributes.name) === \"publisher\" || lowerIfExists(sn.attributes.name) === \"progid\" || lowerIfExists(sn.attributes.property).match(/^article:/) || lowerIfExists(sn.attributes.property).match(/^product:/))) {\n                return true;\n            } else if (slimDOMOptions.headMetaVerification && (lowerIfExists(sn.attributes.name) === \"google-site-verification\" || lowerIfExists(sn.attributes.name) === \"yandex-verification\" || lowerIfExists(sn.attributes.name) === \"csrf-token\" || lowerIfExists(sn.attributes.name) === \"p:domain_verify\" || lowerIfExists(sn.attributes.name) === \"verify-v1\" || lowerIfExists(sn.attributes.name) === \"verification\" || lowerIfExists(sn.attributes.name) === \"shopify-checkout-api-token\")) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction serializeNodeWithId(n2, options) {\n    var doc = options.doc, mirror2 = options.mirror, blockClass = options.blockClass, blockSelector = options.blockSelector, maskTextClass = options.maskTextClass, maskTextSelector = options.maskTextSelector, _options_skipChild = options.skipChild, skipChild = _options_skipChild === void 0 ? false : _options_skipChild, _options_inlineStylesheet = options.inlineStylesheet, inlineStylesheet = _options_inlineStylesheet === void 0 ? true : _options_inlineStylesheet, _options_maskInputOptions = options.maskInputOptions, maskInputOptions = _options_maskInputOptions === void 0 ? {} : _options_maskInputOptions, maskTextFn = options.maskTextFn, maskInputFn = options.maskInputFn, slimDOMOptions = options.slimDOMOptions, _options_dataURLOptions = options.dataURLOptions, dataURLOptions = _options_dataURLOptions === void 0 ? {} : _options_dataURLOptions, _options_inlineImages = options.inlineImages, inlineImages = _options_inlineImages === void 0 ? false : _options_inlineImages, _options_recordCanvas = options.recordCanvas, recordCanvas = _options_recordCanvas === void 0 ? false : _options_recordCanvas, onSerialize = options.onSerialize, onIframeLoad = options.onIframeLoad, _options_iframeLoadTimeout = options.iframeLoadTimeout, iframeLoadTimeout = _options_iframeLoadTimeout === void 0 ? 5e3 : _options_iframeLoadTimeout, onStylesheetLoad = options.onStylesheetLoad, _options_stylesheetLoadTimeout = options.stylesheetLoadTimeout, stylesheetLoadTimeout = _options_stylesheetLoadTimeout === void 0 ? 5e3 : _options_stylesheetLoadTimeout, _options_keepIframeSrcFn = options.keepIframeSrcFn, keepIframeSrcFn = _options_keepIframeSrcFn === void 0 ? function() {\n        return false;\n    } : _options_keepIframeSrcFn, _options_newlyAddedElement = options.newlyAddedElement, newlyAddedElement = _options_newlyAddedElement === void 0 ? false : _options_newlyAddedElement, _options_cssCaptured = options.cssCaptured, cssCaptured = _options_cssCaptured === void 0 ? false : _options_cssCaptured;\n    var needsMask = options.needsMask;\n    var _options_preserveWhiteSpace = options.preserveWhiteSpace, preserveWhiteSpace = _options_preserveWhiteSpace === void 0 ? true : _options_preserveWhiteSpace;\n    if (!needsMask) {\n        var checkAncestors = needsMask === void 0;\n        needsMask = needMaskingText(n2, maskTextClass, maskTextSelector, checkAncestors);\n    }\n    var _serializedNode = serializeNode(n2, {\n        doc: doc,\n        mirror: mirror2,\n        blockClass: blockClass,\n        blockSelector: blockSelector,\n        needsMask: needsMask,\n        inlineStylesheet: inlineStylesheet,\n        maskInputOptions: maskInputOptions,\n        maskTextFn: maskTextFn,\n        maskInputFn: maskInputFn,\n        dataURLOptions: dataURLOptions,\n        inlineImages: inlineImages,\n        recordCanvas: recordCanvas,\n        keepIframeSrcFn: keepIframeSrcFn,\n        newlyAddedElement: newlyAddedElement,\n        cssCaptured: cssCaptured\n    });\n    if (!_serializedNode) {\n        console.warn(n2, \"not serialized\");\n        return null;\n    }\n    var id;\n    if (mirror2.hasNode(n2)) {\n        id = mirror2.getId(n2);\n    } else if (slimDOMExcluded(_serializedNode, slimDOMOptions) || !preserveWhiteSpace && _serializedNode.type === NodeType$3.Text && !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, \"\").length) {\n        id = IGNORED_NODE;\n    } else {\n        id = genId();\n    }\n    var serializedNode = Object.assign(_serializedNode, {\n        id: id\n    });\n    mirror2.add(n2, serializedNode);\n    if (id === IGNORED_NODE) {\n        return null;\n    }\n    if (onSerialize) {\n        onSerialize(n2);\n    }\n    var recordChild = !skipChild;\n    if (serializedNode.type === NodeType$3.Element) {\n        recordChild = recordChild && !serializedNode.needBlock;\n        delete serializedNode.needBlock;\n        var shadowRootEl = index$1.shadowRoot(n2);\n        if (shadowRootEl && isNativeShadowDom(shadowRootEl)) serializedNode.isShadowHost = true;\n    }\n    if ((serializedNode.type === NodeType$3.Document || serializedNode.type === NodeType$3.Element) && recordChild) {\n        if (slimDOMOptions.headWhitespace && serializedNode.type === NodeType$3.Element && serializedNode.tagName === \"head\") {\n            preserveWhiteSpace = false;\n        }\n        var bypassOptions = {\n            doc: doc,\n            mirror: mirror2,\n            blockClass: blockClass,\n            blockSelector: blockSelector,\n            needsMask: needsMask,\n            maskTextClass: maskTextClass,\n            maskTextSelector: maskTextSelector,\n            skipChild: skipChild,\n            inlineStylesheet: inlineStylesheet,\n            maskInputOptions: maskInputOptions,\n            maskTextFn: maskTextFn,\n            maskInputFn: maskInputFn,\n            slimDOMOptions: slimDOMOptions,\n            dataURLOptions: dataURLOptions,\n            inlineImages: inlineImages,\n            recordCanvas: recordCanvas,\n            preserveWhiteSpace: preserveWhiteSpace,\n            onSerialize: onSerialize,\n            onIframeLoad: onIframeLoad,\n            iframeLoadTimeout: iframeLoadTimeout,\n            onStylesheetLoad: onStylesheetLoad,\n            stylesheetLoadTimeout: stylesheetLoadTimeout,\n            keepIframeSrcFn: keepIframeSrcFn,\n            cssCaptured: false\n        };\n        if (serializedNode.type === NodeType$3.Element && serializedNode.tagName === \"textarea\" && serializedNode.attributes.value !== void 0) ;\n        else {\n            if (serializedNode.type === NodeType$3.Element && serializedNode.attributes._cssText !== void 0 && typeof serializedNode.attributes._cssText === \"string\") {\n                bypassOptions.cssCaptured = true;\n            }\n            for(var _iterator = _create_for_of_iterator_helper_loose(Array.from(index$1.childNodes(n2))), _step; !(_step = _iterator()).done;){\n                var childN = _step.value;\n                var serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n                if (serializedChildNode) {\n                    serializedNode.childNodes.push(serializedChildNode);\n                }\n            }\n        }\n        var shadowRootEl1 = null;\n        if (isElement(n2) && (shadowRootEl1 = index$1.shadowRoot(n2))) {\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(Array.from(index$1.childNodes(shadowRootEl1))), _step1; !(_step1 = _iterator1()).done;){\n                var childN1 = _step1.value;\n                var serializedChildNode1 = serializeNodeWithId(childN1, bypassOptions);\n                if (serializedChildNode1) {\n                    isNativeShadowDom(shadowRootEl1) && (serializedChildNode1.isShadow = true);\n                    serializedNode.childNodes.push(serializedChildNode1);\n                }\n            }\n        }\n    }\n    var parent = index$1.parentNode(n2);\n    if (parent && isShadowRoot(parent) && isNativeShadowDom(parent)) {\n        serializedNode.isShadow = true;\n    }\n    if (serializedNode.type === NodeType$3.Element && serializedNode.tagName === \"iframe\") {\n        onceIframeLoaded(n2, function() {\n            var iframeDoc = n2.contentDocument;\n            if (iframeDoc && onIframeLoad) {\n                var serializedIframeNode = serializeNodeWithId(iframeDoc, {\n                    doc: iframeDoc,\n                    mirror: mirror2,\n                    blockClass: blockClass,\n                    blockSelector: blockSelector,\n                    needsMask: needsMask,\n                    maskTextClass: maskTextClass,\n                    maskTextSelector: maskTextSelector,\n                    skipChild: false,\n                    inlineStylesheet: inlineStylesheet,\n                    maskInputOptions: maskInputOptions,\n                    maskTextFn: maskTextFn,\n                    maskInputFn: maskInputFn,\n                    slimDOMOptions: slimDOMOptions,\n                    dataURLOptions: dataURLOptions,\n                    inlineImages: inlineImages,\n                    recordCanvas: recordCanvas,\n                    preserveWhiteSpace: preserveWhiteSpace,\n                    onSerialize: onSerialize,\n                    onIframeLoad: onIframeLoad,\n                    iframeLoadTimeout: iframeLoadTimeout,\n                    onStylesheetLoad: onStylesheetLoad,\n                    stylesheetLoadTimeout: stylesheetLoadTimeout,\n                    keepIframeSrcFn: keepIframeSrcFn\n                });\n                if (serializedIframeNode) {\n                    onIframeLoad(n2, serializedIframeNode);\n                }\n            }\n        }, iframeLoadTimeout);\n    }\n    if (serializedNode.type === NodeType$3.Element && serializedNode.tagName === \"link\" && typeof serializedNode.attributes.rel === \"string\" && (serializedNode.attributes.rel === \"stylesheet\" || serializedNode.attributes.rel === \"preload\" && typeof serializedNode.attributes.href === \"string\" && extractFileExtension(serializedNode.attributes.href) === \"css\")) {\n        onceStylesheetLoaded(n2, function() {\n            if (onStylesheetLoad) {\n                var serializedLinkNode = serializeNodeWithId(n2, {\n                    doc: doc,\n                    mirror: mirror2,\n                    blockClass: blockClass,\n                    blockSelector: blockSelector,\n                    needsMask: needsMask,\n                    maskTextClass: maskTextClass,\n                    maskTextSelector: maskTextSelector,\n                    skipChild: false,\n                    inlineStylesheet: inlineStylesheet,\n                    maskInputOptions: maskInputOptions,\n                    maskTextFn: maskTextFn,\n                    maskInputFn: maskInputFn,\n                    slimDOMOptions: slimDOMOptions,\n                    dataURLOptions: dataURLOptions,\n                    inlineImages: inlineImages,\n                    recordCanvas: recordCanvas,\n                    preserveWhiteSpace: preserveWhiteSpace,\n                    onSerialize: onSerialize,\n                    onIframeLoad: onIframeLoad,\n                    iframeLoadTimeout: iframeLoadTimeout,\n                    onStylesheetLoad: onStylesheetLoad,\n                    stylesheetLoadTimeout: stylesheetLoadTimeout,\n                    keepIframeSrcFn: keepIframeSrcFn\n                });\n                if (serializedLinkNode) {\n                    onStylesheetLoad(n2, serializedLinkNode);\n                }\n            }\n        }, stylesheetLoadTimeout);\n    }\n    return serializedNode;\n}\nfunction snapshot(n2, options) {\n    var _ref = options || {}, tmp = _ref.mirror, mirror2 = tmp === void 0 ? new Mirror() : tmp, _ref_blockClass = _ref.blockClass, blockClass = _ref_blockClass === void 0 ? \"rr-block\" : _ref_blockClass, _ref_blockSelector = _ref.blockSelector, blockSelector = _ref_blockSelector === void 0 ? null : _ref_blockSelector, _ref_maskTextClass = _ref.maskTextClass, maskTextClass = _ref_maskTextClass === void 0 ? \"rr-mask\" : _ref_maskTextClass, _ref_maskTextSelector = _ref.maskTextSelector, maskTextSelector = _ref_maskTextSelector === void 0 ? null : _ref_maskTextSelector, _ref_inlineStylesheet = _ref.inlineStylesheet, inlineStylesheet = _ref_inlineStylesheet === void 0 ? true : _ref_inlineStylesheet, _ref_inlineImages = _ref.inlineImages, inlineImages = _ref_inlineImages === void 0 ? false : _ref_inlineImages, _ref_recordCanvas = _ref.recordCanvas, recordCanvas = _ref_recordCanvas === void 0 ? false : _ref_recordCanvas, _ref_maskAllInputs = _ref.maskAllInputs, maskAllInputs = _ref_maskAllInputs === void 0 ? false : _ref_maskAllInputs, maskTextFn = _ref.maskTextFn, maskInputFn = _ref.maskInputFn, _ref_slimDOM = _ref.slimDOM, slimDOM = _ref_slimDOM === void 0 ? false : _ref_slimDOM, dataURLOptions = _ref.dataURLOptions, preserveWhiteSpace = _ref.preserveWhiteSpace, onSerialize = _ref.onSerialize, onIframeLoad = _ref.onIframeLoad, iframeLoadTimeout = _ref.iframeLoadTimeout, onStylesheetLoad = _ref.onStylesheetLoad, stylesheetLoadTimeout = _ref.stylesheetLoadTimeout, _ref_keepIframeSrcFn = _ref.keepIframeSrcFn, keepIframeSrcFn = _ref_keepIframeSrcFn === void 0 ? function() {\n        return false;\n    } : _ref_keepIframeSrcFn;\n    var maskInputOptions = maskAllInputs === true ? {\n        color: true,\n        date: true,\n        \"datetime-local\": true,\n        email: true,\n        month: true,\n        number: true,\n        range: true,\n        search: true,\n        tel: true,\n        text: true,\n        time: true,\n        url: true,\n        week: true,\n        textarea: true,\n        select: true,\n        password: true,\n        hidden: true\n    } : maskAllInputs === false ? {\n        password: true\n    } : maskAllInputs;\n    var slimDOMOptions = slimDOM === true || slimDOM === \"all\" ? // if true: set of sensible options that should not throw away any information\n    {\n        script: true,\n        comment: true,\n        headFavicon: true,\n        headWhitespace: true,\n        headMetaDescKeywords: slimDOM === \"all\",\n        // destructive\n        headMetaSocial: true,\n        headMetaRobots: true,\n        headMetaHttpEquiv: true,\n        headMetaAuthorship: true,\n        headMetaVerification: true\n    } : slimDOM === false ? {} : slimDOM;\n    return serializeNodeWithId(n2, {\n        doc: n2,\n        mirror: mirror2,\n        blockClass: blockClass,\n        blockSelector: blockSelector,\n        maskTextClass: maskTextClass,\n        maskTextSelector: maskTextSelector,\n        skipChild: false,\n        inlineStylesheet: inlineStylesheet,\n        maskInputOptions: maskInputOptions,\n        maskTextFn: maskTextFn,\n        maskInputFn: maskInputFn,\n        slimDOMOptions: slimDOMOptions,\n        dataURLOptions: dataURLOptions,\n        inlineImages: inlineImages,\n        recordCanvas: recordCanvas,\n        preserveWhiteSpace: preserveWhiteSpace,\n        onSerialize: onSerialize,\n        onIframeLoad: onIframeLoad,\n        iframeLoadTimeout: iframeLoadTimeout,\n        onStylesheetLoad: onStylesheetLoad,\n        stylesheetLoadTimeout: stylesheetLoadTimeout,\n        keepIframeSrcFn: keepIframeSrcFn,\n        newlyAddedElement: false\n    });\n}\nfunction getDefaultExportFromCjs$1(x2) {\n    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, \"default\") ? x2[\"default\"] : x2;\n}\nfunction getAugmentedNamespace$1(n2) {\n    if (n2.__esModule) return n2;\n    var f2 = n2.default;\n    if (typeof f2 == \"function\") {\n        var a2 = function a22() {\n            if (_instanceof(this, a22)) {\n                return Reflect.construct(f2, arguments, this.constructor);\n            }\n            return f2.apply(this, arguments);\n        };\n        a2.prototype = f2.prototype;\n    } else a2 = {};\n    Object.defineProperty(a2, \"__esModule\", {\n        value: true\n    });\n    Object.keys(n2).forEach(function(k) {\n        var d = Object.getOwnPropertyDescriptor(n2, k);\n        Object.defineProperty(a2, k, d.get ? d : {\n            enumerable: true,\n            get: function get() {\n                return n2[k];\n            }\n        });\n    });\n    return a2;\n}\nvar picocolors_browser$1 = {\n    exports: {}\n};\nvar x$1 = String;\nvar create$1 = function create$1() {\n    return {\n        isColorSupported: false,\n        reset: x$1,\n        bold: x$1,\n        dim: x$1,\n        italic: x$1,\n        underline: x$1,\n        inverse: x$1,\n        hidden: x$1,\n        strikethrough: x$1,\n        black: x$1,\n        red: x$1,\n        green: x$1,\n        yellow: x$1,\n        blue: x$1,\n        magenta: x$1,\n        cyan: x$1,\n        white: x$1,\n        gray: x$1,\n        bgBlack: x$1,\n        bgRed: x$1,\n        bgGreen: x$1,\n        bgYellow: x$1,\n        bgBlue: x$1,\n        bgMagenta: x$1,\n        bgCyan: x$1,\n        bgWhite: x$1\n    };\n};\npicocolors_browser$1.exports = create$1();\npicocolors_browser$1.exports.createColors = create$1;\nvar picocolors_browserExports$1 = picocolors_browser$1.exports;\nvar __viteBrowserExternal$2 = {};\nvar __viteBrowserExternal$1$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n    __proto__: null,\n    default: __viteBrowserExternal$2\n}, Symbol.toStringTag, {\n    value: \"Module\"\n}));\nvar require$$2$1 = /* @__PURE__ */ getAugmentedNamespace$1(__viteBrowserExternal$1$1);\nvar pico$1 = picocolors_browserExports$1;\nvar terminalHighlight$1$1 = require$$2$1;\nvar CssSyntaxError$3$1 = /*#__PURE__*/ function(Error1) {\n    _inherits(CssSyntaxError, Error1);\n    function CssSyntaxError(message, line, column, source, file, plugin22) {\n        var _this;\n        _this = Error1.call(this, message) || this;\n        _this.name = \"CssSyntaxError\";\n        _this.reason = message;\n        if (file) {\n            _this.file = file;\n        }\n        if (source) {\n            _this.source = source;\n        }\n        if (plugin22) {\n            _this.plugin = plugin22;\n        }\n        if (typeof line !== \"undefined\" && typeof column !== \"undefined\") {\n            if (typeof line === \"number\") {\n                _this.line = line;\n                _this.column = column;\n            } else {\n                _this.line = line.line;\n                _this.column = line.column;\n                _this.endLine = column.line;\n                _this.endColumn = column.column;\n            }\n        }\n        _this.setMessage();\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(_this, CssSyntaxError);\n        }\n        return _this;\n    }\n    var _proto = CssSyntaxError.prototype;\n    _proto.setMessage = function setMessage() {\n        this.message = this.plugin ? this.plugin + \": \" : \"\";\n        this.message += this.file ? this.file : \"<css input>\";\n        if (typeof this.line !== \"undefined\") {\n            this.message += \":\" + this.line + \":\" + this.column;\n        }\n        this.message += \": \" + this.reason;\n    };\n    _proto.showSourceCode = function showSourceCode(color) {\n        var _this = this;\n        if (!this.source) return \"\";\n        var css = this.source;\n        if (color == null) color = pico$1.isColorSupported;\n        if (terminalHighlight$1$1) {\n            if (color) css = terminalHighlight$1$1(css);\n        }\n        var lines = css.split(/\\r?\\n/);\n        var start = Math.max(this.line - 3, 0);\n        var end = Math.min(this.line + 2, lines.length);\n        var maxWidth = String(end).length;\n        var mark, aside;\n        if (color) {\n            var _pico$1_createColors = pico$1.createColors(true), bold = _pico$1_createColors.bold, gray = _pico$1_createColors.gray, red = _pico$1_createColors.red;\n            mark = function(text) {\n                return bold(red(text));\n            };\n            aside = function(text) {\n                return gray(text);\n            };\n        } else {\n            mark = aside = function(str) {\n                return str;\n            };\n        }\n        return lines.slice(start, end).map(function(line, index2) {\n            var number = start + 1 + index2;\n            var gutter = \" \" + (\" \" + number).slice(-maxWidth) + \" | \";\n            if (number === _this.line) {\n                var spacing = aside(gutter.replace(/\\d/g, \" \")) + line.slice(0, _this.column - 1).replace(/[^\\t]/g, \" \");\n                return mark(\">\") + aside(gutter) + line + \"\\n \" + spacing + mark(\"^\");\n            }\n            return \" \" + aside(gutter) + line;\n        }).join(\"\\n\");\n    };\n    _proto.toString = function toString() {\n        var code = this.showSourceCode();\n        if (code) {\n            code = \"\\n\\n\" + code + \"\\n\";\n        }\n        return this.name + \": \" + this.message + code;\n    };\n    return CssSyntaxError;\n}(_wrap_native_super(Error));\nvar cssSyntaxError$1 = CssSyntaxError$3$1;\nCssSyntaxError$3$1.default = CssSyntaxError$3$1;\nvar symbols$1 = {};\nsymbols$1.isClean = Symbol(\"isClean\");\nsymbols$1.my = Symbol(\"my\");\nvar DEFAULT_RAW$1 = {\n    after: \"\\n\",\n    beforeClose: \"\\n\",\n    beforeComment: \"\\n\",\n    beforeDecl: \"\\n\",\n    beforeOpen: \" \",\n    beforeRule: \"\\n\",\n    colon: \": \",\n    commentLeft: \" \",\n    commentRight: \" \",\n    emptyBody: \"\",\n    indent: \"    \",\n    semicolon: false\n};\nfunction capitalize$1(str) {\n    return str[0].toUpperCase() + str.slice(1);\n}\nvar Stringifier$2$1 = /*#__PURE__*/ function() {\n    function Stringifier(builder) {\n        this.builder = builder;\n    }\n    var _proto = Stringifier.prototype;\n    _proto.atrule = function atrule(node2, semicolon) {\n        var name = \"@\" + node2.name;\n        var params = node2.params ? this.rawValue(node2, \"params\") : \"\";\n        if (typeof node2.raws.afterName !== \"undefined\") {\n            name += node2.raws.afterName;\n        } else if (params) {\n            name += \" \";\n        }\n        if (node2.nodes) {\n            this.block(node2, name + params);\n        } else {\n            var end = (node2.raws.between || \"\") + (semicolon ? \";\" : \"\");\n            this.builder(name + params + end, node2);\n        }\n    };\n    _proto.beforeAfter = function beforeAfter(node2, detect) {\n        var value;\n        if (node2.type === \"decl\") {\n            value = this.raw(node2, null, \"beforeDecl\");\n        } else if (node2.type === \"comment\") {\n            value = this.raw(node2, null, \"beforeComment\");\n        } else if (detect === \"before\") {\n            value = this.raw(node2, null, \"beforeRule\");\n        } else {\n            value = this.raw(node2, null, \"beforeClose\");\n        }\n        var buf = node2.parent;\n        var depth = 0;\n        while(buf && buf.type !== \"root\"){\n            depth += 1;\n            buf = buf.parent;\n        }\n        if (value.includes(\"\\n\")) {\n            var indent = this.raw(node2, null, \"indent\");\n            if (indent.length) {\n                for(var step = 0; step < depth; step++)value += indent;\n            }\n        }\n        return value;\n    };\n    _proto.block = function block(node2, start) {\n        var between = this.raw(node2, \"between\", \"beforeOpen\");\n        this.builder(start + between + \"{\", node2, \"start\");\n        var after;\n        if (node2.nodes && node2.nodes.length) {\n            this.body(node2);\n            after = this.raw(node2, \"after\");\n        } else {\n            after = this.raw(node2, \"after\", \"emptyBody\");\n        }\n        if (after) this.builder(after);\n        this.builder(\"}\", node2, \"end\");\n    };\n    _proto.body = function body(node2) {\n        var last = node2.nodes.length - 1;\n        while(last > 0){\n            if (node2.nodes[last].type !== \"comment\") break;\n            last -= 1;\n        }\n        var semicolon = this.raw(node2, \"semicolon\");\n        for(var i2 = 0; i2 < node2.nodes.length; i2++){\n            var child = node2.nodes[i2];\n            var before = this.raw(child, \"before\");\n            if (before) this.builder(before);\n            this.stringify(child, last !== i2 || semicolon);\n        }\n    };\n    _proto.comment = function comment(node2) {\n        var left = this.raw(node2, \"left\", \"commentLeft\");\n        var right = this.raw(node2, \"right\", \"commentRight\");\n        this.builder(\"/*\" + left + node2.text + right + \"*/\", node2);\n    };\n    _proto.decl = function decl(node2, semicolon) {\n        var between = this.raw(node2, \"between\", \"colon\");\n        var string = node2.prop + between + this.rawValue(node2, \"value\");\n        if (node2.important) {\n            string += node2.raws.important || \" !important\";\n        }\n        if (semicolon) string += \";\";\n        this.builder(string, node2);\n    };\n    _proto.document = function document1(node2) {\n        this.body(node2);\n    };\n    _proto.raw = function raw(node2, own, detect) {\n        var value;\n        if (!detect) detect = own;\n        if (own) {\n            value = node2.raws[own];\n            if (typeof value !== \"undefined\") return value;\n        }\n        var parent = node2.parent;\n        if (detect === \"before\") {\n            if (!parent || parent.type === \"root\" && parent.first === node2) {\n                return \"\";\n            }\n            if (parent && parent.type === \"document\") {\n                return \"\";\n            }\n        }\n        if (!parent) return DEFAULT_RAW$1[detect];\n        var root2 = node2.root();\n        if (!root2.rawCache) root2.rawCache = {};\n        if (typeof root2.rawCache[detect] !== \"undefined\") {\n            return root2.rawCache[detect];\n        }\n        if (detect === \"before\" || detect === \"after\") {\n            return this.beforeAfter(node2, detect);\n        } else {\n            var method = \"raw\" + capitalize$1(detect);\n            if (this[method]) {\n                value = this[method](root2, node2);\n            } else {\n                root2.walk(function(i2) {\n                    value = i2.raws[own];\n                    if (typeof value !== \"undefined\") return false;\n                });\n            }\n        }\n        if (typeof value === \"undefined\") value = DEFAULT_RAW$1[detect];\n        root2.rawCache[detect] = value;\n        return value;\n    };\n    _proto.rawBeforeClose = function rawBeforeClose(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && i2.nodes.length > 0) {\n                if (typeof i2.raws.after !== \"undefined\") {\n                    value = i2.raws.after;\n                    if (value.includes(\"\\n\")) {\n                        value = value.replace(/[^\\n]+$/, \"\");\n                    }\n                    return false;\n                }\n            }\n        });\n        if (value) value = value.replace(/\\S/g, \"\");\n        return value;\n    };\n    _proto.rawBeforeComment = function rawBeforeComment(root2, node2) {\n        var value;\n        root2.walkComments(function(i2) {\n            if (typeof i2.raws.before !== \"undefined\") {\n                value = i2.raws.before;\n                if (value.includes(\"\\n\")) {\n                    value = value.replace(/[^\\n]+$/, \"\");\n                }\n                return false;\n            }\n        });\n        if (typeof value === \"undefined\") {\n            value = this.raw(node2, null, \"beforeDecl\");\n        } else if (value) {\n            value = value.replace(/\\S/g, \"\");\n        }\n        return value;\n    };\n    _proto.rawBeforeDecl = function rawBeforeDecl(root2, node2) {\n        var value;\n        root2.walkDecls(function(i2) {\n            if (typeof i2.raws.before !== \"undefined\") {\n                value = i2.raws.before;\n                if (value.includes(\"\\n\")) {\n                    value = value.replace(/[^\\n]+$/, \"\");\n                }\n                return false;\n            }\n        });\n        if (typeof value === \"undefined\") {\n            value = this.raw(node2, null, \"beforeRule\");\n        } else if (value) {\n            value = value.replace(/\\S/g, \"\");\n        }\n        return value;\n    };\n    _proto.rawBeforeOpen = function rawBeforeOpen(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.type !== \"decl\") {\n                value = i2.raws.between;\n                if (typeof value !== \"undefined\") return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawBeforeRule = function rawBeforeRule(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && (i2.parent !== root2 || root2.first !== i2)) {\n                if (typeof i2.raws.before !== \"undefined\") {\n                    value = i2.raws.before;\n                    if (value.includes(\"\\n\")) {\n                        value = value.replace(/[^\\n]+$/, \"\");\n                    }\n                    return false;\n                }\n            }\n        });\n        if (value) value = value.replace(/\\S/g, \"\");\n        return value;\n    };\n    _proto.rawColon = function rawColon(root2) {\n        var value;\n        root2.walkDecls(function(i2) {\n            if (typeof i2.raws.between !== \"undefined\") {\n                value = i2.raws.between.replace(/[^\\s:]/g, \"\");\n                return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawEmptyBody = function rawEmptyBody(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && i2.nodes.length === 0) {\n                value = i2.raws.after;\n                if (typeof value !== \"undefined\") return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawIndent = function rawIndent(root2) {\n        if (root2.raws.indent) return root2.raws.indent;\n        var value;\n        root2.walk(function(i2) {\n            var p = i2.parent;\n            if (p && p !== root2 && p.parent && p.parent === root2) {\n                if (typeof i2.raws.before !== \"undefined\") {\n                    var parts = i2.raws.before.split(\"\\n\");\n                    value = parts[parts.length - 1];\n                    value = value.replace(/\\S/g, \"\");\n                    return false;\n                }\n            }\n        });\n        return value;\n    };\n    _proto.rawSemicolon = function rawSemicolon(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && i2.nodes.length && i2.last.type === \"decl\") {\n                value = i2.raws.semicolon;\n                if (typeof value !== \"undefined\") return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawValue = function rawValue(node2, prop) {\n        var value = node2[prop];\n        var raw = node2.raws[prop];\n        if (raw && raw.value === value) {\n            return raw.raw;\n        }\n        return value;\n    };\n    _proto.root = function root(node2) {\n        this.body(node2);\n        if (node2.raws.after) this.builder(node2.raws.after);\n    };\n    _proto.rule = function rule(node2) {\n        this.block(node2, this.rawValue(node2, \"selector\"));\n        if (node2.raws.ownSemicolon) {\n            this.builder(node2.raws.ownSemicolon, node2, \"end\");\n        }\n    };\n    _proto.stringify = function stringify(node2, semicolon) {\n        if (!this[node2.type]) {\n            throw new Error(\"Unknown AST node type \" + node2.type + \". Maybe you need to change PostCSS stringifier.\");\n        }\n        this[node2.type](node2, semicolon);\n    };\n    return Stringifier;\n}();\nvar stringifier$1 = Stringifier$2$1;\nStringifier$2$1.default = Stringifier$2$1;\nvar Stringifier$1$1 = stringifier$1;\nfunction stringify$4$1(node2, builder) {\n    var str = new Stringifier$1$1(builder);\n    str.stringify(node2);\n}\nvar stringify_1$1 = stringify$4$1;\nstringify$4$1.default = stringify$4$1;\nvar isClean$2$1 = symbols$1.isClean, my$2$1 = symbols$1.my;\nvar CssSyntaxError$2$1 = cssSyntaxError$1;\nvar Stringifier2$1 = stringifier$1;\nvar stringify$3$1 = stringify_1$1;\nfunction cloneNode$1(obj, parent) {\n    var cloned = new obj.constructor();\n    for(var i2 in obj){\n        if (!Object.prototype.hasOwnProperty.call(obj, i2)) {\n            continue;\n        }\n        if (i2 === \"proxyCache\") continue;\n        var value = obj[i2];\n        var type = typeof value === \"undefined\" ? \"undefined\" : _type_of(value);\n        if (i2 === \"parent\" && type === \"object\") {\n            if (parent) cloned[i2] = parent;\n        } else if (i2 === \"source\") {\n            cloned[i2] = value;\n        } else if (Array.isArray(value)) {\n            cloned[i2] = value.map(function(j) {\n                return cloneNode$1(j, cloned);\n            });\n        } else {\n            if (type === \"object\" && value !== null) value = cloneNode$1(value);\n            cloned[i2] = value;\n        }\n    }\n    return cloned;\n}\nvar Node$4$1 = /*#__PURE__*/ function() {\n    function Node2(defaults) {\n        if (defaults === void 0) defaults = {};\n        this.raws = {};\n        this[isClean$2$1] = false;\n        this[my$2$1] = true;\n        for(var name in defaults){\n            if (name === \"nodes\") {\n                this.nodes = [];\n                for(var _iterator = _create_for_of_iterator_helper_loose(defaults[name]), _step; !(_step = _iterator()).done;){\n                    var node2 = _step.value;\n                    if (typeof node2.clone === \"function\") {\n                        this.append(node2.clone());\n                    } else {\n                        this.append(node2);\n                    }\n                }\n            } else {\n                this[name] = defaults[name];\n            }\n        }\n    }\n    var _proto = Node2.prototype;\n    _proto.addToError = function addToError(error) {\n        error.postcssNode = this;\n        if (error.stack && this.source && /\\n\\s{4}at /.test(error.stack)) {\n            var s2 = this.source;\n            error.stack = error.stack.replace(/\\n\\s{4}at /, \"$&\" + s2.input.from + \":\" + s2.start.line + \":\" + s2.start.column + \"$&\");\n        }\n        return error;\n    };\n    _proto.after = function after(add) {\n        this.parent.insertAfter(this, add);\n        return this;\n    };\n    _proto.assign = function assign(overrides) {\n        if (overrides === void 0) overrides = {};\n        for(var name in overrides){\n            this[name] = overrides[name];\n        }\n        return this;\n    };\n    _proto.before = function before(add) {\n        this.parent.insertBefore(this, add);\n        return this;\n    };\n    _proto.cleanRaws = function cleanRaws(keepBetween) {\n        delete this.raws.before;\n        delete this.raws.after;\n        if (!keepBetween) delete this.raws.between;\n    };\n    _proto.clone = function clone(overrides) {\n        if (overrides === void 0) overrides = {};\n        var cloned = cloneNode$1(this);\n        for(var name in overrides){\n            cloned[name] = overrides[name];\n        }\n        return cloned;\n    };\n    _proto.cloneAfter = function cloneAfter(overrides) {\n        if (overrides === void 0) overrides = {};\n        var cloned = this.clone(overrides);\n        this.parent.insertAfter(this, cloned);\n        return cloned;\n    };\n    _proto.cloneBefore = function cloneBefore(overrides) {\n        if (overrides === void 0) overrides = {};\n        var cloned = this.clone(overrides);\n        this.parent.insertBefore(this, cloned);\n        return cloned;\n    };\n    _proto.error = function error(message, opts) {\n        if (opts === void 0) opts = {};\n        if (this.source) {\n            var _this_rangeBy = this.rangeBy(opts), end = _this_rangeBy.end, start = _this_rangeBy.start;\n            return this.source.input.error(message, {\n                column: start.column,\n                line: start.line\n            }, {\n                column: end.column,\n                line: end.line\n            }, opts);\n        }\n        return new CssSyntaxError$2$1(message);\n    };\n    _proto.getProxyProcessor = function getProxyProcessor() {\n        return {\n            get: function get(node2, prop) {\n                if (prop === \"proxyOf\") {\n                    return node2;\n                } else if (prop === \"root\") {\n                    return function() {\n                        return node2.root().toProxy();\n                    };\n                } else {\n                    return node2[prop];\n                }\n            },\n            set: function set(node2, prop, value) {\n                if (node2[prop] === value) return true;\n                node2[prop] = value;\n                if (prop === \"prop\" || prop === \"value\" || prop === \"name\" || prop === \"params\" || prop === \"important\" || /* c8 ignore next */ prop === \"text\") {\n                    node2.markDirty();\n                }\n                return true;\n            }\n        };\n    };\n    _proto.markDirty = function markDirty() {\n        if (this[isClean$2$1]) {\n            this[isClean$2$1] = false;\n            var next = this;\n            while(next = next.parent){\n                next[isClean$2$1] = false;\n            }\n        }\n    };\n    _proto.next = function next() {\n        if (!this.parent) return void 0;\n        var index2 = this.parent.index(this);\n        return this.parent.nodes[index2 + 1];\n    };\n    _proto.positionBy = function positionBy(opts, stringRepresentation) {\n        var pos = this.source.start;\n        if (opts.index) {\n            pos = this.positionInside(opts.index, stringRepresentation);\n        } else if (opts.word) {\n            stringRepresentation = this.toString();\n            var index2 = stringRepresentation.indexOf(opts.word);\n            if (index2 !== -1) pos = this.positionInside(index2, stringRepresentation);\n        }\n        return pos;\n    };\n    _proto.positionInside = function positionInside(index2, stringRepresentation) {\n        var string = stringRepresentation || this.toString();\n        var column = this.source.start.column;\n        var line = this.source.start.line;\n        for(var i2 = 0; i2 < index2; i2++){\n            if (string[i2] === \"\\n\") {\n                column = 1;\n                line += 1;\n            } else {\n                column += 1;\n            }\n        }\n        return {\n            column: column,\n            line: line\n        };\n    };\n    _proto.prev = function prev() {\n        if (!this.parent) return void 0;\n        var index2 = this.parent.index(this);\n        return this.parent.nodes[index2 - 1];\n    };\n    _proto.rangeBy = function rangeBy(opts) {\n        var start = {\n            column: this.source.start.column,\n            line: this.source.start.line\n        };\n        var end = this.source.end ? {\n            column: this.source.end.column + 1,\n            line: this.source.end.line\n        } : {\n            column: start.column + 1,\n            line: start.line\n        };\n        if (opts.word) {\n            var stringRepresentation = this.toString();\n            var index2 = stringRepresentation.indexOf(opts.word);\n            if (index2 !== -1) {\n                start = this.positionInside(index2, stringRepresentation);\n                end = this.positionInside(index2 + opts.word.length, stringRepresentation);\n            }\n        } else {\n            if (opts.start) {\n                start = {\n                    column: opts.start.column,\n                    line: opts.start.line\n                };\n            } else if (opts.index) {\n                start = this.positionInside(opts.index);\n            }\n            if (opts.end) {\n                end = {\n                    column: opts.end.column,\n                    line: opts.end.line\n                };\n            } else if (typeof opts.endIndex === \"number\") {\n                end = this.positionInside(opts.endIndex);\n            } else if (opts.index) {\n                end = this.positionInside(opts.index + 1);\n            }\n        }\n        if (end.line < start.line || end.line === start.line && end.column <= start.column) {\n            end = {\n                column: start.column + 1,\n                line: start.line\n            };\n        }\n        return {\n            end: end,\n            start: start\n        };\n    };\n    _proto.raw = function raw(prop, defaultType) {\n        var str = new Stringifier2$1();\n        return str.raw(this, prop, defaultType);\n    };\n    _proto.remove = function remove() {\n        if (this.parent) {\n            this.parent.removeChild(this);\n        }\n        this.parent = void 0;\n        return this;\n    };\n    _proto.replaceWith = function replaceWith() {\n        for(var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++){\n            nodes[_key] = arguments[_key];\n        }\n        if (this.parent) {\n            var bookmark = this;\n            var foundSelf = false;\n            for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n                var node2 = _step.value;\n                if (node2 === this) {\n                    foundSelf = true;\n                } else if (foundSelf) {\n                    this.parent.insertAfter(bookmark, node2);\n                    bookmark = node2;\n                } else {\n                    this.parent.insertBefore(bookmark, node2);\n                }\n            }\n            if (!foundSelf) {\n                this.remove();\n            }\n        }\n        return this;\n    };\n    _proto.root = function root() {\n        var result2 = this;\n        while(result2.parent && result2.parent.type !== \"document\"){\n            result2 = result2.parent;\n        }\n        return result2;\n    };\n    _proto.toJSON = function toJSON(_, inputs) {\n        var fixed = {};\n        var emitInputs = inputs == null;\n        inputs = inputs || /* @__PURE__ */ new Map();\n        var inputsNextIndex = 0;\n        for(var name in this){\n            if (!Object.prototype.hasOwnProperty.call(this, name)) {\n                continue;\n            }\n            if (name === \"parent\" || name === \"proxyCache\") continue;\n            var value = this[name];\n            if (Array.isArray(value)) {\n                fixed[name] = value.map(function(i2) {\n                    if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && i2.toJSON) {\n                        return i2.toJSON(null, inputs);\n                    } else {\n                        return i2;\n                    }\n                });\n            } else if ((typeof value === \"undefined\" ? \"undefined\" : _type_of(value)) === \"object\" && value.toJSON) {\n                fixed[name] = value.toJSON(null, inputs);\n            } else if (name === \"source\") {\n                var inputId = inputs.get(value.input);\n                if (inputId == null) {\n                    inputId = inputsNextIndex;\n                    inputs.set(value.input, inputsNextIndex);\n                    inputsNextIndex++;\n                }\n                fixed[name] = {\n                    end: value.end,\n                    inputId: inputId,\n                    start: value.start\n                };\n            } else {\n                fixed[name] = value;\n            }\n        }\n        if (emitInputs) {\n            fixed.inputs = [].concat(inputs.keys()).map(function(input2) {\n                return input2.toJSON();\n            });\n        }\n        return fixed;\n    };\n    _proto.toProxy = function toProxy() {\n        if (!this.proxyCache) {\n            this.proxyCache = new Proxy(this, this.getProxyProcessor());\n        }\n        return this.proxyCache;\n    };\n    _proto.toString = function toString(stringifier2) {\n        if (stringifier2 === void 0) stringifier2 = stringify$3$1;\n        if (stringifier2.stringify) stringifier2 = stringifier2.stringify;\n        var result2 = \"\";\n        stringifier2(this, function(i2) {\n            result2 += i2;\n        });\n        return result2;\n    };\n    _proto.warn = function warn(result2, text, opts) {\n        var data = {\n            node: this\n        };\n        for(var i2 in opts)data[i2] = opts[i2];\n        return result2.warn(text, data);\n    };\n    _create_class(Node2, [\n        {\n            key: \"proxyOf\",\n            get: function get() {\n                return this;\n            }\n        }\n    ]);\n    return Node2;\n}();\nvar node$1 = Node$4$1;\nNode$4$1.default = Node$4$1;\nvar Node$3$1 = node$1;\nvar Declaration$4$1 = /*#__PURE__*/ function(Node$3$1) {\n    _inherits(Declaration, Node$3$1);\n    function Declaration(defaults) {\n        var _this;\n        if (defaults && typeof defaults.value !== \"undefined\" && typeof defaults.value !== \"string\") {\n            defaults = _extends({}, defaults, {\n                value: String(defaults.value)\n            });\n        }\n        _this = Node$3$1.call(this, defaults) || this;\n        _this.type = \"decl\";\n        return _this;\n    }\n    _create_class(Declaration, [\n        {\n            key: \"variable\",\n            get: function get() {\n                return this.prop.startsWith(\"--\") || this.prop[0] === \"$\";\n            }\n        }\n    ]);\n    return Declaration;\n}(Node$3$1);\nvar declaration$1 = Declaration$4$1;\nDeclaration$4$1.default = Declaration$4$1;\nvar urlAlphabet$1 = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nvar nanoid$1$1 = function(size) {\n    if (size === void 0) size = 21;\n    var id = \"\";\n    var i2 = size;\n    while(i2--){\n        id += urlAlphabet$1[Math.random() * 64 | 0];\n    }\n    return id;\n};\nvar nonSecure$1 = {\n    nanoid: nanoid$1$1\n};\nvar SourceMapConsumer$2$1 = require$$2$1.SourceMapConsumer, SourceMapGenerator$2$1 = require$$2$1.SourceMapGenerator;\nvar existsSync$1 = require$$2$1.existsSync, readFileSync$1 = require$$2$1.readFileSync;\nvar dirname$1$1 = require$$2$1.dirname, join$1 = require$$2$1.join;\nfunction fromBase64$1(str) {\n    if (Buffer) {\n        return Buffer.from(str, \"base64\").toString();\n    } else {\n        return window.atob(str);\n    }\n}\nvar PreviousMap$2$1 = /*#__PURE__*/ function() {\n    function PreviousMap(css, opts) {\n        if (opts.map === false) return;\n        this.loadAnnotation(css);\n        this.inline = this.startWith(this.annotation, \"data:\");\n        var prev = opts.map ? opts.map.prev : void 0;\n        var text = this.loadMap(opts.from, prev);\n        if (!this.mapFile && opts.from) {\n            this.mapFile = opts.from;\n        }\n        if (this.mapFile) this.root = dirname$1$1(this.mapFile);\n        if (text) this.text = text;\n    }\n    var _proto = PreviousMap.prototype;\n    _proto.consumer = function consumer() {\n        if (!this.consumerCache) {\n            this.consumerCache = new SourceMapConsumer$2$1(this.text);\n        }\n        return this.consumerCache;\n    };\n    _proto.decodeInline = function decodeInline(text) {\n        var baseCharsetUri = /^data:application\\/json;charset=utf-?8;base64,/;\n        var baseUri = /^data:application\\/json;base64,/;\n        var charsetUri = /^data:application\\/json;charset=utf-?8,/;\n        var uri = /^data:application\\/json,/;\n        if (charsetUri.test(text) || uri.test(text)) {\n            return decodeURIComponent(text.substr(RegExp.lastMatch.length));\n        }\n        if (baseCharsetUri.test(text) || baseUri.test(text)) {\n            return fromBase64$1(text.substr(RegExp.lastMatch.length));\n        }\n        var encoding = text.match(/data:application\\/json;([^,]+),/)[1];\n        throw new Error(\"Unsupported source map encoding \" + encoding);\n    };\n    _proto.getAnnotationURL = function getAnnotationURL(sourceMapString) {\n        return sourceMapString.replace(/^\\/\\*\\s*# sourceMappingURL=/, \"\").trim();\n    };\n    _proto.isMap = function isMap(map) {\n        if ((typeof map === \"undefined\" ? \"undefined\" : _type_of(map)) !== \"object\") return false;\n        return typeof map.mappings === \"string\" || typeof map._mappings === \"string\" || Array.isArray(map.sections);\n    };\n    _proto.loadAnnotation = function loadAnnotation(css) {\n        var comments = css.match(/\\/\\*\\s*# sourceMappingURL=/gm);\n        if (!comments) return;\n        var start = css.lastIndexOf(comments.pop());\n        var end = css.indexOf(\"*/\", start);\n        if (start > -1 && end > -1) {\n            this.annotation = this.getAnnotationURL(css.substring(start, end));\n        }\n    };\n    _proto.loadFile = function loadFile(path) {\n        this.root = dirname$1$1(path);\n        if (existsSync$1(path)) {\n            this.mapFile = path;\n            return readFileSync$1(path, \"utf-8\").toString().trim();\n        }\n    };\n    _proto.loadMap = function loadMap(file, prev) {\n        if (prev === false) return false;\n        if (prev) {\n            if (typeof prev === \"string\") {\n                return prev;\n            } else if (typeof prev === \"function\") {\n                var prevPath = prev(file);\n                if (prevPath) {\n                    var map = this.loadFile(prevPath);\n                    if (!map) {\n                        throw new Error(\"Unable to load previous source map: \" + prevPath.toString());\n                    }\n                    return map;\n                }\n            } else if (_instanceof(prev, SourceMapConsumer$2$1)) {\n                return SourceMapGenerator$2$1.fromSourceMap(prev).toString();\n            } else if (_instanceof(prev, SourceMapGenerator$2$1)) {\n                return prev.toString();\n            } else if (this.isMap(prev)) {\n                return JSON.stringify(prev);\n            } else {\n                throw new Error(\"Unsupported previous source map format: \" + prev.toString());\n            }\n        } else if (this.inline) {\n            return this.decodeInline(this.annotation);\n        } else if (this.annotation) {\n            var map1 = this.annotation;\n            if (file) map1 = join$1(dirname$1$1(file), map1);\n            return this.loadFile(map1);\n        }\n    };\n    _proto.startWith = function startWith(string, start) {\n        if (!string) return false;\n        return string.substr(0, start.length) === start;\n    };\n    _proto.withContent = function withContent() {\n        return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);\n    };\n    return PreviousMap;\n}();\nvar previousMap$1 = PreviousMap$2$1;\nPreviousMap$2$1.default = PreviousMap$2$1;\nvar SourceMapConsumer$1$1 = require$$2$1.SourceMapConsumer, SourceMapGenerator$1$1 = require$$2$1.SourceMapGenerator;\nvar fileURLToPath$1 = require$$2$1.fileURLToPath, pathToFileURL$1$1 = require$$2$1.pathToFileURL;\nvar isAbsolute$1 = require$$2$1.isAbsolute, resolve$1$1 = require$$2$1.resolve;\nvar nanoid$2 = nonSecure$1.nanoid;\nvar terminalHighlight$2 = require$$2$1;\nvar CssSyntaxError$1$1 = cssSyntaxError$1;\nvar PreviousMap$1$1 = previousMap$1;\nvar fromOffsetCache$1 = Symbol(\"fromOffsetCache\");\nvar sourceMapAvailable$1$1 = Boolean(SourceMapConsumer$1$1 && SourceMapGenerator$1$1);\nvar pathAvailable$1$1 = Boolean(resolve$1$1 && isAbsolute$1);\nvar Input$4$1 = /*#__PURE__*/ function() {\n    function Input(css, opts) {\n        if (opts === void 0) opts = {};\n        if (css === null || typeof css === \"undefined\" || (typeof css === \"undefined\" ? \"undefined\" : _type_of(css)) === \"object\" && !css.toString) {\n            throw new Error(\"PostCSS received \" + css + \" instead of CSS string\");\n        }\n        this.css = css.toString();\n        if (this.css[0] === \"\\uFEFF\" || this.css[0] === \"\") {\n            this.hasBOM = true;\n            this.css = this.css.slice(1);\n        } else {\n            this.hasBOM = false;\n        }\n        if (opts.from) {\n            if (!pathAvailable$1$1 || /^\\w+:\\/\\//.test(opts.from) || isAbsolute$1(opts.from)) {\n                this.file = opts.from;\n            } else {\n                this.file = resolve$1$1(opts.from);\n            }\n        }\n        if (pathAvailable$1$1 && sourceMapAvailable$1$1) {\n            var map = new PreviousMap$1$1(this.css, opts);\n            if (map.text) {\n                this.map = map;\n                var file = map.consumer().file;\n                if (!this.file && file) this.file = this.mapResolve(file);\n            }\n        }\n        if (!this.file) {\n            this.id = \"<input css \" + nanoid$2(6) + \">\";\n        }\n        if (this.map) this.map.file = this.from;\n    }\n    var _proto = Input.prototype;\n    _proto.error = function error(message, line, column, opts) {\n        if (opts === void 0) opts = {};\n        var result2, endLine, endColumn;\n        if (line && (typeof line === \"undefined\" ? \"undefined\" : _type_of(line)) === \"object\") {\n            var start = line;\n            var end = column;\n            if (typeof start.offset === \"number\") {\n                var pos = this.fromOffset(start.offset);\n                line = pos.line;\n                column = pos.col;\n            } else {\n                line = start.line;\n                column = start.column;\n            }\n            if (typeof end.offset === \"number\") {\n                var pos1 = this.fromOffset(end.offset);\n                endLine = pos1.line;\n                endColumn = pos1.col;\n            } else {\n                endLine = end.line;\n                endColumn = end.column;\n            }\n        } else if (!column) {\n            var pos2 = this.fromOffset(line);\n            line = pos2.line;\n            column = pos2.col;\n        }\n        var origin = this.origin(line, column, endLine, endColumn);\n        if (origin) {\n            result2 = new CssSyntaxError$1$1(message, origin.endLine === void 0 ? origin.line : {\n                column: origin.column,\n                line: origin.line\n            }, origin.endLine === void 0 ? origin.column : {\n                column: origin.endColumn,\n                line: origin.endLine\n            }, origin.source, origin.file, opts.plugin);\n        } else {\n            result2 = new CssSyntaxError$1$1(message, endLine === void 0 ? line : {\n                column: column,\n                line: line\n            }, endLine === void 0 ? column : {\n                column: endColumn,\n                line: endLine\n            }, this.css, this.file, opts.plugin);\n        }\n        result2.input = {\n            column: column,\n            endColumn: endColumn,\n            endLine: endLine,\n            line: line,\n            source: this.css\n        };\n        if (this.file) {\n            if (pathToFileURL$1$1) {\n                result2.input.url = pathToFileURL$1$1(this.file).toString();\n            }\n            result2.input.file = this.file;\n        }\n        return result2;\n    };\n    _proto.fromOffset = function fromOffset(offset) {\n        var lastLine, lineToIndex;\n        if (!this[fromOffsetCache$1]) {\n            var lines = this.css.split(\"\\n\");\n            lineToIndex = new Array(lines.length);\n            var prevIndex = 0;\n            for(var i2 = 0, l2 = lines.length; i2 < l2; i2++){\n                lineToIndex[i2] = prevIndex;\n                prevIndex += lines[i2].length + 1;\n            }\n            this[fromOffsetCache$1] = lineToIndex;\n        } else {\n            lineToIndex = this[fromOffsetCache$1];\n        }\n        lastLine = lineToIndex[lineToIndex.length - 1];\n        var min = 0;\n        if (offset >= lastLine) {\n            min = lineToIndex.length - 1;\n        } else {\n            var max = lineToIndex.length - 2;\n            var mid;\n            while(min < max){\n                mid = min + (max - min >> 1);\n                if (offset < lineToIndex[mid]) {\n                    max = mid - 1;\n                } else if (offset >= lineToIndex[mid + 1]) {\n                    min = mid + 1;\n                } else {\n                    min = mid;\n                    break;\n                }\n            }\n        }\n        return {\n            col: offset - lineToIndex[min] + 1,\n            line: min + 1\n        };\n    };\n    _proto.mapResolve = function mapResolve(file) {\n        if (/^\\w+:\\/\\//.test(file)) {\n            return file;\n        }\n        return resolve$1$1(this.map.consumer().sourceRoot || this.map.root || \".\", file);\n    };\n    _proto.origin = function origin(line, column, endLine, endColumn) {\n        if (!this.map) return false;\n        var consumer = this.map.consumer();\n        var from = consumer.originalPositionFor({\n            column: column,\n            line: line\n        });\n        if (!from.source) return false;\n        var to;\n        if (typeof endLine === \"number\") {\n            to = consumer.originalPositionFor({\n                column: endColumn,\n                line: endLine\n            });\n        }\n        var fromUrl;\n        if (isAbsolute$1(from.source)) {\n            fromUrl = pathToFileURL$1$1(from.source);\n        } else {\n            fromUrl = new URL(from.source, this.map.consumer().sourceRoot || pathToFileURL$1$1(this.map.mapFile));\n        }\n        var result2 = {\n            column: from.column,\n            endColumn: to && to.column,\n            endLine: to && to.line,\n            line: from.line,\n            url: fromUrl.toString()\n        };\n        if (fromUrl.protocol === \"file:\") {\n            if (fileURLToPath$1) {\n                result2.file = fileURLToPath$1(fromUrl);\n            } else {\n                throw new Error(\"file: protocol is not available in this PostCSS build\");\n            }\n        }\n        var source = consumer.sourceContentFor(from.source);\n        if (source) result2.source = source;\n        return result2;\n    };\n    _proto.toJSON = function toJSON() {\n        var json = {};\n        for(var _i = 0, _iter = [\n            \"hasBOM\",\n            \"css\",\n            \"file\",\n            \"id\"\n        ]; _i < _iter.length; _i++){\n            var name = _iter[_i];\n            if (this[name] != null) {\n                json[name] = this[name];\n            }\n        }\n        if (this.map) {\n            json.map = _extends({}, this.map);\n            if (json.map.consumerCache) {\n                json.map.consumerCache = void 0;\n            }\n        }\n        return json;\n    };\n    _create_class(Input, [\n        {\n            key: \"from\",\n            get: function get() {\n                return this.file || this.id;\n            }\n        }\n    ]);\n    return Input;\n}();\nvar input$1 = Input$4$1;\nInput$4$1.default = Input$4$1;\nif (terminalHighlight$2 && terminalHighlight$2.registerInput) {\n    terminalHighlight$2.registerInput(Input$4$1);\n}\nvar SourceMapConsumer$3 = require$$2$1.SourceMapConsumer, SourceMapGenerator$3 = require$$2$1.SourceMapGenerator;\nvar dirname$2 = require$$2$1.dirname, relative$1 = require$$2$1.relative, resolve$2 = require$$2$1.resolve, sep$1 = require$$2$1.sep;\nvar pathToFileURL$2 = require$$2$1.pathToFileURL;\nvar Input$3$1 = input$1;\nvar sourceMapAvailable$2 = Boolean(SourceMapConsumer$3 && SourceMapGenerator$3);\nvar pathAvailable$2 = Boolean(dirname$2 && resolve$2 && relative$1 && sep$1);\nvar MapGenerator$2$1 = /*#__PURE__*/ function() {\n    function MapGenerator(stringify2, root2, opts, cssString) {\n        this.stringify = stringify2;\n        this.mapOpts = opts.map || {};\n        this.root = root2;\n        this.opts = opts;\n        this.css = cssString;\n        this.originalCSS = cssString;\n        this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;\n        this.memoizedFileURLs = /* @__PURE__ */ new Map();\n        this.memoizedPaths = /* @__PURE__ */ new Map();\n        this.memoizedURLs = /* @__PURE__ */ new Map();\n    }\n    var _proto = MapGenerator.prototype;\n    _proto.addAnnotation = function addAnnotation() {\n        var content;\n        if (this.isInline()) {\n            content = \"data:application/json;base64,\" + this.toBase64(this.map.toString());\n        } else if (typeof this.mapOpts.annotation === \"string\") {\n            content = this.mapOpts.annotation;\n        } else if (typeof this.mapOpts.annotation === \"function\") {\n            content = this.mapOpts.annotation(this.opts.to, this.root);\n        } else {\n            content = this.outputFile() + \".map\";\n        }\n        var eol = \"\\n\";\n        if (this.css.includes(\"\\r\\n\")) eol = \"\\r\\n\";\n        this.css += eol + \"/*# sourceMappingURL=\" + content + \" */\";\n    };\n    _proto.applyPrevMaps = function applyPrevMaps() {\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.previous()), _step; !(_step = _iterator()).done;){\n            var prev = _step.value;\n            var from = this.toUrl(this.path(prev.file));\n            var root2 = prev.root || dirname$2(prev.file);\n            var map = void 0;\n            if (this.mapOpts.sourcesContent === false) {\n                map = new SourceMapConsumer$3(prev.text);\n                if (map.sourcesContent) {\n                    map.sourcesContent = null;\n                }\n            } else {\n                map = prev.consumer();\n            }\n            this.map.applySourceMap(map, from, this.toUrl(this.path(root2)));\n        }\n    };\n    _proto.clearAnnotation = function clearAnnotation() {\n        if (this.mapOpts.annotation === false) return;\n        if (this.root) {\n            var node2;\n            for(var i2 = this.root.nodes.length - 1; i2 >= 0; i2--){\n                node2 = this.root.nodes[i2];\n                if (node2.type !== \"comment\") continue;\n                if (node2.text.indexOf(\"# sourceMappingURL=\") === 0) {\n                    this.root.removeChild(i2);\n                }\n            }\n        } else if (this.css) {\n            this.css = this.css.replace(/\\n*?\\/\\*#[\\S\\s]*?\\*\\/$/gm, \"\");\n        }\n    };\n    _proto.generate = function generate() {\n        this.clearAnnotation();\n        if (pathAvailable$2 && sourceMapAvailable$2 && this.isMap()) {\n            return this.generateMap();\n        } else {\n            var result2 = \"\";\n            this.stringify(this.root, function(i2) {\n                result2 += i2;\n            });\n            return [\n                result2\n            ];\n        }\n    };\n    _proto.generateMap = function generateMap() {\n        if (this.root) {\n            this.generateString();\n        } else if (this.previous().length === 1) {\n            var prev = this.previous()[0].consumer();\n            prev.file = this.outputFile();\n            this.map = SourceMapGenerator$3.fromSourceMap(prev, {\n                ignoreInvalidMapping: true\n            });\n        } else {\n            this.map = new SourceMapGenerator$3({\n                file: this.outputFile(),\n                ignoreInvalidMapping: true\n            });\n            this.map.addMapping({\n                generated: {\n                    column: 0,\n                    line: 1\n                },\n                original: {\n                    column: 0,\n                    line: 1\n                },\n                source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : \"<no source>\"\n            });\n        }\n        if (this.isSourcesContent()) this.setSourcesContent();\n        if (this.root && this.previous().length > 0) this.applyPrevMaps();\n        if (this.isAnnotation()) this.addAnnotation();\n        if (this.isInline()) {\n            return [\n                this.css\n            ];\n        } else {\n            return [\n                this.css,\n                this.map\n            ];\n        }\n    };\n    _proto.generateString = function generateString() {\n        var _this = this;\n        this.css = \"\";\n        this.map = new SourceMapGenerator$3({\n            file: this.outputFile(),\n            ignoreInvalidMapping: true\n        });\n        var line = 1;\n        var column = 1;\n        var noSource = \"<no source>\";\n        var mapping = {\n            generated: {\n                column: 0,\n                line: 0\n            },\n            original: {\n                column: 0,\n                line: 0\n            },\n            source: \"\"\n        };\n        var lines, last;\n        this.stringify(this.root, function(str, node2, type) {\n            _this.css += str;\n            if (node2 && type !== \"end\") {\n                mapping.generated.line = line;\n                mapping.generated.column = column - 1;\n                if (node2.source && node2.source.start) {\n                    mapping.source = _this.sourcePath(node2);\n                    mapping.original.line = node2.source.start.line;\n                    mapping.original.column = node2.source.start.column - 1;\n                    _this.map.addMapping(mapping);\n                } else {\n                    mapping.source = noSource;\n                    mapping.original.line = 1;\n                    mapping.original.column = 0;\n                    _this.map.addMapping(mapping);\n                }\n            }\n            lines = str.match(/\\n/g);\n            if (lines) {\n                line += lines.length;\n                last = str.lastIndexOf(\"\\n\");\n                column = str.length - last;\n            } else {\n                column += str.length;\n            }\n            if (node2 && type !== \"start\") {\n                var p = node2.parent || {\n                    raws: {}\n                };\n                var childless = node2.type === \"decl\" || node2.type === \"atrule\" && !node2.nodes;\n                if (!childless || node2 !== p.last || p.raws.semicolon) {\n                    if (node2.source && node2.source.end) {\n                        mapping.source = _this.sourcePath(node2);\n                        mapping.original.line = node2.source.end.line;\n                        mapping.original.column = node2.source.end.column - 1;\n                        mapping.generated.line = line;\n                        mapping.generated.column = column - 2;\n                        _this.map.addMapping(mapping);\n                    } else {\n                        mapping.source = noSource;\n                        mapping.original.line = 1;\n                        mapping.original.column = 0;\n                        mapping.generated.line = line;\n                        mapping.generated.column = column - 1;\n                        _this.map.addMapping(mapping);\n                    }\n                }\n            }\n        });\n    };\n    _proto.isAnnotation = function isAnnotation() {\n        if (this.isInline()) {\n            return true;\n        }\n        if (typeof this.mapOpts.annotation !== \"undefined\") {\n            return this.mapOpts.annotation;\n        }\n        if (this.previous().length) {\n            return this.previous().some(function(i2) {\n                return i2.annotation;\n            });\n        }\n        return true;\n    };\n    _proto.isInline = function isInline() {\n        if (typeof this.mapOpts.inline !== \"undefined\") {\n            return this.mapOpts.inline;\n        }\n        var annotation = this.mapOpts.annotation;\n        if (typeof annotation !== \"undefined\" && annotation !== true) {\n            return false;\n        }\n        if (this.previous().length) {\n            return this.previous().some(function(i2) {\n                return i2.inline;\n            });\n        }\n        return true;\n    };\n    _proto.isMap = function isMap() {\n        if (typeof this.opts.map !== \"undefined\") {\n            return !!this.opts.map;\n        }\n        return this.previous().length > 0;\n    };\n    _proto.isSourcesContent = function isSourcesContent() {\n        if (typeof this.mapOpts.sourcesContent !== \"undefined\") {\n            return this.mapOpts.sourcesContent;\n        }\n        if (this.previous().length) {\n            return this.previous().some(function(i2) {\n                return i2.withContent();\n            });\n        }\n        return true;\n    };\n    _proto.outputFile = function outputFile() {\n        if (this.opts.to) {\n            return this.path(this.opts.to);\n        } else if (this.opts.from) {\n            return this.path(this.opts.from);\n        } else {\n            return \"to.css\";\n        }\n    };\n    _proto.path = function path(file) {\n        if (this.mapOpts.absolute) return file;\n        if (file.charCodeAt(0) === 60) return file;\n        if (/^\\w+:\\/\\//.test(file)) return file;\n        var cached = this.memoizedPaths.get(file);\n        if (cached) return cached;\n        var from = this.opts.to ? dirname$2(this.opts.to) : \".\";\n        if (typeof this.mapOpts.annotation === \"string\") {\n            from = dirname$2(resolve$2(from, this.mapOpts.annotation));\n        }\n        var path = relative$1(from, file);\n        this.memoizedPaths.set(file, path);\n        return path;\n    };\n    _proto.previous = function previous() {\n        var _this = this;\n        if (!this.previousMaps) {\n            this.previousMaps = [];\n            if (this.root) {\n                this.root.walk(function(node2) {\n                    if (node2.source && node2.source.input.map) {\n                        var map = node2.source.input.map;\n                        if (!_this.previousMaps.includes(map)) {\n                            _this.previousMaps.push(map);\n                        }\n                    }\n                });\n            } else {\n                var input2 = new Input$3$1(this.originalCSS, this.opts);\n                if (input2.map) this.previousMaps.push(input2.map);\n            }\n        }\n        return this.previousMaps;\n    };\n    _proto.setSourcesContent = function setSourcesContent() {\n        var _this = this;\n        var already = {};\n        if (this.root) {\n            this.root.walk(function(node2) {\n                if (node2.source) {\n                    var from = node2.source.input.from;\n                    if (from && !already[from]) {\n                        already[from] = true;\n                        var fromUrl = _this.usesFileUrls ? _this.toFileUrl(from) : _this.toUrl(_this.path(from));\n                        _this.map.setSourceContent(fromUrl, node2.source.input.css);\n                    }\n                }\n            });\n        } else if (this.css) {\n            var from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : \"<no source>\";\n            this.map.setSourceContent(from, this.css);\n        }\n    };\n    _proto.sourcePath = function sourcePath(node2) {\n        if (this.mapOpts.from) {\n            return this.toUrl(this.mapOpts.from);\n        } else if (this.usesFileUrls) {\n            return this.toFileUrl(node2.source.input.from);\n        } else {\n            return this.toUrl(this.path(node2.source.input.from));\n        }\n    };\n    _proto.toBase64 = function toBase64(str) {\n        if (Buffer) {\n            return Buffer.from(str).toString(\"base64\");\n        } else {\n            return window.btoa(unescape(encodeURIComponent(str)));\n        }\n    };\n    _proto.toFileUrl = function toFileUrl(path) {\n        var cached = this.memoizedFileURLs.get(path);\n        if (cached) return cached;\n        if (pathToFileURL$2) {\n            var fileURL = pathToFileURL$2(path).toString();\n            this.memoizedFileURLs.set(path, fileURL);\n            return fileURL;\n        } else {\n            throw new Error(\"`map.absolute` option is not available in this PostCSS build\");\n        }\n    };\n    _proto.toUrl = function toUrl(path) {\n        var cached = this.memoizedURLs.get(path);\n        if (cached) return cached;\n        if (sep$1 === \"\\\\\") {\n            path = path.replace(/\\\\/g, \"/\");\n        }\n        var url = encodeURI(path).replace(/[#?]/g, encodeURIComponent);\n        this.memoizedURLs.set(path, url);\n        return url;\n    };\n    return MapGenerator;\n}();\nvar mapGenerator$1 = MapGenerator$2$1;\nvar Node$2$1 = node$1;\nvar Comment$4$1 = /*#__PURE__*/ function(Node$2$1) {\n    _inherits(Comment, Node$2$1);\n    function Comment(defaults) {\n        var _this;\n        _this = Node$2$1.call(this, defaults) || this;\n        _this.type = \"comment\";\n        return _this;\n    }\n    return Comment;\n}(Node$2$1);\nvar comment$1 = Comment$4$1;\nComment$4$1.default = Comment$4$1;\nvar isClean$1$1 = symbols$1.isClean, my$1$1 = symbols$1.my;\nvar Declaration$3$1 = declaration$1;\nvar Comment$3$1 = comment$1;\nvar Node$1$1 = node$1;\nvar parse$4$1, Rule$4$1, AtRule$4$1, Root$6$1;\nfunction cleanSource$1(nodes) {\n    return nodes.map(function(i2) {\n        if (i2.nodes) i2.nodes = cleanSource$1(i2.nodes);\n        delete i2.source;\n        return i2;\n    });\n}\nfunction markDirtyUp$1(node2) {\n    node2[isClean$1$1] = false;\n    if (node2.proxyOf.nodes) {\n        for(var _iterator = _create_for_of_iterator_helper_loose(node2.proxyOf.nodes), _step; !(_step = _iterator()).done;){\n            var i2 = _step.value;\n            markDirtyUp$1(i2);\n        }\n    }\n}\nvar Container$7$1 = /*#__PURE__*/ function(Node$1$1) {\n    _inherits(Container, Node$1$1);\n    function Container() {\n        return Node$1$1.apply(this, arguments) || this;\n    }\n    var _proto = Container.prototype;\n    _proto.append = function append() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        for(var _iterator = _create_for_of_iterator_helper_loose(children), _step; !(_step = _iterator()).done;){\n            var child = _step.value;\n            var nodes = this.normalize(child, this.last);\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(nodes), _step1; !(_step1 = _iterator1()).done;){\n                var node2 = _step1.value;\n                this.proxyOf.nodes.push(node2);\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.cleanRaws = function cleanRaws(keepBetween) {\n        Node$1$1.prototype.cleanRaws.call(this, keepBetween);\n        if (this.nodes) {\n            for(var _iterator = _create_for_of_iterator_helper_loose(this.nodes), _step; !(_step = _iterator()).done;){\n                var node2 = _step.value;\n                node2.cleanRaws(keepBetween);\n            }\n        }\n    };\n    _proto.each = function each(callback) {\n        if (!this.proxyOf.nodes) return void 0;\n        var iterator = this.getIterator();\n        var index2, result2;\n        while(this.indexes[iterator] < this.proxyOf.nodes.length){\n            index2 = this.indexes[iterator];\n            result2 = callback(this.proxyOf.nodes[index2], index2);\n            if (result2 === false) break;\n            this.indexes[iterator] += 1;\n        }\n        delete this.indexes[iterator];\n        return result2;\n    };\n    _proto.every = function every(condition) {\n        return this.nodes.every(condition);\n    };\n    _proto.getIterator = function getIterator() {\n        if (!this.lastEach) this.lastEach = 0;\n        if (!this.indexes) this.indexes = {};\n        this.lastEach += 1;\n        var iterator = this.lastEach;\n        this.indexes[iterator] = 0;\n        return iterator;\n    };\n    _proto.getProxyProcessor = function getProxyProcessor() {\n        return {\n            get: function get(node2, prop) {\n                if (prop === \"proxyOf\") {\n                    return node2;\n                } else if (!node2[prop]) {\n                    return node2[prop];\n                } else if (prop === \"each\" || typeof prop === \"string\" && prop.startsWith(\"walk\")) {\n                    return function() {\n                        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                            args[_key] = arguments[_key];\n                        }\n                        var _node2;\n                        return (_node2 = node2)[prop].apply(_node2, [].concat(args.map(function(i2) {\n                            if (typeof i2 === \"function\") {\n                                return function(child, index2) {\n                                    return i2(child.toProxy(), index2);\n                                };\n                            } else {\n                                return i2;\n                            }\n                        })));\n                    };\n                } else if (prop === \"every\" || prop === \"some\") {\n                    return function(cb) {\n                        return node2[prop](function(child) {\n                            for(var _len = arguments.length, other = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                                other[_key - 1] = arguments[_key];\n                            }\n                            return cb.apply(void 0, [].concat([\n                                child.toProxy()\n                            ], other));\n                        });\n                    };\n                } else if (prop === \"root\") {\n                    return function() {\n                        return node2.root().toProxy();\n                    };\n                } else if (prop === \"nodes\") {\n                    return node2.nodes.map(function(i2) {\n                        return i2.toProxy();\n                    });\n                } else if (prop === \"first\" || prop === \"last\") {\n                    return node2[prop].toProxy();\n                } else {\n                    return node2[prop];\n                }\n            },\n            set: function set(node2, prop, value) {\n                if (node2[prop] === value) return true;\n                node2[prop] = value;\n                if (prop === \"name\" || prop === \"params\" || prop === \"selector\") {\n                    node2.markDirty();\n                }\n                return true;\n            }\n        };\n    };\n    _proto.index = function index(child) {\n        if (typeof child === \"number\") return child;\n        if (child.proxyOf) child = child.proxyOf;\n        return this.proxyOf.nodes.indexOf(child);\n    };\n    _proto.insertAfter = function insertAfter(exist, add) {\n        var existIndex = this.index(exist);\n        var nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();\n        existIndex = this.index(exist);\n        for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n            var node2 = _step.value;\n            this.proxyOf.nodes.splice(existIndex + 1, 0, node2);\n        }\n        var index2;\n        for(var id in this.indexes){\n            index2 = this.indexes[id];\n            if (existIndex < index2) {\n                this.indexes[id] = index2 + nodes.length;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.insertBefore = function insertBefore(exist, add) {\n        var existIndex = this.index(exist);\n        var type = existIndex === 0 ? \"prepend\" : false;\n        var nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse();\n        existIndex = this.index(exist);\n        for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n            var node2 = _step.value;\n            this.proxyOf.nodes.splice(existIndex, 0, node2);\n        }\n        var index2;\n        for(var id in this.indexes){\n            index2 = this.indexes[id];\n            if (existIndex <= index2) {\n                this.indexes[id] = index2 + nodes.length;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.normalize = function normalize(nodes, sample) {\n        var _this = this;\n        if (typeof nodes === \"string\") {\n            nodes = cleanSource$1(parse$4$1(nodes).nodes);\n        } else if (typeof nodes === \"undefined\") {\n            nodes = [];\n        } else if (Array.isArray(nodes)) {\n            nodes = nodes.slice(0);\n            for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n                var i2 = _step.value;\n                if (i2.parent) i2.parent.removeChild(i2, \"ignore\");\n            }\n        } else if (nodes.type === \"root\" && this.type !== \"document\") {\n            nodes = nodes.nodes.slice(0);\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(nodes), _step1; !(_step1 = _iterator1()).done;){\n                var i21 = _step1.value;\n                if (i21.parent) i21.parent.removeChild(i21, \"ignore\");\n            }\n        } else if (nodes.type) {\n            nodes = [\n                nodes\n            ];\n        } else if (nodes.prop) {\n            if (typeof nodes.value === \"undefined\") {\n                throw new Error(\"Value field is missed in node creation\");\n            } else if (typeof nodes.value !== \"string\") {\n                nodes.value = String(nodes.value);\n            }\n            nodes = [\n                new Declaration$3$1(nodes)\n            ];\n        } else if (nodes.selector) {\n            nodes = [\n                new Rule$4$1(nodes)\n            ];\n        } else if (nodes.name) {\n            nodes = [\n                new AtRule$4$1(nodes)\n            ];\n        } else if (nodes.text) {\n            nodes = [\n                new Comment$3$1(nodes)\n            ];\n        } else {\n            throw new Error(\"Unknown node type in node creation\");\n        }\n        var processed = nodes.map(function(i2) {\n            if (!i2[my$1$1]) Container.rebuild(i2);\n            i2 = i2.proxyOf;\n            if (i2.parent) i2.parent.removeChild(i2);\n            if (i2[isClean$1$1]) markDirtyUp$1(i2);\n            if (typeof i2.raws.before === \"undefined\") {\n                if (sample && typeof sample.raws.before !== \"undefined\") {\n                    i2.raws.before = sample.raws.before.replace(/\\S/g, \"\");\n                }\n            }\n            i2.parent = _this.proxyOf;\n            return i2;\n        });\n        return processed;\n    };\n    _proto.prepend = function prepend() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        children = children.reverse();\n        for(var _iterator = _create_for_of_iterator_helper_loose(children), _step; !(_step = _iterator()).done;){\n            var child = _step.value;\n            var nodes = this.normalize(child, this.first, \"prepend\").reverse();\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(nodes), _step1; !(_step1 = _iterator1()).done;){\n                var node2 = _step1.value;\n                this.proxyOf.nodes.unshift(node2);\n            }\n            for(var id in this.indexes){\n                this.indexes[id] = this.indexes[id] + nodes.length;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.push = function push(child) {\n        child.parent = this;\n        this.proxyOf.nodes.push(child);\n        return this;\n    };\n    _proto.removeAll = function removeAll() {\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.proxyOf.nodes), _step; !(_step = _iterator()).done;){\n            var node2 = _step.value;\n            node2.parent = void 0;\n        }\n        this.proxyOf.nodes = [];\n        this.markDirty();\n        return this;\n    };\n    _proto.removeChild = function removeChild(child) {\n        child = this.index(child);\n        this.proxyOf.nodes[child].parent = void 0;\n        this.proxyOf.nodes.splice(child, 1);\n        var index2;\n        for(var id in this.indexes){\n            index2 = this.indexes[id];\n            if (index2 >= child) {\n                this.indexes[id] = index2 - 1;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.replaceValues = function replaceValues(pattern, opts, callback) {\n        if (!callback) {\n            callback = opts;\n            opts = {};\n        }\n        this.walkDecls(function(decl) {\n            if (opts.props && !opts.props.includes(decl.prop)) return;\n            if (opts.fast && !decl.value.includes(opts.fast)) return;\n            decl.value = decl.value.replace(pattern, callback);\n        });\n        this.markDirty();\n        return this;\n    };\n    _proto.some = function some(condition) {\n        return this.nodes.some(condition);\n    };\n    _proto.walk = function walk(callback) {\n        return this.each(function(child, i2) {\n            var result2;\n            try {\n                result2 = callback(child, i2);\n            } catch (e2) {\n                throw child.addToError(e2);\n            }\n            if (result2 !== false && child.walk) {\n                result2 = child.walk(callback);\n            }\n            return result2;\n        });\n    };\n    _proto.walkAtRules = function walkAtRules(name, callback) {\n        if (!callback) {\n            callback = name;\n            return this.walk(function(child, i2) {\n                if (child.type === \"atrule\") {\n                    return callback(child, i2);\n                }\n            });\n        }\n        if (_instanceof(name, RegExp)) {\n            return this.walk(function(child, i2) {\n                if (child.type === \"atrule\" && name.test(child.name)) {\n                    return callback(child, i2);\n                }\n            });\n        }\n        return this.walk(function(child, i2) {\n            if (child.type === \"atrule\" && child.name === name) {\n                return callback(child, i2);\n            }\n        });\n    };\n    _proto.walkComments = function walkComments(callback) {\n        return this.walk(function(child, i2) {\n            if (child.type === \"comment\") {\n                return callback(child, i2);\n            }\n        });\n    };\n    _proto.walkDecls = function walkDecls(prop, callback) {\n        if (!callback) {\n            callback = prop;\n            return this.walk(function(child, i2) {\n                if (child.type === \"decl\") {\n                    return callback(child, i2);\n                }\n            });\n        }\n        if (_instanceof(prop, RegExp)) {\n            return this.walk(function(child, i2) {\n                if (child.type === \"decl\" && prop.test(child.prop)) {\n                    return callback(child, i2);\n                }\n            });\n        }\n        return this.walk(function(child, i2) {\n            if (child.type === \"decl\" && child.prop === prop) {\n                return callback(child, i2);\n            }\n        });\n    };\n    _proto.walkRules = function walkRules(selector, callback) {\n        if (!callback) {\n            callback = selector;\n            return this.walk(function(child, i2) {\n                if (child.type === \"rule\") {\n                    return callback(child, i2);\n                }\n            });\n        }\n        if (_instanceof(selector, RegExp)) {\n            return this.walk(function(child, i2) {\n                if (child.type === \"rule\" && selector.test(child.selector)) {\n                    return callback(child, i2);\n                }\n            });\n        }\n        return this.walk(function(child, i2) {\n            if (child.type === \"rule\" && child.selector === selector) {\n                return callback(child, i2);\n            }\n        });\n    };\n    _create_class(Container, [\n        {\n            key: \"first\",\n            get: function get() {\n                if (!this.proxyOf.nodes) return void 0;\n                return this.proxyOf.nodes[0];\n            }\n        },\n        {\n            key: \"last\",\n            get: function get() {\n                if (!this.proxyOf.nodes) return void 0;\n                return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];\n            }\n        }\n    ]);\n    return Container;\n}(Node$1$1);\nContainer$7$1.registerParse = function(dependant) {\n    parse$4$1 = dependant;\n};\nContainer$7$1.registerRule = function(dependant) {\n    Rule$4$1 = dependant;\n};\nContainer$7$1.registerAtRule = function(dependant) {\n    AtRule$4$1 = dependant;\n};\nContainer$7$1.registerRoot = function(dependant) {\n    Root$6$1 = dependant;\n};\nvar container$1 = Container$7$1;\nContainer$7$1.default = Container$7$1;\nContainer$7$1.rebuild = function(node2) {\n    if (node2.type === \"atrule\") {\n        Object.setPrototypeOf(node2, AtRule$4$1.prototype);\n    } else if (node2.type === \"rule\") {\n        Object.setPrototypeOf(node2, Rule$4$1.prototype);\n    } else if (node2.type === \"decl\") {\n        Object.setPrototypeOf(node2, Declaration$3$1.prototype);\n    } else if (node2.type === \"comment\") {\n        Object.setPrototypeOf(node2, Comment$3$1.prototype);\n    } else if (node2.type === \"root\") {\n        Object.setPrototypeOf(node2, Root$6$1.prototype);\n    }\n    node2[my$1$1] = true;\n    if (node2.nodes) {\n        node2.nodes.forEach(function(child) {\n            Container$7$1.rebuild(child);\n        });\n    }\n};\nvar Container$6$1 = container$1;\nvar LazyResult$4$1, Processor$3$1;\nvar Document$3$1 = /*#__PURE__*/ function(Container$6$1) {\n    _inherits(Document2, Container$6$1);\n    function Document2(defaults) {\n        var _this;\n        _this = Container$6$1.call(this, _extends({\n            type: \"document\"\n        }, defaults)) || this;\n        if (!_this.nodes) {\n            _this.nodes = [];\n        }\n        return _this;\n    }\n    var _proto = Document2.prototype;\n    _proto.toResult = function toResult(opts) {\n        if (opts === void 0) opts = {};\n        var lazy = new LazyResult$4$1(new Processor$3$1(), this, opts);\n        return lazy.stringify();\n    };\n    return Document2;\n}(Container$6$1);\nDocument$3$1.registerLazyResult = function(dependant) {\n    LazyResult$4$1 = dependant;\n};\nDocument$3$1.registerProcessor = function(dependant) {\n    Processor$3$1 = dependant;\n};\nvar document$1$1 = Document$3$1;\nDocument$3$1.default = Document$3$1;\nvar printed$1 = {};\nvar warnOnce$2$1 = function warnOnce(message) {\n    if (printed$1[message]) return;\n    printed$1[message] = true;\n    if (typeof console !== \"undefined\" && console.warn) {\n        console.warn(message);\n    }\n};\nvar Warning$2$1 = /*#__PURE__*/ function() {\n    function Warning(text, opts) {\n        if (opts === void 0) opts = {};\n        this.type = \"warning\";\n        this.text = text;\n        if (opts.node && opts.node.source) {\n            var range = opts.node.rangeBy(opts);\n            this.line = range.start.line;\n            this.column = range.start.column;\n            this.endLine = range.end.line;\n            this.endColumn = range.end.column;\n        }\n        for(var opt in opts)this[opt] = opts[opt];\n    }\n    var _proto = Warning.prototype;\n    _proto.toString = function toString() {\n        if (this.node) {\n            return this.node.error(this.text, {\n                index: this.index,\n                plugin: this.plugin,\n                word: this.word\n            }).message;\n        }\n        if (this.plugin) {\n            return this.plugin + \": \" + this.text;\n        }\n        return this.text;\n    };\n    return Warning;\n}();\nvar warning$1 = Warning$2$1;\nWarning$2$1.default = Warning$2$1;\nvar Warning$1$1 = warning$1;\nvar Result$3$1 = /*#__PURE__*/ function() {\n    function Result(processor2, root2, opts) {\n        this.processor = processor2;\n        this.messages = [];\n        this.root = root2;\n        this.opts = opts;\n        this.css = void 0;\n        this.map = void 0;\n    }\n    var _proto = Result.prototype;\n    _proto.toString = function toString() {\n        return this.css;\n    };\n    _proto.warn = function warn(text, opts) {\n        if (opts === void 0) opts = {};\n        if (!opts.plugin) {\n            if (this.lastPlugin && this.lastPlugin.postcssPlugin) {\n                opts.plugin = this.lastPlugin.postcssPlugin;\n            }\n        }\n        var warning2 = new Warning$1$1(text, opts);\n        this.messages.push(warning2);\n        return warning2;\n    };\n    _proto.warnings = function warnings() {\n        return this.messages.filter(function(i2) {\n            return i2.type === \"warning\";\n        });\n    };\n    _create_class(Result, [\n        {\n            key: \"content\",\n            get: function get() {\n                return this.css;\n            }\n        }\n    ]);\n    return Result;\n}();\nvar result$1 = Result$3$1;\nResult$3$1.default = Result$3$1;\nvar SINGLE_QUOTE$1 = \"'\".charCodeAt(0);\nvar DOUBLE_QUOTE$1 = '\"'.charCodeAt(0);\nvar BACKSLASH$1 = \"\\\\\".charCodeAt(0);\nvar SLASH$1 = \"/\".charCodeAt(0);\nvar NEWLINE$1 = \"\\n\".charCodeAt(0);\nvar SPACE$1 = \" \".charCodeAt(0);\nvar FEED$1 = \"\\f\".charCodeAt(0);\nvar TAB$1 = \"\t\".charCodeAt(0);\nvar CR$1 = \"\\r\".charCodeAt(0);\nvar OPEN_SQUARE$1 = \"[\".charCodeAt(0);\nvar CLOSE_SQUARE$1 = \"]\".charCodeAt(0);\nvar OPEN_PARENTHESES$1 = \"(\".charCodeAt(0);\nvar CLOSE_PARENTHESES$1 = \")\".charCodeAt(0);\nvar OPEN_CURLY$1 = \"{\".charCodeAt(0);\nvar CLOSE_CURLY$1 = \"}\".charCodeAt(0);\nvar SEMICOLON$1 = \";\".charCodeAt(0);\nvar ASTERISK$1 = \"*\".charCodeAt(0);\nvar COLON$1 = \":\".charCodeAt(0);\nvar AT$1 = \"@\".charCodeAt(0);\nvar RE_AT_END$1 = /[\\t\\n\\f\\r \"#'()/;[\\\\\\]{}]/g;\nvar RE_WORD_END$1 = /[\\t\\n\\f\\r !\"#'():;@[\\\\\\]{}]|\\/(?=\\*)/g;\nvar RE_BAD_BRACKET$1 = /.[\\r\\n\"'(/\\\\]/;\nvar RE_HEX_ESCAPE$1 = /[\\da-f]/i;\nvar tokenize$1 = function tokenizer(input2, options) {\n    if (options === void 0) options = {};\n    var css = input2.css.valueOf();\n    var ignore = options.ignoreErrors;\n    var code, next, quote, content, escape;\n    var escaped, escapePos, prev, n2, currentToken;\n    var length = css.length;\n    var pos = 0;\n    var buffer = [];\n    var returned = [];\n    function position() {\n        return pos;\n    }\n    function unclosed(what) {\n        throw input2.error(\"Unclosed \" + what, pos);\n    }\n    function endOfFile() {\n        return returned.length === 0 && pos >= length;\n    }\n    function nextToken(opts) {\n        if (returned.length) return returned.pop();\n        if (pos >= length) return;\n        var ignoreUnclosed = opts ? opts.ignoreUnclosed : false;\n        code = css.charCodeAt(pos);\n        switch(code){\n            case NEWLINE$1:\n            case SPACE$1:\n            case TAB$1:\n            case CR$1:\n            case FEED$1:\n                {\n                    next = pos;\n                    do {\n                        next += 1;\n                        code = css.charCodeAt(next);\n                    }while (code === SPACE$1 || code === NEWLINE$1 || code === TAB$1 || code === CR$1 || code === FEED$1);\n                    currentToken = [\n                        \"space\",\n                        css.slice(pos, next)\n                    ];\n                    pos = next - 1;\n                    break;\n                }\n            case OPEN_SQUARE$1:\n            case CLOSE_SQUARE$1:\n            case OPEN_CURLY$1:\n            case CLOSE_CURLY$1:\n            case COLON$1:\n            case SEMICOLON$1:\n            case CLOSE_PARENTHESES$1:\n                {\n                    var controlChar = String.fromCharCode(code);\n                    currentToken = [\n                        controlChar,\n                        controlChar,\n                        pos\n                    ];\n                    break;\n                }\n            case OPEN_PARENTHESES$1:\n                {\n                    prev = buffer.length ? buffer.pop()[1] : \"\";\n                    n2 = css.charCodeAt(pos + 1);\n                    if (prev === \"url\" && n2 !== SINGLE_QUOTE$1 && n2 !== DOUBLE_QUOTE$1 && n2 !== SPACE$1 && n2 !== NEWLINE$1 && n2 !== TAB$1 && n2 !== FEED$1 && n2 !== CR$1) {\n                        next = pos;\n                        do {\n                            escaped = false;\n                            next = css.indexOf(\")\", next + 1);\n                            if (next === -1) {\n                                if (ignore || ignoreUnclosed) {\n                                    next = pos;\n                                    break;\n                                } else {\n                                    unclosed(\"bracket\");\n                                }\n                            }\n                            escapePos = next;\n                            while(css.charCodeAt(escapePos - 1) === BACKSLASH$1){\n                                escapePos -= 1;\n                                escaped = !escaped;\n                            }\n                        }while (escaped);\n                        currentToken = [\n                            \"brackets\",\n                            css.slice(pos, next + 1),\n                            pos,\n                            next\n                        ];\n                        pos = next;\n                    } else {\n                        next = css.indexOf(\")\", pos + 1);\n                        content = css.slice(pos, next + 1);\n                        if (next === -1 || RE_BAD_BRACKET$1.test(content)) {\n                            currentToken = [\n                                \"(\",\n                                \"(\",\n                                pos\n                            ];\n                        } else {\n                            currentToken = [\n                                \"brackets\",\n                                content,\n                                pos,\n                                next\n                            ];\n                            pos = next;\n                        }\n                    }\n                    break;\n                }\n            case SINGLE_QUOTE$1:\n            case DOUBLE_QUOTE$1:\n                {\n                    quote = code === SINGLE_QUOTE$1 ? \"'\" : '\"';\n                    next = pos;\n                    do {\n                        escaped = false;\n                        next = css.indexOf(quote, next + 1);\n                        if (next === -1) {\n                            if (ignore || ignoreUnclosed) {\n                                next = pos + 1;\n                                break;\n                            } else {\n                                unclosed(\"string\");\n                            }\n                        }\n                        escapePos = next;\n                        while(css.charCodeAt(escapePos - 1) === BACKSLASH$1){\n                            escapePos -= 1;\n                            escaped = !escaped;\n                        }\n                    }while (escaped);\n                    currentToken = [\n                        \"string\",\n                        css.slice(pos, next + 1),\n                        pos,\n                        next\n                    ];\n                    pos = next;\n                    break;\n                }\n            case AT$1:\n                {\n                    RE_AT_END$1.lastIndex = pos + 1;\n                    RE_AT_END$1.test(css);\n                    if (RE_AT_END$1.lastIndex === 0) {\n                        next = css.length - 1;\n                    } else {\n                        next = RE_AT_END$1.lastIndex - 2;\n                    }\n                    currentToken = [\n                        \"at-word\",\n                        css.slice(pos, next + 1),\n                        pos,\n                        next\n                    ];\n                    pos = next;\n                    break;\n                }\n            case BACKSLASH$1:\n                {\n                    next = pos;\n                    escape = true;\n                    while(css.charCodeAt(next + 1) === BACKSLASH$1){\n                        next += 1;\n                        escape = !escape;\n                    }\n                    code = css.charCodeAt(next + 1);\n                    if (escape && code !== SLASH$1 && code !== SPACE$1 && code !== NEWLINE$1 && code !== TAB$1 && code !== CR$1 && code !== FEED$1) {\n                        next += 1;\n                        if (RE_HEX_ESCAPE$1.test(css.charAt(next))) {\n                            while(RE_HEX_ESCAPE$1.test(css.charAt(next + 1))){\n                                next += 1;\n                            }\n                            if (css.charCodeAt(next + 1) === SPACE$1) {\n                                next += 1;\n                            }\n                        }\n                    }\n                    currentToken = [\n                        \"word\",\n                        css.slice(pos, next + 1),\n                        pos,\n                        next\n                    ];\n                    pos = next;\n                    break;\n                }\n            default:\n                {\n                    if (code === SLASH$1 && css.charCodeAt(pos + 1) === ASTERISK$1) {\n                        next = css.indexOf(\"*/\", pos + 2) + 1;\n                        if (next === 0) {\n                            if (ignore || ignoreUnclosed) {\n                                next = css.length;\n                            } else {\n                                unclosed(\"comment\");\n                            }\n                        }\n                        currentToken = [\n                            \"comment\",\n                            css.slice(pos, next + 1),\n                            pos,\n                            next\n                        ];\n                        pos = next;\n                    } else {\n                        RE_WORD_END$1.lastIndex = pos + 1;\n                        RE_WORD_END$1.test(css);\n                        if (RE_WORD_END$1.lastIndex === 0) {\n                            next = css.length - 1;\n                        } else {\n                            next = RE_WORD_END$1.lastIndex - 2;\n                        }\n                        currentToken = [\n                            \"word\",\n                            css.slice(pos, next + 1),\n                            pos,\n                            next\n                        ];\n                        buffer.push(currentToken);\n                        pos = next;\n                    }\n                    break;\n                }\n        }\n        pos++;\n        return currentToken;\n    }\n    function back(token) {\n        returned.push(token);\n    }\n    return {\n        back: back,\n        endOfFile: endOfFile,\n        nextToken: nextToken,\n        position: position\n    };\n};\nvar Container$5$1 = container$1;\nvar AtRule$3$1 = /*#__PURE__*/ function(Container$5$1) {\n    _inherits(AtRule, Container$5$1);\n    function AtRule(defaults) {\n        var _this;\n        _this = Container$5$1.call(this, defaults) || this;\n        _this.type = \"atrule\";\n        return _this;\n    }\n    var _proto = AtRule.prototype;\n    _proto.append = function append() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        var _Container$5$1_prototype_append;\n        if (!this.proxyOf.nodes) this.nodes = [];\n        return (_Container$5$1_prototype_append = Container$5$1.prototype.append).call.apply(_Container$5$1_prototype_append, [].concat([\n            this\n        ], children));\n    };\n    _proto.prepend = function prepend() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        var _Container$5$1_prototype_prepend;\n        if (!this.proxyOf.nodes) this.nodes = [];\n        return (_Container$5$1_prototype_prepend = Container$5$1.prototype.prepend).call.apply(_Container$5$1_prototype_prepend, [].concat([\n            this\n        ], children));\n    };\n    return AtRule;\n}(Container$5$1);\nvar atRule$1 = AtRule$3$1;\nAtRule$3$1.default = AtRule$3$1;\nContainer$5$1.registerAtRule(AtRule$3$1);\nvar Container$4$1 = container$1;\nvar LazyResult$3$1, Processor$2$1;\nvar Root$5$1 = /*#__PURE__*/ function(Container$4$1) {\n    _inherits(Root, Container$4$1);\n    function Root(defaults) {\n        var _this;\n        _this = Container$4$1.call(this, defaults) || this;\n        _this.type = \"root\";\n        if (!_this.nodes) _this.nodes = [];\n        return _this;\n    }\n    var _proto = Root.prototype;\n    _proto.normalize = function normalize(child, sample, type) {\n        var nodes = Container$4$1.prototype.normalize.call(this, child);\n        if (sample) {\n            if (type === \"prepend\") {\n                if (this.nodes.length > 1) {\n                    sample.raws.before = this.nodes[1].raws.before;\n                } else {\n                    delete sample.raws.before;\n                }\n            } else if (this.first !== sample) {\n                for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n                    var node2 = _step.value;\n                    node2.raws.before = sample.raws.before;\n                }\n            }\n        }\n        return nodes;\n    };\n    _proto.removeChild = function removeChild(child, ignore) {\n        var index2 = this.index(child);\n        if (!ignore && index2 === 0 && this.nodes.length > 1) {\n            this.nodes[1].raws.before = this.nodes[index2].raws.before;\n        }\n        return Container$4$1.prototype.removeChild.call(this, child);\n    };\n    _proto.toResult = function toResult(opts) {\n        if (opts === void 0) opts = {};\n        var lazy = new LazyResult$3$1(new Processor$2$1(), this, opts);\n        return lazy.stringify();\n    };\n    return Root;\n}(Container$4$1);\nRoot$5$1.registerLazyResult = function(dependant) {\n    LazyResult$3$1 = dependant;\n};\nRoot$5$1.registerProcessor = function(dependant) {\n    Processor$2$1 = dependant;\n};\nvar root$1 = Root$5$1;\nRoot$5$1.default = Root$5$1;\nContainer$4$1.registerRoot(Root$5$1);\nvar list$2$1 = {\n    comma: function comma(string) {\n        return list$2$1.split(string, [\n            \",\"\n        ], true);\n    },\n    space: function space(string) {\n        var spaces = [\n            \" \",\n            \"\\n\",\n            \"\t\"\n        ];\n        return list$2$1.split(string, spaces);\n    },\n    split: function split(string, separators, last) {\n        var array = [];\n        var current = \"\";\n        var split = false;\n        var func = 0;\n        var inQuote = false;\n        var prevQuote = \"\";\n        var escape = false;\n        for(var _iterator = _create_for_of_iterator_helper_loose(string), _step; !(_step = _iterator()).done;){\n            var letter = _step.value;\n            if (escape) {\n                escape = false;\n            } else if (letter === \"\\\\\") {\n                escape = true;\n            } else if (inQuote) {\n                if (letter === prevQuote) {\n                    inQuote = false;\n                }\n            } else if (letter === '\"' || letter === \"'\") {\n                inQuote = true;\n                prevQuote = letter;\n            } else if (letter === \"(\") {\n                func += 1;\n            } else if (letter === \")\") {\n                if (func > 0) func -= 1;\n            } else if (func === 0) {\n                if (separators.includes(letter)) split = true;\n            }\n            if (split) {\n                if (current !== \"\") array.push(current.trim());\n                current = \"\";\n                split = false;\n            } else {\n                current += letter;\n            }\n        }\n        if (last || current !== \"\") array.push(current.trim());\n        return array;\n    }\n};\nvar list_1$1 = list$2$1;\nlist$2$1.default = list$2$1;\nvar Container$3$1 = container$1;\nvar list$1$1 = list_1$1;\nvar Rule$3$1 = /*#__PURE__*/ function(Container$3$1) {\n    _inherits(Rule, Container$3$1);\n    function Rule(defaults) {\n        var _this;\n        _this = Container$3$1.call(this, defaults) || this;\n        _this.type = \"rule\";\n        if (!_this.nodes) _this.nodes = [];\n        return _this;\n    }\n    _create_class(Rule, [\n        {\n            key: \"selectors\",\n            get: function get() {\n                return list$1$1.comma(this.selector);\n            },\n            set: function set(values) {\n                var match = this.selector ? this.selector.match(/,\\s*/) : null;\n                var sep2 = match ? match[0] : \",\" + this.raw(\"between\", \"beforeOpen\");\n                this.selector = values.join(sep2);\n            }\n        }\n    ]);\n    return Rule;\n}(Container$3$1);\nvar rule$1 = Rule$3$1;\nRule$3$1.default = Rule$3$1;\nContainer$3$1.registerRule(Rule$3$1);\nvar Declaration$2$1 = declaration$1;\nvar tokenizer2$1 = tokenize$1;\nvar Comment$2$1 = comment$1;\nvar AtRule$2$1 = atRule$1;\nvar Root$4$1 = root$1;\nvar Rule$2$1 = rule$1;\nvar SAFE_COMMENT_NEIGHBOR$1 = {\n    empty: true,\n    space: true\n};\nfunction findLastWithPosition$1(tokens) {\n    for(var i2 = tokens.length - 1; i2 >= 0; i2--){\n        var token = tokens[i2];\n        var pos = token[3] || token[2];\n        if (pos) return pos;\n    }\n}\nvar Parser$1$1 = /*#__PURE__*/ function() {\n    function Parser(input2) {\n        this.input = input2;\n        this.root = new Root$4$1();\n        this.current = this.root;\n        this.spaces = \"\";\n        this.semicolon = false;\n        this.createTokenizer();\n        this.root.source = {\n            input: input2,\n            start: {\n                column: 1,\n                line: 1,\n                offset: 0\n            }\n        };\n    }\n    var _proto = Parser.prototype;\n    _proto.atrule = function atrule(token) {\n        var node2 = new AtRule$2$1();\n        node2.name = token[1].slice(1);\n        if (node2.name === \"\") {\n            this.unnamedAtrule(node2, token);\n        }\n        this.init(node2, token[2]);\n        var type;\n        var prev;\n        var shift;\n        var last = false;\n        var open = false;\n        var params = [];\n        var brackets = [];\n        while(!this.tokenizer.endOfFile()){\n            token = this.tokenizer.nextToken();\n            type = token[0];\n            if (type === \"(\" || type === \"[\") {\n                brackets.push(type === \"(\" ? \")\" : \"]\");\n            } else if (type === \"{\" && brackets.length > 0) {\n                brackets.push(\"}\");\n            } else if (type === brackets[brackets.length - 1]) {\n                brackets.pop();\n            }\n            if (brackets.length === 0) {\n                if (type === \";\") {\n                    node2.source.end = this.getPosition(token[2]);\n                    node2.source.end.offset++;\n                    this.semicolon = true;\n                    break;\n                } else if (type === \"{\") {\n                    open = true;\n                    break;\n                } else if (type === \"}\") {\n                    if (params.length > 0) {\n                        shift = params.length - 1;\n                        prev = params[shift];\n                        while(prev && prev[0] === \"space\"){\n                            prev = params[--shift];\n                        }\n                        if (prev) {\n                            node2.source.end = this.getPosition(prev[3] || prev[2]);\n                            node2.source.end.offset++;\n                        }\n                    }\n                    this.end(token);\n                    break;\n                } else {\n                    params.push(token);\n                }\n            } else {\n                params.push(token);\n            }\n            if (this.tokenizer.endOfFile()) {\n                last = true;\n                break;\n            }\n        }\n        node2.raws.between = this.spacesAndCommentsFromEnd(params);\n        if (params.length) {\n            node2.raws.afterName = this.spacesAndCommentsFromStart(params);\n            this.raw(node2, \"params\", params);\n            if (last) {\n                token = params[params.length - 1];\n                node2.source.end = this.getPosition(token[3] || token[2]);\n                node2.source.end.offset++;\n                this.spaces = node2.raws.between;\n                node2.raws.between = \"\";\n            }\n        } else {\n            node2.raws.afterName = \"\";\n            node2.params = \"\";\n        }\n        if (open) {\n            node2.nodes = [];\n            this.current = node2;\n        }\n    };\n    _proto.checkMissedSemicolon = function checkMissedSemicolon(tokens) {\n        var colon = this.colon(tokens);\n        if (colon === false) return;\n        var founded = 0;\n        var token;\n        for(var j = colon - 1; j >= 0; j--){\n            token = tokens[j];\n            if (token[0] !== \"space\") {\n                founded += 1;\n                if (founded === 2) break;\n            }\n        }\n        throw this.input.error(\"Missed semicolon\", token[0] === \"word\" ? token[3] + 1 : token[2]);\n    };\n    _proto.colon = function colon(tokens) {\n        var brackets = 0;\n        var token, type, prev;\n        for(var _iterator = _create_for_of_iterator_helper_loose(tokens.entries()), _step; !(_step = _iterator()).done;){\n            var _step_value = _step.value, i2 = _step_value[0], element = _step_value[1];\n            token = element;\n            type = token[0];\n            if (type === \"(\") {\n                brackets += 1;\n            }\n            if (type === \")\") {\n                brackets -= 1;\n            }\n            if (brackets === 0 && type === \":\") {\n                if (!prev) {\n                    this.doubleColon(token);\n                } else if (prev[0] === \"word\" && prev[1] === \"progid\") {\n                    continue;\n                } else {\n                    return i2;\n                }\n            }\n            prev = token;\n        }\n        return false;\n    };\n    _proto.comment = function comment(token) {\n        var node2 = new Comment$2$1();\n        this.init(node2, token[2]);\n        node2.source.end = this.getPosition(token[3] || token[2]);\n        node2.source.end.offset++;\n        var text = token[1].slice(2, -2);\n        if (/^\\s*$/.test(text)) {\n            node2.text = \"\";\n            node2.raws.left = text;\n            node2.raws.right = \"\";\n        } else {\n            var match = text.match(/^(\\s*)([^]*\\S)(\\s*)$/);\n            node2.text = match[2];\n            node2.raws.left = match[1];\n            node2.raws.right = match[3];\n        }\n    };\n    _proto.createTokenizer = function createTokenizer() {\n        this.tokenizer = tokenizer2$1(this.input);\n    };\n    _proto.decl = function decl(tokens, customProperty) {\n        var node2 = new Declaration$2$1();\n        this.init(node2, tokens[0][2]);\n        var last = tokens[tokens.length - 1];\n        if (last[0] === \";\") {\n            this.semicolon = true;\n            tokens.pop();\n        }\n        node2.source.end = this.getPosition(last[3] || last[2] || findLastWithPosition$1(tokens));\n        node2.source.end.offset++;\n        while(tokens[0][0] !== \"word\"){\n            if (tokens.length === 1) this.unknownWord(tokens);\n            node2.raws.before += tokens.shift()[1];\n        }\n        node2.source.start = this.getPosition(tokens[0][2]);\n        node2.prop = \"\";\n        while(tokens.length){\n            var type = tokens[0][0];\n            if (type === \":\" || type === \"space\" || type === \"comment\") {\n                break;\n            }\n            node2.prop += tokens.shift()[1];\n        }\n        node2.raws.between = \"\";\n        var token;\n        while(tokens.length){\n            token = tokens.shift();\n            if (token[0] === \":\") {\n                node2.raws.between += token[1];\n                break;\n            } else {\n                if (token[0] === \"word\" && /\\w/.test(token[1])) {\n                    this.unknownWord([\n                        token\n                    ]);\n                }\n                node2.raws.between += token[1];\n            }\n        }\n        if (node2.prop[0] === \"_\" || node2.prop[0] === \"*\") {\n            node2.raws.before += node2.prop[0];\n            node2.prop = node2.prop.slice(1);\n        }\n        var firstSpaces = [];\n        var next;\n        while(tokens.length){\n            next = tokens[0][0];\n            if (next !== \"space\" && next !== \"comment\") break;\n            firstSpaces.push(tokens.shift());\n        }\n        this.precheckMissedSemicolon(tokens);\n        for(var i2 = tokens.length - 1; i2 >= 0; i2--){\n            token = tokens[i2];\n            if (token[1].toLowerCase() === \"!important\") {\n                node2.important = true;\n                var string = this.stringFrom(tokens, i2);\n                string = this.spacesFromEnd(tokens) + string;\n                if (string !== \" !important\") node2.raws.important = string;\n                break;\n            } else if (token[1].toLowerCase() === \"important\") {\n                var cache = tokens.slice(0);\n                var str = \"\";\n                for(var j = i2; j > 0; j--){\n                    var type1 = cache[j][0];\n                    if (str.trim().indexOf(\"!\") === 0 && type1 !== \"space\") {\n                        break;\n                    }\n                    str = cache.pop()[1] + str;\n                }\n                if (str.trim().indexOf(\"!\") === 0) {\n                    node2.important = true;\n                    node2.raws.important = str;\n                    tokens = cache;\n                }\n            }\n            if (token[0] !== \"space\" && token[0] !== \"comment\") {\n                break;\n            }\n        }\n        var hasWord = tokens.some(function(i2) {\n            return i2[0] !== \"space\" && i2[0] !== \"comment\";\n        });\n        if (hasWord) {\n            node2.raws.between += firstSpaces.map(function(i2) {\n                return i2[1];\n            }).join(\"\");\n            firstSpaces = [];\n        }\n        this.raw(node2, \"value\", firstSpaces.concat(tokens), customProperty);\n        if (node2.value.includes(\":\") && !customProperty) {\n            this.checkMissedSemicolon(tokens);\n        }\n    };\n    _proto.doubleColon = function doubleColon(token) {\n        throw this.input.error(\"Double colon\", {\n            offset: token[2]\n        }, {\n            offset: token[2] + token[1].length\n        });\n    };\n    _proto.emptyRule = function emptyRule(token) {\n        var node2 = new Rule$2$1();\n        this.init(node2, token[2]);\n        node2.selector = \"\";\n        node2.raws.between = \"\";\n        this.current = node2;\n    };\n    _proto.end = function end(token) {\n        if (this.current.nodes && this.current.nodes.length) {\n            this.current.raws.semicolon = this.semicolon;\n        }\n        this.semicolon = false;\n        this.current.raws.after = (this.current.raws.after || \"\") + this.spaces;\n        this.spaces = \"\";\n        if (this.current.parent) {\n            this.current.source.end = this.getPosition(token[2]);\n            this.current.source.end.offset++;\n            this.current = this.current.parent;\n        } else {\n            this.unexpectedClose(token);\n        }\n    };\n    _proto.endFile = function endFile() {\n        if (this.current.parent) this.unclosedBlock();\n        if (this.current.nodes && this.current.nodes.length) {\n            this.current.raws.semicolon = this.semicolon;\n        }\n        this.current.raws.after = (this.current.raws.after || \"\") + this.spaces;\n        this.root.source.end = this.getPosition(this.tokenizer.position());\n    };\n    _proto.freeSemicolon = function freeSemicolon(token) {\n        this.spaces += token[1];\n        if (this.current.nodes) {\n            var prev = this.current.nodes[this.current.nodes.length - 1];\n            if (prev && prev.type === \"rule\" && !prev.raws.ownSemicolon) {\n                prev.raws.ownSemicolon = this.spaces;\n                this.spaces = \"\";\n            }\n        }\n    };\n    // Helpers\n    _proto.getPosition = function getPosition(offset) {\n        var pos = this.input.fromOffset(offset);\n        return {\n            column: pos.col,\n            line: pos.line,\n            offset: offset\n        };\n    };\n    _proto.init = function init(node2, offset) {\n        this.current.push(node2);\n        node2.source = {\n            input: this.input,\n            start: this.getPosition(offset)\n        };\n        node2.raws.before = this.spaces;\n        this.spaces = \"\";\n        if (node2.type !== \"comment\") this.semicolon = false;\n    };\n    _proto.other = function other(start) {\n        var end = false;\n        var type = null;\n        var colon = false;\n        var bracket = null;\n        var brackets = [];\n        var customProperty = start[1].startsWith(\"--\");\n        var tokens = [];\n        var token = start;\n        while(token){\n            type = token[0];\n            tokens.push(token);\n            if (type === \"(\" || type === \"[\") {\n                if (!bracket) bracket = token;\n                brackets.push(type === \"(\" ? \")\" : \"]\");\n            } else if (customProperty && colon && type === \"{\") {\n                if (!bracket) bracket = token;\n                brackets.push(\"}\");\n            } else if (brackets.length === 0) {\n                if (type === \";\") {\n                    if (colon) {\n                        this.decl(tokens, customProperty);\n                        return;\n                    } else {\n                        break;\n                    }\n                } else if (type === \"{\") {\n                    this.rule(tokens);\n                    return;\n                } else if (type === \"}\") {\n                    this.tokenizer.back(tokens.pop());\n                    end = true;\n                    break;\n                } else if (type === \":\") {\n                    colon = true;\n                }\n            } else if (type === brackets[brackets.length - 1]) {\n                brackets.pop();\n                if (brackets.length === 0) bracket = null;\n            }\n            token = this.tokenizer.nextToken();\n        }\n        if (this.tokenizer.endOfFile()) end = true;\n        if (brackets.length > 0) this.unclosedBracket(bracket);\n        if (end && colon) {\n            if (!customProperty) {\n                while(tokens.length){\n                    token = tokens[tokens.length - 1][0];\n                    if (token !== \"space\" && token !== \"comment\") break;\n                    this.tokenizer.back(tokens.pop());\n                }\n            }\n            this.decl(tokens, customProperty);\n        } else {\n            this.unknownWord(tokens);\n        }\n    };\n    _proto.parse = function parse() {\n        var token;\n        while(!this.tokenizer.endOfFile()){\n            token = this.tokenizer.nextToken();\n            switch(token[0]){\n                case \"space\":\n                    this.spaces += token[1];\n                    break;\n                case \";\":\n                    this.freeSemicolon(token);\n                    break;\n                case \"}\":\n                    this.end(token);\n                    break;\n                case \"comment\":\n                    this.comment(token);\n                    break;\n                case \"at-word\":\n                    this.atrule(token);\n                    break;\n                case \"{\":\n                    this.emptyRule(token);\n                    break;\n                default:\n                    this.other(token);\n                    break;\n            }\n        }\n        this.endFile();\n    };\n    _proto.precheckMissedSemicolon = function precheckMissedSemicolon() {};\n    _proto.raw = function raw(node2, prop, tokens, customProperty) {\n        var token, type;\n        var length = tokens.length;\n        var value = \"\";\n        var clean = true;\n        var next, prev;\n        for(var i2 = 0; i2 < length; i2 += 1){\n            token = tokens[i2];\n            type = token[0];\n            if (type === \"space\" && i2 === length - 1 && !customProperty) {\n                clean = false;\n            } else if (type === \"comment\") {\n                prev = tokens[i2 - 1] ? tokens[i2 - 1][0] : \"empty\";\n                next = tokens[i2 + 1] ? tokens[i2 + 1][0] : \"empty\";\n                if (!SAFE_COMMENT_NEIGHBOR$1[prev] && !SAFE_COMMENT_NEIGHBOR$1[next]) {\n                    if (value.slice(-1) === \",\") {\n                        clean = false;\n                    } else {\n                        value += token[1];\n                    }\n                } else {\n                    clean = false;\n                }\n            } else {\n                value += token[1];\n            }\n        }\n        if (!clean) {\n            var raw = tokens.reduce(function(all, i2) {\n                return all + i2[1];\n            }, \"\");\n            node2.raws[prop] = {\n                raw: raw,\n                value: value\n            };\n        }\n        node2[prop] = value;\n    };\n    _proto.rule = function rule(tokens) {\n        tokens.pop();\n        var node2 = new Rule$2$1();\n        this.init(node2, tokens[0][2]);\n        node2.raws.between = this.spacesAndCommentsFromEnd(tokens);\n        this.raw(node2, \"selector\", tokens);\n        this.current = node2;\n    };\n    _proto.spacesAndCommentsFromEnd = function spacesAndCommentsFromEnd(tokens) {\n        var lastTokenType;\n        var spaces = \"\";\n        while(tokens.length){\n            lastTokenType = tokens[tokens.length - 1][0];\n            if (lastTokenType !== \"space\" && lastTokenType !== \"comment\") break;\n            spaces = tokens.pop()[1] + spaces;\n        }\n        return spaces;\n    };\n    // Errors\n    _proto.spacesAndCommentsFromStart = function spacesAndCommentsFromStart(tokens) {\n        var next;\n        var spaces = \"\";\n        while(tokens.length){\n            next = tokens[0][0];\n            if (next !== \"space\" && next !== \"comment\") break;\n            spaces += tokens.shift()[1];\n        }\n        return spaces;\n    };\n    _proto.spacesFromEnd = function spacesFromEnd(tokens) {\n        var lastTokenType;\n        var spaces = \"\";\n        while(tokens.length){\n            lastTokenType = tokens[tokens.length - 1][0];\n            if (lastTokenType !== \"space\") break;\n            spaces = tokens.pop()[1] + spaces;\n        }\n        return spaces;\n    };\n    _proto.stringFrom = function stringFrom(tokens, from) {\n        var result2 = \"\";\n        for(var i2 = from; i2 < tokens.length; i2++){\n            result2 += tokens[i2][1];\n        }\n        tokens.splice(from, tokens.length - from);\n        return result2;\n    };\n    _proto.unclosedBlock = function unclosedBlock() {\n        var pos = this.current.source.start;\n        throw this.input.error(\"Unclosed block\", pos.line, pos.column);\n    };\n    _proto.unclosedBracket = function unclosedBracket(bracket) {\n        throw this.input.error(\"Unclosed bracket\", {\n            offset: bracket[2]\n        }, {\n            offset: bracket[2] + 1\n        });\n    };\n    _proto.unexpectedClose = function unexpectedClose(token) {\n        throw this.input.error(\"Unexpected }\", {\n            offset: token[2]\n        }, {\n            offset: token[2] + 1\n        });\n    };\n    _proto.unknownWord = function unknownWord(tokens) {\n        throw this.input.error(\"Unknown word\", {\n            offset: tokens[0][2]\n        }, {\n            offset: tokens[0][2] + tokens[0][1].length\n        });\n    };\n    _proto.unnamedAtrule = function unnamedAtrule(node2, token) {\n        throw this.input.error(\"At-rule without name\", {\n            offset: token[2]\n        }, {\n            offset: token[2] + token[1].length\n        });\n    };\n    return Parser;\n}();\nvar parser$1 = Parser$1$1;\nvar Container$2$1 = container$1;\nvar Parser2$1 = parser$1;\nvar Input$2$1 = input$1;\nfunction parse$3$1(css, opts) {\n    var input2 = new Input$2$1(css, opts);\n    var parser2 = new Parser2$1(input2);\n    try {\n        parser2.parse();\n    } catch (e2) {\n        if (true) {\n            if (e2.name === \"CssSyntaxError\" && opts && opts.from) {\n                if (/\\.scss$/i.test(opts.from)) {\n                    e2.message += \"\\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser\";\n                } else if (/\\.sass/i.test(opts.from)) {\n                    e2.message += \"\\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser\";\n                } else if (/\\.less$/i.test(opts.from)) {\n                    e2.message += \"\\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser\";\n                }\n            }\n        }\n        throw e2;\n    }\n    return parser2.root;\n}\nvar parse_1$1 = parse$3$1;\nparse$3$1.default = parse$3$1;\nContainer$2$1.registerParse(parse$3$1);\nvar isClean$3 = symbols$1.isClean, my$3 = symbols$1.my;\nvar MapGenerator$1$1 = mapGenerator$1;\nvar stringify$2$1 = stringify_1$1;\nvar Container$1$1 = container$1;\nvar Document$2$1 = document$1$1;\nvar warnOnce$1$1 = warnOnce$2$1;\nvar Result$2$1 = result$1;\nvar parse$2$1 = parse_1$1;\nvar Root$3$1 = root$1;\nvar TYPE_TO_CLASS_NAME$1 = {\n    atrule: \"AtRule\",\n    comment: \"Comment\",\n    decl: \"Declaration\",\n    document: \"Document\",\n    root: \"Root\",\n    rule: \"Rule\"\n};\nvar PLUGIN_PROPS$1 = {\n    AtRule: true,\n    AtRuleExit: true,\n    Comment: true,\n    CommentExit: true,\n    Declaration: true,\n    DeclarationExit: true,\n    Document: true,\n    DocumentExit: true,\n    Once: true,\n    OnceExit: true,\n    postcssPlugin: true,\n    prepare: true,\n    Root: true,\n    RootExit: true,\n    Rule: true,\n    RuleExit: true\n};\nvar NOT_VISITORS$1 = {\n    Once: true,\n    postcssPlugin: true,\n    prepare: true\n};\nvar CHILDREN$1 = 0;\nfunction isPromise$1(obj) {\n    return (typeof obj === \"undefined\" ? \"undefined\" : _type_of(obj)) === \"object\" && typeof obj.then === \"function\";\n}\nfunction getEvents$1(node2) {\n    var key = false;\n    var type = TYPE_TO_CLASS_NAME$1[node2.type];\n    if (node2.type === \"decl\") {\n        key = node2.prop.toLowerCase();\n    } else if (node2.type === \"atrule\") {\n        key = node2.name.toLowerCase();\n    }\n    if (key && node2.append) {\n        return [\n            type,\n            type + \"-\" + key,\n            CHILDREN$1,\n            type + \"Exit\",\n            type + \"Exit-\" + key\n        ];\n    } else if (key) {\n        return [\n            type,\n            type + \"-\" + key,\n            type + \"Exit\",\n            type + \"Exit-\" + key\n        ];\n    } else if (node2.append) {\n        return [\n            type,\n            CHILDREN$1,\n            type + \"Exit\"\n        ];\n    } else {\n        return [\n            type,\n            type + \"Exit\"\n        ];\n    }\n}\nfunction toStack$1(node2) {\n    var events;\n    if (node2.type === \"document\") {\n        events = [\n            \"Document\",\n            CHILDREN$1,\n            \"DocumentExit\"\n        ];\n    } else if (node2.type === \"root\") {\n        events = [\n            \"Root\",\n            CHILDREN$1,\n            \"RootExit\"\n        ];\n    } else {\n        events = getEvents$1(node2);\n    }\n    return {\n        eventIndex: 0,\n        events: events,\n        iterator: 0,\n        node: node2,\n        visitorIndex: 0,\n        visitors: []\n    };\n}\nfunction cleanMarks$1(node2) {\n    node2[isClean$3] = false;\n    if (node2.nodes) node2.nodes.forEach(function(i2) {\n        return cleanMarks$1(i2);\n    });\n    return node2;\n}\nvar postcss$2$1 = {};\nvar LazyResult$2$1 = /*#__PURE__*/ function() {\n    function LazyResult(processor2, css, opts) {\n        var _this = this;\n        this.stringified = false;\n        this.processed = false;\n        var root2;\n        if ((typeof css === \"undefined\" ? \"undefined\" : _type_of(css)) === \"object\" && css !== null && (css.type === \"root\" || css.type === \"document\")) {\n            root2 = cleanMarks$1(css);\n        } else if (_instanceof(css, LazyResult) || _instanceof(css, Result$2$1)) {\n            root2 = cleanMarks$1(css.root);\n            if (css.map) {\n                if (typeof opts.map === \"undefined\") opts.map = {};\n                if (!opts.map.inline) opts.map.inline = false;\n                opts.map.prev = css.map;\n            }\n        } else {\n            var parser2 = parse$2$1;\n            if (opts.syntax) parser2 = opts.syntax.parse;\n            if (opts.parser) parser2 = opts.parser;\n            if (parser2.parse) parser2 = parser2.parse;\n            try {\n                root2 = parser2(css, opts);\n            } catch (error) {\n                this.processed = true;\n                this.error = error;\n            }\n            if (root2 && !root2[my$3]) {\n                Container$1$1.rebuild(root2);\n            }\n        }\n        this.result = new Result$2$1(processor2, root2, opts);\n        this.helpers = _extends({}, postcss$2$1, {\n            postcss: postcss$2$1,\n            result: this.result\n        });\n        this.plugins = this.processor.plugins.map(function(plugin22) {\n            if ((typeof plugin22 === \"undefined\" ? \"undefined\" : _type_of(plugin22)) === \"object\" && plugin22.prepare) {\n                return _extends({}, plugin22, plugin22.prepare(_this.result));\n            } else {\n                return plugin22;\n            }\n        });\n    }\n    var _proto = LazyResult.prototype;\n    _proto.async = function async() {\n        if (this.error) return Promise.reject(this.error);\n        if (this.processed) return Promise.resolve(this.result);\n        if (!this.processing) {\n            this.processing = this.runAsync();\n        }\n        return this.processing;\n    };\n    _proto.catch = function _catch(onRejected) {\n        return this.async().catch(onRejected);\n    };\n    _proto.finally = function _finally(onFinally) {\n        return this.async().then(onFinally, onFinally);\n    };\n    _proto.getAsyncError = function getAsyncError() {\n        throw new Error(\"Use process(css).then(cb) to work with async plugins\");\n    };\n    _proto.handleError = function handleError(error, node2) {\n        var plugin22 = this.result.lastPlugin;\n        try {\n            if (node2) node2.addToError(error);\n            this.error = error;\n            if (error.name === \"CssSyntaxError\" && !error.plugin) {\n                error.plugin = plugin22.postcssPlugin;\n                error.setMessage();\n            } else if (plugin22.postcssVersion) {\n                if (true) {\n                    var pluginName = plugin22.postcssPlugin;\n                    var pluginVer = plugin22.postcssVersion;\n                    var runtimeVer = this.result.processor.version;\n                    var a2 = pluginVer.split(\".\");\n                    var b = runtimeVer.split(\".\");\n                    if (a2[0] !== b[0] || parseInt(a2[1]) > parseInt(b[1])) {\n                        console.error(\"Unknown error from PostCSS plugin. Your current PostCSS version is \" + runtimeVer + \", but \" + pluginName + \" uses \" + pluginVer + \". Perhaps this is the source of the error below.\");\n                    }\n                }\n            }\n        } catch (err) {\n            if (console && console.error) console.error(err);\n        }\n        return error;\n    };\n    _proto.prepareVisitors = function prepareVisitors() {\n        var _this = this;\n        this.listeners = {};\n        var add = function(plugin22, type, cb) {\n            if (!_this.listeners[type]) _this.listeners[type] = [];\n            _this.listeners[type].push([\n                plugin22,\n                cb\n            ]);\n        };\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.plugins), _step; !(_step = _iterator()).done;){\n            var plugin22 = _step.value;\n            if ((typeof plugin22 === \"undefined\" ? \"undefined\" : _type_of(plugin22)) === \"object\") {\n                for(var event in plugin22){\n                    if (!PLUGIN_PROPS$1[event] && /^[A-Z]/.test(event)) {\n                        throw new Error(\"Unknown event \" + event + \" in \" + plugin22.postcssPlugin + \". Try to update PostCSS (\" + this.processor.version + \" now).\");\n                    }\n                    if (!NOT_VISITORS$1[event]) {\n                        if (_type_of(plugin22[event]) === \"object\") {\n                            for(var filter in plugin22[event]){\n                                if (filter === \"*\") {\n                                    add(plugin22, event, plugin22[event][filter]);\n                                } else {\n                                    add(plugin22, event + \"-\" + filter.toLowerCase(), plugin22[event][filter]);\n                                }\n                            }\n                        } else if (typeof plugin22[event] === \"function\") {\n                            add(plugin22, event, plugin22[event]);\n                        }\n                    }\n                }\n            }\n        }\n        this.hasListener = Object.keys(this.listeners).length > 0;\n    };\n    _proto.runAsync = function runAsync() {\n        var _this = this;\n        return _async_to_generator(function() {\n            var i2, plugin22, promise, error, root2, stack, promise1, e2, node2, _loop, _iterator, _step;\n            return _ts_generator(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        _this.plugin = 0;\n                        i2 = 0;\n                        _state.label = 1;\n                    case 1:\n                        if (!(i2 < _this.plugins.length)) return [\n                            3,\n                            6\n                        ];\n                        plugin22 = _this.plugins[i2];\n                        promise = _this.runOnRoot(plugin22);\n                        if (!isPromise$1(promise)) return [\n                            3,\n                            5\n                        ];\n                        _state.label = 2;\n                    case 2:\n                        _state.trys.push([\n                            2,\n                            4,\n                            ,\n                            5\n                        ]);\n                        return [\n                            4,\n                            promise\n                        ];\n                    case 3:\n                        _state.sent();\n                        return [\n                            3,\n                            5\n                        ];\n                    case 4:\n                        error = _state.sent();\n                        throw _this.handleError(error);\n                    case 5:\n                        i2++;\n                        return [\n                            3,\n                            1\n                        ];\n                    case 6:\n                        _this.prepareVisitors();\n                        if (!_this.hasListener) return [\n                            3,\n                            18\n                        ];\n                        root2 = _this.result.root;\n                        _state.label = 7;\n                    case 7:\n                        if (!!root2[isClean$3]) return [\n                            3,\n                            14\n                        ];\n                        root2[isClean$3] = true;\n                        stack = [\n                            toStack$1(root2)\n                        ];\n                        _state.label = 8;\n                    case 8:\n                        if (!(stack.length > 0)) return [\n                            3,\n                            13\n                        ];\n                        promise1 = _this.visitTick(stack);\n                        if (!isPromise$1(promise1)) return [\n                            3,\n                            12\n                        ];\n                        _state.label = 9;\n                    case 9:\n                        _state.trys.push([\n                            9,\n                            11,\n                            ,\n                            12\n                        ]);\n                        return [\n                            4,\n                            promise1\n                        ];\n                    case 10:\n                        _state.sent();\n                        return [\n                            3,\n                            12\n                        ];\n                    case 11:\n                        e2 = _state.sent();\n                        node2 = stack[stack.length - 1].node;\n                        throw _this.handleError(e2, node2);\n                    case 12:\n                        return [\n                            3,\n                            8\n                        ];\n                    case 13:\n                        return [\n                            3,\n                            7\n                        ];\n                    case 14:\n                        if (!_this.listeners.OnceExit) return [\n                            3,\n                            18\n                        ];\n                        _loop = function() {\n                            var _step_value, plugin22, visitor, roots, e2;\n                            return _ts_generator(this, function(_state) {\n                                switch(_state.label){\n                                    case 0:\n                                        _step_value = _step.value, plugin22 = _step_value[0], visitor = _step_value[1];\n                                        _this.result.lastPlugin = plugin22;\n                                        _state.label = 1;\n                                    case 1:\n                                        _state.trys.push([\n                                            1,\n                                            6,\n                                            ,\n                                            7\n                                        ]);\n                                        if (!(root2.type === \"document\")) return [\n                                            3,\n                                            3\n                                        ];\n                                        roots = root2.nodes.map(function(subRoot) {\n                                            return visitor(subRoot, _this.helpers);\n                                        });\n                                        return [\n                                            4,\n                                            Promise.all(roots)\n                                        ];\n                                    case 2:\n                                        _state.sent();\n                                        return [\n                                            3,\n                                            5\n                                        ];\n                                    case 3:\n                                        return [\n                                            4,\n                                            visitor(root2, _this.helpers)\n                                        ];\n                                    case 4:\n                                        _state.sent();\n                                        _state.label = 5;\n                                    case 5:\n                                        return [\n                                            3,\n                                            7\n                                        ];\n                                    case 6:\n                                        e2 = _state.sent();\n                                        throw _this.handleError(e2);\n                                    case 7:\n                                        return [\n                                            2\n                                        ];\n                                }\n                            });\n                        };\n                        _iterator = _create_for_of_iterator_helper_loose(_this.listeners.OnceExit);\n                        _state.label = 15;\n                    case 15:\n                        if (!!(_step = _iterator()).done) return [\n                            3,\n                            18\n                        ];\n                        return [\n                            5,\n                            _ts_values(_loop())\n                        ];\n                    case 16:\n                        _state.sent();\n                        _state.label = 17;\n                    case 17:\n                        return [\n                            3,\n                            15\n                        ];\n                    case 18:\n                        _this.processed = true;\n                        return [\n                            2,\n                            _this.stringify()\n                        ];\n                }\n            });\n        })();\n    };\n    _proto.runOnRoot = function runOnRoot(plugin22) {\n        var _this = this;\n        this.result.lastPlugin = plugin22;\n        try {\n            if ((typeof plugin22 === \"undefined\" ? \"undefined\" : _type_of(plugin22)) === \"object\" && plugin22.Once) {\n                if (this.result.root.type === \"document\") {\n                    var roots = this.result.root.nodes.map(function(root2) {\n                        return plugin22.Once(root2, _this.helpers);\n                    });\n                    if (isPromise$1(roots[0])) {\n                        return Promise.all(roots);\n                    }\n                    return roots;\n                }\n                return plugin22.Once(this.result.root, this.helpers);\n            } else if (typeof plugin22 === \"function\") {\n                return plugin22(this.result.root, this.result);\n            }\n        } catch (error) {\n            throw this.handleError(error);\n        }\n    };\n    _proto.stringify = function stringify() {\n        if (this.error) throw this.error;\n        if (this.stringified) return this.result;\n        this.stringified = true;\n        this.sync();\n        var opts = this.result.opts;\n        var str = stringify$2$1;\n        if (opts.syntax) str = opts.syntax.stringify;\n        if (opts.stringifier) str = opts.stringifier;\n        if (str.stringify) str = str.stringify;\n        var map = new MapGenerator$1$1(str, this.result.root, this.result.opts);\n        var data = map.generate();\n        this.result.css = data[0];\n        this.result.map = data[1];\n        return this.result;\n    };\n    _proto.sync = function sync() {\n        if (this.error) throw this.error;\n        if (this.processed) return this.result;\n        this.processed = true;\n        if (this.processing) {\n            throw this.getAsyncError();\n        }\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.plugins), _step; !(_step = _iterator()).done;){\n            var plugin22 = _step.value;\n            var promise = this.runOnRoot(plugin22);\n            if (isPromise$1(promise)) {\n                throw this.getAsyncError();\n            }\n        }\n        this.prepareVisitors();\n        if (this.hasListener) {\n            var root2 = this.result.root;\n            while(!root2[isClean$3]){\n                root2[isClean$3] = true;\n                this.walkSync(root2);\n            }\n            if (this.listeners.OnceExit) {\n                if (root2.type === \"document\") {\n                    for(var _iterator1 = _create_for_of_iterator_helper_loose(root2.nodes), _step1; !(_step1 = _iterator1()).done;){\n                        var subRoot = _step1.value;\n                        this.visitSync(this.listeners.OnceExit, subRoot);\n                    }\n                } else {\n                    this.visitSync(this.listeners.OnceExit, root2);\n                }\n            }\n        }\n        return this.result;\n    };\n    _proto.then = function then(onFulfilled, onRejected) {\n        if (true) {\n            if (!(\"from\" in this.opts)) {\n                warnOnce$1$1(\"Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.\");\n            }\n        }\n        return this.async().then(onFulfilled, onRejected);\n    };\n    _proto.toString = function toString() {\n        return this.css;\n    };\n    _proto.visitSync = function visitSync(visitors, node2) {\n        for(var _iterator = _create_for_of_iterator_helper_loose(visitors), _step; !(_step = _iterator()).done;){\n            var _step_value = _step.value, plugin22 = _step_value[0], visitor = _step_value[1];\n            this.result.lastPlugin = plugin22;\n            var promise = void 0;\n            try {\n                promise = visitor(node2, this.helpers);\n            } catch (e2) {\n                throw this.handleError(e2, node2.proxyOf);\n            }\n            if (node2.type !== \"root\" && node2.type !== \"document\" && !node2.parent) {\n                return true;\n            }\n            if (isPromise$1(promise)) {\n                throw this.getAsyncError();\n            }\n        }\n    };\n    _proto.visitTick = function visitTick(stack) {\n        var visit2 = stack[stack.length - 1];\n        var node2 = visit2.node, visitors = visit2.visitors;\n        if (node2.type !== \"root\" && node2.type !== \"document\" && !node2.parent) {\n            stack.pop();\n            return;\n        }\n        if (visitors.length > 0 && visit2.visitorIndex < visitors.length) {\n            var _visitors_visit2_visitorIndex = visitors[visit2.visitorIndex], plugin22 = _visitors_visit2_visitorIndex[0], visitor = _visitors_visit2_visitorIndex[1];\n            visit2.visitorIndex += 1;\n            if (visit2.visitorIndex === visitors.length) {\n                visit2.visitors = [];\n                visit2.visitorIndex = 0;\n            }\n            this.result.lastPlugin = plugin22;\n            try {\n                return visitor(node2.toProxy(), this.helpers);\n            } catch (e2) {\n                throw this.handleError(e2, node2);\n            }\n        }\n        if (visit2.iterator !== 0) {\n            var iterator = visit2.iterator;\n            var child;\n            while(child = node2.nodes[node2.indexes[iterator]]){\n                node2.indexes[iterator] += 1;\n                if (!child[isClean$3]) {\n                    child[isClean$3] = true;\n                    stack.push(toStack$1(child));\n                    return;\n                }\n            }\n            visit2.iterator = 0;\n            delete node2.indexes[iterator];\n        }\n        var events = visit2.events;\n        while(visit2.eventIndex < events.length){\n            var event = events[visit2.eventIndex];\n            visit2.eventIndex += 1;\n            if (event === CHILDREN$1) {\n                if (node2.nodes && node2.nodes.length) {\n                    node2[isClean$3] = true;\n                    visit2.iterator = node2.getIterator();\n                }\n                return;\n            } else if (this.listeners[event]) {\n                visit2.visitors = this.listeners[event];\n                return;\n            }\n        }\n        stack.pop();\n    };\n    _proto.walkSync = function walkSync(node2) {\n        var _this = this;\n        node2[isClean$3] = true;\n        var events = getEvents$1(node2);\n        for(var _iterator = _create_for_of_iterator_helper_loose(events), _step; !(_step = _iterator()).done;){\n            var event = _step.value;\n            if (event === CHILDREN$1) {\n                if (node2.nodes) {\n                    node2.each(function(child) {\n                        if (!child[isClean$3]) _this.walkSync(child);\n                    });\n                }\n            } else {\n                var visitors = this.listeners[event];\n                if (visitors) {\n                    if (this.visitSync(visitors, node2.toProxy())) return;\n                }\n            }\n        }\n    };\n    _proto.warnings = function warnings() {\n        return this.sync().warnings();\n    };\n    _create_class(LazyResult, [\n        {\n            key: \"content\",\n            get: function get() {\n                return this.stringify().content;\n            }\n        },\n        {\n            key: \"css\",\n            get: function get() {\n                return this.stringify().css;\n            }\n        },\n        {\n            key: \"map\",\n            get: function get() {\n                return this.stringify().map;\n            }\n        },\n        {\n            key: \"messages\",\n            get: function get() {\n                return this.sync().messages;\n            }\n        },\n        {\n            key: \"opts\",\n            get: function get() {\n                return this.result.opts;\n            }\n        },\n        {\n            key: \"processor\",\n            get: function get() {\n                return this.result.processor;\n            }\n        },\n        {\n            key: \"root\",\n            get: function get() {\n                return this.sync().root;\n            }\n        },\n        {\n            key: Symbol.toStringTag,\n            get: function get() {\n                return \"LazyResult\";\n            }\n        }\n    ]);\n    return LazyResult;\n}();\nLazyResult$2$1.registerPostcss = function(dependant) {\n    postcss$2$1 = dependant;\n};\nvar lazyResult$1 = LazyResult$2$1;\nLazyResult$2$1.default = LazyResult$2$1;\nRoot$3$1.registerLazyResult(LazyResult$2$1);\nDocument$2$1.registerLazyResult(LazyResult$2$1);\nvar MapGenerator2$1 = mapGenerator$1;\nvar stringify$1$1 = stringify_1$1;\nvar warnOnce2$1 = warnOnce$2$1;\nvar parse$1$1 = parse_1$1;\nvar Result$1$1 = result$1;\nvar NoWorkResult$1$1 = /*#__PURE__*/ function() {\n    function NoWorkResult(processor2, css, opts) {\n        css = css.toString();\n        this.stringified = false;\n        this._processor = processor2;\n        this._css = css;\n        this._opts = opts;\n        this._map = void 0;\n        var root2;\n        var str = stringify$1$1;\n        this.result = new Result$1$1(this._processor, root2, this._opts);\n        this.result.css = css;\n        var self = this;\n        Object.defineProperty(this.result, \"root\", {\n            get: function get() {\n                return self.root;\n            }\n        });\n        var map = new MapGenerator2$1(str, root2, this._opts, css);\n        if (map.isMap()) {\n            var _map_generate = map.generate(), generatedCSS = _map_generate[0], generatedMap = _map_generate[1];\n            if (generatedCSS) {\n                this.result.css = generatedCSS;\n            }\n            if (generatedMap) {\n                this.result.map = generatedMap;\n            }\n        } else {\n            map.clearAnnotation();\n            this.result.css = map.css;\n        }\n    }\n    var _proto = NoWorkResult.prototype;\n    _proto.async = function async() {\n        if (this.error) return Promise.reject(this.error);\n        return Promise.resolve(this.result);\n    };\n    _proto.catch = function _catch(onRejected) {\n        return this.async().catch(onRejected);\n    };\n    _proto.finally = function _finally(onFinally) {\n        return this.async().then(onFinally, onFinally);\n    };\n    _proto.sync = function sync() {\n        if (this.error) throw this.error;\n        return this.result;\n    };\n    _proto.then = function then(onFulfilled, onRejected) {\n        if (true) {\n            if (!(\"from\" in this._opts)) {\n                warnOnce2$1(\"Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.\");\n            }\n        }\n        return this.async().then(onFulfilled, onRejected);\n    };\n    _proto.toString = function toString() {\n        return this._css;\n    };\n    _proto.warnings = function warnings() {\n        return [];\n    };\n    _create_class(NoWorkResult, [\n        {\n            key: \"content\",\n            get: function get() {\n                return this.result.css;\n            }\n        },\n        {\n            key: \"css\",\n            get: function get() {\n                return this.result.css;\n            }\n        },\n        {\n            key: \"map\",\n            get: function get() {\n                return this.result.map;\n            }\n        },\n        {\n            key: \"messages\",\n            get: function get() {\n                return [];\n            }\n        },\n        {\n            key: \"opts\",\n            get: function get() {\n                return this.result.opts;\n            }\n        },\n        {\n            key: \"processor\",\n            get: function get() {\n                return this.result.processor;\n            }\n        },\n        {\n            key: \"root\",\n            get: function get() {\n                if (this._root) {\n                    return this._root;\n                }\n                var root2;\n                var parser2 = parse$1$1;\n                try {\n                    root2 = parser2(this._css, this._opts);\n                } catch (error) {\n                    this.error = error;\n                }\n                if (this.error) {\n                    throw this.error;\n                } else {\n                    this._root = root2;\n                    return root2;\n                }\n            }\n        },\n        {\n            key: Symbol.toStringTag,\n            get: function get() {\n                return \"NoWorkResult\";\n            }\n        }\n    ]);\n    return NoWorkResult;\n}();\nvar noWorkResult$1 = NoWorkResult$1$1;\nNoWorkResult$1$1.default = NoWorkResult$1$1;\nvar NoWorkResult2$1 = noWorkResult$1;\nvar LazyResult$1$1 = lazyResult$1;\nvar Document$1$1 = document$1$1;\nvar Root$2$1 = root$1;\nvar Processor$1$1 = /*#__PURE__*/ function() {\n    function Processor(plugins) {\n        if (plugins === void 0) plugins = [];\n        this.version = \"8.4.38\";\n        this.plugins = this.normalize(plugins);\n    }\n    var _proto = Processor.prototype;\n    _proto.normalize = function normalize(plugins) {\n        var normalized = [];\n        for(var _iterator = _create_for_of_iterator_helper_loose(plugins), _step; !(_step = _iterator()).done;){\n            var i2 = _step.value;\n            if (i2.postcss === true) {\n                i2 = i2();\n            } else if (i2.postcss) {\n                i2 = i2.postcss;\n            }\n            if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && Array.isArray(i2.plugins)) {\n                normalized = normalized.concat(i2.plugins);\n            } else if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && i2.postcssPlugin) {\n                normalized.push(i2);\n            } else if (typeof i2 === \"function\") {\n                normalized.push(i2);\n            } else if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && (i2.parse || i2.stringify)) {\n                if (true) {\n                    throw new Error(\"PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation.\");\n                }\n            } else {\n                throw new Error(i2 + \" is not a PostCSS plugin\");\n            }\n        }\n        return normalized;\n    };\n    _proto.process = function process1(css, opts) {\n        if (opts === void 0) opts = {};\n        if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) {\n            return new NoWorkResult2$1(this, css, opts);\n        } else {\n            return new LazyResult$1$1(this, css, opts);\n        }\n    };\n    _proto.use = function use(plugin22) {\n        this.plugins = this.plugins.concat(this.normalize([\n            plugin22\n        ]));\n        return this;\n    };\n    return Processor;\n}();\nvar processor$1 = Processor$1$1;\nProcessor$1$1.default = Processor$1$1;\nRoot$2$1.registerProcessor(Processor$1$1);\nDocument$1$1.registerProcessor(Processor$1$1);\nvar Declaration$1$1 = declaration$1;\nvar PreviousMap2$1 = previousMap$1;\nvar Comment$1$1 = comment$1;\nvar AtRule$1$1 = atRule$1;\nvar Input$1$1 = input$1;\nvar Root$1$1 = root$1;\nvar Rule$1$1 = rule$1;\nfunction fromJSON$1$1(json, inputs) {\n    if (Array.isArray(json)) return json.map(function(n2) {\n        return fromJSON$1$1(n2);\n    });\n    var ownInputs = json.inputs, defaults = _object_without_properties_loose(json, [\n        \"inputs\"\n    ]);\n    if (ownInputs) {\n        inputs = [];\n        for(var _iterator = _create_for_of_iterator_helper_loose(ownInputs), _step; !(_step = _iterator()).done;){\n            var input2 = _step.value;\n            var inputHydrated = _extends({}, input2, {\n                __proto__: Input$1$1.prototype\n            });\n            if (inputHydrated.map) {\n                inputHydrated.map = _extends({}, inputHydrated.map, {\n                    __proto__: PreviousMap2$1.prototype\n                });\n            }\n            inputs.push(inputHydrated);\n        }\n    }\n    if (defaults.nodes) {\n        defaults.nodes = json.nodes.map(function(n2) {\n            return fromJSON$1$1(n2, inputs);\n        });\n    }\n    if (defaults.source) {\n        var _defaults_source = defaults.source, inputId = _defaults_source.inputId, source = _object_without_properties_loose(_defaults_source, [\n            \"inputId\"\n        ]);\n        defaults.source = source;\n        if (inputId != null) {\n            defaults.source.input = inputs[inputId];\n        }\n    }\n    if (defaults.type === \"root\") {\n        return new Root$1$1(defaults);\n    } else if (defaults.type === \"decl\") {\n        return new Declaration$1$1(defaults);\n    } else if (defaults.type === \"rule\") {\n        return new Rule$1$1(defaults);\n    } else if (defaults.type === \"comment\") {\n        return new Comment$1$1(defaults);\n    } else if (defaults.type === \"atrule\") {\n        return new AtRule$1$1(defaults);\n    } else {\n        throw new Error(\"Unknown node type: \" + json.type);\n    }\n}\nvar fromJSON_1$1 = fromJSON$1$1;\nfromJSON$1$1.default = fromJSON$1$1;\nvar CssSyntaxError2$1 = cssSyntaxError$1;\nvar Declaration2$1 = declaration$1;\nvar LazyResult2$1 = lazyResult$1;\nvar Container2$1 = container$1;\nvar Processor2$1 = processor$1;\nvar stringify$5 = stringify_1$1;\nvar fromJSON$2 = fromJSON_1$1;\nvar Document22 = document$1$1;\nvar Warning2$1 = warning$1;\nvar Comment2$1 = comment$1;\nvar AtRule2$1 = atRule$1;\nvar Result2$1 = result$1;\nvar Input2$1 = input$1;\nvar parse$5 = parse_1$1;\nvar list$3 = list_1$1;\nvar Rule2$1 = rule$1;\nvar Root2$1 = root$1;\nvar Node2$1 = node$1;\nfunction postcss$3() {\n    for(var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++){\n        plugins[_key] = arguments[_key];\n    }\n    if (plugins.length === 1 && Array.isArray(plugins[0])) {\n        plugins = plugins[0];\n    }\n    return new Processor2$1(plugins);\n}\npostcss$3.plugin = function plugin(name, initializer) {\n    var warningPrinted = false;\n    function creator() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (console && console.warn && !warningPrinted) {\n            warningPrinted = true;\n            console.warn(name + \": postcss.plugin was deprecated. Migration guide:\\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration\");\n            if (process.env.LANG && process.env.LANG.startsWith(\"cn\")) {\n                console.warn(name + \":  postcss.plugin . :\\nhttps://www.w3ctech.com/topic/2226\");\n            }\n        }\n        var transformer = initializer.apply(void 0, [].concat(args));\n        transformer.postcssPlugin = name;\n        transformer.postcssVersion = new Processor2$1().version;\n        return transformer;\n    }\n    var cache;\n    Object.defineProperty(creator, \"postcss\", {\n        get: function get() {\n            if (!cache) cache = creator();\n            return cache;\n        }\n    });\n    creator.process = function(css, processOpts, pluginOpts) {\n        return postcss$3([\n            creator(pluginOpts)\n        ]).process(css, processOpts);\n    };\n    return creator;\n};\npostcss$3.stringify = stringify$5;\npostcss$3.parse = parse$5;\npostcss$3.fromJSON = fromJSON$2;\npostcss$3.list = list$3;\npostcss$3.comment = function(defaults) {\n    return new Comment2$1(defaults);\n};\npostcss$3.atRule = function(defaults) {\n    return new AtRule2$1(defaults);\n};\npostcss$3.decl = function(defaults) {\n    return new Declaration2$1(defaults);\n};\npostcss$3.rule = function(defaults) {\n    return new Rule2$1(defaults);\n};\npostcss$3.root = function(defaults) {\n    return new Root2$1(defaults);\n};\npostcss$3.document = function(defaults) {\n    return new Document22(defaults);\n};\npostcss$3.CssSyntaxError = CssSyntaxError2$1;\npostcss$3.Declaration = Declaration2$1;\npostcss$3.Container = Container2$1;\npostcss$3.Processor = Processor2$1;\npostcss$3.Document = Document22;\npostcss$3.Comment = Comment2$1;\npostcss$3.Warning = Warning2$1;\npostcss$3.AtRule = AtRule2$1;\npostcss$3.Result = Result2$1;\npostcss$3.Input = Input2$1;\npostcss$3.Rule = Rule2$1;\npostcss$3.Root = Root2$1;\npostcss$3.Node = Node2$1;\nLazyResult2$1.registerPostcss(postcss$3);\nvar postcss_1$1 = postcss$3;\npostcss$3.default = postcss$3;\nvar postcss$1$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(postcss_1$1);\npostcss$1$1.stringify;\npostcss$1$1.fromJSON;\npostcss$1$1.plugin;\npostcss$1$1.parse;\npostcss$1$1.list;\npostcss$1$1.document;\npostcss$1$1.comment;\npostcss$1$1.atRule;\npostcss$1$1.rule;\npostcss$1$1.decl;\npostcss$1$1.root;\npostcss$1$1.CssSyntaxError;\npostcss$1$1.Declaration;\npostcss$1$1.Container;\npostcss$1$1.Processor;\npostcss$1$1.Document;\npostcss$1$1.Comment;\npostcss$1$1.Warning;\npostcss$1$1.AtRule;\npostcss$1$1.Result;\npostcss$1$1.Input;\npostcss$1$1.Rule;\npostcss$1$1.Root;\npostcss$1$1.Node;\nvar __defProp2 = Object.defineProperty;\nvar __defNormalProp2 = function(obj, key, value) {\n    return key in obj ? __defProp2(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: value\n    }) : obj[key] = value;\n};\nvar __publicField2 = function(obj, key, value) {\n    return __defNormalProp2(obj, (typeof key === \"undefined\" ? \"undefined\" : _type_of(key)) !== \"symbol\" ? key + \"\" : key, value);\n};\nfunction getDefaultExportFromCjs(x2) {\n    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, \"default\") ? x2[\"default\"] : x2;\n}\nfunction getAugmentedNamespace(n2) {\n    if (n2.__esModule) return n2;\n    var f2 = n2.default;\n    if (typeof f2 == \"function\") {\n        var a2 = function a22() {\n            if (_instanceof(this, a22)) {\n                return Reflect.construct(f2, arguments, this.constructor);\n            }\n            return f2.apply(this, arguments);\n        };\n        a2.prototype = f2.prototype;\n    } else a2 = {};\n    Object.defineProperty(a2, \"__esModule\", {\n        value: true\n    });\n    Object.keys(n2).forEach(function(k) {\n        var d = Object.getOwnPropertyDescriptor(n2, k);\n        Object.defineProperty(a2, k, d.get ? d : {\n            enumerable: true,\n            get: function get() {\n                return n2[k];\n            }\n        });\n    });\n    return a2;\n}\nvar picocolors_browser = {\n    exports: {}\n};\nvar x = String;\nvar create = function create() {\n    return {\n        isColorSupported: false,\n        reset: x,\n        bold: x,\n        dim: x,\n        italic: x,\n        underline: x,\n        inverse: x,\n        hidden: x,\n        strikethrough: x,\n        black: x,\n        red: x,\n        green: x,\n        yellow: x,\n        blue: x,\n        magenta: x,\n        cyan: x,\n        white: x,\n        gray: x,\n        bgBlack: x,\n        bgRed: x,\n        bgGreen: x,\n        bgYellow: x,\n        bgBlue: x,\n        bgMagenta: x,\n        bgCyan: x,\n        bgWhite: x\n    };\n};\npicocolors_browser.exports = create();\npicocolors_browser.exports.createColors = create;\nvar picocolors_browserExports = picocolors_browser.exports;\nvar __viteBrowserExternal = {};\nvar __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n    __proto__: null,\n    default: __viteBrowserExternal\n}, Symbol.toStringTag, {\n    value: \"Module\"\n}));\nvar require$$2 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);\nvar pico = picocolors_browserExports;\nvar terminalHighlight$1 = require$$2;\nvar CssSyntaxError$3 = /*#__PURE__*/ function(Error1) {\n    _inherits(CssSyntaxError2, Error1);\n    function CssSyntaxError2(message, line, column, source, file, plugin22) {\n        var _this;\n        _this = Error1.call(this, message) || this;\n        _this.name = \"CssSyntaxError\";\n        _this.reason = message;\n        if (file) {\n            _this.file = file;\n        }\n        if (source) {\n            _this.source = source;\n        }\n        if (plugin22) {\n            _this.plugin = plugin22;\n        }\n        if (typeof line !== \"undefined\" && typeof column !== \"undefined\") {\n            if (typeof line === \"number\") {\n                _this.line = line;\n                _this.column = column;\n            } else {\n                _this.line = line.line;\n                _this.column = line.column;\n                _this.endLine = column.line;\n                _this.endColumn = column.column;\n            }\n        }\n        _this.setMessage();\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(_this, CssSyntaxError2);\n        }\n        return _this;\n    }\n    var _proto = CssSyntaxError2.prototype;\n    _proto.setMessage = function setMessage() {\n        this.message = this.plugin ? this.plugin + \": \" : \"\";\n        this.message += this.file ? this.file : \"<css input>\";\n        if (typeof this.line !== \"undefined\") {\n            this.message += \":\" + this.line + \":\" + this.column;\n        }\n        this.message += \": \" + this.reason;\n    };\n    _proto.showSourceCode = function showSourceCode(color) {\n        var _this = this;\n        if (!this.source) return \"\";\n        var css = this.source;\n        if (color == null) color = pico.isColorSupported;\n        if (terminalHighlight$1) {\n            if (color) css = terminalHighlight$1(css);\n        }\n        var lines = css.split(/\\r?\\n/);\n        var start = Math.max(this.line - 3, 0);\n        var end = Math.min(this.line + 2, lines.length);\n        var maxWidth = String(end).length;\n        var mark, aside;\n        if (color) {\n            var _pico_createColors = pico.createColors(true), bold = _pico_createColors.bold, gray = _pico_createColors.gray, red = _pico_createColors.red;\n            mark = function(text) {\n                return bold(red(text));\n            };\n            aside = function(text) {\n                return gray(text);\n            };\n        } else {\n            mark = aside = function(str) {\n                return str;\n            };\n        }\n        return lines.slice(start, end).map(function(line, index2) {\n            var number = start + 1 + index2;\n            var gutter = \" \" + (\" \" + number).slice(-maxWidth) + \" | \";\n            if (number === _this.line) {\n                var spacing = aside(gutter.replace(/\\d/g, \" \")) + line.slice(0, _this.column - 1).replace(/[^\\t]/g, \" \");\n                return mark(\">\") + aside(gutter) + line + \"\\n \" + spacing + mark(\"^\");\n            }\n            return \" \" + aside(gutter) + line;\n        }).join(\"\\n\");\n    };\n    _proto.toString = function toString() {\n        var code = this.showSourceCode();\n        if (code) {\n            code = \"\\n\\n\" + code + \"\\n\";\n        }\n        return this.name + \": \" + this.message + code;\n    };\n    return CssSyntaxError2;\n}(_wrap_native_super(Error));\nvar cssSyntaxError = CssSyntaxError$3;\nCssSyntaxError$3.default = CssSyntaxError$3;\nvar symbols = {};\nsymbols.isClean = Symbol(\"isClean\");\nsymbols.my = Symbol(\"my\");\nvar DEFAULT_RAW = {\n    after: \"\\n\",\n    beforeClose: \"\\n\",\n    beforeComment: \"\\n\",\n    beforeDecl: \"\\n\",\n    beforeOpen: \" \",\n    beforeRule: \"\\n\",\n    colon: \": \",\n    commentLeft: \" \",\n    commentRight: \" \",\n    emptyBody: \"\",\n    indent: \"    \",\n    semicolon: false\n};\nfunction capitalize(str) {\n    return str[0].toUpperCase() + str.slice(1);\n}\nvar Stringifier$2 = /*#__PURE__*/ function() {\n    function Stringifier2(builder) {\n        this.builder = builder;\n    }\n    var _proto = Stringifier2.prototype;\n    _proto.atrule = function atrule(node2, semicolon) {\n        var name = \"@\" + node2.name;\n        var params = node2.params ? this.rawValue(node2, \"params\") : \"\";\n        if (typeof node2.raws.afterName !== \"undefined\") {\n            name += node2.raws.afterName;\n        } else if (params) {\n            name += \" \";\n        }\n        if (node2.nodes) {\n            this.block(node2, name + params);\n        } else {\n            var end = (node2.raws.between || \"\") + (semicolon ? \";\" : \"\");\n            this.builder(name + params + end, node2);\n        }\n    };\n    _proto.beforeAfter = function beforeAfter(node2, detect) {\n        var value;\n        if (node2.type === \"decl\") {\n            value = this.raw(node2, null, \"beforeDecl\");\n        } else if (node2.type === \"comment\") {\n            value = this.raw(node2, null, \"beforeComment\");\n        } else if (detect === \"before\") {\n            value = this.raw(node2, null, \"beforeRule\");\n        } else {\n            value = this.raw(node2, null, \"beforeClose\");\n        }\n        var buf = node2.parent;\n        var depth = 0;\n        while(buf && buf.type !== \"root\"){\n            depth += 1;\n            buf = buf.parent;\n        }\n        if (value.includes(\"\\n\")) {\n            var indent = this.raw(node2, null, \"indent\");\n            if (indent.length) {\n                for(var step = 0; step < depth; step++)value += indent;\n            }\n        }\n        return value;\n    };\n    _proto.block = function block(node2, start) {\n        var between = this.raw(node2, \"between\", \"beforeOpen\");\n        this.builder(start + between + \"{\", node2, \"start\");\n        var after;\n        if (node2.nodes && node2.nodes.length) {\n            this.body(node2);\n            after = this.raw(node2, \"after\");\n        } else {\n            after = this.raw(node2, \"after\", \"emptyBody\");\n        }\n        if (after) this.builder(after);\n        this.builder(\"}\", node2, \"end\");\n    };\n    _proto.body = function body(node2) {\n        var last = node2.nodes.length - 1;\n        while(last > 0){\n            if (node2.nodes[last].type !== \"comment\") break;\n            last -= 1;\n        }\n        var semicolon = this.raw(node2, \"semicolon\");\n        for(var i2 = 0; i2 < node2.nodes.length; i2++){\n            var child = node2.nodes[i2];\n            var before = this.raw(child, \"before\");\n            if (before) this.builder(before);\n            this.stringify(child, last !== i2 || semicolon);\n        }\n    };\n    _proto.comment = function comment(node2) {\n        var left = this.raw(node2, \"left\", \"commentLeft\");\n        var right = this.raw(node2, \"right\", \"commentRight\");\n        this.builder(\"/*\" + left + node2.text + right + \"*/\", node2);\n    };\n    _proto.decl = function decl(node2, semicolon) {\n        var between = this.raw(node2, \"between\", \"colon\");\n        var string = node2.prop + between + this.rawValue(node2, \"value\");\n        if (node2.important) {\n            string += node2.raws.important || \" !important\";\n        }\n        if (semicolon) string += \";\";\n        this.builder(string, node2);\n    };\n    _proto.document = function document1(node2) {\n        this.body(node2);\n    };\n    _proto.raw = function raw(node2, own, detect) {\n        var value;\n        if (!detect) detect = own;\n        if (own) {\n            value = node2.raws[own];\n            if (typeof value !== \"undefined\") return value;\n        }\n        var parent = node2.parent;\n        if (detect === \"before\") {\n            if (!parent || parent.type === \"root\" && parent.first === node2) {\n                return \"\";\n            }\n            if (parent && parent.type === \"document\") {\n                return \"\";\n            }\n        }\n        if (!parent) return DEFAULT_RAW[detect];\n        var root2 = node2.root();\n        if (!root2.rawCache) root2.rawCache = {};\n        if (typeof root2.rawCache[detect] !== \"undefined\") {\n            return root2.rawCache[detect];\n        }\n        if (detect === \"before\" || detect === \"after\") {\n            return this.beforeAfter(node2, detect);\n        } else {\n            var method = \"raw\" + capitalize(detect);\n            if (this[method]) {\n                value = this[method](root2, node2);\n            } else {\n                root2.walk(function(i2) {\n                    value = i2.raws[own];\n                    if (typeof value !== \"undefined\") return false;\n                });\n            }\n        }\n        if (typeof value === \"undefined\") value = DEFAULT_RAW[detect];\n        root2.rawCache[detect] = value;\n        return value;\n    };\n    _proto.rawBeforeClose = function rawBeforeClose(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && i2.nodes.length > 0) {\n                if (typeof i2.raws.after !== \"undefined\") {\n                    value = i2.raws.after;\n                    if (value.includes(\"\\n\")) {\n                        value = value.replace(/[^\\n]+$/, \"\");\n                    }\n                    return false;\n                }\n            }\n        });\n        if (value) value = value.replace(/\\S/g, \"\");\n        return value;\n    };\n    _proto.rawBeforeComment = function rawBeforeComment(root2, node2) {\n        var value;\n        root2.walkComments(function(i2) {\n            if (typeof i2.raws.before !== \"undefined\") {\n                value = i2.raws.before;\n                if (value.includes(\"\\n\")) {\n                    value = value.replace(/[^\\n]+$/, \"\");\n                }\n                return false;\n            }\n        });\n        if (typeof value === \"undefined\") {\n            value = this.raw(node2, null, \"beforeDecl\");\n        } else if (value) {\n            value = value.replace(/\\S/g, \"\");\n        }\n        return value;\n    };\n    _proto.rawBeforeDecl = function rawBeforeDecl(root2, node2) {\n        var value;\n        root2.walkDecls(function(i2) {\n            if (typeof i2.raws.before !== \"undefined\") {\n                value = i2.raws.before;\n                if (value.includes(\"\\n\")) {\n                    value = value.replace(/[^\\n]+$/, \"\");\n                }\n                return false;\n            }\n        });\n        if (typeof value === \"undefined\") {\n            value = this.raw(node2, null, \"beforeRule\");\n        } else if (value) {\n            value = value.replace(/\\S/g, \"\");\n        }\n        return value;\n    };\n    _proto.rawBeforeOpen = function rawBeforeOpen(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.type !== \"decl\") {\n                value = i2.raws.between;\n                if (typeof value !== \"undefined\") return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawBeforeRule = function rawBeforeRule(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && (i2.parent !== root2 || root2.first !== i2)) {\n                if (typeof i2.raws.before !== \"undefined\") {\n                    value = i2.raws.before;\n                    if (value.includes(\"\\n\")) {\n                        value = value.replace(/[^\\n]+$/, \"\");\n                    }\n                    return false;\n                }\n            }\n        });\n        if (value) value = value.replace(/\\S/g, \"\");\n        return value;\n    };\n    _proto.rawColon = function rawColon(root2) {\n        var value;\n        root2.walkDecls(function(i2) {\n            if (typeof i2.raws.between !== \"undefined\") {\n                value = i2.raws.between.replace(/[^\\s:]/g, \"\");\n                return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawEmptyBody = function rawEmptyBody(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && i2.nodes.length === 0) {\n                value = i2.raws.after;\n                if (typeof value !== \"undefined\") return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawIndent = function rawIndent(root2) {\n        if (root2.raws.indent) return root2.raws.indent;\n        var value;\n        root2.walk(function(i2) {\n            var p = i2.parent;\n            if (p && p !== root2 && p.parent && p.parent === root2) {\n                if (typeof i2.raws.before !== \"undefined\") {\n                    var parts = i2.raws.before.split(\"\\n\");\n                    value = parts[parts.length - 1];\n                    value = value.replace(/\\S/g, \"\");\n                    return false;\n                }\n            }\n        });\n        return value;\n    };\n    _proto.rawSemicolon = function rawSemicolon(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && i2.nodes.length && i2.last.type === \"decl\") {\n                value = i2.raws.semicolon;\n                if (typeof value !== \"undefined\") return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawValue = function rawValue(node2, prop) {\n        var value = node2[prop];\n        var raw = node2.raws[prop];\n        if (raw && raw.value === value) {\n            return raw.raw;\n        }\n        return value;\n    };\n    _proto.root = function root(node2) {\n        this.body(node2);\n        if (node2.raws.after) this.builder(node2.raws.after);\n    };\n    _proto.rule = function rule(node2) {\n        this.block(node2, this.rawValue(node2, \"selector\"));\n        if (node2.raws.ownSemicolon) {\n            this.builder(node2.raws.ownSemicolon, node2, \"end\");\n        }\n    };\n    _proto.stringify = function stringify(node2, semicolon) {\n        if (!this[node2.type]) {\n            throw new Error(\"Unknown AST node type \" + node2.type + \". Maybe you need to change PostCSS stringifier.\");\n        }\n        this[node2.type](node2, semicolon);\n    };\n    return Stringifier2;\n}();\nvar stringifier = Stringifier$2;\nStringifier$2.default = Stringifier$2;\nvar Stringifier$1 = stringifier;\nfunction stringify$4(node2, builder) {\n    var str = new Stringifier$1(builder);\n    str.stringify(node2);\n}\nvar stringify_1 = stringify$4;\nstringify$4.default = stringify$4;\nvar isClean$2 = symbols.isClean, my$2 = symbols.my;\nvar CssSyntaxError$2 = cssSyntaxError;\nvar Stringifier22 = stringifier;\nvar stringify$3 = stringify_1;\nfunction cloneNode(obj, parent) {\n    var cloned = new obj.constructor();\n    for(var i2 in obj){\n        if (!Object.prototype.hasOwnProperty.call(obj, i2)) {\n            continue;\n        }\n        if (i2 === \"proxyCache\") continue;\n        var value = obj[i2];\n        var type = typeof value === \"undefined\" ? \"undefined\" : _type_of(value);\n        if (i2 === \"parent\" && type === \"object\") {\n            if (parent) cloned[i2] = parent;\n        } else if (i2 === \"source\") {\n            cloned[i2] = value;\n        } else if (Array.isArray(value)) {\n            cloned[i2] = value.map(function(j) {\n                return cloneNode(j, cloned);\n            });\n        } else {\n            if (type === \"object\" && value !== null) value = cloneNode(value);\n            cloned[i2] = value;\n        }\n    }\n    return cloned;\n}\nvar Node$4 = /*#__PURE__*/ function() {\n    function Node3(defaults) {\n        if (defaults === void 0) defaults = {};\n        this.raws = {};\n        this[isClean$2] = false;\n        this[my$2] = true;\n        for(var name in defaults){\n            if (name === \"nodes\") {\n                this.nodes = [];\n                for(var _iterator = _create_for_of_iterator_helper_loose(defaults[name]), _step; !(_step = _iterator()).done;){\n                    var node2 = _step.value;\n                    if (typeof node2.clone === \"function\") {\n                        this.append(node2.clone());\n                    } else {\n                        this.append(node2);\n                    }\n                }\n            } else {\n                this[name] = defaults[name];\n            }\n        }\n    }\n    var _proto = Node3.prototype;\n    _proto.addToError = function addToError(error) {\n        error.postcssNode = this;\n        if (error.stack && this.source && /\\n\\s{4}at /.test(error.stack)) {\n            var s2 = this.source;\n            error.stack = error.stack.replace(/\\n\\s{4}at /, \"$&\" + s2.input.from + \":\" + s2.start.line + \":\" + s2.start.column + \"$&\");\n        }\n        return error;\n    };\n    _proto.after = function after(add) {\n        this.parent.insertAfter(this, add);\n        return this;\n    };\n    _proto.assign = function assign(overrides) {\n        if (overrides === void 0) overrides = {};\n        for(var name in overrides){\n            this[name] = overrides[name];\n        }\n        return this;\n    };\n    _proto.before = function before(add) {\n        this.parent.insertBefore(this, add);\n        return this;\n    };\n    _proto.cleanRaws = function cleanRaws(keepBetween) {\n        delete this.raws.before;\n        delete this.raws.after;\n        if (!keepBetween) delete this.raws.between;\n    };\n    _proto.clone = function clone(overrides) {\n        if (overrides === void 0) overrides = {};\n        var cloned = cloneNode(this);\n        for(var name in overrides){\n            cloned[name] = overrides[name];\n        }\n        return cloned;\n    };\n    _proto.cloneAfter = function cloneAfter(overrides) {\n        if (overrides === void 0) overrides = {};\n        var cloned = this.clone(overrides);\n        this.parent.insertAfter(this, cloned);\n        return cloned;\n    };\n    _proto.cloneBefore = function cloneBefore(overrides) {\n        if (overrides === void 0) overrides = {};\n        var cloned = this.clone(overrides);\n        this.parent.insertBefore(this, cloned);\n        return cloned;\n    };\n    _proto.error = function error(message, opts) {\n        if (opts === void 0) opts = {};\n        if (this.source) {\n            var _this_rangeBy = this.rangeBy(opts), end = _this_rangeBy.end, start = _this_rangeBy.start;\n            return this.source.input.error(message, {\n                column: start.column,\n                line: start.line\n            }, {\n                column: end.column,\n                line: end.line\n            }, opts);\n        }\n        return new CssSyntaxError$2(message);\n    };\n    _proto.getProxyProcessor = function getProxyProcessor() {\n        return {\n            get: function get(node2, prop) {\n                if (prop === \"proxyOf\") {\n                    return node2;\n                } else if (prop === \"root\") {\n                    return function() {\n                        return node2.root().toProxy();\n                    };\n                } else {\n                    return node2[prop];\n                }\n            },\n            set: function set(node2, prop, value) {\n                if (node2[prop] === value) return true;\n                node2[prop] = value;\n                if (prop === \"prop\" || prop === \"value\" || prop === \"name\" || prop === \"params\" || prop === \"important\" || /* c8 ignore next */ prop === \"text\") {\n                    node2.markDirty();\n                }\n                return true;\n            }\n        };\n    };\n    _proto.markDirty = function markDirty() {\n        if (this[isClean$2]) {\n            this[isClean$2] = false;\n            var next = this;\n            while(next = next.parent){\n                next[isClean$2] = false;\n            }\n        }\n    };\n    _proto.next = function next() {\n        if (!this.parent) return void 0;\n        var index2 = this.parent.index(this);\n        return this.parent.nodes[index2 + 1];\n    };\n    _proto.positionBy = function positionBy(opts, stringRepresentation) {\n        var pos = this.source.start;\n        if (opts.index) {\n            pos = this.positionInside(opts.index, stringRepresentation);\n        } else if (opts.word) {\n            stringRepresentation = this.toString();\n            var index2 = stringRepresentation.indexOf(opts.word);\n            if (index2 !== -1) pos = this.positionInside(index2, stringRepresentation);\n        }\n        return pos;\n    };\n    _proto.positionInside = function positionInside(index2, stringRepresentation) {\n        var string = stringRepresentation || this.toString();\n        var column = this.source.start.column;\n        var line = this.source.start.line;\n        for(var i2 = 0; i2 < index2; i2++){\n            if (string[i2] === \"\\n\") {\n                column = 1;\n                line += 1;\n            } else {\n                column += 1;\n            }\n        }\n        return {\n            column: column,\n            line: line\n        };\n    };\n    _proto.prev = function prev() {\n        if (!this.parent) return void 0;\n        var index2 = this.parent.index(this);\n        return this.parent.nodes[index2 - 1];\n    };\n    _proto.rangeBy = function rangeBy(opts) {\n        var start = {\n            column: this.source.start.column,\n            line: this.source.start.line\n        };\n        var end = this.source.end ? {\n            column: this.source.end.column + 1,\n            line: this.source.end.line\n        } : {\n            column: start.column + 1,\n            line: start.line\n        };\n        if (opts.word) {\n            var stringRepresentation = this.toString();\n            var index2 = stringRepresentation.indexOf(opts.word);\n            if (index2 !== -1) {\n                start = this.positionInside(index2, stringRepresentation);\n                end = this.positionInside(index2 + opts.word.length, stringRepresentation);\n            }\n        } else {\n            if (opts.start) {\n                start = {\n                    column: opts.start.column,\n                    line: opts.start.line\n                };\n            } else if (opts.index) {\n                start = this.positionInside(opts.index);\n            }\n            if (opts.end) {\n                end = {\n                    column: opts.end.column,\n                    line: opts.end.line\n                };\n            } else if (typeof opts.endIndex === \"number\") {\n                end = this.positionInside(opts.endIndex);\n            } else if (opts.index) {\n                end = this.positionInside(opts.index + 1);\n            }\n        }\n        if (end.line < start.line || end.line === start.line && end.column <= start.column) {\n            end = {\n                column: start.column + 1,\n                line: start.line\n            };\n        }\n        return {\n            end: end,\n            start: start\n        };\n    };\n    _proto.raw = function raw(prop, defaultType) {\n        var str = new Stringifier22();\n        return str.raw(this, prop, defaultType);\n    };\n    _proto.remove = function remove() {\n        if (this.parent) {\n            this.parent.removeChild(this);\n        }\n        this.parent = void 0;\n        return this;\n    };\n    _proto.replaceWith = function replaceWith() {\n        for(var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++){\n            nodes[_key] = arguments[_key];\n        }\n        if (this.parent) {\n            var bookmark = this;\n            var foundSelf = false;\n            for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n                var node2 = _step.value;\n                if (node2 === this) {\n                    foundSelf = true;\n                } else if (foundSelf) {\n                    this.parent.insertAfter(bookmark, node2);\n                    bookmark = node2;\n                } else {\n                    this.parent.insertBefore(bookmark, node2);\n                }\n            }\n            if (!foundSelf) {\n                this.remove();\n            }\n        }\n        return this;\n    };\n    _proto.root = function root() {\n        var result2 = this;\n        while(result2.parent && result2.parent.type !== \"document\"){\n            result2 = result2.parent;\n        }\n        return result2;\n    };\n    _proto.toJSON = function toJSON(_, inputs) {\n        var fixed = {};\n        var emitInputs = inputs == null;\n        inputs = inputs || /* @__PURE__ */ new Map();\n        var inputsNextIndex = 0;\n        for(var name in this){\n            if (!Object.prototype.hasOwnProperty.call(this, name)) {\n                continue;\n            }\n            if (name === \"parent\" || name === \"proxyCache\") continue;\n            var value = this[name];\n            if (Array.isArray(value)) {\n                fixed[name] = value.map(function(i2) {\n                    if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && i2.toJSON) {\n                        return i2.toJSON(null, inputs);\n                    } else {\n                        return i2;\n                    }\n                });\n            } else if ((typeof value === \"undefined\" ? \"undefined\" : _type_of(value)) === \"object\" && value.toJSON) {\n                fixed[name] = value.toJSON(null, inputs);\n            } else if (name === \"source\") {\n                var inputId = inputs.get(value.input);\n                if (inputId == null) {\n                    inputId = inputsNextIndex;\n                    inputs.set(value.input, inputsNextIndex);\n                    inputsNextIndex++;\n                }\n                fixed[name] = {\n                    end: value.end,\n                    inputId: inputId,\n                    start: value.start\n                };\n            } else {\n                fixed[name] = value;\n            }\n        }\n        if (emitInputs) {\n            fixed.inputs = [].concat(inputs.keys()).map(function(input2) {\n                return input2.toJSON();\n            });\n        }\n        return fixed;\n    };\n    _proto.toProxy = function toProxy() {\n        if (!this.proxyCache) {\n            this.proxyCache = new Proxy(this, this.getProxyProcessor());\n        }\n        return this.proxyCache;\n    };\n    _proto.toString = function toString(stringifier2) {\n        if (stringifier2 === void 0) stringifier2 = stringify$3;\n        if (stringifier2.stringify) stringifier2 = stringifier2.stringify;\n        var result2 = \"\";\n        stringifier2(this, function(i2) {\n            result2 += i2;\n        });\n        return result2;\n    };\n    _proto.warn = function warn(result2, text, opts) {\n        var data = {\n            node: this\n        };\n        for(var i2 in opts)data[i2] = opts[i2];\n        return result2.warn(text, data);\n    };\n    _create_class(Node3, [\n        {\n            key: \"proxyOf\",\n            get: function get() {\n                return this;\n            }\n        }\n    ]);\n    return Node3;\n}();\nvar node = Node$4;\nNode$4.default = Node$4;\nvar Node$3 = node;\nvar Declaration$4 = /*#__PURE__*/ function(Node$3) {\n    _inherits(Declaration2, Node$3);\n    function Declaration2(defaults) {\n        var _this;\n        if (defaults && typeof defaults.value !== \"undefined\" && typeof defaults.value !== \"string\") {\n            defaults = _extends({}, defaults, {\n                value: String(defaults.value)\n            });\n        }\n        _this = Node$3.call(this, defaults) || this;\n        _this.type = \"decl\";\n        return _this;\n    }\n    _create_class(Declaration2, [\n        {\n            key: \"variable\",\n            get: function get() {\n                return this.prop.startsWith(\"--\") || this.prop[0] === \"$\";\n            }\n        }\n    ]);\n    return Declaration2;\n}(Node$3);\nvar declaration = Declaration$4;\nDeclaration$4.default = Declaration$4;\nvar urlAlphabet = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nvar nanoid$1 = function(size) {\n    if (size === void 0) size = 21;\n    var id = \"\";\n    var i2 = size;\n    while(i2--){\n        id += urlAlphabet[Math.random() * 64 | 0];\n    }\n    return id;\n};\nvar nonSecure = {\n    nanoid: nanoid$1\n};\nvar SourceMapConsumer$2 = require$$2.SourceMapConsumer, SourceMapGenerator$2 = require$$2.SourceMapGenerator;\nvar existsSync = require$$2.existsSync, readFileSync = require$$2.readFileSync;\nvar dirname$1 = require$$2.dirname, join = require$$2.join;\nfunction fromBase64(str) {\n    if (Buffer) {\n        return Buffer.from(str, \"base64\").toString();\n    } else {\n        return window.atob(str);\n    }\n}\nvar PreviousMap$2 = /*#__PURE__*/ function() {\n    function PreviousMap2(css, opts) {\n        if (opts.map === false) return;\n        this.loadAnnotation(css);\n        this.inline = this.startWith(this.annotation, \"data:\");\n        var prev = opts.map ? opts.map.prev : void 0;\n        var text = this.loadMap(opts.from, prev);\n        if (!this.mapFile && opts.from) {\n            this.mapFile = opts.from;\n        }\n        if (this.mapFile) this.root = dirname$1(this.mapFile);\n        if (text) this.text = text;\n    }\n    var _proto = PreviousMap2.prototype;\n    _proto.consumer = function consumer() {\n        if (!this.consumerCache) {\n            this.consumerCache = new SourceMapConsumer$2(this.text);\n        }\n        return this.consumerCache;\n    };\n    _proto.decodeInline = function decodeInline(text) {\n        var baseCharsetUri = /^data:application\\/json;charset=utf-?8;base64,/;\n        var baseUri = /^data:application\\/json;base64,/;\n        var charsetUri = /^data:application\\/json;charset=utf-?8,/;\n        var uri = /^data:application\\/json,/;\n        if (charsetUri.test(text) || uri.test(text)) {\n            return decodeURIComponent(text.substr(RegExp.lastMatch.length));\n        }\n        if (baseCharsetUri.test(text) || baseUri.test(text)) {\n            return fromBase64(text.substr(RegExp.lastMatch.length));\n        }\n        var encoding = text.match(/data:application\\/json;([^,]+),/)[1];\n        throw new Error(\"Unsupported source map encoding \" + encoding);\n    };\n    _proto.getAnnotationURL = function getAnnotationURL(sourceMapString) {\n        return sourceMapString.replace(/^\\/\\*\\s*# sourceMappingURL=/, \"\").trim();\n    };\n    _proto.isMap = function isMap(map) {\n        if ((typeof map === \"undefined\" ? \"undefined\" : _type_of(map)) !== \"object\") return false;\n        return typeof map.mappings === \"string\" || typeof map._mappings === \"string\" || Array.isArray(map.sections);\n    };\n    _proto.loadAnnotation = function loadAnnotation(css) {\n        var comments = css.match(/\\/\\*\\s*# sourceMappingURL=/gm);\n        if (!comments) return;\n        var start = css.lastIndexOf(comments.pop());\n        var end = css.indexOf(\"*/\", start);\n        if (start > -1 && end > -1) {\n            this.annotation = this.getAnnotationURL(css.substring(start, end));\n        }\n    };\n    _proto.loadFile = function loadFile(path) {\n        this.root = dirname$1(path);\n        if (existsSync(path)) {\n            this.mapFile = path;\n            return readFileSync(path, \"utf-8\").toString().trim();\n        }\n    };\n    _proto.loadMap = function loadMap(file, prev) {\n        if (prev === false) return false;\n        if (prev) {\n            if (typeof prev === \"string\") {\n                return prev;\n            } else if (typeof prev === \"function\") {\n                var prevPath = prev(file);\n                if (prevPath) {\n                    var map = this.loadFile(prevPath);\n                    if (!map) {\n                        throw new Error(\"Unable to load previous source map: \" + prevPath.toString());\n                    }\n                    return map;\n                }\n            } else if (_instanceof(prev, SourceMapConsumer$2)) {\n                return SourceMapGenerator$2.fromSourceMap(prev).toString();\n            } else if (_instanceof(prev, SourceMapGenerator$2)) {\n                return prev.toString();\n            } else if (this.isMap(prev)) {\n                return JSON.stringify(prev);\n            } else {\n                throw new Error(\"Unsupported previous source map format: \" + prev.toString());\n            }\n        } else if (this.inline) {\n            return this.decodeInline(this.annotation);\n        } else if (this.annotation) {\n            var map1 = this.annotation;\n            if (file) map1 = join(dirname$1(file), map1);\n            return this.loadFile(map1);\n        }\n    };\n    _proto.startWith = function startWith(string, start) {\n        if (!string) return false;\n        return string.substr(0, start.length) === start;\n    };\n    _proto.withContent = function withContent() {\n        return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);\n    };\n    return PreviousMap2;\n}();\nvar previousMap = PreviousMap$2;\nPreviousMap$2.default = PreviousMap$2;\nvar SourceMapConsumer$1 = require$$2.SourceMapConsumer, SourceMapGenerator$1 = require$$2.SourceMapGenerator;\nvar fileURLToPath = require$$2.fileURLToPath, pathToFileURL$1 = require$$2.pathToFileURL;\nvar isAbsolute = require$$2.isAbsolute, resolve$1 = require$$2.resolve;\nvar nanoid = nonSecure.nanoid;\nvar terminalHighlight = require$$2;\nvar CssSyntaxError$1 = cssSyntaxError;\nvar PreviousMap$1 = previousMap;\nvar fromOffsetCache = Symbol(\"fromOffsetCache\");\nvar sourceMapAvailable$1 = Boolean(SourceMapConsumer$1 && SourceMapGenerator$1);\nvar pathAvailable$1 = Boolean(resolve$1 && isAbsolute);\nvar Input$4 = /*#__PURE__*/ function() {\n    function Input2(css, opts) {\n        if (opts === void 0) opts = {};\n        if (css === null || typeof css === \"undefined\" || (typeof css === \"undefined\" ? \"undefined\" : _type_of(css)) === \"object\" && !css.toString) {\n            throw new Error(\"PostCSS received \" + css + \" instead of CSS string\");\n        }\n        this.css = css.toString();\n        if (this.css[0] === \"\\uFEFF\" || this.css[0] === \"\") {\n            this.hasBOM = true;\n            this.css = this.css.slice(1);\n        } else {\n            this.hasBOM = false;\n        }\n        if (opts.from) {\n            if (!pathAvailable$1 || /^\\w+:\\/\\//.test(opts.from) || isAbsolute(opts.from)) {\n                this.file = opts.from;\n            } else {\n                this.file = resolve$1(opts.from);\n            }\n        }\n        if (pathAvailable$1 && sourceMapAvailable$1) {\n            var map = new PreviousMap$1(this.css, opts);\n            if (map.text) {\n                this.map = map;\n                var file = map.consumer().file;\n                if (!this.file && file) this.file = this.mapResolve(file);\n            }\n        }\n        if (!this.file) {\n            this.id = \"<input css \" + nanoid(6) + \">\";\n        }\n        if (this.map) this.map.file = this.from;\n    }\n    var _proto = Input2.prototype;\n    _proto.error = function error(message, line, column, opts) {\n        if (opts === void 0) opts = {};\n        var result2, endLine, endColumn;\n        if (line && (typeof line === \"undefined\" ? \"undefined\" : _type_of(line)) === \"object\") {\n            var start = line;\n            var end = column;\n            if (typeof start.offset === \"number\") {\n                var pos = this.fromOffset(start.offset);\n                line = pos.line;\n                column = pos.col;\n            } else {\n                line = start.line;\n                column = start.column;\n            }\n            if (typeof end.offset === \"number\") {\n                var pos1 = this.fromOffset(end.offset);\n                endLine = pos1.line;\n                endColumn = pos1.col;\n            } else {\n                endLine = end.line;\n                endColumn = end.column;\n            }\n        } else if (!column) {\n            var pos2 = this.fromOffset(line);\n            line = pos2.line;\n            column = pos2.col;\n        }\n        var origin = this.origin(line, column, endLine, endColumn);\n        if (origin) {\n            result2 = new CssSyntaxError$1(message, origin.endLine === void 0 ? origin.line : {\n                column: origin.column,\n                line: origin.line\n            }, origin.endLine === void 0 ? origin.column : {\n                column: origin.endColumn,\n                line: origin.endLine\n            }, origin.source, origin.file, opts.plugin);\n        } else {\n            result2 = new CssSyntaxError$1(message, endLine === void 0 ? line : {\n                column: column,\n                line: line\n            }, endLine === void 0 ? column : {\n                column: endColumn,\n                line: endLine\n            }, this.css, this.file, opts.plugin);\n        }\n        result2.input = {\n            column: column,\n            endColumn: endColumn,\n            endLine: endLine,\n            line: line,\n            source: this.css\n        };\n        if (this.file) {\n            if (pathToFileURL$1) {\n                result2.input.url = pathToFileURL$1(this.file).toString();\n            }\n            result2.input.file = this.file;\n        }\n        return result2;\n    };\n    _proto.fromOffset = function fromOffset(offset) {\n        var lastLine, lineToIndex;\n        if (!this[fromOffsetCache]) {\n            var lines = this.css.split(\"\\n\");\n            lineToIndex = new Array(lines.length);\n            var prevIndex = 0;\n            for(var i2 = 0, l2 = lines.length; i2 < l2; i2++){\n                lineToIndex[i2] = prevIndex;\n                prevIndex += lines[i2].length + 1;\n            }\n            this[fromOffsetCache] = lineToIndex;\n        } else {\n            lineToIndex = this[fromOffsetCache];\n        }\n        lastLine = lineToIndex[lineToIndex.length - 1];\n        var min = 0;\n        if (offset >= lastLine) {\n            min = lineToIndex.length - 1;\n        } else {\n            var max = lineToIndex.length - 2;\n            var mid;\n            while(min < max){\n                mid = min + (max - min >> 1);\n                if (offset < lineToIndex[mid]) {\n                    max = mid - 1;\n                } else if (offset >= lineToIndex[mid + 1]) {\n                    min = mid + 1;\n                } else {\n                    min = mid;\n                    break;\n                }\n            }\n        }\n        return {\n            col: offset - lineToIndex[min] + 1,\n            line: min + 1\n        };\n    };\n    _proto.mapResolve = function mapResolve(file) {\n        if (/^\\w+:\\/\\//.test(file)) {\n            return file;\n        }\n        return resolve$1(this.map.consumer().sourceRoot || this.map.root || \".\", file);\n    };\n    _proto.origin = function origin(line, column, endLine, endColumn) {\n        if (!this.map) return false;\n        var consumer = this.map.consumer();\n        var from = consumer.originalPositionFor({\n            column: column,\n            line: line\n        });\n        if (!from.source) return false;\n        var to;\n        if (typeof endLine === \"number\") {\n            to = consumer.originalPositionFor({\n                column: endColumn,\n                line: endLine\n            });\n        }\n        var fromUrl;\n        if (isAbsolute(from.source)) {\n            fromUrl = pathToFileURL$1(from.source);\n        } else {\n            fromUrl = new URL(from.source, this.map.consumer().sourceRoot || pathToFileURL$1(this.map.mapFile));\n        }\n        var result2 = {\n            column: from.column,\n            endColumn: to && to.column,\n            endLine: to && to.line,\n            line: from.line,\n            url: fromUrl.toString()\n        };\n        if (fromUrl.protocol === \"file:\") {\n            if (fileURLToPath) {\n                result2.file = fileURLToPath(fromUrl);\n            } else {\n                throw new Error(\"file: protocol is not available in this PostCSS build\");\n            }\n        }\n        var source = consumer.sourceContentFor(from.source);\n        if (source) result2.source = source;\n        return result2;\n    };\n    _proto.toJSON = function toJSON() {\n        var json = {};\n        for(var _i = 0, _iter = [\n            \"hasBOM\",\n            \"css\",\n            \"file\",\n            \"id\"\n        ]; _i < _iter.length; _i++){\n            var name = _iter[_i];\n            if (this[name] != null) {\n                json[name] = this[name];\n            }\n        }\n        if (this.map) {\n            json.map = _extends({}, this.map);\n            if (json.map.consumerCache) {\n                json.map.consumerCache = void 0;\n            }\n        }\n        return json;\n    };\n    _create_class(Input2, [\n        {\n            key: \"from\",\n            get: function get() {\n                return this.file || this.id;\n            }\n        }\n    ]);\n    return Input2;\n}();\nvar input = Input$4;\nInput$4.default = Input$4;\nif (terminalHighlight && terminalHighlight.registerInput) {\n    terminalHighlight.registerInput(Input$4);\n}\nvar SourceMapConsumer = require$$2.SourceMapConsumer, SourceMapGenerator = require$$2.SourceMapGenerator;\nvar dirname = require$$2.dirname, relative = require$$2.relative, resolve$3 = require$$2.resolve, sep = require$$2.sep;\nvar pathToFileURL = require$$2.pathToFileURL;\nvar Input$3 = input;\nvar sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);\nvar pathAvailable = Boolean(dirname && resolve$3 && relative && sep);\nvar MapGenerator$2 = /*#__PURE__*/ function() {\n    function MapGenerator2(stringify2, root2, opts, cssString) {\n        this.stringify = stringify2;\n        this.mapOpts = opts.map || {};\n        this.root = root2;\n        this.opts = opts;\n        this.css = cssString;\n        this.originalCSS = cssString;\n        this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;\n        this.memoizedFileURLs = /* @__PURE__ */ new Map();\n        this.memoizedPaths = /* @__PURE__ */ new Map();\n        this.memoizedURLs = /* @__PURE__ */ new Map();\n    }\n    var _proto = MapGenerator2.prototype;\n    _proto.addAnnotation = function addAnnotation() {\n        var content;\n        if (this.isInline()) {\n            content = \"data:application/json;base64,\" + this.toBase64(this.map.toString());\n        } else if (typeof this.mapOpts.annotation === \"string\") {\n            content = this.mapOpts.annotation;\n        } else if (typeof this.mapOpts.annotation === \"function\") {\n            content = this.mapOpts.annotation(this.opts.to, this.root);\n        } else {\n            content = this.outputFile() + \".map\";\n        }\n        var eol = \"\\n\";\n        if (this.css.includes(\"\\r\\n\")) eol = \"\\r\\n\";\n        this.css += eol + \"/*# sourceMappingURL=\" + content + \" */\";\n    };\n    _proto.applyPrevMaps = function applyPrevMaps() {\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.previous()), _step; !(_step = _iterator()).done;){\n            var prev = _step.value;\n            var from = this.toUrl(this.path(prev.file));\n            var root2 = prev.root || dirname(prev.file);\n            var map = void 0;\n            if (this.mapOpts.sourcesContent === false) {\n                map = new SourceMapConsumer(prev.text);\n                if (map.sourcesContent) {\n                    map.sourcesContent = null;\n                }\n            } else {\n                map = prev.consumer();\n            }\n            this.map.applySourceMap(map, from, this.toUrl(this.path(root2)));\n        }\n    };\n    _proto.clearAnnotation = function clearAnnotation() {\n        if (this.mapOpts.annotation === false) return;\n        if (this.root) {\n            var node2;\n            for(var i2 = this.root.nodes.length - 1; i2 >= 0; i2--){\n                node2 = this.root.nodes[i2];\n                if (node2.type !== \"comment\") continue;\n                if (node2.text.indexOf(\"# sourceMappingURL=\") === 0) {\n                    this.root.removeChild(i2);\n                }\n            }\n        } else if (this.css) {\n            this.css = this.css.replace(/\\n*?\\/\\*#[\\S\\s]*?\\*\\/$/gm, \"\");\n        }\n    };\n    _proto.generate = function generate() {\n        this.clearAnnotation();\n        if (pathAvailable && sourceMapAvailable && this.isMap()) {\n            return this.generateMap();\n        } else {\n            var result2 = \"\";\n            this.stringify(this.root, function(i2) {\n                result2 += i2;\n            });\n            return [\n                result2\n            ];\n        }\n    };\n    _proto.generateMap = function generateMap() {\n        if (this.root) {\n            this.generateString();\n        } else if (this.previous().length === 1) {\n            var prev = this.previous()[0].consumer();\n            prev.file = this.outputFile();\n            this.map = SourceMapGenerator.fromSourceMap(prev, {\n                ignoreInvalidMapping: true\n            });\n        } else {\n            this.map = new SourceMapGenerator({\n                file: this.outputFile(),\n                ignoreInvalidMapping: true\n            });\n            this.map.addMapping({\n                generated: {\n                    column: 0,\n                    line: 1\n                },\n                original: {\n                    column: 0,\n                    line: 1\n                },\n                source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : \"<no source>\"\n            });\n        }\n        if (this.isSourcesContent()) this.setSourcesContent();\n        if (this.root && this.previous().length > 0) this.applyPrevMaps();\n        if (this.isAnnotation()) this.addAnnotation();\n        if (this.isInline()) {\n            return [\n                this.css\n            ];\n        } else {\n            return [\n                this.css,\n                this.map\n            ];\n        }\n    };\n    _proto.generateString = function generateString() {\n        var _this = this;\n        this.css = \"\";\n        this.map = new SourceMapGenerator({\n            file: this.outputFile(),\n            ignoreInvalidMapping: true\n        });\n        var line = 1;\n        var column = 1;\n        var noSource = \"<no source>\";\n        var mapping = {\n            generated: {\n                column: 0,\n                line: 0\n            },\n            original: {\n                column: 0,\n                line: 0\n            },\n            source: \"\"\n        };\n        var lines, last;\n        this.stringify(this.root, function(str, node2, type) {\n            _this.css += str;\n            if (node2 && type !== \"end\") {\n                mapping.generated.line = line;\n                mapping.generated.column = column - 1;\n                if (node2.source && node2.source.start) {\n                    mapping.source = _this.sourcePath(node2);\n                    mapping.original.line = node2.source.start.line;\n                    mapping.original.column = node2.source.start.column - 1;\n                    _this.map.addMapping(mapping);\n                } else {\n                    mapping.source = noSource;\n                    mapping.original.line = 1;\n                    mapping.original.column = 0;\n                    _this.map.addMapping(mapping);\n                }\n            }\n            lines = str.match(/\\n/g);\n            if (lines) {\n                line += lines.length;\n                last = str.lastIndexOf(\"\\n\");\n                column = str.length - last;\n            } else {\n                column += str.length;\n            }\n            if (node2 && type !== \"start\") {\n                var p = node2.parent || {\n                    raws: {}\n                };\n                var childless = node2.type === \"decl\" || node2.type === \"atrule\" && !node2.nodes;\n                if (!childless || node2 !== p.last || p.raws.semicolon) {\n                    if (node2.source && node2.source.end) {\n                        mapping.source = _this.sourcePath(node2);\n                        mapping.original.line = node2.source.end.line;\n                        mapping.original.column = node2.source.end.column - 1;\n                        mapping.generated.line = line;\n                        mapping.generated.column = column - 2;\n                        _this.map.addMapping(mapping);\n                    } else {\n                        mapping.source = noSource;\n                        mapping.original.line = 1;\n                        mapping.original.column = 0;\n                        mapping.generated.line = line;\n                        mapping.generated.column = column - 1;\n                        _this.map.addMapping(mapping);\n                    }\n                }\n            }\n        });\n    };\n    _proto.isAnnotation = function isAnnotation() {\n        if (this.isInline()) {\n            return true;\n        }\n        if (typeof this.mapOpts.annotation !== \"undefined\") {\n            return this.mapOpts.annotation;\n        }\n        if (this.previous().length) {\n            return this.previous().some(function(i2) {\n                return i2.annotation;\n            });\n        }\n        return true;\n    };\n    _proto.isInline = function isInline() {\n        if (typeof this.mapOpts.inline !== \"undefined\") {\n            return this.mapOpts.inline;\n        }\n        var annotation = this.mapOpts.annotation;\n        if (typeof annotation !== \"undefined\" && annotation !== true) {\n            return false;\n        }\n        if (this.previous().length) {\n            return this.previous().some(function(i2) {\n                return i2.inline;\n            });\n        }\n        return true;\n    };\n    _proto.isMap = function isMap() {\n        if (typeof this.opts.map !== \"undefined\") {\n            return !!this.opts.map;\n        }\n        return this.previous().length > 0;\n    };\n    _proto.isSourcesContent = function isSourcesContent() {\n        if (typeof this.mapOpts.sourcesContent !== \"undefined\") {\n            return this.mapOpts.sourcesContent;\n        }\n        if (this.previous().length) {\n            return this.previous().some(function(i2) {\n                return i2.withContent();\n            });\n        }\n        return true;\n    };\n    _proto.outputFile = function outputFile() {\n        if (this.opts.to) {\n            return this.path(this.opts.to);\n        } else if (this.opts.from) {\n            return this.path(this.opts.from);\n        } else {\n            return \"to.css\";\n        }\n    };\n    _proto.path = function path(file) {\n        if (this.mapOpts.absolute) return file;\n        if (file.charCodeAt(0) === 60) return file;\n        if (/^\\w+:\\/\\//.test(file)) return file;\n        var cached = this.memoizedPaths.get(file);\n        if (cached) return cached;\n        var from = this.opts.to ? dirname(this.opts.to) : \".\";\n        if (typeof this.mapOpts.annotation === \"string\") {\n            from = dirname(resolve$3(from, this.mapOpts.annotation));\n        }\n        var path = relative(from, file);\n        this.memoizedPaths.set(file, path);\n        return path;\n    };\n    _proto.previous = function previous() {\n        var _this = this;\n        if (!this.previousMaps) {\n            this.previousMaps = [];\n            if (this.root) {\n                this.root.walk(function(node2) {\n                    if (node2.source && node2.source.input.map) {\n                        var map = node2.source.input.map;\n                        if (!_this.previousMaps.includes(map)) {\n                            _this.previousMaps.push(map);\n                        }\n                    }\n                });\n            } else {\n                var input2 = new Input$3(this.originalCSS, this.opts);\n                if (input2.map) this.previousMaps.push(input2.map);\n            }\n        }\n        return this.previousMaps;\n    };\n    _proto.setSourcesContent = function setSourcesContent() {\n        var _this = this;\n        var already = {};\n        if (this.root) {\n            this.root.walk(function(node2) {\n                if (node2.source) {\n                    var from = node2.source.input.from;\n                    if (from && !already[from]) {\n                        already[from] = true;\n                        var fromUrl = _this.usesFileUrls ? _this.toFileUrl(from) : _this.toUrl(_this.path(from));\n                        _this.map.setSourceContent(fromUrl, node2.source.input.css);\n                    }\n                }\n            });\n        } else if (this.css) {\n            var from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : \"<no source>\";\n            this.map.setSourceContent(from, this.css);\n        }\n    };\n    _proto.sourcePath = function sourcePath(node2) {\n        if (this.mapOpts.from) {\n            return this.toUrl(this.mapOpts.from);\n        } else if (this.usesFileUrls) {\n            return this.toFileUrl(node2.source.input.from);\n        } else {\n            return this.toUrl(this.path(node2.source.input.from));\n        }\n    };\n    _proto.toBase64 = function toBase64(str) {\n        if (Buffer) {\n            return Buffer.from(str).toString(\"base64\");\n        } else {\n            return window.btoa(unescape(encodeURIComponent(str)));\n        }\n    };\n    _proto.toFileUrl = function toFileUrl(path) {\n        var cached = this.memoizedFileURLs.get(path);\n        if (cached) return cached;\n        if (pathToFileURL) {\n            var fileURL = pathToFileURL(path).toString();\n            this.memoizedFileURLs.set(path, fileURL);\n            return fileURL;\n        } else {\n            throw new Error(\"`map.absolute` option is not available in this PostCSS build\");\n        }\n    };\n    _proto.toUrl = function toUrl(path) {\n        var cached = this.memoizedURLs.get(path);\n        if (cached) return cached;\n        if (sep === \"\\\\\") {\n            path = path.replace(/\\\\/g, \"/\");\n        }\n        var url = encodeURI(path).replace(/[#?]/g, encodeURIComponent);\n        this.memoizedURLs.set(path, url);\n        return url;\n    };\n    return MapGenerator2;\n}();\nvar mapGenerator = MapGenerator$2;\nvar Node$2 = node;\nvar Comment$4 = /*#__PURE__*/ function(Node$2) {\n    _inherits(Comment2, Node$2);\n    function Comment2(defaults) {\n        var _this;\n        _this = Node$2.call(this, defaults) || this;\n        _this.type = \"comment\";\n        return _this;\n    }\n    return Comment2;\n}(Node$2);\nvar comment = Comment$4;\nComment$4.default = Comment$4;\nvar isClean$1 = symbols.isClean, my$1 = symbols.my;\nvar Declaration$3 = declaration;\nvar Comment$3 = comment;\nvar Node$1 = node;\nvar parse$4, Rule$4, AtRule$4, Root$6;\nfunction cleanSource(nodes) {\n    return nodes.map(function(i2) {\n        if (i2.nodes) i2.nodes = cleanSource(i2.nodes);\n        delete i2.source;\n        return i2;\n    });\n}\nfunction markDirtyUp(node2) {\n    node2[isClean$1] = false;\n    if (node2.proxyOf.nodes) {\n        for(var _iterator = _create_for_of_iterator_helper_loose(node2.proxyOf.nodes), _step; !(_step = _iterator()).done;){\n            var i2 = _step.value;\n            markDirtyUp(i2);\n        }\n    }\n}\nvar Container$7 = /*#__PURE__*/ function(Node$1) {\n    _inherits(Container2, Node$1);\n    function Container2() {\n        return Node$1.apply(this, arguments) || this;\n    }\n    var _proto = Container2.prototype;\n    _proto.append = function append() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        for(var _iterator = _create_for_of_iterator_helper_loose(children), _step; !(_step = _iterator()).done;){\n            var child = _step.value;\n            var nodes = this.normalize(child, this.last);\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(nodes), _step1; !(_step1 = _iterator1()).done;){\n                var node2 = _step1.value;\n                this.proxyOf.nodes.push(node2);\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.cleanRaws = function cleanRaws(keepBetween) {\n        Node$1.prototype.cleanRaws.call(this, keepBetween);\n        if (this.nodes) {\n            for(var _iterator = _create_for_of_iterator_helper_loose(this.nodes), _step; !(_step = _iterator()).done;){\n                var node2 = _step.value;\n                node2.cleanRaws(keepBetween);\n            }\n        }\n    };\n    _proto.each = function each(callback) {\n        if (!this.proxyOf.nodes) return void 0;\n        var iterator = this.getIterator();\n        var index2, result2;\n        while(this.indexes[iterator] < this.proxyOf.nodes.length){\n            index2 = this.indexes[iterator];\n            result2 = callback(this.proxyOf.nodes[index2], index2);\n            if (result2 === false) break;\n            this.indexes[iterator] += 1;\n        }\n        delete this.indexes[iterator];\n        return result2;\n    };\n    _proto.every = function every(condition) {\n        return this.nodes.every(condition);\n    };\n    _proto.getIterator = function getIterator() {\n        if (!this.lastEach) this.lastEach = 0;\n        if (!this.indexes) this.indexes = {};\n        this.lastEach += 1;\n        var iterator = this.lastEach;\n        this.indexes[iterator] = 0;\n        return iterator;\n    };\n    _proto.getProxyProcessor = function getProxyProcessor() {\n        return {\n            get: function get(node2, prop) {\n                if (prop === \"proxyOf\") {\n                    return node2;\n                } else if (!node2[prop]) {\n                    return node2[prop];\n                } else if (prop === \"each\" || typeof prop === \"string\" && prop.startsWith(\"walk\")) {\n                    return function() {\n                        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                            args[_key] = arguments[_key];\n                        }\n                        var _node2;\n                        return (_node2 = node2)[prop].apply(_node2, [].concat(args.map(function(i2) {\n                            if (typeof i2 === \"function\") {\n                                return function(child, index2) {\n                                    return i2(child.toProxy(), index2);\n                                };\n                            } else {\n                                return i2;\n                            }\n                        })));\n                    };\n                } else if (prop === \"every\" || prop === \"some\") {\n                    return function(cb) {\n                        return node2[prop](function(child) {\n                            for(var _len = arguments.length, other = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                                other[_key - 1] = arguments[_key];\n                            }\n                            return cb.apply(void 0, [].concat([\n                                child.toProxy()\n                            ], other));\n                        });\n                    };\n                } else if (prop === \"root\") {\n                    return function() {\n                        return node2.root().toProxy();\n                    };\n                } else if (prop === \"nodes\") {\n                    return node2.nodes.map(function(i2) {\n                        return i2.toProxy();\n                    });\n                } else if (prop === \"first\" || prop === \"last\") {\n                    return node2[prop].toProxy();\n                } else {\n                    return node2[prop];\n                }\n            },\n            set: function set(node2, prop, value) {\n                if (node2[prop] === value) return true;\n                node2[prop] = value;\n                if (prop === \"name\" || prop === \"params\" || prop === \"selector\") {\n                    node2.markDirty();\n                }\n                return true;\n            }\n        };\n    };\n    _proto.index = function index(child) {\n        if (typeof child === \"number\") return child;\n        if (child.proxyOf) child = child.proxyOf;\n        return this.proxyOf.nodes.indexOf(child);\n    };\n    _proto.insertAfter = function insertAfter(exist, add) {\n        var existIndex = this.index(exist);\n        var nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();\n        existIndex = this.index(exist);\n        for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n            var node2 = _step.value;\n            this.proxyOf.nodes.splice(existIndex + 1, 0, node2);\n        }\n        var index2;\n        for(var id in this.indexes){\n            index2 = this.indexes[id];\n            if (existIndex < index2) {\n                this.indexes[id] = index2 + nodes.length;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.insertBefore = function insertBefore(exist, add) {\n        var existIndex = this.index(exist);\n        var type = existIndex === 0 ? \"prepend\" : false;\n        var nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse();\n        existIndex = this.index(exist);\n        for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n            var node2 = _step.value;\n            this.proxyOf.nodes.splice(existIndex, 0, node2);\n        }\n        var index2;\n        for(var id in this.indexes){\n            index2 = this.indexes[id];\n            if (existIndex <= index2) {\n                this.indexes[id] = index2 + nodes.length;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.normalize = function normalize(nodes, sample) {\n        var _this = this;\n        if (typeof nodes === \"string\") {\n            nodes = cleanSource(parse$4(nodes).nodes);\n        } else if (typeof nodes === \"undefined\") {\n            nodes = [];\n        } else if (Array.isArray(nodes)) {\n            nodes = nodes.slice(0);\n            for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n                var i2 = _step.value;\n                if (i2.parent) i2.parent.removeChild(i2, \"ignore\");\n            }\n        } else if (nodes.type === \"root\" && this.type !== \"document\") {\n            nodes = nodes.nodes.slice(0);\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(nodes), _step1; !(_step1 = _iterator1()).done;){\n                var i21 = _step1.value;\n                if (i21.parent) i21.parent.removeChild(i21, \"ignore\");\n            }\n        } else if (nodes.type) {\n            nodes = [\n                nodes\n            ];\n        } else if (nodes.prop) {\n            if (typeof nodes.value === \"undefined\") {\n                throw new Error(\"Value field is missed in node creation\");\n            } else if (typeof nodes.value !== \"string\") {\n                nodes.value = String(nodes.value);\n            }\n            nodes = [\n                new Declaration$3(nodes)\n            ];\n        } else if (nodes.selector) {\n            nodes = [\n                new Rule$4(nodes)\n            ];\n        } else if (nodes.name) {\n            nodes = [\n                new AtRule$4(nodes)\n            ];\n        } else if (nodes.text) {\n            nodes = [\n                new Comment$3(nodes)\n            ];\n        } else {\n            throw new Error(\"Unknown node type in node creation\");\n        }\n        var processed = nodes.map(function(i2) {\n            if (!i2[my$1]) Container2.rebuild(i2);\n            i2 = i2.proxyOf;\n            if (i2.parent) i2.parent.removeChild(i2);\n            if (i2[isClean$1]) markDirtyUp(i2);\n            if (typeof i2.raws.before === \"undefined\") {\n                if (sample && typeof sample.raws.before !== \"undefined\") {\n                    i2.raws.before = sample.raws.before.replace(/\\S/g, \"\");\n                }\n            }\n            i2.parent = _this.proxyOf;\n            return i2;\n        });\n        return processed;\n    };\n    _proto.prepend = function prepend() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        children = children.reverse();\n        for(var _iterator = _create_for_of_iterator_helper_loose(children), _step; !(_step = _iterator()).done;){\n            var child = _step.value;\n            var nodes = this.normalize(child, this.first, \"prepend\").reverse();\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(nodes), _step1; !(_step1 = _iterator1()).done;){\n                var node2 = _step1.value;\n                this.proxyOf.nodes.unshift(node2);\n            }\n            for(var id in this.indexes){\n                this.indexes[id] = this.indexes[id] + nodes.length;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.push = function push(child) {\n        child.parent = this;\n        this.proxyOf.nodes.push(child);\n        return this;\n    };\n    _proto.removeAll = function removeAll() {\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.proxyOf.nodes), _step; !(_step = _iterator()).done;){\n            var node2 = _step.value;\n            node2.parent = void 0;\n        }\n        this.proxyOf.nodes = [];\n        this.markDirty();\n        return this;\n    };\n    _proto.removeChild = function removeChild(child) {\n        child = this.index(child);\n        this.proxyOf.nodes[child].parent = void 0;\n        this.proxyOf.nodes.splice(child, 1);\n        var index2;\n        for(var id in this.indexes){\n            index2 = this.indexes[id];\n            if (index2 >= child) {\n                this.indexes[id] = index2 - 1;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.replaceValues = function replaceValues(pattern, opts, callback) {\n        if (!callback) {\n            callback = opts;\n            opts = {};\n        }\n        this.walkDecls(function(decl) {\n            if (opts.props && !opts.props.includes(decl.prop)) return;\n            if (opts.fast && !decl.value.includes(opts.fast)) return;\n            decl.value = decl.value.replace(pattern, callback);\n        });\n        this.markDirty();\n        return this;\n    };\n    _proto.some = function some(condition) {\n        return this.nodes.some(condition);\n    };\n    _proto.walk = function walk(callback) {\n        return this.each(function(child, i2) {\n            var result2;\n            try {\n                result2 = callback(child, i2);\n            } catch (e2) {\n                throw child.addToError(e2);\n            }\n            if (result2 !== false && child.walk) {\n                result2 = child.walk(callback);\n            }\n            return result2;\n        });\n    };\n    _proto.walkAtRules = function walkAtRules(name, callback) {\n        if (!callback) {\n            callback = name;\n            return this.walk(function(child, i2) {\n                if (child.type === \"atrule\") {\n                    return callback(child, i2);\n                }\n            });\n        }\n        if (_instanceof(name, RegExp)) {\n            return this.walk(function(child, i2) {\n                if (child.type === \"atrule\" && name.test(child.name)) {\n                    return callback(child, i2);\n                }\n            });\n        }\n        return this.walk(function(child, i2) {\n            if (child.type === \"atrule\" && child.name === name) {\n                return callback(child, i2);\n            }\n        });\n    };\n    _proto.walkComments = function walkComments(callback) {\n        return this.walk(function(child, i2) {\n            if (child.type === \"comment\") {\n                return callback(child, i2);\n            }\n        });\n    };\n    _proto.walkDecls = function walkDecls(prop, callback) {\n        if (!callback) {\n            callback = prop;\n            return this.walk(function(child, i2) {\n                if (child.type === \"decl\") {\n                    return callback(child, i2);\n                }\n            });\n        }\n        if (_instanceof(prop, RegExp)) {\n            return this.walk(function(child, i2) {\n                if (child.type === \"decl\" && prop.test(child.prop)) {\n                    return callback(child, i2);\n                }\n            });\n        }\n        return this.walk(function(child, i2) {\n            if (child.type === \"decl\" && child.prop === prop) {\n                return callback(child, i2);\n            }\n        });\n    };\n    _proto.walkRules = function walkRules(selector, callback) {\n        if (!callback) {\n            callback = selector;\n            return this.walk(function(child, i2) {\n                if (child.type === \"rule\") {\n                    return callback(child, i2);\n                }\n            });\n        }\n        if (_instanceof(selector, RegExp)) {\n            return this.walk(function(child, i2) {\n                if (child.type === \"rule\" && selector.test(child.selector)) {\n                    return callback(child, i2);\n                }\n            });\n        }\n        return this.walk(function(child, i2) {\n            if (child.type === \"rule\" && child.selector === selector) {\n                return callback(child, i2);\n            }\n        });\n    };\n    _create_class(Container2, [\n        {\n            key: \"first\",\n            get: function get() {\n                if (!this.proxyOf.nodes) return void 0;\n                return this.proxyOf.nodes[0];\n            }\n        },\n        {\n            key: \"last\",\n            get: function get() {\n                if (!this.proxyOf.nodes) return void 0;\n                return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];\n            }\n        }\n    ]);\n    return Container2;\n}(Node$1);\nContainer$7.registerParse = function(dependant) {\n    parse$4 = dependant;\n};\nContainer$7.registerRule = function(dependant) {\n    Rule$4 = dependant;\n};\nContainer$7.registerAtRule = function(dependant) {\n    AtRule$4 = dependant;\n};\nContainer$7.registerRoot = function(dependant) {\n    Root$6 = dependant;\n};\nvar container = Container$7;\nContainer$7.default = Container$7;\nContainer$7.rebuild = function(node2) {\n    if (node2.type === \"atrule\") {\n        Object.setPrototypeOf(node2, AtRule$4.prototype);\n    } else if (node2.type === \"rule\") {\n        Object.setPrototypeOf(node2, Rule$4.prototype);\n    } else if (node2.type === \"decl\") {\n        Object.setPrototypeOf(node2, Declaration$3.prototype);\n    } else if (node2.type === \"comment\") {\n        Object.setPrototypeOf(node2, Comment$3.prototype);\n    } else if (node2.type === \"root\") {\n        Object.setPrototypeOf(node2, Root$6.prototype);\n    }\n    node2[my$1] = true;\n    if (node2.nodes) {\n        node2.nodes.forEach(function(child) {\n            Container$7.rebuild(child);\n        });\n    }\n};\nvar Container$6 = container;\nvar LazyResult$4, Processor$3;\nvar Document$3 = /*#__PURE__*/ function(Container$6) {\n    _inherits(Document23, Container$6);\n    function Document23(defaults) {\n        var _this;\n        _this = Container$6.call(this, _extends({\n            type: \"document\"\n        }, defaults)) || this;\n        if (!_this.nodes) {\n            _this.nodes = [];\n        }\n        return _this;\n    }\n    var _proto = Document23.prototype;\n    _proto.toResult = function toResult(opts) {\n        if (opts === void 0) opts = {};\n        var lazy = new LazyResult$4(new Processor$3(), this, opts);\n        return lazy.stringify();\n    };\n    return Document23;\n}(Container$6);\nDocument$3.registerLazyResult = function(dependant) {\n    LazyResult$4 = dependant;\n};\nDocument$3.registerProcessor = function(dependant) {\n    Processor$3 = dependant;\n};\nvar document$1$2 = Document$3;\nDocument$3.default = Document$3;\nvar printed = {};\nvar warnOnce$2 = function warnOnce2(message) {\n    if (printed[message]) return;\n    printed[message] = true;\n    if (typeof console !== \"undefined\" && console.warn) {\n        console.warn(message);\n    }\n};\nvar Warning$2 = /*#__PURE__*/ function() {\n    function Warning2(text, opts) {\n        if (opts === void 0) opts = {};\n        this.type = \"warning\";\n        this.text = text;\n        if (opts.node && opts.node.source) {\n            var range = opts.node.rangeBy(opts);\n            this.line = range.start.line;\n            this.column = range.start.column;\n            this.endLine = range.end.line;\n            this.endColumn = range.end.column;\n        }\n        for(var opt in opts)this[opt] = opts[opt];\n    }\n    var _proto = Warning2.prototype;\n    _proto.toString = function toString() {\n        if (this.node) {\n            return this.node.error(this.text, {\n                index: this.index,\n                plugin: this.plugin,\n                word: this.word\n            }).message;\n        }\n        if (this.plugin) {\n            return this.plugin + \": \" + this.text;\n        }\n        return this.text;\n    };\n    return Warning2;\n}();\nvar warning = Warning$2;\nWarning$2.default = Warning$2;\nvar Warning$1 = warning;\nvar Result$3 = /*#__PURE__*/ function() {\n    function Result2(processor2, root2, opts) {\n        this.processor = processor2;\n        this.messages = [];\n        this.root = root2;\n        this.opts = opts;\n        this.css = void 0;\n        this.map = void 0;\n    }\n    var _proto = Result2.prototype;\n    _proto.toString = function toString() {\n        return this.css;\n    };\n    _proto.warn = function warn(text, opts) {\n        if (opts === void 0) opts = {};\n        if (!opts.plugin) {\n            if (this.lastPlugin && this.lastPlugin.postcssPlugin) {\n                opts.plugin = this.lastPlugin.postcssPlugin;\n            }\n        }\n        var warning2 = new Warning$1(text, opts);\n        this.messages.push(warning2);\n        return warning2;\n    };\n    _proto.warnings = function warnings() {\n        return this.messages.filter(function(i2) {\n            return i2.type === \"warning\";\n        });\n    };\n    _create_class(Result2, [\n        {\n            key: \"content\",\n            get: function get() {\n                return this.css;\n            }\n        }\n    ]);\n    return Result2;\n}();\nvar result = Result$3;\nResult$3.default = Result$3;\nvar SINGLE_QUOTE = \"'\".charCodeAt(0);\nvar DOUBLE_QUOTE = '\"'.charCodeAt(0);\nvar BACKSLASH = \"\\\\\".charCodeAt(0);\nvar SLASH = \"/\".charCodeAt(0);\nvar NEWLINE = \"\\n\".charCodeAt(0);\nvar SPACE = \" \".charCodeAt(0);\nvar FEED = \"\\f\".charCodeAt(0);\nvar TAB = \"\t\".charCodeAt(0);\nvar CR = \"\\r\".charCodeAt(0);\nvar OPEN_SQUARE = \"[\".charCodeAt(0);\nvar CLOSE_SQUARE = \"]\".charCodeAt(0);\nvar OPEN_PARENTHESES = \"(\".charCodeAt(0);\nvar CLOSE_PARENTHESES = \")\".charCodeAt(0);\nvar OPEN_CURLY = \"{\".charCodeAt(0);\nvar CLOSE_CURLY = \"}\".charCodeAt(0);\nvar SEMICOLON = \";\".charCodeAt(0);\nvar ASTERISK = \"*\".charCodeAt(0);\nvar COLON = \":\".charCodeAt(0);\nvar AT = \"@\".charCodeAt(0);\nvar RE_AT_END = /[\\t\\n\\f\\r \"#'()/;[\\\\\\]{}]/g;\nvar RE_WORD_END = /[\\t\\n\\f\\r !\"#'():;@[\\\\\\]{}]|\\/(?=\\*)/g;\nvar RE_BAD_BRACKET = /.[\\r\\n\"'(/\\\\]/;\nvar RE_HEX_ESCAPE = /[\\da-f]/i;\nvar tokenize = function tokenizer2(input2, options) {\n    if (options === void 0) options = {};\n    var css = input2.css.valueOf();\n    var ignore = options.ignoreErrors;\n    var code, next, quote, content, escape;\n    var escaped, escapePos, prev, n2, currentToken;\n    var length = css.length;\n    var pos = 0;\n    var buffer = [];\n    var returned = [];\n    function position() {\n        return pos;\n    }\n    function unclosed(what) {\n        throw input2.error(\"Unclosed \" + what, pos);\n    }\n    function endOfFile() {\n        return returned.length === 0 && pos >= length;\n    }\n    function nextToken(opts) {\n        if (returned.length) return returned.pop();\n        if (pos >= length) return;\n        var ignoreUnclosed = opts ? opts.ignoreUnclosed : false;\n        code = css.charCodeAt(pos);\n        switch(code){\n            case NEWLINE:\n            case SPACE:\n            case TAB:\n            case CR:\n            case FEED:\n                {\n                    next = pos;\n                    do {\n                        next += 1;\n                        code = css.charCodeAt(next);\n                    }while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);\n                    currentToken = [\n                        \"space\",\n                        css.slice(pos, next)\n                    ];\n                    pos = next - 1;\n                    break;\n                }\n            case OPEN_SQUARE:\n            case CLOSE_SQUARE:\n            case OPEN_CURLY:\n            case CLOSE_CURLY:\n            case COLON:\n            case SEMICOLON:\n            case CLOSE_PARENTHESES:\n                {\n                    var controlChar = String.fromCharCode(code);\n                    currentToken = [\n                        controlChar,\n                        controlChar,\n                        pos\n                    ];\n                    break;\n                }\n            case OPEN_PARENTHESES:\n                {\n                    prev = buffer.length ? buffer.pop()[1] : \"\";\n                    n2 = css.charCodeAt(pos + 1);\n                    if (prev === \"url\" && n2 !== SINGLE_QUOTE && n2 !== DOUBLE_QUOTE && n2 !== SPACE && n2 !== NEWLINE && n2 !== TAB && n2 !== FEED && n2 !== CR) {\n                        next = pos;\n                        do {\n                            escaped = false;\n                            next = css.indexOf(\")\", next + 1);\n                            if (next === -1) {\n                                if (ignore || ignoreUnclosed) {\n                                    next = pos;\n                                    break;\n                                } else {\n                                    unclosed(\"bracket\");\n                                }\n                            }\n                            escapePos = next;\n                            while(css.charCodeAt(escapePos - 1) === BACKSLASH){\n                                escapePos -= 1;\n                                escaped = !escaped;\n                            }\n                        }while (escaped);\n                        currentToken = [\n                            \"brackets\",\n                            css.slice(pos, next + 1),\n                            pos,\n                            next\n                        ];\n                        pos = next;\n                    } else {\n                        next = css.indexOf(\")\", pos + 1);\n                        content = css.slice(pos, next + 1);\n                        if (next === -1 || RE_BAD_BRACKET.test(content)) {\n                            currentToken = [\n                                \"(\",\n                                \"(\",\n                                pos\n                            ];\n                        } else {\n                            currentToken = [\n                                \"brackets\",\n                                content,\n                                pos,\n                                next\n                            ];\n                            pos = next;\n                        }\n                    }\n                    break;\n                }\n            case SINGLE_QUOTE:\n            case DOUBLE_QUOTE:\n                {\n                    quote = code === SINGLE_QUOTE ? \"'\" : '\"';\n                    next = pos;\n                    do {\n                        escaped = false;\n                        next = css.indexOf(quote, next + 1);\n                        if (next === -1) {\n                            if (ignore || ignoreUnclosed) {\n                                next = pos + 1;\n                                break;\n                            } else {\n                                unclosed(\"string\");\n                            }\n                        }\n                        escapePos = next;\n                        while(css.charCodeAt(escapePos - 1) === BACKSLASH){\n                            escapePos -= 1;\n                            escaped = !escaped;\n                        }\n                    }while (escaped);\n                    currentToken = [\n                        \"string\",\n                        css.slice(pos, next + 1),\n                        pos,\n                        next\n                    ];\n                    pos = next;\n                    break;\n                }\n            case AT:\n                {\n                    RE_AT_END.lastIndex = pos + 1;\n                    RE_AT_END.test(css);\n                    if (RE_AT_END.lastIndex === 0) {\n                        next = css.length - 1;\n                    } else {\n                        next = RE_AT_END.lastIndex - 2;\n                    }\n                    currentToken = [\n                        \"at-word\",\n                        css.slice(pos, next + 1),\n                        pos,\n                        next\n                    ];\n                    pos = next;\n                    break;\n                }\n            case BACKSLASH:\n                {\n                    next = pos;\n                    escape = true;\n                    while(css.charCodeAt(next + 1) === BACKSLASH){\n                        next += 1;\n                        escape = !escape;\n                    }\n                    code = css.charCodeAt(next + 1);\n                    if (escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {\n                        next += 1;\n                        if (RE_HEX_ESCAPE.test(css.charAt(next))) {\n                            while(RE_HEX_ESCAPE.test(css.charAt(next + 1))){\n                                next += 1;\n                            }\n                            if (css.charCodeAt(next + 1) === SPACE) {\n                                next += 1;\n                            }\n                        }\n                    }\n                    currentToken = [\n                        \"word\",\n                        css.slice(pos, next + 1),\n                        pos,\n                        next\n                    ];\n                    pos = next;\n                    break;\n                }\n            default:\n                {\n                    if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {\n                        next = css.indexOf(\"*/\", pos + 2) + 1;\n                        if (next === 0) {\n                            if (ignore || ignoreUnclosed) {\n                                next = css.length;\n                            } else {\n                                unclosed(\"comment\");\n                            }\n                        }\n                        currentToken = [\n                            \"comment\",\n                            css.slice(pos, next + 1),\n                            pos,\n                            next\n                        ];\n                        pos = next;\n                    } else {\n                        RE_WORD_END.lastIndex = pos + 1;\n                        RE_WORD_END.test(css);\n                        if (RE_WORD_END.lastIndex === 0) {\n                            next = css.length - 1;\n                        } else {\n                            next = RE_WORD_END.lastIndex - 2;\n                        }\n                        currentToken = [\n                            \"word\",\n                            css.slice(pos, next + 1),\n                            pos,\n                            next\n                        ];\n                        buffer.push(currentToken);\n                        pos = next;\n                    }\n                    break;\n                }\n        }\n        pos++;\n        return currentToken;\n    }\n    function back(token) {\n        returned.push(token);\n    }\n    return {\n        back: back,\n        endOfFile: endOfFile,\n        nextToken: nextToken,\n        position: position\n    };\n};\nvar Container$5 = container;\nvar AtRule$3 = /*#__PURE__*/ function(Container$5) {\n    _inherits(AtRule2, Container$5);\n    function AtRule2(defaults) {\n        var _this;\n        _this = Container$5.call(this, defaults) || this;\n        _this.type = \"atrule\";\n        return _this;\n    }\n    var _proto = AtRule2.prototype;\n    _proto.append = function append() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        var _Container$5_prototype_append;\n        if (!this.proxyOf.nodes) this.nodes = [];\n        return (_Container$5_prototype_append = Container$5.prototype.append).call.apply(_Container$5_prototype_append, [].concat([\n            this\n        ], children));\n    };\n    _proto.prepend = function prepend() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        var _Container$5_prototype_prepend;\n        if (!this.proxyOf.nodes) this.nodes = [];\n        return (_Container$5_prototype_prepend = Container$5.prototype.prepend).call.apply(_Container$5_prototype_prepend, [].concat([\n            this\n        ], children));\n    };\n    return AtRule2;\n}(Container$5);\nvar atRule = AtRule$3;\nAtRule$3.default = AtRule$3;\nContainer$5.registerAtRule(AtRule$3);\nvar Container$4 = container;\nvar LazyResult$3, Processor$2;\nvar Root$5 = /*#__PURE__*/ function(Container$4) {\n    _inherits(Root2, Container$4);\n    function Root2(defaults) {\n        var _this;\n        _this = Container$4.call(this, defaults) || this;\n        _this.type = \"root\";\n        if (!_this.nodes) _this.nodes = [];\n        return _this;\n    }\n    var _proto = Root2.prototype;\n    _proto.normalize = function normalize(child, sample, type) {\n        var nodes = Container$4.prototype.normalize.call(this, child);\n        if (sample) {\n            if (type === \"prepend\") {\n                if (this.nodes.length > 1) {\n                    sample.raws.before = this.nodes[1].raws.before;\n                } else {\n                    delete sample.raws.before;\n                }\n            } else if (this.first !== sample) {\n                for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n                    var node2 = _step.value;\n                    node2.raws.before = sample.raws.before;\n                }\n            }\n        }\n        return nodes;\n    };\n    _proto.removeChild = function removeChild(child, ignore) {\n        var index2 = this.index(child);\n        if (!ignore && index2 === 0 && this.nodes.length > 1) {\n            this.nodes[1].raws.before = this.nodes[index2].raws.before;\n        }\n        return Container$4.prototype.removeChild.call(this, child);\n    };\n    _proto.toResult = function toResult(opts) {\n        if (opts === void 0) opts = {};\n        var lazy = new LazyResult$3(new Processor$2(), this, opts);\n        return lazy.stringify();\n    };\n    return Root2;\n}(Container$4);\nRoot$5.registerLazyResult = function(dependant) {\n    LazyResult$3 = dependant;\n};\nRoot$5.registerProcessor = function(dependant) {\n    Processor$2 = dependant;\n};\nvar root = Root$5;\nRoot$5.default = Root$5;\nContainer$4.registerRoot(Root$5);\nvar list$2 = {\n    comma: function comma(string) {\n        return list$2.split(string, [\n            \",\"\n        ], true);\n    },\n    space: function space(string) {\n        var spaces = [\n            \" \",\n            \"\\n\",\n            \"\t\"\n        ];\n        return list$2.split(string, spaces);\n    },\n    split: function split(string, separators, last) {\n        var array = [];\n        var current = \"\";\n        var split = false;\n        var func = 0;\n        var inQuote = false;\n        var prevQuote = \"\";\n        var escape = false;\n        for(var _iterator = _create_for_of_iterator_helper_loose(string), _step; !(_step = _iterator()).done;){\n            var letter = _step.value;\n            if (escape) {\n                escape = false;\n            } else if (letter === \"\\\\\") {\n                escape = true;\n            } else if (inQuote) {\n                if (letter === prevQuote) {\n                    inQuote = false;\n                }\n            } else if (letter === '\"' || letter === \"'\") {\n                inQuote = true;\n                prevQuote = letter;\n            } else if (letter === \"(\") {\n                func += 1;\n            } else if (letter === \")\") {\n                if (func > 0) func -= 1;\n            } else if (func === 0) {\n                if (separators.includes(letter)) split = true;\n            }\n            if (split) {\n                if (current !== \"\") array.push(current.trim());\n                current = \"\";\n                split = false;\n            } else {\n                current += letter;\n            }\n        }\n        if (last || current !== \"\") array.push(current.trim());\n        return array;\n    }\n};\nvar list_1 = list$2;\nlist$2.default = list$2;\nvar Container$3 = container;\nvar list$1 = list_1;\nvar Rule$3 = /*#__PURE__*/ function(Container$3) {\n    _inherits(Rule2, Container$3);\n    function Rule2(defaults) {\n        var _this;\n        _this = Container$3.call(this, defaults) || this;\n        _this.type = \"rule\";\n        if (!_this.nodes) _this.nodes = [];\n        return _this;\n    }\n    _create_class(Rule2, [\n        {\n            key: \"selectors\",\n            get: function get() {\n                return list$1.comma(this.selector);\n            },\n            set: function set(values) {\n                var match = this.selector ? this.selector.match(/,\\s*/) : null;\n                var sep2 = match ? match[0] : \",\" + this.raw(\"between\", \"beforeOpen\");\n                this.selector = values.join(sep2);\n            }\n        }\n    ]);\n    return Rule2;\n}(Container$3);\nvar rule = Rule$3;\nRule$3.default = Rule$3;\nContainer$3.registerRule(Rule$3);\nvar Declaration$2 = declaration;\nvar tokenizer22 = tokenize;\nvar Comment$2 = comment;\nvar AtRule$2 = atRule;\nvar Root$4 = root;\nvar Rule$2 = rule;\nvar SAFE_COMMENT_NEIGHBOR = {\n    empty: true,\n    space: true\n};\nfunction findLastWithPosition(tokens) {\n    for(var i2 = tokens.length - 1; i2 >= 0; i2--){\n        var token = tokens[i2];\n        var pos = token[3] || token[2];\n        if (pos) return pos;\n    }\n}\nvar Parser$1 = /*#__PURE__*/ function() {\n    function Parser2(input2) {\n        this.input = input2;\n        this.root = new Root$4();\n        this.current = this.root;\n        this.spaces = \"\";\n        this.semicolon = false;\n        this.createTokenizer();\n        this.root.source = {\n            input: input2,\n            start: {\n                column: 1,\n                line: 1,\n                offset: 0\n            }\n        };\n    }\n    var _proto = Parser2.prototype;\n    _proto.atrule = function atrule(token) {\n        var node2 = new AtRule$2();\n        node2.name = token[1].slice(1);\n        if (node2.name === \"\") {\n            this.unnamedAtrule(node2, token);\n        }\n        this.init(node2, token[2]);\n        var type;\n        var prev;\n        var shift;\n        var last = false;\n        var open = false;\n        var params = [];\n        var brackets = [];\n        while(!this.tokenizer.endOfFile()){\n            token = this.tokenizer.nextToken();\n            type = token[0];\n            if (type === \"(\" || type === \"[\") {\n                brackets.push(type === \"(\" ? \")\" : \"]\");\n            } else if (type === \"{\" && brackets.length > 0) {\n                brackets.push(\"}\");\n            } else if (type === brackets[brackets.length - 1]) {\n                brackets.pop();\n            }\n            if (brackets.length === 0) {\n                if (type === \";\") {\n                    node2.source.end = this.getPosition(token[2]);\n                    node2.source.end.offset++;\n                    this.semicolon = true;\n                    break;\n                } else if (type === \"{\") {\n                    open = true;\n                    break;\n                } else if (type === \"}\") {\n                    if (params.length > 0) {\n                        shift = params.length - 1;\n                        prev = params[shift];\n                        while(prev && prev[0] === \"space\"){\n                            prev = params[--shift];\n                        }\n                        if (prev) {\n                            node2.source.end = this.getPosition(prev[3] || prev[2]);\n                            node2.source.end.offset++;\n                        }\n                    }\n                    this.end(token);\n                    break;\n                } else {\n                    params.push(token);\n                }\n            } else {\n                params.push(token);\n            }\n            if (this.tokenizer.endOfFile()) {\n                last = true;\n                break;\n            }\n        }\n        node2.raws.between = this.spacesAndCommentsFromEnd(params);\n        if (params.length) {\n            node2.raws.afterName = this.spacesAndCommentsFromStart(params);\n            this.raw(node2, \"params\", params);\n            if (last) {\n                token = params[params.length - 1];\n                node2.source.end = this.getPosition(token[3] || token[2]);\n                node2.source.end.offset++;\n                this.spaces = node2.raws.between;\n                node2.raws.between = \"\";\n            }\n        } else {\n            node2.raws.afterName = \"\";\n            node2.params = \"\";\n        }\n        if (open) {\n            node2.nodes = [];\n            this.current = node2;\n        }\n    };\n    _proto.checkMissedSemicolon = function checkMissedSemicolon(tokens) {\n        var colon = this.colon(tokens);\n        if (colon === false) return;\n        var founded = 0;\n        var token;\n        for(var j = colon - 1; j >= 0; j--){\n            token = tokens[j];\n            if (token[0] !== \"space\") {\n                founded += 1;\n                if (founded === 2) break;\n            }\n        }\n        throw this.input.error(\"Missed semicolon\", token[0] === \"word\" ? token[3] + 1 : token[2]);\n    };\n    _proto.colon = function colon(tokens) {\n        var brackets = 0;\n        var token, type, prev;\n        for(var _iterator = _create_for_of_iterator_helper_loose(tokens.entries()), _step; !(_step = _iterator()).done;){\n            var _step_value = _step.value, i2 = _step_value[0], element = _step_value[1];\n            token = element;\n            type = token[0];\n            if (type === \"(\") {\n                brackets += 1;\n            }\n            if (type === \")\") {\n                brackets -= 1;\n            }\n            if (brackets === 0 && type === \":\") {\n                if (!prev) {\n                    this.doubleColon(token);\n                } else if (prev[0] === \"word\" && prev[1] === \"progid\") {\n                    continue;\n                } else {\n                    return i2;\n                }\n            }\n            prev = token;\n        }\n        return false;\n    };\n    _proto.comment = function comment(token) {\n        var node2 = new Comment$2();\n        this.init(node2, token[2]);\n        node2.source.end = this.getPosition(token[3] || token[2]);\n        node2.source.end.offset++;\n        var text = token[1].slice(2, -2);\n        if (/^\\s*$/.test(text)) {\n            node2.text = \"\";\n            node2.raws.left = text;\n            node2.raws.right = \"\";\n        } else {\n            var match = text.match(/^(\\s*)([^]*\\S)(\\s*)$/);\n            node2.text = match[2];\n            node2.raws.left = match[1];\n            node2.raws.right = match[3];\n        }\n    };\n    _proto.createTokenizer = function createTokenizer() {\n        this.tokenizer = tokenizer22(this.input);\n    };\n    _proto.decl = function decl(tokens, customProperty) {\n        var node2 = new Declaration$2();\n        this.init(node2, tokens[0][2]);\n        var last = tokens[tokens.length - 1];\n        if (last[0] === \";\") {\n            this.semicolon = true;\n            tokens.pop();\n        }\n        node2.source.end = this.getPosition(last[3] || last[2] || findLastWithPosition(tokens));\n        node2.source.end.offset++;\n        while(tokens[0][0] !== \"word\"){\n            if (tokens.length === 1) this.unknownWord(tokens);\n            node2.raws.before += tokens.shift()[1];\n        }\n        node2.source.start = this.getPosition(tokens[0][2]);\n        node2.prop = \"\";\n        while(tokens.length){\n            var type = tokens[0][0];\n            if (type === \":\" || type === \"space\" || type === \"comment\") {\n                break;\n            }\n            node2.prop += tokens.shift()[1];\n        }\n        node2.raws.between = \"\";\n        var token;\n        while(tokens.length){\n            token = tokens.shift();\n            if (token[0] === \":\") {\n                node2.raws.between += token[1];\n                break;\n            } else {\n                if (token[0] === \"word\" && /\\w/.test(token[1])) {\n                    this.unknownWord([\n                        token\n                    ]);\n                }\n                node2.raws.between += token[1];\n            }\n        }\n        if (node2.prop[0] === \"_\" || node2.prop[0] === \"*\") {\n            node2.raws.before += node2.prop[0];\n            node2.prop = node2.prop.slice(1);\n        }\n        var firstSpaces = [];\n        var next;\n        while(tokens.length){\n            next = tokens[0][0];\n            if (next !== \"space\" && next !== \"comment\") break;\n            firstSpaces.push(tokens.shift());\n        }\n        this.precheckMissedSemicolon(tokens);\n        for(var i2 = tokens.length - 1; i2 >= 0; i2--){\n            token = tokens[i2];\n            if (token[1].toLowerCase() === \"!important\") {\n                node2.important = true;\n                var string = this.stringFrom(tokens, i2);\n                string = this.spacesFromEnd(tokens) + string;\n                if (string !== \" !important\") node2.raws.important = string;\n                break;\n            } else if (token[1].toLowerCase() === \"important\") {\n                var cache = tokens.slice(0);\n                var str = \"\";\n                for(var j = i2; j > 0; j--){\n                    var type1 = cache[j][0];\n                    if (str.trim().indexOf(\"!\") === 0 && type1 !== \"space\") {\n                        break;\n                    }\n                    str = cache.pop()[1] + str;\n                }\n                if (str.trim().indexOf(\"!\") === 0) {\n                    node2.important = true;\n                    node2.raws.important = str;\n                    tokens = cache;\n                }\n            }\n            if (token[0] !== \"space\" && token[0] !== \"comment\") {\n                break;\n            }\n        }\n        var hasWord = tokens.some(function(i2) {\n            return i2[0] !== \"space\" && i2[0] !== \"comment\";\n        });\n        if (hasWord) {\n            node2.raws.between += firstSpaces.map(function(i2) {\n                return i2[1];\n            }).join(\"\");\n            firstSpaces = [];\n        }\n        this.raw(node2, \"value\", firstSpaces.concat(tokens), customProperty);\n        if (node2.value.includes(\":\") && !customProperty) {\n            this.checkMissedSemicolon(tokens);\n        }\n    };\n    _proto.doubleColon = function doubleColon(token) {\n        throw this.input.error(\"Double colon\", {\n            offset: token[2]\n        }, {\n            offset: token[2] + token[1].length\n        });\n    };\n    _proto.emptyRule = function emptyRule(token) {\n        var node2 = new Rule$2();\n        this.init(node2, token[2]);\n        node2.selector = \"\";\n        node2.raws.between = \"\";\n        this.current = node2;\n    };\n    _proto.end = function end(token) {\n        if (this.current.nodes && this.current.nodes.length) {\n            this.current.raws.semicolon = this.semicolon;\n        }\n        this.semicolon = false;\n        this.current.raws.after = (this.current.raws.after || \"\") + this.spaces;\n        this.spaces = \"\";\n        if (this.current.parent) {\n            this.current.source.end = this.getPosition(token[2]);\n            this.current.source.end.offset++;\n            this.current = this.current.parent;\n        } else {\n            this.unexpectedClose(token);\n        }\n    };\n    _proto.endFile = function endFile() {\n        if (this.current.parent) this.unclosedBlock();\n        if (this.current.nodes && this.current.nodes.length) {\n            this.current.raws.semicolon = this.semicolon;\n        }\n        this.current.raws.after = (this.current.raws.after || \"\") + this.spaces;\n        this.root.source.end = this.getPosition(this.tokenizer.position());\n    };\n    _proto.freeSemicolon = function freeSemicolon(token) {\n        this.spaces += token[1];\n        if (this.current.nodes) {\n            var prev = this.current.nodes[this.current.nodes.length - 1];\n            if (prev && prev.type === \"rule\" && !prev.raws.ownSemicolon) {\n                prev.raws.ownSemicolon = this.spaces;\n                this.spaces = \"\";\n            }\n        }\n    };\n    // Helpers\n    _proto.getPosition = function getPosition(offset) {\n        var pos = this.input.fromOffset(offset);\n        return {\n            column: pos.col,\n            line: pos.line,\n            offset: offset\n        };\n    };\n    _proto.init = function init(node2, offset) {\n        this.current.push(node2);\n        node2.source = {\n            input: this.input,\n            start: this.getPosition(offset)\n        };\n        node2.raws.before = this.spaces;\n        this.spaces = \"\";\n        if (node2.type !== \"comment\") this.semicolon = false;\n    };\n    _proto.other = function other(start) {\n        var end = false;\n        var type = null;\n        var colon = false;\n        var bracket = null;\n        var brackets = [];\n        var customProperty = start[1].startsWith(\"--\");\n        var tokens = [];\n        var token = start;\n        while(token){\n            type = token[0];\n            tokens.push(token);\n            if (type === \"(\" || type === \"[\") {\n                if (!bracket) bracket = token;\n                brackets.push(type === \"(\" ? \")\" : \"]\");\n            } else if (customProperty && colon && type === \"{\") {\n                if (!bracket) bracket = token;\n                brackets.push(\"}\");\n            } else if (brackets.length === 0) {\n                if (type === \";\") {\n                    if (colon) {\n                        this.decl(tokens, customProperty);\n                        return;\n                    } else {\n                        break;\n                    }\n                } else if (type === \"{\") {\n                    this.rule(tokens);\n                    return;\n                } else if (type === \"}\") {\n                    this.tokenizer.back(tokens.pop());\n                    end = true;\n                    break;\n                } else if (type === \":\") {\n                    colon = true;\n                }\n            } else if (type === brackets[brackets.length - 1]) {\n                brackets.pop();\n                if (brackets.length === 0) bracket = null;\n            }\n            token = this.tokenizer.nextToken();\n        }\n        if (this.tokenizer.endOfFile()) end = true;\n        if (brackets.length > 0) this.unclosedBracket(bracket);\n        if (end && colon) {\n            if (!customProperty) {\n                while(tokens.length){\n                    token = tokens[tokens.length - 1][0];\n                    if (token !== \"space\" && token !== \"comment\") break;\n                    this.tokenizer.back(tokens.pop());\n                }\n            }\n            this.decl(tokens, customProperty);\n        } else {\n            this.unknownWord(tokens);\n        }\n    };\n    _proto.parse = function parse() {\n        var token;\n        while(!this.tokenizer.endOfFile()){\n            token = this.tokenizer.nextToken();\n            switch(token[0]){\n                case \"space\":\n                    this.spaces += token[1];\n                    break;\n                case \";\":\n                    this.freeSemicolon(token);\n                    break;\n                case \"}\":\n                    this.end(token);\n                    break;\n                case \"comment\":\n                    this.comment(token);\n                    break;\n                case \"at-word\":\n                    this.atrule(token);\n                    break;\n                case \"{\":\n                    this.emptyRule(token);\n                    break;\n                default:\n                    this.other(token);\n                    break;\n            }\n        }\n        this.endFile();\n    };\n    _proto.precheckMissedSemicolon = function precheckMissedSemicolon() {};\n    _proto.raw = function raw(node2, prop, tokens, customProperty) {\n        var token, type;\n        var length = tokens.length;\n        var value = \"\";\n        var clean = true;\n        var next, prev;\n        for(var i2 = 0; i2 < length; i2 += 1){\n            token = tokens[i2];\n            type = token[0];\n            if (type === \"space\" && i2 === length - 1 && !customProperty) {\n                clean = false;\n            } else if (type === \"comment\") {\n                prev = tokens[i2 - 1] ? tokens[i2 - 1][0] : \"empty\";\n                next = tokens[i2 + 1] ? tokens[i2 + 1][0] : \"empty\";\n                if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {\n                    if (value.slice(-1) === \",\") {\n                        clean = false;\n                    } else {\n                        value += token[1];\n                    }\n                } else {\n                    clean = false;\n                }\n            } else {\n                value += token[1];\n            }\n        }\n        if (!clean) {\n            var raw = tokens.reduce(function(all, i2) {\n                return all + i2[1];\n            }, \"\");\n            node2.raws[prop] = {\n                raw: raw,\n                value: value\n            };\n        }\n        node2[prop] = value;\n    };\n    _proto.rule = function rule(tokens) {\n        tokens.pop();\n        var node2 = new Rule$2();\n        this.init(node2, tokens[0][2]);\n        node2.raws.between = this.spacesAndCommentsFromEnd(tokens);\n        this.raw(node2, \"selector\", tokens);\n        this.current = node2;\n    };\n    _proto.spacesAndCommentsFromEnd = function spacesAndCommentsFromEnd(tokens) {\n        var lastTokenType;\n        var spaces = \"\";\n        while(tokens.length){\n            lastTokenType = tokens[tokens.length - 1][0];\n            if (lastTokenType !== \"space\" && lastTokenType !== \"comment\") break;\n            spaces = tokens.pop()[1] + spaces;\n        }\n        return spaces;\n    };\n    // Errors\n    _proto.spacesAndCommentsFromStart = function spacesAndCommentsFromStart(tokens) {\n        var next;\n        var spaces = \"\";\n        while(tokens.length){\n            next = tokens[0][0];\n            if (next !== \"space\" && next !== \"comment\") break;\n            spaces += tokens.shift()[1];\n        }\n        return spaces;\n    };\n    _proto.spacesFromEnd = function spacesFromEnd(tokens) {\n        var lastTokenType;\n        var spaces = \"\";\n        while(tokens.length){\n            lastTokenType = tokens[tokens.length - 1][0];\n            if (lastTokenType !== \"space\") break;\n            spaces = tokens.pop()[1] + spaces;\n        }\n        return spaces;\n    };\n    _proto.stringFrom = function stringFrom(tokens, from) {\n        var result2 = \"\";\n        for(var i2 = from; i2 < tokens.length; i2++){\n            result2 += tokens[i2][1];\n        }\n        tokens.splice(from, tokens.length - from);\n        return result2;\n    };\n    _proto.unclosedBlock = function unclosedBlock() {\n        var pos = this.current.source.start;\n        throw this.input.error(\"Unclosed block\", pos.line, pos.column);\n    };\n    _proto.unclosedBracket = function unclosedBracket(bracket) {\n        throw this.input.error(\"Unclosed bracket\", {\n            offset: bracket[2]\n        }, {\n            offset: bracket[2] + 1\n        });\n    };\n    _proto.unexpectedClose = function unexpectedClose(token) {\n        throw this.input.error(\"Unexpected }\", {\n            offset: token[2]\n        }, {\n            offset: token[2] + 1\n        });\n    };\n    _proto.unknownWord = function unknownWord(tokens) {\n        throw this.input.error(\"Unknown word\", {\n            offset: tokens[0][2]\n        }, {\n            offset: tokens[0][2] + tokens[0][1].length\n        });\n    };\n    _proto.unnamedAtrule = function unnamedAtrule(node2, token) {\n        throw this.input.error(\"At-rule without name\", {\n            offset: token[2]\n        }, {\n            offset: token[2] + token[1].length\n        });\n    };\n    return Parser2;\n}();\nvar parser = Parser$1;\nvar Container$2 = container;\nvar Parser22 = parser;\nvar Input$2 = input;\nfunction parse$3(css, opts) {\n    var input2 = new Input$2(css, opts);\n    var parser2 = new Parser22(input2);\n    try {\n        parser2.parse();\n    } catch (e2) {\n        if (true) {\n            if (e2.name === \"CssSyntaxError\" && opts && opts.from) {\n                if (/\\.scss$/i.test(opts.from)) {\n                    e2.message += \"\\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser\";\n                } else if (/\\.sass/i.test(opts.from)) {\n                    e2.message += \"\\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser\";\n                } else if (/\\.less$/i.test(opts.from)) {\n                    e2.message += \"\\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser\";\n                }\n            }\n        }\n        throw e2;\n    }\n    return parser2.root;\n}\nvar parse_1 = parse$3;\nparse$3.default = parse$3;\nContainer$2.registerParse(parse$3);\nvar isClean = symbols.isClean, my = symbols.my;\nvar MapGenerator$1 = mapGenerator;\nvar stringify$2 = stringify_1;\nvar Container$1 = container;\nvar Document$2 = document$1$2;\nvar warnOnce$1 = warnOnce$2;\nvar Result$2 = result;\nvar parse$2 = parse_1;\nvar Root$3 = root;\nvar TYPE_TO_CLASS_NAME = {\n    atrule: \"AtRule\",\n    comment: \"Comment\",\n    decl: \"Declaration\",\n    document: \"Document\",\n    root: \"Root\",\n    rule: \"Rule\"\n};\nvar PLUGIN_PROPS = {\n    AtRule: true,\n    AtRuleExit: true,\n    Comment: true,\n    CommentExit: true,\n    Declaration: true,\n    DeclarationExit: true,\n    Document: true,\n    DocumentExit: true,\n    Once: true,\n    OnceExit: true,\n    postcssPlugin: true,\n    prepare: true,\n    Root: true,\n    RootExit: true,\n    Rule: true,\n    RuleExit: true\n};\nvar NOT_VISITORS = {\n    Once: true,\n    postcssPlugin: true,\n    prepare: true\n};\nvar CHILDREN = 0;\nfunction isPromise(obj) {\n    return (typeof obj === \"undefined\" ? \"undefined\" : _type_of(obj)) === \"object\" && typeof obj.then === \"function\";\n}\nfunction getEvents(node2) {\n    var key = false;\n    var type = TYPE_TO_CLASS_NAME[node2.type];\n    if (node2.type === \"decl\") {\n        key = node2.prop.toLowerCase();\n    } else if (node2.type === \"atrule\") {\n        key = node2.name.toLowerCase();\n    }\n    if (key && node2.append) {\n        return [\n            type,\n            type + \"-\" + key,\n            CHILDREN,\n            type + \"Exit\",\n            type + \"Exit-\" + key\n        ];\n    } else if (key) {\n        return [\n            type,\n            type + \"-\" + key,\n            type + \"Exit\",\n            type + \"Exit-\" + key\n        ];\n    } else if (node2.append) {\n        return [\n            type,\n            CHILDREN,\n            type + \"Exit\"\n        ];\n    } else {\n        return [\n            type,\n            type + \"Exit\"\n        ];\n    }\n}\nfunction toStack(node2) {\n    var events;\n    if (node2.type === \"document\") {\n        events = [\n            \"Document\",\n            CHILDREN,\n            \"DocumentExit\"\n        ];\n    } else if (node2.type === \"root\") {\n        events = [\n            \"Root\",\n            CHILDREN,\n            \"RootExit\"\n        ];\n    } else {\n        events = getEvents(node2);\n    }\n    return {\n        eventIndex: 0,\n        events: events,\n        iterator: 0,\n        node: node2,\n        visitorIndex: 0,\n        visitors: []\n    };\n}\nfunction cleanMarks(node2) {\n    node2[isClean] = false;\n    if (node2.nodes) node2.nodes.forEach(function(i2) {\n        return cleanMarks(i2);\n    });\n    return node2;\n}\nvar postcss$2 = {};\nvar LazyResult$2 = /*#__PURE__*/ function() {\n    function LazyResult2(processor2, css, opts) {\n        var _this = this;\n        this.stringified = false;\n        this.processed = false;\n        var root2;\n        if ((typeof css === \"undefined\" ? \"undefined\" : _type_of(css)) === \"object\" && css !== null && (css.type === \"root\" || css.type === \"document\")) {\n            root2 = cleanMarks(css);\n        } else if (_instanceof(css, LazyResult2) || _instanceof(css, Result$2)) {\n            root2 = cleanMarks(css.root);\n            if (css.map) {\n                if (typeof opts.map === \"undefined\") opts.map = {};\n                if (!opts.map.inline) opts.map.inline = false;\n                opts.map.prev = css.map;\n            }\n        } else {\n            var parser2 = parse$2;\n            if (opts.syntax) parser2 = opts.syntax.parse;\n            if (opts.parser) parser2 = opts.parser;\n            if (parser2.parse) parser2 = parser2.parse;\n            try {\n                root2 = parser2(css, opts);\n            } catch (error) {\n                this.processed = true;\n                this.error = error;\n            }\n            if (root2 && !root2[my]) {\n                Container$1.rebuild(root2);\n            }\n        }\n        this.result = new Result$2(processor2, root2, opts);\n        this.helpers = _extends({}, postcss$2, {\n            postcss: postcss$2,\n            result: this.result\n        });\n        this.plugins = this.processor.plugins.map(function(plugin22) {\n            if ((typeof plugin22 === \"undefined\" ? \"undefined\" : _type_of(plugin22)) === \"object\" && plugin22.prepare) {\n                return _extends({}, plugin22, plugin22.prepare(_this.result));\n            } else {\n                return plugin22;\n            }\n        });\n    }\n    var _proto = LazyResult2.prototype;\n    _proto.async = function async() {\n        if (this.error) return Promise.reject(this.error);\n        if (this.processed) return Promise.resolve(this.result);\n        if (!this.processing) {\n            this.processing = this.runAsync();\n        }\n        return this.processing;\n    };\n    _proto.catch = function _catch(onRejected) {\n        return this.async().catch(onRejected);\n    };\n    _proto.finally = function _finally(onFinally) {\n        return this.async().then(onFinally, onFinally);\n    };\n    _proto.getAsyncError = function getAsyncError() {\n        throw new Error(\"Use process(css).then(cb) to work with async plugins\");\n    };\n    _proto.handleError = function handleError(error, node2) {\n        var plugin22 = this.result.lastPlugin;\n        try {\n            if (node2) node2.addToError(error);\n            this.error = error;\n            if (error.name === \"CssSyntaxError\" && !error.plugin) {\n                error.plugin = plugin22.postcssPlugin;\n                error.setMessage();\n            } else if (plugin22.postcssVersion) {\n                if (true) {\n                    var pluginName = plugin22.postcssPlugin;\n                    var pluginVer = plugin22.postcssVersion;\n                    var runtimeVer = this.result.processor.version;\n                    var a2 = pluginVer.split(\".\");\n                    var b = runtimeVer.split(\".\");\n                    if (a2[0] !== b[0] || parseInt(a2[1]) > parseInt(b[1])) {\n                        console.error(\"Unknown error from PostCSS plugin. Your current PostCSS version is \" + runtimeVer + \", but \" + pluginName + \" uses \" + pluginVer + \". Perhaps this is the source of the error below.\");\n                    }\n                }\n            }\n        } catch (err) {\n            if (console && console.error) console.error(err);\n        }\n        return error;\n    };\n    _proto.prepareVisitors = function prepareVisitors() {\n        var _this = this;\n        this.listeners = {};\n        var add = function(plugin22, type, cb) {\n            if (!_this.listeners[type]) _this.listeners[type] = [];\n            _this.listeners[type].push([\n                plugin22,\n                cb\n            ]);\n        };\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.plugins), _step; !(_step = _iterator()).done;){\n            var plugin22 = _step.value;\n            if ((typeof plugin22 === \"undefined\" ? \"undefined\" : _type_of(plugin22)) === \"object\") {\n                for(var event in plugin22){\n                    if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {\n                        throw new Error(\"Unknown event \" + event + \" in \" + plugin22.postcssPlugin + \". Try to update PostCSS (\" + this.processor.version + \" now).\");\n                    }\n                    if (!NOT_VISITORS[event]) {\n                        if (_type_of(plugin22[event]) === \"object\") {\n                            for(var filter in plugin22[event]){\n                                if (filter === \"*\") {\n                                    add(plugin22, event, plugin22[event][filter]);\n                                } else {\n                                    add(plugin22, event + \"-\" + filter.toLowerCase(), plugin22[event][filter]);\n                                }\n                            }\n                        } else if (typeof plugin22[event] === \"function\") {\n                            add(plugin22, event, plugin22[event]);\n                        }\n                    }\n                }\n            }\n        }\n        this.hasListener = Object.keys(this.listeners).length > 0;\n    };\n    _proto.runAsync = function runAsync() {\n        var _this = this;\n        return _async_to_generator(function() {\n            var i2, plugin22, promise, error, root2, stack, promise1, e2, node2, _loop, _iterator, _step;\n            return _ts_generator(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        _this.plugin = 0;\n                        i2 = 0;\n                        _state.label = 1;\n                    case 1:\n                        if (!(i2 < _this.plugins.length)) return [\n                            3,\n                            6\n                        ];\n                        plugin22 = _this.plugins[i2];\n                        promise = _this.runOnRoot(plugin22);\n                        if (!isPromise(promise)) return [\n                            3,\n                            5\n                        ];\n                        _state.label = 2;\n                    case 2:\n                        _state.trys.push([\n                            2,\n                            4,\n                            ,\n                            5\n                        ]);\n                        return [\n                            4,\n                            promise\n                        ];\n                    case 3:\n                        _state.sent();\n                        return [\n                            3,\n                            5\n                        ];\n                    case 4:\n                        error = _state.sent();\n                        throw _this.handleError(error);\n                    case 5:\n                        i2++;\n                        return [\n                            3,\n                            1\n                        ];\n                    case 6:\n                        _this.prepareVisitors();\n                        if (!_this.hasListener) return [\n                            3,\n                            18\n                        ];\n                        root2 = _this.result.root;\n                        _state.label = 7;\n                    case 7:\n                        if (!!root2[isClean]) return [\n                            3,\n                            14\n                        ];\n                        root2[isClean] = true;\n                        stack = [\n                            toStack(root2)\n                        ];\n                        _state.label = 8;\n                    case 8:\n                        if (!(stack.length > 0)) return [\n                            3,\n                            13\n                        ];\n                        promise1 = _this.visitTick(stack);\n                        if (!isPromise(promise1)) return [\n                            3,\n                            12\n                        ];\n                        _state.label = 9;\n                    case 9:\n                        _state.trys.push([\n                            9,\n                            11,\n                            ,\n                            12\n                        ]);\n                        return [\n                            4,\n                            promise1\n                        ];\n                    case 10:\n                        _state.sent();\n                        return [\n                            3,\n                            12\n                        ];\n                    case 11:\n                        e2 = _state.sent();\n                        node2 = stack[stack.length - 1].node;\n                        throw _this.handleError(e2, node2);\n                    case 12:\n                        return [\n                            3,\n                            8\n                        ];\n                    case 13:\n                        return [\n                            3,\n                            7\n                        ];\n                    case 14:\n                        if (!_this.listeners.OnceExit) return [\n                            3,\n                            18\n                        ];\n                        _loop = function() {\n                            var _step_value, plugin22, visitor, roots, e2;\n                            return _ts_generator(this, function(_state) {\n                                switch(_state.label){\n                                    case 0:\n                                        _step_value = _step.value, plugin22 = _step_value[0], visitor = _step_value[1];\n                                        _this.result.lastPlugin = plugin22;\n                                        _state.label = 1;\n                                    case 1:\n                                        _state.trys.push([\n                                            1,\n                                            6,\n                                            ,\n                                            7\n                                        ]);\n                                        if (!(root2.type === \"document\")) return [\n                                            3,\n                                            3\n                                        ];\n                                        roots = root2.nodes.map(function(subRoot) {\n                                            return visitor(subRoot, _this.helpers);\n                                        });\n                                        return [\n                                            4,\n                                            Promise.all(roots)\n                                        ];\n                                    case 2:\n                                        _state.sent();\n                                        return [\n                                            3,\n                                            5\n                                        ];\n                                    case 3:\n                                        return [\n                                            4,\n                                            visitor(root2, _this.helpers)\n                                        ];\n                                    case 4:\n                                        _state.sent();\n                                        _state.label = 5;\n                                    case 5:\n                                        return [\n                                            3,\n                                            7\n                                        ];\n                                    case 6:\n                                        e2 = _state.sent();\n                                        throw _this.handleError(e2);\n                                    case 7:\n                                        return [\n                                            2\n                                        ];\n                                }\n                            });\n                        };\n                        _iterator = _create_for_of_iterator_helper_loose(_this.listeners.OnceExit);\n                        _state.label = 15;\n                    case 15:\n                        if (!!(_step = _iterator()).done) return [\n                            3,\n                            18\n                        ];\n                        return [\n                            5,\n                            _ts_values(_loop())\n                        ];\n                    case 16:\n                        _state.sent();\n                        _state.label = 17;\n                    case 17:\n                        return [\n                            3,\n                            15\n                        ];\n                    case 18:\n                        _this.processed = true;\n                        return [\n                            2,\n                            _this.stringify()\n                        ];\n                }\n            });\n        })();\n    };\n    _proto.runOnRoot = function runOnRoot(plugin22) {\n        var _this = this;\n        this.result.lastPlugin = plugin22;\n        try {\n            if ((typeof plugin22 === \"undefined\" ? \"undefined\" : _type_of(plugin22)) === \"object\" && plugin22.Once) {\n                if (this.result.root.type === \"document\") {\n                    var roots = this.result.root.nodes.map(function(root2) {\n                        return plugin22.Once(root2, _this.helpers);\n                    });\n                    if (isPromise(roots[0])) {\n                        return Promise.all(roots);\n                    }\n                    return roots;\n                }\n                return plugin22.Once(this.result.root, this.helpers);\n            } else if (typeof plugin22 === \"function\") {\n                return plugin22(this.result.root, this.result);\n            }\n        } catch (error) {\n            throw this.handleError(error);\n        }\n    };\n    _proto.stringify = function stringify() {\n        if (this.error) throw this.error;\n        if (this.stringified) return this.result;\n        this.stringified = true;\n        this.sync();\n        var opts = this.result.opts;\n        var str = stringify$2;\n        if (opts.syntax) str = opts.syntax.stringify;\n        if (opts.stringifier) str = opts.stringifier;\n        if (str.stringify) str = str.stringify;\n        var map = new MapGenerator$1(str, this.result.root, this.result.opts);\n        var data = map.generate();\n        this.result.css = data[0];\n        this.result.map = data[1];\n        return this.result;\n    };\n    _proto.sync = function sync() {\n        if (this.error) throw this.error;\n        if (this.processed) return this.result;\n        this.processed = true;\n        if (this.processing) {\n            throw this.getAsyncError();\n        }\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.plugins), _step; !(_step = _iterator()).done;){\n            var plugin22 = _step.value;\n            var promise = this.runOnRoot(plugin22);\n            if (isPromise(promise)) {\n                throw this.getAsyncError();\n            }\n        }\n        this.prepareVisitors();\n        if (this.hasListener) {\n            var root2 = this.result.root;\n            while(!root2[isClean]){\n                root2[isClean] = true;\n                this.walkSync(root2);\n            }\n            if (this.listeners.OnceExit) {\n                if (root2.type === \"document\") {\n                    for(var _iterator1 = _create_for_of_iterator_helper_loose(root2.nodes), _step1; !(_step1 = _iterator1()).done;){\n                        var subRoot = _step1.value;\n                        this.visitSync(this.listeners.OnceExit, subRoot);\n                    }\n                } else {\n                    this.visitSync(this.listeners.OnceExit, root2);\n                }\n            }\n        }\n        return this.result;\n    };\n    _proto.then = function then(onFulfilled, onRejected) {\n        if (true) {\n            if (!(\"from\" in this.opts)) {\n                warnOnce$1(\"Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.\");\n            }\n        }\n        return this.async().then(onFulfilled, onRejected);\n    };\n    _proto.toString = function toString() {\n        return this.css;\n    };\n    _proto.visitSync = function visitSync(visitors, node2) {\n        for(var _iterator = _create_for_of_iterator_helper_loose(visitors), _step; !(_step = _iterator()).done;){\n            var _step_value = _step.value, plugin22 = _step_value[0], visitor = _step_value[1];\n            this.result.lastPlugin = plugin22;\n            var promise = void 0;\n            try {\n                promise = visitor(node2, this.helpers);\n            } catch (e2) {\n                throw this.handleError(e2, node2.proxyOf);\n            }\n            if (node2.type !== \"root\" && node2.type !== \"document\" && !node2.parent) {\n                return true;\n            }\n            if (isPromise(promise)) {\n                throw this.getAsyncError();\n            }\n        }\n    };\n    _proto.visitTick = function visitTick(stack) {\n        var visit2 = stack[stack.length - 1];\n        var node2 = visit2.node, visitors = visit2.visitors;\n        if (node2.type !== \"root\" && node2.type !== \"document\" && !node2.parent) {\n            stack.pop();\n            return;\n        }\n        if (visitors.length > 0 && visit2.visitorIndex < visitors.length) {\n            var _visitors_visit2_visitorIndex = visitors[visit2.visitorIndex], plugin22 = _visitors_visit2_visitorIndex[0], visitor = _visitors_visit2_visitorIndex[1];\n            visit2.visitorIndex += 1;\n            if (visit2.visitorIndex === visitors.length) {\n                visit2.visitors = [];\n                visit2.visitorIndex = 0;\n            }\n            this.result.lastPlugin = plugin22;\n            try {\n                return visitor(node2.toProxy(), this.helpers);\n            } catch (e2) {\n                throw this.handleError(e2, node2);\n            }\n        }\n        if (visit2.iterator !== 0) {\n            var iterator = visit2.iterator;\n            var child;\n            while(child = node2.nodes[node2.indexes[iterator]]){\n                node2.indexes[iterator] += 1;\n                if (!child[isClean]) {\n                    child[isClean] = true;\n                    stack.push(toStack(child));\n                    return;\n                }\n            }\n            visit2.iterator = 0;\n            delete node2.indexes[iterator];\n        }\n        var events = visit2.events;\n        while(visit2.eventIndex < events.length){\n            var event = events[visit2.eventIndex];\n            visit2.eventIndex += 1;\n            if (event === CHILDREN) {\n                if (node2.nodes && node2.nodes.length) {\n                    node2[isClean] = true;\n                    visit2.iterator = node2.getIterator();\n                }\n                return;\n            } else if (this.listeners[event]) {\n                visit2.visitors = this.listeners[event];\n                return;\n            }\n        }\n        stack.pop();\n    };\n    _proto.walkSync = function walkSync(node2) {\n        var _this = this;\n        node2[isClean] = true;\n        var events = getEvents(node2);\n        for(var _iterator = _create_for_of_iterator_helper_loose(events), _step; !(_step = _iterator()).done;){\n            var event = _step.value;\n            if (event === CHILDREN) {\n                if (node2.nodes) {\n                    node2.each(function(child) {\n                        if (!child[isClean]) _this.walkSync(child);\n                    });\n                }\n            } else {\n                var visitors = this.listeners[event];\n                if (visitors) {\n                    if (this.visitSync(visitors, node2.toProxy())) return;\n                }\n            }\n        }\n    };\n    _proto.warnings = function warnings() {\n        return this.sync().warnings();\n    };\n    _create_class(LazyResult2, [\n        {\n            key: \"content\",\n            get: function get() {\n                return this.stringify().content;\n            }\n        },\n        {\n            key: \"css\",\n            get: function get() {\n                return this.stringify().css;\n            }\n        },\n        {\n            key: \"map\",\n            get: function get() {\n                return this.stringify().map;\n            }\n        },\n        {\n            key: \"messages\",\n            get: function get() {\n                return this.sync().messages;\n            }\n        },\n        {\n            key: \"opts\",\n            get: function get() {\n                return this.result.opts;\n            }\n        },\n        {\n            key: \"processor\",\n            get: function get() {\n                return this.result.processor;\n            }\n        },\n        {\n            key: \"root\",\n            get: function get() {\n                return this.sync().root;\n            }\n        },\n        {\n            key: Symbol.toStringTag,\n            get: function get() {\n                return \"LazyResult\";\n            }\n        }\n    ]);\n    return LazyResult2;\n}();\nLazyResult$2.registerPostcss = function(dependant) {\n    postcss$2 = dependant;\n};\nvar lazyResult = LazyResult$2;\nLazyResult$2.default = LazyResult$2;\nRoot$3.registerLazyResult(LazyResult$2);\nDocument$2.registerLazyResult(LazyResult$2);\nvar MapGenerator22 = mapGenerator;\nvar stringify$1 = stringify_1;\nvar warnOnce22 = warnOnce$2;\nvar parse$1 = parse_1;\nvar Result$1 = result;\nvar NoWorkResult$1 = /*#__PURE__*/ function() {\n    function NoWorkResult2(processor2, css, opts) {\n        css = css.toString();\n        this.stringified = false;\n        this._processor = processor2;\n        this._css = css;\n        this._opts = opts;\n        this._map = void 0;\n        var root2;\n        var str = stringify$1;\n        this.result = new Result$1(this._processor, root2, this._opts);\n        this.result.css = css;\n        var self = this;\n        Object.defineProperty(this.result, \"root\", {\n            get: function get() {\n                return self.root;\n            }\n        });\n        var map = new MapGenerator22(str, root2, this._opts, css);\n        if (map.isMap()) {\n            var _map_generate = map.generate(), generatedCSS = _map_generate[0], generatedMap = _map_generate[1];\n            if (generatedCSS) {\n                this.result.css = generatedCSS;\n            }\n            if (generatedMap) {\n                this.result.map = generatedMap;\n            }\n        } else {\n            map.clearAnnotation();\n            this.result.css = map.css;\n        }\n    }\n    var _proto = NoWorkResult2.prototype;\n    _proto.async = function async() {\n        if (this.error) return Promise.reject(this.error);\n        return Promise.resolve(this.result);\n    };\n    _proto.catch = function _catch(onRejected) {\n        return this.async().catch(onRejected);\n    };\n    _proto.finally = function _finally(onFinally) {\n        return this.async().then(onFinally, onFinally);\n    };\n    _proto.sync = function sync() {\n        if (this.error) throw this.error;\n        return this.result;\n    };\n    _proto.then = function then(onFulfilled, onRejected) {\n        if (true) {\n            if (!(\"from\" in this._opts)) {\n                warnOnce22(\"Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.\");\n            }\n        }\n        return this.async().then(onFulfilled, onRejected);\n    };\n    _proto.toString = function toString() {\n        return this._css;\n    };\n    _proto.warnings = function warnings() {\n        return [];\n    };\n    _create_class(NoWorkResult2, [\n        {\n            key: \"content\",\n            get: function get() {\n                return this.result.css;\n            }\n        },\n        {\n            key: \"css\",\n            get: function get() {\n                return this.result.css;\n            }\n        },\n        {\n            key: \"map\",\n            get: function get() {\n                return this.result.map;\n            }\n        },\n        {\n            key: \"messages\",\n            get: function get() {\n                return [];\n            }\n        },\n        {\n            key: \"opts\",\n            get: function get() {\n                return this.result.opts;\n            }\n        },\n        {\n            key: \"processor\",\n            get: function get() {\n                return this.result.processor;\n            }\n        },\n        {\n            key: \"root\",\n            get: function get() {\n                if (this._root) {\n                    return this._root;\n                }\n                var root2;\n                var parser2 = parse$1;\n                try {\n                    root2 = parser2(this._css, this._opts);\n                } catch (error) {\n                    this.error = error;\n                }\n                if (this.error) {\n                    throw this.error;\n                } else {\n                    this._root = root2;\n                    return root2;\n                }\n            }\n        },\n        {\n            key: Symbol.toStringTag,\n            get: function get() {\n                return \"NoWorkResult\";\n            }\n        }\n    ]);\n    return NoWorkResult2;\n}();\nvar noWorkResult = NoWorkResult$1;\nNoWorkResult$1.default = NoWorkResult$1;\nvar NoWorkResult22 = noWorkResult;\nvar LazyResult$1 = lazyResult;\nvar Document$1 = document$1$2;\nvar Root$2 = root;\nvar Processor$1 = /*#__PURE__*/ function() {\n    function Processor2(plugins) {\n        if (plugins === void 0) plugins = [];\n        this.version = \"8.4.38\";\n        this.plugins = this.normalize(plugins);\n    }\n    var _proto = Processor2.prototype;\n    _proto.normalize = function normalize(plugins) {\n        var normalized = [];\n        for(var _iterator = _create_for_of_iterator_helper_loose(plugins), _step; !(_step = _iterator()).done;){\n            var i2 = _step.value;\n            if (i2.postcss === true) {\n                i2 = i2();\n            } else if (i2.postcss) {\n                i2 = i2.postcss;\n            }\n            if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && Array.isArray(i2.plugins)) {\n                normalized = normalized.concat(i2.plugins);\n            } else if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && i2.postcssPlugin) {\n                normalized.push(i2);\n            } else if (typeof i2 === \"function\") {\n                normalized.push(i2);\n            } else if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && (i2.parse || i2.stringify)) {\n                if (true) {\n                    throw new Error(\"PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation.\");\n                }\n            } else {\n                throw new Error(i2 + \" is not a PostCSS plugin\");\n            }\n        }\n        return normalized;\n    };\n    _proto.process = function process1(css, opts) {\n        if (opts === void 0) opts = {};\n        if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) {\n            return new NoWorkResult22(this, css, opts);\n        } else {\n            return new LazyResult$1(this, css, opts);\n        }\n    };\n    _proto.use = function use(plugin22) {\n        this.plugins = this.plugins.concat(this.normalize([\n            plugin22\n        ]));\n        return this;\n    };\n    return Processor2;\n}();\nvar processor = Processor$1;\nProcessor$1.default = Processor$1;\nRoot$2.registerProcessor(Processor$1);\nDocument$1.registerProcessor(Processor$1);\nvar Declaration$1 = declaration;\nvar PreviousMap22 = previousMap;\nvar Comment$1 = comment;\nvar AtRule$1 = atRule;\nvar Input$1 = input;\nvar Root$1 = root;\nvar Rule$1 = rule;\nfunction fromJSON$1(json, inputs) {\n    if (Array.isArray(json)) return json.map(function(n2) {\n        return fromJSON$1(n2);\n    });\n    var ownInputs = json.inputs, defaults = _object_without_properties_loose(json, [\n        \"inputs\"\n    ]);\n    if (ownInputs) {\n        inputs = [];\n        for(var _iterator = _create_for_of_iterator_helper_loose(ownInputs), _step; !(_step = _iterator()).done;){\n            var input2 = _step.value;\n            var inputHydrated = _extends({}, input2, {\n                __proto__: Input$1.prototype\n            });\n            if (inputHydrated.map) {\n                inputHydrated.map = _extends({}, inputHydrated.map, {\n                    __proto__: PreviousMap22.prototype\n                });\n            }\n            inputs.push(inputHydrated);\n        }\n    }\n    if (defaults.nodes) {\n        defaults.nodes = json.nodes.map(function(n2) {\n            return fromJSON$1(n2, inputs);\n        });\n    }\n    if (defaults.source) {\n        var _defaults_source = defaults.source, inputId = _defaults_source.inputId, source = _object_without_properties_loose(_defaults_source, [\n            \"inputId\"\n        ]);\n        defaults.source = source;\n        if (inputId != null) {\n            defaults.source.input = inputs[inputId];\n        }\n    }\n    if (defaults.type === \"root\") {\n        return new Root$1(defaults);\n    } else if (defaults.type === \"decl\") {\n        return new Declaration$1(defaults);\n    } else if (defaults.type === \"rule\") {\n        return new Rule$1(defaults);\n    } else if (defaults.type === \"comment\") {\n        return new Comment$1(defaults);\n    } else if (defaults.type === \"atrule\") {\n        return new AtRule$1(defaults);\n    } else {\n        throw new Error(\"Unknown node type: \" + json.type);\n    }\n}\nvar fromJSON_1 = fromJSON$1;\nfromJSON$1.default = fromJSON$1;\nvar CssSyntaxError22 = cssSyntaxError;\nvar Declaration22 = declaration;\nvar LazyResult22 = lazyResult;\nvar Container22 = container;\nvar Processor22 = processor;\nvar stringify$6 = stringify_1;\nvar fromJSON = fromJSON_1;\nvar Document222 = document$1$2;\nvar Warning22 = warning;\nvar Comment22 = comment;\nvar AtRule22 = atRule;\nvar Result22 = result;\nvar Input22 = input;\nvar parse = parse_1;\nvar list = list_1;\nvar Rule22 = rule;\nvar Root22 = root;\nvar Node22 = node;\nfunction postcss() {\n    for(var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++){\n        plugins[_key] = arguments[_key];\n    }\n    if (plugins.length === 1 && Array.isArray(plugins[0])) {\n        plugins = plugins[0];\n    }\n    return new Processor22(plugins);\n}\npostcss.plugin = function plugin2(name, initializer) {\n    var warningPrinted = false;\n    function creator() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (console && console.warn && !warningPrinted) {\n            warningPrinted = true;\n            console.warn(name + \": postcss.plugin was deprecated. Migration guide:\\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration\");\n            if (process.env.LANG && process.env.LANG.startsWith(\"cn\")) {\n                console.warn(name + \":  postcss.plugin . :\\nhttps://www.w3ctech.com/topic/2226\");\n            }\n        }\n        var transformer = initializer.apply(void 0, [].concat(args));\n        transformer.postcssPlugin = name;\n        transformer.postcssVersion = new Processor22().version;\n        return transformer;\n    }\n    var cache;\n    Object.defineProperty(creator, \"postcss\", {\n        get: function get() {\n            if (!cache) cache = creator();\n            return cache;\n        }\n    });\n    creator.process = function(css, processOpts, pluginOpts) {\n        return postcss([\n            creator(pluginOpts)\n        ]).process(css, processOpts);\n    };\n    return creator;\n};\npostcss.stringify = stringify$6;\npostcss.parse = parse;\npostcss.fromJSON = fromJSON;\npostcss.list = list;\npostcss.comment = function(defaults) {\n    return new Comment22(defaults);\n};\npostcss.atRule = function(defaults) {\n    return new AtRule22(defaults);\n};\npostcss.decl = function(defaults) {\n    return new Declaration22(defaults);\n};\npostcss.rule = function(defaults) {\n    return new Rule22(defaults);\n};\npostcss.root = function(defaults) {\n    return new Root22(defaults);\n};\npostcss.document = function(defaults) {\n    return new Document222(defaults);\n};\npostcss.CssSyntaxError = CssSyntaxError22;\npostcss.Declaration = Declaration22;\npostcss.Container = Container22;\npostcss.Processor = Processor22;\npostcss.Document = Document222;\npostcss.Comment = Comment22;\npostcss.Warning = Warning22;\npostcss.AtRule = AtRule22;\npostcss.Result = Result22;\npostcss.Input = Input22;\npostcss.Rule = Rule22;\npostcss.Root = Root22;\npostcss.Node = Node22;\nLazyResult22.registerPostcss(postcss);\nvar postcss_1 = postcss;\npostcss.default = postcss;\nvar postcss$1 = /* @__PURE__ */ getDefaultExportFromCjs(postcss_1);\npostcss$1.stringify;\npostcss$1.fromJSON;\npostcss$1.plugin;\npostcss$1.parse;\npostcss$1.list;\npostcss$1.document;\npostcss$1.comment;\npostcss$1.atRule;\npostcss$1.rule;\npostcss$1.decl;\npostcss$1.root;\npostcss$1.CssSyntaxError;\npostcss$1.Declaration;\npostcss$1.Container;\npostcss$1.Processor;\npostcss$1.Document;\npostcss$1.Comment;\npostcss$1.Warning;\npostcss$1.AtRule;\npostcss$1.Result;\npostcss$1.Input;\npostcss$1.Rule;\npostcss$1.Root;\npostcss$1.Node;\nvar BaseRRNode = /*#__PURE__*/ function() {\n    function BaseRRNode() {\n        for(var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++){\n            _args[_key] = arguments[_key];\n        }\n        __publicField2(this, \"parentElement\", null);\n        __publicField2(this, \"parentNode\", null);\n        __publicField2(this, \"ownerDocument\");\n        __publicField2(this, \"firstChild\", null);\n        __publicField2(this, \"lastChild\", null);\n        __publicField2(this, \"previousSibling\", null);\n        __publicField2(this, \"nextSibling\", null);\n        __publicField2(this, \"ELEMENT_NODE\", 1);\n        __publicField2(this, \"TEXT_NODE\", 3);\n        __publicField2(this, \"nodeType\");\n        __publicField2(this, \"nodeName\");\n        __publicField2(this, \"RRNodeType\");\n    }\n    var _proto = BaseRRNode.prototype;\n    _proto.contains = function contains(node2) {\n        if (!_instanceof(node2, BaseRRNode)) return false;\n        else if (node2.ownerDocument !== this.ownerDocument) return false;\n        else if (node2 === this) return true;\n        while(node2.parentNode){\n            if (node2.parentNode === this) return true;\n            node2 = node2.parentNode;\n        }\n        return false;\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _proto.appendChild = function appendChild(_newChild) {\n        throw new Error(\"RRDomException: Failed to execute 'appendChild' on 'RRNode': This RRNode type does not support this method.\");\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _proto.insertBefore = function insertBefore(_newChild, _refChild) {\n        throw new Error(\"RRDomException: Failed to execute 'insertBefore' on 'RRNode': This RRNode type does not support this method.\");\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _proto.removeChild = function removeChild(_node) {\n        throw new Error(\"RRDomException: Failed to execute 'removeChild' on 'RRNode': This RRNode type does not support this method.\");\n    };\n    _proto.toString = function toString() {\n        return \"RRNode\";\n    };\n    _create_class(BaseRRNode, [\n        {\n            key: \"childNodes\",\n            get: function get() {\n                var childNodes2 = [];\n                var childIterator = this.firstChild;\n                while(childIterator){\n                    childNodes2.push(childIterator);\n                    childIterator = childIterator.nextSibling;\n                }\n                return childNodes2;\n            }\n        }\n    ]);\n    return BaseRRNode;\n}();\nvar testableAccessors = {\n    Node: [\n        \"childNodes\",\n        \"parentNode\",\n        \"parentElement\",\n        \"textContent\"\n    ],\n    ShadowRoot: [\n        \"host\",\n        \"styleSheets\"\n    ],\n    Element: [\n        \"shadowRoot\",\n        \"querySelector\",\n        \"querySelectorAll\"\n    ],\n    MutationObserver: []\n};\nvar testableMethods = {\n    Node: [\n        \"contains\",\n        \"getRootNode\"\n    ],\n    ShadowRoot: [\n        \"getSelection\"\n    ],\n    Element: [],\n    MutationObserver: [\n        \"constructor\"\n    ]\n};\nvar untaintedBasePrototype = {};\nvar isAngularZonePresent = function() {\n    return !!globalThis.Zone;\n};\nfunction getUntaintedPrototype(key) {\n    if (untaintedBasePrototype[key]) return untaintedBasePrototype[key];\n    var defaultObj = globalThis[key];\n    var defaultPrototype = defaultObj.prototype;\n    var accessorNames = key in testableAccessors ? testableAccessors[key] : void 0;\n    var isUntaintedAccessors = Boolean(accessorNames && // @ts-expect-error 2345\n    accessorNames.every(function(accessor) {\n        var _a2, _b;\n        return Boolean((_b = (_a2 = Object.getOwnPropertyDescriptor(defaultPrototype, accessor)) == null ? void 0 : _a2.get) == null ? void 0 : _b.toString().includes(\"[native code]\"));\n    }));\n    var methodNames = key in testableMethods ? testableMethods[key] : void 0;\n    var isUntaintedMethods = Boolean(methodNames && methodNames.every(// @ts-expect-error 2345\n    function(method) {\n        var _a2;\n        return typeof defaultPrototype[method] === \"function\" && ((_a2 = defaultPrototype[method]) == null ? void 0 : _a2.toString().includes(\"[native code]\"));\n    }));\n    if (isUntaintedAccessors && isUntaintedMethods && !isAngularZonePresent()) {\n        untaintedBasePrototype[key] = defaultObj.prototype;\n        return defaultObj.prototype;\n    }\n    try {\n        var iframeEl = document.createElement(\"iframe\");\n        document.body.appendChild(iframeEl);\n        var win = iframeEl.contentWindow;\n        if (!win) return defaultObj.prototype;\n        var untaintedObject = win[key].prototype;\n        document.body.removeChild(iframeEl);\n        if (!untaintedObject) return defaultPrototype;\n        return untaintedBasePrototype[key] = untaintedObject;\n    } catch (e) {\n        return defaultPrototype;\n    }\n}\nvar untaintedAccessorCache = {};\nfunction getUntaintedAccessor(key, instance, accessor) {\n    var _a2;\n    var cacheKey = key + \".\" + String(accessor);\n    if (untaintedAccessorCache[cacheKey]) return untaintedAccessorCache[cacheKey].call(instance);\n    var untaintedPrototype = getUntaintedPrototype(key);\n    var untaintedAccessor = (_a2 = Object.getOwnPropertyDescriptor(untaintedPrototype, accessor)) == null ? void 0 : _a2.get;\n    if (!untaintedAccessor) return instance[accessor];\n    untaintedAccessorCache[cacheKey] = untaintedAccessor;\n    return untaintedAccessor.call(instance);\n}\nvar untaintedMethodCache = {};\nfunction getUntaintedMethod(key, instance, method) {\n    var cacheKey = key + \".\" + String(method);\n    if (untaintedMethodCache[cacheKey]) return untaintedMethodCache[cacheKey].bind(instance);\n    var untaintedPrototype = getUntaintedPrototype(key);\n    var untaintedMethod = untaintedPrototype[method];\n    if (typeof untaintedMethod !== \"function\") return instance[method];\n    untaintedMethodCache[cacheKey] = untaintedMethod;\n    return untaintedMethod.bind(instance);\n}\nfunction childNodes(n2) {\n    return getUntaintedAccessor(\"Node\", n2, \"childNodes\");\n}\nfunction parentNode(n2) {\n    return getUntaintedAccessor(\"Node\", n2, \"parentNode\");\n}\nfunction parentElement(n2) {\n    return getUntaintedAccessor(\"Node\", n2, \"parentElement\");\n}\nfunction textContent(n2) {\n    return getUntaintedAccessor(\"Node\", n2, \"textContent\");\n}\nfunction contains(n2, other) {\n    return getUntaintedMethod(\"Node\", n2, \"contains\")(other);\n}\nfunction getRootNode(n2) {\n    return getUntaintedMethod(\"Node\", n2, \"getRootNode\")();\n}\nfunction host(n2) {\n    if (!n2 || !(\"host\" in n2)) return null;\n    return getUntaintedAccessor(\"ShadowRoot\", n2, \"host\");\n}\nfunction styleSheets(n2) {\n    return n2.styleSheets;\n}\nfunction shadowRoot(n2) {\n    if (!n2 || !(\"shadowRoot\" in n2)) return null;\n    return getUntaintedAccessor(\"Element\", n2, \"shadowRoot\");\n}\nfunction querySelector(n2, selectors) {\n    return getUntaintedAccessor(\"Element\", n2, \"querySelector\")(selectors);\n}\nfunction querySelectorAll(n2, selectors) {\n    return getUntaintedAccessor(\"Element\", n2, \"querySelectorAll\")(selectors);\n}\nfunction mutationObserverCtor() {\n    return getUntaintedPrototype(\"MutationObserver\").constructor;\n}\nfunction patch$2(source, name, replacement) {\n    try {\n        if (!(name in source)) {\n            return function() {};\n        }\n        var original = source[name];\n        var wrapped = replacement(original);\n        if (typeof wrapped === \"function\") {\n            wrapped.prototype = wrapped.prototype || {};\n            Object.defineProperties(wrapped, {\n                __rrweb_original__: {\n                    enumerable: false,\n                    value: original\n                }\n            });\n        }\n        source[name] = wrapped;\n        return function() {\n            source[name] = original;\n        };\n    } catch (e) {\n        return function() {};\n    }\n}\nvar index = {\n    childNodes: childNodes,\n    parentNode: parentNode,\n    parentElement: parentElement,\n    textContent: textContent,\n    contains: contains,\n    getRootNode: getRootNode,\n    host: host,\n    styleSheets: styleSheets,\n    shadowRoot: shadowRoot,\n    querySelector: querySelector,\n    querySelectorAll: querySelectorAll,\n    mutationObserver: mutationObserverCtor,\n    patch: patch$2\n};\nfunction on(type, fn, target) {\n    if (target === void 0) target = document;\n    var options = {\n        capture: true,\n        passive: true\n    };\n    target.addEventListener(type, fn, options);\n    return function() {\n        return target.removeEventListener(type, fn, options);\n    };\n}\nvar DEPARTED_MIRROR_ACCESS_WARNING = \"Please stop import mirror directly. Instead of that,\\r\\nnow you can use replayer.getMirror() to access the mirror instance of a replayer,\\r\\nor you can use record.mirror to access the mirror instance during recording.\";\nvar _mirror = {\n    map: {},\n    getId: function getId() {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n        return -1;\n    },\n    getNode: function getNode() {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n        return null;\n    },\n    removeNodeFromMap: function removeNodeFromMap() {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    },\n    has: function has() {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n        return false;\n    },\n    reset: function reset() {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    }\n};\nif (typeof window !== \"undefined\" && window.Proxy && window.Reflect) {\n    _mirror = new Proxy(_mirror, {\n        get: function get(target, prop, receiver) {\n            if (prop === \"map\") {\n                console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n            }\n            return Reflect.get(target, prop, receiver);\n        }\n    });\n}\nfunction throttle(func, wait, options) {\n    if (options === void 0) options = {};\n    var timeout = null;\n    var previous = 0;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        var now = Date.now();\n        if (!previous && options.leading === false) {\n            previous = now;\n        }\n        var remaining = wait - (now - previous);\n        var context = this;\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            func.apply(context, args);\n        } else if (!timeout && options.trailing !== false) {\n            timeout = setTimeout(function() {\n                previous = options.leading === false ? 0 : Date.now();\n                timeout = null;\n                func.apply(context, args);\n            }, remaining);\n        }\n    };\n}\nfunction hookSetter(target, key, d, isRevoked, win) {\n    if (win === void 0) win = window;\n    var original = win.Object.getOwnPropertyDescriptor(target, key);\n    win.Object.defineProperty(target, key, isRevoked ? d : {\n        set: function set(value) {\n            var _this = this;\n            setTimeout(function() {\n                d.set.call(_this, value);\n            }, 0);\n            if (original && original.set) {\n                original.set.call(this, value);\n            }\n        }\n    });\n    return function() {\n        return hookSetter(target, key, original || {}, true);\n    };\n}\nvar nowTimestamp = Date.now;\nif (!/* @__PURE__ */ /[1-9][0-9]{12}/.test(Date.now().toString())) {\n    nowTimestamp = function() {\n        return /* @__PURE__ */ new Date().getTime();\n    };\n}\nfunction getWindowScroll(win) {\n    var _a2, _b, _c, _d;\n    var doc = win.document;\n    return {\n        left: doc.scrollingElement ? doc.scrollingElement.scrollLeft : win.pageXOffset !== void 0 ? win.pageXOffset : doc.documentElement.scrollLeft || (doc == null ? void 0 : doc.body) && ((_a2 = index.parentElement(doc.body)) == null ? void 0 : _a2.scrollLeft) || ((_b = doc == null ? void 0 : doc.body) == null ? void 0 : _b.scrollLeft) || 0,\n        top: doc.scrollingElement ? doc.scrollingElement.scrollTop : win.pageYOffset !== void 0 ? win.pageYOffset : (doc == null ? void 0 : doc.documentElement.scrollTop) || (doc == null ? void 0 : doc.body) && ((_c = index.parentElement(doc.body)) == null ? void 0 : _c.scrollTop) || ((_d = doc == null ? void 0 : doc.body) == null ? void 0 : _d.scrollTop) || 0\n    };\n}\nfunction getWindowHeight() {\n    return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight;\n}\nfunction getWindowWidth() {\n    return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth;\n}\nfunction closestElementOfNode(node2) {\n    if (!node2) {\n        return null;\n    }\n    var el = node2.nodeType === node2.ELEMENT_NODE ? node2 : index.parentElement(node2);\n    return el;\n}\nfunction isBlocked(node2, blockClass, blockSelector, checkAncestors) {\n    if (!node2) {\n        return false;\n    }\n    var el = closestElementOfNode(node2);\n    if (!el) {\n        return false;\n    }\n    try {\n        if (typeof blockClass === \"string\") {\n            if (el.classList.contains(blockClass)) return true;\n            if (checkAncestors && el.closest(\".\" + blockClass) !== null) return true;\n        } else {\n            if (classMatchesRegex(el, blockClass, checkAncestors)) return true;\n        }\n    } catch (e2) {}\n    if (blockSelector) {\n        if (el.matches(blockSelector)) return true;\n        if (checkAncestors && el.closest(blockSelector) !== null) return true;\n    }\n    return false;\n}\nfunction isSerialized(n2, mirror2) {\n    return mirror2.getId(n2) !== -1;\n}\nfunction isIgnored(n2, mirror2, slimDOMOptions) {\n    if (n2.tagName === \"TITLE\" && slimDOMOptions.headTitleMutations) {\n        return true;\n    }\n    return mirror2.getId(n2) === IGNORED_NODE;\n}\nfunction isAncestorRemoved(target, mirror2) {\n    if (isShadowRoot(target)) {\n        return false;\n    }\n    var id = mirror2.getId(target);\n    if (!mirror2.has(id)) {\n        return true;\n    }\n    var parent = index.parentNode(target);\n    if (parent && parent.nodeType === target.DOCUMENT_NODE) {\n        return false;\n    }\n    if (!parent) {\n        return true;\n    }\n    return isAncestorRemoved(parent, mirror2);\n}\nfunction legacy_isTouchEvent(event) {\n    return Boolean(event.changedTouches);\n}\nfunction polyfill$1(win) {\n    if (win === void 0) win = window;\n    if (\"NodeList\" in win && !win.NodeList.prototype.forEach) {\n        win.NodeList.prototype.forEach = Array.prototype.forEach;\n    }\n    if (\"DOMTokenList\" in win && !win.DOMTokenList.prototype.forEach) {\n        win.DOMTokenList.prototype.forEach = Array.prototype.forEach;\n    }\n}\nfunction isSerializedIframe(n2, mirror2) {\n    return Boolean(n2.nodeName === \"IFRAME\" && mirror2.getMeta(n2));\n}\nfunction isSerializedStylesheet(n2, mirror2) {\n    return Boolean(n2.nodeName === \"LINK\" && n2.nodeType === n2.ELEMENT_NODE && n2.getAttribute && n2.getAttribute(\"rel\") === \"stylesheet\" && mirror2.getMeta(n2));\n}\nfunction hasShadowRoot(n2) {\n    if (!n2) return false;\n    if (_instanceof(n2, BaseRRNode) && \"shadowRoot\" in n2) {\n        return Boolean(n2.shadowRoot);\n    }\n    return Boolean(index.shadowRoot(n2));\n}\nvar StyleSheetMirror = /*#__PURE__*/ function() {\n    function StyleSheetMirror() {\n        __publicField$1(this, \"id\", 1);\n        __publicField$1(this, \"styleIDMap\", /* @__PURE__ */ new WeakMap());\n        __publicField$1(this, \"idStyleMap\", /* @__PURE__ */ new Map());\n    }\n    var _proto = StyleSheetMirror.prototype;\n    _proto.getId = function getId(stylesheet) {\n        var _this_styleIDMap_get;\n        return (_this_styleIDMap_get = this.styleIDMap.get(stylesheet)) != null ? _this_styleIDMap_get : -1;\n    };\n    _proto.has = function has(stylesheet) {\n        return this.styleIDMap.has(stylesheet);\n    };\n    /**\n   * @returns If the stylesheet is in the mirror, returns the id of the stylesheet. If not, return the new assigned id.\n   */ _proto.add = function add(stylesheet, id) {\n        if (this.has(stylesheet)) return this.getId(stylesheet);\n        var newId;\n        if (id === void 0) {\n            newId = this.id++;\n        } else newId = id;\n        this.styleIDMap.set(stylesheet, newId);\n        this.idStyleMap.set(newId, stylesheet);\n        return newId;\n    };\n    _proto.getStyle = function getStyle(id) {\n        return this.idStyleMap.get(id) || null;\n    };\n    _proto.reset = function reset() {\n        this.styleIDMap = /* @__PURE__ */ new WeakMap();\n        this.idStyleMap = /* @__PURE__ */ new Map();\n        this.id = 1;\n    };\n    _proto.generateId = function generateId() {\n        return this.id++;\n    };\n    return StyleSheetMirror;\n}();\nfunction getShadowHost(n2) {\n    var _a2;\n    var shadowHost = null;\n    if (\"getRootNode\" in n2 && ((_a2 = index.getRootNode(n2)) == null ? void 0 : _a2.nodeType) === Node.DOCUMENT_FRAGMENT_NODE && index.host(index.getRootNode(n2))) shadowHost = index.host(index.getRootNode(n2));\n    return shadowHost;\n}\nfunction getRootShadowHost(n2) {\n    var rootShadowHost = n2;\n    var shadowHost;\n    while(shadowHost = getShadowHost(rootShadowHost))rootShadowHost = shadowHost;\n    return rootShadowHost;\n}\nfunction shadowHostInDom(n2) {\n    var doc = n2.ownerDocument;\n    if (!doc) return false;\n    var shadowHost = getRootShadowHost(n2);\n    return index.contains(doc, shadowHost);\n}\nfunction inDom(n2) {\n    var doc = n2.ownerDocument;\n    if (!doc) return false;\n    return index.contains(doc, n2) || shadowHostInDom(n2);\n}\nvar EventType = /* @__PURE__ */ function(EventType2) {\n    EventType2[EventType2[\"DomContentLoaded\"] = 0] = \"DomContentLoaded\";\n    EventType2[EventType2[\"Load\"] = 1] = \"Load\";\n    EventType2[EventType2[\"FullSnapshot\"] = 2] = \"FullSnapshot\";\n    EventType2[EventType2[\"IncrementalSnapshot\"] = 3] = \"IncrementalSnapshot\";\n    EventType2[EventType2[\"Meta\"] = 4] = \"Meta\";\n    EventType2[EventType2[\"Custom\"] = 5] = \"Custom\";\n    EventType2[EventType2[\"Plugin\"] = 6] = \"Plugin\";\n    return EventType2;\n}(EventType || {});\nvar IncrementalSource = /* @__PURE__ */ function(IncrementalSource2) {\n    IncrementalSource2[IncrementalSource2[\"Mutation\"] = 0] = \"Mutation\";\n    IncrementalSource2[IncrementalSource2[\"MouseMove\"] = 1] = \"MouseMove\";\n    IncrementalSource2[IncrementalSource2[\"MouseInteraction\"] = 2] = \"MouseInteraction\";\n    IncrementalSource2[IncrementalSource2[\"Scroll\"] = 3] = \"Scroll\";\n    IncrementalSource2[IncrementalSource2[\"ViewportResize\"] = 4] = \"ViewportResize\";\n    IncrementalSource2[IncrementalSource2[\"Input\"] = 5] = \"Input\";\n    IncrementalSource2[IncrementalSource2[\"TouchMove\"] = 6] = \"TouchMove\";\n    IncrementalSource2[IncrementalSource2[\"MediaInteraction\"] = 7] = \"MediaInteraction\";\n    IncrementalSource2[IncrementalSource2[\"StyleSheetRule\"] = 8] = \"StyleSheetRule\";\n    IncrementalSource2[IncrementalSource2[\"CanvasMutation\"] = 9] = \"CanvasMutation\";\n    IncrementalSource2[IncrementalSource2[\"Font\"] = 10] = \"Font\";\n    IncrementalSource2[IncrementalSource2[\"Log\"] = 11] = \"Log\";\n    IncrementalSource2[IncrementalSource2[\"Drag\"] = 12] = \"Drag\";\n    IncrementalSource2[IncrementalSource2[\"StyleDeclaration\"] = 13] = \"StyleDeclaration\";\n    IncrementalSource2[IncrementalSource2[\"Selection\"] = 14] = \"Selection\";\n    IncrementalSource2[IncrementalSource2[\"AdoptedStyleSheet\"] = 15] = \"AdoptedStyleSheet\";\n    IncrementalSource2[IncrementalSource2[\"CustomElement\"] = 16] = \"CustomElement\";\n    return IncrementalSource2;\n}(IncrementalSource || {});\nvar MouseInteractions = /* @__PURE__ */ function(MouseInteractions2) {\n    MouseInteractions2[MouseInteractions2[\"MouseUp\"] = 0] = \"MouseUp\";\n    MouseInteractions2[MouseInteractions2[\"MouseDown\"] = 1] = \"MouseDown\";\n    MouseInteractions2[MouseInteractions2[\"Click\"] = 2] = \"Click\";\n    MouseInteractions2[MouseInteractions2[\"ContextMenu\"] = 3] = \"ContextMenu\";\n    MouseInteractions2[MouseInteractions2[\"DblClick\"] = 4] = \"DblClick\";\n    MouseInteractions2[MouseInteractions2[\"Focus\"] = 5] = \"Focus\";\n    MouseInteractions2[MouseInteractions2[\"Blur\"] = 6] = \"Blur\";\n    MouseInteractions2[MouseInteractions2[\"TouchStart\"] = 7] = \"TouchStart\";\n    MouseInteractions2[MouseInteractions2[\"TouchMove_Departed\"] = 8] = \"TouchMove_Departed\";\n    MouseInteractions2[MouseInteractions2[\"TouchEnd\"] = 9] = \"TouchEnd\";\n    MouseInteractions2[MouseInteractions2[\"TouchCancel\"] = 10] = \"TouchCancel\";\n    return MouseInteractions2;\n}(MouseInteractions || {});\nvar PointerTypes = /* @__PURE__ */ function(PointerTypes2) {\n    PointerTypes2[PointerTypes2[\"Mouse\"] = 0] = \"Mouse\";\n    PointerTypes2[PointerTypes2[\"Pen\"] = 1] = \"Pen\";\n    PointerTypes2[PointerTypes2[\"Touch\"] = 2] = \"Touch\";\n    return PointerTypes2;\n}(PointerTypes || {});\nvar CanvasContext = /* @__PURE__ */ function(CanvasContext2) {\n    CanvasContext2[CanvasContext2[\"2D\"] = 0] = \"2D\";\n    CanvasContext2[CanvasContext2[\"WebGL\"] = 1] = \"WebGL\";\n    CanvasContext2[CanvasContext2[\"WebGL2\"] = 2] = \"WebGL2\";\n    return CanvasContext2;\n}(CanvasContext || {});\nvar MediaInteractions = /* @__PURE__ */ function(MediaInteractions2) {\n    MediaInteractions2[MediaInteractions2[\"Play\"] = 0] = \"Play\";\n    MediaInteractions2[MediaInteractions2[\"Pause\"] = 1] = \"Pause\";\n    MediaInteractions2[MediaInteractions2[\"Seeked\"] = 2] = \"Seeked\";\n    MediaInteractions2[MediaInteractions2[\"VolumeChange\"] = 3] = \"VolumeChange\";\n    MediaInteractions2[MediaInteractions2[\"RateChange\"] = 4] = \"RateChange\";\n    return MediaInteractions2;\n}(MediaInteractions || {});\nvar NodeType = /* @__PURE__ */ function(NodeType2) {\n    NodeType2[NodeType2[\"Document\"] = 0] = \"Document\";\n    NodeType2[NodeType2[\"DocumentType\"] = 1] = \"DocumentType\";\n    NodeType2[NodeType2[\"Element\"] = 2] = \"Element\";\n    NodeType2[NodeType2[\"Text\"] = 3] = \"Text\";\n    NodeType2[NodeType2[\"CDATA\"] = 4] = \"CDATA\";\n    NodeType2[NodeType2[\"Comment\"] = 5] = \"Comment\";\n    return NodeType2;\n}(NodeType || {});\nfunction isNodeInLinkedList(n2) {\n    return \"__ln\" in n2;\n}\nvar DoubleLinkedList = /*#__PURE__*/ function() {\n    function DoubleLinkedList() {\n        __publicField$1(this, \"length\", 0);\n        __publicField$1(this, \"head\", null);\n        __publicField$1(this, \"tail\", null);\n    }\n    var _proto = DoubleLinkedList.prototype;\n    _proto.get = function get(position) {\n        if (position >= this.length) {\n            throw new Error(\"Position outside of list range\");\n        }\n        var current = this.head;\n        for(var index2 = 0; index2 < position; index2++){\n            current = (current == null ? void 0 : current.next) || null;\n        }\n        return current;\n    };\n    _proto.addNode = function addNode(n2) {\n        var node2 = {\n            value: n2,\n            previous: null,\n            next: null\n        };\n        n2.__ln = node2;\n        if (n2.previousSibling && isNodeInLinkedList(n2.previousSibling)) {\n            var current = n2.previousSibling.__ln.next;\n            node2.next = current;\n            node2.previous = n2.previousSibling.__ln;\n            n2.previousSibling.__ln.next = node2;\n            if (current) {\n                current.previous = node2;\n            }\n        } else if (n2.nextSibling && isNodeInLinkedList(n2.nextSibling) && n2.nextSibling.__ln.previous) {\n            var current1 = n2.nextSibling.__ln.previous;\n            node2.previous = current1;\n            node2.next = n2.nextSibling.__ln;\n            n2.nextSibling.__ln.previous = node2;\n            if (current1) {\n                current1.next = node2;\n            }\n        } else {\n            if (this.head) {\n                this.head.previous = node2;\n            }\n            node2.next = this.head;\n            this.head = node2;\n        }\n        if (node2.next === null) {\n            this.tail = node2;\n        }\n        this.length++;\n    };\n    _proto.removeNode = function removeNode(n2) {\n        var current = n2.__ln;\n        if (!this.head) {\n            return;\n        }\n        if (!current.previous) {\n            this.head = current.next;\n            if (this.head) {\n                this.head.previous = null;\n            } else {\n                this.tail = null;\n            }\n        } else {\n            current.previous.next = current.next;\n            if (current.next) {\n                current.next.previous = current.previous;\n            } else {\n                this.tail = current.previous;\n            }\n        }\n        if (n2.__ln) {\n            delete n2.__ln;\n        }\n        this.length--;\n    };\n    return DoubleLinkedList;\n}();\nvar moveKey = function(id, parentId) {\n    return id + \"@\" + parentId;\n};\nvar MutationBuffer = /*#__PURE__*/ function() {\n    function MutationBuffer() {\n        var _this = this;\n        __publicField$1(this, \"frozen\", false);\n        __publicField$1(this, \"locked\", false);\n        __publicField$1(this, \"texts\", []);\n        __publicField$1(this, \"attributes\", []);\n        __publicField$1(this, \"attributeMap\", /* @__PURE__ */ new WeakMap());\n        __publicField$1(this, \"removes\", []);\n        __publicField$1(this, \"mapRemoves\", []);\n        __publicField$1(this, \"movedMap\", {});\n        /**\n     * the browser MutationObserver emits multiple mutations after\n     * a delay for performance reasons, making tracing added nodes hard\n     * in our `processMutations` callback function.\n     * For example, if we append an element el_1 into body, and then append\n     * another element el_2 into el_1, these two mutations may be passed to the\n     * callback function together when the two operations were done.\n     * Generally we need to trace child nodes of newly added nodes, but in this\n     * case if we count el_2 as el_1's child node in the first mutation record,\n     * then we will count el_2 again in the second mutation record which was\n     * duplicated.\n     * To avoid of duplicate counting added nodes, we use a Set to store\n     * added nodes and its child nodes during iterate mutation records. Then\n     * collect added nodes from the Set which have no duplicate copy. But\n     * this also causes newly added nodes will not be serialized with id ASAP,\n     * which means all the id related calculation should be lazy too.\n     */ __publicField$1(this, \"addedSet\", /* @__PURE__ */ new Set());\n        __publicField$1(this, \"movedSet\", /* @__PURE__ */ new Set());\n        __publicField$1(this, \"droppedSet\", /* @__PURE__ */ new Set());\n        __publicField$1(this, \"removesSubTreeCache\", /* @__PURE__ */ new Set());\n        __publicField$1(this, \"mutationCb\");\n        __publicField$1(this, \"blockClass\");\n        __publicField$1(this, \"blockSelector\");\n        __publicField$1(this, \"maskTextClass\");\n        __publicField$1(this, \"maskTextSelector\");\n        __publicField$1(this, \"inlineStylesheet\");\n        __publicField$1(this, \"maskInputOptions\");\n        __publicField$1(this, \"maskTextFn\");\n        __publicField$1(this, \"maskInputFn\");\n        __publicField$1(this, \"keepIframeSrcFn\");\n        __publicField$1(this, \"recordCanvas\");\n        __publicField$1(this, \"inlineImages\");\n        __publicField$1(this, \"slimDOMOptions\");\n        __publicField$1(this, \"dataURLOptions\");\n        __publicField$1(this, \"doc\");\n        __publicField$1(this, \"mirror\");\n        __publicField$1(this, \"iframeManager\");\n        __publicField$1(this, \"stylesheetManager\");\n        __publicField$1(this, \"shadowDomManager\");\n        __publicField$1(this, \"canvasManager\");\n        __publicField$1(this, \"processedNodeManager\");\n        __publicField$1(this, \"unattachedDoc\");\n        __publicField$1(this, \"processMutations\", function(mutations) {\n            mutations.forEach(_this.processMutation);\n            _this.emit();\n        });\n        __publicField$1(this, \"emit\", function() {\n            if (_this.frozen || _this.locked) {\n                return;\n            }\n            var adds = [];\n            var addedIds = /* @__PURE__ */ new Set();\n            var addList = new DoubleLinkedList();\n            var getNextId = function(n2) {\n                var ns = n2;\n                var nextId = IGNORED_NODE;\n                while(nextId === IGNORED_NODE){\n                    ns = ns && ns.nextSibling;\n                    nextId = ns && _this.mirror.getId(ns);\n                }\n                return nextId;\n            };\n            var pushAdd = function(n2) {\n                var parent = index.parentNode(n2);\n                if (!parent || !inDom(n2)) {\n                    return;\n                }\n                var cssCaptured = false;\n                if (n2.nodeType === Node.TEXT_NODE) {\n                    var parentTag = parent.tagName;\n                    if (parentTag === \"TEXTAREA\") {\n                        return;\n                    } else if (parentTag === \"STYLE\" && _this.addedSet.has(parent)) {\n                        cssCaptured = true;\n                    }\n                }\n                var parentId = isShadowRoot(parent) ? _this.mirror.getId(getShadowHost(n2)) : _this.mirror.getId(parent);\n                var nextId = getNextId(n2);\n                if (parentId === -1 || nextId === -1) {\n                    return addList.addNode(n2);\n                }\n                var sn = serializeNodeWithId(n2, {\n                    doc: _this.doc,\n                    mirror: _this.mirror,\n                    blockClass: _this.blockClass,\n                    blockSelector: _this.blockSelector,\n                    maskTextClass: _this.maskTextClass,\n                    maskTextSelector: _this.maskTextSelector,\n                    skipChild: true,\n                    newlyAddedElement: true,\n                    inlineStylesheet: _this.inlineStylesheet,\n                    maskInputOptions: _this.maskInputOptions,\n                    maskTextFn: _this.maskTextFn,\n                    maskInputFn: _this.maskInputFn,\n                    slimDOMOptions: _this.slimDOMOptions,\n                    dataURLOptions: _this.dataURLOptions,\n                    recordCanvas: _this.recordCanvas,\n                    inlineImages: _this.inlineImages,\n                    onSerialize: function(currentN) {\n                        if (isSerializedIframe(currentN, _this.mirror)) {\n                            _this.iframeManager.addIframe(currentN);\n                        }\n                        if (isSerializedStylesheet(currentN, _this.mirror)) {\n                            _this.stylesheetManager.trackLinkElement(currentN);\n                        }\n                        if (hasShadowRoot(n2)) {\n                            _this.shadowDomManager.addShadowRoot(index.shadowRoot(n2), _this.doc);\n                        }\n                    },\n                    onIframeLoad: function(iframe, childSn) {\n                        _this.iframeManager.attachIframe(iframe, childSn);\n                        _this.shadowDomManager.observeAttachShadow(iframe);\n                    },\n                    onStylesheetLoad: function(link, childSn) {\n                        _this.stylesheetManager.attachLinkElement(link, childSn);\n                    },\n                    cssCaptured: cssCaptured\n                });\n                if (sn) {\n                    adds.push({\n                        parentId: parentId,\n                        nextId: nextId,\n                        node: sn\n                    });\n                    addedIds.add(sn.id);\n                }\n            };\n            while(_this.mapRemoves.length){\n                _this.mirror.removeNodeFromMap(_this.mapRemoves.shift());\n            }\n            for(var _iterator = _create_for_of_iterator_helper_loose(_this.movedSet), _step; !(_step = _iterator()).done;){\n                var n2 = _step.value;\n                if (isParentRemoved(_this.removesSubTreeCache, n2, _this.mirror) && !_this.movedSet.has(index.parentNode(n2))) {\n                    continue;\n                }\n                pushAdd(n2);\n            }\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(_this.addedSet), _step1; !(_step1 = _iterator1()).done;){\n                var n21 = _step1.value;\n                if (!isAncestorInSet(_this.droppedSet, n21) && !isParentRemoved(_this.removesSubTreeCache, n21, _this.mirror)) {\n                    pushAdd(n21);\n                } else if (isAncestorInSet(_this.movedSet, n21)) {\n                    pushAdd(n21);\n                } else {\n                    _this.droppedSet.add(n21);\n                }\n            }\n            var candidate = null;\n            while(addList.length){\n                var node2 = null;\n                if (candidate) {\n                    var parentId = _this.mirror.getId(index.parentNode(candidate.value));\n                    var nextId = getNextId(candidate.value);\n                    if (parentId !== -1 && nextId !== -1) {\n                        node2 = candidate;\n                    }\n                }\n                if (!node2) {\n                    var tailNode = addList.tail;\n                    while(tailNode){\n                        var _node = tailNode;\n                        tailNode = tailNode.previous;\n                        if (_node) {\n                            var parentId1 = _this.mirror.getId(index.parentNode(_node.value));\n                            var nextId1 = getNextId(_node.value);\n                            if (nextId1 === -1) continue;\n                            else if (parentId1 !== -1) {\n                                node2 = _node;\n                                break;\n                            } else {\n                                var unhandledNode = _node.value;\n                                var parent = index.parentNode(unhandledNode);\n                                if (parent && parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n                                    var shadowHost = index.host(parent);\n                                    var parentId2 = _this.mirror.getId(shadowHost);\n                                    if (parentId2 !== -1) {\n                                        node2 = _node;\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!node2) {\n                    while(addList.head){\n                        addList.removeNode(addList.head.value);\n                    }\n                    break;\n                }\n                candidate = node2.previous;\n                addList.removeNode(node2.value);\n                pushAdd(node2.value);\n            }\n            var payload = {\n                texts: _this.texts.map(function(text) {\n                    var n2 = text.node;\n                    var parent = index.parentNode(n2);\n                    if (parent && parent.tagName === \"TEXTAREA\") {\n                        _this.genTextAreaValueMutation(parent);\n                    }\n                    return {\n                        id: _this.mirror.getId(n2),\n                        value: text.value\n                    };\n                }).filter(function(text) {\n                    return !addedIds.has(text.id);\n                }).filter(function(text) {\n                    return _this.mirror.has(text.id);\n                }),\n                attributes: _this.attributes.map(function(attribute) {\n                    var attributes = attribute.attributes;\n                    if (typeof attributes.style === \"string\") {\n                        var diffAsStr = JSON.stringify(attribute.styleDiff);\n                        var unchangedAsStr = JSON.stringify(attribute._unchangedStyles);\n                        if (diffAsStr.length < attributes.style.length) {\n                            if ((diffAsStr + unchangedAsStr).split(\"var(\").length === attributes.style.split(\"var(\").length) {\n                                attributes.style = attribute.styleDiff;\n                            }\n                        }\n                    }\n                    return {\n                        id: _this.mirror.getId(attribute.node),\n                        attributes: attributes\n                    };\n                }).filter(function(attribute) {\n                    return !addedIds.has(attribute.id);\n                }).filter(function(attribute) {\n                    return _this.mirror.has(attribute.id);\n                }),\n                removes: _this.removes,\n                adds: adds\n            };\n            if (!payload.texts.length && !payload.attributes.length && !payload.removes.length && !payload.adds.length) {\n                return;\n            }\n            _this.texts = [];\n            _this.attributes = [];\n            _this.attributeMap = /* @__PURE__ */ new WeakMap();\n            _this.removes = [];\n            _this.addedSet = /* @__PURE__ */ new Set();\n            _this.movedSet = /* @__PURE__ */ new Set();\n            _this.droppedSet = /* @__PURE__ */ new Set();\n            _this.removesSubTreeCache = /* @__PURE__ */ new Set();\n            _this.movedMap = {};\n            _this.mutationCb(payload);\n        });\n        __publicField$1(this, \"genTextAreaValueMutation\", function(textarea) {\n            var item = _this.attributeMap.get(textarea);\n            if (!item) {\n                item = {\n                    node: textarea,\n                    attributes: {},\n                    styleDiff: {},\n                    _unchangedStyles: {}\n                };\n                _this.attributes.push(item);\n                _this.attributeMap.set(textarea, item);\n            }\n            var value = Array.from(index.childNodes(textarea), function(cn) {\n                return index.textContent(cn) || \"\";\n            }).join(\"\");\n            item.attributes.value = maskInputValue({\n                element: textarea,\n                maskInputOptions: _this.maskInputOptions,\n                tagName: textarea.tagName,\n                type: getInputType(textarea),\n                value: value,\n                maskInputFn: _this.maskInputFn\n            });\n        });\n        __publicField$1(this, \"processMutation\", function(m) {\n            if (isIgnored(m.target, _this.mirror, _this.slimDOMOptions)) {\n                return;\n            }\n            switch(m.type){\n                case \"characterData\":\n                    {\n                        var value = index.textContent(m.target);\n                        if (!isBlocked(m.target, _this.blockClass, _this.blockSelector, false) && value !== m.oldValue) {\n                            _this.texts.push({\n                                value: needMaskingText(m.target, _this.maskTextClass, _this.maskTextSelector, true) && value ? _this.maskTextFn ? _this.maskTextFn(value, closestElementOfNode(m.target)) : value.replace(/[\\S]/g, \"*\") : value,\n                                node: m.target\n                            });\n                        }\n                        break;\n                    }\n                case \"attributes\":\n                    {\n                        var target = m.target;\n                        var attributeName = m.attributeName;\n                        var value1 = m.target.getAttribute(attributeName);\n                        if (attributeName === \"value\") {\n                            var type = getInputType(target);\n                            value1 = maskInputValue({\n                                element: target,\n                                maskInputOptions: _this.maskInputOptions,\n                                tagName: target.tagName,\n                                type: type,\n                                value: value1,\n                                maskInputFn: _this.maskInputFn\n                            });\n                        }\n                        if (isBlocked(m.target, _this.blockClass, _this.blockSelector, false) || value1 === m.oldValue) {\n                            return;\n                        }\n                        var item = _this.attributeMap.get(m.target);\n                        if (target.tagName === \"IFRAME\" && attributeName === \"src\" && !_this.keepIframeSrcFn(value1)) {\n                            if (!target.contentDocument) {\n                                attributeName = \"rr_src\";\n                            } else {\n                                return;\n                            }\n                        }\n                        if (!item) {\n                            item = {\n                                node: m.target,\n                                attributes: {},\n                                styleDiff: {},\n                                _unchangedStyles: {}\n                            };\n                            _this.attributes.push(item);\n                            _this.attributeMap.set(m.target, item);\n                        }\n                        if (attributeName === \"type\" && target.tagName === \"INPUT\" && (m.oldValue || \"\").toLowerCase() === \"password\") {\n                            target.setAttribute(\"data-rr-is-password\", \"true\");\n                        }\n                        if (!ignoreAttribute(target.tagName, attributeName)) {\n                            item.attributes[attributeName] = transformAttribute(_this.doc, toLowerCase(target.tagName), toLowerCase(attributeName), value1);\n                            if (attributeName === \"style\") {\n                                if (!_this.unattachedDoc) {\n                                    try {\n                                        _this.unattachedDoc = document.implementation.createHTMLDocument();\n                                    } catch (e2) {\n                                        _this.unattachedDoc = _this.doc;\n                                    }\n                                }\n                                var old = _this.unattachedDoc.createElement(\"span\");\n                                if (m.oldValue) {\n                                    old.setAttribute(\"style\", m.oldValue);\n                                }\n                                for(var _iterator = _create_for_of_iterator_helper_loose(Array.from(target.style)), _step; !(_step = _iterator()).done;){\n                                    var pname = _step.value;\n                                    var newValue = target.style.getPropertyValue(pname);\n                                    var newPriority = target.style.getPropertyPriority(pname);\n                                    if (newValue !== old.style.getPropertyValue(pname) || newPriority !== old.style.getPropertyPriority(pname)) {\n                                        if (newPriority === \"\") {\n                                            item.styleDiff[pname] = newValue;\n                                        } else {\n                                            item.styleDiff[pname] = [\n                                                newValue,\n                                                newPriority\n                                            ];\n                                        }\n                                    } else {\n                                        item._unchangedStyles[pname] = [\n                                            newValue,\n                                            newPriority\n                                        ];\n                                    }\n                                }\n                                for(var _iterator1 = _create_for_of_iterator_helper_loose(Array.from(old.style)), _step1; !(_step1 = _iterator1()).done;){\n                                    var pname1 = _step1.value;\n                                    if (target.style.getPropertyValue(pname1) === \"\") {\n                                        item.styleDiff[pname1] = false;\n                                    }\n                                }\n                            } else if (attributeName === \"open\" && target.tagName === \"DIALOG\") {\n                                if (target.matches(\"dialog:modal\")) {\n                                    item.attributes[\"rr_open_mode\"] = \"modal\";\n                                } else {\n                                    item.attributes[\"rr_open_mode\"] = \"non-modal\";\n                                }\n                            }\n                        }\n                        break;\n                    }\n                case \"childList\":\n                    {\n                        if (isBlocked(m.target, _this.blockClass, _this.blockSelector, true)) return;\n                        if (m.target.tagName === \"TEXTAREA\") {\n                            _this.genTextAreaValueMutation(m.target);\n                            return;\n                        }\n                        m.addedNodes.forEach(function(n2) {\n                            return _this.genAdds(n2, m.target);\n                        });\n                        m.removedNodes.forEach(function(n2) {\n                            var nodeId = _this.mirror.getId(n2);\n                            var parentId = isShadowRoot(m.target) ? _this.mirror.getId(index.host(m.target)) : _this.mirror.getId(m.target);\n                            if (isBlocked(m.target, _this.blockClass, _this.blockSelector, false) || isIgnored(n2, _this.mirror, _this.slimDOMOptions) || !isSerialized(n2, _this.mirror)) {\n                                return;\n                            }\n                            if (_this.addedSet.has(n2)) {\n                                deepDelete(_this.addedSet, n2);\n                                _this.droppedSet.add(n2);\n                            } else if (_this.addedSet.has(m.target) && nodeId === -1) ;\n                            else if (isAncestorRemoved(m.target, _this.mirror)) ;\n                            else if (_this.movedSet.has(n2) && _this.movedMap[moveKey(nodeId, parentId)]) {\n                                deepDelete(_this.movedSet, n2);\n                            } else {\n                                _this.removes.push({\n                                    parentId: parentId,\n                                    id: nodeId,\n                                    isShadow: isShadowRoot(m.target) && isNativeShadowDom(m.target) ? true : void 0\n                                });\n                                processRemoves(n2, _this.removesSubTreeCache);\n                            }\n                            _this.mapRemoves.push(n2);\n                        });\n                        break;\n                    }\n            }\n        });\n        /**\n     * Make sure you check if `n`'s parent is blocked before calling this function\n     * */ __publicField$1(this, \"genAdds\", function(n2, target) {\n            if (_this.processedNodeManager.inOtherBuffer(n2, _this)) return;\n            if (_this.addedSet.has(n2) || _this.movedSet.has(n2)) return;\n            if (_this.mirror.hasNode(n2)) {\n                if (isIgnored(n2, _this.mirror, _this.slimDOMOptions)) {\n                    return;\n                }\n                _this.movedSet.add(n2);\n                var targetId = null;\n                if (target && _this.mirror.hasNode(target)) {\n                    targetId = _this.mirror.getId(target);\n                }\n                if (targetId && targetId !== -1) {\n                    _this.movedMap[moveKey(_this.mirror.getId(n2), targetId)] = true;\n                }\n            } else {\n                _this.addedSet.add(n2);\n                _this.droppedSet.delete(n2);\n            }\n            if (!isBlocked(n2, _this.blockClass, _this.blockSelector, false)) {\n                index.childNodes(n2).forEach(function(childN) {\n                    return _this.genAdds(childN);\n                });\n                if (hasShadowRoot(n2)) {\n                    index.childNodes(index.shadowRoot(n2)).forEach(function(childN) {\n                        _this.processedNodeManager.add(childN, _this);\n                        _this.genAdds(childN, n2);\n                    });\n                }\n            }\n        });\n    }\n    var _proto = MutationBuffer.prototype;\n    _proto.init = function init(options) {\n        var _this = this;\n        [\n            \"mutationCb\",\n            \"blockClass\",\n            \"blockSelector\",\n            \"maskTextClass\",\n            \"maskTextSelector\",\n            \"inlineStylesheet\",\n            \"maskInputOptions\",\n            \"maskTextFn\",\n            \"maskInputFn\",\n            \"keepIframeSrcFn\",\n            \"recordCanvas\",\n            \"inlineImages\",\n            \"slimDOMOptions\",\n            \"dataURLOptions\",\n            \"doc\",\n            \"mirror\",\n            \"iframeManager\",\n            \"stylesheetManager\",\n            \"shadowDomManager\",\n            \"canvasManager\",\n            \"processedNodeManager\"\n        ].forEach(function(key) {\n            _this[key] = options[key];\n        });\n    };\n    _proto.freeze = function freeze() {\n        this.frozen = true;\n        this.canvasManager.freeze();\n    };\n    _proto.unfreeze = function unfreeze() {\n        this.frozen = false;\n        this.canvasManager.unfreeze();\n        this.emit();\n    };\n    _proto.isFrozen = function isFrozen() {\n        return this.frozen;\n    };\n    _proto.lock = function lock() {\n        this.locked = true;\n        this.canvasManager.lock();\n    };\n    _proto.unlock = function unlock() {\n        this.locked = false;\n        this.canvasManager.unlock();\n        this.emit();\n    };\n    _proto.reset = function reset() {\n        this.shadowDomManager.reset();\n        this.canvasManager.reset();\n    };\n    return MutationBuffer;\n}();\nfunction deepDelete(addsSet, n2) {\n    addsSet.delete(n2);\n    index.childNodes(n2).forEach(function(childN) {\n        return deepDelete(addsSet, childN);\n    });\n}\nfunction processRemoves(n2, cache) {\n    var queue = [\n        n2\n    ];\n    while(queue.length){\n        var next = queue.pop();\n        if (cache.has(next)) continue;\n        cache.add(next);\n        index.childNodes(next).forEach(function(n22) {\n            return queue.push(n22);\n        });\n    }\n    return;\n}\nfunction isParentRemoved(removes, n2, mirror2) {\n    if (removes.size === 0) return false;\n    return _isParentRemoved(removes, n2);\n}\nfunction _isParentRemoved(removes, n2, _mirror2) {\n    var node2 = index.parentNode(n2);\n    if (!node2) return false;\n    return removes.has(node2);\n}\nfunction isAncestorInSet(set, n2) {\n    if (set.size === 0) return false;\n    return _isAncestorInSet(set, n2);\n}\nfunction _isAncestorInSet(set, n2) {\n    var parent = index.parentNode(n2);\n    if (!parent) {\n        return false;\n    }\n    if (set.has(parent)) {\n        return true;\n    }\n    return _isAncestorInSet(set, parent);\n}\nvar errorHandler;\nfunction registerErrorHandler(handler) {\n    errorHandler = handler;\n}\nfunction unregisterErrorHandler() {\n    errorHandler = void 0;\n}\nvar callbackWrapper = function(cb) {\n    if (!errorHandler) {\n        return cb;\n    }\n    var rrwebWrapped = function() {\n        for(var _len = arguments.length, rest = new Array(_len), _key = 0; _key < _len; _key++){\n            rest[_key] = arguments[_key];\n        }\n        try {\n            return cb.apply(void 0, [].concat(rest));\n        } catch (error) {\n            if (errorHandler && errorHandler(error) === true) {\n                return;\n            }\n            throw error;\n        }\n    };\n    return rrwebWrapped;\n};\nvar mutationBuffers = [];\nfunction getEventTarget(event) {\n    try {\n        if (\"composedPath\" in event) {\n            var path = event.composedPath();\n            if (path.length) {\n                return path[0];\n            }\n        } else if (\"path\" in event && event.path.length) {\n            return event.path[0];\n        }\n    } catch (e) {}\n    return event && event.target;\n}\nfunction initMutationObserver(options, rootEl) {\n    var mutationBuffer = new MutationBuffer();\n    mutationBuffers.push(mutationBuffer);\n    mutationBuffer.init(options);\n    var observer = new (mutationObserverCtor())(callbackWrapper(mutationBuffer.processMutations.bind(mutationBuffer)));\n    observer.observe(rootEl, {\n        attributes: true,\n        attributeOldValue: true,\n        characterData: true,\n        characterDataOldValue: true,\n        childList: true,\n        subtree: true\n    });\n    return observer;\n}\nfunction initMoveObserver(param) {\n    var mousemoveCb = param.mousemoveCb, sampling = param.sampling, doc = param.doc, mirror2 = param.mirror;\n    if (sampling.mousemove === false) {\n        return function() {};\n    }\n    var threshold = typeof sampling.mousemove === \"number\" ? sampling.mousemove : 50;\n    var callbackThreshold = typeof sampling.mousemoveCallback === \"number\" ? sampling.mousemoveCallback : 500;\n    var positions = [];\n    var timeBaseline;\n    var wrappedCb = throttle(callbackWrapper(function(source) {\n        var totalOffset = Date.now() - timeBaseline;\n        mousemoveCb(positions.map(function(p) {\n            p.timeOffset -= totalOffset;\n            return p;\n        }), source);\n        positions = [];\n        timeBaseline = null;\n    }), callbackThreshold);\n    var updatePosition = callbackWrapper(throttle(callbackWrapper(function(evt) {\n        var target = getEventTarget(evt);\n        var _ref = legacy_isTouchEvent(evt) ? evt.changedTouches[0] : evt, clientX = _ref.clientX, clientY = _ref.clientY;\n        if (!timeBaseline) {\n            timeBaseline = nowTimestamp();\n        }\n        positions.push({\n            x: clientX,\n            y: clientY,\n            id: mirror2.getId(target),\n            timeOffset: nowTimestamp() - timeBaseline\n        });\n        wrappedCb(typeof DragEvent !== \"undefined\" && _instanceof(evt, DragEvent) ? IncrementalSource.Drag : _instanceof(evt, MouseEvent) ? IncrementalSource.MouseMove : IncrementalSource.TouchMove);\n    }), threshold, {\n        trailing: false\n    }));\n    var handlers = [\n        on(\"mousemove\", updatePosition, doc),\n        on(\"touchmove\", updatePosition, doc),\n        on(\"drag\", updatePosition, doc)\n    ];\n    return callbackWrapper(function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    });\n}\nfunction initMouseInteractionObserver(param) {\n    var mouseInteractionCb = param.mouseInteractionCb, doc = param.doc, mirror2 = param.mirror, blockClass = param.blockClass, blockSelector = param.blockSelector, sampling = param.sampling;\n    if (sampling.mouseInteraction === false) {\n        return function() {};\n    }\n    var disableMap = sampling.mouseInteraction === true || sampling.mouseInteraction === void 0 ? {} : sampling.mouseInteraction;\n    var handlers = [];\n    var currentPointerType = null;\n    var getHandler = function(eventKey) {\n        return function(event) {\n            var target = getEventTarget(event);\n            if (isBlocked(target, blockClass, blockSelector, true)) {\n                return;\n            }\n            var pointerType = null;\n            var thisEventKey = eventKey;\n            if (\"pointerType\" in event) {\n                switch(event.pointerType){\n                    case \"mouse\":\n                        pointerType = PointerTypes.Mouse;\n                        break;\n                    case \"touch\":\n                        pointerType = PointerTypes.Touch;\n                        break;\n                    case \"pen\":\n                        pointerType = PointerTypes.Pen;\n                        break;\n                }\n                if (pointerType === PointerTypes.Touch) {\n                    if (MouseInteractions[eventKey] === MouseInteractions.MouseDown) {\n                        thisEventKey = \"TouchStart\";\n                    } else if (MouseInteractions[eventKey] === MouseInteractions.MouseUp) {\n                        thisEventKey = \"TouchEnd\";\n                    }\n                } else if (pointerType === PointerTypes.Pen) ;\n            } else if (legacy_isTouchEvent(event)) {\n                pointerType = PointerTypes.Touch;\n            }\n            if (pointerType !== null) {\n                currentPointerType = pointerType;\n                if (thisEventKey.startsWith(\"Touch\") && pointerType === PointerTypes.Touch || thisEventKey.startsWith(\"Mouse\") && pointerType === PointerTypes.Mouse) {\n                    pointerType = null;\n                }\n            } else if (MouseInteractions[eventKey] === MouseInteractions.Click) {\n                pointerType = currentPointerType;\n                currentPointerType = null;\n            }\n            var e2 = legacy_isTouchEvent(event) ? event.changedTouches[0] : event;\n            if (!e2) {\n                return;\n            }\n            var id = mirror2.getId(target);\n            var clientX = e2.clientX, clientY = e2.clientY;\n            callbackWrapper(mouseInteractionCb)(_extends({\n                type: MouseInteractions[thisEventKey],\n                id: id,\n                x: clientX,\n                y: clientY\n            }, pointerType !== null && {\n                pointerType: pointerType\n            }));\n        };\n    };\n    Object.keys(MouseInteractions).filter(function(key) {\n        return Number.isNaN(Number(key)) && !key.endsWith(\"_Departed\") && disableMap[key] !== false;\n    }).forEach(function(eventKey) {\n        var eventName = toLowerCase(eventKey);\n        var handler = getHandler(eventKey);\n        if (window.PointerEvent) {\n            switch(MouseInteractions[eventKey]){\n                case MouseInteractions.MouseDown:\n                case MouseInteractions.MouseUp:\n                    eventName = eventName.replace(\"mouse\", \"pointer\");\n                    break;\n                case MouseInteractions.TouchStart:\n                case MouseInteractions.TouchEnd:\n                    return;\n            }\n        }\n        handlers.push(on(eventName, handler, doc));\n    });\n    return callbackWrapper(function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    });\n}\nfunction initScrollObserver(param) {\n    var scrollCb = param.scrollCb, doc = param.doc, mirror2 = param.mirror, blockClass = param.blockClass, blockSelector = param.blockSelector, sampling = param.sampling;\n    var updatePosition = callbackWrapper(throttle(callbackWrapper(function(evt) {\n        var target = getEventTarget(evt);\n        if (!target || isBlocked(target, blockClass, blockSelector, true)) {\n            return;\n        }\n        var id = mirror2.getId(target);\n        if (target === doc && doc.defaultView) {\n            var scrollLeftTop = getWindowScroll(doc.defaultView);\n            scrollCb({\n                id: id,\n                x: scrollLeftTop.left,\n                y: scrollLeftTop.top\n            });\n        } else {\n            scrollCb({\n                id: id,\n                x: target.scrollLeft,\n                y: target.scrollTop\n            });\n        }\n    }), sampling.scroll || 100));\n    return on(\"scroll\", updatePosition, doc);\n}\nfunction initViewportResizeObserver(param, param1) {\n    var viewportResizeCb = param.viewportResizeCb;\n    var win = param1.win;\n    var lastH = -1;\n    var lastW = -1;\n    var updateDimension = callbackWrapper(throttle(callbackWrapper(function() {\n        var height = getWindowHeight();\n        var width = getWindowWidth();\n        if (lastH !== height || lastW !== width) {\n            viewportResizeCb({\n                width: Number(width),\n                height: Number(height)\n            });\n            lastH = height;\n            lastW = width;\n        }\n    }), 200));\n    return on(\"resize\", updateDimension, win);\n}\nvar INPUT_TAGS = [\n    \"INPUT\",\n    \"TEXTAREA\",\n    \"SELECT\"\n];\nvar lastInputValueMap = /* @__PURE__ */ new WeakMap();\nfunction initInputObserver(param) {\n    var inputCb = param.inputCb, doc = param.doc, mirror2 = param.mirror, blockClass = param.blockClass, blockSelector = param.blockSelector, ignoreClass = param.ignoreClass, ignoreSelector = param.ignoreSelector, maskInputOptions = param.maskInputOptions, maskInputFn = param.maskInputFn, sampling = param.sampling, userTriggeredOnInput = param.userTriggeredOnInput;\n    function eventHandler(event) {\n        var target = getEventTarget(event);\n        var userTriggered = event.isTrusted;\n        var tagName = target && target.tagName;\n        if (target && tagName === \"OPTION\") {\n            target = index.parentElement(target);\n        }\n        if (!target || !tagName || INPUT_TAGS.indexOf(tagName) < 0 || isBlocked(target, blockClass, blockSelector, true)) {\n            return;\n        }\n        if (target.classList.contains(ignoreClass) || ignoreSelector && target.matches(ignoreSelector)) {\n            return;\n        }\n        var text = target.value;\n        var isChecked = false;\n        var type = getInputType(target) || \"\";\n        if (type === \"radio\" || type === \"checkbox\") {\n            isChecked = target.checked;\n        } else if (maskInputOptions[tagName.toLowerCase()] || maskInputOptions[type]) {\n            text = maskInputValue({\n                element: target,\n                maskInputOptions: maskInputOptions,\n                tagName: tagName,\n                type: type,\n                value: text,\n                maskInputFn: maskInputFn\n            });\n        }\n        cbWithDedup(target, userTriggeredOnInput ? {\n            text: text,\n            isChecked: isChecked,\n            userTriggered: userTriggered\n        } : {\n            text: text,\n            isChecked: isChecked\n        });\n        var name = target.name;\n        if (type === \"radio\" && name && isChecked) {\n            doc.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]').forEach(function(el) {\n                if (el !== target) {\n                    var text2 = el.value;\n                    cbWithDedup(el, userTriggeredOnInput ? {\n                        text: text2,\n                        isChecked: !isChecked,\n                        userTriggered: false\n                    } : {\n                        text: text2,\n                        isChecked: !isChecked\n                    });\n                }\n            });\n        }\n    }\n    function cbWithDedup(target, v2) {\n        var lastInputValue = lastInputValueMap.get(target);\n        if (!lastInputValue || lastInputValue.text !== v2.text || lastInputValue.isChecked !== v2.isChecked) {\n            lastInputValueMap.set(target, v2);\n            var id = mirror2.getId(target);\n            callbackWrapper(inputCb)(_extends({}, v2, {\n                id: id\n            }));\n        }\n    }\n    var events = sampling.input === \"last\" ? [\n        \"change\"\n    ] : [\n        \"input\",\n        \"change\"\n    ];\n    var handlers = events.map(function(eventName) {\n        return on(eventName, callbackWrapper(eventHandler), doc);\n    });\n    var currentWindow = doc.defaultView;\n    if (!currentWindow) {\n        return function() {\n            handlers.forEach(function(h) {\n                return h();\n            });\n        };\n    }\n    var propertyDescriptor = currentWindow.Object.getOwnPropertyDescriptor(currentWindow.HTMLInputElement.prototype, \"value\");\n    var hookProperties = [\n        [\n            currentWindow.HTMLInputElement.prototype,\n            \"value\"\n        ],\n        [\n            currentWindow.HTMLInputElement.prototype,\n            \"checked\"\n        ],\n        [\n            currentWindow.HTMLSelectElement.prototype,\n            \"value\"\n        ],\n        [\n            currentWindow.HTMLTextAreaElement.prototype,\n            \"value\"\n        ],\n        // Some UI library use selectedIndex to set select value\n        [\n            currentWindow.HTMLSelectElement.prototype,\n            \"selectedIndex\"\n        ],\n        [\n            currentWindow.HTMLOptionElement.prototype,\n            \"selected\"\n        ]\n    ];\n    if (propertyDescriptor && propertyDescriptor.set) {\n        var _handlers;\n        (_handlers = handlers).push.apply(_handlers, [].concat(hookProperties.map(function(p) {\n            return hookSetter(p[0], p[1], {\n                set: function set() {\n                    callbackWrapper(eventHandler)({\n                        target: this,\n                        isTrusted: false\n                    });\n                }\n            }, false, currentWindow);\n        })));\n    }\n    return callbackWrapper(function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    });\n}\nfunction getNestedCSSRulePositions(rule2) {\n    var positions = [];\n    function recurse(childRule, pos) {\n        if (hasNestedCSSRule(\"CSSGroupingRule\") && _instanceof(childRule.parentRule, CSSGroupingRule) || hasNestedCSSRule(\"CSSMediaRule\") && _instanceof(childRule.parentRule, CSSMediaRule) || hasNestedCSSRule(\"CSSSupportsRule\") && _instanceof(childRule.parentRule, CSSSupportsRule) || hasNestedCSSRule(\"CSSConditionRule\") && _instanceof(childRule.parentRule, CSSConditionRule)) {\n            var rules2 = Array.from(childRule.parentRule.cssRules);\n            var index2 = rules2.indexOf(childRule);\n            pos.unshift(index2);\n        } else if (childRule.parentStyleSheet) {\n            var rules21 = Array.from(childRule.parentStyleSheet.cssRules);\n            var index21 = rules21.indexOf(childRule);\n            pos.unshift(index21);\n        }\n        return pos;\n    }\n    return recurse(rule2, positions);\n}\nfunction getIdAndStyleId(sheet, mirror2, styleMirror) {\n    var id, styleId;\n    if (!sheet) return {};\n    if (sheet.ownerNode) id = mirror2.getId(sheet.ownerNode);\n    else styleId = styleMirror.getId(sheet);\n    return {\n        styleId: styleId,\n        id: id\n    };\n}\nfunction initStyleSheetObserver(param, param1) {\n    var styleSheetRuleCb = param.styleSheetRuleCb, mirror2 = param.mirror, stylesheetManager = param.stylesheetManager;\n    var win = param1.win;\n    if (!win.CSSStyleSheet || !win.CSSStyleSheet.prototype) {\n        return function() {};\n    }\n    var insertRule = win.CSSStyleSheet.prototype.insertRule;\n    win.CSSStyleSheet.prototype.insertRule = new Proxy(insertRule, {\n        apply: callbackWrapper(function(target, thisArg, argumentsList) {\n            var rule2 = argumentsList[0], index2 = argumentsList[1];\n            var _getIdAndStyleId = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n            if (id && id !== -1 || styleId && styleId !== -1) {\n                styleSheetRuleCb({\n                    id: id,\n                    styleId: styleId,\n                    adds: [\n                        {\n                            rule: rule2,\n                            index: index2\n                        }\n                    ]\n                });\n            }\n            return target.apply(thisArg, argumentsList);\n        })\n    });\n    win.CSSStyleSheet.prototype.addRule = function(selector, styleBlock, index2) {\n        if (index2 === void 0) index2 = this.cssRules.length;\n        var rule2 = selector + \" { \" + styleBlock + \" }\";\n        return win.CSSStyleSheet.prototype.insertRule.apply(this, [\n            rule2,\n            index2\n        ]);\n    };\n    var deleteRule = win.CSSStyleSheet.prototype.deleteRule;\n    win.CSSStyleSheet.prototype.deleteRule = new Proxy(deleteRule, {\n        apply: callbackWrapper(function(target, thisArg, argumentsList) {\n            var index2 = argumentsList[0];\n            var _getIdAndStyleId = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n            if (id && id !== -1 || styleId && styleId !== -1) {\n                styleSheetRuleCb({\n                    id: id,\n                    styleId: styleId,\n                    removes: [\n                        {\n                            index: index2\n                        }\n                    ]\n                });\n            }\n            return target.apply(thisArg, argumentsList);\n        })\n    });\n    win.CSSStyleSheet.prototype.removeRule = function(index2) {\n        return win.CSSStyleSheet.prototype.deleteRule.apply(this, [\n            index2\n        ]);\n    };\n    var replace;\n    if (win.CSSStyleSheet.prototype.replace) {\n        replace = win.CSSStyleSheet.prototype.replace;\n        win.CSSStyleSheet.prototype.replace = new Proxy(replace, {\n            apply: callbackWrapper(function(target, thisArg, argumentsList) {\n                var text = argumentsList[0];\n                var _getIdAndStyleId = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n                if (id && id !== -1 || styleId && styleId !== -1) {\n                    styleSheetRuleCb({\n                        id: id,\n                        styleId: styleId,\n                        replace: text\n                    });\n                }\n                return target.apply(thisArg, argumentsList);\n            })\n        });\n    }\n    var replaceSync;\n    if (win.CSSStyleSheet.prototype.replaceSync) {\n        replaceSync = win.CSSStyleSheet.prototype.replaceSync;\n        win.CSSStyleSheet.prototype.replaceSync = new Proxy(replaceSync, {\n            apply: callbackWrapper(function(target, thisArg, argumentsList) {\n                var text = argumentsList[0];\n                var _getIdAndStyleId = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n                if (id && id !== -1 || styleId && styleId !== -1) {\n                    styleSheetRuleCb({\n                        id: id,\n                        styleId: styleId,\n                        replaceSync: text\n                    });\n                }\n                return target.apply(thisArg, argumentsList);\n            })\n        });\n    }\n    var supportedNestedCSSRuleTypes = {};\n    if (canMonkeyPatchNestedCSSRule(\"CSSGroupingRule\")) {\n        supportedNestedCSSRuleTypes.CSSGroupingRule = win.CSSGroupingRule;\n    } else {\n        if (canMonkeyPatchNestedCSSRule(\"CSSMediaRule\")) {\n            supportedNestedCSSRuleTypes.CSSMediaRule = win.CSSMediaRule;\n        }\n        if (canMonkeyPatchNestedCSSRule(\"CSSConditionRule\")) {\n            supportedNestedCSSRuleTypes.CSSConditionRule = win.CSSConditionRule;\n        }\n        if (canMonkeyPatchNestedCSSRule(\"CSSSupportsRule\")) {\n            supportedNestedCSSRuleTypes.CSSSupportsRule = win.CSSSupportsRule;\n        }\n    }\n    var unmodifiedFunctions = {};\n    Object.entries(supportedNestedCSSRuleTypes).forEach(function(param) {\n        var typeKey = param[0], type = param[1];\n        unmodifiedFunctions[typeKey] = {\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            insertRule: type.prototype.insertRule,\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            deleteRule: type.prototype.deleteRule\n        };\n        type.prototype.insertRule = new Proxy(unmodifiedFunctions[typeKey].insertRule, {\n            apply: callbackWrapper(function(target, thisArg, argumentsList) {\n                var rule2 = argumentsList[0], index2 = argumentsList[1];\n                var _getIdAndStyleId = getIdAndStyleId(thisArg.parentStyleSheet, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n                if (id && id !== -1 || styleId && styleId !== -1) {\n                    styleSheetRuleCb({\n                        id: id,\n                        styleId: styleId,\n                        adds: [\n                            {\n                                rule: rule2,\n                                index: [].concat(getNestedCSSRulePositions(thisArg), [\n                                    index2 || 0\n                                ])\n                            }\n                        ]\n                    });\n                }\n                return target.apply(thisArg, argumentsList);\n            })\n        });\n        type.prototype.deleteRule = new Proxy(unmodifiedFunctions[typeKey].deleteRule, {\n            apply: callbackWrapper(function(target, thisArg, argumentsList) {\n                var index2 = argumentsList[0];\n                var _getIdAndStyleId = getIdAndStyleId(thisArg.parentStyleSheet, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n                if (id && id !== -1 || styleId && styleId !== -1) {\n                    styleSheetRuleCb({\n                        id: id,\n                        styleId: styleId,\n                        removes: [\n                            {\n                                index: [].concat(getNestedCSSRulePositions(thisArg), [\n                                    index2\n                                ])\n                            }\n                        ]\n                    });\n                }\n                return target.apply(thisArg, argumentsList);\n            })\n        });\n    });\n    return callbackWrapper(function() {\n        win.CSSStyleSheet.prototype.insertRule = insertRule;\n        win.CSSStyleSheet.prototype.deleteRule = deleteRule;\n        replace && (win.CSSStyleSheet.prototype.replace = replace);\n        replaceSync && (win.CSSStyleSheet.prototype.replaceSync = replaceSync);\n        Object.entries(supportedNestedCSSRuleTypes).forEach(function(param) {\n            var typeKey = param[0], type = param[1];\n            type.prototype.insertRule = unmodifiedFunctions[typeKey].insertRule;\n            type.prototype.deleteRule = unmodifiedFunctions[typeKey].deleteRule;\n        });\n    });\n}\nfunction initAdoptedStyleSheetObserver(param, host2) {\n    var mirror2 = param.mirror, stylesheetManager = param.stylesheetManager;\n    var _a2, _b, _c;\n    var hostId = null;\n    if (host2.nodeName === \"#document\") hostId = mirror2.getId(host2);\n    else hostId = mirror2.getId(index.host(host2));\n    var patchTarget = host2.nodeName === \"#document\" ? (_a2 = host2.defaultView) == null ? void 0 : _a2.Document : (_c = (_b = host2.ownerDocument) == null ? void 0 : _b.defaultView) == null ? void 0 : _c.ShadowRoot;\n    var originalPropertyDescriptor = (patchTarget == null ? void 0 : patchTarget.prototype) ? Object.getOwnPropertyDescriptor(patchTarget == null ? void 0 : patchTarget.prototype, \"adoptedStyleSheets\") : void 0;\n    if (hostId === null || hostId === -1 || !patchTarget || !originalPropertyDescriptor) return function() {};\n    Object.defineProperty(host2, \"adoptedStyleSheets\", {\n        configurable: originalPropertyDescriptor.configurable,\n        enumerable: originalPropertyDescriptor.enumerable,\n        get: function get() {\n            var _a3;\n            return (_a3 = originalPropertyDescriptor.get) == null ? void 0 : _a3.call(this);\n        },\n        set: function set(sheets) {\n            var _a3;\n            var result2 = (_a3 = originalPropertyDescriptor.set) == null ? void 0 : _a3.call(this, sheets);\n            if (hostId !== null && hostId !== -1) {\n                try {\n                    stylesheetManager.adoptStyleSheets(sheets, hostId);\n                } catch (e2) {}\n            }\n            return result2;\n        }\n    });\n    return callbackWrapper(function() {\n        Object.defineProperty(host2, \"adoptedStyleSheets\", {\n            configurable: originalPropertyDescriptor.configurable,\n            enumerable: originalPropertyDescriptor.enumerable,\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            get: originalPropertyDescriptor.get,\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            set: originalPropertyDescriptor.set\n        });\n    });\n}\nfunction initStyleDeclarationObserver(param, param1) {\n    var styleDeclarationCb = param.styleDeclarationCb, mirror2 = param.mirror, ignoreCSSAttributes = param.ignoreCSSAttributes, stylesheetManager = param.stylesheetManager;\n    var win = param1.win;\n    var setProperty = win.CSSStyleDeclaration.prototype.setProperty;\n    win.CSSStyleDeclaration.prototype.setProperty = new Proxy(setProperty, {\n        apply: callbackWrapper(function(target, thisArg, argumentsList) {\n            var _a2;\n            var property = argumentsList[0], value = argumentsList[1], priority = argumentsList[2];\n            if (ignoreCSSAttributes.has(property)) {\n                return setProperty.apply(thisArg, [\n                    property,\n                    value,\n                    priority\n                ]);\n            }\n            var _getIdAndStyleId = getIdAndStyleId((_a2 = thisArg.parentRule) == null ? void 0 : _a2.parentStyleSheet, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n            if (id && id !== -1 || styleId && styleId !== -1) {\n                styleDeclarationCb({\n                    id: id,\n                    styleId: styleId,\n                    set: {\n                        property: property,\n                        value: value,\n                        priority: priority\n                    },\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    index: getNestedCSSRulePositions(thisArg.parentRule)\n                });\n            }\n            return target.apply(thisArg, argumentsList);\n        })\n    });\n    var removeProperty = win.CSSStyleDeclaration.prototype.removeProperty;\n    win.CSSStyleDeclaration.prototype.removeProperty = new Proxy(removeProperty, {\n        apply: callbackWrapper(function(target, thisArg, argumentsList) {\n            var _a2;\n            var property = argumentsList[0];\n            if (ignoreCSSAttributes.has(property)) {\n                return removeProperty.apply(thisArg, [\n                    property\n                ]);\n            }\n            var _getIdAndStyleId = getIdAndStyleId((_a2 = thisArg.parentRule) == null ? void 0 : _a2.parentStyleSheet, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n            if (id && id !== -1 || styleId && styleId !== -1) {\n                styleDeclarationCb({\n                    id: id,\n                    styleId: styleId,\n                    remove: {\n                        property: property\n                    },\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    index: getNestedCSSRulePositions(thisArg.parentRule)\n                });\n            }\n            return target.apply(thisArg, argumentsList);\n        })\n    });\n    return callbackWrapper(function() {\n        win.CSSStyleDeclaration.prototype.setProperty = setProperty;\n        win.CSSStyleDeclaration.prototype.removeProperty = removeProperty;\n    });\n}\nfunction initMediaInteractionObserver(param) {\n    var mediaInteractionCb = param.mediaInteractionCb, blockClass = param.blockClass, blockSelector = param.blockSelector, mirror2 = param.mirror, sampling = param.sampling, doc = param.doc;\n    var handler = callbackWrapper(function(type) {\n        return throttle(callbackWrapper(function(event) {\n            var target = getEventTarget(event);\n            if (!target || isBlocked(target, blockClass, blockSelector, true)) {\n                return;\n            }\n            var currentTime = target.currentTime, volume = target.volume, muted = target.muted, playbackRate = target.playbackRate, loop = target.loop;\n            mediaInteractionCb({\n                type: type,\n                id: mirror2.getId(target),\n                currentTime: currentTime,\n                volume: volume,\n                muted: muted,\n                playbackRate: playbackRate,\n                loop: loop\n            });\n        }), sampling.media || 500);\n    });\n    var handlers = [\n        on(\"play\", handler(MediaInteractions.Play), doc),\n        on(\"pause\", handler(MediaInteractions.Pause), doc),\n        on(\"seeked\", handler(MediaInteractions.Seeked), doc),\n        on(\"volumechange\", handler(MediaInteractions.VolumeChange), doc),\n        on(\"ratechange\", handler(MediaInteractions.RateChange), doc)\n    ];\n    return callbackWrapper(function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    });\n}\nfunction initFontObserver(param) {\n    var fontCb = param.fontCb, doc = param.doc;\n    var win = doc.defaultView;\n    if (!win) {\n        return function() {};\n    }\n    var handlers = [];\n    var fontMap = /* @__PURE__ */ new WeakMap();\n    var originalFontFace = win.FontFace;\n    win.FontFace = function FontFace2(family, source, descriptors) {\n        var fontFace = new originalFontFace(family, source, descriptors);\n        fontMap.set(fontFace, {\n            family: family,\n            buffer: typeof source !== \"string\",\n            descriptors: descriptors,\n            fontSource: typeof source === \"string\" ? source : JSON.stringify(Array.from(new Uint8Array(source)))\n        });\n        return fontFace;\n    };\n    var restoreHandler = patch$2(doc.fonts, \"add\", function(original) {\n        return function(fontFace) {\n            setTimeout(callbackWrapper(function() {\n                var p = fontMap.get(fontFace);\n                if (p) {\n                    fontCb(p);\n                    fontMap.delete(fontFace);\n                }\n            }), 0);\n            return original.apply(this, [\n                fontFace\n            ]);\n        };\n    });\n    handlers.push(function() {\n        win.FontFace = originalFontFace;\n    });\n    handlers.push(restoreHandler);\n    return callbackWrapper(function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    });\n}\nfunction initSelectionObserver(param) {\n    var doc = param.doc, mirror2 = param.mirror, blockClass = param.blockClass, blockSelector = param.blockSelector, selectionCb = param.selectionCb;\n    var collapsed = true;\n    var updateSelection = callbackWrapper(function() {\n        var selection = doc.getSelection();\n        if (!selection || collapsed && (selection == null ? void 0 : selection.isCollapsed)) return;\n        collapsed = selection.isCollapsed || false;\n        var ranges = [];\n        var count = selection.rangeCount || 0;\n        for(var i2 = 0; i2 < count; i2++){\n            var range = selection.getRangeAt(i2);\n            var startContainer = range.startContainer, startOffset = range.startOffset, endContainer = range.endContainer, endOffset = range.endOffset;\n            var blocked = isBlocked(startContainer, blockClass, blockSelector, true) || isBlocked(endContainer, blockClass, blockSelector, true);\n            if (blocked) continue;\n            ranges.push({\n                start: mirror2.getId(startContainer),\n                startOffset: startOffset,\n                end: mirror2.getId(endContainer),\n                endOffset: endOffset\n            });\n        }\n        selectionCb({\n            ranges: ranges\n        });\n    });\n    updateSelection();\n    return on(\"selectionchange\", updateSelection);\n}\nfunction initCustomElementObserver(param) {\n    var doc = param.doc, customElementCb = param.customElementCb;\n    var win = doc.defaultView;\n    if (!win || !win.customElements) return function() {};\n    var restoreHandler = patch$2(win.customElements, \"define\", function(original) {\n        return function(name, constructor, options) {\n            try {\n                customElementCb({\n                    define: {\n                        name: name\n                    }\n                });\n            } catch (e2) {\n                console.warn(\"Custom element callback failed for \" + name);\n            }\n            return original.apply(this, [\n                name,\n                constructor,\n                options\n            ]);\n        };\n    });\n    return restoreHandler;\n}\nfunction mergeHooks(o2, hooks) {\n    var mutationCb = o2.mutationCb, mousemoveCb = o2.mousemoveCb, mouseInteractionCb = o2.mouseInteractionCb, scrollCb = o2.scrollCb, viewportResizeCb = o2.viewportResizeCb, inputCb = o2.inputCb, mediaInteractionCb = o2.mediaInteractionCb, styleSheetRuleCb = o2.styleSheetRuleCb, styleDeclarationCb = o2.styleDeclarationCb, canvasMutationCb = o2.canvasMutationCb, fontCb = o2.fontCb, selectionCb = o2.selectionCb, customElementCb = o2.customElementCb;\n    o2.mutationCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.mutation) {\n            var _hooks;\n            (_hooks = hooks).mutation.apply(_hooks, [].concat(p));\n        }\n        mutationCb.apply(void 0, [].concat(p));\n    };\n    o2.mousemoveCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.mousemove) {\n            var _hooks;\n            (_hooks = hooks).mousemove.apply(_hooks, [].concat(p));\n        }\n        mousemoveCb.apply(void 0, [].concat(p));\n    };\n    o2.mouseInteractionCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.mouseInteraction) {\n            var _hooks;\n            (_hooks = hooks).mouseInteraction.apply(_hooks, [].concat(p));\n        }\n        mouseInteractionCb.apply(void 0, [].concat(p));\n    };\n    o2.scrollCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.scroll) {\n            var _hooks;\n            (_hooks = hooks).scroll.apply(_hooks, [].concat(p));\n        }\n        scrollCb.apply(void 0, [].concat(p));\n    };\n    o2.viewportResizeCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.viewportResize) {\n            var _hooks;\n            (_hooks = hooks).viewportResize.apply(_hooks, [].concat(p));\n        }\n        viewportResizeCb.apply(void 0, [].concat(p));\n    };\n    o2.inputCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.input) {\n            var _hooks;\n            (_hooks = hooks).input.apply(_hooks, [].concat(p));\n        }\n        inputCb.apply(void 0, [].concat(p));\n    };\n    o2.mediaInteractionCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.mediaInteaction) {\n            var _hooks;\n            (_hooks = hooks).mediaInteaction.apply(_hooks, [].concat(p));\n        }\n        mediaInteractionCb.apply(void 0, [].concat(p));\n    };\n    o2.styleSheetRuleCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.styleSheetRule) {\n            var _hooks;\n            (_hooks = hooks).styleSheetRule.apply(_hooks, [].concat(p));\n        }\n        styleSheetRuleCb.apply(void 0, [].concat(p));\n    };\n    o2.styleDeclarationCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.styleDeclaration) {\n            var _hooks;\n            (_hooks = hooks).styleDeclaration.apply(_hooks, [].concat(p));\n        }\n        styleDeclarationCb.apply(void 0, [].concat(p));\n    };\n    o2.canvasMutationCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.canvasMutation) {\n            var _hooks;\n            (_hooks = hooks).canvasMutation.apply(_hooks, [].concat(p));\n        }\n        canvasMutationCb.apply(void 0, [].concat(p));\n    };\n    o2.fontCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.font) {\n            var _hooks;\n            (_hooks = hooks).font.apply(_hooks, [].concat(p));\n        }\n        fontCb.apply(void 0, [].concat(p));\n    };\n    o2.selectionCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.selection) {\n            var _hooks;\n            (_hooks = hooks).selection.apply(_hooks, [].concat(p));\n        }\n        selectionCb.apply(void 0, [].concat(p));\n    };\n    o2.customElementCb = function() {\n        for(var _len = arguments.length, c2 = new Array(_len), _key = 0; _key < _len; _key++){\n            c2[_key] = arguments[_key];\n        }\n        if (hooks.customElement) {\n            var _hooks;\n            (_hooks = hooks).customElement.apply(_hooks, [].concat(c2));\n        }\n        customElementCb.apply(void 0, [].concat(c2));\n    };\n}\nfunction initObservers(o2, hooks) {\n    if (hooks === void 0) hooks = {};\n    var currentWindow = o2.doc.defaultView;\n    if (!currentWindow) {\n        return function() {};\n    }\n    mergeHooks(o2, hooks);\n    var mutationObserver;\n    if (o2.recordDOM) {\n        mutationObserver = initMutationObserver(o2, o2.doc);\n    }\n    var mousemoveHandler = initMoveObserver(o2);\n    var mouseInteractionHandler = initMouseInteractionObserver(o2);\n    var scrollHandler = initScrollObserver(o2);\n    var viewportResizeHandler = initViewportResizeObserver(o2, {\n        win: currentWindow\n    });\n    var inputHandler = initInputObserver(o2);\n    var mediaInteractionHandler = initMediaInteractionObserver(o2);\n    var styleSheetObserver = function() {};\n    var adoptedStyleSheetObserver = function() {};\n    var styleDeclarationObserver = function() {};\n    var fontObserver = function() {};\n    if (o2.recordDOM) {\n        styleSheetObserver = initStyleSheetObserver(o2, {\n            win: currentWindow\n        });\n        adoptedStyleSheetObserver = initAdoptedStyleSheetObserver(o2, o2.doc);\n        styleDeclarationObserver = initStyleDeclarationObserver(o2, {\n            win: currentWindow\n        });\n        if (o2.collectFonts) {\n            fontObserver = initFontObserver(o2);\n        }\n    }\n    var selectionObserver = initSelectionObserver(o2);\n    var customElementObserver = initCustomElementObserver(o2);\n    var pluginHandlers = [];\n    for(var _iterator = _create_for_of_iterator_helper_loose(o2.plugins), _step; !(_step = _iterator()).done;){\n        var plugin3 = _step.value;\n        pluginHandlers.push(plugin3.observer(plugin3.callback, currentWindow, plugin3.options));\n    }\n    return callbackWrapper(function() {\n        mutationBuffers.forEach(function(b) {\n            return b.reset();\n        });\n        mutationObserver == null ? void 0 : mutationObserver.disconnect();\n        mousemoveHandler();\n        mouseInteractionHandler();\n        scrollHandler();\n        viewportResizeHandler();\n        inputHandler();\n        mediaInteractionHandler();\n        styleSheetObserver();\n        adoptedStyleSheetObserver();\n        styleDeclarationObserver();\n        fontObserver();\n        selectionObserver();\n        customElementObserver();\n        pluginHandlers.forEach(function(h) {\n            return h();\n        });\n    });\n}\nfunction hasNestedCSSRule(prop) {\n    return typeof window[prop] !== \"undefined\";\n}\nfunction canMonkeyPatchNestedCSSRule(prop) {\n    return Boolean(typeof window[prop] !== \"undefined\" && // Note: Generally, this check _shouldn't_ be necessary\n    // However, in some scenarios (e.g. jsdom) this can sometimes fail, so we check for it here\n    window[prop].prototype && \"insertRule\" in window[prop].prototype && \"deleteRule\" in window[prop].prototype);\n}\nvar CrossOriginIframeMirror = /*#__PURE__*/ function() {\n    function CrossOriginIframeMirror(generateIdFn) {\n        __publicField$1(this, \"iframeIdToRemoteIdMap\", /* @__PURE__ */ new WeakMap());\n        __publicField$1(this, \"iframeRemoteIdToIdMap\", /* @__PURE__ */ new WeakMap());\n        this.generateIdFn = generateIdFn;\n    }\n    var _proto = CrossOriginIframeMirror.prototype;\n    _proto.getId = function getId(iframe, remoteId, idToRemoteMap, remoteToIdMap) {\n        var idToRemoteIdMap = idToRemoteMap || this.getIdToRemoteIdMap(iframe);\n        var remoteIdToIdMap = remoteToIdMap || this.getRemoteIdToIdMap(iframe);\n        var id = idToRemoteIdMap.get(remoteId);\n        if (!id) {\n            id = this.generateIdFn();\n            idToRemoteIdMap.set(remoteId, id);\n            remoteIdToIdMap.set(id, remoteId);\n        }\n        return id;\n    };\n    _proto.getIds = function getIds(iframe, remoteId) {\n        var _this = this;\n        var idToRemoteIdMap = this.getIdToRemoteIdMap(iframe);\n        var remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\n        return remoteId.map(function(id) {\n            return _this.getId(iframe, id, idToRemoteIdMap, remoteIdToIdMap);\n        });\n    };\n    _proto.getRemoteId = function getRemoteId(iframe, id, map) {\n        var remoteIdToIdMap = map || this.getRemoteIdToIdMap(iframe);\n        if (typeof id !== \"number\") return id;\n        var remoteId = remoteIdToIdMap.get(id);\n        if (!remoteId) return -1;\n        return remoteId;\n    };\n    _proto.getRemoteIds = function getRemoteIds(iframe, ids) {\n        var _this = this;\n        var remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\n        return ids.map(function(id) {\n            return _this.getRemoteId(iframe, id, remoteIdToIdMap);\n        });\n    };\n    _proto.reset = function reset(iframe) {\n        if (!iframe) {\n            this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap();\n            this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();\n            return;\n        }\n        this.iframeIdToRemoteIdMap.delete(iframe);\n        this.iframeRemoteIdToIdMap.delete(iframe);\n    };\n    _proto.getIdToRemoteIdMap = function getIdToRemoteIdMap(iframe) {\n        var idToRemoteIdMap = this.iframeIdToRemoteIdMap.get(iframe);\n        if (!idToRemoteIdMap) {\n            idToRemoteIdMap = /* @__PURE__ */ new Map();\n            this.iframeIdToRemoteIdMap.set(iframe, idToRemoteIdMap);\n        }\n        return idToRemoteIdMap;\n    };\n    _proto.getRemoteIdToIdMap = function getRemoteIdToIdMap(iframe) {\n        var remoteIdToIdMap = this.iframeRemoteIdToIdMap.get(iframe);\n        if (!remoteIdToIdMap) {\n            remoteIdToIdMap = /* @__PURE__ */ new Map();\n            this.iframeRemoteIdToIdMap.set(iframe, remoteIdToIdMap);\n        }\n        return remoteIdToIdMap;\n    };\n    return CrossOriginIframeMirror;\n}();\nvar IframeManager = /*#__PURE__*/ function() {\n    function IframeManager(options) {\n        __publicField$1(this, \"iframes\", /* @__PURE__ */ new WeakMap());\n        __publicField$1(this, \"crossOriginIframeMap\", /* @__PURE__ */ new WeakMap());\n        __publicField$1(this, \"crossOriginIframeMirror\", new CrossOriginIframeMirror(genId));\n        __publicField$1(this, \"crossOriginIframeStyleMirror\");\n        __publicField$1(this, \"crossOriginIframeRootIdMap\", /* @__PURE__ */ new WeakMap());\n        __publicField$1(this, \"mirror\");\n        __publicField$1(this, \"mutationCb\");\n        __publicField$1(this, \"wrappedEmit\");\n        __publicField$1(this, \"loadListener\");\n        __publicField$1(this, \"stylesheetManager\");\n        __publicField$1(this, \"recordCrossOriginIframes\");\n        this.mutationCb = options.mutationCb;\n        this.wrappedEmit = options.wrappedEmit;\n        this.stylesheetManager = options.stylesheetManager;\n        this.recordCrossOriginIframes = options.recordCrossOriginIframes;\n        this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(this.stylesheetManager.styleMirror.generateId.bind(this.stylesheetManager.styleMirror));\n        this.mirror = options.mirror;\n        if (this.recordCrossOriginIframes) {\n            window.addEventListener(\"message\", this.handleMessage.bind(this));\n        }\n    }\n    var _proto = IframeManager.prototype;\n    _proto.addIframe = function addIframe(iframeEl) {\n        this.iframes.set(iframeEl, true);\n        if (iframeEl.contentWindow) this.crossOriginIframeMap.set(iframeEl.contentWindow, iframeEl);\n    };\n    _proto.addLoadListener = function addLoadListener(cb) {\n        this.loadListener = cb;\n    };\n    _proto.attachIframe = function attachIframe(iframeEl, childSn) {\n        var _a2, _b;\n        this.mutationCb({\n            adds: [\n                {\n                    parentId: this.mirror.getId(iframeEl),\n                    nextId: null,\n                    node: childSn\n                }\n            ],\n            removes: [],\n            texts: [],\n            attributes: [],\n            isAttachIframe: true\n        });\n        if (this.recordCrossOriginIframes) (_a2 = iframeEl.contentWindow) == null ? void 0 : _a2.addEventListener(\"message\", this.handleMessage.bind(this));\n        (_b = this.loadListener) == null ? void 0 : _b.call(this, iframeEl);\n        if (iframeEl.contentDocument && iframeEl.contentDocument.adoptedStyleSheets && iframeEl.contentDocument.adoptedStyleSheets.length > 0) this.stylesheetManager.adoptStyleSheets(iframeEl.contentDocument.adoptedStyleSheets, this.mirror.getId(iframeEl.contentDocument));\n    };\n    _proto.handleMessage = function handleMessage(message) {\n        var crossOriginMessageEvent = message;\n        if (crossOriginMessageEvent.data.type !== \"rrweb\" || // To filter out the rrweb messages which are forwarded by some sites.\n        crossOriginMessageEvent.origin !== crossOriginMessageEvent.data.origin) return;\n        var iframeSourceWindow = message.source;\n        if (!iframeSourceWindow) return;\n        var iframeEl = this.crossOriginIframeMap.get(message.source);\n        if (!iframeEl) return;\n        var transformedEvent = this.transformCrossOriginEvent(iframeEl, crossOriginMessageEvent.data.event);\n        if (transformedEvent) this.wrappedEmit(transformedEvent, crossOriginMessageEvent.data.isCheckout);\n    };\n    _proto.transformCrossOriginEvent = function transformCrossOriginEvent(iframeEl, e2) {\n        var _this = this;\n        var _a2;\n        switch(e2.type){\n            case EventType.FullSnapshot:\n                {\n                    this.crossOriginIframeMirror.reset(iframeEl);\n                    this.crossOriginIframeStyleMirror.reset(iframeEl);\n                    this.replaceIdOnNode(e2.data.node, iframeEl);\n                    var rootId = e2.data.node.id;\n                    this.crossOriginIframeRootIdMap.set(iframeEl, rootId);\n                    this.patchRootIdOnNode(e2.data.node, rootId);\n                    return {\n                        timestamp: e2.timestamp,\n                        type: EventType.IncrementalSnapshot,\n                        data: {\n                            source: IncrementalSource.Mutation,\n                            adds: [\n                                {\n                                    parentId: this.mirror.getId(iframeEl),\n                                    nextId: null,\n                                    node: e2.data.node\n                                }\n                            ],\n                            removes: [],\n                            texts: [],\n                            attributes: [],\n                            isAttachIframe: true\n                        }\n                    };\n                }\n            case EventType.Meta:\n            case EventType.Load:\n            case EventType.DomContentLoaded:\n                {\n                    return false;\n                }\n            case EventType.Plugin:\n                {\n                    return e2;\n                }\n            case EventType.Custom:\n                {\n                    this.replaceIds(e2.data.payload, iframeEl, [\n                        \"id\",\n                        \"parentId\",\n                        \"previousId\",\n                        \"nextId\"\n                    ]);\n                    return e2;\n                }\n            case EventType.IncrementalSnapshot:\n                {\n                    switch(e2.data.source){\n                        case IncrementalSource.Mutation:\n                            {\n                                e2.data.adds.forEach(function(n2) {\n                                    _this.replaceIds(n2, iframeEl, [\n                                        \"parentId\",\n                                        \"nextId\",\n                                        \"previousId\"\n                                    ]);\n                                    _this.replaceIdOnNode(n2.node, iframeEl);\n                                    var rootId = _this.crossOriginIframeRootIdMap.get(iframeEl);\n                                    rootId && _this.patchRootIdOnNode(n2.node, rootId);\n                                });\n                                e2.data.removes.forEach(function(n2) {\n                                    _this.replaceIds(n2, iframeEl, [\n                                        \"parentId\",\n                                        \"id\"\n                                    ]);\n                                });\n                                e2.data.attributes.forEach(function(n2) {\n                                    _this.replaceIds(n2, iframeEl, [\n                                        \"id\"\n                                    ]);\n                                });\n                                e2.data.texts.forEach(function(n2) {\n                                    _this.replaceIds(n2, iframeEl, [\n                                        \"id\"\n                                    ]);\n                                });\n                                return e2;\n                            }\n                        case IncrementalSource.Drag:\n                        case IncrementalSource.TouchMove:\n                        case IncrementalSource.MouseMove:\n                            {\n                                e2.data.positions.forEach(function(p) {\n                                    _this.replaceIds(p, iframeEl, [\n                                        \"id\"\n                                    ]);\n                                });\n                                return e2;\n                            }\n                        case IncrementalSource.ViewportResize:\n                            {\n                                return false;\n                            }\n                        case IncrementalSource.MediaInteraction:\n                        case IncrementalSource.MouseInteraction:\n                        case IncrementalSource.Scroll:\n                        case IncrementalSource.CanvasMutation:\n                        case IncrementalSource.Input:\n                            {\n                                this.replaceIds(e2.data, iframeEl, [\n                                    \"id\"\n                                ]);\n                                return e2;\n                            }\n                        case IncrementalSource.StyleSheetRule:\n                        case IncrementalSource.StyleDeclaration:\n                            {\n                                this.replaceIds(e2.data, iframeEl, [\n                                    \"id\"\n                                ]);\n                                this.replaceStyleIds(e2.data, iframeEl, [\n                                    \"styleId\"\n                                ]);\n                                return e2;\n                            }\n                        case IncrementalSource.Font:\n                            {\n                                return e2;\n                            }\n                        case IncrementalSource.Selection:\n                            {\n                                e2.data.ranges.forEach(function(range) {\n                                    _this.replaceIds(range, iframeEl, [\n                                        \"start\",\n                                        \"end\"\n                                    ]);\n                                });\n                                return e2;\n                            }\n                        case IncrementalSource.AdoptedStyleSheet:\n                            {\n                                this.replaceIds(e2.data, iframeEl, [\n                                    \"id\"\n                                ]);\n                                this.replaceStyleIds(e2.data, iframeEl, [\n                                    \"styleIds\"\n                                ]);\n                                (_a2 = e2.data.styles) == null ? void 0 : _a2.forEach(function(style) {\n                                    _this.replaceStyleIds(style, iframeEl, [\n                                        \"styleId\"\n                                    ]);\n                                });\n                                return e2;\n                            }\n                    }\n                }\n        }\n        return false;\n    };\n    _proto.replace = function replace(iframeMirror, obj, iframeEl, keys) {\n        for(var _iterator = _create_for_of_iterator_helper_loose(keys), _step; !(_step = _iterator()).done;){\n            var key = _step.value;\n            if (!Array.isArray(obj[key]) && typeof obj[key] !== \"number\") continue;\n            if (Array.isArray(obj[key])) {\n                obj[key] = iframeMirror.getIds(iframeEl, obj[key]);\n            } else {\n                obj[key] = iframeMirror.getId(iframeEl, obj[key]);\n            }\n        }\n        return obj;\n    };\n    _proto.replaceIds = function replaceIds(obj, iframeEl, keys) {\n        return this.replace(this.crossOriginIframeMirror, obj, iframeEl, keys);\n    };\n    _proto.replaceStyleIds = function replaceStyleIds(obj, iframeEl, keys) {\n        return this.replace(this.crossOriginIframeStyleMirror, obj, iframeEl, keys);\n    };\n    _proto.replaceIdOnNode = function replaceIdOnNode(node2, iframeEl) {\n        var _this = this;\n        this.replaceIds(node2, iframeEl, [\n            \"id\",\n            \"rootId\"\n        ]);\n        if (\"childNodes\" in node2) {\n            node2.childNodes.forEach(function(child) {\n                _this.replaceIdOnNode(child, iframeEl);\n            });\n        }\n    };\n    _proto.patchRootIdOnNode = function patchRootIdOnNode(node2, rootId) {\n        var _this = this;\n        if (node2.type !== NodeType.Document && !node2.rootId) node2.rootId = rootId;\n        if (\"childNodes\" in node2) {\n            node2.childNodes.forEach(function(child) {\n                _this.patchRootIdOnNode(child, rootId);\n            });\n        }\n    };\n    return IframeManager;\n}();\nvar ShadowDomManager = /*#__PURE__*/ function() {\n    function ShadowDomManager(options) {\n        __publicField$1(this, \"shadowDoms\", /* @__PURE__ */ new WeakSet());\n        __publicField$1(this, \"mutationCb\");\n        __publicField$1(this, \"scrollCb\");\n        __publicField$1(this, \"bypassOptions\");\n        __publicField$1(this, \"mirror\");\n        __publicField$1(this, \"restoreHandlers\", []);\n        this.mutationCb = options.mutationCb;\n        this.scrollCb = options.scrollCb;\n        this.bypassOptions = options.bypassOptions;\n        this.mirror = options.mirror;\n        this.init();\n    }\n    var _proto = ShadowDomManager.prototype;\n    _proto.init = function init() {\n        this.reset();\n        this.patchAttachShadow(Element, document);\n    };\n    _proto.addShadowRoot = function addShadowRoot(shadowRoot2, doc) {\n        var _this = this;\n        if (!isNativeShadowDom(shadowRoot2)) return;\n        if (this.shadowDoms.has(shadowRoot2)) return;\n        this.shadowDoms.add(shadowRoot2);\n        var observer = initMutationObserver(_extends({}, this.bypassOptions, {\n            doc: doc,\n            mutationCb: this.mutationCb,\n            mirror: this.mirror,\n            shadowDomManager: this\n        }), shadowRoot2);\n        this.restoreHandlers.push(function() {\n            return observer.disconnect();\n        });\n        this.restoreHandlers.push(initScrollObserver(_extends({}, this.bypassOptions, {\n            scrollCb: this.scrollCb,\n            // https://gist.github.com/praveenpuglia/0832da687ed5a5d7a0907046c9ef1813\n            // scroll is not allowed to pass the boundary, so we need to listen the shadow document\n            doc: shadowRoot2,\n            mirror: this.mirror\n        })));\n        setTimeout(function() {\n            if (shadowRoot2.adoptedStyleSheets && shadowRoot2.adoptedStyleSheets.length > 0) _this.bypassOptions.stylesheetManager.adoptStyleSheets(shadowRoot2.adoptedStyleSheets, _this.mirror.getId(index.host(shadowRoot2)));\n            _this.restoreHandlers.push(initAdoptedStyleSheetObserver({\n                mirror: _this.mirror,\n                stylesheetManager: _this.bypassOptions.stylesheetManager\n            }, shadowRoot2));\n        }, 0);\n    };\n    /**\n   * Monkey patch 'attachShadow' of an IFrameElement to observe newly added shadow doms.\n   */ _proto.observeAttachShadow = function observeAttachShadow(iframeElement) {\n        if (!iframeElement.contentWindow || !iframeElement.contentDocument) return;\n        this.patchAttachShadow(iframeElement.contentWindow.Element, iframeElement.contentDocument);\n    };\n    /**\n   * Patch 'attachShadow' to observe newly added shadow doms.\n   */ _proto.patchAttachShadow = function patchAttachShadow(element, doc) {\n        var manager = this;\n        this.restoreHandlers.push(patch$2(element.prototype, \"attachShadow\", function(original) {\n            return function(option) {\n                var sRoot = original.call(this, option);\n                var shadowRootEl = index.shadowRoot(this);\n                if (shadowRootEl && inDom(this)) manager.addShadowRoot(shadowRootEl, doc);\n                return sRoot;\n            };\n        }));\n    };\n    _proto.reset = function reset() {\n        this.restoreHandlers.forEach(function(handler) {\n            try {\n                handler();\n            } catch (e2) {}\n        });\n        this.restoreHandlers = [];\n        this.shadowDoms = /* @__PURE__ */ new WeakSet();\n    };\n    return ShadowDomManager;\n}();\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar lookup = typeof Uint8Array === \"undefined\" ? [] : new Uint8Array(256);\nfor(var i$1 = 0; i$1 < chars.length; i$1++){\n    lookup[chars.charCodeAt(i$1)] = i$1;\n}\nvar encode = function encode(arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer), i2, len = bytes.length, base64 = \"\";\n    for(i2 = 0; i2 < len; i2 += 3){\n        base64 += chars[bytes[i2] >> 2];\n        base64 += chars[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];\n        base64 += chars[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];\n        base64 += chars[bytes[i2 + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + \"=\";\n    } else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + \"==\";\n    }\n    return base64;\n};\nvar canvasVarMap = /* @__PURE__ */ new Map();\nfunction variableListFor$1(ctx, ctor) {\n    var contextMap = canvasVarMap.get(ctx);\n    if (!contextMap) {\n        contextMap = /* @__PURE__ */ new Map();\n        canvasVarMap.set(ctx, contextMap);\n    }\n    if (!contextMap.has(ctor)) {\n        contextMap.set(ctor, []);\n    }\n    return contextMap.get(ctor);\n}\nvar saveWebGLVar = function(value, win, ctx) {\n    if (!value || !(isInstanceOfWebGLObject(value, win) || (typeof value === \"undefined\" ? \"undefined\" : _type_of(value)) === \"object\")) return;\n    var name = value.constructor.name;\n    var list2 = variableListFor$1(ctx, name);\n    var index2 = list2.indexOf(value);\n    if (index2 === -1) {\n        index2 = list2.length;\n        list2.push(value);\n    }\n    return index2;\n};\nfunction serializeArg(value, win, ctx) {\n    if (_instanceof(value, Array)) {\n        return value.map(function(arg) {\n            return serializeArg(arg, win, ctx);\n        });\n    } else if (value === null) {\n        return value;\n    } else if (_instanceof(value, Float32Array) || _instanceof(value, Float64Array) || _instanceof(value, Int32Array) || _instanceof(value, Uint32Array) || _instanceof(value, Uint8Array) || _instanceof(value, Uint16Array) || _instanceof(value, Int16Array) || _instanceof(value, Int8Array) || _instanceof(value, Uint8ClampedArray)) {\n        var name = value.constructor.name;\n        return {\n            rr_type: name,\n            args: [\n                Object.values(value)\n            ]\n        };\n    } else if (// SharedArrayBuffer disabled on most browsers due to spectre.\n    // More info: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer/SharedArrayBuffer\n    // value instanceof SharedArrayBuffer ||\n    _instanceof(value, ArrayBuffer)) {\n        var name1 = value.constructor.name;\n        var base64 = encode(value);\n        return {\n            rr_type: name1,\n            base64: base64\n        };\n    } else if (_instanceof(value, DataView)) {\n        var name2 = value.constructor.name;\n        return {\n            rr_type: name2,\n            args: [\n                serializeArg(value.buffer, win, ctx),\n                value.byteOffset,\n                value.byteLength\n            ]\n        };\n    } else if (_instanceof(value, HTMLImageElement)) {\n        var name3 = value.constructor.name;\n        var src = value.src;\n        return {\n            rr_type: name3,\n            src: src\n        };\n    } else if (_instanceof(value, HTMLCanvasElement)) {\n        var name4 = \"HTMLImageElement\";\n        var src1 = value.toDataURL();\n        return {\n            rr_type: name4,\n            src: src1\n        };\n    } else if (_instanceof(value, ImageData)) {\n        var name5 = value.constructor.name;\n        return {\n            rr_type: name5,\n            args: [\n                serializeArg(value.data, win, ctx),\n                value.width,\n                value.height\n            ]\n        };\n    } else if (isInstanceOfWebGLObject(value, win) || (typeof value === \"undefined\" ? \"undefined\" : _type_of(value)) === \"object\") {\n        var name6 = value.constructor.name;\n        var index2 = saveWebGLVar(value, win, ctx);\n        return {\n            rr_type: name6,\n            index: index2\n        };\n    }\n    return value;\n}\nvar serializeArgs = function(args, win, ctx) {\n    return args.map(function(arg) {\n        return serializeArg(arg, win, ctx);\n    });\n};\nvar isInstanceOfWebGLObject = function(value, win) {\n    var webGLConstructorNames = [\n        \"WebGLActiveInfo\",\n        \"WebGLBuffer\",\n        \"WebGLFramebuffer\",\n        \"WebGLProgram\",\n        \"WebGLRenderbuffer\",\n        \"WebGLShader\",\n        \"WebGLShaderPrecisionFormat\",\n        \"WebGLTexture\",\n        \"WebGLUniformLocation\",\n        \"WebGLVertexArrayObject\",\n        // In old Chrome versions, value won't be an instanceof WebGLVertexArrayObject.\n        \"WebGLVertexArrayObjectOES\"\n    ];\n    var supportedWebGLConstructorNames = webGLConstructorNames.filter(function(name) {\n        return typeof win[name] === \"function\";\n    });\n    return Boolean(supportedWebGLConstructorNames.find(function(name) {\n        return _instanceof(value, win[name]);\n    }));\n};\nfunction initCanvas2DMutationObserver(cb, win, blockClass, blockSelector) {\n    var _loop = function() {\n        var prop = _step.value;\n        try {\n            if (typeof win.CanvasRenderingContext2D.prototype[prop] !== \"function\") {\n                return \"continue\";\n            }\n            var restoreHandler = patch$2(win.CanvasRenderingContext2D.prototype, prop, function(original) {\n                return function() {\n                    var _this = this;\n                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                        args[_key] = arguments[_key];\n                    }\n                    if (!isBlocked(this.canvas, blockClass, blockSelector, true)) {\n                        setTimeout(function() {\n                            var recordArgs = serializeArgs(args, win, _this);\n                            cb(_this.canvas, {\n                                type: CanvasContext[\"2D\"],\n                                property: prop,\n                                args: recordArgs\n                            });\n                        }, 0);\n                    }\n                    return original.apply(this, args);\n                };\n            });\n            handlers.push(restoreHandler);\n        } catch (e) {\n            var hookHandler = hookSetter(win.CanvasRenderingContext2D.prototype, prop, {\n                set: function set(v2) {\n                    cb(this.canvas, {\n                        type: CanvasContext[\"2D\"],\n                        property: prop,\n                        args: [\n                            v2\n                        ],\n                        setter: true\n                    });\n                }\n            });\n            handlers.push(hookHandler);\n        }\n    };\n    var handlers = [];\n    var props2D = Object.getOwnPropertyNames(win.CanvasRenderingContext2D.prototype);\n    for(var _iterator = _create_for_of_iterator_helper_loose(props2D), _step; !(_step = _iterator()).done;)_loop();\n    return function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    };\n}\nfunction getNormalizedContextName(contextType) {\n    return contextType === \"experimental-webgl\" ? \"webgl\" : contextType;\n}\nfunction initCanvasContextObserver(win, blockClass, blockSelector, setPreserveDrawingBufferToTrue) {\n    var handlers = [];\n    try {\n        var restoreHandler = patch$2(win.HTMLCanvasElement.prototype, \"getContext\", function(original) {\n            return function(contextType) {\n                for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    args[_key - 1] = arguments[_key];\n                }\n                if (!isBlocked(this, blockClass, blockSelector, true)) {\n                    var ctxName = getNormalizedContextName(contextType);\n                    if (!(\"__context\" in this)) this.__context = ctxName;\n                    if (setPreserveDrawingBufferToTrue && [\n                        \"webgl\",\n                        \"webgl2\"\n                    ].includes(ctxName)) {\n                        if (args[0] && _type_of(args[0]) === \"object\") {\n                            var contextAttributes = args[0];\n                            if (!contextAttributes.preserveDrawingBuffer) {\n                                contextAttributes.preserveDrawingBuffer = true;\n                            }\n                        } else {\n                            args.splice(0, 1, {\n                                preserveDrawingBuffer: true\n                            });\n                        }\n                    }\n                }\n                return original.apply(this, [].concat([\n                    contextType\n                ], args));\n            };\n        });\n        handlers.push(restoreHandler);\n    } catch (e) {\n        console.error(\"failed to patch HTMLCanvasElement.prototype.getContext\");\n    }\n    return function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    };\n}\nfunction patchGLPrototype(prototype, type, cb, blockClass, blockSelector, win) {\n    var _loop = function() {\n        var prop = _step.value;\n        if (//prop.startsWith('get') ||  // e.g. getProgramParameter, but too risky\n        [\n            \"isContextLost\",\n            \"canvas\",\n            \"drawingBufferWidth\",\n            \"drawingBufferHeight\"\n        ].includes(prop)) {\n            return \"continue\";\n        }\n        try {\n            if (typeof prototype[prop] !== \"function\") {\n                return \"continue\";\n            }\n            var restoreHandler = patch$2(prototype, prop, function(original) {\n                return function() {\n                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                        args[_key] = arguments[_key];\n                    }\n                    var result2 = original.apply(this, args);\n                    saveWebGLVar(result2, win, this);\n                    if (\"tagName\" in this.canvas && !isBlocked(this.canvas, blockClass, blockSelector, true)) {\n                        var recordArgs = serializeArgs(args, win, this);\n                        var mutation = {\n                            type: type,\n                            property: prop,\n                            args: recordArgs\n                        };\n                        cb(this.canvas, mutation);\n                    }\n                    return result2;\n                };\n            });\n            handlers.push(restoreHandler);\n        } catch (e) {\n            var hookHandler = hookSetter(prototype, prop, {\n                set: function set(v2) {\n                    cb(this.canvas, {\n                        type: type,\n                        property: prop,\n                        args: [\n                            v2\n                        ],\n                        setter: true\n                    });\n                }\n            });\n            handlers.push(hookHandler);\n        }\n    };\n    var handlers = [];\n    var props = Object.getOwnPropertyNames(prototype);\n    for(var _iterator = _create_for_of_iterator_helper_loose(props), _step; !(_step = _iterator()).done;)_loop();\n    return handlers;\n}\nfunction initCanvasWebGLMutationObserver(cb, win, blockClass, blockSelector) {\n    var _handlers;\n    var handlers = [];\n    (_handlers = handlers).push.apply(_handlers, [].concat(patchGLPrototype(win.WebGLRenderingContext.prototype, CanvasContext.WebGL, cb, blockClass, blockSelector, win)));\n    if (typeof win.WebGL2RenderingContext !== \"undefined\") {\n        var _handlers1;\n        (_handlers1 = handlers).push.apply(_handlers1, [].concat(patchGLPrototype(win.WebGL2RenderingContext.prototype, CanvasContext.WebGL2, cb, blockClass, blockSelector, win)));\n    }\n    return function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    };\n}\nvar encodedJs = \"KGZ1bmN0aW9uKCkgewogICJ1c2Ugc3RyaWN0IjsKICB2YXIgY2hhcnMgPSAiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyI7CiAgdmFyIGxvb2t1cCA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAidW5kZWZpbmVkIiA/IFtdIDogbmV3IFVpbnQ4QXJyYXkoMjU2KTsKICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7CiAgICBsb29rdXBbY2hhcnMuY2hhckNvZGVBdChpKV0gPSBpOwogIH0KICB2YXIgZW5jb2RlID0gZnVuY3Rpb24oYXJyYXlidWZmZXIpIHsKICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSwgaTIsIGxlbiA9IGJ5dGVzLmxlbmd0aCwgYmFzZTY0ID0gIiI7CiAgICBmb3IgKGkyID0gMDsgaTIgPCBsZW47IGkyICs9IDMpIHsKICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kyXSA+PiAyXTsKICAgICAgYmFzZTY0ICs9IGNoYXJzWyhieXRlc1tpMl0gJiAzKSA8PCA0IHwgYnl0ZXNbaTIgKyAxXSA+PiA0XTsKICAgICAgYmFzZTY0ICs9IGNoYXJzWyhieXRlc1tpMiArIDFdICYgMTUpIDw8IDIgfCBieXRlc1tpMiArIDJdID4+IDZdOwogICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaTIgKyAyXSAmIDYzXTsKICAgIH0KICAgIGlmIChsZW4gJSAzID09PSAyKSB7CiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgIj0iOwogICAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7CiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgIj09IjsKICAgIH0KICAgIHJldHVybiBiYXNlNjQ7CiAgfTsKICBjb25zdCBsYXN0QmxvYk1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7CiAgY29uc3QgdHJhbnNwYXJlbnRCbG9iTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTsKICBhc3luYyBmdW5jdGlvbiBnZXRUcmFuc3BhcmVudEJsb2JGb3Iod2lkdGgsIGhlaWdodCwgZGF0YVVSTE9wdGlvbnMpIHsKICAgIGNvbnN0IGlkID0gYCR7d2lkdGh9LSR7aGVpZ2h0fWA7CiAgICBpZiAoIk9mZnNjcmVlbkNhbnZhcyIgaW4gZ2xvYmFsVGhpcykgewogICAgICBpZiAodHJhbnNwYXJlbnRCbG9iTWFwLmhhcyhpZCkpIHJldHVybiB0cmFuc3BhcmVudEJsb2JNYXAuZ2V0KGlkKTsKICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTsKICAgICAgb2Zmc2NyZWVuLmdldENvbnRleHQoIjJkIik7CiAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCBvZmZzY3JlZW4uY29udmVydFRvQmxvYihkYXRhVVJMT3B0aW9ucyk7CiAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgYmxvYi5hcnJheUJ1ZmZlcigpOwogICAgICBjb25zdCBiYXNlNjQgPSBlbmNvZGUoYXJyYXlCdWZmZXIpOwogICAgICB0cmFuc3BhcmVudEJsb2JNYXAuc2V0KGlkLCBiYXNlNjQpOwogICAgICByZXR1cm4gYmFzZTY0OwogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuICIiOwogICAgfQogIH0KICBjb25zdCB3b3JrZXIgPSBzZWxmOwogIHdvcmtlci5vbm1lc3NhZ2UgPSBhc3luYyBmdW5jdGlvbihlKSB7CiAgICBpZiAoIk9mZnNjcmVlbkNhbnZhcyIgaW4gZ2xvYmFsVGhpcykgewogICAgICBjb25zdCB7IGlkLCBiaXRtYXAsIHdpZHRoLCBoZWlnaHQsIGRhdGFVUkxPcHRpb25zIH0gPSBlLmRhdGE7CiAgICAgIGNvbnN0IHRyYW5zcGFyZW50QmFzZTY0ID0gZ2V0VHJhbnNwYXJlbnRCbG9iRm9yKAogICAgICAgIHdpZHRoLAogICAgICAgIGhlaWdodCwKICAgICAgICBkYXRhVVJMT3B0aW9ucwogICAgICApOwogICAgICBjb25zdCBvZmZzY3JlZW4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoLCBoZWlnaHQpOwogICAgICBjb25zdCBjdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dCgiMmQiKTsKICAgICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDApOwogICAgICBiaXRtYXAuY2xvc2UoKTsKICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IG9mZnNjcmVlbi5jb252ZXJ0VG9CbG9iKGRhdGFVUkxPcHRpb25zKTsKICAgICAgY29uc3QgdHlwZSA9IGJsb2IudHlwZTsKICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCBibG9iLmFycmF5QnVmZmVyKCk7CiAgICAgIGNvbnN0IGJhc2U2NCA9IGVuY29kZShhcnJheUJ1ZmZlcik7CiAgICAgIGlmICghbGFzdEJsb2JNYXAuaGFzKGlkKSAmJiBhd2FpdCB0cmFuc3BhcmVudEJhc2U2NCA9PT0gYmFzZTY0KSB7CiAgICAgICAgbGFzdEJsb2JNYXAuc2V0KGlkLCBiYXNlNjQpOwogICAgICAgIHJldHVybiB3b3JrZXIucG9zdE1lc3NhZ2UoeyBpZCB9KTsKICAgICAgfQogICAgICBpZiAobGFzdEJsb2JNYXAuZ2V0KGlkKSA9PT0gYmFzZTY0KSByZXR1cm4gd29ya2VyLnBvc3RNZXNzYWdlKHsgaWQgfSk7CiAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7CiAgICAgICAgaWQsCiAgICAgICAgdHlwZSwKICAgICAgICBiYXNlNjQsCiAgICAgICAgd2lkdGgsCiAgICAgICAgaGVpZ2h0CiAgICAgIH0pOwogICAgICBsYXN0QmxvYk1hcC5zZXQoaWQsIGJhc2U2NCk7CiAgICB9IGVsc2UgewogICAgICByZXR1cm4gd29ya2VyLnBvc3RNZXNzYWdlKHsgaWQ6IGUuZGF0YS5pZCB9KTsKICAgIH0KICB9Owp9KSgpOwovLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZS1iaXRtYXAtZGF0YS11cmwtd29ya2VyLUlKcEM3Z19iLmpzLm1hcAo=\";\nvar decodeBase64 = function(base64) {\n    return Uint8Array.from(atob(base64), function(c2) {\n        return c2.charCodeAt(0);\n    });\n};\nvar blob = typeof window !== \"undefined\" && window.Blob && new Blob([\n    decodeBase64(encodedJs)\n], {\n    type: \"text/javascript;charset=utf-8\"\n});\nfunction WorkerWrapper(options) {\n    var objURL;\n    try {\n        objURL = blob && (window.URL || window.webkitURL).createObjectURL(blob);\n        if (!objURL) throw \"\";\n        var worker = new Worker(objURL, {\n            name: options == null ? void 0 : options.name\n        });\n        worker.addEventListener(\"error\", function() {\n            (window.URL || window.webkitURL).revokeObjectURL(objURL);\n        });\n        return worker;\n    } catch (e2) {\n        return new Worker(\"data:text/javascript;base64,\" + encodedJs, {\n            name: options == null ? void 0 : options.name\n        });\n    } finally{\n        objURL && (window.URL || window.webkitURL).revokeObjectURL(objURL);\n    }\n}\nvar CanvasManager = /*#__PURE__*/ function() {\n    function CanvasManager(options) {\n        var _this = this;\n        __publicField$1(this, \"pendingCanvasMutations\", /* @__PURE__ */ new Map());\n        __publicField$1(this, \"rafStamps\", {\n            latestId: 0,\n            invokeId: null\n        });\n        __publicField$1(this, \"mirror\");\n        __publicField$1(this, \"mutationCb\");\n        __publicField$1(this, \"resetObservers\");\n        __publicField$1(this, \"frozen\", false);\n        __publicField$1(this, \"locked\", false);\n        __publicField$1(this, \"processMutation\", function(target, mutation) {\n            var newFrame = _this.rafStamps.invokeId && _this.rafStamps.latestId !== _this.rafStamps.invokeId;\n            if (newFrame || !_this.rafStamps.invokeId) _this.rafStamps.invokeId = _this.rafStamps.latestId;\n            if (!_this.pendingCanvasMutations.has(target)) {\n                _this.pendingCanvasMutations.set(target, []);\n            }\n            _this.pendingCanvasMutations.get(target).push(mutation);\n        });\n        var _options_sampling = options.sampling, sampling = _options_sampling === void 0 ? \"all\" : _options_sampling, win = options.win, blockClass = options.blockClass, blockSelector = options.blockSelector, recordCanvas = options.recordCanvas, dataURLOptions = options.dataURLOptions;\n        this.mutationCb = options.mutationCb;\n        this.mirror = options.mirror;\n        if (recordCanvas && sampling === \"all\") this.initCanvasMutationObserver(win, blockClass, blockSelector);\n        if (recordCanvas && typeof sampling === \"number\") this.initCanvasFPSObserver(sampling, win, blockClass, blockSelector, {\n            dataURLOptions: dataURLOptions\n        });\n    }\n    var _proto = CanvasManager.prototype;\n    _proto.reset = function reset() {\n        this.pendingCanvasMutations.clear();\n        this.resetObservers && this.resetObservers();\n    };\n    _proto.freeze = function freeze() {\n        this.frozen = true;\n    };\n    _proto.unfreeze = function unfreeze() {\n        this.frozen = false;\n    };\n    _proto.lock = function lock() {\n        this.locked = true;\n    };\n    _proto.unlock = function unlock() {\n        this.locked = false;\n    };\n    _proto.initCanvasFPSObserver = function initCanvasFPSObserver(fps, win, blockClass, blockSelector, options) {\n        var _this = this;\n        var canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector, true);\n        var snapshotInProgressMap = /* @__PURE__ */ new Map();\n        var worker = new WorkerWrapper();\n        worker.onmessage = function(e2) {\n            var id = e2.data.id;\n            snapshotInProgressMap.set(id, false);\n            if (!(\"base64\" in e2.data)) return;\n            var _e2_data = e2.data, base64 = _e2_data.base64, type = _e2_data.type, width = _e2_data.width, height = _e2_data.height;\n            _this.mutationCb({\n                id: id,\n                type: CanvasContext[\"2D\"],\n                commands: [\n                    {\n                        property: \"clearRect\",\n                        // wipe canvas\n                        args: [\n                            0,\n                            0,\n                            width,\n                            height\n                        ]\n                    },\n                    {\n                        property: \"drawImage\",\n                        // draws (semi-transparent) image\n                        args: [\n                            {\n                                rr_type: \"ImageBitmap\",\n                                args: [\n                                    {\n                                        rr_type: \"Blob\",\n                                        data: [\n                                            {\n                                                rr_type: \"ArrayBuffer\",\n                                                base64: base64\n                                            }\n                                        ],\n                                        type: type\n                                    }\n                                ]\n                            },\n                            0,\n                            0\n                        ]\n                    }\n                ]\n            });\n        };\n        var timeBetweenSnapshots = 1e3 / fps;\n        var lastSnapshotTime = 0;\n        var rafId;\n        var getCanvas = function() {\n            var matchedCanvas = [];\n            win.document.querySelectorAll(\"canvas\").forEach(function(canvas) {\n                if (!isBlocked(canvas, blockClass, blockSelector, true)) {\n                    matchedCanvas.push(canvas);\n                }\n            });\n            return matchedCanvas;\n        };\n        var takeCanvasSnapshots = function(timestamp) {\n            if (lastSnapshotTime && timestamp - lastSnapshotTime < timeBetweenSnapshots) {\n                rafId = requestAnimationFrame(takeCanvasSnapshots);\n                return;\n            }\n            lastSnapshotTime = timestamp;\n            var _this1 = _this;\n            getCanvas().forEach(/*#__PURE__*/ _async_to_generator(function(canvas) {\n                var _a2, id, context, bitmap;\n                return _ts_generator(this, function(_state) {\n                    switch(_state.label){\n                        case 0:\n                            id = _this1.mirror.getId(canvas);\n                            if (snapshotInProgressMap.get(id)) return [\n                                2\n                            ];\n                            if (canvas.width === 0 || canvas.height === 0) return [\n                                2\n                            ];\n                            snapshotInProgressMap.set(id, true);\n                            if ([\n                                \"webgl\",\n                                \"webgl2\"\n                            ].includes(canvas.__context)) {\n                                context = canvas.getContext(canvas.__context);\n                                if (((_a2 = context == null ? void 0 : context.getContextAttributes()) == null ? void 0 : _a2.preserveDrawingBuffer) === false) {\n                                    context.clear(context.COLOR_BUFFER_BIT);\n                                }\n                            }\n                            return [\n                                4,\n                                createImageBitmap(canvas)\n                            ];\n                        case 1:\n                            bitmap = _state.sent();\n                            worker.postMessage({\n                                id: id,\n                                bitmap: bitmap,\n                                width: canvas.width,\n                                height: canvas.height,\n                                dataURLOptions: options.dataURLOptions\n                            }, [\n                                bitmap\n                            ]);\n                            return [\n                                2\n                            ];\n                    }\n                });\n            }));\n            rafId = requestAnimationFrame(takeCanvasSnapshots);\n        };\n        rafId = requestAnimationFrame(takeCanvasSnapshots);\n        this.resetObservers = function() {\n            canvasContextReset();\n            cancelAnimationFrame(rafId);\n        };\n    };\n    _proto.initCanvasMutationObserver = function initCanvasMutationObserver(win, blockClass, blockSelector) {\n        this.startRAFTimestamping();\n        this.startPendingCanvasMutationFlusher();\n        var canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector, false);\n        var canvas2DReset = initCanvas2DMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector);\n        var canvasWebGL1and2Reset = initCanvasWebGLMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector);\n        this.resetObservers = function() {\n            canvasContextReset();\n            canvas2DReset();\n            canvasWebGL1and2Reset();\n        };\n    };\n    _proto.startPendingCanvasMutationFlusher = function startPendingCanvasMutationFlusher() {\n        var _this = this;\n        requestAnimationFrame(function() {\n            return _this.flushPendingCanvasMutations();\n        });\n    };\n    _proto.startRAFTimestamping = function startRAFTimestamping() {\n        var _this = this;\n        var setLatestRAFTimestamp = function(timestamp) {\n            _this.rafStamps.latestId = timestamp;\n            requestAnimationFrame(setLatestRAFTimestamp);\n        };\n        requestAnimationFrame(setLatestRAFTimestamp);\n    };\n    _proto.flushPendingCanvasMutations = function flushPendingCanvasMutations() {\n        var _this = this;\n        this.pendingCanvasMutations.forEach(function(_values, canvas) {\n            var id = _this.mirror.getId(canvas);\n            _this.flushPendingCanvasMutationFor(canvas, id);\n        });\n        requestAnimationFrame(function() {\n            return _this.flushPendingCanvasMutations();\n        });\n    };\n    _proto.flushPendingCanvasMutationFor = function flushPendingCanvasMutationFor(canvas, id) {\n        if (this.frozen || this.locked) {\n            return;\n        }\n        var valuesWithType = this.pendingCanvasMutations.get(canvas);\n        if (!valuesWithType || id === -1) return;\n        var values = valuesWithType.map(function(value) {\n            value.type; var rest = _object_without_properties_loose(value, [\n                \"type\"\n            ]);\n            return rest;\n        });\n        var type = valuesWithType[0].type;\n        this.mutationCb({\n            id: id,\n            type: type,\n            commands: values\n        });\n        this.pendingCanvasMutations.delete(canvas);\n    };\n    return CanvasManager;\n}();\nvar StylesheetManager = /*#__PURE__*/ function() {\n    function StylesheetManager(options) {\n        __publicField$1(this, \"trackedLinkElements\", /* @__PURE__ */ new WeakSet());\n        __publicField$1(this, \"mutationCb\");\n        __publicField$1(this, \"adoptedStyleSheetCb\");\n        __publicField$1(this, \"styleMirror\", new StyleSheetMirror());\n        this.mutationCb = options.mutationCb;\n        this.adoptedStyleSheetCb = options.adoptedStyleSheetCb;\n    }\n    var _proto = StylesheetManager.prototype;\n    _proto.attachLinkElement = function attachLinkElement(linkEl, childSn) {\n        if (\"_cssText\" in childSn.attributes) this.mutationCb({\n            adds: [],\n            removes: [],\n            texts: [],\n            attributes: [\n                {\n                    id: childSn.id,\n                    attributes: childSn.attributes\n                }\n            ]\n        });\n        this.trackLinkElement(linkEl);\n    };\n    _proto.trackLinkElement = function trackLinkElement(linkEl) {\n        if (this.trackedLinkElements.has(linkEl)) return;\n        this.trackedLinkElements.add(linkEl);\n        this.trackStylesheetInLinkElement(linkEl);\n    };\n    _proto.adoptStyleSheets = function adoptStyleSheets(sheets, hostId) {\n        var _this, _loop = function() {\n            var sheet = _step.value;\n            var styleId = void 0;\n            if (!_this.styleMirror.has(sheet)) {\n                styleId = _this.styleMirror.add(sheet);\n                styles.push({\n                    styleId: styleId,\n                    rules: Array.from(sheet.rules || CSSRule, function(r2, index2) {\n                        return {\n                            rule: stringifyRule(r2, sheet.href),\n                            index: index2\n                        };\n                    })\n                });\n            } else styleId = _this.styleMirror.getId(sheet);\n            adoptedStyleSheetData.styleIds.push(styleId);\n        };\n        if (sheets.length === 0) return;\n        var adoptedStyleSheetData = {\n            id: hostId,\n            styleIds: []\n        };\n        var styles = [];\n        for(var _iterator = _create_for_of_iterator_helper_loose(sheets), _step; !(_step = _iterator()).done;)_this = this, _loop();\n        if (styles.length > 0) adoptedStyleSheetData.styles = styles;\n        this.adoptedStyleSheetCb(adoptedStyleSheetData);\n    };\n    _proto.reset = function reset() {\n        this.styleMirror.reset();\n        this.trackedLinkElements = /* @__PURE__ */ new WeakSet();\n    };\n    // TODO: take snapshot on stylesheet reload by applying event listener\n    _proto.trackStylesheetInLinkElement = function trackStylesheetInLinkElement(_linkEl) {};\n    return StylesheetManager;\n}();\nvar ProcessedNodeManager = /*#__PURE__*/ function() {\n    function ProcessedNodeManager() {\n        __publicField$1(this, \"nodeMap\", /* @__PURE__ */ new WeakMap());\n        __publicField$1(this, \"active\", false);\n    }\n    var _proto = ProcessedNodeManager.prototype;\n    _proto.inOtherBuffer = function inOtherBuffer(node2, thisBuffer) {\n        var buffers = this.nodeMap.get(node2);\n        return buffers && Array.from(buffers).some(function(buffer) {\n            return buffer !== thisBuffer;\n        });\n    };\n    _proto.add = function add(node2, buffer) {\n        var _this = this;\n        if (!this.active) {\n            this.active = true;\n            requestAnimationFrame(function() {\n                _this.nodeMap = /* @__PURE__ */ new WeakMap();\n                _this.active = false;\n            });\n        }\n        this.nodeMap.set(node2, (this.nodeMap.get(node2) || /* @__PURE__ */ new Set()).add(buffer));\n    };\n    _proto.destroy = function destroy() {};\n    return ProcessedNodeManager;\n}();\nvar wrappedEmit;\nvar takeFullSnapshot$1;\nvar canvasManager;\nvar recording = false;\ntry {\n    if (Array.from([\n        1\n    ], function(x2) {\n        return x2 * 2;\n    })[0] !== 2) {\n        var cleanFrame = document.createElement(\"iframe\");\n        document.body.appendChild(cleanFrame);\n        Array.from = ((_a = cleanFrame.contentWindow) == null ? void 0 : _a.Array.from) || Array.from;\n        document.body.removeChild(cleanFrame);\n    }\n} catch (err) {\n    console.debug(\"Unable to override Array.from\", err);\n}\nvar mirror = createMirror$2();\nfunction record(options) {\n    if (options === void 0) options = {};\n    var emit = options.emit, checkoutEveryNms = options.checkoutEveryNms, checkoutEveryNth = options.checkoutEveryNth, _options_blockClass = options.blockClass, blockClass = _options_blockClass === void 0 ? \"rr-block\" : _options_blockClass, _options_blockSelector = options.blockSelector, blockSelector = _options_blockSelector === void 0 ? null : _options_blockSelector, _options_ignoreClass = options.ignoreClass, ignoreClass = _options_ignoreClass === void 0 ? \"rr-ignore\" : _options_ignoreClass, _options_ignoreSelector = options.ignoreSelector, ignoreSelector = _options_ignoreSelector === void 0 ? null : _options_ignoreSelector, _options_maskTextClass = options.maskTextClass, maskTextClass = _options_maskTextClass === void 0 ? \"rr-mask\" : _options_maskTextClass, _options_maskTextSelector = options.maskTextSelector, maskTextSelector = _options_maskTextSelector === void 0 ? null : _options_maskTextSelector, _options_inlineStylesheet = options.inlineStylesheet, inlineStylesheet = _options_inlineStylesheet === void 0 ? true : _options_inlineStylesheet, maskAllInputs = options.maskAllInputs, _maskInputOptions = options.maskInputOptions, _slimDOMOptions = options.slimDOMOptions, maskInputFn = options.maskInputFn, maskTextFn = options.maskTextFn, hooks = options.hooks, packFn = options.packFn, _options_sampling = options.sampling, sampling = _options_sampling === void 0 ? {} : _options_sampling, _options_dataURLOptions = options.dataURLOptions, dataURLOptions = _options_dataURLOptions === void 0 ? {} : _options_dataURLOptions, mousemoveWait = options.mousemoveWait, _options_recordDOM = options.recordDOM, recordDOM = _options_recordDOM === void 0 ? true : _options_recordDOM, _options_recordCanvas = options.recordCanvas, recordCanvas = _options_recordCanvas === void 0 ? false : _options_recordCanvas, _options_recordCrossOriginIframes = options.recordCrossOriginIframes, recordCrossOriginIframes = _options_recordCrossOriginIframes === void 0 ? false : _options_recordCrossOriginIframes, _options_recordAfter = options.recordAfter, recordAfter = _options_recordAfter === void 0 ? options.recordAfter === \"DOMContentLoaded\" ? options.recordAfter : \"load\" : _options_recordAfter, _options_userTriggeredOnInput = options.userTriggeredOnInput, userTriggeredOnInput = _options_userTriggeredOnInput === void 0 ? false : _options_userTriggeredOnInput, _options_collectFonts = options.collectFonts, collectFonts = _options_collectFonts === void 0 ? false : _options_collectFonts, _options_inlineImages = options.inlineImages, inlineImages = _options_inlineImages === void 0 ? false : _options_inlineImages, plugins = options.plugins, _options_keepIframeSrcFn = options.keepIframeSrcFn, keepIframeSrcFn = _options_keepIframeSrcFn === void 0 ? function() {\n        return false;\n    } : _options_keepIframeSrcFn, _options_ignoreCSSAttributes = options.ignoreCSSAttributes, ignoreCSSAttributes = _options_ignoreCSSAttributes === void 0 ? /* @__PURE__ */ new Set([]) : _options_ignoreCSSAttributes, errorHandler2 = options.errorHandler;\n    registerErrorHandler(errorHandler2);\n    var inEmittingFrame = recordCrossOriginIframes ? window.parent === window : true;\n    var passEmitsToParent = false;\n    if (!inEmittingFrame) {\n        try {\n            if (window.parent.document) {\n                passEmitsToParent = false;\n            }\n        } catch (e2) {\n            passEmitsToParent = true;\n        }\n    }\n    if (inEmittingFrame && !emit) {\n        throw new Error(\"emit function is required\");\n    }\n    if (!inEmittingFrame && !passEmitsToParent) {\n        return function() {};\n    }\n    if (mousemoveWait !== void 0 && sampling.mousemove === void 0) {\n        sampling.mousemove = mousemoveWait;\n    }\n    mirror.reset();\n    var maskInputOptions = maskAllInputs === true ? {\n        color: true,\n        date: true,\n        \"datetime-local\": true,\n        email: true,\n        month: true,\n        number: true,\n        range: true,\n        search: true,\n        tel: true,\n        text: true,\n        time: true,\n        url: true,\n        week: true,\n        textarea: true,\n        select: true,\n        password: true,\n        hidden: true\n    } : _maskInputOptions !== void 0 ? _maskInputOptions : {\n        password: true\n    };\n    var slimDOMOptions = _slimDOMOptions === true || _slimDOMOptions === \"all\" ? {\n        script: true,\n        comment: true,\n        headFavicon: true,\n        headWhitespace: true,\n        headMetaSocial: true,\n        headMetaRobots: true,\n        headMetaHttpEquiv: true,\n        headMetaVerification: true,\n        // the following are off for slimDOMOptions === true,\n        // as they destroy some (hidden) info:\n        headMetaAuthorship: _slimDOMOptions === \"all\",\n        headMetaDescKeywords: _slimDOMOptions === \"all\",\n        headTitleMutations: _slimDOMOptions === \"all\"\n    } : _slimDOMOptions ? _slimDOMOptions : {};\n    polyfill$1();\n    var lastFullSnapshotEvent;\n    var incrementalSnapshotCount = 0;\n    var eventProcessor = function(e2) {\n        for(var _iterator = _create_for_of_iterator_helper_loose(plugins || []), _step; !(_step = _iterator()).done;){\n            var plugin3 = _step.value;\n            if (plugin3.eventProcessor) {\n                e2 = plugin3.eventProcessor(e2);\n            }\n        }\n        if (packFn && // Disable packing events which will be emitted to parent frames.\n        !passEmitsToParent) {\n            e2 = packFn(e2);\n        }\n        return e2;\n    };\n    wrappedEmit = function(r2, isCheckout) {\n        var _a2;\n        var e2 = r2;\n        e2.timestamp = nowTimestamp();\n        if (((_a2 = mutationBuffers[0]) == null ? void 0 : _a2.isFrozen()) && e2.type !== EventType.FullSnapshot && !(e2.type === EventType.IncrementalSnapshot && e2.data.source === IncrementalSource.Mutation)) {\n            mutationBuffers.forEach(function(buf) {\n                return buf.unfreeze();\n            });\n        }\n        if (inEmittingFrame) {\n            emit == null ? void 0 : emit(eventProcessor(e2), isCheckout);\n        } else if (passEmitsToParent) {\n            var message = {\n                type: \"rrweb\",\n                event: eventProcessor(e2),\n                origin: window.location.origin,\n                isCheckout: isCheckout\n            };\n            window.parent.postMessage(message, \"*\");\n        }\n        if (e2.type === EventType.FullSnapshot) {\n            lastFullSnapshotEvent = e2;\n            incrementalSnapshotCount = 0;\n        } else if (e2.type === EventType.IncrementalSnapshot) {\n            if (e2.data.source === IncrementalSource.Mutation && e2.data.isAttachIframe) {\n                return;\n            }\n            incrementalSnapshotCount++;\n            var exceedCount = checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;\n            var exceedTime = checkoutEveryNms && e2.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;\n            if (exceedCount || exceedTime) {\n                takeFullSnapshot$1(true);\n            }\n        }\n    };\n    var wrappedMutationEmit = function(m) {\n        wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: _extends({\n                source: IncrementalSource.Mutation\n            }, m)\n        });\n    };\n    var wrappedScrollEmit = function(p) {\n        return wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: _extends({\n                source: IncrementalSource.Scroll\n            }, p)\n        });\n    };\n    var wrappedCanvasMutationEmit = function(p) {\n        return wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: _extends({\n                source: IncrementalSource.CanvasMutation\n            }, p)\n        });\n    };\n    var wrappedAdoptedStyleSheetEmit = function(a2) {\n        return wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: _extends({\n                source: IncrementalSource.AdoptedStyleSheet\n            }, a2)\n        });\n    };\n    var stylesheetManager = new StylesheetManager({\n        mutationCb: wrappedMutationEmit,\n        adoptedStyleSheetCb: wrappedAdoptedStyleSheetEmit\n    });\n    var iframeManager = new IframeManager({\n        mirror: mirror,\n        mutationCb: wrappedMutationEmit,\n        stylesheetManager: stylesheetManager,\n        recordCrossOriginIframes: recordCrossOriginIframes,\n        wrappedEmit: wrappedEmit\n    });\n    for(var _iterator = _create_for_of_iterator_helper_loose(plugins || []), _step; !(_step = _iterator()).done;){\n        var plugin3 = _step.value;\n        if (plugin3.getMirror) plugin3.getMirror({\n            nodeMirror: mirror,\n            crossOriginIframeMirror: iframeManager.crossOriginIframeMirror,\n            crossOriginIframeStyleMirror: iframeManager.crossOriginIframeStyleMirror\n        });\n    }\n    var processedNodeManager = new ProcessedNodeManager();\n    canvasManager = new CanvasManager({\n        recordCanvas: recordCanvas,\n        mutationCb: wrappedCanvasMutationEmit,\n        win: window,\n        blockClass: blockClass,\n        blockSelector: blockSelector,\n        mirror: mirror,\n        sampling: sampling.canvas,\n        dataURLOptions: dataURLOptions\n    });\n    var shadowDomManager = new ShadowDomManager({\n        mutationCb: wrappedMutationEmit,\n        scrollCb: wrappedScrollEmit,\n        bypassOptions: {\n            blockClass: blockClass,\n            blockSelector: blockSelector,\n            maskTextClass: maskTextClass,\n            maskTextSelector: maskTextSelector,\n            inlineStylesheet: inlineStylesheet,\n            maskInputOptions: maskInputOptions,\n            dataURLOptions: dataURLOptions,\n            maskTextFn: maskTextFn,\n            maskInputFn: maskInputFn,\n            recordCanvas: recordCanvas,\n            inlineImages: inlineImages,\n            sampling: sampling,\n            slimDOMOptions: slimDOMOptions,\n            iframeManager: iframeManager,\n            stylesheetManager: stylesheetManager,\n            canvasManager: canvasManager,\n            keepIframeSrcFn: keepIframeSrcFn,\n            processedNodeManager: processedNodeManager\n        },\n        mirror: mirror\n    });\n    takeFullSnapshot$1 = function(isCheckout) {\n        if (isCheckout === void 0) isCheckout = false;\n        if (!recordDOM) {\n            return;\n        }\n        wrappedEmit({\n            type: EventType.Meta,\n            data: {\n                href: window.location.href,\n                width: getWindowWidth(),\n                height: getWindowHeight()\n            }\n        }, isCheckout);\n        stylesheetManager.reset();\n        shadowDomManager.init();\n        mutationBuffers.forEach(function(buf) {\n            return buf.lock();\n        });\n        var node2 = snapshot(document, {\n            mirror: mirror,\n            blockClass: blockClass,\n            blockSelector: blockSelector,\n            maskTextClass: maskTextClass,\n            maskTextSelector: maskTextSelector,\n            inlineStylesheet: inlineStylesheet,\n            maskAllInputs: maskInputOptions,\n            maskTextFn: maskTextFn,\n            maskInputFn: maskInputFn,\n            slimDOM: slimDOMOptions,\n            dataURLOptions: dataURLOptions,\n            recordCanvas: recordCanvas,\n            inlineImages: inlineImages,\n            onSerialize: function(n2) {\n                if (isSerializedIframe(n2, mirror)) {\n                    iframeManager.addIframe(n2);\n                }\n                if (isSerializedStylesheet(n2, mirror)) {\n                    stylesheetManager.trackLinkElement(n2);\n                }\n                if (hasShadowRoot(n2)) {\n                    shadowDomManager.addShadowRoot(index.shadowRoot(n2), document);\n                }\n            },\n            onIframeLoad: function(iframe, childSn) {\n                iframeManager.attachIframe(iframe, childSn);\n                shadowDomManager.observeAttachShadow(iframe);\n            },\n            onStylesheetLoad: function(linkEl, childSn) {\n                stylesheetManager.attachLinkElement(linkEl, childSn);\n            },\n            keepIframeSrcFn: keepIframeSrcFn\n        });\n        if (!node2) {\n            return console.warn(\"Failed to snapshot the document\");\n        }\n        wrappedEmit({\n            type: EventType.FullSnapshot,\n            data: {\n                node: node2,\n                initialOffset: getWindowScroll(window)\n            }\n        }, isCheckout);\n        mutationBuffers.forEach(function(buf) {\n            return buf.unlock();\n        });\n        if (document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0) stylesheetManager.adoptStyleSheets(document.adoptedStyleSheets, mirror.getId(document));\n    };\n    try {\n        var handlers = [];\n        var observe = function(doc) {\n            var _a2;\n            return callbackWrapper(initObservers)({\n                mutationCb: wrappedMutationEmit,\n                mousemoveCb: function(positions, source) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: {\n                            source: source,\n                            positions: positions\n                        }\n                    });\n                },\n                mouseInteractionCb: function(d) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.MouseInteraction\n                        }, d)\n                    });\n                },\n                scrollCb: wrappedScrollEmit,\n                viewportResizeCb: function(d) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.ViewportResize\n                        }, d)\n                    });\n                },\n                inputCb: function(v2) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.Input\n                        }, v2)\n                    });\n                },\n                mediaInteractionCb: function(p) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.MediaInteraction\n                        }, p)\n                    });\n                },\n                styleSheetRuleCb: function(r2) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.StyleSheetRule\n                        }, r2)\n                    });\n                },\n                styleDeclarationCb: function(r2) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.StyleDeclaration\n                        }, r2)\n                    });\n                },\n                canvasMutationCb: wrappedCanvasMutationEmit,\n                fontCb: function(p) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.Font\n                        }, p)\n                    });\n                },\n                selectionCb: function(p) {\n                    wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.Selection\n                        }, p)\n                    });\n                },\n                customElementCb: function(c2) {\n                    wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.CustomElement\n                        }, c2)\n                    });\n                },\n                blockClass: blockClass,\n                ignoreClass: ignoreClass,\n                ignoreSelector: ignoreSelector,\n                maskTextClass: maskTextClass,\n                maskTextSelector: maskTextSelector,\n                maskInputOptions: maskInputOptions,\n                inlineStylesheet: inlineStylesheet,\n                sampling: sampling,\n                recordDOM: recordDOM,\n                recordCanvas: recordCanvas,\n                inlineImages: inlineImages,\n                userTriggeredOnInput: userTriggeredOnInput,\n                collectFonts: collectFonts,\n                doc: doc,\n                maskInputFn: maskInputFn,\n                maskTextFn: maskTextFn,\n                keepIframeSrcFn: keepIframeSrcFn,\n                blockSelector: blockSelector,\n                slimDOMOptions: slimDOMOptions,\n                dataURLOptions: dataURLOptions,\n                mirror: mirror,\n                iframeManager: iframeManager,\n                stylesheetManager: stylesheetManager,\n                shadowDomManager: shadowDomManager,\n                processedNodeManager: processedNodeManager,\n                canvasManager: canvasManager,\n                ignoreCSSAttributes: ignoreCSSAttributes,\n                plugins: ((_a2 = plugins == null ? void 0 : plugins.filter(function(p) {\n                    return p.observer;\n                })) == null ? void 0 : _a2.map(function(p) {\n                    return {\n                        observer: p.observer,\n                        options: p.options,\n                        callback: function(payload) {\n                            return wrappedEmit({\n                                type: EventType.Plugin,\n                                data: {\n                                    plugin: p.name,\n                                    payload: payload\n                                }\n                            });\n                        }\n                    };\n                })) || []\n            }, hooks);\n        };\n        iframeManager.addLoadListener(function(iframeEl) {\n            try {\n                handlers.push(observe(iframeEl.contentDocument));\n            } catch (error) {\n                console.warn(error);\n            }\n        });\n        var init = function() {\n            takeFullSnapshot$1();\n            handlers.push(observe(document));\n            recording = true;\n        };\n        if (document.readyState === \"interactive\" || document.readyState === \"complete\") {\n            init();\n        } else {\n            handlers.push(on(\"DOMContentLoaded\", function() {\n                wrappedEmit({\n                    type: EventType.DomContentLoaded,\n                    data: {}\n                });\n                if (recordAfter === \"DOMContentLoaded\") init();\n            }));\n            handlers.push(on(\"load\", function() {\n                wrappedEmit({\n                    type: EventType.Load,\n                    data: {}\n                });\n                if (recordAfter === \"load\") init();\n            }, window));\n        }\n        return function() {\n            handlers.forEach(function(handler) {\n                try {\n                    handler();\n                } catch (error) {\n                    var msg = String(error).toLowerCase();\n                    if (!msg.includes(\"cross-origin\")) {\n                        console.warn(error);\n                    }\n                }\n            });\n            processedNodeManager.destroy();\n            recording = false;\n            unregisterErrorHandler();\n        };\n    } catch (error) {\n        console.warn(error);\n    }\n}\nrecord.addCustomEvent = function(tag, payload) {\n    if (!recording) {\n        throw new Error(\"please add custom event after start recording\");\n    }\n    wrappedEmit({\n        type: EventType.Custom,\n        data: {\n            tag: tag,\n            payload: payload\n        }\n    });\n};\nrecord.freezePage = function() {\n    mutationBuffers.forEach(function(buf) {\n        return buf.freeze();\n    });\n};\nrecord.takeFullSnapshot = function(isCheckout) {\n    if (!recording) {\n        throw new Error(\"please take full snapshot after start recording\");\n    }\n    takeFullSnapshot$1(isCheckout);\n};\nrecord.mirror = mirror;\nvar n;\n!function(t2) {\n    t2[t2.NotStarted = 0] = \"NotStarted\", t2[t2.Running = 1] = \"Running\", t2[t2.Stopped = 2] = \"Stopped\";\n}(n || (n = {}));\nrecord.addCustomEvent;\nrecord.freezePage;\nrecord.takeFullSnapshot;\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function(obj, key, value) {\n    return key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: value\n    }) : obj[key] = value;\n};\nvar __publicField = function(obj, key, value) {\n    return __defNormalProp(obj, (typeof key === \"undefined\" ? \"undefined\" : _type_of(key)) !== \"symbol\" ? key + \"\" : key, value);\n};\nfunction patch(source, name, replacement) {\n    try {\n        if (!(name in source)) {\n            return function() {};\n        }\n        var original = source[name];\n        var wrapped = replacement(original);\n        if (typeof wrapped === \"function\") {\n            wrapped.prototype = wrapped.prototype || {};\n            Object.defineProperties(wrapped, {\n                __rrweb_original__: {\n                    enumerable: false,\n                    value: original\n                }\n            });\n        }\n        source[name] = wrapped;\n        return function() {\n            source[name] = original;\n        };\n    } catch (e) {\n        return function() {};\n    }\n}\nvar StackFrame = /*#__PURE__*/ function() {\n    function StackFrame(obj) {\n        __publicField(this, \"fileName\");\n        __publicField(this, \"functionName\");\n        __publicField(this, \"lineNumber\");\n        __publicField(this, \"columnNumber\");\n        this.fileName = obj.fileName || \"\";\n        this.functionName = obj.functionName || \"\";\n        this.lineNumber = obj.lineNumber;\n        this.columnNumber = obj.columnNumber;\n    }\n    var _proto = StackFrame.prototype;\n    _proto.toString = function toString() {\n        var lineNumber = this.lineNumber || \"\";\n        var columnNumber = this.columnNumber || \"\";\n        if (this.functionName) return this.functionName + \" (\" + this.fileName + \":\" + lineNumber + \":\" + columnNumber + \")\";\n        return this.fileName + \":\" + lineNumber + \":\" + columnNumber;\n    };\n    return StackFrame;\n}();\nvar FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+:\\d+/;\nvar CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m;\nvar SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code])?$/;\nvar ErrorStackParser = {\n    /**\n   * Given an Error object, extract the most information from it.\n   */ parse: function parse(error) {\n        if (!error) {\n            return [];\n        }\n        if (// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        typeof error.stacktrace !== \"undefined\" || // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        typeof error[\"opera#sourceloc\"] !== \"undefined\") {\n            return this.parseOpera(error);\n        } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n            return this.parseV8OrIE(error);\n        } else if (error.stack) {\n            return this.parseFFOrSafari(error);\n        } else {\n            console.warn(\"[console-record-plugin]: Failed to parse error object:\", error);\n            return [];\n        }\n    },\n    // Separate line and column numbers from a string of the form: (URI:Line:Column)\n    extractLocation: function extractLocation(urlLike) {\n        if (urlLike.indexOf(\":\") === -1) {\n            return [\n                urlLike\n            ];\n        }\n        var regExp = /(.+?)(?::(\\d+))?(?::(\\d+))?$/;\n        var parts = regExp.exec(urlLike.replace(/[()]/g, \"\"));\n        if (!parts) throw new Error(\"Cannot parse given url: \" + urlLike);\n        return [\n            parts[1],\n            parts[2] || void 0,\n            parts[3] || void 0\n        ];\n    },\n    parseV8OrIE: function parseV8OrIE(error) {\n        var filtered = error.stack.split(\"\\n\").filter(function(line) {\n            return !!line.match(CHROME_IE_STACK_REGEXP);\n        }, this);\n        return filtered.map(function(line) {\n            if (line.indexOf(\"(eval \") > -1) {\n                line = line.replace(/eval code/g, \"eval\").replace(/(\\(eval at [^()]*)|(\\),.*$)/g, \"\");\n            }\n            var sanitizedLine = line.replace(/^\\s+/, \"\").replace(/\\(eval code/g, \"(\");\n            var location = sanitizedLine.match(/ (\\((.+):(\\d+):(\\d+)\\)$)/);\n            sanitizedLine = location ? sanitizedLine.replace(location[0], \"\") : sanitizedLine;\n            var tokens = sanitizedLine.split(/\\s+/).slice(1);\n            var locationParts = this.extractLocation(location ? location[1] : tokens.pop());\n            var functionName = tokens.join(\" \") || void 0;\n            var fileName = [\n                \"eval\",\n                \"<anonymous>\"\n            ].indexOf(locationParts[0]) > -1 ? void 0 : locationParts[0];\n            return new StackFrame({\n                functionName: functionName,\n                fileName: fileName,\n                lineNumber: locationParts[1],\n                columnNumber: locationParts[2]\n            });\n        }, this);\n    },\n    parseFFOrSafari: function parseFFOrSafari(error) {\n        var filtered = error.stack.split(\"\\n\").filter(function(line) {\n            return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n        }, this);\n        return filtered.map(function(line) {\n            if (line.indexOf(\" > eval\") > -1) {\n                line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g, \":$1\");\n            }\n            if (line.indexOf(\"@\") === -1 && line.indexOf(\":\") === -1) {\n                return new StackFrame({\n                    functionName: line\n                });\n            } else {\n                var functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(?:@)/;\n                var matches = line.match(functionNameRegex);\n                var functionName = matches && matches[1] ? matches[1] : void 0;\n                var locationParts = this.extractLocation(line.replace(functionNameRegex, \"\"));\n                return new StackFrame({\n                    functionName: functionName,\n                    fileName: locationParts[0],\n                    lineNumber: locationParts[1],\n                    columnNumber: locationParts[2]\n                });\n            }\n        }, this);\n    },\n    parseOpera: function parseOpera(e) {\n        if (!e.stacktrace || e.message.indexOf(\"\\n\") > -1 && e.message.split(\"\\n\").length > e.stacktrace.split(\"\\n\").length) {\n            return this.parseOpera9(e);\n        } else if (!e.stack) {\n            return this.parseOpera10(e);\n        } else {\n            return this.parseOpera11(e);\n        }\n    },\n    parseOpera9: function parseOpera9(e) {\n        var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n        var lines = e.message.split(\"\\n\");\n        var result = [];\n        for(var i = 2, len = lines.length; i < len; i += 2){\n            var match = lineRE.exec(lines[i]);\n            if (match) {\n                result.push(new StackFrame({\n                    fileName: match[2],\n                    lineNumber: parseFloat(match[1])\n                }));\n            }\n        }\n        return result;\n    },\n    parseOpera10: function parseOpera10(e) {\n        var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n        var lines = e.stacktrace.split(\"\\n\");\n        var result = [];\n        for(var i = 0, len = lines.length; i < len; i += 2){\n            var match = lineRE.exec(lines[i]);\n            if (match) {\n                result.push(new StackFrame({\n                    functionName: match[3] || void 0,\n                    fileName: match[2],\n                    lineNumber: parseFloat(match[1])\n                }));\n            }\n        }\n        return result;\n    },\n    // Opera 10.65+ Error.stack very similar to FF/Safari\n    parseOpera11: function parseOpera11(error) {\n        var filtered = error.stack.split(\"\\n\").filter(function(line) {\n            return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n        }, this);\n        return filtered.map(function(line) {\n            var tokens = line.split(\"@\");\n            var locationParts = this.extractLocation(tokens.pop());\n            var functionCall = tokens.shift() || \"\";\n            var functionName = functionCall.replace(/<anonymous function(: (\\w+))?>/, \"$2\").replace(/\\([^)]*\\)/g, \"\") || void 0;\n            return new StackFrame({\n                functionName: functionName,\n                fileName: locationParts[0],\n                lineNumber: locationParts[1],\n                columnNumber: locationParts[2]\n            });\n        }, this);\n    }\n};\nfunction pathToSelector(node) {\n    if (!node || !node.outerHTML) {\n        return \"\";\n    }\n    var path = \"\";\n    while(node.parentElement){\n        var name = node.localName;\n        if (!name) {\n            break;\n        }\n        name = name.toLowerCase();\n        var parent = node.parentElement;\n        var domSiblings = [];\n        if (parent.children && parent.children.length > 0) {\n            for(var i = 0; i < parent.children.length; i++){\n                var sibling = parent.children[i];\n                if (sibling.localName && sibling.localName.toLowerCase) {\n                    if (sibling.localName.toLowerCase() === name) {\n                        domSiblings.push(sibling);\n                    }\n                }\n            }\n        }\n        if (domSiblings.length > 1) {\n            name += \":eq(\" + domSiblings.indexOf(node) + \")\";\n        }\n        path = name + (path ? \">\" + path : \"\");\n        node = parent;\n    }\n    return path;\n}\nfunction isObject(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Object]\";\n}\nfunction isObjTooDeep(obj, limit) {\n    if (limit === 0) {\n        return true;\n    }\n    var keys = Object.keys(obj);\n    for(var _iterator = _create_for_of_iterator_helper_loose(keys), _step; !(_step = _iterator()).done;){\n        var key = _step.value;\n        if (isObject(obj[key]) && isObjTooDeep(obj[key], limit - 1)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction stringify(obj, stringifyOptions) {\n    var options = {\n        numOfKeysLimit: 50,\n        depthOfLimit: 4\n    };\n    Object.assign(options, stringifyOptions);\n    var stack = [];\n    var keys = [];\n    return JSON.stringify(obj, function(key, value) {\n        if (stack.length > 0) {\n            var thisPos = stack.indexOf(this);\n            ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n            ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n            if (~stack.indexOf(value)) {\n                if (stack[0] === value) {\n                    value = \"[Circular ~]\";\n                } else {\n                    value = \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\";\n                }\n            }\n        } else {\n            stack.push(value);\n        }\n        if (value === null) return value;\n        if (value === void 0) return \"undefined\";\n        if (shouldIgnore(value)) {\n            return toString(value);\n        }\n        if ((typeof value === \"undefined\" ? \"undefined\" : _type_of(value)) === \"bigint\") {\n            return value.toString() + \"n\";\n        }\n        if (_instanceof(value, Event)) {\n            var eventResult = {};\n            for(var eventKey in value){\n                var eventValue = value[eventKey];\n                if (Array.isArray(eventValue)) {\n                    eventResult[eventKey] = pathToSelector(eventValue.length ? eventValue[0] : null);\n                } else {\n                    eventResult[eventKey] = eventValue;\n                }\n            }\n            return eventResult;\n        } else if (_instanceof(value, Node)) {\n            if (_instanceof(value, HTMLElement)) {\n                return value ? value.outerHTML : \"\";\n            }\n            return value.nodeName;\n        } else if (_instanceof(value, Error)) {\n            return value.stack ? value.stack + \"\\nEnd of stack for Error object\" : value.name + \": \" + value.message;\n        }\n        return value;\n    });\n    function shouldIgnore(_obj) {\n        if (isObject(_obj) && Object.keys(_obj).length > options.numOfKeysLimit) {\n            return true;\n        }\n        if (typeof _obj === \"function\") {\n            return true;\n        }\n        if (isObject(_obj) && isObjTooDeep(_obj, options.depthOfLimit)) {\n            return true;\n        }\n        return false;\n    }\n    function toString(_obj) {\n        var str = _obj.toString();\n        if (options.stringLengthLimit && str.length > options.stringLengthLimit) {\n            str = \"\" + str.slice(0, options.stringLengthLimit) + \"...\";\n        }\n        return str;\n    }\n}\nvar defaultLogOptions = {\n    level: [\n        \"assert\",\n        \"clear\",\n        \"count\",\n        \"countReset\",\n        \"debug\",\n        \"dir\",\n        \"dirxml\",\n        \"error\",\n        \"group\",\n        \"groupCollapsed\",\n        \"groupEnd\",\n        \"info\",\n        \"log\",\n        \"table\",\n        \"time\",\n        \"timeEnd\",\n        \"timeLog\",\n        \"trace\",\n        \"warn\"\n    ],\n    lengthThreshold: 1e3,\n    logger: \"console\"\n};\nfunction initLogObserver(cb, win, options) {\n    var logOptions = options ? Object.assign({}, defaultLogOptions, options) : defaultLogOptions;\n    var loggerType = logOptions.logger;\n    if (!loggerType) {\n        return function() {};\n    }\n    var logger;\n    if (typeof loggerType === \"string\") {\n        logger = win[loggerType];\n    } else {\n        logger = loggerType;\n    }\n    var logCount = 0;\n    var inStack = false;\n    var cancelHandlers = [];\n    if (logOptions.level.includes(\"error\")) {\n        var errorHandler = function(event) {\n            var message = event.message, error = event.error;\n            var trace = ErrorStackParser.parse(error).map(function(stackFrame) {\n                return stackFrame.toString();\n            });\n            var payload = [\n                stringify(message, logOptions.stringifyOptions)\n            ];\n            cb({\n                level: \"error\",\n                trace: trace,\n                payload: payload\n            });\n        };\n        win.addEventListener(\"error\", errorHandler);\n        cancelHandlers.push(function() {\n            win.removeEventListener(\"error\", errorHandler);\n        });\n        var unhandledrejectionHandler = function(event) {\n            var error;\n            var payload;\n            if (_instanceof(event.reason, Error)) {\n                error = event.reason;\n                payload = [\n                    stringify(\"Uncaught (in promise) \" + error.name + \": \" + error.message, logOptions.stringifyOptions)\n                ];\n            } else {\n                error = new Error();\n                payload = [\n                    stringify(\"Uncaught (in promise)\", logOptions.stringifyOptions),\n                    stringify(event.reason, logOptions.stringifyOptions)\n                ];\n            }\n            var trace = ErrorStackParser.parse(error).map(function(stackFrame) {\n                return stackFrame.toString();\n            });\n            cb({\n                level: \"error\",\n                trace: trace,\n                payload: payload\n            });\n        };\n        win.addEventListener(\"unhandledrejection\", unhandledrejectionHandler);\n        cancelHandlers.push(function() {\n            win.removeEventListener(\"unhandledrejection\", unhandledrejectionHandler);\n        });\n    }\n    for(var _iterator = _create_for_of_iterator_helper_loose(logOptions.level), _step; !(_step = _iterator()).done;){\n        var levelType = _step.value;\n        cancelHandlers.push(replace(logger, levelType));\n    }\n    return function() {\n        cancelHandlers.forEach(function(h) {\n            return h();\n        });\n    };\n    function replace(_logger, level) {\n        var _this = this;\n        if (!_logger[level]) {\n            return function() {};\n        }\n        return patch(_logger, level, function(original) {\n            var _this1 = _this;\n            return function() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                original.apply(_this1, args);\n                if (level === \"assert\" && !!args[0]) {\n                    return;\n                }\n                if (inStack) {\n                    return;\n                }\n                inStack = true;\n                try {\n                    var trace = ErrorStackParser.parse(new Error()).map(function(stackFrame) {\n                        return stackFrame.toString();\n                    }).splice(1);\n                    var argsForPayload = level === \"assert\" ? args.slice(1) : args;\n                    var payload = argsForPayload.map(function(s) {\n                        return stringify(s, logOptions.stringifyOptions);\n                    });\n                    logCount++;\n                    if (logCount < logOptions.lengthThreshold) {\n                        cb({\n                            level: level,\n                            trace: trace,\n                            payload: payload\n                        });\n                    } else if (logCount === logOptions.lengthThreshold) {\n                        cb({\n                            level: \"warn\",\n                            trace: [],\n                            payload: [\n                                stringify(\"The number of log records reached the threshold.\")\n                            ]\n                        });\n                    }\n                } catch (error) {\n                    original.apply(void 0, [].concat([\n                        \"rrweb logger error:\",\n                        error\n                    ], args));\n                } finally{\n                    inStack = false;\n                }\n            };\n        });\n    }\n}\nvar PLUGIN_NAME = \"rrweb/console@1\";\nvar getRecordConsolePlugin = function(options) {\n    return {\n        name: PLUGIN_NAME,\n        observer: initLogObserver,\n        options: options\n    };\n};\n\nvar setImmediate = win['setImmediate'];\nvar builtInProp, cycle, schedulingQueue,\n    ToString = Object.prototype.toString,\n    timer = (typeof setImmediate !== 'undefined') ?\n        function timer(fn) { return setImmediate(fn); } :\n        setTimeout;\n\n// dammit, IE8.\ntry {\n    Object.defineProperty({},'x',{});\n    builtInProp = function builtInProp(obj,name,val,config) {\n        return Object.defineProperty(obj,name,{\n            value: val,\n            writable: true,\n            configurable: config !== false\n        });\n    };\n}\ncatch (err) {\n    builtInProp = function builtInProp(obj,name,val) {\n        obj[name] = val;\n        return obj;\n    };\n}\n\n// Note: using a queue instead of array for efficiency\nschedulingQueue = (function Queue() {\n    var first, last, item;\n\n    function Item(fn,self) {\n        this.fn = fn;\n        this.self = self;\n        this.next = void 0;\n    }\n\n    return {\n        add: function add(fn,self) {\n            item = new Item(fn,self);\n            if (last) {\n                last.next = item;\n            }\n            else {\n                first = item;\n            }\n            last = item;\n            item = void 0;\n        },\n        drain: function drain() {\n            var f = first;\n            first = last = cycle = void 0;\n\n            while (f) {\n                f.fn.call(f.self);\n                f = f.next;\n            }\n        }\n    };\n})();\n\nfunction schedule(fn,self) {\n    schedulingQueue.add(fn,self);\n    if (!cycle) {\n        cycle = timer(schedulingQueue.drain);\n    }\n}\n\n// promise duck typing\nfunction isThenable(o) {\n    var _then, oType = typeof o;\n\n    if (o !== null && (oType === 'object' || oType === 'function')) {\n        _then = o.then;\n    }\n    return typeof _then === 'function' ? _then : false;\n}\n\nfunction notify() {\n    for (var i=0; i<this.chain.length; i++) {\n        notifyIsolated(\n            this,\n            (this.state === 1) ? this.chain[i].success : this.chain[i].failure,\n            this.chain[i]\n        );\n    }\n    this.chain.length = 0;\n}\n\n// NOTE: This is a separate function to isolate\n// the `try..catch` so that other code can be\n// optimized better\nfunction notifyIsolated(self,cb,chain) {\n    var ret, _then;\n    try {\n        if (cb === false) {\n            chain.reject(self.msg);\n        }\n        else {\n            if (cb === true) {\n                ret = self.msg;\n            }\n            else {\n                ret = cb.call(void 0,self.msg);\n            }\n\n            if (ret === chain.promise) {\n                chain.reject(TypeError('Promise-chain cycle'));\n            }\n            // eslint-disable-next-line no-cond-assign\n            else if (_then = isThenable(ret)) {\n                _then.call(ret,chain.resolve,chain.reject);\n            }\n            else {\n                chain.resolve(ret);\n            }\n        }\n    }\n    catch (err) {\n        chain.reject(err);\n    }\n}\n\nfunction resolve(msg) {\n    var _then, self = this;\n\n    // already triggered?\n    if (self.triggered) { return; }\n\n    self.triggered = true;\n\n    // unwrap\n    if (self.def) {\n        self = self.def;\n    }\n\n    try {\n        // eslint-disable-next-line no-cond-assign\n        if (_then = isThenable(msg)) {\n            schedule(function(){\n                var defWrapper = new MakeDefWrapper(self);\n                try {\n                    _then.call(msg,\n                        function $resolve$(){ resolve.apply(defWrapper,arguments); },\n                        function $reject$(){ reject.apply(defWrapper,arguments); }\n                    );\n                }\n                catch (err) {\n                    reject.call(defWrapper,err);\n                }\n            });\n        }\n        else {\n            self.msg = msg;\n            self.state = 1;\n            if (self.chain.length > 0) {\n                schedule(notify,self);\n            }\n        }\n    }\n    catch (err) {\n        reject.call(new MakeDefWrapper(self),err);\n    }\n}\n\nfunction reject(msg) {\n    var self = this;\n\n    // already triggered?\n    if (self.triggered) { return; }\n\n    self.triggered = true;\n\n    // unwrap\n    if (self.def) {\n        self = self.def;\n    }\n\n    self.msg = msg;\n    self.state = 2;\n    if (self.chain.length > 0) {\n        schedule(notify,self);\n    }\n}\n\nfunction iteratePromises(Constructor,arr,resolver,rejecter) {\n    for (var idx=0; idx<arr.length; idx++) {\n        (function IIFE(idx){\n            Constructor.resolve(arr[idx])\n                .then(\n                    function $resolver$(msg){\n                        resolver(idx,msg);\n                    },\n                    rejecter\n                );\n        })(idx);\n    }\n}\n\nfunction MakeDefWrapper(self) {\n    this.def = self;\n    this.triggered = false;\n}\n\nfunction MakeDef(self) {\n    this.promise = self;\n    this.state = 0;\n    this.triggered = false;\n    this.chain = [];\n    this.msg = void 0;\n}\n\nfunction NpoPromise(executor) {\n    if (typeof executor !== 'function') {\n        throw TypeError('Not a function');\n    }\n\n    if (this['__NPO__'] !== 0) {\n        throw TypeError('Not a promise');\n    }\n\n    // instance shadowing the inherited \"brand\"\n    // to signal an already \"initialized\" promise\n    this['__NPO__'] = 1;\n\n    var def = new MakeDef(this);\n\n    this['then'] = function then(success,failure) {\n        var o = {\n            success: typeof success === 'function' ? success : true,\n            failure: typeof failure === 'function' ? failure : false\n        };\n            // Note: `then(..)` itself can be borrowed to be used against\n            // a different promise constructor for making the chained promise,\n            // by substituting a different `this` binding.\n        o.promise = new this.constructor(function extractChain(resolve,reject) {\n            if (typeof resolve !== 'function' || typeof reject !== 'function') {\n                throw TypeError('Not a function');\n            }\n\n            o.resolve = resolve;\n            o.reject = reject;\n        });\n        def.chain.push(o);\n\n        if (def.state !== 0) {\n            schedule(notify,def);\n        }\n\n        return o.promise;\n    };\n    this['catch'] = function $catch$(failure) {\n        return this.then(void 0,failure);\n    };\n\n    try {\n        executor.call(\n            void 0,\n            function publicResolve(msg){\n                resolve.call(def,msg);\n            },\n            function publicReject(msg) {\n                reject.call(def,msg);\n            }\n        );\n    }\n    catch (err) {\n        reject.call(def,err);\n    }\n}\n\nvar PromisePrototype = builtInProp({},'constructor',NpoPromise,\n    /*configurable=*/false\n);\n\n    // Note: Android 4 cannot use `Object.defineProperty(..)` here\nNpoPromise.prototype = PromisePrototype;\n\n// built-in \"brand\" to signal an \"uninitialized\" promise\nbuiltInProp(PromisePrototype,'__NPO__',0,\n    /*configurable=*/false\n);\n\nbuiltInProp(NpoPromise,'resolve',function Promise$resolve(msg) {\n    var Constructor = this;\n\n    // spec mandated checks\n    // note: best \"isPromise\" check that's practical for now\n    if (msg && typeof msg === 'object' && msg['__NPO__'] === 1) {\n        return msg;\n    }\n\n    return new Constructor(function executor(resolve,reject){\n        if (typeof resolve !== 'function' || typeof reject !== 'function') {\n            throw TypeError('Not a function');\n        }\n\n        resolve(msg);\n    });\n});\n\nbuiltInProp(NpoPromise,'reject',function Promise$reject(msg) {\n    return new this(function executor(resolve,reject){\n        if (typeof resolve !== 'function' || typeof reject !== 'function') {\n            throw TypeError('Not a function');\n        }\n\n        reject(msg);\n    });\n});\n\nbuiltInProp(NpoPromise,'all',function Promise$all(arr) {\n    var Constructor = this;\n\n    // spec mandated checks\n    if (ToString.call(arr) !== '[object Array]') {\n        return Constructor.reject(TypeError('Not an array'));\n    }\n    if (arr.length === 0) {\n        return Constructor.resolve([]);\n    }\n\n    return new Constructor(function executor(resolve,reject){\n        if (typeof resolve !== 'function' || typeof reject !== 'function') {\n            throw TypeError('Not a function');\n        }\n\n        var len = arr.length, msgs = Array(len), count = 0;\n\n        iteratePromises(Constructor,arr,function resolver(idx,msg) {\n            msgs[idx] = msg;\n            if (++count === len) {\n                resolve(msgs);\n            }\n        },reject);\n    });\n});\n\nbuiltInProp(NpoPromise,'race',function Promise$race(arr) {\n    var Constructor = this;\n\n    // spec mandated checks\n    if (ToString.call(arr) !== '[object Array]') {\n        return Constructor.reject(TypeError('Not an array'));\n    }\n\n    return new Constructor(function executor(resolve,reject){\n        if (typeof resolve !== 'function' || typeof reject !== 'function') {\n            throw TypeError('Not a function');\n        }\n\n        iteratePromises(Constructor,arr,function resolver(idx,msg){\n            resolve(msg);\n        },reject);\n    });\n});\n\nvar PromisePolyfill;\nif (typeof Promise !== 'undefined' && Promise.toString().indexOf('[native code]') !== -1) {\n    PromisePolyfill = Promise;\n} else {\n    PromisePolyfill = NpoPromise;\n}\n\nvar Config = {\n    DEBUG: false,\n    LIB_VERSION: '2.72.0'\n};\n\n/* eslint camelcase: \"off\", eqeqeq: \"off\" */\n\n// Maximum allowed session recording length\nvar MAX_RECORDING_MS = 24 * 60 * 60 * 1000; // 24 hours\n// Maximum allowed value for minimum session recording length\nvar MAX_VALUE_FOR_MIN_RECORDING_MS = 8 * 1000; // 8 seconds\n\n/*\n * Saved references to long variable names, so that closure compiler can\n * minimize file size.\n */\n\nvar ArrayProto = Array.prototype,\n    FuncProto = Function.prototype,\n    ObjProto = Object.prototype,\n    slice = ArrayProto.slice,\n    toString = ObjProto.toString,\n    hasOwnProperty = ObjProto.hasOwnProperty,\n    windowConsole = win.console,\n    navigator = win.navigator,\n    document$1 = win.document,\n    windowOpera = win.opera,\n    screen = win.screen,\n    userAgent = navigator.userAgent;\n\nvar nativeBind = FuncProto.bind,\n    nativeForEach = ArrayProto.forEach,\n    nativeIndexOf = ArrayProto.indexOf,\n    nativeMap = ArrayProto.map,\n    nativeIsArray = Array.isArray,\n    breaker = {};\n\nvar _ = {\n    trim: function(str) {\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill\n        return str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n    }\n};\n\n// Console override\nvar console$1 = {\n    /** @type {function(...*)} */\n    log: function() {\n        if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {\n            try {\n                windowConsole.log.apply(windowConsole, arguments);\n            } catch (err) {\n                _.each(arguments, function(arg) {\n                    windowConsole.log(arg);\n                });\n            }\n        }\n    },\n    /** @type {function(...*)} */\n    warn: function() {\n        if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {\n            var args = ['Mixpanel warning:'].concat(_.toArray(arguments));\n            try {\n                windowConsole.warn.apply(windowConsole, args);\n            } catch (err) {\n                _.each(args, function(arg) {\n                    windowConsole.warn(arg);\n                });\n            }\n        }\n    },\n    /** @type {function(...*)} */\n    error: function() {\n        if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {\n            var args = ['Mixpanel error:'].concat(_.toArray(arguments));\n            try {\n                windowConsole.error.apply(windowConsole, args);\n            } catch (err) {\n                _.each(args, function(arg) {\n                    windowConsole.error(arg);\n                });\n            }\n        }\n    },\n    /** @type {function(...*)} */\n    critical: function() {\n        if (!_.isUndefined(windowConsole) && windowConsole) {\n            var args = ['Mixpanel error:'].concat(_.toArray(arguments));\n            try {\n                windowConsole.error.apply(windowConsole, args);\n            } catch (err) {\n                _.each(args, function(arg) {\n                    windowConsole.error(arg);\n                });\n            }\n        }\n    }\n};\n\nvar log_func_with_prefix = function(func, prefix) {\n    return function() {\n        arguments[0] = '[' + prefix + '] ' + arguments[0];\n        return func.apply(console$1, arguments);\n    };\n};\nvar console_with_prefix = function(prefix) {\n    return {\n        log: log_func_with_prefix(console$1.log, prefix),\n        error: log_func_with_prefix(console$1.error, prefix),\n        critical: log_func_with_prefix(console$1.critical, prefix)\n    };\n};\n\n\nvar safewrap = function(f) {\n    return function() {\n        try {\n            return f.apply(this, arguments);\n        } catch (e) {\n            console$1.critical('Implementation error. Please turn on debug and contact support@mixpanel.com.');\n            if (Config.DEBUG){\n                console$1.critical(e);\n            }\n        }\n    };\n};\n\nvar safewrapClass = function(klass) {\n    var proto = klass.prototype;\n    for (var func in proto) {\n        if (typeof(proto[func]) === 'function') {\n            proto[func] = safewrap(proto[func]);\n        }\n    }\n};\n\n\n// UNDERSCORE\n// Embed part of the Underscore Library\n_.bind = function(func, context) {\n    var args, bound;\n    if (nativeBind && func.bind === nativeBind) {\n        return nativeBind.apply(func, slice.call(arguments, 1));\n    }\n    if (!_.isFunction(func)) {\n        throw new TypeError();\n    }\n    args = slice.call(arguments, 2);\n    bound = function() {\n        if (!(this instanceof bound)) {\n            return func.apply(context, args.concat(slice.call(arguments)));\n        }\n        var ctor = {};\n        ctor.prototype = func.prototype;\n        var self = new ctor();\n        ctor.prototype = null;\n        var result = func.apply(self, args.concat(slice.call(arguments)));\n        if (Object(result) === result) {\n            return result;\n        }\n        return self;\n    };\n    return bound;\n};\n\n/**\n * @param {*=} obj\n * @param {function(...*)=} iterator\n * @param {Object=} context\n */\n_.each = function(obj, iterator, context) {\n    if (obj === null || obj === undefined) {\n        return;\n    }\n    if (nativeForEach && obj.forEach === nativeForEach) {\n        obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n        for (var i = 0, l = obj.length; i < l; i++) {\n            if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) {\n                return;\n            }\n        }\n    } else {\n        for (var key in obj) {\n            if (hasOwnProperty.call(obj, key)) {\n                if (iterator.call(context, obj[key], key, obj) === breaker) {\n                    return;\n                }\n            }\n        }\n    }\n};\n\n_.extend = function(obj) {\n    _.each(slice.call(arguments, 1), function(source) {\n        for (var prop in source) {\n            if (source[prop] !== void 0) {\n                obj[prop] = source[prop];\n            }\n        }\n    });\n    return obj;\n};\n\n_.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === '[object Array]';\n};\n\n// from a comment on http://dbj.org/dbj/?p=286\n// fails on only one very rare and deliberate custom object:\n// var bomb = { toString : undefined, valueOf: function(o) { return \"function BOMBA!\"; }};\n_.isFunction = function(f) {\n    try {\n        return /^\\s*\\bfunction\\b/.test(f);\n    } catch (x) {\n        return false;\n    }\n};\n\n_.isArguments = function(obj) {\n    return !!(obj && hasOwnProperty.call(obj, 'callee'));\n};\n\n_.toArray = function(iterable) {\n    if (!iterable) {\n        return [];\n    }\n    if (iterable.toArray) {\n        return iterable.toArray();\n    }\n    if (_.isArray(iterable)) {\n        return slice.call(iterable);\n    }\n    if (_.isArguments(iterable)) {\n        return slice.call(iterable);\n    }\n    return _.values(iterable);\n};\n\n_.map = function(arr, callback, context) {\n    if (nativeMap && arr.map === nativeMap) {\n        return arr.map(callback, context);\n    } else {\n        var results = [];\n        _.each(arr, function(item) {\n            results.push(callback.call(context, item));\n        });\n        return results;\n    }\n};\n\n_.keys = function(obj) {\n    var results = [];\n    if (obj === null) {\n        return results;\n    }\n    _.each(obj, function(value, key) {\n        results[results.length] = key;\n    });\n    return results;\n};\n\n_.values = function(obj) {\n    var results = [];\n    if (obj === null) {\n        return results;\n    }\n    _.each(obj, function(value) {\n        results[results.length] = value;\n    });\n    return results;\n};\n\n_.include = function(obj, target) {\n    var found = false;\n    if (obj === null) {\n        return found;\n    }\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) {\n        return obj.indexOf(target) != -1;\n    }\n    _.each(obj, function(value) {\n        if (found || (found = (value === target))) {\n            return breaker;\n        }\n    });\n    return found;\n};\n\n_.includes = function(str, needle) {\n    return str.indexOf(needle) !== -1;\n};\n\n// Underscore Addons\n_.inherit = function(subclass, superclass) {\n    subclass.prototype = new superclass();\n    subclass.prototype.constructor = subclass;\n    subclass.superclass = superclass.prototype;\n    return subclass;\n};\n\n_.isObject = function(obj) {\n    return (obj === Object(obj) && !_.isArray(obj));\n};\n\n_.isEmptyObject = function(obj) {\n    if (_.isObject(obj)) {\n        for (var key in obj) {\n            if (hasOwnProperty.call(obj, key)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n};\n\n_.isUndefined = function(obj) {\n    return obj === void 0;\n};\n\n_.isString = function(obj) {\n    return toString.call(obj) == '[object String]';\n};\n\n_.isDate = function(obj) {\n    return toString.call(obj) == '[object Date]';\n};\n\n_.isNumber = function(obj) {\n    return toString.call(obj) == '[object Number]';\n};\n\n_.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n};\n\n_.encodeDates = function(obj) {\n    _.each(obj, function(v, k) {\n        if (_.isDate(v)) {\n            obj[k] = _.formatDate(v);\n        } else if (_.isObject(v)) {\n            obj[k] = _.encodeDates(v); // recurse\n        }\n    });\n    return obj;\n};\n\n_.timestamp = function() {\n    Date.now = Date.now || function() {\n        return +new Date;\n    };\n    return Date.now();\n};\n\n_.formatDate = function(d) {\n    // YYYY-MM-DDTHH:MM:SS in UTC\n    function pad(n) {\n        return n < 10 ? '0' + n : n;\n    }\n    return d.getUTCFullYear() + '-' +\n        pad(d.getUTCMonth() + 1) + '-' +\n        pad(d.getUTCDate()) + 'T' +\n        pad(d.getUTCHours()) + ':' +\n        pad(d.getUTCMinutes()) + ':' +\n        pad(d.getUTCSeconds());\n};\n\n_.strip_empty_properties = function(p) {\n    var ret = {};\n    _.each(p, function(v, k) {\n        if (_.isString(v) && v.length > 0) {\n            ret[k] = v;\n        }\n    });\n    return ret;\n};\n\n/*\n * this function returns a copy of object after truncating it.  If\n * passed an Array or Object it will iterate through obj and\n * truncate all the values recursively.\n */\n_.truncate = function(obj, length) {\n    var ret;\n\n    if (typeof(obj) === 'string') {\n        ret = obj.slice(0, length);\n    } else if (_.isArray(obj)) {\n        ret = [];\n        _.each(obj, function(val) {\n            ret.push(_.truncate(val, length));\n        });\n    } else if (_.isObject(obj)) {\n        ret = {};\n        _.each(obj, function(val, key) {\n            ret[key] = _.truncate(val, length);\n        });\n    } else {\n        ret = obj;\n    }\n\n    return ret;\n};\n\n_.JSONEncode = (function() {\n    return function(mixed_val) {\n        var value = mixed_val;\n        var quote = function(string) {\n            var escapable = /[\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g; // eslint-disable-line no-control-regex\n            var meta = { // table of character substitutions\n                '\\b': '\\\\b',\n                '\\t': '\\\\t',\n                '\\n': '\\\\n',\n                '\\f': '\\\\f',\n                '\\r': '\\\\r',\n                '\"': '\\\\\"',\n                '\\\\': '\\\\\\\\'\n            };\n\n            escapable.lastIndex = 0;\n            return escapable.test(string) ?\n                '\"' + string.replace(escapable, function(a) {\n                    var c = meta[a];\n                    return typeof c === 'string' ? c :\n                        '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n                }) + '\"' :\n                '\"' + string + '\"';\n        };\n\n        var str = function(key, holder) {\n            var gap = '';\n            var indent = '    ';\n            var i = 0; // The loop counter.\n            var k = ''; // The member key.\n            var v = ''; // The member value.\n            var length = 0;\n            var mind = gap;\n            var partial = [];\n            var value = holder[key];\n\n            // If the value has a toJSON method, call it to obtain a replacement value.\n            if (value && typeof value === 'object' &&\n                typeof value.toJSON === 'function') {\n                value = value.toJSON(key);\n            }\n\n            // What happens next depends on the value's type.\n            switch (typeof value) {\n                case 'string':\n                    return quote(value);\n\n                case 'number':\n                    // JSON numbers must be finite. Encode non-finite numbers as null.\n                    return isFinite(value) ? String(value) : 'null';\n\n                case 'boolean':\n                case 'null':\n                    // If the value is a boolean or null, convert it to a string. Note:\n                    // typeof null does not produce 'null'. The case is included here in\n                    // the remote chance that this gets fixed someday.\n\n                    return String(value);\n\n                case 'object':\n                    // If the type is 'object', we might be dealing with an object or an array or\n                    // null.\n                    // Due to a specification blunder in ECMAScript, typeof null is 'object',\n                    // so watch out for that case.\n                    if (!value) {\n                        return 'null';\n                    }\n\n                    // Make an array to hold the partial results of stringifying this object value.\n                    gap += indent;\n                    partial = [];\n\n                    // Is the value an array?\n                    if (toString.apply(value) === '[object Array]') {\n                        // The value is an array. Stringify every element. Use null as a placeholder\n                        // for non-JSON values.\n\n                        length = value.length;\n                        for (i = 0; i < length; i += 1) {\n                            partial[i] = str(i, value) || 'null';\n                        }\n\n                        // Join all of the elements together, separated with commas, and wrap them in\n                        // brackets.\n                        v = partial.length === 0 ? '[]' :\n                            gap ? '[\\n' + gap +\n                            partial.join(',\\n' + gap) + '\\n' +\n                            mind + ']' :\n                                '[' + partial.join(',') + ']';\n                        gap = mind;\n                        return v;\n                    }\n\n                    // Iterate through all of the keys in the object.\n                    for (k in value) {\n                        if (hasOwnProperty.call(value, k)) {\n                            v = str(k, value);\n                            if (v) {\n                                partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                            }\n                        }\n                    }\n\n                    // Join all of the member texts together, separated with commas,\n                    // and wrap them in braces.\n                    v = partial.length === 0 ? '{}' :\n                        gap ? '{' + partial.join(',') + '' +\n                        mind + '}' : '{' + partial.join(',') + '}';\n                    gap = mind;\n                    return v;\n            }\n        };\n\n        // Make a fake root object containing our value under the key of ''.\n        // Return the result of stringifying the value.\n        return str('', {\n            '': value\n        });\n    };\n})();\n\n/**\n * From https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js\n * Slightly modified to throw a real Error rather than a POJO\n */\n_.JSONDecode = (function() {\n    var at, // The index of the current character\n        ch, // The current character\n        escapee = {\n            '\"': '\"',\n            '\\\\': '\\\\',\n            '/': '/',\n            'b': '\\b',\n            'f': '\\f',\n            'n': '\\n',\n            'r': '\\r',\n            't': '\\t'\n        },\n        text,\n        error = function(m) {\n            var e = new SyntaxError(m);\n            e.at = at;\n            e.text = text;\n            throw e;\n        },\n        next = function(c) {\n            // If a c parameter is provided, verify that it matches the current character.\n            if (c && c !== ch) {\n                error('Expected \\'' + c + '\\' instead of \\'' + ch + '\\'');\n            }\n            // Get the next character. When there are no more characters,\n            // return the empty string.\n            ch = text.charAt(at);\n            at += 1;\n            return ch;\n        },\n        number = function() {\n            // Parse a number value.\n            var number,\n                string = '';\n\n            if (ch === '-') {\n                string = '-';\n                next('-');\n            }\n            while (ch >= '0' && ch <= '9') {\n                string += ch;\n                next();\n            }\n            if (ch === '.') {\n                string += '.';\n                while (next() && ch >= '0' && ch <= '9') {\n                    string += ch;\n                }\n            }\n            if (ch === 'e' || ch === 'E') {\n                string += ch;\n                next();\n                if (ch === '-' || ch === '+') {\n                    string += ch;\n                    next();\n                }\n                while (ch >= '0' && ch <= '9') {\n                    string += ch;\n                    next();\n                }\n            }\n            number = +string;\n            if (!isFinite(number)) {\n                error('Bad number');\n            } else {\n                return number;\n            }\n        },\n\n        string = function() {\n            // Parse a string value.\n            var hex,\n                i,\n                string = '',\n                uffff;\n            // When parsing for string values, we must look for \" and \\ characters.\n            if (ch === '\"') {\n                while (next()) {\n                    if (ch === '\"') {\n                        next();\n                        return string;\n                    }\n                    if (ch === '\\\\') {\n                        next();\n                        if (ch === 'u') {\n                            uffff = 0;\n                            for (i = 0; i < 4; i += 1) {\n                                hex = parseInt(next(), 16);\n                                if (!isFinite(hex)) {\n                                    break;\n                                }\n                                uffff = uffff * 16 + hex;\n                            }\n                            string += String.fromCharCode(uffff);\n                        } else if (typeof escapee[ch] === 'string') {\n                            string += escapee[ch];\n                        } else {\n                            break;\n                        }\n                    } else {\n                        string += ch;\n                    }\n                }\n            }\n            error('Bad string');\n        },\n        white = function() {\n            // Skip whitespace.\n            while (ch && ch <= ' ') {\n                next();\n            }\n        },\n        word = function() {\n            // true, false, or null.\n            switch (ch) {\n                case 't':\n                    next('t');\n                    next('r');\n                    next('u');\n                    next('e');\n                    return true;\n                case 'f':\n                    next('f');\n                    next('a');\n                    next('l');\n                    next('s');\n                    next('e');\n                    return false;\n                case 'n':\n                    next('n');\n                    next('u');\n                    next('l');\n                    next('l');\n                    return null;\n            }\n            error('Unexpected \"' + ch + '\"');\n        },\n        value, // Placeholder for the value function.\n        array = function() {\n            // Parse an array value.\n            var array = [];\n\n            if (ch === '[') {\n                next('[');\n                white();\n                if (ch === ']') {\n                    next(']');\n                    return array; // empty array\n                }\n                while (ch) {\n                    array.push(value());\n                    white();\n                    if (ch === ']') {\n                        next(']');\n                        return array;\n                    }\n                    next(',');\n                    white();\n                }\n            }\n            error('Bad array');\n        },\n        object = function() {\n            // Parse an object value.\n            var key,\n                object = {};\n\n            if (ch === '{') {\n                next('{');\n                white();\n                if (ch === '}') {\n                    next('}');\n                    return object; // empty object\n                }\n                while (ch) {\n                    key = string();\n                    white();\n                    next(':');\n                    if (Object.hasOwnProperty.call(object, key)) {\n                        error('Duplicate key \"' + key + '\"');\n                    }\n                    object[key] = value();\n                    white();\n                    if (ch === '}') {\n                        next('}');\n                        return object;\n                    }\n                    next(',');\n                    white();\n                }\n            }\n            error('Bad object');\n        };\n\n    value = function() {\n        // Parse a JSON value. It could be an object, an array, a string,\n        // a number, or a word.\n        white();\n        switch (ch) {\n            case '{':\n                return object();\n            case '[':\n                return array();\n            case '\"':\n                return string();\n            case '-':\n                return number();\n            default:\n                return ch >= '0' && ch <= '9' ? number() : word();\n        }\n    };\n\n    // Return the json_parse function. It will have access to all of the\n    // above functions and variables.\n    return function(source) {\n        var result;\n\n        text = source;\n        at = 0;\n        ch = ' ';\n        result = value();\n        white();\n        if (ch) {\n            error('Syntax error');\n        }\n\n        return result;\n    };\n})();\n\n_.base64Encode = function(data) {\n    var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,\n        ac = 0,\n        enc = '',\n        tmp_arr = [];\n\n    if (!data) {\n        return data;\n    }\n\n    data = _.utf8Encode(data);\n\n    do { // pack three octets into four hexets\n        o1 = data.charCodeAt(i++);\n        o2 = data.charCodeAt(i++);\n        o3 = data.charCodeAt(i++);\n\n        bits = o1 << 16 | o2 << 8 | o3;\n\n        h1 = bits >> 18 & 0x3f;\n        h2 = bits >> 12 & 0x3f;\n        h3 = bits >> 6 & 0x3f;\n        h4 = bits & 0x3f;\n\n        // use hexets to index into b64, and append result to encoded string\n        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n    } while (i < data.length);\n\n    enc = tmp_arr.join('');\n\n    switch (data.length % 3) {\n        case 1:\n            enc = enc.slice(0, -2) + '==';\n            break;\n        case 2:\n            enc = enc.slice(0, -1) + '=';\n            break;\n    }\n\n    return enc;\n};\n\n_.utf8Encode = function(string) {\n    string = (string + '').replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n\n    var utftext = '',\n        start,\n        end;\n    var stringl = 0,\n        n;\n\n    start = end = 0;\n    stringl = string.length;\n\n    for (n = 0; n < stringl; n++) {\n        var c1 = string.charCodeAt(n);\n        var enc = null;\n\n        if (c1 < 128) {\n            end++;\n        } else if ((c1 > 127) && (c1 < 2048)) {\n            enc = String.fromCharCode((c1 >> 6) | 192, (c1 & 63) | 128);\n        } else {\n            enc = String.fromCharCode((c1 >> 12) | 224, ((c1 >> 6) & 63) | 128, (c1 & 63) | 128);\n        }\n        if (enc !== null) {\n            if (end > start) {\n                utftext += string.substring(start, end);\n            }\n            utftext += enc;\n            start = end = n + 1;\n        }\n    }\n\n    if (end > start) {\n        utftext += string.substring(start, string.length);\n    }\n\n    return utftext;\n};\n\n_.UUID = function() {\n    try {\n        // use native Crypto API when available\n        return win['crypto']['randomUUID']();\n    } catch (err) {\n        // fall back to generating our own UUID\n        // based on https://gist.github.com/scwood/3bff42cc005cc20ab7ec98f0d8e1d59d\n        var uuid = new Array(36);\n        for (var i = 0; i < 36; i++) {\n            uuid[i] = Math.floor(Math.random() * 16);\n        }\n        uuid[14] = 4; // set bits 12-15 of time-high-and-version to 0100\n        uuid[19] = uuid[19] &= -5; // set bit 6 of clock-seq-and-reserved to zero\n        uuid[19] = uuid[19] |= (1 << 3); // set bit 7 of clock-seq-and-reserved to one\n        uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';\n\n        return _.map(uuid, function(x) {\n            return x.toString(16);\n        }).join('');\n    }\n};\n\n// _.isBlockedUA()\n// This is to block various web spiders from executing our JS and\n// sending false tracking data\nvar BLOCKED_UA_STRS = [\n    'ahrefsbot',\n    'ahrefssiteaudit',\n    'amazonbot',\n    'baiduspider',\n    'bingbot',\n    'bingpreview',\n    'chrome-lighthouse',\n    'facebookexternal',\n    'petalbot',\n    'pinterest',\n    'screaming frog',\n    'yahoo! slurp',\n    'yandex',\n\n    // a whole bunch of goog-specific crawlers\n    // https://developers.google.com/search/docs/advanced/crawling/overview-google-crawlers\n    'adsbot-google',\n    'apis-google',\n    'duplexweb-google',\n    'feedfetcher-google',\n    'google favicon',\n    'google web preview',\n    'google-read-aloud',\n    'googlebot',\n    'googleweblight',\n    'mediapartners-google',\n    'storebot-google'\n];\n_.isBlockedUA = function(ua) {\n    var i;\n    ua = ua.toLowerCase();\n    for (i = 0; i < BLOCKED_UA_STRS.length; i++) {\n        if (ua.indexOf(BLOCKED_UA_STRS[i]) !== -1) {\n            return true;\n        }\n    }\n    return false;\n};\n\n/**\n * @param {Object=} formdata\n * @param {string=} arg_separator\n */\n_.HTTPBuildQuery = function(formdata, arg_separator) {\n    var use_val, use_key, tmp_arr = [];\n\n    if (_.isUndefined(arg_separator)) {\n        arg_separator = '&';\n    }\n\n    _.each(formdata, function(val, key) {\n        use_val = encodeURIComponent(val.toString());\n        use_key = encodeURIComponent(key);\n        tmp_arr[tmp_arr.length] = use_key + '=' + use_val;\n    });\n\n    return tmp_arr.join(arg_separator);\n};\n\n_.getQueryParam = function(url, param) {\n    // Expects a raw URL\n\n    param = param.replace(/[[]/g, '\\\\[').replace(/[\\]]/g, '\\\\]');\n    var regexS = '[\\\\?&]' + param + '=([^&#]*)',\n        regex = new RegExp(regexS),\n        results = regex.exec(url);\n    if (results === null || (results && typeof(results[1]) !== 'string' && results[1].length)) {\n        return '';\n    } else {\n        var result = results[1];\n        try {\n            result = decodeURIComponent(result);\n        } catch(err) {\n            console$1.error('Skipping decoding for malformed query param: ' + result);\n        }\n        return result.replace(/\\+/g, ' ');\n    }\n};\n\n\n// _.cookie\n// Methods partially borrowed from quirksmode.org/js/cookies.html\n_.cookie = {\n    get: function(name) {\n        var nameEQ = name + '=';\n        var ca = document$1.cookie.split(';');\n        for (var i = 0; i < ca.length; i++) {\n            var c = ca[i];\n            while (c.charAt(0) == ' ') {\n                c = c.substring(1, c.length);\n            }\n            if (c.indexOf(nameEQ) === 0) {\n                return decodeURIComponent(c.substring(nameEQ.length, c.length));\n            }\n        }\n        return null;\n    },\n\n    parse: function(name) {\n        var cookie;\n        try {\n            cookie = _.JSONDecode(_.cookie.get(name)) || {};\n        } catch (err) {\n            // noop\n        }\n        return cookie;\n    },\n\n    set_seconds: function(name, value, seconds, is_cross_subdomain, is_secure, is_cross_site, domain_override) {\n        var cdomain = '',\n            expires = '',\n            secure = '';\n\n        if (domain_override) {\n            cdomain = '; domain=' + domain_override;\n        } else if (is_cross_subdomain) {\n            var domain = extract_domain(document$1.location.hostname);\n            cdomain = domain ? '; domain=.' + domain : '';\n        }\n\n        if (seconds) {\n            var date = new Date();\n            date.setTime(date.getTime() + (seconds * 1000));\n            expires = '; expires=' + date.toGMTString();\n        }\n\n        if (is_cross_site) {\n            is_secure = true;\n            secure = '; SameSite=None';\n        }\n        if (is_secure) {\n            secure += '; secure';\n        }\n\n        document$1.cookie = name + '=' + encodeURIComponent(value) + expires + '; path=/' + cdomain + secure;\n    },\n\n    set: function(name, value, days, is_cross_subdomain, is_secure, is_cross_site, domain_override) {\n        var cdomain = '', expires = '', secure = '';\n\n        if (domain_override) {\n            cdomain = '; domain=' + domain_override;\n        } else if (is_cross_subdomain) {\n            var domain = extract_domain(document$1.location.hostname);\n            cdomain = domain ? '; domain=.' + domain : '';\n        }\n\n        if (days) {\n            var date = new Date();\n            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));\n            expires = '; expires=' + date.toGMTString();\n        }\n\n        if (is_cross_site) {\n            is_secure = true;\n            secure = '; SameSite=None';\n        }\n        if (is_secure) {\n            secure += '; secure';\n        }\n\n        var new_cookie_val = name + '=' + encodeURIComponent(value) + expires + '; path=/' + cdomain + secure;\n        document$1.cookie = new_cookie_val;\n        return new_cookie_val;\n    },\n\n    remove: function(name, is_cross_subdomain, domain_override) {\n        _.cookie.set(name, '', -1, is_cross_subdomain, false, false, domain_override);\n    }\n};\n\nvar _testStorageSupported = function (storage) {\n    var supported = true;\n    try {\n        var key = '__mplss_' + cheap_guid(8),\n            val = 'xyz';\n        storage.setItem(key, val);\n        if (storage.getItem(key) !== val) {\n            supported = false;\n        }\n        storage.removeItem(key);\n    } catch (err) {\n        supported = false;\n    }\n    return supported;\n};\n\nvar _localStorageSupported = null;\nvar localStorageSupported = function(storage, forceCheck) {\n    if (_localStorageSupported !== null && !forceCheck) {\n        return _localStorageSupported;\n    }\n    return _localStorageSupported = _testStorageSupported(storage || win.localStorage);\n};\n\nvar _sessionStorageSupported = null;\nvar sessionStorageSupported = function(storage, forceCheck) {\n    if (_sessionStorageSupported !== null && !forceCheck) {\n        return _sessionStorageSupported;\n    }\n    return _sessionStorageSupported = _testStorageSupported(storage || win.sessionStorage);\n};\n\nfunction _storageWrapper(storage, name, is_supported_fn) {\n    var log_error = function(msg) {\n        console$1.error(name + ' error: ' + msg);\n    };\n\n    return {\n        is_supported: function(forceCheck) {\n            var supported = is_supported_fn(storage, forceCheck);\n            if (!supported) {\n                console$1.error(name + ' unsupported');\n            }\n            return supported;\n        },\n        error: log_error,\n        get: function(key) {\n            try {\n                return storage.getItem(key);\n            } catch (err) {\n                log_error(err);\n            }\n            return null;\n        },\n        parse: function(key) {\n            try {\n                return _.JSONDecode(storage.getItem(key)) || {};\n            } catch (err) {\n                // noop\n            }\n            return null;\n        },\n        set: function(key, value) {\n            try {\n                storage.setItem(key, value);\n            } catch (err) {\n                log_error(err);\n            }\n        },\n        remove: function(key) {\n            try {\n                storage.removeItem(key);\n            } catch (err) {\n                log_error(err);\n            }\n        }\n    };\n}\n\n_.localStorage = _storageWrapper(win.localStorage, 'localStorage', localStorageSupported);\n_.sessionStorage = _storageWrapper(win.sessionStorage, 'sessionStorage', sessionStorageSupported);\n\n_.register_event = (function() {\n    // written by Dean Edwards, 2005\n    // with input from Tino Zijdel - crisp@xs4all.nl\n    // with input from Carl Sverre - mail@carlsverre.com\n    // with input from Mixpanel\n    // http://dean.edwards.name/weblog/2005/10/add-event/\n    // https://gist.github.com/1930440\n\n    /**\n     * @param {Object} element\n     * @param {string} type\n     * @param {function(...*)} handler\n     * @param {boolean=} oldSchool\n     * @param {boolean=} useCapture\n     */\n    var register_event = function(element, type, handler, oldSchool, useCapture) {\n        if (!element) {\n            console$1.error('No valid element provided to register_event');\n            return;\n        }\n\n        if (element.addEventListener && !oldSchool) {\n            element.addEventListener(type, handler, !!useCapture);\n        } else {\n            var ontype = 'on' + type;\n            var old_handler = element[ontype]; // can be undefined\n            element[ontype] = makeHandler(element, handler, old_handler);\n        }\n    };\n\n    function makeHandler(element, new_handler, old_handlers) {\n        var handler = function(event) {\n            event = event || fixEvent(win.event);\n\n            // this basically happens in firefox whenever another script\n            // overwrites the onload callback and doesn't pass the event\n            // object to previously defined callbacks.  All the browsers\n            // that don't define window.event implement addEventListener\n            // so the dom_loaded handler will still be fired as usual.\n            if (!event) {\n                return undefined;\n            }\n\n            var ret = true;\n            var old_result, new_result;\n\n            if (_.isFunction(old_handlers)) {\n                old_result = old_handlers(event);\n            }\n            new_result = new_handler.call(element, event);\n\n            if ((false === old_result) || (false === new_result)) {\n                ret = false;\n            }\n\n            return ret;\n        };\n\n        return handler;\n    }\n\n    function fixEvent(event) {\n        if (event) {\n            event.preventDefault = fixEvent.preventDefault;\n            event.stopPropagation = fixEvent.stopPropagation;\n        }\n        return event;\n    }\n    fixEvent.preventDefault = function() {\n        this.returnValue = false;\n    };\n    fixEvent.stopPropagation = function() {\n        this.cancelBubble = true;\n    };\n\n    return register_event;\n})();\n\n\nvar TOKEN_MATCH_REGEX = new RegExp('^(\\\\w*)\\\\[(\\\\w+)([=~\\\\|\\\\^\\\\$\\\\*]?)=?\"?([^\\\\]\"]*)\"?\\\\]$');\n\n_.dom_query = (function() {\n    /* document.getElementsBySelector(selector)\n    - returns an array of element objects from the current document\n    matching the CSS selector. Selectors can contain element names,\n    class names and ids and can be nested. For example:\n\n    elements = document.getElementsBySelector('div#main p a.external')\n\n    Will return an array of all 'a' elements with 'external' in their\n    class attribute that are contained inside 'p' elements that are\n    contained inside the 'div' element which has id=\"main\"\n\n    New in version 0.4: Support for CSS2 and CSS3 attribute selectors:\n    See http://www.w3.org/TR/css3-selectors/#attribute-selectors\n\n    Version 0.4 - Simon Willison, March 25th 2003\n    -- Works in Phoenix 0.5, Mozilla 1.3, Opera 7, Internet Explorer 6, Internet Explorer 5 on Windows\n    -- Opera 7 fails\n\n    Version 0.5 - Carl Sverre, Jan 7th 2013\n    -- Now uses jQuery-esque `hasClass` for testing class name\n    equality.  This fixes a bug related to '-' characters being\n    considered not part of a 'word' in regex.\n    */\n\n    function getAllChildren(e) {\n        // Returns all children of element. Workaround required for IE5/Windows. Ugh.\n        return e.all ? e.all : e.getElementsByTagName('*');\n    }\n\n    var bad_whitespace = /[\\t\\r\\n]/g;\n\n    function hasClass(elem, selector) {\n        var className = ' ' + selector + ' ';\n        return ((' ' + elem.className + ' ').replace(bad_whitespace, ' ').indexOf(className) >= 0);\n    }\n\n    function getElementsBySelector(selector) {\n        // Attempt to fail gracefully in lesser browsers\n        if (!document$1.getElementsByTagName) {\n            return [];\n        }\n        // Split selector in to tokens\n        var tokens = selector.split(' ');\n        var token, bits, tagName, found, foundCount, i, j, k, elements, currentContextIndex;\n        var currentContext = [document$1];\n        for (i = 0; i < tokens.length; i++) {\n            token = tokens[i].replace(/^\\s+/, '').replace(/\\s+$/, '');\n            if (token.indexOf('#') > -1) {\n                // Token is an ID selector\n                bits = token.split('#');\n                tagName = bits[0];\n                var id = bits[1];\n                var element = document$1.getElementById(id);\n                if (!element || (tagName && element.nodeName.toLowerCase() != tagName)) {\n                    // element not found or tag with that ID not found, return false\n                    return [];\n                }\n                // Set currentContext to contain just this element\n                currentContext = [element];\n                continue; // Skip to next token\n            }\n            if (token.indexOf('.') > -1) {\n                // Token contains a class selector\n                bits = token.split('.');\n                tagName = bits[0];\n                var className = bits[1];\n                if (!tagName) {\n                    tagName = '*';\n                }\n                // Get elements matching tag, filter them for class selector\n                found = [];\n                foundCount = 0;\n                for (j = 0; j < currentContext.length; j++) {\n                    if (tagName == '*') {\n                        elements = getAllChildren(currentContext[j]);\n                    } else {\n                        elements = currentContext[j].getElementsByTagName(tagName);\n                    }\n                    for (k = 0; k < elements.length; k++) {\n                        found[foundCount++] = elements[k];\n                    }\n                }\n                currentContext = [];\n                currentContextIndex = 0;\n                for (j = 0; j < found.length; j++) {\n                    if (found[j].className &&\n                        _.isString(found[j].className) && // some SVG elements have classNames which are not strings\n                        hasClass(found[j], className)\n                    ) {\n                        currentContext[currentContextIndex++] = found[j];\n                    }\n                }\n                continue; // Skip to next token\n            }\n            // Code to deal with attribute selectors\n            var token_match = token.match(TOKEN_MATCH_REGEX);\n            if (token_match) {\n                tagName = token_match[1];\n                var attrName = token_match[2];\n                var attrOperator = token_match[3];\n                var attrValue = token_match[4];\n                if (!tagName) {\n                    tagName = '*';\n                }\n                // Grab all of the tagName elements within current context\n                found = [];\n                foundCount = 0;\n                for (j = 0; j < currentContext.length; j++) {\n                    if (tagName == '*') {\n                        elements = getAllChildren(currentContext[j]);\n                    } else {\n                        elements = currentContext[j].getElementsByTagName(tagName);\n                    }\n                    for (k = 0; k < elements.length; k++) {\n                        found[foundCount++] = elements[k];\n                    }\n                }\n                currentContext = [];\n                currentContextIndex = 0;\n                var checkFunction; // This function will be used to filter the elements\n                switch (attrOperator) {\n                    case '=': // Equality\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName) == attrValue);\n                        };\n                        break;\n                    case '~': // Match one of space seperated words\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).match(new RegExp('\\\\b' + attrValue + '\\\\b')));\n                        };\n                        break;\n                    case '|': // Match start with value followed by optional hyphen\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).match(new RegExp('^' + attrValue + '-?')));\n                        };\n                        break;\n                    case '^': // Match starts with value\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).indexOf(attrValue) === 0);\n                        };\n                        break;\n                    case '$': // Match ends with value - fails with \"Warning\" in Opera 7\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).lastIndexOf(attrValue) == e.getAttribute(attrName).length - attrValue.length);\n                        };\n                        break;\n                    case '*': // Match ends with value\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).indexOf(attrValue) > -1);\n                        };\n                        break;\n                    default:\n                        // Just test for existence of attribute\n                        checkFunction = function(e) {\n                            return e.getAttribute(attrName);\n                        };\n                }\n                currentContext = [];\n                currentContextIndex = 0;\n                for (j = 0; j < found.length; j++) {\n                    if (checkFunction(found[j])) {\n                        currentContext[currentContextIndex++] = found[j];\n                    }\n                }\n                // alert('Attribute Selector: '+tagName+' '+attrName+' '+attrOperator+' '+attrValue);\n                continue; // Skip to next token\n            }\n            // If we get here, token is JUST an element (not a class or ID selector)\n            tagName = token;\n            found = [];\n            foundCount = 0;\n            for (j = 0; j < currentContext.length; j++) {\n                elements = currentContext[j].getElementsByTagName(tagName);\n                for (k = 0; k < elements.length; k++) {\n                    found[foundCount++] = elements[k];\n                }\n            }\n            currentContext = found;\n        }\n        return currentContext;\n    }\n\n    return function(query) {\n        if (_.isElement(query)) {\n            return [query];\n        } else if (_.isObject(query) && !_.isUndefined(query.length)) {\n            return query;\n        } else {\n            return getElementsBySelector.call(this, query);\n        }\n    };\n})();\n\nvar CAMPAIGN_KEYWORDS = ['utm_source', 'utm_medium', 'utm_campaign', 'utm_content', 'utm_term', 'utm_id', 'utm_source_platform','utm_campaign_id', 'utm_creative_format', 'utm_marketing_tactic'];\nvar CLICK_IDS = ['dclid', 'fbclid', 'gclid', 'ko_click_id', 'li_fat_id', 'msclkid', 'sccid', 'ttclid', 'twclid', 'wbraid'];\n\n_.info = {\n    campaignParams: function(default_value) {\n        var kw = '',\n            params = {};\n        _.each(CAMPAIGN_KEYWORDS, function(kwkey) {\n            kw = _.getQueryParam(document$1.URL, kwkey);\n            if (kw.length) {\n                params[kwkey] = kw;\n            } else if (default_value !== undefined) {\n                params[kwkey] = default_value;\n            }\n        });\n\n        return params;\n    },\n\n    clickParams: function() {\n        var id = '',\n            params = {};\n        _.each(CLICK_IDS, function(idkey) {\n            id = _.getQueryParam(document$1.URL, idkey);\n            if (id.length) {\n                params[idkey] = id;\n            }\n        });\n\n        return params;\n    },\n\n    marketingParams: function() {\n        return _.extend(_.info.campaignParams(), _.info.clickParams());\n    },\n\n    searchEngine: function(referrer) {\n        if (referrer.search('https?://(.*)google.([^/?]*)') === 0) {\n            return 'google';\n        } else if (referrer.search('https?://(.*)bing.com') === 0) {\n            return 'bing';\n        } else if (referrer.search('https?://(.*)yahoo.com') === 0) {\n            return 'yahoo';\n        } else if (referrer.search('https?://(.*)duckduckgo.com') === 0) {\n            return 'duckduckgo';\n        } else {\n            return null;\n        }\n    },\n\n    searchInfo: function(referrer) {\n        var search = _.info.searchEngine(referrer),\n            param = (search != 'yahoo') ? 'q' : 'p',\n            ret = {};\n\n        if (search !== null) {\n            ret['$search_engine'] = search;\n\n            var keyword = _.getQueryParam(referrer, param);\n            if (keyword.length) {\n                ret['mp_keyword'] = keyword;\n            }\n        }\n\n        return ret;\n    },\n\n    /**\n     * This function detects which browser is running this script.\n     * The order of the checks are important since many user agents\n     * include key words used in later checks.\n     */\n    browser: function(user_agent, vendor, opera) {\n        vendor = vendor || ''; // vendor is undefined for at least IE9\n        if (opera || _.includes(user_agent, ' OPR/')) {\n            if (_.includes(user_agent, 'Mini')) {\n                return 'Opera Mini';\n            }\n            return 'Opera';\n        } else if (/(BlackBerry|PlayBook|BB10)/i.test(user_agent)) {\n            return 'BlackBerry';\n        } else if (_.includes(user_agent, 'IEMobile') || _.includes(user_agent, 'WPDesktop')) {\n            return 'Internet Explorer Mobile';\n        } else if (_.includes(user_agent, 'SamsungBrowser/')) {\n            // https://developer.samsung.com/internet/user-agent-string-format\n            return 'Samsung Internet';\n        } else if (_.includes(user_agent, 'Edge') || _.includes(user_agent, 'Edg/')) {\n            return 'Microsoft Edge';\n        } else if (_.includes(user_agent, 'FBIOS')) {\n            return 'Facebook Mobile';\n        } else if (_.includes(user_agent, 'Whale/')) {\n            // https://user-agents.net/browsers/whale-browser\n            return 'Whale Browser';\n        } else if (_.includes(user_agent, 'Chrome')) {\n            return 'Chrome';\n        } else if (_.includes(user_agent, 'CriOS')) {\n            return 'Chrome iOS';\n        } else if (_.includes(user_agent, 'UCWEB') || _.includes(user_agent, 'UCBrowser')) {\n            return 'UC Browser';\n        } else if (_.includes(user_agent, 'FxiOS')) {\n            return 'Firefox iOS';\n        } else if (_.includes(vendor, 'Apple')) {\n            if (_.includes(user_agent, 'Mobile')) {\n                return 'Mobile Safari';\n            }\n            return 'Safari';\n        } else if (_.includes(user_agent, 'Android')) {\n            return 'Android Mobile';\n        } else if (_.includes(user_agent, 'Konqueror')) {\n            return 'Konqueror';\n        } else if (_.includes(user_agent, 'Firefox')) {\n            return 'Firefox';\n        } else if (_.includes(user_agent, 'MSIE') || _.includes(user_agent, 'Trident/')) {\n            return 'Internet Explorer';\n        } else if (_.includes(user_agent, 'Gecko')) {\n            return 'Mozilla';\n        } else {\n            return '';\n        }\n    },\n\n    /**\n     * This function detects which browser version is running this script,\n     * parsing major and minor version (e.g., 42.1). User agent strings from:\n     * http://www.useragentstring.com/pages/useragentstring.php\n     */\n    browserVersion: function(userAgent, vendor, opera) {\n        var browser = _.info.browser(userAgent, vendor, opera);\n        var versionRegexs = {\n            'Internet Explorer Mobile': /rv:(\\d+(\\.\\d+)?)/,\n            'Microsoft Edge': /Edge?\\/(\\d+(\\.\\d+)?)/,\n            'Chrome': /Chrome\\/(\\d+(\\.\\d+)?)/,\n            'Chrome iOS': /CriOS\\/(\\d+(\\.\\d+)?)/,\n            'UC Browser' : /(UCBrowser|UCWEB)\\/(\\d+(\\.\\d+)?)/,\n            'Safari': /Version\\/(\\d+(\\.\\d+)?)/,\n            'Mobile Safari': /Version\\/(\\d+(\\.\\d+)?)/,\n            'Opera': /(Opera|OPR)\\/(\\d+(\\.\\d+)?)/,\n            'Firefox': /Firefox\\/(\\d+(\\.\\d+)?)/,\n            'Firefox iOS': /FxiOS\\/(\\d+(\\.\\d+)?)/,\n            'Konqueror': /Konqueror:(\\d+(\\.\\d+)?)/,\n            'BlackBerry': /BlackBerry (\\d+(\\.\\d+)?)/,\n            'Android Mobile': /android\\s(\\d+(\\.\\d+)?)/,\n            'Samsung Internet': /SamsungBrowser\\/(\\d+(\\.\\d+)?)/,\n            'Internet Explorer': /(rv:|MSIE )(\\d+(\\.\\d+)?)/,\n            'Mozilla': /rv:(\\d+(\\.\\d+)?)/,\n            'Whale Browser': /Whale\\/(\\d+(\\.\\d+)?)/\n        };\n        var regex = versionRegexs[browser];\n        if (regex === undefined) {\n            return null;\n        }\n        var matches = userAgent.match(regex);\n        if (!matches) {\n            return null;\n        }\n        return parseFloat(matches[matches.length - 2]);\n    },\n\n    os: function() {\n        var a = userAgent;\n        if (/Windows/i.test(a)) {\n            if (/Phone/.test(a) || /WPDesktop/.test(a)) {\n                return 'Windows Phone';\n            }\n            return 'Windows';\n        } else if (/(iPhone|iPad|iPod)/.test(a)) {\n            return 'iOS';\n        } else if (/Android/.test(a)) {\n            return 'Android';\n        } else if (/(BlackBerry|PlayBook|BB10)/i.test(a)) {\n            return 'BlackBerry';\n        } else if (/Mac/i.test(a)) {\n            return 'Mac OS X';\n        } else if (/Linux/.test(a)) {\n            return 'Linux';\n        } else if (/CrOS/.test(a)) {\n            return 'Chrome OS';\n        } else {\n            return '';\n        }\n    },\n\n    device: function(user_agent) {\n        if (/Windows Phone/i.test(user_agent) || /WPDesktop/.test(user_agent)) {\n            return 'Windows Phone';\n        } else if (/iPad/.test(user_agent)) {\n            return 'iPad';\n        } else if (/iPod/.test(user_agent)) {\n            return 'iPod Touch';\n        } else if (/iPhone/.test(user_agent)) {\n            return 'iPhone';\n        } else if (/(BlackBerry|PlayBook|BB10)/i.test(user_agent)) {\n            return 'BlackBerry';\n        } else if (/Android/.test(user_agent)) {\n            return 'Android';\n        } else {\n            return '';\n        }\n    },\n\n    referringDomain: function(referrer) {\n        var split = referrer.split('/');\n        if (split.length >= 3) {\n            return split[2];\n        }\n        return '';\n    },\n\n    currentUrl: function() {\n        return win.location.href;\n    },\n\n    properties: function(extra_props) {\n        if (typeof extra_props !== 'object') {\n            extra_props = {};\n        }\n        return _.extend(_.strip_empty_properties({\n            '$os': _.info.os(),\n            '$browser': _.info.browser(userAgent, navigator.vendor, windowOpera),\n            '$referrer': document$1.referrer,\n            '$referring_domain': _.info.referringDomain(document$1.referrer),\n            '$device': _.info.device(userAgent)\n        }), {\n            '$current_url': _.info.currentUrl(),\n            '$browser_version': _.info.browserVersion(userAgent, navigator.vendor, windowOpera),\n            '$screen_height': screen.height,\n            '$screen_width': screen.width,\n            'mp_lib': 'web',\n            '$lib_version': Config.LIB_VERSION,\n            '$insert_id': cheap_guid(),\n            'time': _.timestamp() / 1000 // epoch time in seconds\n        }, _.strip_empty_properties(extra_props));\n    },\n\n    people_properties: function() {\n        return _.extend(_.strip_empty_properties({\n            '$os': _.info.os(),\n            '$browser': _.info.browser(userAgent, navigator.vendor, windowOpera)\n        }), {\n            '$browser_version': _.info.browserVersion(userAgent, navigator.vendor, windowOpera)\n        });\n    },\n\n    mpPageViewProperties: function() {\n        return _.strip_empty_properties({\n            'current_page_title': document$1.title,\n            'current_domain': win.location.hostname,\n            'current_url_path': win.location.pathname,\n            'current_url_protocol': win.location.protocol,\n            'current_url_search': win.location.search\n        });\n    }\n};\n\n/**\n * Returns a throttled function that will only run at most every `waitMs` and returns a promise that resolves with the next invocation.\n * Throttled calls will build up a batch of args and invoke the callback with all args since the last invocation.\n */\nvar batchedThrottle = function (fn, waitMs) {\n    var timeoutPromise = null;\n    var throttledItems = [];\n    return function (item) {\n        var self = this;\n        throttledItems.push(item);\n\n        if (!timeoutPromise) {\n            timeoutPromise = new PromisePolyfill(function (resolve) {\n                setTimeout(function () {\n                    var returnValue = fn.apply(self, [throttledItems]);\n                    timeoutPromise = null;\n                    throttledItems = [];\n                    resolve(returnValue);\n                }, waitMs);\n            });\n        }\n        return timeoutPromise;\n    };\n};\n\nvar cheap_guid = function(maxlen) {\n    var guid = Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10);\n    return maxlen ? guid.substring(0, maxlen) : guid;\n};\n\n/**\n * Generates a W3C traceparent header for easy interop with distributed tracing systems i.e Open Telemetry\n * https://www.w3.org/TR/trace-context/#traceparent-header\n*/\nvar generateTraceparent = function() {\n    var traceID = _.UUID().replace(/-/g, '');\n    var parentID = _.UUID().replace(/-/g, '').substring(0, 16);\n\n    // Sampled trace\n    var traceFlags = '01';\n\n    return '00-' + traceID + '-' + parentID + '-' + traceFlags;\n};\n\n// naive way to extract domain name (example.com) from full hostname (my.sub.example.com)\nvar SIMPLE_DOMAIN_MATCH_REGEX = /[a-z0-9][a-z0-9-]*\\.[a-z]+$/i;\n// this next one attempts to account for some ccSLDs, e.g. extracting oxford.ac.uk from www.oxford.ac.uk\nvar DOMAIN_MATCH_REGEX = /[a-z0-9][a-z0-9-]+\\.[a-z.]{2,6}$/i;\n/**\n * Attempts to extract main domain name from full hostname, using a few blunt heuristics. For\n * common TLDs like .com/.org that always have a simple SLD.TLD structure (example.com), we\n * simply extract the last two .-separated parts of the hostname (SIMPLE_DOMAIN_MATCH_REGEX).\n * For others, we attempt to account for short ccSLD+TLD combos (.ac.uk) with the legacy\n * DOMAIN_MATCH_REGEX (kept to maintain backwards compatibility with existing Mixpanel\n * integrations). The only _reliable_ way to extract domain from hostname is with an up-to-date\n * list like at https://publicsuffix.org/ so for cases that this helper fails at, the SDK\n * offers the 'cookie_domain' config option to set it explicitly.\n * @example\n * extract_domain('my.sub.example.com')\n * // 'example.com'\n */\nvar extract_domain = function(hostname) {\n    var domain_regex = DOMAIN_MATCH_REGEX;\n    var parts = hostname.split('.');\n    var tld = parts[parts.length - 1];\n    if (tld.length > 4 || tld === 'com' || tld === 'org') {\n        domain_regex = SIMPLE_DOMAIN_MATCH_REGEX;\n    }\n    var matches = hostname.match(domain_regex);\n    return matches ? matches[0] : '';\n};\n\n/**\n * Check whether we have network connection. default to true for browsers that don't support navigator.onLine (IE)\n * @returns {boolean}\n */\nvar isOnline = function() {\n    var onLine = win.navigator['onLine'];\n    return _.isUndefined(onLine) || onLine;\n};\n\nvar NOOP_FUNC = function () {};\n\nvar JSONStringify = null, JSONParse = null;\nif (typeof JSON !== 'undefined') {\n    JSONStringify = JSON.stringify;\n    JSONParse = JSON.parse;\n}\nJSONStringify = JSONStringify || _.JSONEncode;\nJSONParse = JSONParse || _.JSONDecode;\n\n/**\n * Determines if CompressionStream API should be used.\n * Returns false for Safari 16.4 and 16.5 which have breaking CompressionStream bugs.\n * https://bugs.webkit.org/show_bug.cgi?id=254021\n * fixed in 16.6 https://developer.apple.com/documentation/safari-release-notes/safari-16_6-release-notes\n */\nvar canUseCompressionStream = function(userAgent, vendor, opera) {\n    if (!win.CompressionStream) {\n        return false;\n    }\n\n    var browser = _.info.browser(userAgent, vendor, opera);\n    var version = _.info.browserVersion(userAgent, vendor, opera);\n    if (browser === 'Safari' || browser === 'Mobile Safari') {\n        if (version >= 16.4 && version < 16.6) {\n            return false;\n        }\n    }\n\n    return true;\n};\n\n// UNMINIFIED EXPORTS (for closure compiler)\n_['info']                   = _.info;\n_['info']['browser']        = _.info.browser;\n_['info']['browserVersion'] = _.info.browserVersion;\n_['info']['device']         = _.info.device;\n_['info']['properties']     = _.info.properties;\n_['isBlockedUA']            = _.isBlockedUA;\n_['isEmptyObject']          = _.isEmptyObject;\n_['isObject']               = _.isObject;\n_['JSONDecode']             = _.JSONDecode;\n_['JSONEncode']             = _.JSONEncode;\n_['toArray']                = _.toArray;\n_['NPO']                    = NpoPromise;\n\nvar MIXPANEL_DB_NAME = 'mixpanelBrowserDb';\n\nvar RECORDING_EVENTS_STORE_NAME = 'mixpanelRecordingEvents';\nvar RECORDING_REGISTRY_STORE_NAME = 'mixpanelRecordingRegistry';\n\n// note: increment the version number when adding new object stores\nvar DB_VERSION = 1;\nvar OBJECT_STORES = [RECORDING_EVENTS_STORE_NAME, RECORDING_REGISTRY_STORE_NAME];\n\n/**\n * @type {import('./wrapper').StorageWrapper}\n */\nvar IDBStorageWrapper = function (storeName) {\n    /**\n     * @type {Promise<IDBDatabase>|null}\n     */\n    this.dbPromise = null;\n    this.storeName = storeName;\n};\n\nIDBStorageWrapper.prototype._openDb = function () {\n    return new PromisePolyfill(function (resolve, reject) {\n        var openRequest = win.indexedDB.open(MIXPANEL_DB_NAME, DB_VERSION);\n        openRequest['onerror'] = function () {\n            reject(openRequest.error);\n        };\n\n        openRequest['onsuccess'] = function () {\n            resolve(openRequest.result);\n        };\n\n        openRequest['onupgradeneeded'] = function (ev) {\n            var db = ev.target.result;\n\n            OBJECT_STORES.forEach(function (storeName) {\n                db.createObjectStore(storeName);\n            });\n        };\n    });\n};\n\nIDBStorageWrapper.prototype.init = function () {\n    if (!win.indexedDB) {\n        return PromisePolyfill.reject('indexedDB is not supported in this browser');\n    }\n\n    if (!this.dbPromise) {\n        this.dbPromise = this._openDb();\n    }\n\n    return this.dbPromise\n        .then(function (dbOrError) {\n            if (dbOrError instanceof win['IDBDatabase']) {\n                return PromisePolyfill.resolve();\n            } else {\n                return PromisePolyfill.reject(dbOrError);\n            }\n        });\n};\n\nIDBStorageWrapper.prototype.isInitialized = function () {\n    return !!this.dbPromise;\n};\n\n/**\n * @param {IDBTransactionMode} mode\n * @param {function(IDBObjectStore): void} storeCb\n */\nIDBStorageWrapper.prototype.makeTransaction = function (mode, storeCb) {\n    var storeName = this.storeName;\n    var doTransaction = function (db) {\n        return new PromisePolyfill(function (resolve, reject) {\n            var transaction = db.transaction(storeName, mode);\n            transaction.oncomplete = function () {\n                resolve(transaction);\n            };\n            transaction.onabort = transaction.onerror = function () {\n                reject(transaction.error);\n            };\n\n            storeCb(transaction.objectStore(storeName));\n        });\n    };\n\n    return this.dbPromise\n        .then(doTransaction)\n        .catch(function (err) {\n            if (err && err['name'] === 'InvalidStateError') {\n                // try reopening the DB if the connection is closed\n                this.dbPromise = this._openDb();\n                return this.dbPromise.then(doTransaction);\n            } else {\n                return PromisePolyfill.reject(err);\n            }\n        }.bind(this));\n};\n\nIDBStorageWrapper.prototype.setItem = function (key, value) {\n    return this.makeTransaction('readwrite', function (objectStore) {\n        objectStore.put(value, key);\n    });\n};\n\nIDBStorageWrapper.prototype.getItem = function (key) {\n    var req;\n    return this.makeTransaction('readonly', function (objectStore) {\n        req = objectStore.get(key);\n    }).then(function () {\n        return req.result;\n    });\n};\n\nIDBStorageWrapper.prototype.removeItem = function (key) {\n    return this.makeTransaction('readwrite', function (objectStore) {\n        objectStore.delete(key);\n    });\n};\n\nIDBStorageWrapper.prototype.getAll = function () {\n    var req;\n    return this.makeTransaction('readonly', function (objectStore) {\n        req = objectStore.getAll();\n    }).then(function () {\n        return req.result;\n    });\n};\n\n/**\n * GDPR utils\n *\n * The General Data Protection Regulation (GDPR) is a regulation in EU law on data protection\n * and privacy for all individuals within the European Union. It addresses the export of personal\n * data outside the EU. The GDPR aims primarily to give control back to citizens and residents\n * over their personal data and to simplify the regulatory environment for international business\n * by unifying the regulation within the EU.\n *\n * This set of utilities is intended to enable opt in/out functionality in the Mixpanel JS SDK.\n * These functions are used internally by the SDK and are not intended to be publicly exposed.\n */\n\n\n/**\n * A function used to track a Mixpanel event (e.g. MixpanelLib.track)\n * @callback trackFunction\n * @param {String} event_name The name of the event. This can be anything the user does - 'Button Click', 'Sign Up', 'Item Purchased', etc.\n * @param {Object} [properties] A set of properties to include with the event you're sending. These describe the user who did the event or details about the event itself.\n * @param {Function} [callback] If provided, the callback function will be called after tracking the event.\n */\n\n/** Public **/\n\nvar GDPR_DEFAULT_PERSISTENCE_PREFIX = '__mp_opt_in_out_';\n\n/**\n * Opt the user in to data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {trackFunction} [options.track] - function used for tracking a Mixpanel event to record the opt-in action\n * @param {string} [options.trackEventName] - event name to be used for tracking the opt-in action\n * @param {Object} [options.trackProperties] - set of properties to be tracked along with the opt-in action\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-in cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-in cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-in cookie is set as secure or not\n */\nfunction optIn(token, options) {\n    _optInOut(true, token, options);\n}\n\n/**\n * Opt the user out of data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-out cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-out cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-out cookie is set as secure or not\n */\nfunction optOut(token, options) {\n    _optInOut(false, token, options);\n}\n\n/**\n * Check whether the user has opted in to data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @returns {boolean} whether the user has opted in to the given opt type\n */\nfunction hasOptedIn(token, options) {\n    return _getStorageValue(token, options) === '1';\n}\n\n/**\n * Check whether the user has opted out of data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {boolean} [options.ignoreDnt] - flag to ignore browser DNT settings and always return false\n * @returns {boolean} whether the user has opted out of the given opt type\n */\nfunction hasOptedOut(token, options) {\n    if (_hasDoNotTrackFlagOn(options)) {\n        console$1.warn('This browser has \"Do Not Track\" enabled. This will prevent the Mixpanel SDK from sending any data. To ignore the \"Do Not Track\" browser setting, initialize the Mixpanel instance with the config \"ignore_dnt: true\"');\n        return true;\n    }\n    var optedOut = _getStorageValue(token, options) === '0';\n    if (optedOut) {\n        console$1.warn('You are opted out of Mixpanel tracking. This will prevent the Mixpanel SDK from sending any data.');\n    }\n    return optedOut;\n}\n\n/**\n * Wrap a MixpanelLib method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */\nfunction addOptOutCheckMixpanelLib(method) {\n    return _addOptOutCheck(method, function(name) {\n        return this.get_config(name);\n    });\n}\n\n/**\n * Wrap a MixpanelPeople method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */\nfunction addOptOutCheckMixpanelPeople(method) {\n    return _addOptOutCheck(method, function(name) {\n        return this._get_config(name);\n    });\n}\n\n/**\n * Wrap a MixpanelGroup method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */\nfunction addOptOutCheckMixpanelGroup(method) {\n    return _addOptOutCheck(method, function(name) {\n        return this._get_config(name);\n    });\n}\n\n/**\n * Clear the user's opt in/out status of data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-in cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-in cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-in cookie is set as secure or not\n */\nfunction clearOptInOut(token, options) {\n    options = options || {};\n    _getStorage(options).remove(\n        _getStorageKey(token, options), !!options.crossSubdomainCookie, options.cookieDomain\n    );\n}\n\n/** Private **/\n\n/**\n * Get storage util\n * @param {Object} [options]\n * @param {string} [options.persistenceType]\n * @returns {object} either _.cookie or _.localstorage\n */\nfunction _getStorage(options) {\n    options = options || {};\n    return options.persistenceType === 'localStorage' ? _.localStorage : _.cookie;\n}\n\n/**\n * Get the name of the cookie that is used for the given opt type (tracking, cookie, etc.)\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @returns {string} the name of the cookie for the given opt type\n */\nfunction _getStorageKey(token, options) {\n    options = options || {};\n    return (options.persistencePrefix || GDPR_DEFAULT_PERSISTENCE_PREFIX) + token;\n}\n\n/**\n * Get the value of the cookie that is used for the given opt type (tracking, cookie, etc.)\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @returns {string} the value of the cookie for the given opt type\n */\nfunction _getStorageValue(token, options) {\n    return _getStorage(options).get(_getStorageKey(token, options));\n}\n\n/**\n * Check whether the user has set the DNT/doNotTrack setting to true in their browser\n * @param {Object} [options]\n * @param {string} [options.window] - alternate window object to check; used to force various DNT settings in browser tests\n * @param {boolean} [options.ignoreDnt] - flag to ignore browser DNT settings and always return false\n * @returns {boolean} whether the DNT setting is true\n */\nfunction _hasDoNotTrackFlagOn(options) {\n    if (options && options.ignoreDnt) {\n        return false;\n    }\n    var win$1 = (options && options.window) || win;\n    var nav = win$1['navigator'] || {};\n    var hasDntOn = false;\n\n    _.each([\n        nav['doNotTrack'], // standard\n        nav['msDoNotTrack'],\n        win$1['doNotTrack']\n    ], function(dntValue) {\n        if (_.includes([true, 1, '1', 'yes'], dntValue)) {\n            hasDntOn = true;\n        }\n    });\n\n    return hasDntOn;\n}\n\n/**\n * Set cookie/localstorage for the user indicating that they are opted in or out for the given opt type\n * @param {boolean} optValue - whether to opt the user in or out for the given opt type\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {trackFunction} [options.track] - function used for tracking a Mixpanel event to record the opt-in action\n * @param {string} [options.trackEventName] - event name to be used for tracking the opt-in action\n * @param {Object} [options.trackProperties] - set of properties to be tracked along with the opt-in action\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-in cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-in cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-in cookie is set as secure or not\n */\nfunction _optInOut(optValue, token, options) {\n    if (!_.isString(token) || !token.length) {\n        console$1.error('gdpr.' + (optValue ? 'optIn' : 'optOut') + ' called with an invalid token');\n        return;\n    }\n\n    options = options || {};\n\n    _getStorage(options).set(\n        _getStorageKey(token, options),\n        optValue ? 1 : 0,\n        _.isNumber(options.cookieExpiration) ? options.cookieExpiration : null,\n        !!options.crossSubdomainCookie,\n        !!options.secureCookie,\n        !!options.crossSiteCookie,\n        options.cookieDomain\n    );\n\n    if (options.track && optValue) { // only track event if opting in (optValue=true)\n        options.track(options.trackEventName || '$opt_in', options.trackProperties, {\n            'send_immediately': true\n        });\n    }\n}\n\n/**\n * Wrap a method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @param {function} getConfigValue - getter function for the Mixpanel API token and other options to be used with opt-out check\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */\nfunction _addOptOutCheck(method, getConfigValue) {\n    return function() {\n        var optedOut = false;\n\n        try {\n            var token = getConfigValue.call(this, 'token');\n            var ignoreDnt = getConfigValue.call(this, 'ignore_dnt');\n            var persistenceType = getConfigValue.call(this, 'opt_out_tracking_persistence_type');\n            var persistencePrefix = getConfigValue.call(this, 'opt_out_tracking_cookie_prefix');\n            var win = getConfigValue.call(this, 'window'); // used to override window during browser tests\n\n            if (token) { // if there was an issue getting the token, continue method execution as normal\n                optedOut = hasOptedOut(token, {\n                    ignoreDnt: ignoreDnt,\n                    persistenceType: persistenceType,\n                    persistencePrefix: persistencePrefix,\n                    window: win\n                });\n            }\n        } catch(err) {\n            console$1.error('Unexpected error when checking tracking opt-out status: ' + err);\n        }\n\n        if (!optedOut) {\n            return method.apply(this, arguments);\n        }\n\n        var callback = arguments[arguments.length - 1];\n        if (typeof(callback) === 'function') {\n            callback(0);\n        }\n\n        return;\n    };\n}\n\nvar logger$6 = console_with_prefix('lock');\n\n/**\n * SharedLock: a mutex built on HTML5 localStorage, to ensure that only one browser\n * window/tab at a time will be able to access shared resources.\n *\n * Based on the Alur and Taubenfeld fast lock\n * (http://www.cs.rochester.edu/research/synchronization/pseudocode/fastlock.html)\n * with an added timeout to ensure there will be eventual progress in the event\n * that a window is closed in the middle of the callback.\n *\n * Implementation based on the original version by David Wolever (https://github.com/wolever)\n * at https://gist.github.com/wolever/5fd7573d1ef6166e8f8c4af286a69432.\n *\n * @example\n * const myLock = new SharedLock('some-key');\n * myLock.withLock(function() {\n *   console.log('I hold the mutex!');\n * });\n *\n * @constructor\n */\nvar SharedLock = function(key, options) {\n    options = options || {};\n\n    this.storageKey = key;\n    this.storage = options.storage || win.localStorage;\n    this.pollIntervalMS = options.pollIntervalMS || 100;\n    this.timeoutMS = options.timeoutMS || 2000;\n\n    // dependency-inject promise implementation for testing purposes\n    this.promiseImpl = options.promiseImpl || PromisePolyfill;\n};\n\n// pass in a specific pid to test contention scenarios; otherwise\n// it is chosen randomly for each acquisition attempt\nSharedLock.prototype.withLock = function(lockedCB, pid) {\n    var Promise = this.promiseImpl;\n    return new Promise(_.bind(function (resolve, reject) {\n        var i = pid || (new Date().getTime() + '|' + Math.random());\n        var startTime = new Date().getTime();\n        var key = this.storageKey;\n        var pollIntervalMS = this.pollIntervalMS;\n        var timeoutMS = this.timeoutMS;\n        var storage = this.storage;\n\n        var keyX = key + ':X';\n        var keyY = key + ':Y';\n        var keyZ = key + ':Z';\n\n        var delay = function(cb) {\n            if (new Date().getTime() - startTime > timeoutMS) {\n                logger$6.error('Timeout waiting for mutex on ' + key + '; clearing lock. [' + i + ']');\n                storage.removeItem(keyZ);\n                storage.removeItem(keyY);\n                loop();\n                return;\n            }\n            setTimeout(function() {\n                try {\n                    cb();\n                } catch(err) {\n                    reject(err);\n                }\n            }, pollIntervalMS * (Math.random() + 0.1));\n        };\n\n        var waitFor = function(predicate, cb) {\n            if (predicate()) {\n                cb();\n            } else {\n                delay(function() {\n                    waitFor(predicate, cb);\n                });\n            }\n        };\n\n        var getSetY = function() {\n            var valY = storage.getItem(keyY);\n            if (valY && valY !== i) { // if Y == i then this process already has the lock (useful for test cases)\n                return false;\n            } else {\n                storage.setItem(keyY, i);\n                if (storage.getItem(keyY) === i) {\n                    return true;\n                } else {\n                    if (!localStorageSupported(storage, true)) {\n                        reject(new Error('localStorage support dropped while acquiring lock'));\n                    }\n                    return false;\n                }\n            }\n        };\n\n        var loop = function() {\n            storage.setItem(keyX, i);\n\n            waitFor(getSetY, function() {\n                if (storage.getItem(keyX) === i) {\n                    criticalSection();\n                    return;\n                }\n\n                delay(function() {\n                    if (storage.getItem(keyY) !== i) {\n                        loop();\n                        return;\n                    }\n                    waitFor(function() {\n                        return !storage.getItem(keyZ);\n                    }, criticalSection);\n                });\n            });\n        };\n\n        var criticalSection = function() {\n            storage.setItem(keyZ, '1');\n            var removeLock = function () {\n                storage.removeItem(keyZ);\n                if (storage.getItem(keyY) === i) {\n                    storage.removeItem(keyY);\n                }\n                if (storage.getItem(keyX) === i) {\n                    storage.removeItem(keyX);\n                }\n            };\n\n            lockedCB()\n                .then(function (ret) {\n                    removeLock();\n                    resolve(ret);\n                })\n                .catch(function (err) {\n                    removeLock();\n                    reject(err);\n                });\n        };\n\n        try {\n            if (localStorageSupported(storage, true)) {\n                loop();\n            } else {\n                throw new Error('localStorage support check failed');\n            }\n        } catch(err) {\n            reject(err);\n        }\n    }, this));\n};\n\n/**\n * @type {import('./wrapper').StorageWrapper}\n */\nvar LocalStorageWrapper = function (storageOverride) {\n    this.storage = storageOverride || win.localStorage;\n};\n\nLocalStorageWrapper.prototype.init = function () {\n    return PromisePolyfill.resolve();\n};\n\nLocalStorageWrapper.prototype.isInitialized = function () {\n    return true;\n};\n\nLocalStorageWrapper.prototype.setItem = function (key, value) {\n    return new PromisePolyfill(_.bind(function (resolve, reject) {\n        try {\n            this.storage.setItem(key, JSONStringify(value));\n        } catch (e) {\n            reject(e);\n        }\n        resolve();\n    }, this));\n};\n\nLocalStorageWrapper.prototype.getItem = function (key) {\n    return new PromisePolyfill(_.bind(function (resolve, reject) {\n        var item;\n        try {\n            item = JSONParse(this.storage.getItem(key));\n        } catch (e) {\n            reject(e);\n        }\n        resolve(item);\n    }, this));\n};\n\nLocalStorageWrapper.prototype.removeItem = function (key) {\n    return new PromisePolyfill(_.bind(function (resolve, reject) {\n        try {\n            this.storage.removeItem(key);\n        } catch (e) {\n            reject(e);\n        }\n        resolve();\n    }, this));\n};\n\nvar logger$5 = console_with_prefix('batch');\n\n/**\n * RequestQueue: queue for batching API requests with localStorage backup for retries.\n * Maintains an in-memory queue which represents the source of truth for the current\n * page, but also writes all items out to a copy in the browser's localStorage, which\n * can be read on subsequent pageloads and retried. For batchability, all the request\n * items in the queue should be of the same type (events, people updates, group updates)\n * so they can be sent in a single request to the same API endpoint.\n *\n * LocalStorage keying and locking: In order for reloads and subsequent pageloads of\n * the same site to access the same persisted data, they must share the same localStorage\n * key (for instance based on project token and queue type). Therefore access to the\n * localStorage entry is guarded by an asynchronous mutex (SharedLock) to prevent\n * simultaneously open windows/tabs from overwriting each other's data (which would lead\n * to data loss in some situations).\n * @constructor\n */\nvar RequestQueue = function (storageKey, options) {\n    options = options || {};\n    this.storageKey = storageKey;\n    this.usePersistence = options.usePersistence;\n    if (this.usePersistence) {\n        this.queueStorage = options.queueStorage || new LocalStorageWrapper();\n        this.lock = new SharedLock(storageKey, {\n            storage: options.sharedLockStorage || win.localStorage,\n            timeoutMS: options.sharedLockTimeoutMS,\n        });\n    }\n    this.reportError = options.errorReporter || _.bind(logger$5.error, logger$5);\n\n    this.pid = options.pid || null; // pass pid to test out storage lock contention scenarios\n\n    this.memQueue = [];\n    this.initialized = false;\n\n    if (options.enqueueThrottleMs) {\n        this.enqueuePersisted = batchedThrottle(_.bind(this._enqueuePersisted, this), options.enqueueThrottleMs);\n    } else {\n        this.enqueuePersisted = _.bind(function (queueEntry) {\n            return this._enqueuePersisted([queueEntry]);\n        }, this);\n    }\n};\n\nRequestQueue.prototype.ensureInit = function () {\n    if (this.initialized || !this.usePersistence) {\n        return PromisePolyfill.resolve();\n    }\n\n    return this.queueStorage\n        .init()\n        .then(_.bind(function () {\n            this.initialized = true;\n        }, this))\n        .catch(_.bind(function (err) {\n            this.reportError('Error initializing queue persistence. Disabling persistence', err);\n            this.initialized = true;\n            this.usePersistence = false;\n        }, this));\n};\n\n/**\n * Add one item to queues (memory and localStorage). The queued entry includes\n * the given item along with an auto-generated ID and a \"flush-after\" timestamp.\n * It is expected that the item will be sent over the network and dequeued\n * before the flush-after time; if this doesn't happen it is considered orphaned\n * (e.g., the original tab where it was enqueued got closed before it could be\n * sent) and the item can be sent by any tab that finds it in localStorage.\n *\n * The final callback param is called with a param indicating success or\n * failure of the enqueue operation; it is asynchronous because the localStorage\n * lock is asynchronous.\n */\nRequestQueue.prototype.enqueue = function (item, flushInterval) {\n    var queueEntry = {\n        'id': cheap_guid(),\n        'flushAfter': new Date().getTime() + flushInterval * 2,\n        'payload': item\n    };\n\n    if (!this.usePersistence) {\n        this.memQueue.push(queueEntry);\n        return PromisePolyfill.resolve(true);\n    } else {\n        return this.enqueuePersisted(queueEntry);\n    }\n};\n\nRequestQueue.prototype._enqueuePersisted = function (queueEntries) {\n    var enqueueItem = _.bind(function () {\n        return this.ensureInit()\n            .then(_.bind(function () {\n                return this.readFromStorage();\n            }, this))\n            .then(_.bind(function (storedQueue) {\n                return this.saveToStorage(storedQueue.concat(queueEntries));\n            }, this))\n            .then(_.bind(function (succeeded) {\n                // only add to in-memory queue when storage succeeds\n                if (succeeded) {\n                    this.memQueue = this.memQueue.concat(queueEntries);\n                }\n\n                return succeeded;\n            }, this))\n            .catch(_.bind(function (err) {\n                this.reportError('Error enqueueing items', err, queueEntries);\n                return false;\n            }, this));\n    }, this);\n\n    return this.lock\n        .withLock(enqueueItem, this.pid)\n        .catch(_.bind(function (err) {\n            this.reportError('Error acquiring storage lock', err);\n            return false;\n        }, this));\n};\n\n/**\n * Read out the given number of queue entries. If this.memQueue\n * has fewer than batchSize items, then look for \"orphaned\" items\n * in the persisted queue (items where the 'flushAfter' time has\n * already passed).\n */\nRequestQueue.prototype.fillBatch = function (batchSize) {\n    var batch = this.memQueue.slice(0, batchSize);\n    if (this.usePersistence && batch.length < batchSize) {\n        // don't need lock just to read events; localStorage is thread-safe\n        // and the worst that could happen is a duplicate send of some\n        // orphaned events, which will be deduplicated on the server side\n        return this.ensureInit()\n            .then(_.bind(function () {\n                return this.readFromStorage();\n            }, this))\n            .then(_.bind(function (storedQueue) {\n                if (storedQueue.length) {\n                    // item IDs already in batch; don't duplicate out of storage\n                    var idsInBatch = {}; // poor man's Set\n                    _.each(batch, function (item) {\n                        idsInBatch[item['id']] = true;\n                    });\n\n                    for (var i = 0; i < storedQueue.length; i++) {\n                        var item = storedQueue[i];\n                        if (new Date().getTime() > item['flushAfter'] && !idsInBatch[item['id']]) {\n                            item.orphaned = true;\n                            batch.push(item);\n                            if (batch.length >= batchSize) {\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                return batch;\n            }, this));\n    } else {\n        return PromisePolyfill.resolve(batch);\n    }\n};\n\n/**\n * Remove items with matching 'id' from array (immutably)\n * also remove any item without a valid id (e.g., malformed\n * storage entries).\n */\nvar filterOutIDsAndInvalid = function (items, idSet) {\n    var filteredItems = [];\n    _.each(items, function (item) {\n        if (item['id'] && !idSet[item['id']]) {\n            filteredItems.push(item);\n        }\n    });\n    return filteredItems;\n};\n\n/**\n * Remove items with matching IDs from both in-memory queue\n * and persisted queue\n */\nRequestQueue.prototype.removeItemsByID = function (ids) {\n    var idSet = {}; // poor man's Set\n    _.each(ids, function (id) {\n        idSet[id] = true;\n    });\n\n    this.memQueue = filterOutIDsAndInvalid(this.memQueue, idSet);\n    if (!this.usePersistence) {\n        return PromisePolyfill.resolve(true);\n    } else {\n        var removeFromStorage = _.bind(function () {\n            return this.ensureInit()\n                .then(_.bind(function () {\n                    return this.readFromStorage();\n                }, this))\n                .then(_.bind(function (storedQueue) {\n                    storedQueue = filterOutIDsAndInvalid(storedQueue, idSet);\n                    return this.saveToStorage(storedQueue);\n                }, this))\n                .then(_.bind(function () {\n                    return this.readFromStorage();\n                }, this))\n                .then(_.bind(function (storedQueue) {\n                    // an extra check: did storage report success but somehow\n                    // the items are still there?\n                    for (var i = 0; i < storedQueue.length; i++) {\n                        var item = storedQueue[i];\n                        if (item['id'] && !!idSet[item['id']]) {\n                            throw new Error('Item not removed from storage');\n                        }\n                    }\n                    return true;\n                }, this))\n                .catch(_.bind(function (err) {\n                    this.reportError('Error removing items', err, ids);\n                    return false;\n                }, this));\n        }, this);\n\n        return this.lock\n            .withLock(removeFromStorage, this.pid)\n            .catch(_.bind(function (err) {\n                this.reportError('Error acquiring storage lock', err);\n                if (!localStorageSupported(this.lock.storage, true)) {\n                    // Looks like localStorage writes have stopped working sometime after\n                    // initialization (probably full), and so nobody can acquire locks\n                    // anymore. Consider it temporarily safe to remove items without the\n                    // lock, since nobody's writing successfully anyway.\n                    return removeFromStorage()\n                        .then(_.bind(function (success) {\n                            if (!success) {\n                                // OK, we couldn't even write out the smaller queue. Try clearing it\n                                // entirely.\n                                return this.queueStorage.removeItem(this.storageKey).then(function () {\n                                    return success;\n                                });\n                            }\n                            return success;\n                        }, this))\n                        .catch(_.bind(function (err) {\n                            this.reportError('Error clearing queue', err);\n                            return false;\n                        }, this));\n                } else {\n                    return false;\n                }\n            }, this));\n    }\n};\n\n// internal helper for RequestQueue.updatePayloads\nvar updatePayloads = function (existingItems, itemsToUpdate) {\n    var newItems = [];\n    _.each(existingItems, function (item) {\n        var id = item['id'];\n        if (id in itemsToUpdate) {\n            var newPayload = itemsToUpdate[id];\n            if (newPayload !== null) {\n                item['payload'] = newPayload;\n                newItems.push(item);\n            }\n        } else {\n            // no update\n            newItems.push(item);\n        }\n    });\n    return newItems;\n};\n\n/**\n * Update payloads of given items in both in-memory queue and\n * persisted queue. Items set to null are removed from queues.\n */\nRequestQueue.prototype.updatePayloads = function (itemsToUpdate) {\n    this.memQueue = updatePayloads(this.memQueue, itemsToUpdate);\n    if (!this.usePersistence) {\n        return PromisePolyfill.resolve(true);\n    } else {\n        return this.lock\n            .withLock(_.bind(function lockAcquired() {\n                return this.ensureInit()\n                    .then(_.bind(function () {\n                        return this.readFromStorage();\n                    }, this))\n                    .then(_.bind(function (storedQueue) {\n                        storedQueue = updatePayloads(storedQueue, itemsToUpdate);\n                        return this.saveToStorage(storedQueue);\n                    }, this))\n                    .catch(_.bind(function (err) {\n                        this.reportError('Error updating items', itemsToUpdate, err);\n                        return false;\n                    }, this));\n            }, this), this.pid)\n            .catch(_.bind(function (err) {\n                this.reportError('Error acquiring storage lock', err);\n                return false;\n            }, this));\n    }\n};\n\n/**\n * Read and parse items array from localStorage entry, handling\n * malformed/missing data if necessary.\n */\nRequestQueue.prototype.readFromStorage = function () {\n    return this.ensureInit()\n        .then(_.bind(function () {\n            return this.queueStorage.getItem(this.storageKey);\n        }, this))\n        .then(_.bind(function (storageEntry) {\n            if (storageEntry) {\n                if (!_.isArray(storageEntry)) {\n                    this.reportError('Invalid storage entry:', storageEntry);\n                    storageEntry = null;\n                }\n            }\n            return storageEntry || [];\n        }, this))\n        .catch(_.bind(function (err) {\n            this.reportError('Error retrieving queue', err);\n            return [];\n        }, this));\n};\n\n/**\n * Serialize the given items array to localStorage.\n */\nRequestQueue.prototype.saveToStorage = function (queue) {\n    return this.ensureInit()\n        .then(_.bind(function () {\n            return this.queueStorage.setItem(this.storageKey, queue);\n        }, this))\n        .then(function () {\n            return true;\n        })\n        .catch(_.bind(function (err) {\n            this.reportError('Error saving queue', err);\n            return false;\n        }, this));\n};\n\n/**\n * Clear out queues (memory and localStorage).\n */\nRequestQueue.prototype.clear = function () {\n    this.memQueue = [];\n\n    if (this.usePersistence) {\n        return this.ensureInit()\n            .then(_.bind(function () {\n                return this.queueStorage.removeItem(this.storageKey);\n            }, this));\n    } else {\n        return PromisePolyfill.resolve();\n    }\n};\n\n// maximum interval between request retries after exponential backoff\nvar MAX_RETRY_INTERVAL_MS = 10 * 60 * 1000; // 10 minutes\n\nvar logger$4 = console_with_prefix('batch');\n\n/**\n * RequestBatcher: manages the queueing, flushing, retry etc of requests of one\n * type (events, people, groups).\n * Uses RequestQueue to manage the backing store.\n * @constructor\n */\nvar RequestBatcher = function(storageKey, options) {\n    this.errorReporter = options.errorReporter;\n    this.queue = new RequestQueue(storageKey, {\n        errorReporter: _.bind(this.reportError, this),\n        queueStorage: options.queueStorage,\n        sharedLockStorage: options.sharedLockStorage,\n        sharedLockTimeoutMS: options.sharedLockTimeoutMS,\n        usePersistence: options.usePersistence,\n        enqueueThrottleMs: options.enqueueThrottleMs\n    });\n\n    this.libConfig = options.libConfig;\n    this.sendRequest = options.sendRequestFunc;\n    this.beforeSendHook = options.beforeSendHook;\n    this.stopAllBatching = options.stopAllBatchingFunc;\n\n    // seed variable batch size + flush interval with configured values\n    this.batchSize = this.libConfig['batch_size'];\n    this.flushInterval = this.libConfig['batch_flush_interval_ms'];\n\n    this.stopped = !this.libConfig['batch_autostart'];\n    this.consecutiveRemovalFailures = 0;\n\n    // extra client-side dedupe\n    this.itemIdsSentSuccessfully = {};\n\n    // Make the flush occur at the interval specified by flushIntervalMs, default behavior will attempt consecutive flushes\n    // as long as the queue is not empty. This is useful for high-frequency events like Session Replay where we might end up\n    // in a request loop and get ratelimited by the server.\n    this.flushOnlyOnInterval = options.flushOnlyOnInterval || false;\n\n    this._flushPromise = null;\n};\n\n/**\n * Add one item to queue.\n */\nRequestBatcher.prototype.enqueue = function(item) {\n    return this.queue.enqueue(item, this.flushInterval);\n};\n\n/**\n * Start flushing batches at the configured time interval. Must call\n * this method upon SDK init in order to send anything over the network.\n */\nRequestBatcher.prototype.start = function() {\n    this.stopped = false;\n    this.consecutiveRemovalFailures = 0;\n    return this.flush();\n};\n\n/**\n * Stop flushing batches. Can be restarted by calling start().\n */\nRequestBatcher.prototype.stop = function() {\n    this.stopped = true;\n    if (this.timeoutID) {\n        clearTimeout(this.timeoutID);\n        this.timeoutID = null;\n    }\n};\n\n/**\n * Clear out queue.\n */\nRequestBatcher.prototype.clear = function() {\n    return this.queue.clear();\n};\n\n/**\n * Restore batch size configuration to whatever is set in the main SDK.\n */\nRequestBatcher.prototype.resetBatchSize = function() {\n    this.batchSize = this.libConfig['batch_size'];\n};\n\n/**\n * Restore flush interval time configuration to whatever is set in the main SDK.\n */\nRequestBatcher.prototype.resetFlush = function() {\n    this.scheduleFlush(this.libConfig['batch_flush_interval_ms']);\n};\n\n/**\n * Schedule the next flush in the given number of milliseconds.\n */\nRequestBatcher.prototype.scheduleFlush = function(flushMS) {\n    this.flushInterval = flushMS;\n    if (!this.stopped) { // don't schedule anymore if batching has been stopped\n        this.timeoutID = setTimeout(_.bind(function() {\n            if (!this.stopped) {\n                this._flushPromise = this.flush();\n            }\n        }, this), this.flushInterval);\n    }\n};\n\n/**\n * Send a request using the sendRequest callback, but promisified.\n * TODO: sendRequest should be promisified in the first place.\n */\nRequestBatcher.prototype.sendRequestPromise = function(data, options) {\n    return new PromisePolyfill(_.bind(function(resolve) {\n        this.sendRequest(data, options, resolve);\n    }, this));\n};\n\n\n/**\n * Flush one batch to network. Depending on success/failure modes, it will either\n * remove the batch from the queue or leave it in for retry, and schedule the next\n * flush. In cases of most network or API failures, it will back off exponentially\n * when retrying.\n * @param {Object} [options]\n * @param {boolean} [options.sendBeacon] - whether to send batch with\n * navigator.sendBeacon (only useful for sending batches before page unloads, as\n * sendBeacon offers no callbacks or status indications)\n */\nRequestBatcher.prototype.flush = function(options) {\n    if (this.requestInProgress) {\n        logger$4.log('Flush: Request already in progress');\n        return PromisePolyfill.resolve();\n    }\n\n    this.requestInProgress = true;\n\n    options = options || {};\n    var timeoutMS = this.libConfig['batch_request_timeout_ms'];\n    var startTime = new Date().getTime();\n    var currentBatchSize = this.batchSize;\n\n    return this.queue.fillBatch(currentBatchSize)\n        .then(_.bind(function(batch) {\n\n            // if there's more items in the queue than the batch size, attempt\n            // to flush again after the current batch is done.\n            var attemptSecondaryFlush = batch.length === currentBatchSize;\n            var dataForRequest = [];\n            var transformedItems = {};\n            _.each(batch, function(item) {\n                var payload = item['payload'];\n                if (this.beforeSendHook && !item.orphaned) {\n                    payload = this.beforeSendHook(payload);\n                }\n                if (payload) {\n                    // mp_sent_by_lib_version prop captures which lib version actually\n                    // sends each event (regardless of which version originally queued\n                    // it for sending)\n                    if (payload['event'] && payload['properties']) {\n                        payload['properties'] = _.extend(\n                            {},\n                            payload['properties'],\n                            {'mp_sent_by_lib_version': Config.LIB_VERSION}\n                        );\n                    }\n                    var addPayload = true;\n                    var itemId = item['id'];\n                    if (itemId) {\n                        if ((this.itemIdsSentSuccessfully[itemId] || 0) > 5) {\n                            this.reportError('[dupe] item ID sent too many times, not sending', {\n                                item: item,\n                                batchSize: batch.length,\n                                timesSent: this.itemIdsSentSuccessfully[itemId]\n                            });\n                            addPayload = false;\n                        }\n                    } else {\n                        this.reportError('[dupe] found item with no ID', {item: item});\n                    }\n\n                    if (addPayload) {\n                        dataForRequest.push(payload);\n                    }\n                }\n                transformedItems[item['id']] = payload;\n            }, this);\n\n            if (dataForRequest.length < 1) {\n                this.requestInProgress = false;\n                this.resetFlush();\n                return PromisePolyfill.resolve(); // nothing to do\n            }\n\n            var removeItemsFromQueue = _.bind(function () {\n                return this.queue\n                    .removeItemsByID(\n                        _.map(batch, function (item) {\n                            return item['id'];\n                        })\n                    )\n                    .then(_.bind(function (succeeded) {\n                        // client-side dedupe\n                        _.each(batch, _.bind(function(item) {\n                            var itemId = item['id'];\n                            if (itemId) {\n                                this.itemIdsSentSuccessfully[itemId] = this.itemIdsSentSuccessfully[itemId] || 0;\n                                this.itemIdsSentSuccessfully[itemId]++;\n                                if (this.itemIdsSentSuccessfully[itemId] > 5) {\n                                    this.reportError('[dupe] item ID sent too many times', {\n                                        item: item,\n                                        batchSize: batch.length,\n                                        timesSent: this.itemIdsSentSuccessfully[itemId]\n                                    });\n                                }\n                            } else {\n                                this.reportError('[dupe] found item with no ID while removing', {item: item});\n                            }\n                        }, this));\n\n                        if (succeeded) {\n                            this.consecutiveRemovalFailures = 0;\n                            if (this.flushOnlyOnInterval && !attemptSecondaryFlush) {\n                                this.resetFlush(); // schedule next batch with a delay\n                                return PromisePolyfill.resolve();\n                            } else {\n                                return this.flush(); // handle next batch if the queue isn't empty\n                            }\n                        } else {\n                            if (++this.consecutiveRemovalFailures > 5) {\n                                this.reportError('Too many queue failures; disabling batching system.');\n                                this.stopAllBatching();\n                            } else {\n                                this.resetFlush();\n                            }\n                            return PromisePolyfill.resolve();\n                        }\n                    }, this));\n            }, this);\n\n            var batchSendCallback = _.bind(function(res) {\n                this.requestInProgress = false;\n\n                try {\n\n                    // handle API response in a try-catch to make sure we can reset the\n                    // flush operation if something goes wrong\n\n                    if (options.unloading) {\n                        // update persisted data to include hook transformations\n                        return this.queue.updatePayloads(transformedItems);\n                    } else if (\n                        _.isObject(res) &&\n                            res.error === 'timeout' &&\n                            new Date().getTime() - startTime >= timeoutMS\n                    ) {\n                        this.reportError('Network timeout; retrying');\n                        return this.flush();\n                    } else if (\n                        _.isObject(res) &&\n                            (\n                                res.httpStatusCode >= 500\n                                || res.httpStatusCode === 429\n                                || (res.httpStatusCode <= 0 && !isOnline())\n                                || res.error === 'timeout'\n                            )\n                    ) {\n                        // network or API error, or 429 Too Many Requests, retry\n                        var retryMS = this.flushInterval * 2;\n                        if (res.retryAfter) {\n                            retryMS = (parseInt(res.retryAfter, 10) * 1000) || retryMS;\n                        }\n                        retryMS = Math.min(MAX_RETRY_INTERVAL_MS, retryMS);\n                        this.reportError('Error; retry in ' + retryMS + ' ms');\n                        this.scheduleFlush(retryMS);\n                        return PromisePolyfill.resolve();\n                    } else if (_.isObject(res) && res.httpStatusCode === 413) {\n                        // 413 Payload Too Large\n                        if (batch.length > 1) {\n                            var halvedBatchSize = Math.max(1, Math.floor(currentBatchSize / 2));\n                            this.batchSize = Math.min(this.batchSize, halvedBatchSize, batch.length - 1);\n                            this.reportError('413 response; reducing batch size to ' + this.batchSize);\n                            this.resetFlush();\n                            return PromisePolyfill.resolve();\n                        } else {\n                            this.reportError('Single-event request too large; dropping', batch);\n                            this.resetBatchSize();\n                            return removeItemsFromQueue();\n                        }\n                    } else {\n                        // successful network request+response; remove each item in batch from queue\n                        // (even if it was e.g. a 400, in which case retrying won't help)\n                        return removeItemsFromQueue();\n                    }\n                } catch(err) {\n                    this.reportError('Error handling API response', err);\n                    this.resetFlush();\n                }\n            }, this);\n            var requestOptions = {\n                method: 'POST',\n                verbose: true,\n                ignore_json_errors: true, // eslint-disable-line camelcase\n                timeout_ms: timeoutMS // eslint-disable-line camelcase\n            };\n            if (options.unloading) {\n                requestOptions.transport = 'sendBeacon';\n            }\n            logger$4.log('MIXPANEL REQUEST:', dataForRequest);\n            return this.sendRequestPromise(dataForRequest, requestOptions).then(batchSendCallback);\n        }, this))\n        .catch(_.bind(function(err) {\n            this.reportError('Error flushing request queue', err);\n            this.resetFlush();\n        }, this));\n};\n\n/**\n * Log error to global logger and optional user-defined logger.\n */\nRequestBatcher.prototype.reportError = function(msg, err) {\n    logger$4.error.apply(logger$4.error, arguments);\n    if (this.errorReporter) {\n        try {\n            if (!(err instanceof Error)) {\n                err = new Error(msg);\n            }\n            this.errorReporter(msg, err);\n        } catch(err) {\n            logger$4.error(err);\n        }\n    }\n};\n\n/**\n * @param {import('./session-recording').SerializedRecording} serializedRecording\n * @returns {boolean}\n */\nvar isRecordingExpired = function(serializedRecording) {\n    var now = Date.now();\n    return !serializedRecording || now > serializedRecording['maxExpires'] || now > serializedRecording['idleExpires'];\n};\n\nvar RECORD_ENQUEUE_THROTTLE_MS = 250;\n\nvar logger$3 = console_with_prefix('recorder');\nvar CompressionStream = win['CompressionStream'];\n\nvar RECORDER_BATCHER_LIB_CONFIG = {\n    'batch_size': 1000,\n    'batch_flush_interval_ms': 10 * 1000,\n    'batch_request_timeout_ms': 90 * 1000,\n    'batch_autostart': true\n};\n\nvar ACTIVE_SOURCES = new Set([\n    IncrementalSource.MouseMove,\n    IncrementalSource.MouseInteraction,\n    IncrementalSource.Scroll,\n    IncrementalSource.ViewportResize,\n    IncrementalSource.Input,\n    IncrementalSource.TouchMove,\n    IncrementalSource.MediaInteraction,\n    IncrementalSource.Drag,\n    IncrementalSource.Selection,\n]);\n\nfunction isUserEvent(ev) {\n    return ev.type === EventType.IncrementalSnapshot && ACTIVE_SOURCES.has(ev.data.source);\n}\n\n/**\n * @typedef {Object} SerializedRecording\n * @property {number} idleExpires\n * @property {number} maxExpires\n * @property {number} replayStartTime\n * @property {number} lastEventTimestamp\n * @property {number} seqNo\n * @property {string} batchStartUrl\n * @property {string} replayId\n * @property {string} tabId\n * @property {string} replayStartUrl\n */\n\n/**\n * @typedef {Object} SessionRecordingOptions\n * @property {Object} [options.mixpanelInstance] - reference to the core MixpanelLib\n * @property {String} [options.replayId] - unique uuid for a single replay\n * @property {Function} [options.onIdleTimeout] - callback when a recording reaches idle timeout\n * @property {Function} [options.onMaxLengthReached] - callback when a recording reaches its maximum length\n * @property {Function} [options.rrwebRecord] - rrweb's `record` function\n * @property {Function} [options.onBatchSent] - callback when a batch of events is sent to the server\n * @property {Storage} [options.sharedLockStorage] - optional storage for shared lock, used for test dependency injection\n * optional properties for deserialization:\n * @property {number} idleExpires\n * @property {number} maxExpires\n * @property {number} replayStartTime\n * @property {number} lastEventTimestamp - the unix timestamp of the last recorded event from rrweb\n * @property {number} seqNo\n * @property {string} batchStartUrl\n * @property {string} replayStartUrl\n */\n\n/**\n * @typedef {Object} UserIdInfo\n * @property {string} distinct_id\n * @property {string} user_id\n * @property {string} device_id\n */\n\n\n/**\n * This class encapsulates a single session recording and its lifecycle.\n * @param {SessionRecordingOptions} options\n */\nvar SessionRecording = function(options) {\n    this._mixpanel = options.mixpanelInstance;\n    this._onIdleTimeout = options.onIdleTimeout || NOOP_FUNC;\n    this._onMaxLengthReached = options.onMaxLengthReached || NOOP_FUNC;\n    this._onBatchSent = options.onBatchSent || NOOP_FUNC;\n    this._rrwebRecord = options.rrwebRecord || null;\n\n    // internal rrweb stopRecording function\n    this._stopRecording = null;\n    this.replayId = options.replayId;\n\n    this.batchStartUrl = options.batchStartUrl || null;\n    this.replayStartUrl = options.replayStartUrl || null;\n    this.idleExpires = options.idleExpires || null;\n    this.maxExpires = options.maxExpires || null;\n    this.replayStartTime = options.replayStartTime || null;\n    this.lastEventTimestamp = options.lastEventTimestamp || null;\n    this.seqNo = options.seqNo || 0;\n\n    this.idleTimeoutId = null;\n    this.maxTimeoutId = null;\n\n    this.recordMaxMs = MAX_RECORDING_MS;\n    this.recordMinMs = 0;\n\n    // disable persistence if localStorage is not supported\n    // request-queue will automatically disable persistence if indexedDB fails to initialize\n    var usePersistence = localStorageSupported(options.sharedLockStorage, true) && !this.getConfig('disable_persistence');\n\n    // each replay has its own batcher key to avoid conflicts between rrweb events of different recordings\n    this.batcherKey = '__mprec_' + this.getConfig('name') + '_' + this.getConfig('token') + '_' + this.replayId;\n    this.queueStorage = new IDBStorageWrapper(RECORDING_EVENTS_STORE_NAME);\n    this.batcher = new RequestBatcher(this.batcherKey, {\n        errorReporter: this.reportError.bind(this),\n        flushOnlyOnInterval: true,\n        libConfig: RECORDER_BATCHER_LIB_CONFIG,\n        sendRequestFunc: this.flushEventsWithOptOut.bind(this),\n        queueStorage: this.queueStorage,\n        sharedLockStorage: options.sharedLockStorage,\n        usePersistence: usePersistence,\n        stopAllBatchingFunc: this.stopRecording.bind(this),\n\n        // increased throttle and shared lock timeout because recording events are very high frequency.\n        // this will minimize the amount of lock contention between enqueued events.\n        // for session recordings there is a lock for each tab anyway, so there's no risk of deadlock between tabs.\n        enqueueThrottleMs: RECORD_ENQUEUE_THROTTLE_MS,\n        sharedLockTimeoutMS: 10 * 1000,\n    });\n};\n\n/**\n * @returns {UserIdInfo}\n */\nSessionRecording.prototype.getUserIdInfo = function () {\n    if (this.finalFlushUserIdInfo) {\n        return this.finalFlushUserIdInfo;\n    }\n\n    var userIdInfo = {\n        'distinct_id': String(this._mixpanel.get_distinct_id()),\n    };\n\n    // send ID management props if they exist\n    var deviceId = this._mixpanel.get_property('$device_id');\n    if (deviceId) {\n        userIdInfo['$device_id'] = deviceId;\n    }\n    var userId = this._mixpanel.get_property('$user_id');\n    if (userId) {\n        userIdInfo['$user_id'] = userId;\n    }\n    return userIdInfo;\n};\n\nSessionRecording.prototype.unloadPersistedData = function () {\n    this.batcher.stop();\n\n    return this.queueStorage.init().catch(function () {\n        this.reportError('Error initializing IndexedDB storage for unloading persisted data.');\n    }.bind(this)).then(function () {\n        // if the recording is too short, just delete any stored events without flushing\n        if (this.getDurationMs() < this._getRecordMinMs()) {\n            return this.queueStorage.removeItem(this.batcherKey);\n        }\n\n        return this.batcher.flush()\n            .then(function () {\n                return this.queueStorage.removeItem(this.batcherKey);\n            }.bind(this));\n    }.bind(this));\n};\n\nSessionRecording.prototype.getConfig = function(configVar) {\n    return this._mixpanel.get_config(configVar);\n};\n\n// Alias for getConfig, used by the common addOptOutCheckMixpanelLib function which\n// reaches into this class instance and expects the snake case version of the function.\n// eslint-disable-next-line camelcase\nSessionRecording.prototype.get_config = function(configVar) {\n    return this.getConfig(configVar);\n};\n\nSessionRecording.prototype.startRecording = function (shouldStopBatcher) {\n    if (this._rrwebRecord === null) {\n        this.reportError('rrweb record function not provided. ');\n        return;\n    }\n\n    if (this._stopRecording !== null) {\n        logger$3.log('Recording already in progress, skipping startRecording.');\n        return;\n    }\n\n    this.recordMaxMs = this.getConfig('record_max_ms');\n    if (this.recordMaxMs > MAX_RECORDING_MS) {\n        this.recordMaxMs = MAX_RECORDING_MS;\n        logger$3.critical('record_max_ms cannot be greater than ' + MAX_RECORDING_MS + 'ms. Capping value.');\n    }\n\n    if (!this.maxExpires) {\n        this.maxExpires = new Date().getTime() + this.recordMaxMs;\n    }\n\n    this.recordMinMs = this._getRecordMinMs();\n\n    if (!this.replayStartTime) {\n        this.replayStartTime = new Date().getTime();\n        this.batchStartUrl = _.info.currentUrl();\n        this.replayStartUrl = _.info.currentUrl();\n    }\n\n    if (shouldStopBatcher || this.recordMinMs > 0) {\n        // the primary case for shouldStopBatcher is when we're starting recording after a reset\n        // and don't want to send anything over the network until there's\n        // actual user activity\n        // this also applies if the minimum recording length has not been hit yet\n        // so that we don't send data until we know the recording will be long enough\n        this.batcher.stop();\n    } else {\n        this.batcher.start();\n    }\n\n    var resetIdleTimeout = function () {\n        clearTimeout(this.idleTimeoutId);\n        var idleTimeoutMs = this.getConfig('record_idle_timeout_ms');\n        this.idleTimeoutId = setTimeout(this._onIdleTimeout, idleTimeoutMs);\n        this.idleExpires = new Date().getTime() + idleTimeoutMs;\n    }.bind(this);\n    resetIdleTimeout();\n\n    var blockSelector = this.getConfig('record_block_selector');\n    if (blockSelector === '' || blockSelector === null) {\n        blockSelector = undefined;\n    }\n\n    try {\n        this._stopRecording = this._rrwebRecord({\n            'emit': function (ev) {\n                if (this.idleExpires && this.idleExpires < ev.timestamp) {\n                    this._onIdleTimeout();\n                    return;\n                }\n                if (isUserEvent(ev)) {\n                    if (this.batcher.stopped && new Date().getTime() - this.replayStartTime >= this.recordMinMs) {\n                        // start flushing again after user activity\n                        this.batcher.start();\n                    }\n                    resetIdleTimeout();\n                }\n                // promise only used to await during tests\n                this.__enqueuePromise = this.batcher.enqueue(ev);\n\n                // Capture the timestamp of the last event for duration calculation.\n                if (this.lastEventTimestamp === null || ev.timestamp > this.lastEventTimestamp) {\n                    this.lastEventTimestamp = ev.timestamp;\n                }\n            }.bind(this),\n            'blockClass': this.getConfig('record_block_class'),\n            'blockSelector': blockSelector,\n            'collectFonts': this.getConfig('record_collect_fonts'),\n            'dataURLOptions': { // canvas image options (https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL)\n                'type': 'image/webp',\n                'quality': 0.6\n            },\n            'maskAllInputs': true,\n            'maskTextClass': this.getConfig('record_mask_text_class'),\n            'maskTextSelector': this.getConfig('record_mask_text_selector'),\n            'recordCanvas': this.getConfig('record_canvas'),\n            'sampling': {\n                'canvas': 15\n            },\n            'plugins': this.getConfig('record_console') ? [\n                getRecordConsolePlugin({\n                    stringifyOptions: {\n                        stringLengthLimit: 1000,\n                        numOfKeysLimit: 50,\n                        depthOfLimit: 2\n                    }\n                })\n            ] : []\n        });\n    } catch (err) {\n        this.reportError('Unexpected error when starting rrweb recording.', err);\n    }\n\n    if (typeof this._stopRecording !== 'function') {\n        this.reportError('rrweb failed to start, skipping this recording.');\n        this._stopRecording = null;\n        this.stopRecording(); // stop batcher looping and any timeouts\n        return;\n    }\n\n    var maxTimeoutMs = this.maxExpires - new Date().getTime();\n    this.maxTimeoutId = setTimeout(this._onMaxLengthReached.bind(this), maxTimeoutMs);\n};\n\nSessionRecording.prototype.stopRecording = function (skipFlush) {\n    // store the user ID info in case this is getting called in mixpanel.reset()\n    this.finalFlushUserIdInfo = this.getUserIdInfo();\n\n    if (!this.isRrwebStopped()) {\n        try {\n            this._stopRecording();\n        } catch (err) {\n            this.reportError('Error with rrweb stopRecording', err);\n        }\n        this._stopRecording = null;\n    }\n\n    var flushPromise;\n    if (this.batcher.stopped) {\n        // never got user activity to flush after reset, so just clear the batcher\n        flushPromise = this.batcher.clear();\n    } else if (!skipFlush) {\n        // flush any remaining events from running batcher\n        flushPromise = this.batcher.flush();\n    }\n    this.batcher.stop();\n\n    clearTimeout(this.idleTimeoutId);\n    clearTimeout(this.maxTimeoutId);\n    return flushPromise;\n};\n\nSessionRecording.prototype.isRrwebStopped = function () {\n    return this._stopRecording === null;\n};\n\n\n/**\n * Flushes the current batch of events to the server, but passes an opt-out callback to make sure\n * we stop recording and dump any queued events if the user has opted out.\n */\nSessionRecording.prototype.flushEventsWithOptOut = function (data, options, cb) {\n    var onOptOut = function (code) {\n        // addOptOutCheckMixpanelLib invokes this function with code=0 when the user has opted out\n        if (code === 0) {\n            this.stopRecording();\n            cb({error: 'Tracking has been opted out, stopping recording.'});\n        }\n    }.bind(this);\n\n    this._flushEvents(data, options, cb, onOptOut);\n};\n\n/**\n * @returns {SerializedRecording}\n */\nSessionRecording.prototype.serialize = function () {\n    // don't break if mixpanel instance was destroyed at some point\n    var tabId;\n    try {\n        tabId = this._mixpanel.get_tab_id();\n    } catch (e) {\n        this.reportError('Error getting tab ID for serialization ', e);\n        tabId = null;\n    }\n\n    return {\n        'replayId': this.replayId,\n        'seqNo': this.seqNo,\n        'replayStartTime': this.replayStartTime,\n        'batchStartUrl': this.batchStartUrl,\n        'replayStartUrl': this.replayStartUrl,\n        'lastEventTimestamp': this.lastEventTimestamp,\n        'idleExpires': this.idleExpires,\n        'maxExpires': this.maxExpires,\n        'tabId': tabId,\n    };\n};\n\n\n/**\n * @static\n * @param {SerializedRecording} serializedRecording\n * @param {SessionRecordingOptions} options\n * @returns {SessionRecording}\n */\nSessionRecording.deserialize = function (serializedRecording, options) {\n    var recording = new SessionRecording(_.extend({}, options, {\n        replayId: serializedRecording['replayId'],\n        batchStartUrl: serializedRecording['batchStartUrl'],\n        replayStartUrl: serializedRecording['replayStartUrl'],\n        idleExpires: serializedRecording['idleExpires'],\n        maxExpires: serializedRecording['maxExpires'],\n        replayStartTime: serializedRecording['replayStartTime'],\n        lastEventTimestamp: serializedRecording['lastEventTimestamp'],\n        seqNo: serializedRecording['seqNo'],\n        sharedLockStorage: options.sharedLockStorage,\n    }));\n\n    return recording;\n};\n\nSessionRecording.prototype._sendRequest = function(currentReplayId, reqParams, reqBody, callback) {\n    var onSuccess = function (response, responseBody) {\n        // Update batch specific props only if the request was successful to guarantee ordering.\n        // RequestBatcher will always flush the next batch after the previous one succeeds.\n        // extra check to see if the replay ID has changed so that we don't increment the seqNo on the wrong replay\n        if (response.status === 200 && this.replayId === currentReplayId) {\n            this.seqNo++;\n            this.batchStartUrl = _.info.currentUrl();\n        }\n\n        this._onBatchSent();\n        callback({\n            status: 0,\n            httpStatusCode: response.status,\n            responseBody: responseBody,\n            retryAfter: response.headers.get('Retry-After')\n        });\n    }.bind(this);\n    var apiHost = (this._mixpanel.get_api_host && this._mixpanel.get_api_host('record')) || this.getConfig('api_host');\n    win['fetch'](apiHost + '/' + this.getConfig('api_routes')['record'] + '?' + new URLSearchParams(reqParams), {\n        'method': 'POST',\n        'headers': {\n            'Authorization': 'Basic ' + btoa(this.getConfig('token') + ':'),\n            'Content-Type': 'application/octet-stream'\n        },\n        'body': reqBody,\n    }).then(function (response) {\n        response.json().then(function (responseBody) {\n            onSuccess(response, responseBody);\n        }).catch(function (error) {\n            callback({error: error});\n        });\n    }).catch(function (error) {\n        callback({error: error, httpStatusCode: 0});\n    });\n};\n\nSessionRecording.prototype._flushEvents = addOptOutCheckMixpanelLib(function (data, options, callback) {\n    var numEvents = data.length;\n\n    if (numEvents > 0) {\n        var replayId = this.replayId;\n\n        // each rrweb event has a timestamp - leverage those to get time properties\n        var batchStartTime = Infinity;\n        var batchEndTime = -Infinity;\n        var hasFullSnapshot = false;\n        for (var i = 0; i < numEvents; i++) {\n            batchStartTime = Math.min(batchStartTime, data[i].timestamp);\n            batchEndTime = Math.max(batchEndTime, data[i].timestamp);\n            if (data[i].type === EventType.FullSnapshot) {\n                hasFullSnapshot = true;\n            }\n        }\n\n        if (this.seqNo === 0) {\n            if (!hasFullSnapshot) {\n                callback({error: 'First batch does not contain a full snapshot. Aborting recording.'});\n                this.stopRecording(true);\n                return;\n            }\n            this.replayStartTime = batchStartTime;\n        } else if (!this.replayStartTime) {\n            this.reportError('Replay start time not set but seqNo is not 0. Using current batch start time as a fallback.');\n            this.replayStartTime = batchStartTime;\n        }\n\n        var replayLengthMs = batchEndTime - this.replayStartTime;\n\n        var reqParams = {\n            '$current_url': this.batchStartUrl,\n            '$lib_version': Config.LIB_VERSION,\n            'batch_start_time': batchStartTime / 1000,\n            'mp_lib': 'web',\n            'replay_id': replayId,\n            'replay_length_ms': replayLengthMs,\n            'replay_start_time': this.replayStartTime / 1000,\n            'replay_start_url': this.replayStartUrl,\n            'seq': this.seqNo\n        };\n        var eventsJson = JSON.stringify(data);\n        Object.assign(reqParams, this.getUserIdInfo());\n\n        if (canUseCompressionStream(userAgent, navigator.vendor, windowOpera)) {\n            var jsonStream = new Blob([eventsJson], {type: 'application/json'}).stream();\n            var gzipStream = jsonStream.pipeThrough(new CompressionStream('gzip'));\n            new Response(gzipStream)\n                .blob()\n                .then(function(compressedBlob) {\n                    reqParams['format'] = 'gzip';\n                    this._sendRequest(replayId, reqParams, compressedBlob, callback);\n                }.bind(this));\n        } else {\n            reqParams['format'] = 'body';\n            this._sendRequest(replayId, reqParams, eventsJson, callback);\n        }\n    }\n});\n\n\nSessionRecording.prototype.reportError = function(msg, err) {\n    logger$3.error.apply(logger$3.error, arguments);\n    try {\n        if (!err && !(msg instanceof Error)) {\n            msg = new Error(msg);\n        }\n        this.getConfig('error_reporter')(msg, err);\n    } catch(err) {\n        logger$3.error(err);\n    }\n};\n\n/**\n * Calculates the duration of the recording in milliseconds, based on the start time and time of last recorded event.\n * @returns {number} The duration of the recording in milliseconds. Returns 0 if recording hasn't started.\n */\nSessionRecording.prototype.getDurationMs = function() {\n    if (this.replayStartTime === null) {\n        return 0;\n    }\n\n    // If the recording has no events, assume it is in progress and use the current time as the end time.\n    if (this.lastEventTimestamp === null) {\n        return new Date().getTime() - this.replayStartTime;\n    }\n\n    return this.lastEventTimestamp - this.replayStartTime;\n};\n\n/**\n * Lazily loads the minimum recording length config in milliseconds, respecting the maximum limit.\n * @returns {number} The minimum recording length in milliseconds.\n */\nSessionRecording.prototype._getRecordMinMs = function() {\n    var configValue = this.getConfig('record_min_ms');\n\n    if (configValue > MAX_VALUE_FOR_MIN_RECORDING_MS) {\n        logger$3.critical('record_min_ms cannot be greater than ' + MAX_VALUE_FOR_MIN_RECORDING_MS + 'ms. Capping value.');\n        return MAX_VALUE_FOR_MIN_RECORDING_MS;\n    }\n\n    return configValue;\n};\n\n/**\n * Module for handling the storage and retrieval of recording metadata as well as any active recordings.\n * Makes sure that only one tab can be recording at a time.\n */\nvar RecordingRegistry = function (options) {\n    /** @type {IDBStorageWrapper} */\n    this.idb = new IDBStorageWrapper(RECORDING_REGISTRY_STORE_NAME);\n    this.errorReporter = options.errorReporter;\n    this.mixpanelInstance = options.mixpanelInstance;\n    this.sharedLockStorage = options.sharedLockStorage;\n};\n\nRecordingRegistry.prototype.isPersistenceEnabled = function() {\n    return !this.mixpanelInstance.get_config('disable_persistence');\n};\n\nRecordingRegistry.prototype.handleError = function (err) {\n    this.errorReporter('IndexedDB error: ', err);\n};\n\n/**\n * @param {import('./session-recording').SerializedRecording} serializedRecording\n */\nRecordingRegistry.prototype.setActiveRecording = function (serializedRecording) {\n    if (!this.isPersistenceEnabled()) {\n        return PromisePolyfill.resolve();\n    }\n\n    var tabId = serializedRecording['tabId'];\n    if (!tabId) {\n        console.warn('No tab ID is set, cannot persist recording metadata.');\n        return PromisePolyfill.resolve();\n    }\n\n    return this.idb.init()\n        .then(function () {\n            return this.idb.setItem(tabId, serializedRecording);\n        }.bind(this))\n        .catch(this.handleError.bind(this));\n};\n\n/**\n * @returns {Promise<import('./session-recording').SerializedRecording>}\n */\nRecordingRegistry.prototype.getActiveRecording = function () {\n    if (!this.isPersistenceEnabled()) {\n        return PromisePolyfill.resolve(null);\n    }\n\n    return this.idb.init()\n        .then(function () {\n            return this.idb.getItem(this.mixpanelInstance.get_tab_id());\n        }.bind(this))\n        .then(function (serializedRecording) {\n            return isRecordingExpired(serializedRecording) ? null : serializedRecording;\n        }.bind(this))\n        .catch(this.handleError.bind(this));\n};\n\nRecordingRegistry.prototype.clearActiveRecording = function () {\n    if (this.isPersistenceEnabled()) {\n        // mark recording as expired instead of deleting it in case the page unloads mid-flush and doesn't make it to ingestion.\n        // this will ensure the next pageload will flush the remaining events, but not try to continue the recording.\n        return this.markActiveRecordingExpired();\n    } else {\n        return this.deleteActiveRecording();\n    }\n};\n\nRecordingRegistry.prototype.markActiveRecordingExpired = function () {\n    return this.getActiveRecording()\n        .then(function (serializedRecording) {\n            if (serializedRecording) {\n                serializedRecording['maxExpires'] = 0;\n                return this.setActiveRecording(serializedRecording);\n            }\n        }.bind(this))\n        .catch(this.handleError.bind(this));\n};\n\nRecordingRegistry.prototype.deleteActiveRecording = function () {\n    // avoid initializing IDB if this registry instance hasn't already written a recording\n    if (this.idb.isInitialized()) {\n        return this.idb.removeItem(this.mixpanelInstance.get_tab_id())\n            .catch(this.handleError.bind(this));\n    } else {\n        return PromisePolyfill.resolve();\n    }\n};\n\n/**\n * Flush any inactive recordings from the registry to minimize data loss.\n * The main idea here is that we can flush remaining rrweb events on the next page load if a tab is closed mid-batch.\n */\nRecordingRegistry.prototype.flushInactiveRecordings = function () {\n    if (!this.isPersistenceEnabled()) {\n        return PromisePolyfill.resolve([]);\n    }\n\n    return this.idb.init()\n        .then(function() {\n            return this.idb.getAll();\n        }.bind(this))\n        .then(function (serializedRecordings) {\n            // clean up any expired recordings from the registry, non-expired ones may be active in other tabs\n            var unloadPromises = serializedRecordings\n                .filter(function (serializedRecording) {\n                    return isRecordingExpired(serializedRecording);\n                })\n                .map(function (serializedRecording) {\n                    var sessionRecording = SessionRecording.deserialize(serializedRecording, {\n                        mixpanelInstance: this.mixpanelInstance,\n                        sharedLockStorage: this.sharedLockStorage\n                    });\n                    return sessionRecording.unloadPersistedData()\n                        .then(function () {\n                            // expired recording was successfully flushed, we can clean it up from the registry\n                            return this.idb.removeItem(serializedRecording['tabId']);\n                        }.bind(this))\n                        .catch(this.handleError.bind(this));\n                }.bind(this));\n\n            return PromisePolyfill.all(unloadPromises);\n        }.bind(this))\n        .catch(this.handleError.bind(this));\n};\n\nvar logger$2 = console_with_prefix('recorder');\n\n/**\n * Recorder API: bundles rrweb and and exposes methods to start and stop recordings.\n * @param {Object} [options.mixpanelInstance] - reference to the core MixpanelLib\n*/\nvar MixpanelRecorder = function(mixpanelInstance, rrwebRecord, sharedLockStorage) {\n    this.mixpanelInstance = mixpanelInstance;\n    this.rrwebRecord = rrwebRecord || record;\n    this.sharedLockStorage = sharedLockStorage;\n\n    /**\n     * @member {import('./registry').RecordingRegistry}\n     */\n    this.recordingRegistry = new RecordingRegistry({\n        mixpanelInstance: this.mixpanelInstance,\n        errorReporter: logger$2.error,\n        sharedLockStorage: sharedLockStorage\n    });\n    this._flushInactivePromise = this.recordingRegistry.flushInactiveRecordings();\n\n    this.activeRecording = null;\n    this.stopRecordingInProgress = false;\n};\n\nMixpanelRecorder.prototype.startRecording = function(options) {\n    options = options || {};\n    if (this.activeRecording && !this.activeRecording.isRrwebStopped()) {\n        logger$2.log('Recording already in progress, skipping startRecording.');\n        return;\n    }\n\n    var onIdleTimeout = function () {\n        logger$2.log('Idle timeout reached, restarting recording.');\n        this.resetRecording();\n    }.bind(this);\n\n    var onMaxLengthReached = function () {\n        logger$2.log('Max recording length reached, stopping recording.');\n        this.resetRecording();\n    }.bind(this);\n\n    var onBatchSent = function () {\n        this.recordingRegistry.setActiveRecording(this.activeRecording.serialize());\n        this['__flushPromise'] = this.activeRecording.batcher._flushPromise;\n    }.bind(this);\n\n    /**\n     * @type {import('./session-recording').SessionRecordingOptions}\n     */\n    var sessionRecordingOptions = {\n        mixpanelInstance: this.mixpanelInstance,\n        onBatchSent: onBatchSent,\n        onIdleTimeout: onIdleTimeout,\n        onMaxLengthReached: onMaxLengthReached,\n        replayId: _.UUID(),\n        rrwebRecord: this.rrwebRecord,\n        sharedLockStorage: this.sharedLockStorage\n    };\n\n    if (options.activeSerializedRecording) {\n        this.activeRecording = SessionRecording.deserialize(options.activeSerializedRecording, sessionRecordingOptions);\n    } else {\n        this.activeRecording = new SessionRecording(sessionRecordingOptions);\n    }\n\n    this.activeRecording.startRecording(options.shouldStopBatcher);\n    return this.recordingRegistry.setActiveRecording(this.activeRecording.serialize());\n};\n\nMixpanelRecorder.prototype.stopRecording = function() {\n    // Prevents activeSerializedRecording from being reused when stopping the recording.\n    this.stopRecordingInProgress = true;\n    return this._stopCurrentRecording(false, true).then(function() {\n        return this.recordingRegistry.clearActiveRecording();\n    }.bind(this)).then(function() {\n        this.stopRecordingInProgress = false;\n    }.bind(this));\n};\n\nMixpanelRecorder.prototype.pauseRecording = function() {\n    return this._stopCurrentRecording(false);\n};\n\nMixpanelRecorder.prototype._stopCurrentRecording = function(skipFlush, disableActiveRecording) {\n    if (this.activeRecording) {\n        var stopRecordingPromise = this.activeRecording.stopRecording(skipFlush);\n        if (disableActiveRecording) {\n            this.activeRecording = null;\n        }\n        return stopRecordingPromise;\n    }\n    return PromisePolyfill.resolve();\n};\n\nMixpanelRecorder.prototype.resumeRecording = function (startNewIfInactive) {\n    if (this.activeRecording && this.activeRecording.isRrwebStopped()) {\n        this.activeRecording.startRecording(false);\n        return PromisePolyfill.resolve(null);\n    }\n\n    return this.recordingRegistry.getActiveRecording()\n        .then(function (activeSerializedRecording) {\n            if (activeSerializedRecording && !this.stopRecordingInProgress) {\n                return this.startRecording({activeSerializedRecording: activeSerializedRecording});\n            } else if (startNewIfInactive) {\n                return this.startRecording({shouldStopBatcher: false});\n            } else {\n                logger$2.log('No resumable recording found.');\n                return null;\n            }\n        }.bind(this));\n};\n\n\nMixpanelRecorder.prototype.resetRecording = function () {\n    this.stopRecording();\n    this.startRecording({shouldStopBatcher: true});\n};\n\nMixpanelRecorder.prototype.getActiveReplayId = function () {\n    if (this.activeRecording && !this.activeRecording.isRrwebStopped()) {\n        return this.activeRecording.replayId;\n    } else {\n        return null;\n    }\n};\n\n// getter so that older mixpanel-core versions can still retrieve the replay ID\n// when pulling the latest recorder bundle from the CDN\nObject.defineProperty(MixpanelRecorder.prototype, 'replayId', {\n    get: function () {\n        return this.getActiveReplayId();\n    }\n});\n\nwin['__mp_recorder'] = MixpanelRecorder;\n\n// stateless utils\n// mostly from https://github.com/mixpanel/mixpanel-js/blob/989ada50f518edab47b9c4fd9535f9fbd5ec5fc0/src/autotrack-utils.js\n\n\nvar EV_CHANGE = 'change';\nvar EV_CLICK = 'click';\nvar EV_HASHCHANGE = 'hashchange';\nvar EV_INPUT = 'input';\nvar EV_LOAD = 'load';\nvar EV_MP_LOCATION_CHANGE = 'mp_locationchange';\nvar EV_POPSTATE = 'popstate';\n// TODO scrollend isn't available in Safari: document or polyfill?\nvar EV_SCROLLEND = 'scrollend';\nvar EV_SCROLL = 'scroll';\nvar EV_SELECT = 'select';\nvar EV_SUBMIT = 'submit';\nvar EV_TOGGLE = 'toggle';\nvar EV_VISIBILITYCHANGE = 'visibilitychange';\n\nvar CLICK_EVENT_PROPS = [\n    'clientX', 'clientY',\n    'offsetX', 'offsetY',\n    'pageX', 'pageY',\n    'screenX', 'screenY',\n    'x', 'y'\n];\nvar OPT_IN_CLASSES = ['mp-include'];\nvar OPT_OUT_CLASSES = ['mp-no-track'];\nvar SENSITIVE_DATA_CLASSES = OPT_OUT_CLASSES.concat(['mp-sensitive']);\nvar TRACKED_ATTRS = [\n    'aria-label', 'aria-labelledby', 'aria-describedby',\n    'href', 'name', 'role', 'title', 'type'\n];\n\nvar INTERACTIVE_ARIA_ROLES = {\n    'button': true,\n    'checkbox': true,\n    'combobox': true,\n    'grid': true,\n    'link': true,\n    'listbox': true,\n    'menu': true,\n    'menubar': true,\n    'menuitem': true,\n    'menuitemcheckbox': true,\n    'menuitemradio': true,\n    'navigation': true,\n    'option': true,\n    'radio': true,\n    'radiogroup': true,\n    'searchbox': true,\n    'slider': true,\n    'spinbutton': true,\n    'switch': true,\n    'tab': true,\n    'tablist': true,\n    'textbox': true,\n    'tree': true,\n    'treegrid': true,\n    'treeitem': true\n};\n\nvar ALWAYS_NON_INTERACTIVE_TAGS = {\n    // Document metadata\n    'base': true,\n    'head': true,\n    'html': true,\n    'link': true,\n    'meta': true,\n    'script': true,\n    'style': true,\n    'title': true,\n    // Text formatting\n    'br': true,\n    'hr': true,\n    'wbr': true,\n    // Other\n    'noscript': true,\n    'picture': true,\n    'source': true,\n    'template': true,\n    'track': true\n};\n\n// Common container tags that need additional checks\nvar TEXT_CONTAINER_TAGS = {\n    'article': true,\n    'div': true,\n    'h1': true,\n    'h2': true,\n    'h3': true,\n    'h4': true,\n    'h5': true,\n    'h6': true,\n    'p': true,\n    'section': true,\n    'span': true\n};\n\nvar EVENT_HANDLER_ATTRIBUTES = [\n    'onclick', 'onmousedown', 'onmouseup', 'onpointerdown', 'onpointerup', 'ontouchend', 'ontouchstart'\n];\n\nvar MAX_DEPTH = 5;\n\nvar logger$1 = console_with_prefix('autocapture');\n\n\nfunction getClasses(el) {\n    var classes = {};\n    var classList = getClassName(el).split(' ');\n    for (var i = 0; i < classList.length; i++) {\n        var cls = classList[i];\n        if (cls) {\n            classes[cls] = true;\n        }\n    }\n    return classes;\n}\n\n/*\n * Get the className of an element, accounting for edge cases where element.className is an object\n * @param {Element} el - element to get the className of\n * @returns {string} the element's class\n */\nfunction getClassName(el) {\n    switch(typeof el.className) {\n        case 'string':\n            return el.className;\n        case 'object': // handle cases where className might be SVGAnimatedString or some other type\n            return el.className.baseVal || el.getAttribute('class') || '';\n        default: // future proof\n            return '';\n    }\n}\n\nfunction getPreviousElementSibling(el) {\n    if (el.previousElementSibling) {\n        return el.previousElementSibling;\n    } else {\n        do {\n            el = el.previousSibling;\n        } while (el && !isElementNode(el));\n        return el;\n    }\n}\n\nfunction getPropertiesFromElement(el, ev, blockAttrsSet, extraAttrs, allowElementCallback, allowSelectors) {\n    var props = {\n        '$classes': getClassName(el).split(' '),\n        '$tag_name': el.tagName.toLowerCase()\n    };\n    var elId = el.id;\n    if (elId) {\n        props['$id'] = elId;\n    }\n\n    if (shouldTrackElementDetails(el, ev, allowElementCallback, allowSelectors)) {\n        _.each(TRACKED_ATTRS.concat(extraAttrs), function(attr) {\n            if (el.hasAttribute(attr) && !blockAttrsSet[attr]) {\n                var attrVal = el.getAttribute(attr);\n                if (shouldTrackValue(attrVal)) {\n                    props['$attr-' + attr] = attrVal;\n                }\n            }\n        });\n    }\n\n    var nthChild = 1;\n    var nthOfType = 1;\n    var currentElem = el;\n    while (currentElem = getPreviousElementSibling(currentElem)) { // eslint-disable-line no-cond-assign\n        nthChild++;\n        if (currentElem.tagName === el.tagName) {\n            nthOfType++;\n        }\n    }\n    props['$nth_child'] = nthChild;\n    props['$nth_of_type'] = nthOfType;\n\n    return props;\n}\n\nfunction getPropsForDOMEvent(ev, config) {\n    var allowElementCallback = config.allowElementCallback;\n    var allowSelectors = config.allowSelectors || [];\n    var blockAttrs = config.blockAttrs || [];\n    var blockElementCallback = config.blockElementCallback;\n    var blockSelectors = config.blockSelectors || [];\n    var captureTextContent = config.captureTextContent || false;\n    var captureExtraAttrs = config.captureExtraAttrs || [];\n    var capturedForHeatMap = config.capturedForHeatMap || false;\n\n    // convert array to set every time, as the config may have changed\n    var blockAttrsSet = {};\n    _.each(blockAttrs, function(attr) {\n        blockAttrsSet[attr] = true;\n    });\n\n    var props = null;\n\n    var target = typeof ev.target === 'undefined' ? ev.srcElement : ev.target;\n    if (isTextNode(target)) { // defeat Safari bug (see: http://www.quirksmode.org/js/events_properties.html)\n        target = target.parentNode;\n    }\n\n    if (\n        shouldTrackDomEvent(target, ev) &&\n        isElementAllowed(target, ev, allowElementCallback, allowSelectors) &&\n        !isElementBlocked(target, ev, blockElementCallback, blockSelectors)\n    ) {\n        var targetElementList = [target];\n        var curEl = target;\n        while (curEl.parentNode && !isTag(curEl, 'body')) {\n            targetElementList.push(curEl.parentNode);\n            curEl = curEl.parentNode;\n        }\n\n        var elementsJson = [];\n        var href, explicitNoTrack = false;\n        _.each(targetElementList, function(el) {\n            var shouldTrackDetails = shouldTrackElementDetails(el, ev, allowElementCallback, allowSelectors);\n\n            // if the element or a parent element is an anchor tag\n            // include the href as a property\n            if (!blockAttrsSet['href'] && el.tagName.toLowerCase() === 'a') {\n                href = el.getAttribute('href');\n                href = shouldTrackDetails && shouldTrackValue(href) && href;\n            }\n\n            if (isElementBlocked(el, ev, blockElementCallback, blockSelectors)) {\n                explicitNoTrack = true;\n            }\n\n            elementsJson.push(getPropertiesFromElement(el, ev, blockAttrsSet, captureExtraAttrs, allowElementCallback, allowSelectors));\n        }, this);\n\n        if (!explicitNoTrack) {\n            var docElement = document$1['documentElement'];\n            props = {\n                '$event_type': ev.type,\n                '$host': win.location.host,\n                '$pathname': win.location.pathname,\n                '$elements':  elementsJson,\n                '$el_attr__href': href,\n                '$viewportHeight': Math.max(docElement['clientHeight'], win['innerHeight'] || 0),\n                '$viewportWidth': Math.max(docElement['clientWidth'], win['innerWidth'] || 0),\n                '$pageHeight': document$1['body']['offsetHeight'] || 0,\n                '$pageWidth': document$1['body']['offsetWidth'] || 0,\n            };\n            _.each(captureExtraAttrs, function(attr) {\n                if (!blockAttrsSet[attr] && target.hasAttribute(attr)) {\n                    var attrVal = target.getAttribute(attr);\n                    if (shouldTrackValue(attrVal)) {\n                        props['$el_attr__' + attr] = attrVal;\n                    }\n                }\n            });\n\n            if (captureTextContent) {\n                elementText = getSafeText(target, ev, allowElementCallback, allowSelectors);\n                if (elementText && elementText.length) {\n                    props['$el_text'] = elementText;\n                }\n            }\n\n            if (ev.type === EV_CLICK) {\n                _.each(CLICK_EVENT_PROPS, function(prop) {\n                    if (prop in ev) {\n                        props['$' + prop] = ev[prop];\n                    }\n                });\n                if (capturedForHeatMap) {\n                    props['$captured_for_heatmap'] = true;\n                }\n                target = guessRealClickTarget(ev);\n            }\n            // prioritize text content from \"real\" click target if different from original target\n            if (captureTextContent) {\n                var elementText = getSafeText(target, ev, allowElementCallback, allowSelectors);\n                if (elementText && elementText.length) {\n                    props['$el_text'] = elementText;\n                }\n            }\n\n            if (target) {\n                // target may have been recalculated; check allowlists and blocklists again\n                if (\n                    !isElementAllowed(target, ev, allowElementCallback, allowSelectors) ||\n                    isElementBlocked(target, ev, blockElementCallback, blockSelectors)\n                ) {\n                    return null;\n                }\n\n                var targetProps = getPropertiesFromElement(target, ev, blockAttrsSet, captureExtraAttrs, allowElementCallback, allowSelectors);\n                props['$target'] = targetProps;\n                // pull up more props onto main event props\n                props['$el_classes'] = targetProps['$classes'];\n                _.extend(props, _.strip_empty_properties({\n                    '$el_id': targetProps['$id'],\n                    '$el_tag_name': targetProps['$tag_name']\n                }));\n            }\n        }\n    }\n\n    return props;\n}\n\n\n/**\n * Get the direct text content of an element, protecting against sensitive data collection.\n * Concats textContent of each of the element's text node children; this avoids potential\n * collection of sensitive data that could happen if we used element.textContent and the\n * element had sensitive child elements, since element.textContent includes child content.\n * Scrubs values that look like they could be sensitive (i.e. cc or ssn number).\n * @param {Element} el - element to get the text of\n * @param {Array<string>} allowSelectors - CSS selectors for elements that should be included\n * @returns {string} the element's direct text content\n */\nfunction getSafeText(el, ev, allowElementCallback, allowSelectors) {\n    var elText = '';\n\n    if (shouldTrackElementDetails(el, ev, allowElementCallback, allowSelectors) && el.childNodes && el.childNodes.length) {\n        _.each(el.childNodes, function(child) {\n            if (isTextNode(child) && child.textContent) {\n                elText += _.trim(child.textContent)\n                    // scrub potentially sensitive values\n                    .split(/(\\s+)/).filter(shouldTrackValue).join('')\n                    // normalize whitespace\n                    .replace(/[\\r\\n]/g, ' ').replace(/[ ]+/g, ' ')\n                    // truncate\n                    .substring(0, 255);\n            }\n        });\n    }\n\n    return _.trim(elText);\n}\n\nfunction guessRealClickTarget(ev) {\n    var target = ev.target;\n    var composedPath = ev['composedPath']();\n    for (var i = 0; i < composedPath.length; i++) {\n        var node = composedPath[i];\n        if (\n            isTag(node, 'a') ||\n            isTag(node, 'button') ||\n            isTag(node, 'input') ||\n            isTag(node, 'select') ||\n            (node.getAttribute && node.getAttribute('role') === 'button')\n        ) {\n            target = node;\n            break;\n        }\n        if (node === target) {\n            break;\n        }\n    }\n    return target;\n}\n\nfunction isElementAllowed(el, ev, allowElementCallback, allowSelectors) {\n    if (allowElementCallback) {\n        try {\n            if (!allowElementCallback(el, ev)) {\n                return false;\n            }\n        } catch (err) {\n            logger$1.critical('Error while checking element in allowElementCallback', err);\n            return false;\n        }\n    }\n\n    if (!allowSelectors.length) {\n        // no allowlist; all elements are fair game\n        return true;\n    }\n\n    for (var i = 0; i < allowSelectors.length; i++) {\n        var sel = allowSelectors[i];\n        try {\n            if (el['matches'](sel)) {\n                return true;\n            }\n        } catch (err) {\n            logger$1.critical('Error while checking selector: ' + sel, err);\n        }\n    }\n    return false;\n}\n\nfunction isElementBlocked(el, ev, blockElementCallback, blockSelectors) {\n    var i;\n\n    if (blockElementCallback) {\n        try {\n            if (blockElementCallback(el, ev)) {\n                return true;\n            }\n        } catch (err) {\n            logger$1.critical('Error while checking element in blockElementCallback', err);\n            return true;\n        }\n    }\n\n    if (blockSelectors && blockSelectors.length) {\n        // programmatically prevent tracking of elements that match CSS selectors\n        for (i = 0; i < blockSelectors.length; i++) {\n            var sel = blockSelectors[i];\n            try {\n                if (el['matches'](sel)) {\n                    return true;\n                }\n            } catch (err) {\n                logger$1.critical('Error while checking selector: ' + sel, err);\n            }\n        }\n    }\n\n    // allow users to programmatically prevent tracking of elements by adding default classes such as 'mp-no-track'\n    var classes = getClasses(el);\n    for (i = 0; i < OPT_OUT_CLASSES.length; i++) {\n        if (classes[OPT_OUT_CLASSES[i]]) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/*\n * Check whether a DOM node has nodeType Node.ELEMENT_NODE\n * @param {Node} node - node to check\n * @returns {boolean} whether node is of the correct nodeType\n */\nfunction isElementNode(node) {\n    return node && node.nodeType === 1; // Node.ELEMENT_NODE - use integer constant for browser portability\n}\n\n/*\n * Check whether an element is of a given tag type.\n * Due to potential reference discrepancies (such as the webcomponents.js polyfill),\n * we want to match tagNames instead of specific references because something like\n * element === document.body won't always work because element might not be a native\n * element.\n * @param {Element} el - element to check\n * @param {string} tag - tag name (e.g., \"div\")\n * @returns {boolean} whether el is of the given tag type\n */\nfunction isTag(el, tag) {\n    return el && el.tagName && el.tagName.toLowerCase() === tag.toLowerCase();\n}\n\n/*\n * Check whether a DOM node is a TEXT_NODE\n * @param {Node} node - node to check\n * @returns {boolean} whether node is of type Node.TEXT_NODE\n */\nfunction isTextNode(node) {\n    return node && node.nodeType === 3; // Node.TEXT_NODE - use integer constant for browser portability\n}\n\nfunction minDOMApisSupported() {\n    try {\n        var testEl = document$1.createElement('div');\n        return !!testEl['matches'];\n    } catch (err) {\n        return false;\n    }\n}\n\nfunction weakSetSupported() {\n    return typeof WeakSet !== 'undefined';\n}\n\n/*\n * Check whether a DOM event should be \"tracked\" or if it may contain sensitive data\n * using a variety of heuristics.\n * @param {Element} el - element to check\n * @param {Event} ev - event to check\n * @returns {boolean} whether the event should be tracked\n */\nfunction shouldTrackDomEvent(el, ev) {\n    if (!el || isTag(el, 'html') || !isElementNode(el)) {\n        return false;\n    }\n    var tag = el.tagName.toLowerCase();\n    switch (tag) {\n        case 'form':\n            return ev.type === EV_SUBMIT;\n        case 'input':\n            if (['button', 'submit'].indexOf(el.getAttribute('type')) === -1) {\n                return ev.type === EV_CHANGE;\n            } else {\n                return ev.type === EV_CLICK;\n            }\n        case 'select':\n        case 'textarea':\n            return ev.type === EV_CHANGE;\n        default:\n            return ev.type === EV_CLICK;\n    }\n}\n\n/*\n * Check whether a DOM element should be \"tracked\" or if it may contain sensitive data\n * using a variety of heuristics.\n * @param {Element} el - element to check\n * @param {Array<string>} allowSelectors - CSS selectors for elements that should be included\n * @returns {boolean} whether the element should be tracked\n */\nfunction shouldTrackElementDetails(el, ev, allowElementCallback, allowSelectors) {\n    var i;\n\n    if (!isElementAllowed(el, ev, allowElementCallback, allowSelectors)) {\n        return false;\n    }\n\n    for (var curEl = el; curEl.parentNode && !isTag(curEl, 'body'); curEl = curEl.parentNode) {\n        var classes = getClasses(curEl);\n        for (i = 0; i < SENSITIVE_DATA_CLASSES.length; i++) {\n            if (classes[SENSITIVE_DATA_CLASSES[i]]) {\n                return false;\n            }\n        }\n    }\n\n    var elClasses = getClasses(el);\n    for (i = 0; i < OPT_IN_CLASSES.length; i++) {\n        if (elClasses[OPT_IN_CLASSES[i]]) {\n            return true;\n        }\n    }\n\n    // don't send data from inputs or similar elements since there will always be\n    // a risk of clientside javascript placing sensitive data in attributes\n    if (\n        isTag(el, 'input') ||\n        isTag(el, 'select') ||\n        isTag(el, 'textarea') ||\n        el.getAttribute('contenteditable') === 'true'\n    ) {\n        return false;\n    }\n\n    // don't include hidden or password fields\n    var type = el.type || '';\n    if (typeof type === 'string') { // it's possible for el.type to be a DOM element if el is a form with a child input[name=\"type\"]\n        switch(type.toLowerCase()) {\n            case 'hidden':\n                return false;\n            case 'password':\n                return false;\n        }\n    }\n\n    // filter out data from fields that look like sensitive fields\n    var name = el.name || el.id || '';\n    if (typeof name === 'string') { // it's possible for el.name or el.id to be a DOM element if el is a form with a child input[name=\"name\"]\n        var sensitiveNameRegex = /^cc|cardnum|ccnum|creditcard|csc|cvc|cvv|exp|pass|pwd|routing|seccode|securitycode|securitynum|socialsec|socsec|ssn/i;\n        if (sensitiveNameRegex.test(name.replace(/[^a-zA-Z0-9]/g, ''))) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n\n/*\n * Check whether a string value should be \"tracked\" or if it may contain sensitive data\n * using a variety of heuristics.\n * @param {string} value - string value to check\n * @returns {boolean} whether the element should be tracked\n */\nfunction shouldTrackValue(value) {\n    if (value === null || _.isUndefined(value)) {\n        return false;\n    }\n\n    if (typeof value === 'string') {\n        value = _.trim(value);\n\n        // check to see if input value looks like a credit card number\n        // see: https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9781449327453/ch04s20.html\n        var ccRegex = /^(?:(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11}))$/;\n        if (ccRegex.test((value || '').replace(/[- ]/g, ''))) {\n            return false;\n        }\n\n        // check to see if input value looks like a social security number\n        var ssnRegex = /(^\\d{3}-?\\d{2}-?\\d{4}$)/;\n        if (ssnRegex.test(value)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Creates a cross-browser compatible scroll end function with appropriate event listener.\n * For browsers that support scrollend, returns the original function with scrollend event.\n * For browsers without scrollend support, returns a debounced function that triggers\n * 100ms after the last scroll event to simulate scrollend behavior.\n * @param {Function} originalFunction - The function to call when scrolling ends\n * @returns {Object} Object containing listener function and eventType string\n * @returns {Function} returns.listener - The wrapped function to use as event listener\n * @returns {string} returns.eventType - The event type to listen for ('scrollend' or 'scroll')\n */\nfunction getPolyfillScrollEndFunction(originalFunction) {\n    var supportsScrollEnd = 'onscrollend' in win;\n    var polyfillFunction = safewrap(originalFunction);\n    var polyfillEvent = EV_SCROLLEND;\n    if (!supportsScrollEnd) {\n        // Polyfill for browsers without scrollend support: wait 100ms after the last scroll event\n        // https://developer.chrome.com/blog/scrollend-a-new-javascript-event\n        var scrollTimer = null;\n        var scrollDelayMs = 100;\n\n        polyfillFunction = safewrap(function() {\n            clearTimeout(scrollTimer);\n            scrollTimer = setTimeout(originalFunction, scrollDelayMs);\n        });\n\n        polyfillEvent = EV_SCROLL;\n    }\n\n    return {\n        listener: polyfillFunction,\n        eventType: polyfillEvent\n    };\n}\n\nfunction hasInlineEventHandlers(element) {\n    for (var i = 0; i < EVENT_HANDLER_ATTRIBUTES.length; i++) {\n        if (element.hasAttribute(EVENT_HANDLER_ATTRIBUTES[i])) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction hasInteractiveAriaRole(element) {\n    var role = element.getAttribute('role');\n    if (!role) return false;\n\n    // Handle invalid markup where multiple roles might be specified\n    // Only the first token is recognized per ARIA spec\n    var primaryRole = role.trim().split(/\\s+/)[0].toLowerCase();\n\n    return INTERACTIVE_ARIA_ROLES[primaryRole];\n}\n\nfunction hasAnyInteractivityIndicators(element) {\n    var tagName = element.tagName.toLowerCase();\n\n    // Check for interactive HTML elements\n    if (tagName === 'button' ||\n        tagName === 'input' ||\n        tagName === 'select' ||\n        tagName === 'textarea' ||\n        tagName === 'details' ||\n        tagName === 'dialog') {\n        return true;\n    }\n\n    if (element.isContentEditable) {\n        return true;\n    }\n\n    if (element.onclick || element.onmousedown || element.onmouseup || element.ontouchstart || element.ontouchend) {\n        return true;\n    }\n\n    if (hasInlineEventHandlers(element)) {\n        return true;\n    }\n\n    if (hasInteractiveAriaRole(element)) {\n        return true;\n    }\n\n    if (tagName === 'a' && element.hasAttribute('href')) {\n        return true;\n    }\n\n    if (element.hasAttribute('tabindex')) {\n        return true;\n    }\n\n    return false;\n}\n\n\nfunction isDefinitelyNonInteractive(element) {\n    if (!element || !element.tagName) {\n        return true;\n    }\n\n    var tagName = element.tagName.toLowerCase();\n\n    // These tags are definitely non-interactive\n    if (ALWAYS_NON_INTERACTIVE_TAGS[tagName]) {\n        return true;\n    }\n\n    // For all other elements, we can only be certain they're non-interactive if they lack ALL indicators of interactivity\n    // Check for any signs of interactivity\n    if (hasAnyInteractivityIndicators(element)) {\n        return false;\n    }\n\n    // Check parent chain for interactive context\n    var parent = element.parentElement;\n    var depth = 0;\n\n    while (parent && depth < MAX_DEPTH) {\n        if (hasAnyInteractivityIndicators(parent)) {\n            return false; // Element is inside an interactive parent\n        }\n\n        if (parent.getRootNode && parent.getRootNode() !== document$1) {\n            var root = parent.getRootNode();\n            if (root.host && hasAnyInteractivityIndicators(root.host)) {\n                return false; // Inside an interactive shadow host\n            }\n        }\n\n        parent = parent.parentElement;\n        depth++;\n    }\n\n    // Pure text containers without any interactive context\n    if (TEXT_CONTAINER_TAGS[tagName]) {\n        // These are non-interactive ONLY if they have no interactive indicators (already checked as part of hasAnyInteractivityIndicators)\n        return true;\n    }\n\n    // Default: we can't be certain it's non-interactive\n    return false;\n}\n\n/**\n * Get the composed path of a click event for elements embedded in shadow DOM.\n * @param {Event} event - event to get the composed path from\n * @returns {Array} the composed path of the click event\n*/\nfunction getClickEventComposedPath(event) {\n    if ('composedPath' in event) {\n        return event['composedPath']();\n    }\n\n    return [];\n}\n\n/**\n * Get the element from a click event, accounting for elements embedded in shadow DOM.\n * @param {Event} event - event to get the target from\n * @returns {Element | null} the element that was the target of the click event\n */\nfunction getClickEventTargetElement(event) {\n    var path = getClickEventComposedPath(event);\n\n    if (path && path.length > 0) {\n        return path[0];\n    }\n\n    return event['target'] || event['srcElement'];\n}\n\n/** @const */ var DEFAULT_RAGE_CLICK_THRESHOLD_PX = 30;\n/** @const */ var DEFAULT_RAGE_CLICK_TIMEOUT_MS = 1000;\n/** @const */ var DEFAULT_RAGE_CLICK_CLICK_COUNT = 4;\n/** @const */ var DEFAULT_RAGE_CLICK_INTERACTIVE_ELEMENTS_ONLY = false;\n\nfunction RageClickTracker() {\n    this.clicks = [];\n}\n\n/**\n * Determines if a click event is part of a rage click sequence.\n * @param {Event} event - the original click event.\n * @param {import('../index.d.ts').RageClickConfig} options - configuration options for rage click detection.\n * @returns {boolean} - true if the click is considered a rage click, false otherwise.\n */\nRageClickTracker.prototype.isRageClick = function(event, options) {\n    options = options || {};\n    var thresholdPx = options['threshold_px'] || DEFAULT_RAGE_CLICK_THRESHOLD_PX;\n    var timeoutMs = options['timeout_ms'] || DEFAULT_RAGE_CLICK_TIMEOUT_MS;\n    var clickCount = options['click_count'] || DEFAULT_RAGE_CLICK_CLICK_COUNT;\n    var interactiveElementsOnly = options['interactive_elements_only'] || DEFAULT_RAGE_CLICK_INTERACTIVE_ELEMENTS_ONLY;\n\n    if (interactiveElementsOnly) {\n        var target = getClickEventTargetElement(event);\n        if (!target || isDefinitelyNonInteractive(target)) {\n            return false;\n        }\n    }\n\n    var timestamp = Date.now();\n    var x = event['pageX'], y = event['pageY'];\n\n    var lastClick = this.clicks[this.clicks.length - 1];\n    if (\n        lastClick &&\n        timestamp - lastClick.timestamp < timeoutMs &&\n        Math.sqrt(Math.pow(x - lastClick.x, 2) + Math.pow(y - lastClick.y, 2)) < thresholdPx\n    ) {\n        this.clicks.push({ x: x, y: y, timestamp: timestamp });\n        if (this.clicks.length >= clickCount) {\n            this.clicks = [];\n            return true;\n        }\n    } else {\n        this.clicks = [{ x: x, y: y, timestamp: timestamp }];\n    }\n    return false;\n};\n\nfunction ShadowDOMObserver(changeCallback, observerConfig) {\n    this.changeCallback = changeCallback || function() {};\n    this.observerConfig = observerConfig;\n\n    this.observedShadowRoots = null;\n    this.shadowObservers = [];\n}\n\nShadowDOMObserver.prototype.getEventTarget = function(event) {\n    if (!this.observedShadowRoots) {\n        return;\n    }\n\n    return getClickEventTargetElement(event);\n};\n\nShadowDOMObserver.prototype.observeFromEvent = function(event) {\n    if (!this.observedShadowRoots) {\n        return;\n    }\n\n    var path = getClickEventComposedPath(event);\n\n    // Check each element in path for shadow roots\n    for (var i = 0; i < path.length; i++) {\n        var element = path[i];\n\n        if (element && element.shadowRoot) {\n            this.observeShadowRoot(element.shadowRoot);\n        }\n    }\n};\n\n\nShadowDOMObserver.prototype.observeShadowRoot = function(shadowRoot) {\n    if (!this.observedShadowRoots || this.observedShadowRoots.has(shadowRoot)) {\n        return;\n    }\n\n    var self = this;\n\n    try {\n        this.observedShadowRoots.add(shadowRoot);\n\n        var observer = new window.MutationObserver(function() {\n            self.changeCallback();\n        });\n\n        observer.observe(shadowRoot, this.observerConfig);\n        this.shadowObservers.push(observer);\n    } catch (e) {\n        logger$1.critical('Error while observing shadow root', e);\n    }\n};\n\n\nShadowDOMObserver.prototype.start = function() {\n    if (this.observedShadowRoots) {\n        return;\n    }\n\n    if (!weakSetSupported()) {\n        logger$1.critical('Shadow DOM observation unavailable: WeakSet not supported');\n        return;\n    }\n\n    this.observedShadowRoots = new WeakSet();\n};\n\nShadowDOMObserver.prototype.stop = function() {\n    if (!this.observedShadowRoots) {\n        return;\n    }\n\n    for (var i = 0; i < this.shadowObservers.length; i++) {\n        try {\n            this.shadowObservers[i].disconnect();\n        } catch (e) {\n            logger$1.critical('Error while disconnecting shadow DOM observer', e);\n        }\n    }\n    this.shadowObservers = [];\n    this.observedShadowRoots = null;\n};\n\n/** @const */ var DEFAULT_DEAD_CLICK_TIMEOUT_MS = 500;\n/** @const */ var INTERACTION_EVENTS = [EV_CHANGE, EV_INPUT, EV_SUBMIT, EV_SELECT, EV_TOGGLE];\n/** @const */ var LAYOUT_EVENTS = [EV_SCROLLEND];\n/** @const */ var NAVIGATION_EVENTS = [EV_HASHCHANGE];\n/** @const */ var MUTATION_OBSERVER_CONFIG = {\n    characterData: true,\n    childList: true,\n    subtree: true,\n    attributes: true,\n    attributeFilter: ['style', 'class', 'hidden', 'checked', 'selected', 'value', 'display', 'visibility']\n};\n\n\nfunction DeadClickTracker(onDeadClickCallback) {\n    this.eventListeners = [];\n    this.mutationObserver = null;\n    this.shadowDOMObserver = null;\n\n    this.isTracking = false;\n    this.lastChangeEventTimestamp = 0;\n    this.pendingClicks = [];\n    this.onDeadClickCallback = onDeadClickCallback;\n    this.processingActive = false;\n    this.processingTimeout = null;\n}\n\n\nDeadClickTracker.prototype.addClick = function(event) {\n    var element = this.shadowDOMObserver && this.shadowDOMObserver.getEventTarget(event);\n\n    if (!element) {\n        element = event['target'] || event['srcElement'];\n    }\n\n    if (!element || isDefinitelyNonInteractive(element)) {\n        return false;\n    }\n\n    if (this.shadowDOMObserver) {\n        this.shadowDOMObserver.observeFromEvent(event);\n    }\n    this.pendingClicks.push({\n        element: element,\n        event: event,\n        timestamp: Date.now()\n    });\n    return true;\n};\n\nDeadClickTracker.prototype.trackClick = function(event, config) {\n    if (!this.isTracking) {\n        return false;\n    }\n\n    var added = this.addClick(event);\n    if (added) {\n        this.triggerProcessing(config);\n    }\n    return added;\n};\n\nDeadClickTracker.prototype.getDeadClicks = function(config) {\n    if (this.pendingClicks.length === 0) {\n        return [];\n    }\n\n    var timeoutMs = config['timeout_ms'];\n    var now = Date.now();\n    var clicksToEvaluate = this.pendingClicks.slice(); // Copy array\n    this.pendingClicks = []; // Clear original\n\n    var deadClicks = [];\n\n    for (var i = 0; i < clicksToEvaluate.length; i++) {\n        var click = clicksToEvaluate[i];\n\n        if (now - click.timestamp >= timeoutMs) {\n            // Click has exceeded timeout, check if it's dead by looking for changes after this specific click\n            if (!this.hasChangesAfter(click.timestamp)) {\n                deadClicks.push(click);\n            }\n        } else {\n            // Still pending - add back\n            this.pendingClicks.push(click);\n        }\n    }\n\n    return deadClicks;\n};\n\nDeadClickTracker.prototype.hasChangesAfter = function(timestamp) {\n    // 100ms tolerance for race condition between when we record the click and the change event\n    return this.lastChangeEventTimestamp >= (timestamp - 100);\n};\n\nDeadClickTracker.prototype.recordChangeEvent = function() {\n    this.lastChangeEventTimestamp = Date.now();\n};\n\nDeadClickTracker.prototype.triggerProcessing = function(config) {\n    // Prevent multiple concurrent processing chains\n    if (this.processingActive) {\n        return;\n    }\n    this.processingActive = true;\n    this.processRecursively(config);\n};\n\nDeadClickTracker.prototype.processRecursively = function(config) {\n    if (!this.isTracking || !this.onDeadClickCallback) {\n        this.processingActive = false;\n        return;\n    }\n\n    var timeoutMs = config['timeout_ms'];\n    var self = this;\n\n    this.processingTimeout = setTimeout(function() {\n        if (!self.processingActive) {\n            return;\n        }\n\n        var deadClicks = self.getDeadClicks(config);\n\n        for (var i = 0; i < deadClicks.length; i++) {\n            self.onDeadClickCallback(deadClicks[i].event);\n        }\n\n        if (self.pendingClicks.length > 0) {\n            self.processRecursively(config);\n        } else {\n            self.processingActive = false;\n        }\n    }, timeoutMs);\n};\n\nDeadClickTracker.prototype.startTracking = function() {\n    if (this.isTracking) {\n        return;\n    }\n\n    this.isTracking = true;\n\n    var self = this;\n\n    INTERACTION_EVENTS.forEach(function(event) {\n        var handler = function() {\n            self.recordChangeEvent();\n        };\n        document.addEventListener(event, handler, { capture: true, passive: true });\n        self.eventListeners.push({ target: document, event: event, handler: handler, options: { capture: true, passive: true } });\n    });\n    NAVIGATION_EVENTS.forEach(function(event) {\n        var handler = function() {\n            self.recordChangeEvent();\n        };\n        window.addEventListener(event, handler);\n        self.eventListeners.push({ target: window, event: event, handler: handler });\n    });\n    LAYOUT_EVENTS.forEach(function(event) {\n        var handler = function() {\n            self.recordChangeEvent();\n        };\n        window.addEventListener(event, handler, { passive: true });\n        self.eventListeners.push({ target: window, event: event, handler: handler, options: { passive: true } });\n    });\n    var selectionHandler = function() {\n        self.recordChangeEvent();\n    };\n    document.addEventListener('selectionchange', selectionHandler);\n    self.eventListeners.push({ target: document, event: 'selectionchange', handler: selectionHandler });\n\n    // Set up MutationObserver\n    if (window.MutationObserver) {\n        try {\n            this.mutationObserver = new window.MutationObserver(function() {\n                self.recordChangeEvent();\n            });\n\n            this.mutationObserver.observe(document.body || document.documentElement, MUTATION_OBSERVER_CONFIG);\n        } catch (e) {\n            logger$1.critical('Error while setting up mutation observer', e);\n        }\n    }\n\n    // Set up Shadow DOM observer\n    if (window.customElements) {\n        try {\n            this.shadowDOMObserver = new ShadowDOMObserver(\n                function() {\n                    self.recordChangeEvent();\n                },\n                MUTATION_OBSERVER_CONFIG\n            );\n            this.shadowDOMObserver.start();\n        } catch (e) {\n            logger$1.critical('Error while setting up shadow DOM observer', e);\n            this.shadowDOMObserver = null;\n        }\n    }\n};\n\nDeadClickTracker.prototype.stopTracking = function() {\n    if (!this.isTracking) {\n        return;\n    }\n\n    this.isTracking = false;\n    this.pendingClicks = [];\n    this.lastChangeEventTimestamp = 0;\n    this.processingActive = false;\n\n    if (this.processingTimeout) {\n        clearTimeout(this.processingTimeout);\n        this.processingTimeout = null;\n    }\n\n    // Remove all event listeners\n    for (var i = 0; i < this.eventListeners.length; i++) {\n        var listener = this.eventListeners[i];\n        try {\n            listener.target.removeEventListener(listener.event, listener.handler, listener.options);\n        } catch (e) {\n            logger$1.critical('Error while removing event listener', e);\n        }\n    }\n    this.eventListeners = [];\n\n    if (this.mutationObserver) {\n        try {\n            this.mutationObserver.disconnect();\n        } catch (e) {\n            logger$1.critical('Error while disconnecting mutation observer', e);\n        }\n        this.mutationObserver = null;\n    }\n\n    if (this.shadowDOMObserver) {\n        try {\n            this.shadowDOMObserver.stop();\n        } catch (e) {\n            logger$1.critical('Error while stopping shadow DOM observer', e);\n        }\n        this.shadowDOMObserver = null;\n    }\n};\n\nvar AUTOCAPTURE_CONFIG_KEY = 'autocapture';\nvar LEGACY_PAGEVIEW_CONFIG_KEY = 'track_pageview';\n\nvar PAGEVIEW_OPTION_FULL_URL = 'full-url';\nvar PAGEVIEW_OPTION_URL_WITH_PATH_AND_QUERY_STRING = 'url-with-path-and-query-string';\nvar PAGEVIEW_OPTION_URL_WITH_PATH = 'url-with-path';\n\nvar CONFIG_ALLOW_ELEMENT_CALLBACK = 'allow_element_callback';\nvar CONFIG_ALLOW_SELECTORS = 'allow_selectors';\nvar CONFIG_ALLOW_URL_REGEXES = 'allow_url_regexes';\nvar CONFIG_BLOCK_ATTRS = 'block_attrs';\nvar CONFIG_BLOCK_ELEMENT_CALLBACK = 'block_element_callback';\nvar CONFIG_BLOCK_SELECTORS = 'block_selectors';\nvar CONFIG_BLOCK_URL_REGEXES = 'block_url_regexes';\nvar CONFIG_CAPTURE_EXTRA_ATTRS = 'capture_extra_attrs';\nvar CONFIG_CAPTURE_TEXT_CONTENT = 'capture_text_content';\nvar CONFIG_SCROLL_CAPTURE_ALL = 'scroll_capture_all';\nvar CONFIG_SCROLL_CHECKPOINTS = 'scroll_depth_percent_checkpoints';\nvar CONFIG_TRACK_CLICK = 'click';\nvar CONFIG_TRACK_DEAD_CLICK = 'dead_click';\nvar CONFIG_TRACK_INPUT = 'input';\nvar CONFIG_TRACK_PAGEVIEW = 'pageview';\nvar CONFIG_TRACK_RAGE_CLICK = 'rage_click';\nvar CONFIG_TRACK_SCROLL = 'scroll';\nvar CONFIG_TRACK_PAGE_LEAVE = 'page_leave';\nvar CONFIG_TRACK_SUBMIT = 'submit';\n\nvar CONFIG_DEFAULTS$1 = {};\nCONFIG_DEFAULTS$1[CONFIG_ALLOW_SELECTORS] = [];\nCONFIG_DEFAULTS$1[CONFIG_ALLOW_URL_REGEXES] = [];\nCONFIG_DEFAULTS$1[CONFIG_BLOCK_ATTRS] = [];\nCONFIG_DEFAULTS$1[CONFIG_BLOCK_ELEMENT_CALLBACK] = null;\nCONFIG_DEFAULTS$1[CONFIG_BLOCK_SELECTORS] = [];\nCONFIG_DEFAULTS$1[CONFIG_BLOCK_URL_REGEXES] = [];\nCONFIG_DEFAULTS$1[CONFIG_CAPTURE_EXTRA_ATTRS] = [];\nCONFIG_DEFAULTS$1[CONFIG_CAPTURE_TEXT_CONTENT] = false;\nCONFIG_DEFAULTS$1[CONFIG_SCROLL_CAPTURE_ALL] = false;\nCONFIG_DEFAULTS$1[CONFIG_SCROLL_CHECKPOINTS] = [25, 50, 75, 100];\nCONFIG_DEFAULTS$1[CONFIG_TRACK_CLICK] = true;\nCONFIG_DEFAULTS$1[CONFIG_TRACK_DEAD_CLICK] = true;\nCONFIG_DEFAULTS$1[CONFIG_TRACK_INPUT] = true;\nCONFIG_DEFAULTS$1[CONFIG_TRACK_PAGEVIEW] = PAGEVIEW_OPTION_FULL_URL;\nCONFIG_DEFAULTS$1[CONFIG_TRACK_RAGE_CLICK] = true;\nCONFIG_DEFAULTS$1[CONFIG_TRACK_SCROLL] = true;\nCONFIG_DEFAULTS$1[CONFIG_TRACK_PAGE_LEAVE] = false;\nCONFIG_DEFAULTS$1[CONFIG_TRACK_SUBMIT] = true;\n\nvar DEFAULT_PROPS = {\n    '$mp_autocapture': true\n};\n\nvar MP_EV_CLICK = '$mp_click';\nvar MP_EV_DEAD_CLICK = '$mp_dead_click';\nvar MP_EV_INPUT = '$mp_input_change';\nvar MP_EV_RAGE_CLICK = '$mp_rage_click';\nvar MP_EV_SCROLL = '$mp_scroll';\nvar MP_EV_SUBMIT = '$mp_submit';\nvar MP_EV_PAGE_LEAVE = '$mp_page_leave';\n\n/**\n * Autocapture: manages automatic event tracking\n * @constructor\n */\nvar Autocapture = function(mp) {\n    this.mp = mp;\n    this.maxScrollViewDepth = 0;\n    this.hasTrackedScrollSession = false;\n    this.previousScrollHeight = 0;\n};\n\nAutocapture.prototype.init = function() {\n    if (!minDOMApisSupported()) {\n        logger$1.critical('Autocapture unavailable: missing required DOM APIs');\n        return;\n    }\n    this.initPageListeners();\n    this.initPageviewTracking();\n    this.initClickTracking();\n    this.initDeadClickTracking();\n    this.initInputTracking();\n    this.initScrollTracking();\n    this.initSubmitTracking();\n    this.initRageClickTracking();\n    this.initPageLeaveTracking();\n};\n\nAutocapture.prototype.getFullConfig = function() {\n    var autocaptureConfig = this.mp.get_config(AUTOCAPTURE_CONFIG_KEY);\n    if (!autocaptureConfig) {\n        // Autocapture is completely off\n        return {};\n    } else if (_.isObject(autocaptureConfig)) {\n        return _.extend({}, CONFIG_DEFAULTS$1, autocaptureConfig);\n    } else {\n        // Autocapture config is non-object truthy value, return default\n        return CONFIG_DEFAULTS$1;\n    }\n};\n\nAutocapture.prototype.getConfig = function(key) {\n    return this.getFullConfig()[key];\n};\n\nAutocapture.prototype.currentUrlBlocked = function() {\n    var i;\n    var currentUrl = _.info.currentUrl();\n\n    var allowUrlRegexes = this.getConfig(CONFIG_ALLOW_URL_REGEXES) || [];\n    if (allowUrlRegexes.length) {\n        // we're using an allowlist, only track if current URL matches\n        var allowed = false;\n        for (i = 0; i < allowUrlRegexes.length; i++) {\n            var allowRegex = allowUrlRegexes[i];\n            try {\n                if (currentUrl.match(allowRegex)) {\n                    allowed = true;\n                    break;\n                }\n            } catch (err) {\n                logger$1.critical('Error while checking block URL regex: ' + allowRegex, err);\n                return true;\n            }\n        }\n        if (!allowed) {\n            // wasn't allowed by any regex\n            return true;\n        }\n    }\n\n    var blockUrlRegexes = this.getConfig(CONFIG_BLOCK_URL_REGEXES) || [];\n    if (!blockUrlRegexes || !blockUrlRegexes.length) {\n        return false;\n    }\n\n    for (i = 0; i < blockUrlRegexes.length; i++) {\n        try {\n            if (currentUrl.match(blockUrlRegexes[i])) {\n                return true;\n            }\n        } catch (err) {\n            logger$1.critical('Error while checking block URL regex: ' + blockUrlRegexes[i], err);\n            return true;\n        }\n    }\n    return false;\n};\n\nAutocapture.prototype.pageviewTrackingConfig = function() {\n    // supports both autocapture config and old track_pageview config\n    if (this.mp.get_config(AUTOCAPTURE_CONFIG_KEY)) {\n        return this.getConfig(CONFIG_TRACK_PAGEVIEW);\n    } else {\n        return this.mp.get_config(LEGACY_PAGEVIEW_CONFIG_KEY);\n    }\n};\n\n// helper for event handlers\nAutocapture.prototype.trackDomEvent = function(ev, mpEventName) {\n    if (this.currentUrlBlocked()) {\n        return;\n    }\n\n    var isCapturedForHeatMap = this.mp.is_recording_heatmap_data() && (\n        (mpEventName === MP_EV_CLICK && !this.getConfig(CONFIG_TRACK_CLICK)) ||\n        (mpEventName === MP_EV_RAGE_CLICK && !this._getClickTrackingConfig(CONFIG_TRACK_RAGE_CLICK)) ||\n        (mpEventName === MP_EV_DEAD_CLICK && !this._getClickTrackingConfig(CONFIG_TRACK_DEAD_CLICK))\n    );\n\n    var props = getPropsForDOMEvent(ev, {\n        allowElementCallback: this.getConfig(CONFIG_ALLOW_ELEMENT_CALLBACK),\n        allowSelectors: this.getConfig(CONFIG_ALLOW_SELECTORS),\n        blockAttrs: this.getConfig(CONFIG_BLOCK_ATTRS),\n        blockElementCallback: this.getConfig(CONFIG_BLOCK_ELEMENT_CALLBACK),\n        blockSelectors: this.getConfig(CONFIG_BLOCK_SELECTORS),\n        captureExtraAttrs: this.getConfig(CONFIG_CAPTURE_EXTRA_ATTRS),\n        captureTextContent: this.getConfig(CONFIG_CAPTURE_TEXT_CONTENT),\n        capturedForHeatMap: isCapturedForHeatMap,\n    });\n    if (props) {\n        _.extend(props, DEFAULT_PROPS);\n        this.mp.track(mpEventName, props);\n    }\n};\n\nAutocapture.prototype.initPageListeners = function() {\n    win.removeEventListener(EV_POPSTATE, this.listenerPopstate);\n    win.removeEventListener(EV_HASHCHANGE, this.listenerHashchange);\n\n    if (!this.pageviewTrackingConfig() && !this.getConfig(CONFIG_TRACK_PAGE_LEAVE) && !this.mp.get_config('record_heatmap_data')) {\n        // These are all the configs that use these listeners\n        return;\n    }\n\n    this.listenerPopstate = function() {\n        win.dispatchEvent(new Event(EV_MP_LOCATION_CHANGE));\n    };\n    this.listenerHashchange = function() {\n        win.dispatchEvent(new Event(EV_MP_LOCATION_CHANGE));\n    };\n\n    win.addEventListener(EV_POPSTATE, this.listenerPopstate);\n    win.addEventListener(EV_HASHCHANGE, this.listenerHashchange);\n    var nativePushState = win.history.pushState;\n    if (typeof nativePushState === 'function') {\n        win.history.pushState = function(state, unused, url) {\n            nativePushState.call(win.history, state, unused, url);\n            win.dispatchEvent(new Event(EV_MP_LOCATION_CHANGE));\n        };\n    }\n    var nativeReplaceState = win.history.replaceState;\n    if (typeof nativeReplaceState === 'function') {\n        win.history.replaceState = function(state, unused, url) {\n            nativeReplaceState.call(win.history, state, unused, url);\n            win.dispatchEvent(new Event(EV_MP_LOCATION_CHANGE));\n        };\n    }\n};\n\nAutocapture.prototype._getClickTrackingConfig = function(configKey) {\n    var config = this.getConfig(configKey);\n\n    if (!config) {\n        return null; // click tracking disabled\n    }\n\n    if (config === true) {\n        return {}; // use defaults\n    }\n\n    if (typeof config === 'object') {\n        return config; // use custom configuration\n    }\n\n    return {}; // fallback to defaults for any other truthy value\n};\n\nAutocapture.prototype._trackPageLeave = function(ev, currentUrl, currentScrollHeight) {\n    if (this.hasTrackedScrollSession) {\n        // User has navigated away already ending their impression.\n        return;\n    }\n\n    if (!this.getConfig(CONFIG_TRACK_PAGE_LEAVE) && !this.mp.is_recording_heatmap_data()) {\n        return;\n    }\n\n    this.hasTrackedScrollSession = true;\n    var viewportHeight = Math.max(document$1.documentElement.clientHeight, win.innerHeight || 0);\n    var scrollPercentage = Math.round(Math.max(this.maxScrollViewDepth - viewportHeight, 0) / (currentScrollHeight - viewportHeight) * 100);\n    var foldLinePercentage = Math.round((viewportHeight / currentScrollHeight) * 100);\n    if (currentScrollHeight <= viewportHeight) {\n        // If the content fits within the viewport, consider it fully scrolled\n        scrollPercentage = 100;\n        foldLinePercentage = 100;\n    }\n\n    var props = _.extend({\n        '$max_scroll_view_depth': this.maxScrollViewDepth,\n        '$max_scroll_percentage': scrollPercentage,\n        '$fold_line_percentage': foldLinePercentage,\n        '$scroll_height':  currentScrollHeight,\n        '$event_type': ev.type,\n        '$current_url': currentUrl || _.info.currentUrl(),\n        '$viewportHeight': viewportHeight, // This is the fold line\n        '$viewportWidth':  Math.max(document$1.documentElement.clientWidth, win.innerWidth || 0),\n        '$captured_for_heatmap': this.mp.is_recording_heatmap_data()\n    }, DEFAULT_PROPS);\n\n    // Send with beacon transport to ensure event is sent before unload\n    this.mp.track(MP_EV_PAGE_LEAVE, props, {transport: 'sendBeacon'});\n};\n\nAutocapture.prototype._initScrollDepthTracking = function() {\n    win.removeEventListener(EV_SCROLL, this.listenerScrollDepth);\n    win.removeEventListener(EV_SCROLLEND, this.listenerScrollDepth);\n\n    if (!this.mp.get_config('record_heatmap_data')) {\n        return;\n    }\n\n    logger$1.log('Initializing scroll depth tracking');\n\n    this.maxScrollViewDepth = Math.max(document$1.documentElement.clientHeight, win.innerHeight || 0);\n\n    var updateScrollDepth = function() {\n        if (this.currentUrlBlocked()) {\n            return;\n        }\n        var scrollViewHeight = Math.max(document$1.documentElement.clientHeight, win.innerHeight || 0) + win.scrollY;\n        if (scrollViewHeight > this.maxScrollViewDepth) {\n            this.maxScrollViewDepth = scrollViewHeight;\n        }\n        this.previousScrollHeight = document$1.body.scrollHeight;\n    }.bind(this);\n\n    var scrollEndPolyfill = getPolyfillScrollEndFunction(updateScrollDepth);\n    this.listenerScrollDepth = scrollEndPolyfill.listener;\n    win.addEventListener(scrollEndPolyfill.eventType, this.listenerScrollDepth);\n};\n\nAutocapture.prototype.initClickTracking = function() {\n    win.removeEventListener(EV_CLICK, this.listenerClick);\n\n    if (!this.getConfig(CONFIG_TRACK_CLICK) && !this.mp.get_config('record_heatmap_data')) {\n        return;\n    }\n    logger$1.log('Initializing click tracking');\n\n    this.listenerClick = function(ev) {\n        if (!this.getConfig(CONFIG_TRACK_CLICK) && !this.mp.is_recording_heatmap_data()) {\n            return;\n        }\n        this.trackDomEvent(ev, MP_EV_CLICK);\n    }.bind(this);\n    win.addEventListener(EV_CLICK, this.listenerClick);\n};\n\nAutocapture.prototype.initDeadClickTracking = function() {\n    var deadClickConfig = this._getClickTrackingConfig(CONFIG_TRACK_DEAD_CLICK);\n\n    if (!deadClickConfig && !this.mp.get_config('record_heatmap_data')) {\n        this.stopDeadClickTracking();\n        return;\n    }\n\n    logger$1.log('Initializing dead click tracking');\n    if (!this._deadClickTracker) {\n        this._deadClickTracker = new DeadClickTracker(function(deadClickEvent) {\n            this.trackDomEvent(deadClickEvent, MP_EV_DEAD_CLICK);\n        }.bind(this));\n        this._deadClickTracker.startTracking();\n    }\n\n    if (!this.listenerDeadClick) {\n        this.listenerDeadClick = function(ev) {\n            var currentDeadClickConfig = this._getClickTrackingConfig(CONFIG_TRACK_DEAD_CLICK);\n            if (!currentDeadClickConfig && !this.mp.is_recording_heatmap_data()) {\n                return;\n            }\n            if (this.currentUrlBlocked()) {\n                return;\n            }\n            // Normalize config to ensure timeout_ms is always set\n            var normalizedConfig = currentDeadClickConfig || {};\n            if (!normalizedConfig['timeout_ms']) {\n                normalizedConfig['timeout_ms'] = DEFAULT_DEAD_CLICK_TIMEOUT_MS;\n            }\n            this._deadClickTracker.trackClick(ev, normalizedConfig);\n        }.bind(this);\n        win.addEventListener(EV_CLICK, this.listenerDeadClick);\n    }\n};\n\nAutocapture.prototype.initInputTracking = function() {\n    win.removeEventListener(EV_CHANGE, this.listenerChange);\n\n    if (!this.getConfig(CONFIG_TRACK_INPUT)) {\n        return;\n    }\n    logger$1.log('Initializing input tracking');\n\n    this.listenerChange = function(ev) {\n        if (!this.getConfig(CONFIG_TRACK_INPUT)) {\n            return;\n        }\n        this.trackDomEvent(ev, MP_EV_INPUT);\n    }.bind(this);\n    win.addEventListener(EV_CHANGE, this.listenerChange);\n};\n\nAutocapture.prototype.initPageviewTracking = function() {\n    win.removeEventListener(EV_MP_LOCATION_CHANGE, this.listenerLocationchange);\n\n    if (!this.pageviewTrackingConfig()) {\n        return;\n    }\n    logger$1.log('Initializing pageview tracking');\n\n    var previousTrackedUrl = '';\n    var tracked = false;\n    if (!this.currentUrlBlocked()) {\n        tracked = this.mp.track_pageview(DEFAULT_PROPS);\n    }\n    if (tracked) {\n        previousTrackedUrl = _.info.currentUrl();\n    }\n\n    this.listenerLocationchange = safewrap(function() {\n        if (this.currentUrlBlocked()) {\n            return;\n        }\n\n        var currentUrl = _.info.currentUrl();\n        var shouldTrack = false;\n        var didPathChange = currentUrl.split('#')[0].split('?')[0] !== previousTrackedUrl.split('#')[0].split('?')[0];\n        var trackPageviewOption = this.pageviewTrackingConfig();\n        if (trackPageviewOption === PAGEVIEW_OPTION_FULL_URL) {\n            shouldTrack = currentUrl !== previousTrackedUrl;\n        } else if (trackPageviewOption === PAGEVIEW_OPTION_URL_WITH_PATH_AND_QUERY_STRING) {\n            shouldTrack = currentUrl.split('#')[0] !== previousTrackedUrl.split('#')[0];\n        } else if (trackPageviewOption === PAGEVIEW_OPTION_URL_WITH_PATH) {\n            shouldTrack = didPathChange;\n        }\n\n        if (shouldTrack) {\n            var tracked = this.mp.track_pageview(DEFAULT_PROPS);\n            if (tracked) {\n                previousTrackedUrl = currentUrl;\n            }\n            if (didPathChange) {\n                this.lastScrollCheckpoint = 0;\n                logger$1.log('Path change: re-initializing scroll depth checkpoints');\n            }\n        }\n    }.bind(this));\n    win.addEventListener(EV_MP_LOCATION_CHANGE, this.listenerLocationchange);\n};\n\nAutocapture.prototype.initRageClickTracking = function() {\n    win.removeEventListener(EV_CLICK, this.listenerRageClick);\n\n    var rageClickConfig = this._getClickTrackingConfig(CONFIG_TRACK_RAGE_CLICK);\n    if (!rageClickConfig && !this.mp.get_config('record_heatmap_data')) {\n        return;\n    }\n\n    logger$1.log('Initializing rage click tracking');\n    if (!this._rageClickTracker) {\n        this._rageClickTracker = new RageClickTracker();\n    }\n\n    this.listenerRageClick = function(ev) {\n        var currentRageClickConfig = this._getClickTrackingConfig(CONFIG_TRACK_RAGE_CLICK);\n        if (!currentRageClickConfig && !this.mp.is_recording_heatmap_data()) {\n            return;\n        }\n\n        if (this.currentUrlBlocked()) {\n            return;\n        }\n\n        if (this._rageClickTracker.isRageClick(ev, currentRageClickConfig)) {\n            this.trackDomEvent(ev, MP_EV_RAGE_CLICK);\n        }\n    }.bind(this);\n    win.addEventListener(EV_CLICK, this.listenerRageClick);\n};\n\nAutocapture.prototype.initScrollTracking = function() {\n    win.removeEventListener(EV_SCROLLEND, this.listenerScroll);\n    win.removeEventListener(EV_SCROLL, this.listenerScroll);\n\n\n    if (!this.getConfig(CONFIG_TRACK_SCROLL)) {\n        return;\n    }\n    logger$1.log('Initializing scroll tracking');\n    this.lastScrollCheckpoint = 0;\n\n    var scrollTrackFunction = function() {\n        if (!this.getConfig(CONFIG_TRACK_SCROLL)) {\n            return;\n        }\n        if (this.currentUrlBlocked()) {\n            return;\n        }\n\n        var shouldTrack = this.getConfig(CONFIG_SCROLL_CAPTURE_ALL);\n        var scrollCheckpoints = (this.getConfig(CONFIG_SCROLL_CHECKPOINTS) || [])\n            .slice()\n            .sort(function(a, b) { return a - b; });\n\n        var scrollTop = win.scrollY;\n        var props = _.extend({'$scroll_top': scrollTop}, DEFAULT_PROPS);\n        try {\n            var scrollHeight = document$1.body.scrollHeight;\n            var scrollPercentage = Math.round((scrollTop / (scrollHeight - win.innerHeight)) * 100);\n            props['$scroll_height'] = scrollHeight;\n            props['$scroll_percentage'] = scrollPercentage;\n            if (scrollPercentage > this.lastScrollCheckpoint) {\n                for (var i = 0; i < scrollCheckpoints.length; i++) {\n                    var checkpoint = scrollCheckpoints[i];\n                    if (\n                        scrollPercentage >= checkpoint &&\n                        this.lastScrollCheckpoint < checkpoint\n                    ) {\n                        props['$scroll_checkpoint'] = checkpoint;\n                        this.lastScrollCheckpoint = checkpoint;\n                        shouldTrack = true;\n                    }\n                }\n            }\n        } catch (err) {\n            logger$1.critical('Error while calculating scroll percentage', err);\n        }\n        if (shouldTrack) {\n            this.mp.track(MP_EV_SCROLL, props);\n        }\n    }.bind(this);\n\n    var scrollEndPolyfill = getPolyfillScrollEndFunction(scrollTrackFunction);\n    this.listenerScroll = scrollEndPolyfill.listener;\n    win.addEventListener(scrollEndPolyfill.eventType, this.listenerScroll);\n};\n\nAutocapture.prototype.initSubmitTracking = function() {\n    win.removeEventListener(EV_SUBMIT, this.listenerSubmit);\n\n    if (!this.getConfig(CONFIG_TRACK_SUBMIT)) {\n        return;\n    }\n    logger$1.log('Initializing submit tracking');\n\n    this.listenerSubmit = function(ev) {\n        if (!this.getConfig(CONFIG_TRACK_SUBMIT)) {\n            return;\n        }\n        this.trackDomEvent(ev, MP_EV_SUBMIT);\n    }.bind(this);\n    win.addEventListener(EV_SUBMIT, this.listenerSubmit);\n};\n\nAutocapture.prototype.initPageLeaveTracking = function() {\n    // Capture page_leave both when the user navigates away from the page (visibilitychange) as well\n    // as when they navigate to a different page within the SPA (popstate/pushstate/hashchange).\n    document$1.removeEventListener(EV_VISIBILITYCHANGE, this.listenerPageLeaveVisibilitychange);\n    win.removeEventListener(EV_MP_LOCATION_CHANGE, this.listenerPageLeaveLocationchange);\n    win.removeEventListener(EV_LOAD, this.listenerPageLoad);\n\n    if (!this.getConfig(CONFIG_TRACK_PAGE_LEAVE) && !this.mp.get_config('record_heatmap_data')) {\n        return;\n    }\n\n    logger$1.log('Initializing page visibility tracking.');\n    this._initScrollDepthTracking();\n    var previousTrackedUrl = _.info.currentUrl();\n\n    // Initialize previousScrollHeight on `load` which handles async loading\n    // https://developer.mozilla.org/en-US/docs/Web/API/Window/load_event\n    this.listenerPageLoad = function() {\n        this.previousScrollHeight = document$1.body.scrollHeight;\n    }.bind(this);\n    win.addEventListener(EV_LOAD, this.listenerPageLoad);\n\n    // Track page navigation events similar to how initPageviewTracking does it\n    this.listenerPageLeaveLocationchange = safewrap(function(ev) {\n        if (this.currentUrlBlocked()) {\n            return;\n        }\n\n        var currentUrl = _.info.currentUrl();\n        // Track all URL changes including query string or fragment changes as separate scroll sessions\n        var shouldTrack = currentUrl !== previousTrackedUrl;\n\n        if (shouldTrack) {\n            this._trackPageLeave(ev, previousTrackedUrl, this.previousScrollHeight);\n            previousTrackedUrl = currentUrl;\n            // Fragment navigation should call scroll(end) and trigger listener, don't add window.scrollY here.\n            this.maxScrollViewDepth = Math.max(document$1.documentElement.clientHeight, win.innerHeight || 0);\n            this.previousScrollHeight = document$1.body.scrollHeight;\n            this.hasTrackedScrollSession = false;\n        }\n    }.bind(this));\n    win.addEventListener(EV_MP_LOCATION_CHANGE, this.listenerPageLeaveLocationchange);\n\n    this.listenerPageLeaveVisibilitychange = function(ev) {\n        if (document$1.hidden) {\n            this._trackPageLeave(ev, previousTrackedUrl, this.previousScrollHeight);\n        }\n    }.bind(this);\n    document$1.addEventListener(EV_VISIBILITYCHANGE, this.listenerPageLeaveVisibilitychange);\n};\n\nAutocapture.prototype.stopDeadClickTracking = function() {\n    if (this.listenerDeadClick) {\n        win.removeEventListener(EV_CLICK, this.listenerDeadClick);\n        this.listenerDeadClick = null;\n    }\n\n    if (this._deadClickTracker) {\n        this._deadClickTracker.stopTracking();\n        this._deadClickTracker = null;\n    }\n};\n\n// TODO integrate error_reporter from mixpanel instance\nsafewrapClass(Autocapture);\n\nvar logger = console_with_prefix('flags');\n\nvar FLAGS_CONFIG_KEY = 'flags';\n\nvar CONFIG_CONTEXT = 'context';\nvar CONFIG_DEFAULTS = {};\nCONFIG_DEFAULTS[CONFIG_CONTEXT] = {};\n\n/**\n * FeatureFlagManager: support for Mixpanel's feature flagging product\n * @constructor\n */\nvar FeatureFlagManager = function(initOptions) {\n    this.fetch = win['fetch'];\n    this.getFullApiRoute = initOptions.getFullApiRoute;\n    this.getMpConfig = initOptions.getConfigFunc;\n    this.setMpConfig = initOptions.setConfigFunc;\n    this.getMpProperty = initOptions.getPropertyFunc;\n    this.track = initOptions.trackingFunc;\n};\n\nFeatureFlagManager.prototype.init = function() {\n    if (!this.minApisSupported()) {\n        logger.critical('Feature Flags unavailable: missing minimum required APIs');\n        return;\n    }\n\n    this.flags = null;\n    this.fetchFlags();\n\n    this.trackedFeatures = new Set();\n};\n\nFeatureFlagManager.prototype.getFullConfig = function() {\n    var ffConfig = this.getMpConfig(FLAGS_CONFIG_KEY);\n    if (!ffConfig) {\n        // flags are completely off\n        return {};\n    } else if (_.isObject(ffConfig)) {\n        return _.extend({}, CONFIG_DEFAULTS, ffConfig);\n    } else {\n        // config is non-object truthy value, return default\n        return CONFIG_DEFAULTS;\n    }\n};\n\nFeatureFlagManager.prototype.getConfig = function(key) {\n    return this.getFullConfig()[key];\n};\n\nFeatureFlagManager.prototype.isSystemEnabled = function() {\n    return !!this.getMpConfig(FLAGS_CONFIG_KEY);\n};\n\nFeatureFlagManager.prototype.updateContext = function(newContext, options) {\n    if (!this.isSystemEnabled()) {\n        logger.critical('Feature Flags not enabled, cannot update context');\n        return Promise.resolve();\n    }\n\n    var ffConfig = this.getMpConfig(FLAGS_CONFIG_KEY);\n    if (!_.isObject(ffConfig)) {\n        ffConfig = {};\n    }\n    var oldContext = (options && options['replace']) ? {} : this.getConfig(CONFIG_CONTEXT);\n    ffConfig[CONFIG_CONTEXT] = _.extend({}, oldContext, newContext);\n\n    this.setMpConfig(FLAGS_CONFIG_KEY, ffConfig);\n    return this.fetchFlags();\n};\n\nFeatureFlagManager.prototype.areFlagsReady = function() {\n    if (!this.isSystemEnabled()) {\n        logger.error('Feature Flags not enabled');\n    }\n    return !!this.flags;\n};\n\nFeatureFlagManager.prototype.fetchFlags = function() {\n    if (!this.isSystemEnabled()) {\n        return Promise.resolve();\n    }\n\n    var distinctId = this.getMpProperty('distinct_id');\n    var deviceId = this.getMpProperty('$device_id');\n    var traceparent = generateTraceparent();\n    logger.log('Fetching flags for distinct ID: ' + distinctId);\n\n    var context = _.extend({'distinct_id': distinctId, 'device_id': deviceId}, this.getConfig(CONFIG_CONTEXT));\n    var searchParams = new URLSearchParams();\n    searchParams.set('context', JSON.stringify(context));\n    searchParams.set('token', this.getMpConfig('token'));\n    searchParams.set('mp_lib', 'web');\n    searchParams.set('$lib_version', Config.LIB_VERSION);\n    var url = this.getFullApiRoute() + '?' + searchParams.toString();\n\n    this._fetchInProgressStartTime = Date.now();\n    this.fetchPromise = this.fetch.call(win, url, {\n        'method': 'GET',\n        'headers': {\n            'Authorization': 'Basic ' + btoa(this.getMpConfig('token') + ':'),\n            'traceparent': traceparent\n        }\n    }).then(function(response) {\n        this.markFetchComplete();\n        return response.json().then(function(responseBody) {\n            var responseFlags = responseBody['flags'];\n            if (!responseFlags) {\n                throw new Error('No flags in API response');\n            }\n            var flags = new Map();\n            _.each(responseFlags, function(data, key) {\n                flags.set(key, {\n                    'key': data['variant_key'],\n                    'value': data['variant_value'],\n                    'experiment_id': data['experiment_id'],\n                    'is_experiment_active': data['is_experiment_active'],\n                    'is_qa_tester': data['is_qa_tester']\n                });\n            });\n            this.flags = flags;\n            this._traceparent = traceparent;\n        }.bind(this)).catch(function(error) {\n            this.markFetchComplete();\n            logger.error(error);\n        }.bind(this));\n    }.bind(this)).catch(function(error) {\n        this.markFetchComplete();\n        logger.error(error);\n    }.bind(this));\n\n    return this.fetchPromise;\n};\n\nFeatureFlagManager.prototype.markFetchComplete = function() {\n    if (!this._fetchInProgressStartTime) {\n        logger.error('Fetch in progress started time not set, cannot mark fetch complete');\n        return;\n    }\n    this._fetchStartTime = this._fetchInProgressStartTime;\n    this._fetchCompleteTime = Date.now();\n    this._fetchLatency = this._fetchCompleteTime - this._fetchStartTime;\n    this._fetchInProgressStartTime = null;\n};\n\nFeatureFlagManager.prototype.getVariant = function(featureName, fallback) {\n    if (!this.fetchPromise) {\n        return new Promise(function(resolve) {\n            logger.critical('Feature Flags not initialized');\n            resolve(fallback);\n        });\n    }\n\n    return this.fetchPromise.then(function() {\n        return this.getVariantSync(featureName, fallback);\n    }.bind(this)).catch(function(error) {\n        logger.error(error);\n        return fallback;\n    });\n};\n\nFeatureFlagManager.prototype.getVariantSync = function(featureName, fallback) {\n    if (!this.areFlagsReady()) {\n        logger.log('Flags not loaded yet');\n        return fallback;\n    }\n    var feature = this.flags.get(featureName);\n    if (!feature) {\n        logger.log('No flag found: \"' + featureName + '\"');\n        return fallback;\n    }\n    this.trackFeatureCheck(featureName, feature);\n    return feature;\n};\n\nFeatureFlagManager.prototype.getVariantValue = function(featureName, fallbackValue) {\n    return this.getVariant(featureName, {'value': fallbackValue}).then(function(feature) {\n        return feature['value'];\n    }).catch(function(error) {\n        logger.error(error);\n        return fallbackValue;\n    });\n};\n\n// TODO remove deprecated method\nFeatureFlagManager.prototype.getFeatureData = function(featureName, fallbackValue) {\n    logger.critical('mixpanel.flags.get_feature_data() is deprecated and will be removed in a future release. Use mixpanel.flags.get_variant_value() instead.');\n    return this.getVariantValue(featureName, fallbackValue);\n};\n\nFeatureFlagManager.prototype.getVariantValueSync = function(featureName, fallbackValue) {\n    return this.getVariantSync(featureName, {'value': fallbackValue})['value'];\n};\n\nFeatureFlagManager.prototype.isEnabled = function(featureName, fallbackValue) {\n    return this.getVariantValue(featureName).then(function() {\n        return this.isEnabledSync(featureName, fallbackValue);\n    }.bind(this)).catch(function(error) {\n        logger.error(error);\n        return fallbackValue;\n    });\n};\n\nFeatureFlagManager.prototype.isEnabledSync = function(featureName, fallbackValue) {\n    fallbackValue = fallbackValue || false;\n    var val = this.getVariantValueSync(featureName, fallbackValue);\n    if (val !== true && val !== false) {\n        logger.error('Feature flag \"' + featureName + '\" value: ' + val + ' is not a boolean; returning fallback value: ' + fallbackValue);\n        val = fallbackValue;\n    }\n    return val;\n};\n\nFeatureFlagManager.prototype.trackFeatureCheck = function(featureName, feature) {\n    if (this.trackedFeatures.has(featureName)) {\n        return;\n    }\n    this.trackedFeatures.add(featureName);\n\n    var trackingProperties = {\n        'Experiment name': featureName,\n        'Variant name': feature['key'],\n        '$experiment_type': 'feature_flag',\n        'Variant fetch start time': new Date(this._fetchStartTime).toISOString(),\n        'Variant fetch complete time': new Date(this._fetchCompleteTime).toISOString(),\n        'Variant fetch latency (ms)': this._fetchLatency,\n        'Variant fetch traceparent': this._traceparent,\n    };\n\n    if (feature['experiment_id'] !== 'undefined') {\n        trackingProperties['$experiment_id'] = feature['experiment_id'];\n    }\n    if (feature['is_experiment_active'] !== 'undefined') {\n        trackingProperties['$is_experiment_active'] = feature['is_experiment_active'];\n    }\n    if (feature['is_qa_tester'] !== 'undefined') {\n        trackingProperties['$is_qa_tester'] = feature['is_qa_tester'];\n    }\n\n    this.track('$experiment_started', trackingProperties);\n};\n\nFeatureFlagManager.prototype.minApisSupported = function() {\n    return !!this.fetch &&\n      typeof Promise !== 'undefined' &&\n      typeof Map !== 'undefined' &&\n      typeof Set !== 'undefined';\n};\n\nsafewrapClass(FeatureFlagManager);\n\nFeatureFlagManager.prototype['are_flags_ready'] = FeatureFlagManager.prototype.areFlagsReady;\nFeatureFlagManager.prototype['get_variant'] = FeatureFlagManager.prototype.getVariant;\nFeatureFlagManager.prototype['get_variant_sync'] = FeatureFlagManager.prototype.getVariantSync;\nFeatureFlagManager.prototype['get_variant_value'] = FeatureFlagManager.prototype.getVariantValue;\nFeatureFlagManager.prototype['get_variant_value_sync'] = FeatureFlagManager.prototype.getVariantValueSync;\nFeatureFlagManager.prototype['is_enabled'] = FeatureFlagManager.prototype.isEnabled;\nFeatureFlagManager.prototype['is_enabled_sync'] = FeatureFlagManager.prototype.isEnabledSync;\nFeatureFlagManager.prototype['update_context'] = FeatureFlagManager.prototype.updateContext;\n\n// Deprecated method\nFeatureFlagManager.prototype['get_feature_data'] = FeatureFlagManager.prototype.getFeatureData;\n\n/* eslint camelcase: \"off\" */\n\n\n/**\n * DomTracker Object\n * @constructor\n */\nvar DomTracker = function() {};\n\n\n// interface\nDomTracker.prototype.create_properties = function() {};\nDomTracker.prototype.event_handler = function() {};\nDomTracker.prototype.after_track_handler = function() {};\n\nDomTracker.prototype.init = function(mixpanel_instance) {\n    this.mp = mixpanel_instance;\n    return this;\n};\n\n/**\n * @param {Object|string} query\n * @param {string} event_name\n * @param {Object=} properties\n * @param {function=} user_callback\n */\nDomTracker.prototype.track = function(query, event_name, properties, user_callback) {\n    var that = this;\n    var elements = _.dom_query(query);\n\n    if (elements.length === 0) {\n        console$1.error('The DOM query (' + query + ') returned 0 elements');\n        return;\n    }\n\n    _.each(elements, function(element) {\n        _.register_event(element, this.override_event, function(e) {\n            var options = {};\n            var props = that.create_properties(properties, this);\n            var timeout = that.mp.get_config('track_links_timeout');\n\n            that.event_handler(e, this, options);\n\n            // in case the mixpanel servers don't get back to us in time\n            window.setTimeout(that.track_callback(user_callback, props, options, true), timeout);\n\n            // fire the tracking event\n            that.mp.track(event_name, props, that.track_callback(user_callback, props, options));\n        });\n    }, this);\n\n    return true;\n};\n\n/**\n * @param {function} user_callback\n * @param {Object} props\n * @param {boolean=} timeout_occured\n */\nDomTracker.prototype.track_callback = function(user_callback, props, options, timeout_occured) {\n    timeout_occured = timeout_occured || false;\n    var that = this;\n\n    return function() {\n        // options is referenced from both callbacks, so we can have\n        // a 'lock' of sorts to ensure only one fires\n        if (options.callback_fired) { return; }\n        options.callback_fired = true;\n\n        if (user_callback && user_callback(timeout_occured, props) === false) {\n            // user can prevent the default functionality by\n            // returning false from their callback\n            return;\n        }\n\n        that.after_track_handler(props, options, timeout_occured);\n    };\n};\n\nDomTracker.prototype.create_properties = function(properties, element) {\n    var props;\n\n    if (typeof(properties) === 'function') {\n        props = properties(element);\n    } else {\n        props = _.extend({}, properties);\n    }\n\n    return props;\n};\n\n/**\n * LinkTracker Object\n * @constructor\n * @extends DomTracker\n */\nvar LinkTracker = function() {\n    this.override_event = 'click';\n};\n_.inherit(LinkTracker, DomTracker);\n\nLinkTracker.prototype.create_properties = function(properties, element) {\n    var props = LinkTracker.superclass.create_properties.apply(this, arguments);\n\n    if (element.href) { props['url'] = element.href; }\n\n    return props;\n};\n\nLinkTracker.prototype.event_handler = function(evt, element, options) {\n    options.new_tab = (\n        evt.which === 2 ||\n        evt.metaKey ||\n        evt.ctrlKey ||\n        element.target === '_blank'\n    );\n    options.href = element.href;\n\n    if (!options.new_tab) {\n        evt.preventDefault();\n    }\n};\n\nLinkTracker.prototype.after_track_handler = function(props, options) {\n    if (options.new_tab) { return; }\n\n    setTimeout(function() {\n        window.location = options.href;\n    }, 0);\n};\n\n/**\n * FormTracker Object\n * @constructor\n * @extends DomTracker\n */\nvar FormTracker = function() {\n    this.override_event = 'submit';\n};\n_.inherit(FormTracker, DomTracker);\n\nFormTracker.prototype.event_handler = function(evt, element, options) {\n    options.element = element;\n    evt.preventDefault();\n};\n\nFormTracker.prototype.after_track_handler = function(props, options) {\n    setTimeout(function() {\n        options.element.submit();\n    }, 0);\n};\n\n/* eslint camelcase: \"off\" */\n\n\n/** @const */ var SET_ACTION      = '$set';\n/** @const */ var SET_ONCE_ACTION = '$set_once';\n/** @const */ var UNSET_ACTION    = '$unset';\n/** @const */ var ADD_ACTION      = '$add';\n/** @const */ var APPEND_ACTION   = '$append';\n/** @const */ var UNION_ACTION    = '$union';\n/** @const */ var REMOVE_ACTION   = '$remove';\n/** @const */ var DELETE_ACTION   = '$delete';\n\n// Common internal methods for mixpanel.people and mixpanel.group APIs.\n// These methods shouldn't involve network I/O.\nvar apiActions = {\n    set_action: function(prop, to) {\n        var data = {};\n        var $set = {};\n        if (_.isObject(prop)) {\n            _.each(prop, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $set[k] = v;\n                }\n            }, this);\n        } else {\n            $set[prop] = to;\n        }\n\n        data[SET_ACTION] = $set;\n        return data;\n    },\n\n    unset_action: function(prop) {\n        var data = {};\n        var $unset = [];\n        if (!_.isArray(prop)) {\n            prop = [prop];\n        }\n\n        _.each(prop, function(k) {\n            if (!this._is_reserved_property(k)) {\n                $unset.push(k);\n            }\n        }, this);\n\n        data[UNSET_ACTION] = $unset;\n        return data;\n    },\n\n    set_once_action: function(prop, to) {\n        var data = {};\n        var $set_once = {};\n        if (_.isObject(prop)) {\n            _.each(prop, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $set_once[k] = v;\n                }\n            }, this);\n        } else {\n            $set_once[prop] = to;\n        }\n        data[SET_ONCE_ACTION] = $set_once;\n        return data;\n    },\n\n    union_action: function(list_name, values) {\n        var data = {};\n        var $union = {};\n        if (_.isObject(list_name)) {\n            _.each(list_name, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $union[k] = _.isArray(v) ? v : [v];\n                }\n            }, this);\n        } else {\n            $union[list_name] = _.isArray(values) ? values : [values];\n        }\n        data[UNION_ACTION] = $union;\n        return data;\n    },\n\n    append_action: function(list_name, value) {\n        var data = {};\n        var $append = {};\n        if (_.isObject(list_name)) {\n            _.each(list_name, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $append[k] = v;\n                }\n            }, this);\n        } else {\n            $append[list_name] = value;\n        }\n        data[APPEND_ACTION] = $append;\n        return data;\n    },\n\n    remove_action: function(list_name, value) {\n        var data = {};\n        var $remove = {};\n        if (_.isObject(list_name)) {\n            _.each(list_name, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $remove[k] = v;\n                }\n            }, this);\n        } else {\n            $remove[list_name] = value;\n        }\n        data[REMOVE_ACTION] = $remove;\n        return data;\n    },\n\n    delete_action: function() {\n        var data = {};\n        data[DELETE_ACTION] = '';\n        return data;\n    }\n};\n\n/* eslint camelcase: \"off\" */\n\n/**\n * Mixpanel Group Object\n * @constructor\n */\nvar MixpanelGroup = function() {};\n\n_.extend(MixpanelGroup.prototype, apiActions);\n\nMixpanelGroup.prototype._init = function(mixpanel_instance, group_key, group_id) {\n    this._mixpanel = mixpanel_instance;\n    this._group_key = group_key;\n    this._group_id = group_id;\n};\n\n/**\n * Set properties on a group.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').set('Location', '405 Howard');\n *\n *     // or set multiple properties at once\n *     mixpanel.get_group('company', 'mixpanel').set({\n *          'Location': '405 Howard',\n *          'Founded' : 2009,\n *     });\n *     // properties can be strings, integers, dates, or lists\n *\n * @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n * @param {*} [to] A value to set on the given property name\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.set = addOptOutCheckMixpanelGroup(function(prop, to, callback) {\n    var data = this.set_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    return this._send_request(data, callback);\n});\n\n/**\n * Set properties on a group, only if they do not yet exist.\n * This will not overwrite previous group property values, unlike\n * group.set().\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').set_once('Location', '405 Howard');\n *\n *     // or set multiple properties at once\n *     mixpanel.get_group('company', 'mixpanel').set_once({\n *          'Location': '405 Howard',\n *          'Founded' : 2009,\n *     });\n *     // properties can be strings, integers, lists or dates\n *\n * @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n * @param {*} [to] A value to set on the given property name\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.set_once = addOptOutCheckMixpanelGroup(function(prop, to, callback) {\n    var data = this.set_once_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    return this._send_request(data, callback);\n});\n\n/**\n * Unset properties on a group permanently.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').unset('Founded');\n *\n * @param {String} prop The name of the property.\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.unset = addOptOutCheckMixpanelGroup(function(prop, callback) {\n    var data = this.unset_action(prop);\n    return this._send_request(data, callback);\n});\n\n/**\n * Merge a given list with a list-valued group property, excluding duplicate values.\n *\n * ### Usage:\n *\n *     // merge a value to a list, creating it if needed\n *     mixpanel.get_group('company', 'mixpanel').union('Location', ['San Francisco', 'London']);\n *\n * @param {String} list_name Name of the property.\n * @param {Array} values Values to merge with the given property\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.union = addOptOutCheckMixpanelGroup(function(list_name, values, callback) {\n    if (_.isObject(list_name)) {\n        callback = values;\n    }\n    var data = this.union_action(list_name, values);\n    return this._send_request(data, callback);\n});\n\n/**\n * Permanently delete a group.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').delete();\n *\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype['delete'] = addOptOutCheckMixpanelGroup(function(callback) {\n    // bracket notation above prevents a minification error related to reserved words\n    var data = this.delete_action();\n    return this._send_request(data, callback);\n});\n\n/**\n * Remove a property from a group. The value will be ignored if doesn't exist.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').remove('Location', 'London');\n *\n * @param {String} list_name Name of the property.\n * @param {Object} value Value to remove from the given group property\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.remove = addOptOutCheckMixpanelGroup(function(list_name, value, callback) {\n    var data = this.remove_action(list_name, value);\n    return this._send_request(data, callback);\n});\n\nMixpanelGroup.prototype._send_request = function(data, callback) {\n    data['$group_key'] = this._group_key;\n    data['$group_id'] = this._group_id;\n    data['$token'] = this._get_config('token');\n\n    var date_encoded_data = _.encodeDates(data);\n    return this._mixpanel._track_or_batch({\n        type: 'groups',\n        data: date_encoded_data,\n        endpoint: this._mixpanel.get_api_host('groups') + '/' +  this._get_config('api_routes')['groups'],\n        batcher: this._mixpanel.request_batchers.groups\n    }, callback);\n};\n\nMixpanelGroup.prototype._is_reserved_property = function(prop) {\n    return prop === '$group_key' || prop === '$group_id';\n};\n\nMixpanelGroup.prototype._get_config = function(conf) {\n    return this._mixpanel.get_config(conf);\n};\n\nMixpanelGroup.prototype.toString = function() {\n    return this._mixpanel.toString() + '.group.' + this._group_key + '.' + this._group_id;\n};\n\n// MixpanelGroup Exports\nMixpanelGroup.prototype['remove']   = MixpanelGroup.prototype.remove;\nMixpanelGroup.prototype['set']      = MixpanelGroup.prototype.set;\nMixpanelGroup.prototype['set_once'] = MixpanelGroup.prototype.set_once;\nMixpanelGroup.prototype['union']    = MixpanelGroup.prototype.union;\nMixpanelGroup.prototype['unset']    = MixpanelGroup.prototype.unset;\nMixpanelGroup.prototype['toString'] = MixpanelGroup.prototype.toString;\n\n/* eslint camelcase: \"off\" */\n\n/**\n * Mixpanel People Object\n * @constructor\n */\nvar MixpanelPeople = function() {};\n\n_.extend(MixpanelPeople.prototype, apiActions);\n\nMixpanelPeople.prototype._init = function(mixpanel_instance) {\n    this._mixpanel = mixpanel_instance;\n};\n\n/*\n* Set properties on a user record.\n*\n* ### Usage:\n*\n*     mixpanel.people.set('gender', 'm');\n*\n*     // or set multiple properties at once\n*     mixpanel.people.set({\n*         'Company': 'Acme',\n*         'Plan': 'Premium',\n*         'Upgrade date': new Date()\n*     });\n*     // properties can be strings, integers, dates, or lists\n*\n* @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [to] A value to set on the given property name\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.set = addOptOutCheckMixpanelPeople(function(prop, to, callback) {\n    var data = this.set_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    // make sure that the referrer info has been updated and saved\n    if (this._get_config('save_referrer')) {\n        this._mixpanel['persistence'].update_referrer_info(document.referrer);\n    }\n\n    // update $set object with default people properties\n    data[SET_ACTION] = _.extend(\n        {},\n        _.info.people_properties(),\n        data[SET_ACTION]\n    );\n    return this._send_request(data, callback);\n});\n\n/*\n* Set properties on a user record, only if they do not yet exist.\n* This will not overwrite previous people property values, unlike\n* people.set().\n*\n* ### Usage:\n*\n*     mixpanel.people.set_once('First Login Date', new Date());\n*\n*     // or set multiple properties at once\n*     mixpanel.people.set_once({\n*         'First Login Date': new Date(),\n*         'Starting Plan': 'Premium'\n*     });\n*\n*     // properties can be strings, integers or dates\n*\n* @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [to] A value to set on the given property name\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.set_once = addOptOutCheckMixpanelPeople(function(prop, to, callback) {\n    var data = this.set_once_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    return this._send_request(data, callback);\n});\n\n/*\n* Unset properties on a user record (permanently removes the properties and their values from a profile).\n*\n* ### Usage:\n*\n*     mixpanel.people.unset('gender');\n*\n*     // or unset multiple properties at once\n*     mixpanel.people.unset(['gender', 'Company']);\n*\n* @param {Array|String} prop If a string, this is the name of the property. If an array, this is a list of property names.\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.unset = addOptOutCheckMixpanelPeople(function(prop, callback) {\n    var data = this.unset_action(prop);\n    return this._send_request(data, callback);\n});\n\n/*\n* Increment/decrement numeric people analytics properties.\n*\n* ### Usage:\n*\n*     mixpanel.people.increment('page_views', 1);\n*\n*     // or, for convenience, if you're just incrementing a counter by\n*     // 1, you can simply do\n*     mixpanel.people.increment('page_views');\n*\n*     // to decrement a counter, pass a negative number\n*     mixpanel.people.increment('credits_left', -1);\n*\n*     // like mixpanel.people.set(), you can increment multiple\n*     // properties at once:\n*     mixpanel.people.increment({\n*         counter1: 1,\n*         counter2: 6\n*     });\n*\n* @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and numeric values.\n* @param {Number} [by] An amount to increment the given property\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.increment = addOptOutCheckMixpanelPeople(function(prop, by, callback) {\n    var data = {};\n    var $add = {};\n    if (_.isObject(prop)) {\n        _.each(prop, function(v, k) {\n            if (!this._is_reserved_property(k)) {\n                if (isNaN(parseFloat(v))) {\n                    console$1.error('Invalid increment value passed to mixpanel.people.increment - must be a number');\n                    return;\n                } else {\n                    $add[k] = v;\n                }\n            }\n        }, this);\n        callback = by;\n    } else {\n        // convenience: mixpanel.people.increment('property'); will\n        // increment 'property' by 1\n        if (_.isUndefined(by)) {\n            by = 1;\n        }\n        $add[prop] = by;\n    }\n    data[ADD_ACTION] = $add;\n\n    return this._send_request(data, callback);\n});\n\n/*\n* Append a value to a list-valued people analytics property.\n*\n* ### Usage:\n*\n*     // append a value to a list, creating it if needed\n*     mixpanel.people.append('pages_visited', 'homepage');\n*\n*     // like mixpanel.people.set(), you can append multiple\n*     // properties at once:\n*     mixpanel.people.append({\n*         list1: 'bob',\n*         list2: 123\n*     });\n*\n* @param {Object|String} list_name If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [value] value An item to append to the list\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.append = addOptOutCheckMixpanelPeople(function(list_name, value, callback) {\n    if (_.isObject(list_name)) {\n        callback = value;\n    }\n    var data = this.append_action(list_name, value);\n    return this._send_request(data, callback);\n});\n\n/*\n* Remove a value from a list-valued people analytics property.\n*\n* ### Usage:\n*\n*     mixpanel.people.remove('School', 'UCB');\n*\n* @param {Object|String} list_name If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [value] value Item to remove from the list\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.remove = addOptOutCheckMixpanelPeople(function(list_name, value, callback) {\n    if (_.isObject(list_name)) {\n        callback = value;\n    }\n    var data = this.remove_action(list_name, value);\n    return this._send_request(data, callback);\n});\n\n/*\n* Merge a given list with a list-valued people analytics property,\n* excluding duplicate values.\n*\n* ### Usage:\n*\n*     // merge a value to a list, creating it if needed\n*     mixpanel.people.union('pages_visited', 'homepage');\n*\n*     // like mixpanel.people.set(), you can append multiple\n*     // properties at once:\n*     mixpanel.people.union({\n*         list1: 'bob',\n*         list2: 123\n*     });\n*\n*     // like mixpanel.people.append(), you can append multiple\n*     // values to the same list:\n*     mixpanel.people.union({\n*         list1: ['bob', 'billy']\n*     });\n*\n* @param {Object|String} list_name If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [value] Value / values to merge with the given property\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.union = addOptOutCheckMixpanelPeople(function(list_name, values, callback) {\n    if (_.isObject(list_name)) {\n        callback = values;\n    }\n    var data = this.union_action(list_name, values);\n    return this._send_request(data, callback);\n});\n\n/*\n * Record that you have charged the current user a certain amount\n * of money. Charges recorded with track_charge() will appear in the\n * Mixpanel revenue report.\n *\n * ### Usage:\n *\n *     // charge a user $50\n *     mixpanel.people.track_charge(50);\n *\n *     // charge a user $30.50 on the 2nd of january\n *     mixpanel.people.track_charge(30.50, {\n *         '$time': new Date('jan 1 2012')\n *     });\n *\n * @param {Number} amount The amount of money charged to the current user\n * @param {Object} [properties] An associative array of properties associated with the charge\n * @param {Function} [callback] If provided, the callback will be called when the server responds\n * @deprecated\n */\nMixpanelPeople.prototype.track_charge = addOptOutCheckMixpanelPeople(function() {\n    console$1.error('mixpanel.people.track_charge() is deprecated and no longer has any effect.');\n});\n\n/*\n * Permanently clear all revenue report transactions from the\n * current user's people analytics profile.\n *\n * ### Usage:\n *\n *     mixpanel.people.clear_charges();\n *\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n * @deprecated\n */\nMixpanelPeople.prototype.clear_charges = function(callback) {\n    return this.set('$transactions', [], callback);\n};\n\n/*\n* Permanently deletes the current people analytics profile from\n* Mixpanel (using the current distinct_id).\n*\n* ### Usage:\n*\n*     // remove the all data you have stored about the current user\n*     mixpanel.people.delete_user();\n*\n*/\nMixpanelPeople.prototype.delete_user = function() {\n    if (!this._identify_called()) {\n        console$1.error('mixpanel.people.delete_user() requires you to call identify() first');\n        return;\n    }\n    var data = {'$delete': this._mixpanel.get_distinct_id()};\n    return this._send_request(data);\n};\n\nMixpanelPeople.prototype.toString = function() {\n    return this._mixpanel.toString() + '.people';\n};\n\nMixpanelPeople.prototype._send_request = function(data, callback) {\n    data['$token'] = this._get_config('token');\n    data['$distinct_id'] = this._mixpanel.get_distinct_id();\n    var device_id = this._mixpanel.get_property('$device_id');\n    var user_id = this._mixpanel.get_property('$user_id');\n    var had_persisted_distinct_id = this._mixpanel.get_property('$had_persisted_distinct_id');\n    if (device_id) {\n        data['$device_id'] = device_id;\n    }\n    if (user_id) {\n        data['$user_id'] = user_id;\n    }\n    if (had_persisted_distinct_id) {\n        data['$had_persisted_distinct_id'] = had_persisted_distinct_id;\n    }\n\n    var date_encoded_data = _.encodeDates(data);\n\n    if (!this._identify_called()) {\n        this._enqueue(data);\n        if (!_.isUndefined(callback)) {\n            if (this._get_config('verbose')) {\n                callback({status: -1, error: null});\n            } else {\n                callback(-1);\n            }\n        }\n        return _.truncate(date_encoded_data, 255);\n    }\n\n    return this._mixpanel._track_or_batch({\n        type: 'people',\n        data: date_encoded_data,\n        endpoint: this._mixpanel.get_api_host('people') + '/' +  this._get_config('api_routes')['engage'],\n        batcher: this._mixpanel.request_batchers.people\n    }, callback);\n};\n\nMixpanelPeople.prototype._get_config = function(conf_var) {\n    return this._mixpanel.get_config(conf_var);\n};\n\nMixpanelPeople.prototype._identify_called = function() {\n    return this._mixpanel._flags.identify_called === true;\n};\n\n// Queue up engage operations if identify hasn't been called yet.\nMixpanelPeople.prototype._enqueue = function(data) {\n    if (SET_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(SET_ACTION, data);\n    } else if (SET_ONCE_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(SET_ONCE_ACTION, data);\n    } else if (UNSET_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(UNSET_ACTION, data);\n    } else if (ADD_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(ADD_ACTION, data);\n    } else if (APPEND_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(APPEND_ACTION, data);\n    } else if (REMOVE_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(REMOVE_ACTION, data);\n    } else if (UNION_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(UNION_ACTION, data);\n    } else {\n        console$1.error('Invalid call to _enqueue():', data);\n    }\n};\n\nMixpanelPeople.prototype._flush_one_queue = function(action, action_method, callback, queue_to_params_fn) {\n    var _this = this;\n    var queued_data = _.extend({}, this._mixpanel['persistence'].load_queue(action));\n    var action_params = queued_data;\n\n    if (!_.isUndefined(queued_data) && _.isObject(queued_data) && !_.isEmptyObject(queued_data)) {\n        _this._mixpanel['persistence']._pop_from_people_queue(action, queued_data);\n        _this._mixpanel['persistence'].save();\n        if (queue_to_params_fn) {\n            action_params = queue_to_params_fn(queued_data);\n        }\n        action_method.call(_this, action_params, function(response, data) {\n            // on bad response, we want to add it back to the queue\n            if (response === 0) {\n                _this._mixpanel['persistence']._add_to_people_queue(action, queued_data);\n            }\n            if (!_.isUndefined(callback)) {\n                callback(response, data);\n            }\n        });\n    }\n};\n\n// Flush queued engage operations - order does not matter,\n// and there are network level race conditions anyway\nMixpanelPeople.prototype._flush = function(\n    _set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback\n) {\n    var _this = this;\n\n    this._flush_one_queue(SET_ACTION, this.set, _set_callback);\n    this._flush_one_queue(SET_ONCE_ACTION, this.set_once, _set_once_callback);\n    this._flush_one_queue(UNSET_ACTION, this.unset, _unset_callback, function(queue) { return _.keys(queue); });\n    this._flush_one_queue(ADD_ACTION, this.increment, _add_callback);\n    this._flush_one_queue(UNION_ACTION, this.union, _union_callback);\n\n    // we have to fire off each $append individually since there is\n    // no concat method server side\n    var $append_queue = this._mixpanel['persistence'].load_queue(APPEND_ACTION);\n    if (!_.isUndefined($append_queue) && _.isArray($append_queue) && $append_queue.length) {\n        var $append_item;\n        var append_callback = function(response, data) {\n            if (response === 0) {\n                _this._mixpanel['persistence']._add_to_people_queue(APPEND_ACTION, $append_item);\n            }\n            if (!_.isUndefined(_append_callback)) {\n                _append_callback(response, data);\n            }\n        };\n        for (var i = $append_queue.length - 1; i >= 0; i--) {\n            $append_queue = this._mixpanel['persistence'].load_queue(APPEND_ACTION);\n            $append_item = $append_queue.pop();\n            _this._mixpanel['persistence'].save();\n            if (!_.isEmptyObject($append_item)) {\n                _this.append($append_item, append_callback);\n            }\n        }\n    }\n\n    // same for $remove\n    var $remove_queue = this._mixpanel['persistence'].load_queue(REMOVE_ACTION);\n    if (!_.isUndefined($remove_queue) && _.isArray($remove_queue) && $remove_queue.length) {\n        var $remove_item;\n        var remove_callback = function(response, data) {\n            if (response === 0) {\n                _this._mixpanel['persistence']._add_to_people_queue(REMOVE_ACTION, $remove_item);\n            }\n            if (!_.isUndefined(_remove_callback)) {\n                _remove_callback(response, data);\n            }\n        };\n        for (var j = $remove_queue.length - 1; j >= 0; j--) {\n            $remove_queue = this._mixpanel['persistence'].load_queue(REMOVE_ACTION);\n            $remove_item = $remove_queue.pop();\n            _this._mixpanel['persistence'].save();\n            if (!_.isEmptyObject($remove_item)) {\n                _this.remove($remove_item, remove_callback);\n            }\n        }\n    }\n};\n\nMixpanelPeople.prototype._is_reserved_property = function(prop) {\n    return prop === '$distinct_id' || prop === '$token' || prop === '$device_id' || prop === '$user_id' || prop === '$had_persisted_distinct_id';\n};\n\n// MixpanelPeople Exports\nMixpanelPeople.prototype['set']           = MixpanelPeople.prototype.set;\nMixpanelPeople.prototype['set_once']      = MixpanelPeople.prototype.set_once;\nMixpanelPeople.prototype['unset']         = MixpanelPeople.prototype.unset;\nMixpanelPeople.prototype['increment']     = MixpanelPeople.prototype.increment;\nMixpanelPeople.prototype['append']        = MixpanelPeople.prototype.append;\nMixpanelPeople.prototype['remove']        = MixpanelPeople.prototype.remove;\nMixpanelPeople.prototype['union']         = MixpanelPeople.prototype.union;\nMixpanelPeople.prototype['track_charge']  = MixpanelPeople.prototype.track_charge;\nMixpanelPeople.prototype['clear_charges'] = MixpanelPeople.prototype.clear_charges;\nMixpanelPeople.prototype['delete_user']   = MixpanelPeople.prototype.delete_user;\nMixpanelPeople.prototype['toString']      = MixpanelPeople.prototype.toString;\n\n/* eslint camelcase: \"off\" */\n\n\n/*\n * Constants\n */\n/** @const */ var SET_QUEUE_KEY          = '__mps';\n/** @const */ var SET_ONCE_QUEUE_KEY     = '__mpso';\n/** @const */ var UNSET_QUEUE_KEY        = '__mpus';\n/** @const */ var ADD_QUEUE_KEY          = '__mpa';\n/** @const */ var APPEND_QUEUE_KEY       = '__mpap';\n/** @const */ var REMOVE_QUEUE_KEY       = '__mpr';\n/** @const */ var UNION_QUEUE_KEY        = '__mpu';\n// This key is deprecated, but we want to check for it to see whether aliasing is allowed.\n/** @const */ var PEOPLE_DISTINCT_ID_KEY = '$people_distinct_id';\n/** @const */ var ALIAS_ID_KEY           = '__alias';\n/** @const */ var EVENT_TIMERS_KEY       = '__timers';\n/** @const */ var RESERVED_PROPERTIES = [\n    SET_QUEUE_KEY,\n    SET_ONCE_QUEUE_KEY,\n    UNSET_QUEUE_KEY,\n    ADD_QUEUE_KEY,\n    APPEND_QUEUE_KEY,\n    REMOVE_QUEUE_KEY,\n    UNION_QUEUE_KEY,\n    PEOPLE_DISTINCT_ID_KEY,\n    ALIAS_ID_KEY,\n    EVENT_TIMERS_KEY\n];\n\n/**\n * Mixpanel Persistence Object\n * @constructor\n */\nvar MixpanelPersistence = function(config) {\n    this['props'] = {};\n    this.campaign_params_saved = false;\n\n    if (config['persistence_name']) {\n        this.name = 'mp_' + config['persistence_name'];\n    } else {\n        this.name = 'mp_' + config['token'] + '_mixpanel';\n    }\n\n    var storage_type = config['persistence'];\n    if (storage_type !== 'cookie' && storage_type !== 'localStorage') {\n        console$1.critical('Unknown persistence type ' + storage_type + '; falling back to cookie');\n        storage_type = config['persistence'] = 'cookie';\n    }\n\n    if (storage_type === 'localStorage' && _.localStorage.is_supported()) {\n        this.storage = _.localStorage;\n    } else {\n        this.storage = _.cookie;\n    }\n\n    this.load();\n    this.update_config(config);\n    this.upgrade();\n    this.save();\n};\n\nMixpanelPersistence.prototype.properties = function() {\n    var p = {};\n\n    this.load();\n\n    // Filter out reserved properties\n    _.each(this['props'], function(v, k) {\n        if (!_.include(RESERVED_PROPERTIES, k)) {\n            p[k] = v;\n        }\n    });\n    return p;\n};\n\nMixpanelPersistence.prototype.load = function() {\n    if (this.disabled) { return; }\n\n    var entry = this.storage.parse(this.name);\n\n    if (entry) {\n        this['props'] = _.extend({}, entry);\n    }\n};\n\nMixpanelPersistence.prototype.upgrade = function() {\n    var old_cookie,\n        old_localstorage;\n\n    // if transferring from cookie to localStorage or vice-versa, copy existing\n    // super properties over to new storage mode\n    if (this.storage === _.localStorage) {\n        old_cookie = _.cookie.parse(this.name);\n\n        _.cookie.remove(this.name);\n        _.cookie.remove(this.name, true);\n\n        if (old_cookie) {\n            this.register_once(old_cookie);\n        }\n    } else if (this.storage === _.cookie) {\n        old_localstorage = _.localStorage.parse(this.name);\n\n        _.localStorage.remove(this.name);\n\n        if (old_localstorage) {\n            this.register_once(old_localstorage);\n        }\n    }\n};\n\nMixpanelPersistence.prototype.save = function() {\n    if (this.disabled) { return; }\n\n    this.storage.set(\n        this.name,\n        JSONStringify(this['props']),\n        this.expire_days,\n        this.cross_subdomain,\n        this.secure,\n        this.cross_site,\n        this.cookie_domain\n    );\n};\n\nMixpanelPersistence.prototype.load_prop = function(key) {\n    this.load();\n    return this['props'][key];\n};\n\nMixpanelPersistence.prototype.remove = function() {\n    // remove both domain and subdomain cookies\n    this.storage.remove(this.name, false, this.cookie_domain);\n    this.storage.remove(this.name, true, this.cookie_domain);\n};\n\n// removes the storage entry and deletes all loaded data\n// forced name for tests\nMixpanelPersistence.prototype.clear = function() {\n    this.remove();\n    this['props'] = {};\n};\n\n/**\n* @param {Object} props\n* @param {*=} default_value\n* @param {number=} days\n*/\nMixpanelPersistence.prototype.register_once = function(props, default_value, days) {\n    if (_.isObject(props)) {\n        if (typeof(default_value) === 'undefined') { default_value = 'None'; }\n        this.expire_days = (typeof(days) === 'undefined') ? this.default_expiry : days;\n\n        this.load();\n\n        _.each(props, function(val, prop) {\n            if (!this['props'].hasOwnProperty(prop) || this['props'][prop] === default_value) {\n                this['props'][prop] = val;\n            }\n        }, this);\n\n        this.save();\n\n        return true;\n    }\n    return false;\n};\n\n/**\n* @param {Object} props\n* @param {number=} days\n*/\nMixpanelPersistence.prototype.register = function(props, days) {\n    if (_.isObject(props)) {\n        this.expire_days = (typeof(days) === 'undefined') ? this.default_expiry : days;\n\n        this.load();\n        _.extend(this['props'], props);\n        this.save();\n\n        return true;\n    }\n    return false;\n};\n\nMixpanelPersistence.prototype.unregister = function(prop) {\n    this.load();\n    if (prop in this['props']) {\n        delete this['props'][prop];\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.update_search_keyword = function(referrer) {\n    this.register(_.info.searchInfo(referrer));\n};\n\n// EXPORTED METHOD, we test this directly.\nMixpanelPersistence.prototype.update_referrer_info = function(referrer) {\n    // If referrer doesn't exist, we want to note the fact that it was type-in traffic.\n    this.register_once({\n        '$initial_referrer': referrer || '$direct',\n        '$initial_referring_domain': _.info.referringDomain(referrer) || '$direct'\n    }, '');\n};\n\nMixpanelPersistence.prototype.get_referrer_info = function() {\n    return _.strip_empty_properties({\n        '$initial_referrer': this['props']['$initial_referrer'],\n        '$initial_referring_domain': this['props']['$initial_referring_domain']\n    });\n};\n\nMixpanelPersistence.prototype.update_config = function(config) {\n    this.default_expiry = this.expire_days = config['cookie_expiration'];\n    this.set_disabled(config['disable_persistence']);\n    this.set_cookie_domain(config['cookie_domain']);\n    this.set_cross_site(config['cross_site_cookie']);\n    this.set_cross_subdomain(config['cross_subdomain_cookie']);\n    this.set_secure(config['secure_cookie']);\n};\n\nMixpanelPersistence.prototype.set_disabled = function(disabled) {\n    this.disabled = disabled;\n    if (this.disabled) {\n        this.remove();\n    } else {\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.set_cookie_domain = function(cookie_domain) {\n    if (cookie_domain !== this.cookie_domain) {\n        this.remove();\n        this.cookie_domain = cookie_domain;\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.set_cross_site = function(cross_site) {\n    if (cross_site !== this.cross_site) {\n        this.cross_site = cross_site;\n        this.remove();\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.set_cross_subdomain = function(cross_subdomain) {\n    if (cross_subdomain !== this.cross_subdomain) {\n        this.cross_subdomain = cross_subdomain;\n        this.remove();\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.get_cross_subdomain = function() {\n    return this.cross_subdomain;\n};\n\nMixpanelPersistence.prototype.set_secure = function(secure) {\n    if (secure !== this.secure) {\n        this.secure = secure ? true : false;\n        this.remove();\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype._add_to_people_queue = function(queue, data) {\n    var q_key = this._get_queue_key(queue),\n        q_data = data[queue],\n        set_q = this._get_or_create_queue(SET_ACTION),\n        set_once_q = this._get_or_create_queue(SET_ONCE_ACTION),\n        unset_q = this._get_or_create_queue(UNSET_ACTION),\n        add_q = this._get_or_create_queue(ADD_ACTION),\n        union_q = this._get_or_create_queue(UNION_ACTION),\n        remove_q = this._get_or_create_queue(REMOVE_ACTION, []),\n        append_q = this._get_or_create_queue(APPEND_ACTION, []);\n\n    if (q_key === SET_QUEUE_KEY) {\n        // Update the set queue - we can override any existing values\n        _.extend(set_q, q_data);\n        // if there was a pending increment, override it\n        // with the set.\n        this._pop_from_people_queue(ADD_ACTION, q_data);\n        // if there was a pending union, override it\n        // with the set.\n        this._pop_from_people_queue(UNION_ACTION, q_data);\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === SET_ONCE_QUEUE_KEY) {\n        // only queue the data if there is not already a set_once call for it.\n        _.each(q_data, function(v, k) {\n            if (!(k in set_once_q)) {\n                set_once_q[k] = v;\n            }\n        });\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === UNSET_QUEUE_KEY) {\n        _.each(q_data, function(prop) {\n\n            // undo previously-queued actions on this key\n            _.each([set_q, set_once_q, add_q, union_q], function(enqueued_obj) {\n                if (prop in enqueued_obj) {\n                    delete enqueued_obj[prop];\n                }\n            });\n            _.each(append_q, function(append_obj) {\n                if (prop in append_obj) {\n                    delete append_obj[prop];\n                }\n            });\n\n            unset_q[prop] = true;\n\n        });\n    } else if (q_key === ADD_QUEUE_KEY) {\n        _.each(q_data, function(v, k) {\n            // If it exists in the set queue, increment\n            // the value\n            if (k in set_q) {\n                set_q[k] += v;\n            } else {\n                // If it doesn't exist, update the add\n                // queue\n                if (!(k in add_q)) {\n                    add_q[k] = 0;\n                }\n                add_q[k] += v;\n            }\n        }, this);\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === UNION_QUEUE_KEY) {\n        _.each(q_data, function(v, k) {\n            if (_.isArray(v)) {\n                if (!(k in union_q)) {\n                    union_q[k] = [];\n                }\n                // Prevent duplicate values\n                _.each(v, function(item) {\n                    if (!_.include(union_q[k], item)) {\n                        union_q[k].push(item);\n                    }\n                });\n            }\n        });\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === REMOVE_QUEUE_KEY) {\n        remove_q.push(q_data);\n        this._pop_from_people_queue(APPEND_ACTION, q_data);\n    } else if (q_key === APPEND_QUEUE_KEY) {\n        append_q.push(q_data);\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    }\n\n    console$1.log('MIXPANEL PEOPLE REQUEST (QUEUED, PENDING IDENTIFY):');\n    console$1.log(data);\n\n    this.save();\n};\n\nMixpanelPersistence.prototype._pop_from_people_queue = function(queue, data) {\n    var q = this['props'][this._get_queue_key(queue)];\n    if (!_.isUndefined(q)) {\n        _.each(data, function(v, k) {\n            if (queue === APPEND_ACTION || queue === REMOVE_ACTION) {\n                // list actions: only remove if both k+v match\n                // e.g. remove should not override append in a case like\n                // append({foo: 'bar'}); remove({foo: 'qux'})\n                _.each(q, function(queued_action) {\n                    if (queued_action[k] === v) {\n                        delete queued_action[k];\n                    }\n                });\n            } else {\n                delete q[k];\n            }\n        }, this);\n    }\n};\n\nMixpanelPersistence.prototype.load_queue = function(queue) {\n    return this.load_prop(this._get_queue_key(queue));\n};\n\nMixpanelPersistence.prototype._get_queue_key = function(queue) {\n    if (queue === SET_ACTION) {\n        return SET_QUEUE_KEY;\n    } else if (queue === SET_ONCE_ACTION) {\n        return SET_ONCE_QUEUE_KEY;\n    } else if (queue === UNSET_ACTION) {\n        return UNSET_QUEUE_KEY;\n    } else if (queue === ADD_ACTION) {\n        return ADD_QUEUE_KEY;\n    } else if (queue === APPEND_ACTION) {\n        return APPEND_QUEUE_KEY;\n    } else if (queue === REMOVE_ACTION) {\n        return REMOVE_QUEUE_KEY;\n    } else if (queue === UNION_ACTION) {\n        return UNION_QUEUE_KEY;\n    } else {\n        console$1.error('Invalid queue:', queue);\n    }\n};\n\nMixpanelPersistence.prototype._get_or_create_queue = function(queue, default_val) {\n    var key = this._get_queue_key(queue);\n    default_val = _.isUndefined(default_val) ? {} : default_val;\n    return this['props'][key] || (this['props'][key] = default_val);\n};\n\nMixpanelPersistence.prototype.set_event_timer = function(event_name, timestamp) {\n    var timers = this.load_prop(EVENT_TIMERS_KEY) || {};\n    timers[event_name] = timestamp;\n    this['props'][EVENT_TIMERS_KEY] = timers;\n    this.save();\n};\n\nMixpanelPersistence.prototype.remove_event_timer = function(event_name) {\n    var timers = this.load_prop(EVENT_TIMERS_KEY) || {};\n    var timestamp = timers[event_name];\n    if (!_.isUndefined(timestamp)) {\n        delete this['props'][EVENT_TIMERS_KEY][event_name];\n        this.save();\n    }\n    return timestamp;\n};\n\n/* eslint camelcase: \"off\" */\n\n/*\n * Mixpanel JS Library\n *\n * Copyright 2012, Mixpanel, Inc. All Rights Reserved\n * http://mixpanel.com/\n *\n * Includes portions of Underscore.js\n * http://documentcloud.github.com/underscore/\n * (c) 2011 Jeremy Ashkenas, DocumentCloud Inc.\n * Released under the MIT License.\n */\n\n/*\nSIMPLE STYLE GUIDE:\n\nthis.x === public function\nthis._x === internal - only use within this file\nthis.__x === private - only use within the class\n\nGlobals should be all caps\n*/\n\nvar init_type;       // MODULE or SNIPPET loader\n// allow bundlers to specify how extra code (recorder bundle) should be loaded\n// eslint-disable-next-line no-unused-vars\nvar load_extra_bundle = function(src, _onload) {\n    throw new Error(src + ' not available in this build.');\n};\n\nvar mixpanel_master; // main mixpanel instance / object\nvar INIT_MODULE  = 0;\nvar INIT_SNIPPET = 1;\n\nvar IDENTITY_FUNC = function(x) {return x;};\n\n/** @const */ var PRIMARY_INSTANCE_NAME = 'mixpanel';\n/** @const */ var PAYLOAD_TYPE_BASE64   = 'base64';\n/** @const */ var PAYLOAD_TYPE_JSON     = 'json';\n/** @const */ var DEVICE_ID_PREFIX      = '$device:';\n\n\n/*\n * Dynamic... constants? Is that an oxymoron?\n */\n// http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/\n// https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#withCredentials\nvar USE_XHR = (win.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest());\n\n// IE<10 does not support cross-origin XHR's but script tags\n// with defer won't block window.onload; ENQUEUE_REQUESTS\n// should only be true for Opera<12\nvar ENQUEUE_REQUESTS = !USE_XHR && (userAgent.indexOf('MSIE') === -1) && (userAgent.indexOf('Mozilla') === -1);\n\n// save reference to navigator.sendBeacon so it can be minified\nvar sendBeacon = null;\nif (navigator['sendBeacon']) {\n    sendBeacon = function() {\n        // late reference to navigator.sendBeacon to allow patching/spying\n        return navigator['sendBeacon'].apply(navigator, arguments);\n    };\n}\n\nvar DEFAULT_API_ROUTES = {\n    'track':  'track/',\n    'engage': 'engage/',\n    'groups': 'groups/',\n    'record': 'record/',\n    'flags':  'flags/'\n};\n\n/*\n * Module-level globals\n */\nvar DEFAULT_CONFIG = {\n    'api_host':                          'https://api-js.mixpanel.com',\n    'api_hosts':                         {},\n    'api_routes':                        DEFAULT_API_ROUTES,\n    'api_extra_query_params':            {},\n    'api_method':                        'POST',\n    'api_transport':                     'XHR',\n    'api_payload_format':                PAYLOAD_TYPE_BASE64,\n    'app_host':                          'https://mixpanel.com',\n    'autocapture':                       false,\n    'cdn':                               'https://cdn.mxpnl.com',\n    'cross_site_cookie':                 false,\n    'cross_subdomain_cookie':            true,\n    'error_reporter':                    NOOP_FUNC,\n    'flags':                             false,\n    'persistence':                       'cookie',\n    'persistence_name':                  '',\n    'cookie_domain':                     '',\n    'cookie_name':                       '',\n    'loaded':                            NOOP_FUNC,\n    'mp_loader':                         null,\n    'track_marketing':                   true,\n    'track_pageview':                    false,\n    'skip_first_touch_marketing':        false,\n    'store_google':                      true,\n    'stop_utm_persistence':              false,\n    'save_referrer':                     true,\n    'test':                              false,\n    'verbose':                           false,\n    'img':                               false,\n    'debug':                             false,\n    'track_links_timeout':               300,\n    'cookie_expiration':                 365,\n    'upgrade':                           false,\n    'disable_persistence':               false,\n    'disable_cookie':                    false,\n    'secure_cookie':                     false,\n    'ip':                                true,\n    'opt_out_tracking_by_default':       false,\n    'opt_out_persistence_by_default':    false,\n    'opt_out_tracking_persistence_type': 'localStorage',\n    'opt_out_tracking_cookie_prefix':    null,\n    'property_blacklist':                [],\n    'xhr_headers':                       {}, // { header: value, header2: value }\n    'ignore_dnt':                        false,\n    'batch_requests':                    true,\n    'batch_size':                        50,\n    'batch_flush_interval_ms':           5000,\n    'batch_request_timeout_ms':          90000,\n    'batch_autostart':                   true,\n    'hooks':                             {},\n    'record_block_class':                new RegExp('^(mp-block|fs-exclude|amp-block|rr-block|ph-no-capture)$'),\n    'record_block_selector':             'img, video, audio',\n    'record_canvas':                     false,\n    'record_collect_fonts':              false,\n    'record_console':                    true,\n    'record_heatmap_data':               false,\n    'record_idle_timeout_ms':            30 * 60 * 1000, // 30 minutes\n    'record_mask_text_class':            new RegExp('^(mp-mask|fs-mask|amp-mask|rr-mask|ph-mask)$'),\n    'record_mask_text_selector':         '*',\n    'record_max_ms':                     MAX_RECORDING_MS,\n    'record_min_ms':                     0,\n    'record_sessions_percent':           0,\n    'recorder_src':                      'https://cdn.mxpnl.com/libs/mixpanel-recorder.min.js'\n};\n\nvar DOM_LOADED = false;\n\n/**\n * Mixpanel Library Object\n * @constructor\n */\nvar MixpanelLib = function() {};\n\n\n/**\n * create_mplib(token:string, config:object, name:string)\n *\n * This function is used by the init method of MixpanelLib objects\n * as well as the main initializer at the end of the JSLib (that\n * initializes document.mixpanel as well as any additional instances\n * declared before this file has loaded).\n */\nvar create_mplib = function(token, config, name) {\n    var instance,\n        target = (name === PRIMARY_INSTANCE_NAME) ? mixpanel_master : mixpanel_master[name];\n\n    if (target && init_type === INIT_MODULE) {\n        instance = target;\n    } else {\n        if (target && !_.isArray(target)) {\n            console$1.error('You have already initialized ' + name);\n            return;\n        }\n        instance = new MixpanelLib();\n    }\n\n    instance._cached_groups = {}; // cache groups in a pool\n\n    instance._init(token, config, name);\n\n    instance['people'] = new MixpanelPeople();\n    instance['people']._init(instance);\n\n    if (!instance.get_config('skip_first_touch_marketing')) {\n        // We need null UTM params in the object because\n        // UTM parameters act as a tuple. If any UTM param\n        // is present, then we set all UTM params including\n        // empty ones together\n        var utm_params = _.info.campaignParams(null);\n        var initial_utm_params = {};\n        var has_utm = false;\n        _.each(utm_params, function(utm_value, utm_key) {\n            initial_utm_params['initial_' + utm_key] = utm_value;\n            if (utm_value) {\n                has_utm = true;\n            }\n        });\n        if (has_utm) {\n            instance['people'].set_once(initial_utm_params);\n        }\n    }\n\n    // if any instance on the page has debug = true, we set the\n    // global debug to be true\n    Config.DEBUG = Config.DEBUG || instance.get_config('debug');\n\n    // if target is not defined, we called init after the lib already\n    // loaded, so there won't be an array of things to execute\n    if (!_.isUndefined(target) && _.isArray(target)) {\n        // Crunch through the people queue first - we queue this data up &\n        // flush on identify, so it's better to do all these operations first\n        instance._execute_array.call(instance['people'], target['people']);\n        instance._execute_array(target);\n    }\n\n    return instance;\n};\n\n// Initialization methods\n\n/**\n * This function initializes a new instance of the Mixpanel tracking object.\n * All new instances are added to the main mixpanel object as sub properties (such as\n * mixpanel.library_name) and also returned by this function. To define a\n * second instance on the page, you would call:\n *\n *     mixpanel.init('new token', { your: 'config' }, 'library_name');\n *\n * and use it like so:\n *\n *     mixpanel.library_name.track(...);\n *\n * @param {String} token   Your Mixpanel API token\n * @param {Object} [config]  A dictionary of config options to override. <a href=\"https://github.com/mixpanel/mixpanel-js/blob/v2.46.0/src/mixpanel-core.js#L88-L127\">See a list of default config options</a>.\n * @param {String} [name]    The name for the new mixpanel instance that you want created\n */\nMixpanelLib.prototype.init = function (token, config, name) {\n    if (_.isUndefined(name)) {\n        this.report_error('You must name your new library: init(token, config, name)');\n        return;\n    }\n    if (name === PRIMARY_INSTANCE_NAME) {\n        this.report_error('You must initialize the main mixpanel object right after you include the Mixpanel js snippet');\n        return;\n    }\n\n    var instance = create_mplib(token, config, name);\n    mixpanel_master[name] = instance;\n    instance._loaded();\n\n    return instance;\n};\n\n// mixpanel._init(token:string, config:object, name:string)\n//\n// This function sets up the current instance of the mixpanel\n// library.  The difference between this method and the init(...)\n// method is this one initializes the actual instance, whereas the\n// init(...) method sets up a new library and calls _init on it.\n//\nMixpanelLib.prototype._init = function(token, config, name) {\n    config = config || {};\n\n    this['__loaded'] = true;\n    this['config'] = {};\n\n    var variable_features = {};\n\n    // default to JSON payload for standard mixpanel.com API hosts\n    if (!('api_payload_format' in config)) {\n        var api_host = config['api_host'] || DEFAULT_CONFIG['api_host'];\n        if (api_host.match(/\\.mixpanel\\.com/)) {\n            variable_features['api_payload_format'] = PAYLOAD_TYPE_JSON;\n        }\n    }\n\n    this.set_config(_.extend({}, DEFAULT_CONFIG, variable_features, config, {\n        'name': name,\n        'token': token,\n        'callback_fn': ((name === PRIMARY_INSTANCE_NAME) ? name : PRIMARY_INSTANCE_NAME + '.' + name) + '._jsc'\n    }));\n\n    this['_jsc'] = NOOP_FUNC;\n\n    this.__dom_loaded_queue = [];\n    this.__request_queue = [];\n    this.__disabled_events = [];\n    this._flags = {\n        'disable_all_events': false,\n        'identify_called': false\n    };\n\n    // set up request queueing/batching\n    this.request_batchers = {};\n    this._batch_requests = this.get_config('batch_requests');\n    if (this._batch_requests) {\n        if (!_.localStorage.is_supported(true) || !USE_XHR) {\n            this._batch_requests = false;\n            console$1.log('Turning off Mixpanel request-queueing; needs XHR and localStorage support');\n            _.each(this.get_batcher_configs(), function(batcher_config) {\n                console$1.log('Clearing batch queue ' + batcher_config.queue_key);\n                _.localStorage.remove(batcher_config.queue_key);\n            });\n        } else {\n            this.init_batchers();\n            if (sendBeacon && win.addEventListener) {\n                // Before page closes or hides (user tabs away etc), attempt to flush any events\n                // queued up via navigator.sendBeacon. Since sendBeacon doesn't report success/failure,\n                // events will not be removed from the persistent store; if the site is loaded again,\n                // the events will be flushed again on startup and deduplicated on the Mixpanel server\n                // side.\n                // There is no reliable way to capture only page close events, so we lean on the\n                // visibilitychange and pagehide events as recommended at\n                // https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event#usage_notes.\n                // These events fire when the user clicks away from the current page/tab, so will occur\n                // more frequently than page unload, but are the only mechanism currently for capturing\n                // this scenario somewhat reliably.\n                var flush_on_unload = _.bind(function() {\n                    if (!this.request_batchers.events.stopped) {\n                        this.request_batchers.events.flush({unloading: true});\n                    }\n                }, this);\n                win.addEventListener('pagehide', function(ev) {\n                    if (ev['persisted']) {\n                        flush_on_unload();\n                    }\n                });\n                win.addEventListener('visibilitychange', function() {\n                    if (document$1['visibilityState'] === 'hidden') {\n                        flush_on_unload();\n                    }\n                });\n            }\n        }\n    }\n\n    this['persistence'] = this['cookie'] = new MixpanelPersistence(this['config']);\n    this.unpersisted_superprops = {};\n    this._gdpr_init();\n\n    var uuid = _.UUID();\n    if (!this.get_distinct_id()) {\n        // There is no need to set the distinct id\n        // or the device id if something was already stored\n        // in the persitence\n        this.register_once({\n            'distinct_id': DEVICE_ID_PREFIX + uuid,\n            '$device_id': uuid\n        }, '');\n    }\n\n    this.flags = new FeatureFlagManager({\n        getFullApiRoute: _.bind(function() {\n            return this.get_api_host('flags') + '/' + this.get_config('api_routes')['flags'];\n        }, this),\n        getConfigFunc: _.bind(this.get_config, this),\n        setConfigFunc: _.bind(this.set_config, this),\n        getPropertyFunc: _.bind(this.get_property, this),\n        trackingFunc: _.bind(this.track, this)\n    });\n    this.flags.init();\n    this['flags'] = this.flags;\n\n    this.autocapture = new Autocapture(this);\n    this.autocapture.init();\n\n    this._init_tab_id();\n    this._check_and_start_session_recording();\n};\n\n/**\n * Assigns a unique UUID to this tab / window by leveraging sessionStorage.\n * This is primarily used for session recording, where data must be isolated to the current tab.\n */\nMixpanelLib.prototype._init_tab_id = function() {\n    if (this.get_config('disable_persistence')) {\n        console$1.log('Tab ID initialization skipped due to disable_persistence config');\n    } else if (_.sessionStorage.is_supported()) {\n        try {\n            var key_suffix = this.get_config('name') + '_' + this.get_config('token');\n            var tab_id_key = 'mp_tab_id_' + key_suffix;\n\n            // A flag is used to determine if sessionStorage is copied over and we need to generate a new tab ID.\n            // This enforces a unique ID in the cases like duplicated tab, window.open(...)\n            var should_generate_new_tab_id_key = 'mp_gen_new_tab_id_' + key_suffix;\n            if (_.sessionStorage.get(should_generate_new_tab_id_key) || !_.sessionStorage.get(tab_id_key)) {\n                _.sessionStorage.set(tab_id_key, '$tab-' + _.UUID());\n            }\n\n            _.sessionStorage.set(should_generate_new_tab_id_key, '1');\n            this.tab_id = _.sessionStorage.get(tab_id_key);\n\n            // Remove the flag when the tab is unloaded to indicate the stored tab ID can be reused. This event is not reliable to detect all page unloads,\n            // but reliable in cases where the user remains in the tab e.g. a refresh or href navigation.\n            // If the flag is absent, this indicates to the next SDK instance that we can reuse the stored tab_id.\n            win.addEventListener('beforeunload', function () {\n                _.sessionStorage.remove(should_generate_new_tab_id_key);\n            });\n        } catch(err) {\n            this.report_error('Error initializing tab id', err);\n        }\n    } else {\n        this.report_error('Session storage is not supported, cannot keep track of unique tab ID.');\n    }\n};\n\nMixpanelLib.prototype.get_tab_id = function () {\n    return this.tab_id || null;\n};\n\nMixpanelLib.prototype._should_load_recorder = function () {\n    if (this.get_config('disable_persistence')) {\n        console$1.log('Load recorder check skipped due to disable_persistence config');\n        return Promise.resolve(false);\n    }\n\n    var recording_registry_idb = new IDBStorageWrapper(RECORDING_REGISTRY_STORE_NAME);\n    var tab_id = this.get_tab_id();\n    return recording_registry_idb.init()\n        .then(function () {\n            return recording_registry_idb.getAll();\n        })\n        .then(function (recordings) {\n            for (var i = 0; i < recordings.length; i++) {\n                // if there are expired recordings in the registry, we should load the recorder to flush them\n                // if there's a recording for this tab id, we should load the recorder to continue the recording\n                if (isRecordingExpired(recordings[i]) || recordings[i]['tabId'] === tab_id) {\n                    return true;\n                }\n            }\n            return false;\n        })\n        .catch(_.bind(function (err) {\n            this.report_error('Error checking recording registry', err);\n        }, this));\n};\n\nMixpanelLib.prototype._check_and_start_session_recording = addOptOutCheckMixpanelLib(function(force_start) {\n    if (!win['MutationObserver']) {\n        console$1.critical('Browser does not support MutationObserver; skipping session recording');\n        return;\n    }\n\n    var loadRecorder = _.bind(function(startNewIfInactive) {\n        var handleLoadedRecorder = _.bind(function() {\n            this._recorder = this._recorder || new win['__mp_recorder'](this);\n            this._recorder['resumeRecording'](startNewIfInactive);\n        }, this);\n\n        if (_.isUndefined(win['__mp_recorder'])) {\n            load_extra_bundle(this.get_config('recorder_src'), handleLoadedRecorder);\n        } else {\n            handleLoadedRecorder();\n        }\n    }, this);\n\n    /**\n     * If the user is sampled or start_session_recording is called, we always load the recorder since it's guaranteed a recording should start.\n     * Otherwise, if the recording registry has any records then it's likely there's a recording in progress or orphaned data that needs to be flushed.\n     */\n    var is_sampled = this.get_config('record_sessions_percent') > 0 && Math.random() * 100 <= this.get_config('record_sessions_percent');\n    if (force_start || is_sampled) {\n        loadRecorder(true);\n    } else {\n        this._should_load_recorder()\n            .then(function (shouldLoad) {\n                if (shouldLoad) {\n                    loadRecorder(false);\n                }\n            });\n    }\n});\n\nMixpanelLib.prototype.start_session_recording = function () {\n    this._check_and_start_session_recording(true);\n};\n\nMixpanelLib.prototype.stop_session_recording = function () {\n    if (this._recorder) {\n        return this._recorder['stopRecording']();\n    }\n    return Promise.resolve();\n};\n\nMixpanelLib.prototype.pause_session_recording = function () {\n    if (this._recorder) {\n        return this._recorder['pauseRecording']();\n    }\n    return Promise.resolve();\n};\n\nMixpanelLib.prototype.resume_session_recording = function () {\n    if (this._recorder) {\n        return this._recorder['resumeRecording']();\n    }\n    return Promise.resolve();\n};\n\nMixpanelLib.prototype.is_recording_heatmap_data = function () {\n    return this._get_session_replay_id() && this.get_config('record_heatmap_data');\n};\n\nMixpanelLib.prototype.get_session_recording_properties = function () {\n    var props = {};\n    var replay_id = this._get_session_replay_id();\n    if (replay_id) {\n        props['$mp_replay_id'] = replay_id;\n    }\n    return props;\n};\n\nMixpanelLib.prototype.get_session_replay_url = function () {\n    var replay_url = null;\n    var replay_id = this._get_session_replay_id();\n    if (replay_id) {\n        var query_params = _.HTTPBuildQuery({\n            'replay_id': replay_id,\n            'distinct_id': this.get_distinct_id(),\n            'token': this.get_config('token')\n        });\n        replay_url = 'https://mixpanel.com/projects/replay-redirect?' + query_params;\n    }\n    return replay_url;\n};\n\nMixpanelLib.prototype._get_session_replay_id = function () {\n    var replay_id = null;\n    if (this._recorder) {\n        replay_id = this._recorder['replayId'];\n    }\n    return replay_id || null;\n};\n\n// \"private\" public method to reach into the recorder in test cases\nMixpanelLib.prototype.__get_recorder = function () {\n    return this._recorder;\n};\n\n// Private methods\n\nMixpanelLib.prototype._loaded = function() {\n    this.get_config('loaded')(this);\n    this._set_default_superprops();\n    this['people'].set_once(this['persistence'].get_referrer_info());\n\n    // `store_google` is now deprecated and previously stored UTM parameters are cleared\n    // from persistence by default.\n    if (this.get_config('store_google') && this.get_config('stop_utm_persistence')) {\n        var utm_params = _.info.campaignParams(null);\n        _.each(utm_params, function(_utm_value, utm_key) {\n            // We need to unregister persisted UTM parameters so old values\n            // are not mixed with the new UTM parameters\n            this.unregister(utm_key);\n        }.bind(this));\n    }\n};\n\n// update persistence with info on referrer, UTM params, etc\nMixpanelLib.prototype._set_default_superprops = function() {\n    this['persistence'].update_search_keyword(document$1.referrer);\n    // Registering super properties for UTM persistence by 'store_google' is deprecated.\n    if (this.get_config('store_google') && !this.get_config('stop_utm_persistence')) {\n        this.register(_.info.campaignParams());\n    }\n    if (this.get_config('save_referrer')) {\n        this['persistence'].update_referrer_info(document$1.referrer);\n    }\n};\n\nMixpanelLib.prototype._dom_loaded = function() {\n    _.each(this.__dom_loaded_queue, function(item) {\n        this._track_dom.apply(this, item);\n    }, this);\n\n    if (!this.has_opted_out_tracking()) {\n        _.each(this.__request_queue, function(item) {\n            this._send_request.apply(this, item);\n        }, this);\n    }\n\n    delete this.__dom_loaded_queue;\n    delete this.__request_queue;\n};\n\nMixpanelLib.prototype._track_dom = function(DomClass, args) {\n    if (this.get_config('img')) {\n        this.report_error('You can\\'t use DOM tracking functions with img = true.');\n        return false;\n    }\n\n    if (!DOM_LOADED) {\n        this.__dom_loaded_queue.push([DomClass, args]);\n        return false;\n    }\n\n    var dt = new DomClass().init(this);\n    return dt.track.apply(dt, args);\n};\n\n/**\n * _prepare_callback() should be called by callers of _send_request for use\n * as the callback argument.\n *\n * If there is no callback, this returns null.\n * If we are going to make XHR/XDR requests, this returns a function.\n * If we are going to use script tags, this returns a string to use as the\n * callback GET param.\n */\nMixpanelLib.prototype._prepare_callback = function(callback, data) {\n    if (_.isUndefined(callback)) {\n        return null;\n    }\n\n    if (USE_XHR) {\n        var callback_function = function(response) {\n            callback(response, data);\n        };\n        return callback_function;\n    } else {\n        // if the user gives us a callback, we store as a random\n        // property on this instances jsc function and update our\n        // callback string to reflect that.\n        var jsc = this['_jsc'];\n        var randomized_cb = '' + Math.floor(Math.random() * 100000000);\n        var callback_string = this.get_config('callback_fn') + '[' + randomized_cb + ']';\n        jsc[randomized_cb] = function(response) {\n            delete jsc[randomized_cb];\n            callback(response, data);\n        };\n        return callback_string;\n    }\n};\n\nMixpanelLib.prototype._send_request = function(url, data, options, callback) {\n    var succeeded = true;\n\n    if (ENQUEUE_REQUESTS) {\n        this.__request_queue.push(arguments);\n        return succeeded;\n    }\n\n    var DEFAULT_OPTIONS = {\n        method: this.get_config('api_method'),\n        transport: this.get_config('api_transport'),\n        verbose: this.get_config('verbose')\n    };\n    var body_data = null;\n\n    if (!callback && (_.isFunction(options) || typeof options === 'string')) {\n        callback = options;\n        options = null;\n    }\n    options = _.extend(DEFAULT_OPTIONS, options || {});\n    if (!USE_XHR) {\n        options.method = 'GET';\n    }\n    var use_post = options.method === 'POST';\n    var use_sendBeacon = sendBeacon && use_post && options.transport.toLowerCase() === 'sendbeacon';\n\n    // needed to correctly format responses\n    var verbose_mode = options.verbose;\n    if (data['verbose']) { verbose_mode = true; }\n\n    if (this.get_config('test')) { data['test'] = 1; }\n    if (verbose_mode) { data['verbose'] = 1; }\n    if (this.get_config('img')) { data['img'] = 1; }\n    if (!USE_XHR) {\n        if (callback) {\n            data['callback'] = callback;\n        } else if (verbose_mode || this.get_config('test')) {\n            // Verbose output (from verbose mode, or an error in test mode) is a json blob,\n            // which by itself is not valid javascript. Without a callback, this verbose output will\n            // cause an error when returned via jsonp, so we force a no-op callback param.\n            // See the ECMA script spec: http://www.ecma-international.org/ecma-262/5.1/#sec-12.4\n            data['callback'] = '(function(){})';\n        }\n    }\n\n    data['ip'] = this.get_config('ip')?1:0;\n    data['_'] = new Date().getTime().toString();\n\n    if (use_post) {\n        body_data = 'data=' + encodeURIComponent(data['data']);\n        delete data['data'];\n    }\n\n    _.extend(data, this.get_config('api_extra_query_params'));\n\n    url += '?' + _.HTTPBuildQuery(data);\n\n    var lib = this;\n    if ('img' in data) {\n        var img = document$1.createElement('img');\n        img.src = url;\n        document$1.body.appendChild(img);\n    } else if (use_sendBeacon) {\n        try {\n            succeeded = sendBeacon(url, body_data);\n        } catch (e) {\n            lib.report_error(e);\n            succeeded = false;\n        }\n        try {\n            if (callback) {\n                callback(succeeded ? 1 : 0);\n            }\n        } catch (e) {\n            lib.report_error(e);\n        }\n    } else if (USE_XHR) {\n        try {\n            var req = new XMLHttpRequest();\n            req.open(options.method, url, true);\n\n            var headers = this.get_config('xhr_headers');\n            if (use_post) {\n                headers['Content-Type'] = 'application/x-www-form-urlencoded';\n            }\n            _.each(headers, function(headerValue, headerName) {\n                req.setRequestHeader(headerName, headerValue);\n            });\n\n            if (options.timeout_ms && typeof req.timeout !== 'undefined') {\n                req.timeout = options.timeout_ms;\n                var start_time = new Date().getTime();\n            }\n\n            // send the mp_optout cookie\n            // withCredentials cannot be modified until after calling .open on Android and Mobile Safari\n            req.withCredentials = true;\n            req.onreadystatechange = function () {\n                if (req.readyState === 4) { // XMLHttpRequest.DONE == 4, except in safari 4\n                    if (req.status === 200) {\n                        if (callback) {\n                            if (verbose_mode) {\n                                var response;\n                                try {\n                                    response = _.JSONDecode(req.responseText);\n                                } catch (e) {\n                                    lib.report_error(e);\n                                    if (options.ignore_json_errors) {\n                                        response = req.responseText;\n                                    } else {\n                                        return;\n                                    }\n                                }\n                                callback(response);\n                            } else {\n                                callback(Number(req.responseText));\n                            }\n                        }\n                    } else {\n                        var error;\n                        if (\n                            req.timeout &&\n                            !req.status &&\n                            new Date().getTime() - start_time >= req.timeout\n                        ) {\n                            error = 'timeout';\n                        } else {\n                            error = 'Bad HTTP status: ' + req.status + ' ' + req.statusText;\n                        }\n                        lib.report_error(error);\n                        if (callback) {\n                            if (verbose_mode) {\n                                var response_headers = req['responseHeaders'] || {};\n                                callback({status: 0, httpStatusCode: req['status'], error: error, retryAfter: response_headers['Retry-After']});\n                            } else {\n                                callback(0);\n                            }\n                        }\n                    }\n                }\n            };\n            req.send(body_data);\n        } catch (e) {\n            lib.report_error(e);\n            succeeded = false;\n        }\n    } else {\n        var script = document$1.createElement('script');\n        script.type = 'text/javascript';\n        script.async = true;\n        script.defer = true;\n        script.src = url;\n        var s = document$1.getElementsByTagName('script')[0];\n        s.parentNode.insertBefore(script, s);\n    }\n\n    return succeeded;\n};\n\n/**\n * _execute_array() deals with processing any mixpanel function\n * calls that were called before the Mixpanel library were loaded\n * (and are thus stored in an array so they can be called later)\n *\n * Note: we fire off all the mixpanel function calls && user defined\n * functions BEFORE we fire off mixpanel tracking calls. This is so\n * identify/register/set_config calls can properly modify early\n * tracking calls.\n *\n * @param {Array} array\n */\nMixpanelLib.prototype._execute_array = function(array) {\n    var fn_name, alias_calls = [], other_calls = [], tracking_calls = [];\n    _.each(array, function(item) {\n        if (item) {\n            fn_name = item[0];\n            if (_.isArray(fn_name)) {\n                tracking_calls.push(item); // chained call e.g. mixpanel.get_group().set()\n            } else if (typeof(item) === 'function') {\n                item.call(this);\n            } else if (_.isArray(item) && fn_name === 'alias') {\n                alias_calls.push(item);\n            } else if (_.isArray(item) && fn_name.indexOf('track') !== -1 && typeof(this[fn_name]) === 'function') {\n                tracking_calls.push(item);\n            } else {\n                other_calls.push(item);\n            }\n        }\n    }, this);\n\n    var execute = function(calls, context) {\n        _.each(calls, function(item) {\n            if (_.isArray(item[0])) {\n                // chained call\n                var caller = context;\n                _.each(item, function(call) {\n                    caller = caller[call[0]].apply(caller, call.slice(1));\n                });\n            } else {\n                this[item[0]].apply(this, item.slice(1));\n            }\n        }, context);\n    };\n\n    execute(alias_calls, this);\n    execute(other_calls, this);\n    execute(tracking_calls, this);\n};\n\n// request queueing utils\n\nMixpanelLib.prototype.are_batchers_initialized = function() {\n    return !!this.request_batchers.events;\n};\n\nMixpanelLib.prototype.get_batcher_configs = function() {\n    var queue_prefix = '__mpq_' + this.get_config('token');\n    this._batcher_configs = this._batcher_configs || {\n        events: {type: 'events', api_name: 'track', queue_key: queue_prefix + '_ev'},\n        people: {type: 'people', api_name: 'engage', queue_key: queue_prefix + '_pp'},\n        groups: {type: 'groups', api_name: 'groups', queue_key: queue_prefix + '_gr'}\n    };\n    return this._batcher_configs;\n};\n\nMixpanelLib.prototype.init_batchers = function() {\n    if (!this.are_batchers_initialized()) {\n        var batcher_for = _.bind(function(attrs) {\n            return new RequestBatcher(\n                attrs.queue_key,\n                {\n                    libConfig: this['config'],\n                    errorReporter: this.get_config('error_reporter'),\n                    sendRequestFunc: _.bind(function(data, options, cb) {\n                        var api_routes = this.get_config('api_routes');\n                        this._send_request(\n                            this.get_api_host(attrs.api_name) + '/' + api_routes[attrs.api_name],\n                            this._encode_data_for_request(data),\n                            options,\n                            this._prepare_callback(cb, data)\n                        );\n                    }, this),\n                    beforeSendHook: _.bind(function(item) {\n                        return this._run_hook('before_send_' + attrs.type, item);\n                    }, this),\n                    stopAllBatchingFunc: _.bind(this.stop_batch_senders, this),\n                    usePersistence: true,\n                }\n            );\n        }, this);\n        var batcher_configs = this.get_batcher_configs();\n        this.request_batchers = {\n            events: batcher_for(batcher_configs.events),\n            people: batcher_for(batcher_configs.people),\n            groups: batcher_for(batcher_configs.groups)\n        };\n    }\n    if (this.get_config('batch_autostart')) {\n        this.start_batch_senders();\n    }\n};\n\nMixpanelLib.prototype.start_batch_senders = function() {\n    this._batchers_were_started = true;\n    if (this.are_batchers_initialized()) {\n        this._batch_requests = true;\n        _.each(this.request_batchers, function(batcher) {\n            batcher.start();\n        });\n    }\n};\n\nMixpanelLib.prototype.stop_batch_senders = function() {\n    this._batch_requests = false;\n    _.each(this.request_batchers, function(batcher) {\n        batcher.stop();\n        batcher.clear();\n    });\n};\n\n/**\n * push() keeps the standard async-array-push\n * behavior around after the lib is loaded.\n * This is only useful for external integrations that\n * do not wish to rely on our convenience methods\n * (created in the snippet).\n *\n * ### Usage:\n *     mixpanel.push(['register', { a: 'b' }]);\n *\n * @param {Array} item A [function_name, args...] array to be executed\n */\nMixpanelLib.prototype.push = function(item) {\n    this._execute_array([item]);\n};\n\n/**\n * Disable events on the Mixpanel object. If passed no arguments,\n * this function disables tracking of any event. If passed an\n * array of event names, those events will be disabled, but other\n * events will continue to be tracked.\n *\n * Note: this function does not stop other mixpanel functions from\n * firing, such as register() or people.set().\n *\n * @param {Array} [events] An array of event names to disable\n */\nMixpanelLib.prototype.disable = function(events) {\n    if (typeof(events) === 'undefined') {\n        this._flags.disable_all_events = true;\n    } else {\n        this.__disabled_events = this.__disabled_events.concat(events);\n    }\n};\n\nMixpanelLib.prototype._encode_data_for_request = function(data) {\n    var encoded_data = JSONStringify(data);\n    if (this.get_config('api_payload_format') === PAYLOAD_TYPE_BASE64) {\n        encoded_data = _.base64Encode(encoded_data);\n    }\n    return {'data': encoded_data};\n};\n\n// internal method for handling track vs batch-enqueue logic\nMixpanelLib.prototype._track_or_batch = function(options, callback) {\n    var truncated_data = _.truncate(options.data, 255);\n    var endpoint = options.endpoint;\n    var batcher = options.batcher;\n    var should_send_immediately = options.should_send_immediately;\n    var send_request_options = options.send_request_options || {};\n    callback = callback || NOOP_FUNC;\n\n    var request_enqueued_or_initiated = true;\n    var send_request_immediately = _.bind(function() {\n        if (!send_request_options.skip_hooks) {\n            truncated_data = this._run_hook('before_send_' + options.type, truncated_data);\n        }\n        if (truncated_data) {\n            console$1.log('MIXPANEL REQUEST:');\n            console$1.log(truncated_data);\n            return this._send_request(\n                endpoint,\n                this._encode_data_for_request(truncated_data),\n                send_request_options,\n                this._prepare_callback(callback, truncated_data)\n            );\n        } else {\n            return null;\n        }\n    }, this);\n\n    if (this._batch_requests && !should_send_immediately) {\n        batcher.enqueue(truncated_data).then(function(succeeded) {\n            if (succeeded) {\n                callback(1, truncated_data);\n            } else {\n                send_request_immediately();\n            }\n        });\n    } else {\n        request_enqueued_or_initiated = send_request_immediately();\n    }\n\n    return request_enqueued_or_initiated && truncated_data;\n};\n\n/**\n * Track an event. This is the most important and\n * frequently used Mixpanel function.\n *\n * ### Usage:\n *\n *     // track an event named 'Registered'\n *     mixpanel.track('Registered', {'Gender': 'Male', 'Age': 21});\n *\n *     // track an event using navigator.sendBeacon\n *     mixpanel.track('Left page', {'duration_seconds': 35}, {transport: 'sendBeacon'});\n *\n * To track link clicks or form submissions, see track_links() or track_forms().\n *\n * @param {String} event_name The name of the event. This can be anything the user does - 'Button Click', 'Sign Up', 'Item Purchased', etc.\n * @param {Object} [properties] A set of properties to include with the event you're sending. These describe the user who did the event or details about the event itself.\n * @param {Object} [options] Optional configuration for this track request.\n * @param {String} [options.transport] Transport method for network request ('xhr' or 'sendBeacon').\n * @param {Boolean} [options.send_immediately] Whether to bypass batching/queueing and send track request immediately.\n * @param {Function} [callback] If provided, the callback function will be called after tracking the event.\n * @returns {Boolean|Object} If the tracking request was successfully initiated/queued, an object\n * with the tracking payload sent to the API server is returned; otherwise false.\n */\nMixpanelLib.prototype.track = addOptOutCheckMixpanelLib(function(event_name, properties, options, callback) {\n    if (!callback && typeof options === 'function') {\n        callback = options;\n        options = null;\n    }\n    options = options || {};\n    var transport = options['transport']; // external API, don't minify 'transport' prop\n    if (transport) {\n        options.transport = transport; // 'transport' prop name can be minified internally\n    }\n    var should_send_immediately = options['send_immediately'];\n    if (typeof callback !== 'function') {\n        callback = NOOP_FUNC;\n    }\n\n    if (_.isUndefined(event_name)) {\n        this.report_error('No event name provided to mixpanel.track');\n        return;\n    }\n\n    if (this._event_is_disabled(event_name)) {\n        callback(0);\n        return;\n    }\n\n    // set defaults\n    properties = _.extend({}, properties);\n    properties['token'] = this.get_config('token');\n\n    // set $duration if time_event was previously called for this event\n    var start_timestamp = this['persistence'].remove_event_timer(event_name);\n    if (!_.isUndefined(start_timestamp)) {\n        var duration_in_ms = new Date().getTime() - start_timestamp;\n        properties['$duration'] = parseFloat((duration_in_ms / 1000).toFixed(3));\n    }\n\n    this._set_default_superprops();\n\n    var marketing_properties = this.get_config('track_marketing')\n        ? _.info.marketingParams()\n        : {};\n\n    // note: extend writes to the first object, so lets make sure we\n    // don't write to the persistence properties object and info\n    // properties object by passing in a new object\n\n    // update properties with pageview info and super-properties\n    properties = _.extend(\n        {},\n        _.info.properties({'mp_loader': this.get_config('mp_loader')}),\n        marketing_properties,\n        this['persistence'].properties(),\n        this.unpersisted_superprops,\n        this.get_session_recording_properties(),\n        properties\n    );\n\n    var property_blacklist = this.get_config('property_blacklist');\n    if (_.isArray(property_blacklist)) {\n        _.each(property_blacklist, function(blacklisted_prop) {\n            delete properties[blacklisted_prop];\n        });\n    } else {\n        this.report_error('Invalid value for property_blacklist config: ' + property_blacklist);\n    }\n\n    var data = {\n        'event': event_name,\n        'properties': properties\n    };\n    var ret = this._track_or_batch({\n        type: 'events',\n        data: data,\n        endpoint: this.get_api_host('events') + '/' + this.get_config('api_routes')['track'],\n        batcher: this.request_batchers.events,\n        should_send_immediately: should_send_immediately,\n        send_request_options: options\n    }, callback);\n\n    return ret;\n});\n\n/**\n * Register the current user into one/many groups.\n *\n * ### Usage:\n *\n *      mixpanel.set_group('company', ['mixpanel', 'google']) // an array of IDs\n *      mixpanel.set_group('company', 'mixpanel')\n *      mixpanel.set_group('company', 128746312)\n *\n * @param {String} group_key Group key\n * @param {Array|String|Number} group_ids An array of group IDs, or a singular group ID\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n *\n */\nMixpanelLib.prototype.set_group = addOptOutCheckMixpanelLib(function(group_key, group_ids, callback) {\n    if (!_.isArray(group_ids)) {\n        group_ids = [group_ids];\n    }\n    var prop = {};\n    prop[group_key] = group_ids;\n    this.register(prop);\n    return this['people'].set(group_key, group_ids, callback);\n});\n\n/**\n * Add a new group for this user.\n *\n * ### Usage:\n *\n *      mixpanel.add_group('company', 'mixpanel')\n *\n * @param {String} group_key Group key\n * @param {*} group_id A valid Mixpanel property type\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n */\nMixpanelLib.prototype.add_group = addOptOutCheckMixpanelLib(function(group_key, group_id, callback) {\n    var old_values = this.get_property(group_key);\n    var prop = {};\n    if (old_values === undefined) {\n        prop[group_key] = [group_id];\n        this.register(prop);\n    } else {\n        if (old_values.indexOf(group_id) === -1) {\n            old_values.push(group_id);\n            prop[group_key] = old_values;\n            this.register(prop);\n        }\n    }\n    return this['people'].union(group_key, group_id, callback);\n});\n\n/**\n * Remove a group from this user.\n *\n * ### Usage:\n *\n *      mixpanel.remove_group('company', 'mixpanel')\n *\n * @param {String} group_key Group key\n * @param {*} group_id A valid Mixpanel property type\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n */\nMixpanelLib.prototype.remove_group = addOptOutCheckMixpanelLib(function(group_key, group_id, callback) {\n    var old_value = this.get_property(group_key);\n    // if the value doesn't exist, the persistent store is unchanged\n    if (old_value !== undefined) {\n        var idx = old_value.indexOf(group_id);\n        if (idx > -1) {\n            old_value.splice(idx, 1);\n            this.register({group_key: old_value});\n        }\n        if (old_value.length === 0) {\n            this.unregister(group_key);\n        }\n    }\n    return this['people'].remove(group_key, group_id, callback);\n});\n\n/**\n * Track an event with specific groups.\n *\n * ### Usage:\n *\n *      mixpanel.track_with_groups('purchase', {'product': 'iphone'}, {'University': ['UCB', 'UCLA']})\n *\n * @param {String} event_name The name of the event (see `mixpanel.track()`)\n * @param {Object=} properties A set of properties to include with the event you're sending (see `mixpanel.track()`)\n * @param {Object=} groups An object mapping group name keys to one or more values\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n */\nMixpanelLib.prototype.track_with_groups = addOptOutCheckMixpanelLib(function(event_name, properties, groups, callback) {\n    var tracking_props = _.extend({}, properties || {});\n    _.each(groups, function(v, k) {\n        if (v !== null && v !== undefined) {\n            tracking_props[k] = v;\n        }\n    });\n    return this.track(event_name, tracking_props, callback);\n});\n\nMixpanelLib.prototype._create_map_key = function (group_key, group_id) {\n    return group_key + '_' + JSON.stringify(group_id);\n};\n\nMixpanelLib.prototype._remove_group_from_cache = function (group_key, group_id) {\n    delete this._cached_groups[this._create_map_key(group_key, group_id)];\n};\n\n/**\n * Look up reference to a Mixpanel group\n *\n * ### Usage:\n *\n *       mixpanel.get_group(group_key, group_id)\n *\n * @param {String} group_key Group key\n * @param {Object} group_id A valid Mixpanel property type\n * @returns {Object} A MixpanelGroup identifier\n */\nMixpanelLib.prototype.get_group = function (group_key, group_id) {\n    var map_key = this._create_map_key(group_key, group_id);\n    var group = this._cached_groups[map_key];\n    if (group === undefined || group._group_key !== group_key || group._group_id !== group_id) {\n        group = new MixpanelGroup();\n        group._init(this, group_key, group_id);\n        this._cached_groups[map_key] = group;\n    }\n    return group;\n};\n\n/**\n * Track a default Mixpanel page view event, which includes extra default event properties to\n * improve page view data.\n *\n * ### Usage:\n *\n *     // track a default $mp_web_page_view event\n *     mixpanel.track_pageview();\n *\n *     // track a page view event with additional event properties\n *     mixpanel.track_pageview({'ab_test_variant': 'card-layout-b'});\n *\n *     // example approach to track page views on different page types as event properties\n *     mixpanel.track_pageview({'page': 'pricing'});\n *     mixpanel.track_pageview({'page': 'homepage'});\n *\n *     // UNCOMMON: Tracking a page view event with a custom event_name option. NOT expected to be used for\n *     // individual pages on the same site or product. Use cases for custom event_name may be page\n *     // views on different products or internal applications that are considered completely separate\n *     mixpanel.track_pageview({'page': 'customer-search'}, {'event_name': '[internal] Admin Page View'});\n *\n * ### Notes:\n *\n * The `config.track_pageview` option for <a href=\"#mixpanelinit\">mixpanel.init()</a>\n * may be turned on for tracking page loads automatically.\n *\n *     // track only page loads\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: true});\n *\n *     // track when the URL changes in any manner\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: 'full-url'});\n *\n *     // track when the URL changes, ignoring any changes in the hash part\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: 'url-with-path-and-query-string'});\n *\n *     // track when the path changes, ignoring any query parameter or hash changes\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: 'url-with-path'});\n *\n * @param {Object} [properties] An optional set of additional properties to send with the page view event\n * @param {Object} [options] Page view tracking options\n * @param {String} [options.event_name] - Alternate name for the tracking event\n * @returns {Boolean|Object} If the tracking request was successfully initiated/queued, an object\n * with the tracking payload sent to the API server is returned; otherwise false.\n */\nMixpanelLib.prototype.track_pageview = addOptOutCheckMixpanelLib(function(properties, options) {\n    if (typeof properties !== 'object') {\n        properties = {};\n    }\n    options = options || {};\n    var event_name = options['event_name'] || '$mp_web_page_view';\n\n    var default_page_properties = _.extend(\n        _.info.mpPageViewProperties(),\n        _.info.campaignParams(),\n        _.info.clickParams()\n    );\n\n    var event_properties = _.extend(\n        {},\n        default_page_properties,\n        properties\n    );\n\n    return this.track(event_name, event_properties);\n});\n\n/**\n * Track clicks on a set of document elements. Selector must be a\n * valid query. Elements must exist on the page at the time track_links is called.\n *\n * ### Usage:\n *\n *     // track click for link id #nav\n *     mixpanel.track_links('#nav', 'Clicked Nav Link');\n *\n * ### Notes:\n *\n * This function will wait up to 300 ms for the Mixpanel\n * servers to respond. If they have not responded by that time\n * it will head to the link without ensuring that your event\n * has been tracked.  To configure this timeout please see the\n * set_config() documentation below.\n *\n * If you pass a function in as the properties argument, the\n * function will receive the DOMElement that triggered the\n * event as an argument.  You are expected to return an object\n * from the function; any properties defined on this object\n * will be sent to mixpanel as event properties.\n *\n * @type {Function}\n * @param {Object|String} query A valid DOM query, element or jQuery-esque list\n * @param {String} event_name The name of the event to track\n * @param {Object|Function} [properties] A properties object or function that returns a dictionary of properties when passed a DOMElement\n */\nMixpanelLib.prototype.track_links = function() {\n    return this._track_dom.call(this, LinkTracker, arguments);\n};\n\n/**\n * Track form submissions. Selector must be a valid query.\n *\n * ### Usage:\n *\n *     // track submission for form id 'register'\n *     mixpanel.track_forms('#register', 'Created Account');\n *\n * ### Notes:\n *\n * This function will wait up to 300 ms for the mixpanel\n * servers to respond, if they have not responded by that time\n * it will head to the link without ensuring that your event\n * has been tracked.  To configure this timeout please see the\n * set_config() documentation below.\n *\n * If you pass a function in as the properties argument, the\n * function will receive the DOMElement that triggered the\n * event as an argument.  You are expected to return an object\n * from the function; any properties defined on this object\n * will be sent to mixpanel as event properties.\n *\n * @type {Function}\n * @param {Object|String} query A valid DOM query, element or jQuery-esque list\n * @param {String} event_name The name of the event to track\n * @param {Object|Function} [properties] This can be a set of properties, or a function that returns a set of properties after being passed a DOMElement\n */\nMixpanelLib.prototype.track_forms = function() {\n    return this._track_dom.call(this, FormTracker, arguments);\n};\n\n/**\n * Time an event by including the time between this call and a\n * later 'track' call for the same event in the properties sent\n * with the event.\n *\n * ### Usage:\n *\n *     // time an event named 'Registered'\n *     mixpanel.time_event('Registered');\n *     mixpanel.track('Registered', {'Gender': 'Male', 'Age': 21});\n *\n * When called for a particular event name, the next track call for that event\n * name will include the elapsed time between the 'time_event' and 'track'\n * calls. This value is stored as seconds in the '$duration' property.\n *\n * @param {String} event_name The name of the event.\n */\nMixpanelLib.prototype.time_event = function(event_name) {\n    if (_.isUndefined(event_name)) {\n        this.report_error('No event name provided to mixpanel.time_event');\n        return;\n    }\n\n    if (this._event_is_disabled(event_name)) {\n        return;\n    }\n\n    this['persistence'].set_event_timer(event_name,  new Date().getTime());\n};\n\nvar REGISTER_DEFAULTS = {\n    'persistent': true\n};\n/**\n * Helper to parse options param for register methods, maintaining\n * legacy support for plain \"days\" param instead of options object\n * @param {Number|Object} [days_or_options] 'days' option (Number), or Options object for register methods\n * @returns {Object} options object\n */\nvar options_for_register = function(days_or_options) {\n    var options;\n    if (_.isObject(days_or_options)) {\n        options = days_or_options;\n    } else if (!_.isUndefined(days_or_options)) {\n        options = {'days': days_or_options};\n    } else {\n        options = {};\n    }\n    return _.extend({}, REGISTER_DEFAULTS, options);\n};\n\n/**\n * Register a set of super properties, which are included with all\n * events. This will overwrite previous super property values.\n *\n * ### Usage:\n *\n *     // register 'Gender' as a super property\n *     mixpanel.register({'Gender': 'Female'});\n *\n *     // register several super properties when a user signs up\n *     mixpanel.register({\n *         'Email': 'jdoe@example.com',\n *         'Account Type': 'Free'\n *     });\n *\n *     // register only for the current pageload\n *     mixpanel.register({'Name': 'Pat'}, {persistent: false});\n *\n * @param {Object} properties An associative array of properties to store about the user\n * @param {Number|Object} [days_or_options] Options object or number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.days] - number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.persistent=true] - whether to put in persistent storage (cookie/localStorage)\n */\nMixpanelLib.prototype.register = function(props, days_or_options) {\n    var options = options_for_register(days_or_options);\n    if (options['persistent']) {\n        this['persistence'].register(props, options['days']);\n    } else {\n        _.extend(this.unpersisted_superprops, props);\n    }\n};\n\n/**\n * Register a set of super properties only once. This will not\n * overwrite previous super property values, unlike register().\n *\n * ### Usage:\n *\n *     // register a super property for the first time only\n *     mixpanel.register_once({\n *         'First Login Date': new Date().toISOString()\n *     });\n *\n *     // register once, only for the current pageload\n *     mixpanel.register_once({\n *         'First interaction time': new Date().toISOString()\n *     }, 'None', {persistent: false});\n *\n * ### Notes:\n *\n * If default_value is specified, current super properties\n * with that value will be overwritten.\n *\n * @param {Object} properties An associative array of properties to store about the user\n * @param {*} [default_value] Value to override if already set in super properties (ex: 'False') Default: 'None'\n * @param {Number|Object} [days_or_options] Options object or number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.days] - number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.persistent=true] - whether to put in persistent storage (cookie/localStorage)\n */\nMixpanelLib.prototype.register_once = function(props, default_value, days_or_options) {\n    var options = options_for_register(days_or_options);\n    if (options['persistent']) {\n        this['persistence'].register_once(props, default_value, options['days']);\n    } else {\n        if (typeof(default_value) === 'undefined') {\n            default_value = 'None';\n        }\n        _.each(props, function(val, prop) {\n            if (!this.unpersisted_superprops.hasOwnProperty(prop) || this.unpersisted_superprops[prop] === default_value) {\n                this.unpersisted_superprops[prop] = val;\n            }\n        }, this);\n    }\n};\n\n/**\n * Delete a super property stored with the current user.\n *\n * @param {String} property The name of the super property to remove\n * @param {Object} [options]\n * @param {boolean} [options.persistent=true] - whether to look in persistent storage (cookie/localStorage)\n */\nMixpanelLib.prototype.unregister = function(property, options) {\n    options = options_for_register(options);\n    if (options['persistent']) {\n        this['persistence'].unregister(property);\n    } else {\n        delete this.unpersisted_superprops[property];\n    }\n};\n\nMixpanelLib.prototype._register_single = function(prop, value) {\n    var props = {};\n    props[prop] = value;\n    this.register(props);\n};\n\n/**\n * Identify a user with a unique ID to track user activity across\n * devices, tie a user to their events, and create a user profile.\n * If you never call this method, unique visitors are tracked using\n * a UUID generated the first time they visit the site.\n *\n * Call identify when you know the identity of the current user,\n * typically after login or signup. We recommend against using\n * identify for anonymous visitors to your site.\n *\n * ### Notes:\n * If your project has\n * <a href=\"https://help.mixpanel.com/hc/en-us/articles/360039133851\">ID Merge</a>\n * enabled, the identify method will connect pre- and\n * post-authentication events when appropriate.\n *\n * If your project does not have ID Merge enabled, identify will\n * change the user's local distinct_id to the unique ID you pass.\n * Events tracked prior to authentication will not be connected\n * to the same user identity. If ID Merge is disabled, alias can\n * be used to connect pre- and post-registration events.\n *\n * @param {String} [unique_id] A string that uniquely identifies a user. If not provided, the distinct_id currently in the persistent store (cookie or localStorage) will be used.\n */\nMixpanelLib.prototype.identify = function(\n    new_distinct_id, _set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback\n) {\n    // Optional Parameters\n    //  _set_callback:function  A callback to be run if and when the People set queue is flushed\n    //  _add_callback:function  A callback to be run if and when the People add queue is flushed\n    //  _append_callback:function  A callback to be run if and when the People append queue is flushed\n    //  _set_once_callback:function  A callback to be run if and when the People set_once queue is flushed\n    //  _union_callback:function  A callback to be run if and when the People union queue is flushed\n    //  _unset_callback:function  A callback to be run if and when the People unset queue is flushed\n\n    var previous_distinct_id = this.get_distinct_id();\n    if (new_distinct_id && previous_distinct_id !== new_distinct_id) {\n        // we allow the following condition if previous distinct_id is same as new_distinct_id\n        // so that you can force flush people updates for anonymous profiles.\n        if (typeof new_distinct_id === 'string' && new_distinct_id.indexOf(DEVICE_ID_PREFIX) === 0) {\n            this.report_error('distinct_id cannot have $device: prefix');\n            return -1;\n        }\n        this.register({'$user_id': new_distinct_id});\n    }\n\n    if (!this.get_property('$device_id')) {\n        // The persisted distinct id might not actually be a device id at all\n        // it might be a distinct id of the user from before\n        var device_id = previous_distinct_id;\n        this.register_once({\n            '$had_persisted_distinct_id': true,\n            '$device_id': device_id\n        }, '');\n    }\n\n    // identify only changes the distinct id if it doesn't match either the existing or the alias;\n    // if it's new, blow away the alias as well.\n    if (new_distinct_id !== previous_distinct_id && new_distinct_id !== this.get_property(ALIAS_ID_KEY)) {\n        this.unregister(ALIAS_ID_KEY);\n        this.register({'distinct_id': new_distinct_id});\n    }\n    this._flags.identify_called = true;\n    // Flush any queued up people requests\n    this['people']._flush(_set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback);\n\n    // send an $identify event any time the distinct_id is changing - logic on the server\n    // will determine whether or not to do anything with it.\n    if (new_distinct_id !== previous_distinct_id) {\n        this.track('$identify', {\n            'distinct_id': new_distinct_id,\n            '$anon_distinct_id': previous_distinct_id\n        }, {skip_hooks: true});\n    }\n\n    // check feature flags again if distinct id has changed\n    if (new_distinct_id !== previous_distinct_id) {\n        this.flags.fetchFlags();\n    }\n};\n\n/**\n * Clears super properties and generates a new random distinct_id for this instance.\n * Useful for clearing data when a user logs out.\n */\nMixpanelLib.prototype.reset = function() {\n    this.stop_session_recording();\n    this['persistence'].clear();\n    this._flags.identify_called = false;\n    var uuid = _.UUID();\n    this.register_once({\n        'distinct_id': DEVICE_ID_PREFIX + uuid,\n        '$device_id': uuid\n    }, '');\n    this._check_and_start_session_recording();\n};\n\n/**\n * Returns the current distinct id of the user. This is either the id automatically\n * generated by the library or the id that has been passed by a call to identify().\n *\n * ### Notes:\n *\n * get_distinct_id() can only be called after the Mixpanel library has finished loading.\n * init() has a loaded function available to handle this automatically. For example:\n *\n *     // set distinct_id after the mixpanel library has loaded\n *     mixpanel.init('YOUR PROJECT TOKEN', {\n *         loaded: function(mixpanel) {\n *             distinct_id = mixpanel.get_distinct_id();\n *         }\n *     });\n */\nMixpanelLib.prototype.get_distinct_id = function() {\n    return this.get_property('distinct_id');\n};\n\n/**\n * The alias method creates an alias which Mixpanel will use to\n * remap one id to another. Multiple aliases can point to the\n * same identifier.\n *\n * The following is a valid use of alias:\n *\n *     mixpanel.alias('new_id', 'existing_id');\n *     // You can add multiple id aliases to the existing ID\n *     mixpanel.alias('newer_id', 'existing_id');\n *\n * Aliases can also be chained - the following is a valid example:\n *\n *     mixpanel.alias('new_id', 'existing_id');\n *     // chain newer_id - new_id - existing_id\n *     mixpanel.alias('newer_id', 'new_id');\n *\n * Aliases cannot point to multiple identifiers - the following\n * example will not work:\n *\n *     mixpanel.alias('new_id', 'existing_id');\n *     // this is invalid as 'new_id' already points to 'existing_id'\n *     mixpanel.alias('new_id', 'newer_id');\n *\n * ### Notes:\n *\n * If your project does not have\n * <a href=\"https://help.mixpanel.com/hc/en-us/articles/360039133851\">ID Merge</a>\n * enabled, the best practice is to call alias once when a unique\n * ID is first created for a user (e.g., when a user first registers\n * for an account). Do not use alias multiple times for a single\n * user without ID Merge enabled.\n *\n * @param {String} alias A unique identifier that you want to use for this user in the future.\n * @param {String} [original] The current identifier being used for this user.\n */\nMixpanelLib.prototype.alias = function(alias, original) {\n    // If the $people_distinct_id key exists in persistence, there has been a previous\n    // mixpanel.people.identify() call made for this user. It is VERY BAD to make an alias with\n    // this ID, as it will duplicate users.\n    if (alias === this.get_property(PEOPLE_DISTINCT_ID_KEY)) {\n        this.report_error('Attempting to create alias for existing People user - aborting.');\n        return -2;\n    }\n\n    var _this = this;\n    if (_.isUndefined(original)) {\n        original = this.get_distinct_id();\n    }\n    if (alias !== original) {\n        this._register_single(ALIAS_ID_KEY, alias);\n        return this.track('$create_alias', {\n            'alias': alias,\n            'distinct_id': original\n        }, {\n            skip_hooks: true\n        }, function() {\n            // Flush the people queue\n            _this.identify(alias);\n        });\n    } else {\n        this.report_error('alias matches current distinct_id - skipping api call.');\n        this.identify(alias);\n        return -1;\n    }\n};\n\n/**\n * Provide a string to recognize the user by. The string passed to\n * this method will appear in the Mixpanel Streams product rather\n * than an automatically generated name. Name tags do not have to\n * be unique.\n *\n * This value will only be included in Streams data.\n *\n * @param {String} name_tag A human readable name for the user\n * @deprecated\n */\nMixpanelLib.prototype.name_tag = function(name_tag) {\n    this._register_single('mp_name_tag', name_tag);\n};\n\n/**\n * Update the configuration of a mixpanel library instance.\n *\n * The default config is:\n *\n *     {\n *       // host for requests (customizable for e.g. a local proxy)\n *       api_host: 'https://api-js.mixpanel.com',\n *\n *       // endpoints for different types of requests\n *       api_routes: {\n *         track: 'track/',\n *         engage: 'engage/',\n *         groups: 'groups/',\n *       }\n *\n *       // HTTP method for tracking requests\n *       api_method: 'POST'\n *\n *       // transport for sending requests ('XHR' or 'sendBeacon')\n *       // NB: sendBeacon should only be used for scenarios such as\n *       // page unload where a \"best-effort\" attempt to send is\n *       // acceptable; the sendBeacon API does not support callbacks\n *       // or any way to know the result of the request. Mixpanel\n *       // tracking via sendBeacon will not support any event-\n *       // batching or retry mechanisms.\n *       api_transport: 'XHR'\n *\n *       // request-batching/queueing/retry\n *       batch_requests: true,\n *\n *       // maximum number of events/updates to send in a single\n *       // network request\n *       batch_size: 50,\n *\n *       // milliseconds to wait between sending batch requests\n *       batch_flush_interval_ms: 5000,\n *\n *       // milliseconds to wait for network responses to batch requests\n *       // before they are considered timed-out and retried\n *       batch_request_timeout_ms: 90000,\n *\n *       // override value for cookie domain, only useful for ensuring\n *       // correct cross-subdomain cookies on unusual domains like\n *       // subdomain.mainsite.avocat.fr; NB this cannot be used to\n *       // set cookies on a different domain than the current origin\n *       cookie_domain: ''\n *\n *       // super properties cookie expiration (in days)\n *       cookie_expiration: 365\n *\n *       // if true, cookie will be set with SameSite=None; Secure\n *       // this is only useful in special situations, like embedded\n *       // 3rd-party iframes that set up a Mixpanel instance\n *       cross_site_cookie: false\n *\n *       // super properties span subdomains\n *       cross_subdomain_cookie: true\n *\n *       // debug mode\n *       debug: false\n *\n *       // if this is true, the mixpanel cookie or localStorage entry\n *       // will be deleted, and no user persistence will take place\n *       disable_persistence: false\n *\n *       // if this is true, Mixpanel will automatically determine\n *       // City, Region and Country data using the IP address of\n *       //the client\n *       ip: true\n *\n *       // opt users out of tracking by this Mixpanel instance by default\n *       opt_out_tracking_by_default: false\n *\n *       // opt users out of browser data storage by this Mixpanel instance by default\n *       opt_out_persistence_by_default: false\n *\n *       // persistence mechanism used by opt-in/opt-out methods - cookie\n *       // or localStorage - falls back to cookie if localStorage is unavailable\n *       opt_out_tracking_persistence_type: 'localStorage'\n *\n *       // customize the name of cookie/localStorage set by opt-in/opt-out methods\n *       opt_out_tracking_cookie_prefix: null\n *\n *       // type of persistent store for super properties (cookie/\n *       // localStorage) if set to 'localStorage', any existing\n *       // mixpanel cookie value with the same persistence_name\n *       // will be transferred to localStorage and deleted\n *       persistence: 'cookie'\n *\n *       // name for super properties persistent store\n *       persistence_name: ''\n *\n *       // names of properties/superproperties which should never\n *       // be sent with track() calls\n *       property_blacklist: []\n *\n *       // if this is true, mixpanel cookies will be marked as\n *       // secure, meaning they will only be transmitted over https\n *       secure_cookie: false\n *\n *       // disables enriching user profiles with first touch marketing data\n *       skip_first_touch_marketing: false\n *\n *       // the amount of time track_links will\n *       // wait for Mixpanel's servers to respond\n *       track_links_timeout: 300\n *\n *       // adds any UTM parameters and click IDs present on the page to any events fired\n *       track_marketing: true\n *\n *       // enables automatic page view tracking using default page view events through\n *       // the track_pageview() method\n *       track_pageview: false\n *\n *       // if you set upgrade to be true, the library will check for\n *       // a cookie from our old js library and import super\n *       // properties from it, then the old cookie is deleted\n *       // The upgrade config option only works in the initialization,\n *       // so make sure you set it when you create the library.\n *       upgrade: false\n *\n *       // extra HTTP request headers to set for each API request, in\n *       // the format {'Header-Name': value}\n *       xhr_headers: {}\n *\n *       // whether to ignore or respect the web browser's Do Not Track setting\n *       ignore_dnt: false\n *     }\n *\n *\n * @param {Object} config A dictionary of new configuration values to update\n */\nMixpanelLib.prototype.set_config = function(config) {\n    if (_.isObject(config)) {\n        _.extend(this['config'], config);\n\n        var new_batch_size = config['batch_size'];\n        if (new_batch_size) {\n            _.each(this.request_batchers, function(batcher) {\n                batcher.resetBatchSize();\n            });\n        }\n\n        if (!this.get_config('persistence_name')) {\n            this['config']['persistence_name'] = this['config']['cookie_name'];\n        }\n        if (!this.get_config('disable_persistence')) {\n            this['config']['disable_persistence'] = this['config']['disable_cookie'];\n        }\n\n        if (this['persistence']) {\n            this['persistence'].update_config(this['config']);\n        }\n        Config.DEBUG = Config.DEBUG || this.get_config('debug');\n\n        if (('autocapture' in config || 'record_heatmap_data' in config) && this.autocapture) {\n            this.autocapture.init();\n        }\n    }\n};\n\n/**\n * returns the current config object for the library.\n */\nMixpanelLib.prototype.get_config = function(prop_name) {\n    return this['config'][prop_name];\n};\n\n/**\n * Fetch a hook function from config, with safe default, and run it\n * against the given arguments\n * @param {string} hook_name which hook to retrieve\n * @returns {any|null} return value of user-provided hook, or null if nothing was returned\n */\nMixpanelLib.prototype._run_hook = function(hook_name) {\n    var ret = (this['config']['hooks'][hook_name] || IDENTITY_FUNC).apply(this, slice.call(arguments, 1));\n    if (typeof ret === 'undefined') {\n        this.report_error(hook_name + ' hook did not return a value');\n        ret = null;\n    }\n    return ret;\n};\n\n/**\n * Returns the value of the super property named property_name. If no such\n * property is set, get_property() will return the undefined value.\n *\n * ### Notes:\n *\n * get_property() can only be called after the Mixpanel library has finished loading.\n * init() has a loaded function available to handle this automatically. For example:\n *\n *     // grab value for 'user_id' after the mixpanel library has loaded\n *     mixpanel.init('YOUR PROJECT TOKEN', {\n *         loaded: function(mixpanel) {\n *             user_id = mixpanel.get_property('user_id');\n *         }\n *     });\n *\n * @param {String} property_name The name of the super property you want to retrieve\n */\nMixpanelLib.prototype.get_property = function(property_name) {\n    return this['persistence'].load_prop([property_name]);\n};\n\n/**\n * Get the API host for a specific endpoint type, falling back to the default api_host if not specified\n *\n * @param {String} endpoint_type The type of endpoint (e.g., \"events\", \"people\", \"groups\")\n * @returns {String} The API host to use for this endpoint\n */\nMixpanelLib.prototype.get_api_host = function(endpoint_type) {\n    return this.get_config('api_hosts')[endpoint_type] || this.get_config('api_host');\n};\n\nMixpanelLib.prototype.toString = function() {\n    var name = this.get_config('name');\n    if (name !== PRIMARY_INSTANCE_NAME) {\n        name = PRIMARY_INSTANCE_NAME + '.' + name;\n    }\n    return name;\n};\n\nMixpanelLib.prototype._event_is_disabled = function(event_name) {\n    return _.isBlockedUA(userAgent) ||\n        this._flags.disable_all_events ||\n        _.include(this.__disabled_events, event_name);\n};\n\n// perform some housekeeping around GDPR opt-in/out state\nMixpanelLib.prototype._gdpr_init = function() {\n    var is_localStorage_requested = this.get_config('opt_out_tracking_persistence_type') === 'localStorage';\n\n    // try to convert opt-in/out cookies to localStorage if possible\n    if (is_localStorage_requested && _.localStorage.is_supported()) {\n        if (!this.has_opted_in_tracking() && this.has_opted_in_tracking({'persistence_type': 'cookie'})) {\n            this.opt_in_tracking({'enable_persistence': false});\n        }\n        if (!this.has_opted_out_tracking() && this.has_opted_out_tracking({'persistence_type': 'cookie'})) {\n            this.opt_out_tracking({'clear_persistence': false});\n        }\n        this.clear_opt_in_out_tracking({\n            'persistence_type': 'cookie',\n            'enable_persistence': false\n        });\n    }\n\n    // check whether the user has already opted out - if so, clear & disable persistence\n    if (this.has_opted_out_tracking()) {\n        this._gdpr_update_persistence({'clear_persistence': true});\n\n    // check whether we should opt out by default\n    // note: we don't clear persistence here by default since opt-out default state is often\n    //       used as an initial state while GDPR information is being collected\n    } else if (!this.has_opted_in_tracking() && (\n        this.get_config('opt_out_tracking_by_default') || _.cookie.get('mp_optout')\n    )) {\n        _.cookie.remove('mp_optout');\n        this.opt_out_tracking({\n            'clear_persistence': this.get_config('opt_out_persistence_by_default')\n        });\n    }\n};\n\n/**\n * Enable or disable persistence based on options\n * only enable/disable if persistence is not already in this state\n * @param {boolean} [options.clear_persistence] If true, will delete all data stored by the sdk in persistence and disable it\n * @param {boolean} [options.enable_persistence] If true, will re-enable sdk persistence\n */\nMixpanelLib.prototype._gdpr_update_persistence = function(options) {\n    var disabled;\n    if (options && options['clear_persistence']) {\n        disabled = true;\n    } else if (options && options['enable_persistence']) {\n        disabled = false;\n    } else {\n        return;\n    }\n\n    if (!this.get_config('disable_persistence') && this['persistence'].disabled !== disabled) {\n        this['persistence'].set_disabled(disabled);\n    }\n\n    if (disabled) {\n        this.stop_batch_senders();\n        this.stop_session_recording();\n    } else {\n        // only start batchers after opt-in if they have previously been started\n        // in order to avoid unintentionally starting up batching for the first time\n        if (this._batchers_were_started) {\n            this.start_batch_senders();\n        }\n    }\n};\n\n// call a base gdpr function after constructing the appropriate token and options args\nMixpanelLib.prototype._gdpr_call_func = function(func, options) {\n    options = _.extend({\n        'track': _.bind(this.track, this),\n        'persistence_type': this.get_config('opt_out_tracking_persistence_type'),\n        'cookie_prefix': this.get_config('opt_out_tracking_cookie_prefix'),\n        'cookie_expiration': this.get_config('cookie_expiration'),\n        'cross_site_cookie': this.get_config('cross_site_cookie'),\n        'cross_subdomain_cookie': this.get_config('cross_subdomain_cookie'),\n        'cookie_domain': this.get_config('cookie_domain'),\n        'secure_cookie': this.get_config('secure_cookie'),\n        'ignore_dnt': this.get_config('ignore_dnt')\n    }, options);\n\n    // check if localStorage can be used for recording opt out status, fall back to cookie if not\n    if (!_.localStorage.is_supported()) {\n        options['persistence_type'] = 'cookie';\n    }\n\n    return func(this.get_config('token'), {\n        track: options['track'],\n        trackEventName: options['track_event_name'],\n        trackProperties: options['track_properties'],\n        persistenceType: options['persistence_type'],\n        persistencePrefix: options['cookie_prefix'],\n        cookieDomain: options['cookie_domain'],\n        cookieExpiration: options['cookie_expiration'],\n        crossSiteCookie: options['cross_site_cookie'],\n        crossSubdomainCookie: options['cross_subdomain_cookie'],\n        secureCookie: options['secure_cookie'],\n        ignoreDnt: options['ignore_dnt']\n    });\n};\n\n/**\n * Opt the user in to data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     // opt user in\n *     mixpanel.opt_in_tracking();\n *\n *     // opt user in with specific event name, properties, cookie configuration\n *     mixpanel.opt_in_tracking({\n *         track_event_name: 'User opted in',\n *         track_event_properties: {\n *             'Email': 'jdoe@example.com'\n *         },\n *         cookie_expiration: 30,\n *         secure_cookie: true\n *     });\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {function} [options.track] Function used for tracking a Mixpanel event to record the opt-in action (default is this Mixpanel instance's track method)\n * @param {string} [options.track_event_name=$opt_in] Event name to be used for tracking the opt-in action\n * @param {Object} [options.track_properties] Set of properties to be tracked along with the opt-in action\n * @param {boolean} [options.enable_persistence=true] If true, will re-enable sdk persistence\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookie_expiration] Number of days until the opt-in cookie expires (overrides value specified in this Mixpanel instance's config)\n * @param {string} [options.cookie_domain] Custom cookie domain (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_site_cookie] Whether the opt-in cookie is set as cross-site-enabled (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_subdomain_cookie] Whether the opt-in cookie is set as cross-subdomain or not (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.secure_cookie] Whether the opt-in cookie is set as secure or not (overrides value specified in this Mixpanel instance's config)\n */\nMixpanelLib.prototype.opt_in_tracking = function(options) {\n    options = _.extend({\n        'enable_persistence': true\n    }, options);\n\n    this._gdpr_call_func(optIn, options);\n    this._gdpr_update_persistence(options);\n};\n\n/**\n * Opt the user out of data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     // opt user out\n *     mixpanel.opt_out_tracking();\n *\n *     // opt user out with different cookie configuration from Mixpanel instance\n *     mixpanel.opt_out_tracking({\n *         cookie_expiration: 30,\n *         secure_cookie: true\n *     });\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {boolean} [options.delete_user=true] If true, will delete the currently identified user's profile and clear all charges after opting the user out\n * @param {boolean} [options.clear_persistence=true] If true, will delete all data stored by the sdk in persistence\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookie_expiration] Number of days until the opt-in cookie expires (overrides value specified in this Mixpanel instance's config)\n * @param {string} [options.cookie_domain] Custom cookie domain (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_site_cookie] Whether the opt-in cookie is set as cross-site-enabled (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_subdomain_cookie] Whether the opt-in cookie is set as cross-subdomain or not (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.secure_cookie] Whether the opt-in cookie is set as secure or not (overrides value specified in this Mixpanel instance's config)\n */\nMixpanelLib.prototype.opt_out_tracking = function(options) {\n    options = _.extend({\n        'clear_persistence': true,\n        'delete_user': true\n    }, options);\n\n    // delete user and clear charges since these methods may be disabled by opt-out\n    if (options['delete_user'] && this['people'] && this['people']._identify_called()) {\n        this['people'].delete_user();\n        this['people'].clear_charges();\n    }\n\n    this._gdpr_call_func(optOut, options);\n    this._gdpr_update_persistence(options);\n};\n\n/**\n * Check whether the user has opted in to data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     var has_opted_in = mixpanel.has_opted_in_tracking();\n *     // use has_opted_in value\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @returns {boolean} current opt-in status\n */\nMixpanelLib.prototype.has_opted_in_tracking = function(options) {\n    return this._gdpr_call_func(hasOptedIn, options);\n};\n\n/**\n * Check whether the user has opted out of data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     var has_opted_out = mixpanel.has_opted_out_tracking();\n *     // use has_opted_out value\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @returns {boolean} current opt-out status\n */\nMixpanelLib.prototype.has_opted_out_tracking = function(options) {\n    return this._gdpr_call_func(hasOptedOut, options);\n};\n\n/**\n * Clear the user's opt in/out status of data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     // clear user's opt-in/out status\n *     mixpanel.clear_opt_in_out_tracking();\n *\n *     // clear user's opt-in/out status with specific cookie configuration - should match\n *     // configuration used when opt_in_tracking/opt_out_tracking methods were called.\n *     mixpanel.clear_opt_in_out_tracking({\n *         cookie_expiration: 30,\n *         secure_cookie: true\n *     });\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {boolean} [options.enable_persistence=true] If true, will re-enable sdk persistence\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookie_expiration] Number of days until the opt-in cookie expires (overrides value specified in this Mixpanel instance's config)\n * @param {string} [options.cookie_domain] Custom cookie domain (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_site_cookie] Whether the opt-in cookie is set as cross-site-enabled (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_subdomain_cookie] Whether the opt-in cookie is set as cross-subdomain or not (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.secure_cookie] Whether the opt-in cookie is set as secure or not (overrides value specified in this Mixpanel instance's config)\n */\nMixpanelLib.prototype.clear_opt_in_out_tracking = function(options) {\n    options = _.extend({\n        'enable_persistence': true\n    }, options);\n\n    this._gdpr_call_func(clearOptInOut, options);\n    this._gdpr_update_persistence(options);\n};\n\nMixpanelLib.prototype.report_error = function(msg, err) {\n    console$1.error.apply(console$1.error, arguments);\n    try {\n        if (!err && !(msg instanceof Error)) {\n            msg = new Error(msg);\n        }\n        this.get_config('error_reporter')(msg, err);\n    } catch(err) {\n        console$1.error(err);\n    }\n};\n\n// EXPORTS (for closure compiler)\n\n// MixpanelLib Exports\nMixpanelLib.prototype['init']                               = MixpanelLib.prototype.init;\nMixpanelLib.prototype['reset']                              = MixpanelLib.prototype.reset;\nMixpanelLib.prototype['disable']                            = MixpanelLib.prototype.disable;\nMixpanelLib.prototype['time_event']                         = MixpanelLib.prototype.time_event;\nMixpanelLib.prototype['track']                              = MixpanelLib.prototype.track;\nMixpanelLib.prototype['track_links']                        = MixpanelLib.prototype.track_links;\nMixpanelLib.prototype['track_forms']                        = MixpanelLib.prototype.track_forms;\nMixpanelLib.prototype['track_pageview']                     = MixpanelLib.prototype.track_pageview;\nMixpanelLib.prototype['register']                           = MixpanelLib.prototype.register;\nMixpanelLib.prototype['register_once']                      = MixpanelLib.prototype.register_once;\nMixpanelLib.prototype['unregister']                         = MixpanelLib.prototype.unregister;\nMixpanelLib.prototype['identify']                           = MixpanelLib.prototype.identify;\nMixpanelLib.prototype['alias']                              = MixpanelLib.prototype.alias;\nMixpanelLib.prototype['name_tag']                           = MixpanelLib.prototype.name_tag;\nMixpanelLib.prototype['set_config']                         = MixpanelLib.prototype.set_config;\nMixpanelLib.prototype['get_config']                         = MixpanelLib.prototype.get_config;\nMixpanelLib.prototype['get_api_host']                       = MixpanelLib.prototype.get_api_host;\nMixpanelLib.prototype['get_property']                       = MixpanelLib.prototype.get_property;\nMixpanelLib.prototype['get_distinct_id']                    = MixpanelLib.prototype.get_distinct_id;\nMixpanelLib.prototype['toString']                           = MixpanelLib.prototype.toString;\nMixpanelLib.prototype['opt_out_tracking']                   = MixpanelLib.prototype.opt_out_tracking;\nMixpanelLib.prototype['opt_in_tracking']                    = MixpanelLib.prototype.opt_in_tracking;\nMixpanelLib.prototype['has_opted_out_tracking']             = MixpanelLib.prototype.has_opted_out_tracking;\nMixpanelLib.prototype['has_opted_in_tracking']              = MixpanelLib.prototype.has_opted_in_tracking;\nMixpanelLib.prototype['clear_opt_in_out_tracking']          = MixpanelLib.prototype.clear_opt_in_out_tracking;\nMixpanelLib.prototype['get_group']                          = MixpanelLib.prototype.get_group;\nMixpanelLib.prototype['set_group']                          = MixpanelLib.prototype.set_group;\nMixpanelLib.prototype['add_group']                          = MixpanelLib.prototype.add_group;\nMixpanelLib.prototype['remove_group']                       = MixpanelLib.prototype.remove_group;\nMixpanelLib.prototype['track_with_groups']                  = MixpanelLib.prototype.track_with_groups;\nMixpanelLib.prototype['start_batch_senders']                = MixpanelLib.prototype.start_batch_senders;\nMixpanelLib.prototype['stop_batch_senders']                 = MixpanelLib.prototype.stop_batch_senders;\nMixpanelLib.prototype['start_session_recording']            = MixpanelLib.prototype.start_session_recording;\nMixpanelLib.prototype['stop_session_recording']             = MixpanelLib.prototype.stop_session_recording;\nMixpanelLib.prototype['pause_session_recording']            = MixpanelLib.prototype.pause_session_recording;\nMixpanelLib.prototype['resume_session_recording']           = MixpanelLib.prototype.resume_session_recording;\nMixpanelLib.prototype['get_session_recording_properties']   = MixpanelLib.prototype.get_session_recording_properties;\nMixpanelLib.prototype['get_session_replay_url']             = MixpanelLib.prototype.get_session_replay_url;\nMixpanelLib.prototype['get_tab_id']                         = MixpanelLib.prototype.get_tab_id;\nMixpanelLib.prototype['DEFAULT_API_ROUTES']                 = DEFAULT_API_ROUTES;\n\n// Exports intended only for testing\nMixpanelLib.prototype['__get_recorder']                     = MixpanelLib.prototype.__get_recorder;\n\n// MixpanelPersistence Exports\nMixpanelPersistence.prototype['properties']            = MixpanelPersistence.prototype.properties;\nMixpanelPersistence.prototype['update_search_keyword'] = MixpanelPersistence.prototype.update_search_keyword;\nMixpanelPersistence.prototype['update_referrer_info']  = MixpanelPersistence.prototype.update_referrer_info;\nMixpanelPersistence.prototype['get_cross_subdomain']   = MixpanelPersistence.prototype.get_cross_subdomain;\nMixpanelPersistence.prototype['clear']                 = MixpanelPersistence.prototype.clear;\n\n\nvar instances = {};\nvar extend_mp = function() {\n    // add all the sub mixpanel instances\n    _.each(instances, function(instance, name) {\n        if (name !== PRIMARY_INSTANCE_NAME) { mixpanel_master[name] = instance; }\n    });\n\n    // add private functions as _\n    mixpanel_master['_'] = _;\n};\n\nvar override_mp_init_func = function() {\n    // we override the snippets init function to handle the case where a\n    // user initializes the mixpanel library after the script loads & runs\n    mixpanel_master['init'] = function(token, config, name) {\n        if (name) {\n            // initialize a sub library\n            if (!mixpanel_master[name]) {\n                mixpanel_master[name] = instances[name] = create_mplib(token, config, name);\n                mixpanel_master[name]._loaded();\n            }\n            return mixpanel_master[name];\n        } else {\n            var instance = mixpanel_master;\n\n            if (instances[PRIMARY_INSTANCE_NAME]) {\n                // main mixpanel lib already initialized\n                instance = instances[PRIMARY_INSTANCE_NAME];\n            } else if (token) {\n                // intialize the main mixpanel lib\n                instance = create_mplib(token, config, PRIMARY_INSTANCE_NAME);\n                instance._loaded();\n                instances[PRIMARY_INSTANCE_NAME] = instance;\n            }\n\n            mixpanel_master = instance;\n            if (init_type === INIT_SNIPPET) {\n                win[PRIMARY_INSTANCE_NAME] = mixpanel_master;\n            }\n            extend_mp();\n        }\n    };\n};\n\nvar add_dom_loaded_handler = function() {\n    // Cross browser DOM Loaded support\n    function dom_loaded_handler() {\n        // function flag since we only want to execute this once\n        if (dom_loaded_handler.done) { return; }\n        dom_loaded_handler.done = true;\n\n        DOM_LOADED = true;\n        ENQUEUE_REQUESTS = false;\n\n        _.each(instances, function(inst) {\n            inst._dom_loaded();\n        });\n    }\n\n    function do_scroll_check() {\n        try {\n            document$1.documentElement.doScroll('left');\n        } catch(e) {\n            setTimeout(do_scroll_check, 1);\n            return;\n        }\n\n        dom_loaded_handler();\n    }\n\n    if (document$1.addEventListener) {\n        if (document$1.readyState === 'complete') {\n            // safari 4 can fire the DOMContentLoaded event before loading all\n            // external JS (including this file). you will see some copypasta\n            // on the internet that checks for 'complete' and 'loaded', but\n            // 'loaded' is an IE thing\n            dom_loaded_handler();\n        } else {\n            document$1.addEventListener('DOMContentLoaded', dom_loaded_handler, false);\n        }\n    } else if (document$1.attachEvent) {\n        // IE\n        document$1.attachEvent('onreadystatechange', dom_loaded_handler);\n\n        // check to make sure we arn't in a frame\n        var toplevel = false;\n        try {\n            toplevel = win.frameElement === null;\n        } catch(e) {\n            // noop\n        }\n\n        if (document$1.documentElement.doScroll && toplevel) {\n            do_scroll_check();\n        }\n    }\n\n    // fallback handler, always will work\n    _.register_event(win, 'load', dom_loaded_handler, true);\n};\n\nfunction init_as_module(bundle_loader) {\n    load_extra_bundle = bundle_loader;\n    init_type = INIT_MODULE;\n    mixpanel_master = new MixpanelLib();\n\n    override_mp_init_func();\n    mixpanel_master['init']();\n    add_dom_loaded_handler();\n\n    return mixpanel_master;\n}\n\n// For loading separate bundles asynchronously via script tag\n// so that we don't load them until they are needed at runtime.\n\n// For builds that have everything in one bundle, no extra work.\nfunction loadNoop (_src, onload) {\n    onload();\n}\n\n/* eslint camelcase: \"off\" */\n\nvar mixpanel = init_as_module(loadNoop);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL21peHBhbmVsLWJyb3dzZXIvZGlzdC9taXhwYW5lbC5tb2R1bGUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdCQUF3Qiw2QkFBNkI7QUFDdEUscUJBQXFCLDZCQUE2QjtBQUNsRDtBQUNBLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHO0FBQ2pHLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlCQUFpQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx3REFBd0Q7QUFDekcsNkRBQTZELHFDQUFxQyxzQkFBc0I7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkMsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRiw0QkFBNEI7QUFDNUc7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BELE1BQU07QUFDTixvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDRCQUE0QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHVEQUF1RCxTQUFTO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRUQUE0VCw0TUFBNE07QUFDeGdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1RQUFtUSwyS0FBMks7QUFDOWE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc2tCQUFza0IscVBBQXFQO0FBQzN6QjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlIQUFpSCw0QkFBNEI7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEhBQThILDhCQUE4QjtBQUM1SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0seUJBQXlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGNBQWM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLDRCQUE0QjtBQUM3SDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEVBQUU7QUFDbEQ7QUFDQSxvREFBb0QsRUFBRTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGFBQWE7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRiw0QkFBNEI7QUFDaEg7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxlQUFlO0FBQ3JFLCtDQUErQztBQUMvQyxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRiw0QkFBNEI7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxTQUFTO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLDRCQUE0QjtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsYUFBYTtBQUM1RjtBQUNBO0FBQ0EsbUZBQW1GLDRCQUE0QjtBQUMvRztBQUNBO0FBQ0Esc0ZBQXNGLDhCQUE4QjtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5Riw0QkFBNEI7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSwyRkFBMkYsYUFBYTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLG1IQUFtSCxhQUFhO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsNEJBQTRCO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRiw0QkFBNEI7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLG9GQUFvRiw0QkFBNEI7QUFDaEg7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0Esc0ZBQXNGLDhCQUE4QjtBQUNwSDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxhQUFhO0FBQzVGO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRiw0QkFBNEI7QUFDL0c7QUFDQTtBQUNBLHNGQUFzRiw4QkFBOEI7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsNEJBQTRCO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQyx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGFBQWE7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGFBQWE7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsY0FBYztBQUNkLHdGQUF3Riw0QkFBNEI7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsNEJBQTRCO0FBQzdHO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvQkFBb0I7QUFDbEMsZ0NBQWdDO0FBQ2hDLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRiw0QkFBNEI7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywrQ0FBK0M7QUFDN0Q7QUFDQSxnQ0FBZ0M7QUFDaEMsY0FBYztBQUNkLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixZQUFZLElBQXFDO0FBQ2pEO0FBQ0E7QUFDQSwyRkFBMkY7QUFDM0Ysa0JBQWtCO0FBQ2xCLDJGQUEyRjtBQUMzRixrQkFBa0I7QUFDbEIsMkZBQTJGO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLG9CQUFvQixJQUFxQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLDRCQUE0QjtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLDRCQUE0QjtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0csOEJBQThCO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsNEJBQTRCO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRiw0QkFBNEI7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsNEJBQTRCO0FBQzlHO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZCxvQkFBb0IsSUFBcUM7QUFDekQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLDRCQUE0QjtBQUNoSDtBQUNBLDJDQUEyQztBQUMzQztBQUNBLGFBQWE7QUFDYjtBQUNBLCtDQUErQztBQUMvQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLGFBQWE7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsYUFBYTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxjQUFjO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyw0QkFBNEI7QUFDN0g7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxFQUFFO0FBQ2xEO0FBQ0Esb0RBQW9ELEVBQUU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxhQUFhO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsNEJBQTRCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsZUFBZTtBQUNyRSwrQ0FBK0M7QUFDL0Msa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QyxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsNEJBQTRCO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsU0FBUztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4Riw0QkFBNEI7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGFBQWE7QUFDNUY7QUFDQTtBQUNBLG1GQUFtRiw0QkFBNEI7QUFDL0c7QUFDQTtBQUNBLHNGQUFzRiw4QkFBOEI7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsNEJBQTRCO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsMkZBQTJGLGFBQWE7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxtSEFBbUgsYUFBYTtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLDRCQUE0QjtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsNEJBQTRCO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxvRkFBb0YsNEJBQTRCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHNGQUFzRiw4QkFBOEI7QUFDcEg7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsYUFBYTtBQUM1RjtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsNEJBQTRCO0FBQy9HO0FBQ0E7QUFDQSxzRkFBc0YsOEJBQThCO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLDRCQUE0QjtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekMscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxhQUFhO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxhQUFhO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGNBQWM7QUFDZCx3RkFBd0YsNEJBQTRCO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLDRCQUE0QjtBQUM3RztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDLGdDQUFnQztBQUNoQyxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsNEJBQTRCO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0NBQStDO0FBQzdEO0FBQ0EsZ0NBQWdDO0FBQ2hDLGNBQWM7QUFDZCwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sWUFBWSxJQUFxQztBQUNqRDtBQUNBO0FBQ0EsMkZBQTJGO0FBQzNGLGtCQUFrQjtBQUNsQiwyRkFBMkY7QUFDM0Ysa0JBQWtCO0FBQ2xCLDJGQUEyRjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxvQkFBb0IsSUFBcUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1Riw0QkFBNEI7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1Riw0QkFBNEI7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HLDhCQUE4QjtBQUNsSTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLDRCQUE0QjtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsNEJBQTRCO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLDRCQUE0QjtBQUM5RztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Qsb0JBQW9CLElBQXFDO0FBQ3pEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRiw0QkFBNEI7QUFDaEg7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxhQUFhO0FBQ2I7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxhQUFhO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGFBQWE7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsYUFBYTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxhQUFhO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxHQUFHO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdCQUFnQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsbUJBQW1CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGVBQWU7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLDRCQUE0QjtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YsOEJBQThCO0FBQzdIO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwySEFBMkgsNEJBQTRCO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBIQUEwSCw4QkFBOEI7QUFDeEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGFBQWE7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxR0FBcUc7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1DQUFtQyxvQkFBb0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxhQUFhO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsNEJBQTRCO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLDRCQUE0QjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLGFBQWE7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNEJBQTRCO0FBQzFHO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRyxhQUFhO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsYUFBYTtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsNEJBQTRCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTixnREFBZ0Q7QUFDaEQ7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLDRCQUE0QjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDgyQ0FBODJDLGdJQUFnSTtBQUM5K0M7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3Riw0QkFBNEI7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0ZBQW9GLDRCQUE0QjtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGFBQWE7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNEJBQTRCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSw0QkFBNEI7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHVGQUF1Riw0QkFBNEI7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixhQUFhO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkJBQTJCO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjs7QUFFMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsc0NBQXNDO0FBQ3BGLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7O0FBRTFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLDZDQUE2QztBQUM3RDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHVDQUF1QztBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUpBQXVKO0FBQ3ZKLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsWUFBWTtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELGdDQUFnQztBQUNoQyxpQ0FBaUMsTUFBTSwwQkFBMEI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekIsdUJBQXVCO0FBQ3ZCO0FBQ0EsNkJBQTZCO0FBQzdCLDJCQUEyQjtBQUMzQixtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixtQ0FBbUM7QUFDbkMseUNBQXlDO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNEJBQTRCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekIsVUFBVTtBQUNWO0FBQ0Esa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUEsa0ZBQWtGO0FBQ2xGLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6QixVQUFVO0FBQ1Y7QUFDQSxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxJQUFJO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLFdBQVcsZ0NBQWdDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsYUFBYSxHQUFHO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixhQUFhLEdBQUc7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRLHFEQUFxRDtBQUN4RSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQixhQUFhLEdBQUc7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDs7QUFFM0QseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLG9DQUFvQzs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELHlDQUF5QztBQUN6QztBQUNBO0FBQ0EscUJBQXFCOztBQUVyQixvQ0FBb0Msd0JBQXdCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx3QkFBd0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7O0FBRTVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QiwwRUFBMEUsV0FBVztBQUNyRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBLDhCQUE4QjtBQUM5QixpR0FBaUcsV0FBVztBQUM1RztBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0EsOEJBQThCO0FBQzlCLHFEQUFxRDtBQUNyRDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixhQUFhOztBQUViO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxtREFBbUQ7QUFDOUQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFVBQVU7QUFDeEIsY0FBYyxVQUFVO0FBQ3hCLGNBQWMsVUFBVTtBQUN4QixjQUFjLFVBQVU7QUFDeEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBEQUEwRDtBQUMxRTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcseUJBQXlCO0FBQ3BDLGFBQWE7QUFDYjtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFNBQVM7QUFDVCxzQkFBc0IsYUFBYTtBQUNuQyxTQUFTO0FBQ1QsS0FBSztBQUNMLGtCQUFrQixnQ0FBZ0M7QUFDbEQsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLDJFQUEyRTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxREFBcUQseUJBQXlCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxtREFBbUQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHFEQUFxRDtBQUNqRyxjQUFjO0FBQ2QsNENBQTRDLHlCQUF5QjtBQUNyRSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOzs7QUFHQTtBQUNBO0FBQ0EseUJBQXlCLHdCQUF3QjtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLDRCQUE0QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsZUFBZTtBQUMxQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsMkNBQTJDO0FBQ3BFO0FBQ0Esb0JBQW9CLG1DQUFtQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLDJCQUEyQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLEdBQUcsU0FBUyxFQUFFLGlCQUFpQixHQUFHLGtCQUFrQixFQUFFLE9BQU8sR0FBRyxjQUFjLEdBQUcsOEJBQThCLEdBQUcsd0JBQXdCLEVBQUUsT0FBTyxHQUFHO0FBQ3pMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHFDQUFxQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLHlDQUF5QztBQUNwRCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtDQUFrQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix5QkFBeUIsa0NBQWtDO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlDQUFpQztBQUNyRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsNkJBQTZCOztBQUU3Qjs7QUFFQSxvQkFBb0IsNkJBQTZCO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCw4QkFBOEI7QUFDbEYsbUNBQW1DLDZEQUE2RCxnQ0FBZ0M7QUFDaEksS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0RBQWdEO0FBQ25GLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxlQUFlO0FBQ2pFLG1DQUFtQywyREFBMkQsaUJBQWlCO0FBQy9HLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix1RUFBdUU7O0FBRXRHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsZ0NBQWdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDBCQUEwQjtBQUMxQixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsNEJBQTRCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsNENBQTRDLHdCQUF3QjtBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGVBQWU7O0FBRWxEO0FBQ0EsOEJBQThCLHlCQUF5QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsOEJBQThCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwwQkFBMEI7QUFDMUIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLGlEQUFpRDtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLHVCQUF1QjtBQUNoRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkMsdUJBQXVCO0FBQ3BFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGO0FBQzlGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCOztBQUV4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsR0FBRztBQUNkLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLEdBQUc7QUFDZCxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxVQUFVLGVBQWU7QUFDekIsVUFBVSxHQUFHO0FBQ2IsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZUFBZTtBQUN6QixVQUFVLEdBQUc7QUFDYixVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxVQUFVLGVBQWU7QUFDekIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ04sK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLFVBQVUsZUFBZTtBQUN6QixVQUFVLEdBQUc7QUFDYixVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCLFVBQVUsR0FBRztBQUNiLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCLFVBQVUsR0FBRztBQUNiLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0JBQXdCO0FBQ2xELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1RkFBdUYsdUJBQXVCO0FBQzlHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7O0FBRXpCOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsSUFBSTtBQUNkLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFdBQVcsR0FBRyxRQUFRLFdBQVc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUEsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQzs7QUFFbEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnQkFBZ0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGdCQUFnQjtBQUM1RTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0IsbUNBQW1DO0FBQ25DLHdCQUF3QjtBQUN4QixrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsb0dBQW9HO0FBQzlJLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUVBQW1FO0FBQ3BGLGlCQUFpQixvRUFBb0U7QUFDckYsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsNEJBQTRCO0FBQ2pFO0FBQ0E7QUFDQSxvQ0FBb0MsdUJBQXVCLEdBQUcsd0JBQXdCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsZ0JBQWdCO0FBQzdCLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsMkJBQTJCLDBDQUEwQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsR0FBRztBQUNkLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxvQkFBb0IsR0FBRyw4QkFBOEI7QUFDckc7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBLG9DQUFvQyxrQkFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1DQUFtQztBQUNuRTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRCxnQ0FBZ0MsbUJBQW1CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDBCQUEwQixHQUFHLDJDQUEyQztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxxQkFBcUI7QUFDMUQ7QUFDQTtBQUNBLHFDQUFxQywyQkFBMkI7QUFDaEU7QUFDQTtBQUNBLHFDQUFxQyxpREFBaUQ7QUFDdEY7QUFDQTtBQUNBLHFDQUFxQyxnQ0FBZ0M7QUFDckU7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLGdCQUFnQjtBQUM3QixpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLFVBQVU7QUFDVixXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsNEJBQTRCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixtQkFBbUI7QUFDbkIsTUFBTTtBQUNOO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQW1CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLDBCQUEwQixjQUFjLEdBQUcsa0JBQWtCO0FBQzdEO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVyxrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsR0FBRztBQUNkLFdBQVcsZUFBZTtBQUMxQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBNEI7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0JBQStCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRyxpQkFBaUI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUVBQXlFLDZCQUE2QjtBQUN0RyxrQ0FBa0MsNEJBQTRCO0FBQzlEO0FBQ0EsMkVBQTJFLDZCQUE2QjtBQUN4RyxtQ0FBbUMsMkJBQTJCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsMEJBQTBCOztBQUVqRTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUUrQiIsInNvdXJjZXMiOlsid2VicGFjazovL0Bzb3VsbWF0ZXMvYXBwLy4uLy4uL25vZGVfbW9kdWxlcy9taXhwYW5lbC1icm93c2VyL2Rpc3QvbWl4cGFuZWwubW9kdWxlLmpzP2VkMzAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2luY2UgZXM2IGltcG9ydHMgYXJlIHN0YXRpYyBhbmQgd2UgcnVuIHVuaXQgdGVzdHMgZnJvbSB0aGUgY29uc29sZSwgd2luZG93IHdvbid0IGJlIGRlZmluZWQgd2hlbiBpbXBvcnRpbmcgdGhpcyBmaWxlXG52YXIgd2luO1xuaWYgKHR5cGVvZih3aW5kb3cpID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBsb2MgPSB7XG4gICAgICAgIGhvc3RuYW1lOiAnJ1xuICAgIH07XG4gICAgd2luID0ge1xuICAgICAgICBjcnlwdG86IHtyYW5kb21VVUlEOiBmdW5jdGlvbigpIHt0aHJvdyBFcnJvcigndW5zdXBwb3J0ZWQnKTt9fSxcbiAgICAgICAgbmF2aWdhdG9yOiB7IHVzZXJBZ2VudDogJycsIG9uTGluZTogdHJ1ZSB9LFxuICAgICAgICBkb2N1bWVudDoge1xuICAgICAgICAgICAgY3JlYXRlRWxlbWVudDogZnVuY3Rpb24oKSB7IHJldHVybiB7fTsgfSxcbiAgICAgICAgICAgIGxvY2F0aW9uOiBsb2MsXG4gICAgICAgICAgICByZWZlcnJlcjogJydcbiAgICAgICAgfSxcbiAgICAgICAgc2NyZWVuOiB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSxcbiAgICAgICAgbG9jYXRpb246IGxvYyxcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oKSB7fVxuICAgIH07XG59IGVsc2Uge1xuICAgIHdpbiA9IHdpbmRvdztcbn1cblxuZnVuY3Rpb24gX2FycmF5X2xpa2VfdG9fYXJyYXkoYXJyLCBsZW4pIHtcbiAgICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcbiAgICBmb3IodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKylhcnIyW2ldID0gYXJyW2ldO1xuICAgIHJldHVybiBhcnIyO1xufVxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICAgICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9hc3luY190b19nZW5lcmF0b3IoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgaWYgKF9pc19uYXRpdmVfcmVmbGVjdF9jb25zdHJ1Y3QoKSkge1xuICAgICAgICBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIGNvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICAgICAgICB2YXIgYSA9IFtcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpO1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICAgICAgICBpZiAoQ2xhc3MpIF9zZXRfcHJvdG90eXBlX29mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZV9jbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvcih2YXIga2V5IGluIHNvdXJjZSl7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuICAgIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX2dldF9wcm90b3R5cGVfb2Yobykge1xuICAgIF9nZXRfcHJvdG90eXBlX29mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRfcHJvdG90eXBlX29mKG8pO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0X3Byb3RvdHlwZV9vZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfaW5zdGFuY2VvZihsZWZ0LCByaWdodCkge1xuICAgIGlmIChyaWdodCAhPSBudWxsICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgcmlnaHRbU3ltYm9sLmhhc0luc3RhbmNlXSkge1xuICAgICAgICByZXR1cm4gISFyaWdodFtTeW1ib2wuaGFzSW5zdGFuY2VdKGxlZnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsZWZ0IGluc3RhbmNlb2YgcmlnaHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gX2lzX25hdGl2ZV9mdW5jdGlvbihmbikge1xuICAgIHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7XG59XG5mdW5jdGlvbiBfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gICAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gICAgdmFyIHRhcmdldCA9IHt9O1xuICAgIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICB2YXIga2V5LCBpO1xuICAgIGZvcihpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspe1xuICAgICAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gX3NldF9wcm90b3R5cGVfb2YobywgcCkge1xuICAgIF9zZXRfcHJvdG90eXBlX29mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0X3Byb3RvdHlwZV9vZihvLCBwKTtcbn1cbmZ1bmN0aW9uIF90eXBlX29mKG9iaikge1xuICAgIFwiQHN3Yy9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRfaXRlcmFibGVfdG9fYXJyYXkobywgbWluTGVuKSB7XG4gICAgaWYgKCFvKSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5X2xpa2VfdG9fYXJyYXkobywgbWluTGVuKTtcbiAgICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gICAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShuKTtcbiAgICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheV9saWtlX3RvX2FycmF5KG8sIG1pbkxlbik7XG59XG5mdW5jdGlvbiBfd3JhcF9uYXRpdmVfc3VwZXIoQ2xhc3MpIHtcbiAgICB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkO1xuICAgIF93cmFwX25hdGl2ZV9zdXBlciA9IGZ1bmN0aW9uIHdyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICAgICAgICBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc19uYXRpdmVfZnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7XG4gICAgICAgIGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTtcbiAgICAgICAgICAgIF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIFdyYXBwZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0X3Byb3RvdHlwZV9vZih0aGlzKS5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogV3JhcHBlcixcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfc2V0X3Byb3RvdHlwZV9vZihXcmFwcGVyLCBDbGFzcyk7XG4gICAgfTtcbiAgICByZXR1cm4gX3dyYXBfbmF0aXZlX3N1cGVyKENsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pc19uYXRpdmVfcmVmbGVjdF9jb25zdHJ1Y3QoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uKCkge30pKTtcbiAgICB9IGNhdGNoIChfKSB7fVxuICAgIHJldHVybiAoX2lzX25hdGl2ZV9yZWZsZWN0X2NvbnN0cnVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISFyZXN1bHQ7XG4gICAgfSkoKTtcbn1cbmZ1bmN0aW9uIF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShvLCBhbGxvd0FycmF5TGlrZSkge1xuICAgIHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdO1xuICAgIGlmIChpdCkgcmV0dXJuIChpdCA9IGl0LmNhbGwobykpLm5leHQuYmluZChpdCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkX2l0ZXJhYmxlX3RvX2FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSkge1xuICAgICAgICBpZiAoaXQpIG8gPSBpdDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoaSA+PSBvLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogb1tpKytdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbmZ1bmN0aW9uIF90c19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBmLCB5LCB0LCBnLCBfID0ge1xuICAgICAgICBsYWJlbDogMCxcbiAgICAgICAgc2VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodFswXSAmIDEpIHRocm93IHRbMV07XG4gICAgICAgICAgICByZXR1cm4gdFsxXTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJ5czogW10sXG4gICAgICAgIG9wczogW11cbiAgICB9O1xuICAgIHJldHVybiBnID0ge1xuICAgICAgICBuZXh0OiB2ZXJiKDApLFxuICAgICAgICBcInRocm93XCI6IHZlcmIoMSksXG4gICAgICAgIFwicmV0dXJuXCI6IHZlcmIoMilcbiAgICB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGVwKFtcbiAgICAgICAgICAgICAgICBuLFxuICAgICAgICAgICAgICAgIHZcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUoXyl0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtcbiAgICAgICAgICAgICAgICBvcFswXSAmIDIsXG4gICAgICAgICAgICAgICAgdC52YWx1ZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHN3aXRjaChvcFswXSl7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvcFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBvcFsxXTtcbiAgICAgICAgICAgICAgICAgICAgb3AgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgb3AgPSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gb3BbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5vcHMucHVzaChvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgb3AgPSBbXG4gICAgICAgICAgICAgICAgNixcbiAgICAgICAgICAgICAgICBlXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgIGYgPSB0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLFxuICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIF90c192YWx1ZXMobykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvICYmIG9baSsrXSxcbiAgICAgICAgICAgICAgICBkb25lOiAhb1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufVxudmFyIF9fZGVmUHJvcCQxID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCQxID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIGtleSBpbiBvYmogPyBfX2RlZlByb3AkMShvYmosIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICB9KSA6IG9ialtrZXldID0gdmFsdWU7XG59O1xudmFyIF9fcHVibGljRmllbGQkMSA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBfX2RlZk5vcm1hbFByb3AkMShvYmosICh0eXBlb2Yga2V5ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKGtleSkpICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xufTtcbnZhciBfYTtcbnZhciBfX2RlZlByb3AkMSQxID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCQxJDEgPSBmdW5jdGlvbihvYmosIGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQxJDEob2JqLCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xufTtcbnZhciBfX3B1YmxpY0ZpZWxkJDEkMSA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBfX2RlZk5vcm1hbFByb3AkMSQxKG9iaiwgKHR5cGVvZiBrZXkgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2Yoa2V5KSkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG59O1xudmFyIE5vZGVUeXBlJDMgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oTm9kZVR5cGUyKSB7XG4gICAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkRvY3VtZW50XCJdID0gMF0gPSBcIkRvY3VtZW50XCI7XG4gICAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkRvY3VtZW50VHlwZVwiXSA9IDFdID0gXCJEb2N1bWVudFR5cGVcIjtcbiAgICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiRWxlbWVudFwiXSA9IDJdID0gXCJFbGVtZW50XCI7XG4gICAgTm9kZVR5cGUyW05vZGVUeXBlMltcIlRleHRcIl0gPSAzXSA9IFwiVGV4dFwiO1xuICAgIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJDREFUQVwiXSA9IDRdID0gXCJDREFUQVwiO1xuICAgIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJDb21tZW50XCJdID0gNV0gPSBcIkNvbW1lbnRcIjtcbiAgICByZXR1cm4gTm9kZVR5cGUyO1xufShOb2RlVHlwZSQzIHx8IHt9KTtcbnZhciB0ZXN0YWJsZUFjY2Vzc29ycyQxID0ge1xuICAgIE5vZGU6IFtcbiAgICAgICAgXCJjaGlsZE5vZGVzXCIsXG4gICAgICAgIFwicGFyZW50Tm9kZVwiLFxuICAgICAgICBcInBhcmVudEVsZW1lbnRcIixcbiAgICAgICAgXCJ0ZXh0Q29udGVudFwiXG4gICAgXSxcbiAgICBTaGFkb3dSb290OiBbXG4gICAgICAgIFwiaG9zdFwiLFxuICAgICAgICBcInN0eWxlU2hlZXRzXCJcbiAgICBdLFxuICAgIEVsZW1lbnQ6IFtcbiAgICAgICAgXCJzaGFkb3dSb290XCIsXG4gICAgICAgIFwicXVlcnlTZWxlY3RvclwiLFxuICAgICAgICBcInF1ZXJ5U2VsZWN0b3JBbGxcIlxuICAgIF0sXG4gICAgTXV0YXRpb25PYnNlcnZlcjogW11cbn07XG52YXIgdGVzdGFibGVNZXRob2RzJDEgPSB7XG4gICAgTm9kZTogW1xuICAgICAgICBcImNvbnRhaW5zXCIsXG4gICAgICAgIFwiZ2V0Um9vdE5vZGVcIlxuICAgIF0sXG4gICAgU2hhZG93Um9vdDogW1xuICAgICAgICBcImdldFNlbGVjdGlvblwiXG4gICAgXSxcbiAgICBFbGVtZW50OiBbXSxcbiAgICBNdXRhdGlvbk9ic2VydmVyOiBbXG4gICAgICAgIFwiY29uc3RydWN0b3JcIlxuICAgIF1cbn07XG52YXIgdW50YWludGVkQmFzZVByb3RvdHlwZSQxID0ge307XG52YXIgaXNBbmd1bGFyWm9uZVByZXNlbnQkMSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhIWdsb2JhbFRoaXMuWm9uZTtcbn07XG5mdW5jdGlvbiBnZXRVbnRhaW50ZWRQcm90b3R5cGUkMShrZXkpIHtcbiAgICBpZiAodW50YWludGVkQmFzZVByb3RvdHlwZSQxW2tleV0pIHJldHVybiB1bnRhaW50ZWRCYXNlUHJvdG90eXBlJDFba2V5XTtcbiAgICB2YXIgZGVmYXVsdE9iaiA9IGdsb2JhbFRoaXNba2V5XTtcbiAgICB2YXIgZGVmYXVsdFByb3RvdHlwZSA9IGRlZmF1bHRPYmoucHJvdG90eXBlO1xuICAgIHZhciBhY2Nlc3Nvck5hbWVzID0ga2V5IGluIHRlc3RhYmxlQWNjZXNzb3JzJDEgPyB0ZXN0YWJsZUFjY2Vzc29ycyQxW2tleV0gOiB2b2lkIDA7XG4gICAgdmFyIGlzVW50YWludGVkQWNjZXNzb3JzID0gQm9vbGVhbihhY2Nlc3Nvck5hbWVzICYmIC8vIEB0cy1leHBlY3QtZXJyb3IgMjM0NVxuICAgIGFjY2Vzc29yTmFtZXMuZXZlcnkoZnVuY3Rpb24oYWNjZXNzb3IpIHtcbiAgICAgICAgdmFyIF9hMiwgX2I7XG4gICAgICAgIHJldHVybiBCb29sZWFuKChfYiA9IChfYTIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGRlZmF1bHRQcm90b3R5cGUsIGFjY2Vzc29yKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5nZXQpID09IG51bGwgPyB2b2lkIDAgOiBfYi50b1N0cmluZygpLmluY2x1ZGVzKFwiW25hdGl2ZSBjb2RlXVwiKSk7XG4gICAgfSkpO1xuICAgIHZhciBtZXRob2ROYW1lcyA9IGtleSBpbiB0ZXN0YWJsZU1ldGhvZHMkMSA/IHRlc3RhYmxlTWV0aG9kcyQxW2tleV0gOiB2b2lkIDA7XG4gICAgdmFyIGlzVW50YWludGVkTWV0aG9kcyA9IEJvb2xlYW4obWV0aG9kTmFtZXMgJiYgbWV0aG9kTmFtZXMuZXZlcnkoLy8gQHRzLWV4cGVjdC1lcnJvciAyMzQ1XG4gICAgZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZGVmYXVsdFByb3RvdHlwZVttZXRob2RdID09PSBcImZ1bmN0aW9uXCIgJiYgKChfYTIgPSBkZWZhdWx0UHJvdG90eXBlW21ldGhvZF0pID09IG51bGwgPyB2b2lkIDAgOiBfYTIudG9TdHJpbmcoKS5pbmNsdWRlcyhcIltuYXRpdmUgY29kZV1cIikpO1xuICAgIH0pKTtcbiAgICBpZiAoaXNVbnRhaW50ZWRBY2Nlc3NvcnMgJiYgaXNVbnRhaW50ZWRNZXRob2RzICYmICFpc0FuZ3VsYXJab25lUHJlc2VudCQxKCkpIHtcbiAgICAgICAgdW50YWludGVkQmFzZVByb3RvdHlwZSQxW2tleV0gPSBkZWZhdWx0T2JqLnByb3RvdHlwZTtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRPYmoucHJvdG90eXBlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB2YXIgaWZyYW1lRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZUVsKTtcbiAgICAgICAgdmFyIHdpbiA9IGlmcmFtZUVsLmNvbnRlbnRXaW5kb3c7XG4gICAgICAgIGlmICghd2luKSByZXR1cm4gZGVmYXVsdE9iai5wcm90b3R5cGU7XG4gICAgICAgIHZhciB1bnRhaW50ZWRPYmplY3QgPSB3aW5ba2V5XS5wcm90b3R5cGU7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lRWwpO1xuICAgICAgICBpZiAoIXVudGFpbnRlZE9iamVjdCkgcmV0dXJuIGRlZmF1bHRQcm90b3R5cGU7XG4gICAgICAgIHJldHVybiB1bnRhaW50ZWRCYXNlUHJvdG90eXBlJDFba2V5XSA9IHVudGFpbnRlZE9iamVjdDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0UHJvdG90eXBlO1xuICAgIH1cbn1cbnZhciB1bnRhaW50ZWRBY2Nlc3NvckNhY2hlJDEgPSB7fTtcbmZ1bmN0aW9uIGdldFVudGFpbnRlZEFjY2Vzc29yJDEoa2V5LCBpbnN0YW5jZSwgYWNjZXNzb3IpIHtcbiAgICB2YXIgX2EyO1xuICAgIHZhciBjYWNoZUtleSA9IGtleSArIFwiLlwiICsgU3RyaW5nKGFjY2Vzc29yKTtcbiAgICBpZiAodW50YWludGVkQWNjZXNzb3JDYWNoZSQxW2NhY2hlS2V5XSkgcmV0dXJuIHVudGFpbnRlZEFjY2Vzc29yQ2FjaGUkMVtjYWNoZUtleV0uY2FsbChpbnN0YW5jZSk7XG4gICAgdmFyIHVudGFpbnRlZFByb3RvdHlwZSA9IGdldFVudGFpbnRlZFByb3RvdHlwZSQxKGtleSk7XG4gICAgdmFyIHVudGFpbnRlZEFjY2Vzc29yID0gKF9hMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodW50YWludGVkUHJvdG90eXBlLCBhY2Nlc3NvcikpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZ2V0O1xuICAgIGlmICghdW50YWludGVkQWNjZXNzb3IpIHJldHVybiBpbnN0YW5jZVthY2Nlc3Nvcl07XG4gICAgdW50YWludGVkQWNjZXNzb3JDYWNoZSQxW2NhY2hlS2V5XSA9IHVudGFpbnRlZEFjY2Vzc29yO1xuICAgIHJldHVybiB1bnRhaW50ZWRBY2Nlc3Nvci5jYWxsKGluc3RhbmNlKTtcbn1cbnZhciB1bnRhaW50ZWRNZXRob2RDYWNoZSQxID0ge307XG5mdW5jdGlvbiBnZXRVbnRhaW50ZWRNZXRob2QkMShrZXksIGluc3RhbmNlLCBtZXRob2QpIHtcbiAgICB2YXIgY2FjaGVLZXkgPSBrZXkgKyBcIi5cIiArIFN0cmluZyhtZXRob2QpO1xuICAgIGlmICh1bnRhaW50ZWRNZXRob2RDYWNoZSQxW2NhY2hlS2V5XSkgcmV0dXJuIHVudGFpbnRlZE1ldGhvZENhY2hlJDFbY2FjaGVLZXldLmJpbmQoaW5zdGFuY2UpO1xuICAgIHZhciB1bnRhaW50ZWRQcm90b3R5cGUgPSBnZXRVbnRhaW50ZWRQcm90b3R5cGUkMShrZXkpO1xuICAgIHZhciB1bnRhaW50ZWRNZXRob2QgPSB1bnRhaW50ZWRQcm90b3R5cGVbbWV0aG9kXTtcbiAgICBpZiAodHlwZW9mIHVudGFpbnRlZE1ldGhvZCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gaW5zdGFuY2VbbWV0aG9kXTtcbiAgICB1bnRhaW50ZWRNZXRob2RDYWNoZSQxW2NhY2hlS2V5XSA9IHVudGFpbnRlZE1ldGhvZDtcbiAgICByZXR1cm4gdW50YWludGVkTWV0aG9kLmJpbmQoaW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gY2hpbGROb2RlcyQxKG4yKSB7XG4gICAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yJDEoXCJOb2RlXCIsIG4yLCBcImNoaWxkTm9kZXNcIik7XG59XG5mdW5jdGlvbiBwYXJlbnROb2RlJDEobjIpIHtcbiAgICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IkMShcIk5vZGVcIiwgbjIsIFwicGFyZW50Tm9kZVwiKTtcbn1cbmZ1bmN0aW9uIHBhcmVudEVsZW1lbnQkMShuMikge1xuICAgIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvciQxKFwiTm9kZVwiLCBuMiwgXCJwYXJlbnRFbGVtZW50XCIpO1xufVxuZnVuY3Rpb24gdGV4dENvbnRlbnQkMShuMikge1xuICAgIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvciQxKFwiTm9kZVwiLCBuMiwgXCJ0ZXh0Q29udGVudFwiKTtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zJDEobjIsIG90aGVyKSB7XG4gICAgcmV0dXJuIGdldFVudGFpbnRlZE1ldGhvZCQxKFwiTm9kZVwiLCBuMiwgXCJjb250YWluc1wiKShvdGhlcik7XG59XG5mdW5jdGlvbiBnZXRSb290Tm9kZSQxKG4yKSB7XG4gICAgcmV0dXJuIGdldFVudGFpbnRlZE1ldGhvZCQxKFwiTm9kZVwiLCBuMiwgXCJnZXRSb290Tm9kZVwiKSgpO1xufVxuZnVuY3Rpb24gaG9zdCQxKG4yKSB7XG4gICAgaWYgKCFuMiB8fCAhKFwiaG9zdFwiIGluIG4yKSkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yJDEoXCJTaGFkb3dSb290XCIsIG4yLCBcImhvc3RcIik7XG59XG5mdW5jdGlvbiBzdHlsZVNoZWV0cyQxKG4yKSB7XG4gICAgcmV0dXJuIG4yLnN0eWxlU2hlZXRzO1xufVxuZnVuY3Rpb24gc2hhZG93Um9vdCQxKG4yKSB7XG4gICAgaWYgKCFuMiB8fCAhKFwic2hhZG93Um9vdFwiIGluIG4yKSkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yJDEoXCJFbGVtZW50XCIsIG4yLCBcInNoYWRvd1Jvb3RcIik7XG59XG5mdW5jdGlvbiBxdWVyeVNlbGVjdG9yJDEobjIsIHNlbGVjdG9ycykge1xuICAgIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvciQxKFwiRWxlbWVudFwiLCBuMiwgXCJxdWVyeVNlbGVjdG9yXCIpKHNlbGVjdG9ycyk7XG59XG5mdW5jdGlvbiBxdWVyeVNlbGVjdG9yQWxsJDEobjIsIHNlbGVjdG9ycykge1xuICAgIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvciQxKFwiRWxlbWVudFwiLCBuMiwgXCJxdWVyeVNlbGVjdG9yQWxsXCIpKHNlbGVjdG9ycyk7XG59XG5mdW5jdGlvbiBtdXRhdGlvbk9ic2VydmVyQ3RvciQxKCkge1xuICAgIHJldHVybiBnZXRVbnRhaW50ZWRQcm90b3R5cGUkMShcIk11dGF0aW9uT2JzZXJ2ZXJcIikuY29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBwYXRjaCQxKHNvdXJjZSwgbmFtZSwgcmVwbGFjZW1lbnQpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIShuYW1lIGluIHNvdXJjZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcmlnaW5hbCA9IHNvdXJjZVtuYW1lXTtcbiAgICAgICAgdmFyIHdyYXBwZWQgPSByZXBsYWNlbWVudChvcmlnaW5hbCk7XG4gICAgICAgIGlmICh0eXBlb2Ygd3JhcHBlZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB3cmFwcGVkLnByb3RvdHlwZSA9IHdyYXBwZWQucHJvdG90eXBlIHx8IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMod3JhcHBlZCwge1xuICAgICAgICAgICAgICAgIF9fcnJ3ZWJfb3JpZ2luYWxfXzoge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlW25hbWVdID0gd3JhcHBlZDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc291cmNlW25hbWVdID0gb3JpZ2luYWw7XG4gICAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG59XG52YXIgaW5kZXgkMSA9IHtcbiAgICBjaGlsZE5vZGVzOiBjaGlsZE5vZGVzJDEsXG4gICAgcGFyZW50Tm9kZTogcGFyZW50Tm9kZSQxLFxuICAgIHBhcmVudEVsZW1lbnQ6IHBhcmVudEVsZW1lbnQkMSxcbiAgICB0ZXh0Q29udGVudDogdGV4dENvbnRlbnQkMSxcbiAgICBjb250YWluczogY29udGFpbnMkMSxcbiAgICBnZXRSb290Tm9kZTogZ2V0Um9vdE5vZGUkMSxcbiAgICBob3N0OiBob3N0JDEsXG4gICAgc3R5bGVTaGVldHM6IHN0eWxlU2hlZXRzJDEsXG4gICAgc2hhZG93Um9vdDogc2hhZG93Um9vdCQxLFxuICAgIHF1ZXJ5U2VsZWN0b3I6IHF1ZXJ5U2VsZWN0b3IkMSxcbiAgICBxdWVyeVNlbGVjdG9yQWxsOiBxdWVyeVNlbGVjdG9yQWxsJDEsXG4gICAgbXV0YXRpb25PYnNlcnZlcjogbXV0YXRpb25PYnNlcnZlckN0b3IkMSxcbiAgICBwYXRjaDogcGF0Y2gkMVxufTtcbmZ1bmN0aW9uIGlzRWxlbWVudChuMikge1xuICAgIHJldHVybiBuMi5ub2RlVHlwZSA9PT0gbjIuRUxFTUVOVF9OT0RFO1xufVxuZnVuY3Rpb24gaXNTaGFkb3dSb290KG4yKSB7XG4gICAgdmFyIGhvc3RFbCA9IC8vIGFuY2hvciBhbmQgdGV4dGFyZWEgZWxlbWVudHMgYWxzbyBoYXZlIGEgYGhvc3RgIHByb3BlcnR5XG4gICAgLy8gYnV0IG9ubHkgc2hhZG93IHJvb3RzIGhhdmUgYSBgbW9kZWAgcHJvcGVydHlcbiAgICBuMiAmJiBcImhvc3RcIiBpbiBuMiAmJiBcIm1vZGVcIiBpbiBuMiAmJiBpbmRleCQxLmhvc3QobjIpIHx8IG51bGw7XG4gICAgcmV0dXJuIEJvb2xlYW4oaG9zdEVsICYmIFwic2hhZG93Um9vdFwiIGluIGhvc3RFbCAmJiBpbmRleCQxLnNoYWRvd1Jvb3QoaG9zdEVsKSA9PT0gbjIpO1xufVxuZnVuY3Rpb24gaXNOYXRpdmVTaGFkb3dEb20oc2hhZG93Um9vdDIpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNoYWRvd1Jvb3QyKSA9PT0gXCJbb2JqZWN0IFNoYWRvd1Jvb3RdXCI7XG59XG5mdW5jdGlvbiBmaXhCcm93c2VyQ29tcGF0aWJpbGl0eUlzc3Vlc0luQ1NTKGNzc1RleHQpIHtcbiAgICBpZiAoY3NzVGV4dC5pbmNsdWRlcyhcIiBiYWNrZ3JvdW5kLWNsaXA6IHRleHQ7XCIpICYmICFjc3NUZXh0LmluY2x1ZGVzKFwiIC13ZWJraXQtYmFja2dyb3VuZC1jbGlwOiB0ZXh0O1wiKSkge1xuICAgICAgICBjc3NUZXh0ID0gY3NzVGV4dC5yZXBsYWNlKC9cXHNiYWNrZ3JvdW5kLWNsaXA6XFxzKnRleHQ7L2csIFwiIC13ZWJraXQtYmFja2dyb3VuZC1jbGlwOiB0ZXh0OyBiYWNrZ3JvdW5kLWNsaXA6IHRleHQ7XCIpO1xuICAgIH1cbiAgICByZXR1cm4gY3NzVGV4dDtcbn1cbmZ1bmN0aW9uIGVzY2FwZUltcG9ydFN0YXRlbWVudChydWxlMikge1xuICAgIHZhciBjc3NUZXh0ID0gcnVsZTIuY3NzVGV4dDtcbiAgICBpZiAoY3NzVGV4dC5zcGxpdCgnXCInKS5sZW5ndGggPCAzKSByZXR1cm4gY3NzVGV4dDtcbiAgICB2YXIgc3RhdGVtZW50ID0gW1xuICAgICAgICBcIkBpbXBvcnRcIixcbiAgICAgICAgXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShydWxlMi5ocmVmKSArIFwiKVwiXG4gICAgXTtcbiAgICBpZiAocnVsZTIubGF5ZXJOYW1lID09PSBcIlwiKSB7XG4gICAgICAgIHN0YXRlbWVudC5wdXNoKFwibGF5ZXJcIik7XG4gICAgfSBlbHNlIGlmIChydWxlMi5sYXllck5hbWUpIHtcbiAgICAgICAgc3RhdGVtZW50LnB1c2goXCJsYXllcihcIiArIHJ1bGUyLmxheWVyTmFtZSArIFwiKVwiKTtcbiAgICB9XG4gICAgaWYgKHJ1bGUyLnN1cHBvcnRzVGV4dCkge1xuICAgICAgICBzdGF0ZW1lbnQucHVzaChcInN1cHBvcnRzKFwiICsgcnVsZTIuc3VwcG9ydHNUZXh0ICsgXCIpXCIpO1xuICAgIH1cbiAgICBpZiAocnVsZTIubWVkaWEubGVuZ3RoKSB7XG4gICAgICAgIHN0YXRlbWVudC5wdXNoKHJ1bGUyLm1lZGlhLm1lZGlhVGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZW1lbnQuam9pbihcIiBcIikgKyBcIjtcIjtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVN0eWxlc2hlZXQoczIpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgcnVsZXMyID0gczIucnVsZXMgfHwgczIuY3NzUnVsZXM7XG4gICAgICAgIGlmICghcnVsZXMyKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2hlZXRIcmVmID0gczIuaHJlZjtcbiAgICAgICAgaWYgKCFzaGVldEhyZWYgJiYgczIub3duZXJOb2RlICYmIHMyLm93bmVyTm9kZS5vd25lckRvY3VtZW50KSB7XG4gICAgICAgICAgICBzaGVldEhyZWYgPSBzMi5vd25lck5vZGUub3duZXJEb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJpbmdpZmllZFJ1bGVzID0gQXJyYXkuZnJvbShydWxlczIsIGZ1bmN0aW9uKHJ1bGUyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5UnVsZShydWxlMiwgc2hlZXRIcmVmKTtcbiAgICAgICAgfSkuam9pbihcIlwiKTtcbiAgICAgICAgcmV0dXJuIGZpeEJyb3dzZXJDb21wYXRpYmlsaXR5SXNzdWVzSW5DU1Moc3RyaW5naWZpZWRSdWxlcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gc3RyaW5naWZ5UnVsZShydWxlMiwgc2hlZXRIcmVmKSB7XG4gICAgaWYgKGlzQ1NTSW1wb3J0UnVsZShydWxlMikpIHtcbiAgICAgICAgdmFyIGltcG9ydFN0cmluZ2lmaWVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaW1wb3J0U3RyaW5naWZpZWQgPSAvLyB3ZSBjYW4gYWNjZXNzIHRoZSBpbXBvcnRlZCBzdHlsZXNoZWV0IHJ1bGVzIGRpcmVjdGx5XG4gICAgICAgICAgICBzdHJpbmdpZnlTdHlsZXNoZWV0KHJ1bGUyLnN0eWxlU2hlZXQpIHx8IC8vIHdvcmsgYXJvdW5kIGJyb3dzZXIgaXNzdWVzIHdpdGggdGhlIHJhdyBzdHJpbmcgYEBpbXBvcnQgdXJsKC4uLilgIHN0YXRlbWVudFxuICAgICAgICAgICAgZXNjYXBlSW1wb3J0U3RhdGVtZW50KHJ1bGUyKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGltcG9ydFN0cmluZ2lmaWVkID0gcnVsZTIuY3NzVGV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVsZTIuc3R5bGVTaGVldC5ocmVmKSB7XG4gICAgICAgICAgICByZXR1cm4gYWJzb2x1dGlmeVVSTHMoaW1wb3J0U3RyaW5naWZpZWQsIHJ1bGUyLnN0eWxlU2hlZXQuaHJlZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGltcG9ydFN0cmluZ2lmaWVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBydWxlU3RyaW5naWZpZWQgPSBydWxlMi5jc3NUZXh0O1xuICAgICAgICBpZiAoaXNDU1NTdHlsZVJ1bGUocnVsZTIpICYmIHJ1bGUyLnNlbGVjdG9yVGV4dC5pbmNsdWRlcyhcIjpcIikpIHtcbiAgICAgICAgICAgIHJ1bGVTdHJpbmdpZmllZCA9IGZpeFNhZmFyaUNvbG9ucyhydWxlU3RyaW5naWZpZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaGVldEhyZWYpIHtcbiAgICAgICAgICAgIHJldHVybiBhYnNvbHV0aWZ5VVJMcyhydWxlU3RyaW5naWZpZWQsIHNoZWV0SHJlZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bGVTdHJpbmdpZmllZDtcbiAgICB9XG59XG5mdW5jdGlvbiBmaXhTYWZhcmlDb2xvbnMoY3NzU3RyaW5naWZpZWQpIHtcbiAgICB2YXIgcmVnZXggPSAvKFxcWyg/OltcXHctXSspW15cXFxcXSkoOig/OltcXHctXSspXFxdKS9nbTtcbiAgICByZXR1cm4gY3NzU3RyaW5naWZpZWQucmVwbGFjZShyZWdleCwgXCIkMVxcXFwkMlwiKTtcbn1cbmZ1bmN0aW9uIGlzQ1NTSW1wb3J0UnVsZShydWxlMikge1xuICAgIHJldHVybiBcInN0eWxlU2hlZXRcIiBpbiBydWxlMjtcbn1cbmZ1bmN0aW9uIGlzQ1NTU3R5bGVSdWxlKHJ1bGUyKSB7XG4gICAgcmV0dXJuIFwic2VsZWN0b3JUZXh0XCIgaW4gcnVsZTI7XG59XG52YXIgTWlycm9yID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBNaXJyb3IoKSB7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSQxKHRoaXMsIFwiaWROb2RlTWFwXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEkMSh0aGlzLCBcIm5vZGVNZXRhTWFwXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpKTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IE1pcnJvci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmdldElkID0gZnVuY3Rpb24gZ2V0SWQobjIpIHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgaWYgKCFuMikgcmV0dXJuIC0xO1xuICAgICAgICB2YXIgaWQgPSAoX2EyID0gdGhpcy5nZXRNZXRhKG4yKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5pZDtcbiAgICAgICAgcmV0dXJuIGlkICE9IG51bGwgPyBpZCA6IC0xO1xuICAgIH07XG4gICAgX3Byb3RvLmdldE5vZGUgPSBmdW5jdGlvbiBnZXROb2RlKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkTm9kZU1hcC5nZXQoaWQpIHx8IG51bGw7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0SWRzID0gZnVuY3Rpb24gZ2V0SWRzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmlkTm9kZU1hcC5rZXlzKCkpO1xuICAgIH07XG4gICAgX3Byb3RvLmdldE1ldGEgPSBmdW5jdGlvbiBnZXRNZXRhKG4yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVNZXRhTWFwLmdldChuMikgfHwgbnVsbDtcbiAgICB9O1xuICAgIC8vIHJlbW92ZXMgdGhlIG5vZGUgZnJvbSBpZE5vZGVNYXBcbiAgICAvLyBkb2Vzbid0IHJlbW92ZSB0aGUgbm9kZSBmcm9tIG5vZGVNZXRhTWFwXG4gICAgX3Byb3RvLnJlbW92ZU5vZGVGcm9tTWFwID0gZnVuY3Rpb24gcmVtb3ZlTm9kZUZyb21NYXAobjIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGlkID0gdGhpcy5nZXRJZChuMik7XG4gICAgICAgIHRoaXMuaWROb2RlTWFwLmRlbGV0ZShpZCk7XG4gICAgICAgIGlmIChuMi5jaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICBuMi5jaGlsZE5vZGVzLmZvckVhY2goZnVuY3Rpb24oY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlbW92ZU5vZGVGcm9tTWFwKGNoaWxkTm9kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmhhcyA9IGZ1bmN0aW9uIGhhcyhpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZE5vZGVNYXAuaGFzKGlkKTtcbiAgICB9O1xuICAgIF9wcm90by5oYXNOb2RlID0gZnVuY3Rpb24gaGFzTm9kZShub2RlMikge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlTWV0YU1hcC5oYXMobm9kZTIpO1xuICAgIH07XG4gICAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZChuMiwgbWV0YSkge1xuICAgICAgICB2YXIgaWQgPSBtZXRhLmlkO1xuICAgICAgICB0aGlzLmlkTm9kZU1hcC5zZXQoaWQsIG4yKTtcbiAgICAgICAgdGhpcy5ub2RlTWV0YU1hcC5zZXQobjIsIG1ldGEpO1xuICAgIH07XG4gICAgX3Byb3RvLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKGlkLCBuMikge1xuICAgICAgICB2YXIgb2xkTm9kZSA9IHRoaXMuZ2V0Tm9kZShpZCk7XG4gICAgICAgIGlmIChvbGROb2RlKSB7XG4gICAgICAgICAgICB2YXIgbWV0YSA9IHRoaXMubm9kZU1ldGFNYXAuZ2V0KG9sZE5vZGUpO1xuICAgICAgICAgICAgaWYgKG1ldGEpIHRoaXMubm9kZU1ldGFNYXAuc2V0KG4yLCBtZXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlkTm9kZU1hcC5zZXQoaWQsIG4yKTtcbiAgICB9O1xuICAgIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICB0aGlzLmlkTm9kZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubm9kZU1ldGFNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICB9O1xuICAgIHJldHVybiBNaXJyb3I7XG59KCk7XG5mdW5jdGlvbiBjcmVhdGVNaXJyb3IkMigpIHtcbiAgICByZXR1cm4gbmV3IE1pcnJvcigpO1xufVxuZnVuY3Rpb24gbWFza0lucHV0VmFsdWUocGFyYW0pIHtcbiAgICB2YXIgZWxlbWVudCA9IHBhcmFtLmVsZW1lbnQsIG1hc2tJbnB1dE9wdGlvbnMgPSBwYXJhbS5tYXNrSW5wdXRPcHRpb25zLCB0YWdOYW1lID0gcGFyYW0udGFnTmFtZSwgdHlwZSA9IHBhcmFtLnR5cGUsIHZhbHVlID0gcGFyYW0udmFsdWUsIG1hc2tJbnB1dEZuID0gcGFyYW0ubWFza0lucHV0Rm47XG4gICAgdmFyIHRleHQgPSB2YWx1ZSB8fCBcIlwiO1xuICAgIHZhciBhY3R1YWxUeXBlID0gdHlwZSAmJiB0b0xvd2VyQ2FzZSh0eXBlKTtcbiAgICBpZiAobWFza0lucHV0T3B0aW9uc1t0YWdOYW1lLnRvTG93ZXJDYXNlKCldIHx8IGFjdHVhbFR5cGUgJiYgbWFza0lucHV0T3B0aW9uc1thY3R1YWxUeXBlXSkge1xuICAgICAgICBpZiAobWFza0lucHV0Rm4pIHtcbiAgICAgICAgICAgIHRleHQgPSBtYXNrSW5wdXRGbih0ZXh0LCBlbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHQgPSBcIipcIi5yZXBlYXQodGV4dC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xufVxuZnVuY3Rpb24gdG9Mb3dlckNhc2Uoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpO1xufVxudmFyIE9SSUdJTkFMX0FUVFJJQlVURV9OQU1FID0gXCJfX3Jyd2ViX29yaWdpbmFsX19cIjtcbmZ1bmN0aW9uIGlzMkRDYW52YXNCbGFuayhjYW52YXMpIHtcbiAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBpZiAoIWN0eCkgcmV0dXJuIHRydWU7XG4gICAgdmFyIGNodW5rU2l6ZSA9IDUwO1xuICAgIGZvcih2YXIgeDIgPSAwOyB4MiA8IGNhbnZhcy53aWR0aDsgeDIgKz0gY2h1bmtTaXplKXtcbiAgICAgICAgZm9yKHZhciB5ID0gMDsgeSA8IGNhbnZhcy5oZWlnaHQ7IHkgKz0gY2h1bmtTaXplKXtcbiAgICAgICAgICAgIHZhciBnZXRJbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhO1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsR2V0SW1hZ2VEYXRhID0gT1JJR0lOQUxfQVRUUklCVVRFX05BTUUgaW4gZ2V0SW1hZ2VEYXRhID8gZ2V0SW1hZ2VEYXRhW09SSUdJTkFMX0FUVFJJQlVURV9OQU1FXSA6IGdldEltYWdlRGF0YTtcbiAgICAgICAgICAgIHZhciBwaXhlbEJ1ZmZlciA9IG5ldyBVaW50MzJBcnJheSgvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICBvcmlnaW5hbEdldEltYWdlRGF0YS5jYWxsKGN0eCwgeDIsIHksIE1hdGgubWluKGNodW5rU2l6ZSwgY2FudmFzLndpZHRoIC0geDIpLCBNYXRoLm1pbihjaHVua1NpemUsIGNhbnZhcy5oZWlnaHQgLSB5KSkuZGF0YS5idWZmZXIpO1xuICAgICAgICAgICAgaWYgKHBpeGVsQnVmZmVyLnNvbWUoZnVuY3Rpb24ocGl4ZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGl4ZWwgIT09IDA7XG4gICAgICAgICAgICB9KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0SW5wdXRUeXBlKGVsZW1lbnQpIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJkYXRhLXJyLWlzLXBhc3N3b3JkXCIpID8gXCJwYXNzd29yZFwiIDogdHlwZSA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktdHlwZS1hc3NlcnRpb25cbiAgICB0b0xvd2VyQ2FzZSh0eXBlKSA6IG51bGw7XG59XG5mdW5jdGlvbiBleHRyYWN0RmlsZUV4dGVuc2lvbihwYXRoLCBiYXNlVVJMKSB7XG4gICAgdmFyIHVybDtcbiAgICB0cnkge1xuICAgICAgICB1cmwgPSBuZXcgVVJMKHBhdGgsIGJhc2VVUkwgIT0gbnVsbCA/IGJhc2VVUkwgOiB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgcmVnZXggPSAvXFwuKFswLTlhLXpdKykoPzokKS9pO1xuICAgIHZhciBtYXRjaCA9IHVybC5wYXRobmFtZS5tYXRjaChyZWdleCk7XG4gICAgdmFyIF9yZWY7XG4gICAgcmV0dXJuIChfcmVmID0gbWF0Y2ggPT0gbnVsbCA/IHZvaWQgMCA6IG1hdGNoWzFdKSAhPSBudWxsID8gX3JlZiA6IG51bGw7XG59XG5mdW5jdGlvbiBleHRyYWN0T3JpZ2luKHVybCkge1xuICAgIHZhciBvcmlnaW4gPSBcIlwiO1xuICAgIGlmICh1cmwuaW5kZXhPZihcIi8vXCIpID4gLTEpIHtcbiAgICAgICAgb3JpZ2luID0gdXJsLnNwbGl0KFwiL1wiKS5zbGljZSgwLCAzKS5qb2luKFwiL1wiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvcmlnaW4gPSB1cmwuc3BsaXQoXCIvXCIpWzBdO1xuICAgIH1cbiAgICBvcmlnaW4gPSBvcmlnaW4uc3BsaXQoXCI/XCIpWzBdO1xuICAgIHJldHVybiBvcmlnaW47XG59XG52YXIgVVJMX0lOX0NTU19SRUYgPSAvdXJsXFwoKD86KCcpKFteJ10qKSd8KFwiKSguKj8pXCJ8KFteKV0qKSlcXCkvZ207XG52YXIgVVJMX1BST1RPQ09MX01BVENIID0gL14oPzpbYS16K10rOik/XFwvXFwvL2k7XG52YXIgVVJMX1dXV19NQVRDSCA9IC9ed3d3XFwuLiovaTtcbnZhciBEQVRBX1VSSSA9IC9eKGRhdGE6KShbXixdKiksKC4qKS9pO1xuZnVuY3Rpb24gYWJzb2x1dGlmeVVSTHMoY3NzVGV4dCwgaHJlZikge1xuICAgIHJldHVybiAoY3NzVGV4dCB8fCBcIlwiKS5yZXBsYWNlKFVSTF9JTl9DU1NfUkVGLCBmdW5jdGlvbihvcmlnaW4sIHF1b3RlMSwgcGF0aDEsIHF1b3RlMiwgcGF0aDIsIHBhdGgzKSB7XG4gICAgICAgIHZhciBmaWxlUGF0aCA9IHBhdGgxIHx8IHBhdGgyIHx8IHBhdGgzO1xuICAgICAgICB2YXIgbWF5YmVRdW90ZSA9IHF1b3RlMSB8fCBxdW90ZTIgfHwgXCJcIjtcbiAgICAgICAgaWYgKCFmaWxlUGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVVJMX1BST1RPQ09MX01BVENILnRlc3QoZmlsZVBhdGgpIHx8IFVSTF9XV1dfTUFUQ0gudGVzdChmaWxlUGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBcInVybChcIiArIG1heWJlUXVvdGUgKyBmaWxlUGF0aCArIG1heWJlUXVvdGUgKyBcIilcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoREFUQV9VUkkudGVzdChmaWxlUGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBcInVybChcIiArIG1heWJlUXVvdGUgKyBmaWxlUGF0aCArIG1heWJlUXVvdGUgKyBcIilcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsZVBhdGhbMF0gPT09IFwiL1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ1cmwoXCIgKyBtYXliZVF1b3RlICsgKGV4dHJhY3RPcmlnaW4oaHJlZikgKyBmaWxlUGF0aCkgKyBtYXliZVF1b3RlICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YWNrID0gaHJlZi5zcGxpdChcIi9cIik7XG4gICAgICAgIHZhciBwYXJ0cyA9IGZpbGVQYXRoLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHBhcnRzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIHBhcnQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChwYXJ0ID09PSBcIi5cIikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJ0ID09PSBcIi4uXCIpIHtcbiAgICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChwYXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJ1cmwoXCIgKyBtYXliZVF1b3RlICsgc3RhY2suam9pbihcIi9cIikgKyBtYXliZVF1b3RlICsgXCIpXCI7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDc3NTdHJpbmcoY3NzVGV4dCwgX3Rlc3ROb1B4Tm9ybSkge1xuICAgIGlmIChfdGVzdE5vUHhOb3JtID09PSB2b2lkIDApIF90ZXN0Tm9QeE5vcm0gPSBmYWxzZTtcbiAgICBpZiAoX3Rlc3ROb1B4Tm9ybSkge1xuICAgICAgICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKC8oXFwvXFwqW14qXSpcXCpcXC8pfFtcXHM7XS9nLCBcIlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKC8oXFwvXFwqW14qXSpcXCpcXC8pfFtcXHM7XS9nLCBcIlwiKS5yZXBsYWNlKC8wcHgvZywgXCIwXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNwbGl0Q3NzVGV4dChjc3NUZXh0LCBzdHlsZSwgX3Rlc3ROb1B4Tm9ybSkge1xuICAgIGlmIChfdGVzdE5vUHhOb3JtID09PSB2b2lkIDApIF90ZXN0Tm9QeE5vcm0gPSBmYWxzZTtcbiAgICB2YXIgY2hpbGROb2RlczIgPSBBcnJheS5mcm9tKHN0eWxlLmNoaWxkTm9kZXMpO1xuICAgIHZhciBzcGxpdHMgPSBbXTtcbiAgICB2YXIgaXRlckNvdW50ID0gMDtcbiAgICBpZiAoY2hpbGROb2RlczIubGVuZ3RoID4gMSAmJiBjc3NUZXh0ICYmIHR5cGVvZiBjc3NUZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhciBjc3NUZXh0Tm9ybSA9IG5vcm1hbGl6ZUNzc1N0cmluZyhjc3NUZXh0LCBfdGVzdE5vUHhOb3JtKTtcbiAgICAgICAgdmFyIG5vcm1GYWN0b3IgPSBjc3NUZXh0Tm9ybS5sZW5ndGggLyBjc3NUZXh0Lmxlbmd0aDtcbiAgICAgICAgZm9yKHZhciBpMiA9IDE7IGkyIDwgY2hpbGROb2RlczIubGVuZ3RoOyBpMisrKXtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzMltpMl0udGV4dENvbnRlbnQgJiYgdHlwZW9mIGNoaWxkTm9kZXMyW2kyXS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0Q29udGVudE5vcm0gPSBub3JtYWxpemVDc3NTdHJpbmcoY2hpbGROb2RlczJbaTJdLnRleHRDb250ZW50LCBfdGVzdE5vUHhOb3JtKTtcbiAgICAgICAgICAgICAgICB2YXIgakxpbWl0ID0gMTAwO1xuICAgICAgICAgICAgICAgIHZhciBqID0gMztcbiAgICAgICAgICAgICAgICBmb3IoOyBqIDwgdGV4dENvbnRlbnROb3JtLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC8vIGtlZXAgY29uc3VtaW5nIGNzcyBpZGVudGlmaWVycyAodG8gZ2V0IGEgZGVjZW50IGNodW5rIG1vcmUgcXVpY2tseSlcbiAgICAgICAgICAgICAgICAgICAgdGV4dENvbnRlbnROb3JtW2pdLm1hdGNoKC9bYS16QS1aMC05XS8pIHx8IC8vIHN1YnN0cmluZyBuZWVkcyB0byBiZSB1bmlxdWUgdG8gdGhpcyBzZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHRleHRDb250ZW50Tm9ybS5pbmRleE9mKHRleHRDb250ZW50Tm9ybS5zdWJzdHJpbmcoMCwgaiksIDEpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvcig7IGogPCB0ZXh0Q29udGVudE5vcm0ubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRTdWJzdHJpbmcgPSB0ZXh0Q29udGVudE5vcm0uc3Vic3RyaW5nKDAsIGopO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3NzTm9ybVNwbGl0cyA9IGNzc1RleHROb3JtLnNwbGl0KHN0YXJ0U3Vic3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwbGl0Tm9ybSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3NzTm9ybVNwbGl0cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0Tm9ybSA9IGNzc05vcm1TcGxpdHNbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNzc05vcm1TcGxpdHMubGVuZ3RoID4gMiAmJiBjc3NOb3JtU3BsaXRzWzBdID09PSBcIlwiICYmIGNoaWxkTm9kZXMyW2kyIC0gMV0udGV4dENvbnRlbnQgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0Tm9ybSA9IGNzc1RleHROb3JtLmluZGV4T2Yoc3RhcnRTdWJzdHJpbmcsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNzc05vcm1TcGxpdHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFN1YnN0cmluZyA9IHN0YXJ0U3Vic3RyaW5nLnN1YnN0cmluZygwLCBzdGFydFN1YnN0cmluZy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc05vcm1TcGxpdHMgPSBjc3NUZXh0Tm9ybS5zcGxpdChzdGFydFN1YnN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3NzTm9ybVNwbGl0cy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0cy5wdXNoKGNzc1RleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzcGxpdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBqID0gakxpbWl0ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChqID09PSB0ZXh0Q29udGVudE5vcm0ubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXROb3JtID0gY3NzVGV4dE5vcm0uaW5kZXhPZihzdGFydFN1YnN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNzc05vcm1TcGxpdHMubGVuZ3RoID49IDIgJiYgaiA+IGpMaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZUZXh0Q29udGVudCA9IGNoaWxkTm9kZXMyW2kyIC0gMV0udGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldlRleHRDb250ZW50ICYmIHR5cGVvZiBwcmV2VGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldk1pbkxlbmd0aCA9IG5vcm1hbGl6ZUNzc1N0cmluZyhwcmV2VGV4dENvbnRlbnQpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGxpdE5vcm0gPSBjc3NUZXh0Tm9ybS5pbmRleE9mKHN0YXJ0U3Vic3RyaW5nLCBwcmV2TWluTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGxpdE5vcm0gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXROb3JtID0gY3NzTm9ybVNwbGl0c1swXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwbGl0Tm9ybSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrID0gTWF0aC5mbG9vcihzcGxpdE5vcm0gLyBub3JtRmFjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcig7IGsgPiAwICYmIGsgPCBjc3NUZXh0Lmxlbmd0aDspe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJDb3VudCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVyQ291bnQgPiA1MCAqIGNoaWxkTm9kZXMyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGxpdHMucHVzaChjc3NUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNwbGl0cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vcm1QYXJ0ID0gbm9ybWFsaXplQ3NzU3RyaW5nKGNzc1RleHQuc3Vic3RyaW5nKDAsIGspLCBfdGVzdE5vUHhOb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9ybVBhcnQubGVuZ3RoID09PSBzcGxpdE5vcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXRzLnB1c2goY3NzVGV4dC5zdWJzdHJpbmcoMCwgaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3NUZXh0ID0gY3NzVGV4dC5zdWJzdHJpbmcoayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzc1RleHROb3JtID0gY3NzVGV4dE5vcm0uc3Vic3RyaW5nKHNwbGl0Tm9ybSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9ybVBhcnQubGVuZ3RoIDwgc3BsaXROb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsgKz0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcigoc3BsaXROb3JtIC0gbm9ybVBhcnQubGVuZ3RoKSAvIG5vcm1GYWN0b3IpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrIC09IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoKG5vcm1QYXJ0Lmxlbmd0aCAtIHNwbGl0Tm9ybSkgKiBub3JtRmFjdG9yKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3BsaXRzLnB1c2goY3NzVGV4dCk7XG4gICAgcmV0dXJuIHNwbGl0cztcbn1cbmZ1bmN0aW9uIG1hcmtDc3NTcGxpdHMoY3NzVGV4dCwgc3R5bGUpIHtcbiAgICByZXR1cm4gc3BsaXRDc3NUZXh0KGNzc1RleHQsIHN0eWxlKS5qb2luKFwiLyogcnJfc3BsaXQgKi9cIik7XG59XG52YXIgX2lkID0gMTtcbnZhciB0YWdOYW1lUmVnZXggPSBuZXcgUmVnRXhwKFwiW15hLXowLTktXzpdXCIpO1xudmFyIElHTk9SRURfTk9ERSA9IC0yO1xuZnVuY3Rpb24gZ2VuSWQoKSB7XG4gICAgcmV0dXJuIF9pZCsrO1xufVxuZnVuY3Rpb24gZ2V0VmFsaWRUYWdOYW1lJDEoZWxlbWVudCkge1xuICAgIGlmIChfaW5zdGFuY2VvZihlbGVtZW50LCBIVE1MRm9ybUVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBcImZvcm1cIjtcbiAgICB9XG4gICAgdmFyIHByb2Nlc3NlZFRhZ05hbWUgPSB0b0xvd2VyQ2FzZShlbGVtZW50LnRhZ05hbWUpO1xuICAgIGlmICh0YWdOYW1lUmVnZXgudGVzdChwcm9jZXNzZWRUYWdOYW1lKSkge1xuICAgICAgICByZXR1cm4gXCJkaXZcIjtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3NlZFRhZ05hbWU7XG59XG52YXIgY2FudmFzU2VydmljZTtcbnZhciBjYW52YXNDdHg7XG52YXIgU1JDU0VUX05PVF9TUEFDRVMgPSAvXlteIFxcdFxcblxcclxcdTAwMGNdKy87XG52YXIgU1JDU0VUX0NPTU1BU19PUl9TUEFDRVMgPSAvXlssIFxcdFxcblxcclxcdTAwMGNdKy87XG5mdW5jdGlvbiBnZXRBYnNvbHV0ZVNyY3NldFN0cmluZyhkb2MsIGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgaWYgKGF0dHJpYnV0ZVZhbHVlLnRyaW0oKSA9PT0gXCJcIikge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlVmFsdWU7XG4gICAgfVxuICAgIHZhciBwb3MgPSAwO1xuICAgIGZ1bmN0aW9uIGNvbGxlY3RDaGFyYWN0ZXJzKHJlZ0V4KSB7XG4gICAgICAgIHZhciBjaGFyczI7XG4gICAgICAgIHZhciBtYXRjaCA9IHJlZ0V4LmV4ZWMoYXR0cmlidXRlVmFsdWUuc3Vic3RyaW5nKHBvcykpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNoYXJzMiA9IG1hdGNoWzBdO1xuICAgICAgICAgICAgcG9zICs9IGNoYXJzMi5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gY2hhcnMyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgd2hpbGUodHJ1ZSl7XG4gICAgICAgIGNvbGxlY3RDaGFyYWN0ZXJzKFNSQ1NFVF9DT01NQVNfT1JfU1BBQ0VTKTtcbiAgICAgICAgaWYgKHBvcyA+PSBhdHRyaWJ1dGVWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1cmwgPSBjb2xsZWN0Q2hhcmFjdGVycyhTUkNTRVRfTk9UX1NQQUNFUyk7XG4gICAgICAgIGlmICh1cmwuc2xpY2UoLTEpID09PSBcIixcIikge1xuICAgICAgICAgICAgdXJsID0gYWJzb2x1dGVUb0RvYyhkb2MsIHVybC5zdWJzdHJpbmcoMCwgdXJsLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKHVybCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGVzY3JpcHRvcnNTdHIgPSBcIlwiO1xuICAgICAgICAgICAgdXJsID0gYWJzb2x1dGVUb0RvYyhkb2MsIHVybCk7XG4gICAgICAgICAgICB2YXIgaW5QYXJlbnMgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlKHRydWUpe1xuICAgICAgICAgICAgICAgIHZhciBjMiA9IGF0dHJpYnV0ZVZhbHVlLmNoYXJBdChwb3MpO1xuICAgICAgICAgICAgICAgIGlmIChjMiA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCgodXJsICsgZGVzY3JpcHRvcnNTdHIpLnRyaW0oKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWluUGFyZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjMiA9PT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goKHVybCArIGRlc2NyaXB0b3JzU3RyKS50cmltKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYzIgPT09IFwiKFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpblBhcmVucyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYzIgPT09IFwiKVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpblBhcmVucyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3JzU3RyICs9IGMyO1xuICAgICAgICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQuam9pbihcIiwgXCIpO1xufVxudmFyIGNhY2hlZERvY3VtZW50ID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBhYnNvbHV0ZVRvRG9jKGRvYywgYXR0cmlidXRlVmFsdWUpIHtcbiAgICBpZiAoIWF0dHJpYnV0ZVZhbHVlIHx8IGF0dHJpYnV0ZVZhbHVlLnRyaW0oKSA9PT0gXCJcIikge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlVmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBnZXRIcmVmKGRvYywgYXR0cmlidXRlVmFsdWUpO1xufVxuZnVuY3Rpb24gaXNTVkdFbGVtZW50KGVsKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oZWwudGFnTmFtZSA9PT0gXCJzdmdcIiB8fCBlbC5vd25lclNWR0VsZW1lbnQpO1xufVxuZnVuY3Rpb24gZ2V0SHJlZihkb2MsIGN1c3RvbUhyZWYpIHtcbiAgICB2YXIgYTIgPSBjYWNoZWREb2N1bWVudC5nZXQoZG9jKTtcbiAgICBpZiAoIWEyKSB7XG4gICAgICAgIGEyID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgICAgICBjYWNoZWREb2N1bWVudC5zZXQoZG9jLCBhMik7XG4gICAgfVxuICAgIGlmICghY3VzdG9tSHJlZikge1xuICAgICAgICBjdXN0b21IcmVmID0gXCJcIjtcbiAgICB9IGVsc2UgaWYgKGN1c3RvbUhyZWYuc3RhcnRzV2l0aChcImJsb2I6XCIpIHx8IGN1c3RvbUhyZWYuc3RhcnRzV2l0aChcImRhdGE6XCIpKSB7XG4gICAgICAgIHJldHVybiBjdXN0b21IcmVmO1xuICAgIH1cbiAgICBhMi5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGN1c3RvbUhyZWYpO1xuICAgIHJldHVybiBhMi5ocmVmO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtQXR0cmlidXRlKGRvYywgdGFnTmFtZSwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09IFwic3JjXCIgfHwgbmFtZSA9PT0gXCJocmVmXCIgJiYgISh0YWdOYW1lID09PSBcInVzZVwiICYmIHZhbHVlWzBdID09PSBcIiNcIikpIHtcbiAgICAgICAgcmV0dXJuIGFic29sdXRlVG9Eb2MoZG9jLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSBcInhsaW5rOmhyZWZcIiAmJiB2YWx1ZVswXSAhPT0gXCIjXCIpIHtcbiAgICAgICAgcmV0dXJuIGFic29sdXRlVG9Eb2MoZG9jLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSBcImJhY2tncm91bmRcIiAmJiAodGFnTmFtZSA9PT0gXCJ0YWJsZVwiIHx8IHRhZ05hbWUgPT09IFwidGRcIiB8fCB0YWdOYW1lID09PSBcInRoXCIpKSB7XG4gICAgICAgIHJldHVybiBhYnNvbHV0ZVRvRG9jKGRvYywgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJzcmNzZXRcIikge1xuICAgICAgICByZXR1cm4gZ2V0QWJzb2x1dGVTcmNzZXRTdHJpbmcoZG9jLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSBcInN0eWxlXCIpIHtcbiAgICAgICAgcmV0dXJuIGFic29sdXRpZnlVUkxzKHZhbHVlLCBnZXRIcmVmKGRvYykpO1xuICAgIH0gZWxzZSBpZiAodGFnTmFtZSA9PT0gXCJvYmplY3RcIiAmJiBuYW1lID09PSBcImRhdGFcIikge1xuICAgICAgICByZXR1cm4gYWJzb2x1dGVUb0RvYyhkb2MsIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gaWdub3JlQXR0cmlidXRlKHRhZ05hbWUsIG5hbWUsIF92YWx1ZSkge1xuICAgIHJldHVybiAodGFnTmFtZSA9PT0gXCJ2aWRlb1wiIHx8IHRhZ05hbWUgPT09IFwiYXVkaW9cIikgJiYgbmFtZSA9PT0gXCJhdXRvcGxheVwiO1xufVxuZnVuY3Rpb24gX2lzQmxvY2tlZEVsZW1lbnQoZWxlbWVudCwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvcikge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgYmxvY2tDbGFzcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGJsb2NrQ2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IodmFyIGVJbmRleCA9IGVsZW1lbnQuY2xhc3NMaXN0Lmxlbmd0aDsgZUluZGV4LS07KXtcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc0xpc3RbZUluZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tDbGFzcy50ZXN0KGNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChibG9ja1NlbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5tYXRjaGVzKGJsb2NrU2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZTIpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY2xhc3NNYXRjaGVzUmVnZXgobm9kZTIsIHJlZ2V4LCBjaGVja0FuY2VzdG9ycykge1xuICAgIGlmICghbm9kZTIpIHJldHVybiBmYWxzZTtcbiAgICBpZiAobm9kZTIubm9kZVR5cGUgIT09IG5vZGUyLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICBpZiAoIWNoZWNrQW5jZXN0b3JzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBjbGFzc01hdGNoZXNSZWdleChpbmRleCQxLnBhcmVudE5vZGUobm9kZTIpLCByZWdleCwgY2hlY2tBbmNlc3RvcnMpO1xuICAgIH1cbiAgICBmb3IodmFyIGVJbmRleCA9IG5vZGUyLmNsYXNzTGlzdC5sZW5ndGg7IGVJbmRleC0tOyl7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSBub2RlMi5jbGFzc0xpc3RbZUluZGV4XTtcbiAgICAgICAgaWYgKHJlZ2V4LnRlc3QoY2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjaGVja0FuY2VzdG9ycykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBjbGFzc01hdGNoZXNSZWdleChpbmRleCQxLnBhcmVudE5vZGUobm9kZTIpLCByZWdleCwgY2hlY2tBbmNlc3RvcnMpO1xufVxuZnVuY3Rpb24gbmVlZE1hc2tpbmdUZXh0KG5vZGUyLCBtYXNrVGV4dENsYXNzLCBtYXNrVGV4dFNlbGVjdG9yLCBjaGVja0FuY2VzdG9ycykge1xuICAgIHZhciBlbDtcbiAgICBpZiAoaXNFbGVtZW50KG5vZGUyKSkge1xuICAgICAgICBlbCA9IG5vZGUyO1xuICAgICAgICBpZiAoIWluZGV4JDEuY2hpbGROb2RlcyhlbCkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGluZGV4JDEucGFyZW50RWxlbWVudChub2RlMikgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGVsID0gaW5kZXgkMS5wYXJlbnRFbGVtZW50KG5vZGUyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXNrVGV4dENsYXNzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tBbmNlc3RvcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWwuY2xvc2VzdChcIi5cIiArIG1hc2tUZXh0Q2xhc3MpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucyhtYXNrVGV4dENsYXNzKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2xhc3NNYXRjaGVzUmVnZXgoZWwsIG1hc2tUZXh0Q2xhc3MsIGNoZWNrQW5jZXN0b3JzKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hc2tUZXh0U2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGlmIChjaGVja0FuY2VzdG9ycykge1xuICAgICAgICAgICAgICAgIGlmIChlbC5jbG9zZXN0KG1hc2tUZXh0U2VsZWN0b3IpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsLm1hdGNoZXMobWFza1RleHRTZWxlY3RvcikpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZTIpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gb25jZUlmcmFtZUxvYWRlZChpZnJhbWVFbCwgbGlzdGVuZXIsIGlmcmFtZUxvYWRUaW1lb3V0KSB7XG4gICAgdmFyIHdpbiA9IGlmcmFtZUVsLmNvbnRlbnRXaW5kb3c7XG4gICAgaWYgKCF3aW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZmlyZWQgPSBmYWxzZTtcbiAgICB2YXIgcmVhZHlTdGF0ZTtcbiAgICB0cnkge1xuICAgICAgICByZWFkeVN0YXRlID0gd2luLmRvY3VtZW50LnJlYWR5U3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocmVhZHlTdGF0ZSAhPT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIWZpcmVkKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICBmaXJlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGlmcmFtZUxvYWRUaW1lb3V0KTtcbiAgICAgICAgaWZyYW1lRWwuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGJsYW5rVXJsID0gXCJhYm91dDpibGFua1wiO1xuICAgIGlmICh3aW4ubG9jYXRpb24uaHJlZiAhPT0gYmxhbmtVcmwgfHwgaWZyYW1lRWwuc3JjID09PSBibGFua1VybCB8fCBpZnJhbWVFbC5zcmMgPT09IFwiXCIpIHtcbiAgICAgICAgc2V0VGltZW91dChsaXN0ZW5lciwgMCk7XG4gICAgICAgIHJldHVybiBpZnJhbWVFbC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIGlmcmFtZUVsLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGxpc3RlbmVyKTtcbn1cbmZ1bmN0aW9uIG9uY2VTdHlsZXNoZWV0TG9hZGVkKGxpbmssIGxpc3RlbmVyLCBzdHlsZVNoZWV0TG9hZFRpbWVvdXQpIHtcbiAgICB2YXIgZmlyZWQgPSBmYWxzZTtcbiAgICB2YXIgc3R5bGVTaGVldExvYWRlZDtcbiAgICB0cnkge1xuICAgICAgICBzdHlsZVNoZWV0TG9hZGVkID0gbGluay5zaGVldDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzdHlsZVNoZWV0TG9hZGVkKSByZXR1cm47XG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFmaXJlZCkge1xuICAgICAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgICAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sIHN0eWxlU2hlZXRMb2FkVGltZW91dCk7XG4gICAgbGluay5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgICBsaXN0ZW5lcigpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplTm9kZShuMiwgb3B0aW9ucykge1xuICAgIHZhciBkb2MgPSBvcHRpb25zLmRvYywgbWlycm9yMiA9IG9wdGlvbnMubWlycm9yLCBibG9ja0NsYXNzID0gb3B0aW9ucy5ibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yID0gb3B0aW9ucy5ibG9ja1NlbGVjdG9yLCBuZWVkc01hc2sgPSBvcHRpb25zLm5lZWRzTWFzaywgaW5saW5lU3R5bGVzaGVldCA9IG9wdGlvbnMuaW5saW5lU3R5bGVzaGVldCwgX29wdGlvbnNfbWFza0lucHV0T3B0aW9ucyA9IG9wdGlvbnMubWFza0lucHV0T3B0aW9ucywgbWFza0lucHV0T3B0aW9ucyA9IF9vcHRpb25zX21hc2tJbnB1dE9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX29wdGlvbnNfbWFza0lucHV0T3B0aW9ucywgbWFza1RleHRGbiA9IG9wdGlvbnMubWFza1RleHRGbiwgbWFza0lucHV0Rm4gPSBvcHRpb25zLm1hc2tJbnB1dEZuLCBfb3B0aW9uc19kYXRhVVJMT3B0aW9ucyA9IG9wdGlvbnMuZGF0YVVSTE9wdGlvbnMsIGRhdGFVUkxPcHRpb25zID0gX29wdGlvbnNfZGF0YVVSTE9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX29wdGlvbnNfZGF0YVVSTE9wdGlvbnMsIGlubGluZUltYWdlcyA9IG9wdGlvbnMuaW5saW5lSW1hZ2VzLCByZWNvcmRDYW52YXMgPSBvcHRpb25zLnJlY29yZENhbnZhcywga2VlcElmcmFtZVNyY0ZuID0gb3B0aW9ucy5rZWVwSWZyYW1lU3JjRm4sIF9vcHRpb25zX25ld2x5QWRkZWRFbGVtZW50ID0gb3B0aW9ucy5uZXdseUFkZGVkRWxlbWVudCwgbmV3bHlBZGRlZEVsZW1lbnQgPSBfb3B0aW9uc19uZXdseUFkZGVkRWxlbWVudCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9uc19uZXdseUFkZGVkRWxlbWVudCwgX29wdGlvbnNfY3NzQ2FwdHVyZWQgPSBvcHRpb25zLmNzc0NhcHR1cmVkLCBjc3NDYXB0dXJlZCA9IF9vcHRpb25zX2Nzc0NhcHR1cmVkID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zX2Nzc0NhcHR1cmVkO1xuICAgIHZhciByb290SWQgPSBnZXRSb290SWQoZG9jLCBtaXJyb3IyKTtcbiAgICBzd2l0Y2gobjIubm9kZVR5cGUpe1xuICAgICAgICBjYXNlIG4yLkRPQ1VNRU5UX05PREU6XG4gICAgICAgICAgICBpZiAobjIuY29tcGF0TW9kZSAhPT0gXCJDU1MxQ29tcGF0XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBOb2RlVHlwZSQzLkRvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgY29tcGF0TW9kZTogbjIuY29tcGF0TW9kZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE5vZGVUeXBlJDMuRG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBuMi5ET0NVTUVOVF9UWVBFX05PREU6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IE5vZGVUeXBlJDMuRG9jdW1lbnRUeXBlLFxuICAgICAgICAgICAgICAgIG5hbWU6IG4yLm5hbWUsXG4gICAgICAgICAgICAgICAgcHVibGljSWQ6IG4yLnB1YmxpY0lkLFxuICAgICAgICAgICAgICAgIHN5c3RlbUlkOiBuMi5zeXN0ZW1JZCxcbiAgICAgICAgICAgICAgICByb290SWQ6IHJvb3RJZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBuMi5FTEVNRU5UX05PREU6XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplRWxlbWVudE5vZGUobjIsIHtcbiAgICAgICAgICAgICAgICBkb2M6IGRvYyxcbiAgICAgICAgICAgICAgICBibG9ja0NsYXNzOiBibG9ja0NsYXNzLFxuICAgICAgICAgICAgICAgIGJsb2NrU2VsZWN0b3I6IGJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgaW5saW5lU3R5bGVzaGVldDogaW5saW5lU3R5bGVzaGVldCxcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiBtYXNrSW5wdXRPcHRpb25zLFxuICAgICAgICAgICAgICAgIG1hc2tJbnB1dEZuOiBtYXNrSW5wdXRGbixcbiAgICAgICAgICAgICAgICBkYXRhVVJMT3B0aW9uczogZGF0YVVSTE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgaW5saW5lSW1hZ2VzOiBpbmxpbmVJbWFnZXMsXG4gICAgICAgICAgICAgICAgcmVjb3JkQ2FudmFzOiByZWNvcmRDYW52YXMsXG4gICAgICAgICAgICAgICAga2VlcElmcmFtZVNyY0ZuOiBrZWVwSWZyYW1lU3JjRm4sXG4gICAgICAgICAgICAgICAgbmV3bHlBZGRlZEVsZW1lbnQ6IG5ld2x5QWRkZWRFbGVtZW50LFxuICAgICAgICAgICAgICAgIHJvb3RJZDogcm9vdElkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSBuMi5URVhUX05PREU6XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVGV4dE5vZGUobjIsIHtcbiAgICAgICAgICAgICAgICBkb2M6IGRvYyxcbiAgICAgICAgICAgICAgICBuZWVkc01hc2s6IG5lZWRzTWFzayxcbiAgICAgICAgICAgICAgICBtYXNrVGV4dEZuOiBtYXNrVGV4dEZuLFxuICAgICAgICAgICAgICAgIHJvb3RJZDogcm9vdElkLFxuICAgICAgICAgICAgICAgIGNzc0NhcHR1cmVkOiBjc3NDYXB0dXJlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgbjIuQ0RBVEFfU0VDVElPTl9OT0RFOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBOb2RlVHlwZSQzLkNEQVRBLFxuICAgICAgICAgICAgICAgIHRleHRDb250ZW50OiBcIlwiLFxuICAgICAgICAgICAgICAgIHJvb3RJZDogcm9vdElkXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIG4yLkNPTU1FTlRfTk9ERTpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogTm9kZVR5cGUkMy5Db21tZW50LFxuICAgICAgICAgICAgICAgIHRleHRDb250ZW50OiBpbmRleCQxLnRleHRDb250ZW50KG4yKSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIHJvb3RJZDogcm9vdElkXG4gICAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFJvb3RJZChkb2MsIG1pcnJvcjIpIHtcbiAgICBpZiAoIW1pcnJvcjIuaGFzTm9kZShkb2MpKSByZXR1cm4gdm9pZCAwO1xuICAgIHZhciBkb2NJZCA9IG1pcnJvcjIuZ2V0SWQoZG9jKTtcbiAgICByZXR1cm4gZG9jSWQgPT09IDEgPyB2b2lkIDAgOiBkb2NJZDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVRleHROb2RlKG4yLCBvcHRpb25zKSB7XG4gICAgdmFyIG5lZWRzTWFzayA9IG9wdGlvbnMubmVlZHNNYXNrLCBtYXNrVGV4dEZuID0gb3B0aW9ucy5tYXNrVGV4dEZuLCByb290SWQgPSBvcHRpb25zLnJvb3RJZCwgY3NzQ2FwdHVyZWQgPSBvcHRpb25zLmNzc0NhcHR1cmVkO1xuICAgIHZhciBwYXJlbnQgPSBpbmRleCQxLnBhcmVudE5vZGUobjIpO1xuICAgIHZhciBwYXJlbnRUYWdOYW1lID0gcGFyZW50ICYmIHBhcmVudC50YWdOYW1lO1xuICAgIHZhciB0ZXh0Q29udGVudDIgPSBcIlwiO1xuICAgIHZhciBpc1N0eWxlID0gcGFyZW50VGFnTmFtZSA9PT0gXCJTVFlMRVwiID8gdHJ1ZSA6IHZvaWQgMDtcbiAgICB2YXIgaXNTY3JpcHQgPSBwYXJlbnRUYWdOYW1lID09PSBcIlNDUklQVFwiID8gdHJ1ZSA6IHZvaWQgMDtcbiAgICBpZiAoaXNTY3JpcHQpIHtcbiAgICAgICAgdGV4dENvbnRlbnQyID0gXCJTQ1JJUFRfUExBQ0VIT0xERVJcIjtcbiAgICB9IGVsc2UgaWYgKCFjc3NDYXB0dXJlZCkge1xuICAgICAgICB0ZXh0Q29udGVudDIgPSBpbmRleCQxLnRleHRDb250ZW50KG4yKTtcbiAgICAgICAgaWYgKGlzU3R5bGUgJiYgdGV4dENvbnRlbnQyKSB7XG4gICAgICAgICAgICB0ZXh0Q29udGVudDIgPSBhYnNvbHV0aWZ5VVJMcyh0ZXh0Q29udGVudDIsIGdldEhyZWYob3B0aW9ucy5kb2MpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzU3R5bGUgJiYgIWlzU2NyaXB0ICYmIHRleHRDb250ZW50MiAmJiBuZWVkc01hc2spIHtcbiAgICAgICAgdGV4dENvbnRlbnQyID0gbWFza1RleHRGbiA/IG1hc2tUZXh0Rm4odGV4dENvbnRlbnQyLCBpbmRleCQxLnBhcmVudEVsZW1lbnQobjIpKSA6IHRleHRDb250ZW50Mi5yZXBsYWNlKC9bXFxTXS9nLCBcIipcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IE5vZGVUeXBlJDMuVGV4dCxcbiAgICAgICAgdGV4dENvbnRlbnQ6IHRleHRDb250ZW50MiB8fCBcIlwiLFxuICAgICAgICByb290SWQ6IHJvb3RJZFxuICAgIH07XG59XG5mdW5jdGlvbiBzZXJpYWxpemVFbGVtZW50Tm9kZShuMiwgb3B0aW9ucykge1xuICAgIHZhciBkb2MgPSBvcHRpb25zLmRvYywgYmxvY2tDbGFzcyA9IG9wdGlvbnMuYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciA9IG9wdGlvbnMuYmxvY2tTZWxlY3RvciwgaW5saW5lU3R5bGVzaGVldCA9IG9wdGlvbnMuaW5saW5lU3R5bGVzaGVldCwgX29wdGlvbnNfbWFza0lucHV0T3B0aW9ucyA9IG9wdGlvbnMubWFza0lucHV0T3B0aW9ucywgbWFza0lucHV0T3B0aW9ucyA9IF9vcHRpb25zX21hc2tJbnB1dE9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX29wdGlvbnNfbWFza0lucHV0T3B0aW9ucywgbWFza0lucHV0Rm4gPSBvcHRpb25zLm1hc2tJbnB1dEZuLCBfb3B0aW9uc19kYXRhVVJMT3B0aW9ucyA9IG9wdGlvbnMuZGF0YVVSTE9wdGlvbnMsIGRhdGFVUkxPcHRpb25zID0gX29wdGlvbnNfZGF0YVVSTE9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX29wdGlvbnNfZGF0YVVSTE9wdGlvbnMsIGlubGluZUltYWdlcyA9IG9wdGlvbnMuaW5saW5lSW1hZ2VzLCByZWNvcmRDYW52YXMgPSBvcHRpb25zLnJlY29yZENhbnZhcywga2VlcElmcmFtZVNyY0ZuID0gb3B0aW9ucy5rZWVwSWZyYW1lU3JjRm4sIF9vcHRpb25zX25ld2x5QWRkZWRFbGVtZW50ID0gb3B0aW9ucy5uZXdseUFkZGVkRWxlbWVudCwgbmV3bHlBZGRlZEVsZW1lbnQgPSBfb3B0aW9uc19uZXdseUFkZGVkRWxlbWVudCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9uc19uZXdseUFkZGVkRWxlbWVudCwgcm9vdElkID0gb3B0aW9ucy5yb290SWQ7XG4gICAgdmFyIG5lZWRCbG9jayA9IF9pc0Jsb2NrZWRFbGVtZW50KG4yLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKTtcbiAgICB2YXIgdGFnTmFtZSA9IGdldFZhbGlkVGFnTmFtZSQxKG4yKTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICAgIHZhciBsZW4gPSBuMi5hdHRyaWJ1dGVzLmxlbmd0aDtcbiAgICBmb3IodmFyIGkyID0gMDsgaTIgPCBsZW47IGkyKyspe1xuICAgICAgICB2YXIgYXR0ciA9IG4yLmF0dHJpYnV0ZXNbaTJdO1xuICAgICAgICBpZiAoIWlnbm9yZUF0dHJpYnV0ZSh0YWdOYW1lLCBhdHRyLm5hbWUsIGF0dHIudmFsdWUpKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzW2F0dHIubmFtZV0gPSB0cmFuc2Zvcm1BdHRyaWJ1dGUoZG9jLCB0YWdOYW1lLCB0b0xvd2VyQ2FzZShhdHRyLm5hbWUpLCBhdHRyLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGFnTmFtZSA9PT0gXCJsaW5rXCIgJiYgaW5saW5lU3R5bGVzaGVldCkge1xuICAgICAgICB2YXIgc3R5bGVzaGVldCA9IEFycmF5LmZyb20oZG9jLnN0eWxlU2hlZXRzKS5maW5kKGZ1bmN0aW9uKHMyKSB7XG4gICAgICAgICAgICByZXR1cm4gczIuaHJlZiA9PT0gbjIuaHJlZjtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjc3NUZXh0ID0gbnVsbDtcbiAgICAgICAgaWYgKHN0eWxlc2hlZXQpIHtcbiAgICAgICAgICAgIGNzc1RleHQgPSBzdHJpbmdpZnlTdHlsZXNoZWV0KHN0eWxlc2hlZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjc3NUZXh0KSB7XG4gICAgICAgICAgICBkZWxldGUgYXR0cmlidXRlcy5yZWw7XG4gICAgICAgICAgICBkZWxldGUgYXR0cmlidXRlcy5ocmVmO1xuICAgICAgICAgICAgYXR0cmlidXRlcy5fY3NzVGV4dCA9IGNzc1RleHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhZ05hbWUgPT09IFwic3R5bGVcIiAmJiBuMi5zaGVldCkge1xuICAgICAgICB2YXIgY3NzVGV4dDEgPSBzdHJpbmdpZnlTdHlsZXNoZWV0KG4yLnNoZWV0KTtcbiAgICAgICAgaWYgKGNzc1RleHQxKSB7XG4gICAgICAgICAgICBpZiAobjIuY2hpbGROb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgY3NzVGV4dDEgPSBtYXJrQ3NzU3BsaXRzKGNzc1RleHQxLCBuMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLl9jc3NUZXh0ID0gY3NzVGV4dDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhZ05hbWUgPT09IFwiaW5wdXRcIiB8fCB0YWdOYW1lID09PSBcInRleHRhcmVhXCIgfHwgdGFnTmFtZSA9PT0gXCJzZWxlY3RcIikge1xuICAgICAgICB2YXIgdmFsdWUgPSBuMi52YWx1ZTtcbiAgICAgICAgdmFyIGNoZWNrZWQgPSBuMi5jaGVja2VkO1xuICAgICAgICBpZiAoYXR0cmlidXRlcy50eXBlICE9PSBcInJhZGlvXCIgJiYgYXR0cmlidXRlcy50eXBlICE9PSBcImNoZWNrYm94XCIgJiYgYXR0cmlidXRlcy50eXBlICE9PSBcInN1Ym1pdFwiICYmIGF0dHJpYnV0ZXMudHlwZSAhPT0gXCJidXR0b25cIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy52YWx1ZSA9IG1hc2tJbnB1dFZhbHVlKHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBuMixcbiAgICAgICAgICAgICAgICB0eXBlOiBnZXRJbnB1dFR5cGUobjIpLFxuICAgICAgICAgICAgICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnM6IG1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgbWFza0lucHV0Rm46IG1hc2tJbnB1dEZuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGVja2VkKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLmNoZWNrZWQgPSBjaGVja2VkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0YWdOYW1lID09PSBcIm9wdGlvblwiKSB7XG4gICAgICAgIGlmIChuMi5zZWxlY3RlZCAmJiAhbWFza0lucHV0T3B0aW9uc1tcInNlbGVjdFwiXSkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgYXR0cmlidXRlcy5zZWxlY3RlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGFnTmFtZSA9PT0gXCJkaWFsb2dcIiAmJiBuMi5vcGVuKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMucnJfb3Blbl9tb2RlID0gbjIubWF0Y2hlcyhcImRpYWxvZzptb2RhbFwiKSA/IFwibW9kYWxcIiA6IFwibm9uLW1vZGFsXCI7XG4gICAgfVxuICAgIGlmICh0YWdOYW1lID09PSBcImNhbnZhc1wiICYmIHJlY29yZENhbnZhcykge1xuICAgICAgICBpZiAobjIuX19jb250ZXh0ID09PSBcIjJkXCIpIHtcbiAgICAgICAgICAgIGlmICghaXMyRENhbnZhc0JsYW5rKG4yKSkge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMucnJfZGF0YVVSTCA9IG4yLnRvRGF0YVVSTChkYXRhVVJMT3B0aW9ucy50eXBlLCBkYXRhVVJMT3B0aW9ucy5xdWFsaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghKFwiX19jb250ZXh0XCIgaW4gbjIpKSB7XG4gICAgICAgICAgICB2YXIgY2FudmFzRGF0YVVSTCA9IG4yLnRvRGF0YVVSTChkYXRhVVJMT3B0aW9ucy50eXBlLCBkYXRhVVJMT3B0aW9ucy5xdWFsaXR5KTtcbiAgICAgICAgICAgIHZhciBibGFua0NhbnZhcyA9IGRvYy5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAgICAgYmxhbmtDYW52YXMud2lkdGggPSBuMi53aWR0aDtcbiAgICAgICAgICAgIGJsYW5rQ2FudmFzLmhlaWdodCA9IG4yLmhlaWdodDtcbiAgICAgICAgICAgIHZhciBibGFua0NhbnZhc0RhdGFVUkwgPSBibGFua0NhbnZhcy50b0RhdGFVUkwoZGF0YVVSTE9wdGlvbnMudHlwZSwgZGF0YVVSTE9wdGlvbnMucXVhbGl0eSk7XG4gICAgICAgICAgICBpZiAoY2FudmFzRGF0YVVSTCAhPT0gYmxhbmtDYW52YXNEYXRhVVJMKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5ycl9kYXRhVVJMID0gY2FudmFzRGF0YVVSTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGFnTmFtZSA9PT0gXCJpbWdcIiAmJiBpbmxpbmVJbWFnZXMpIHtcbiAgICAgICAgaWYgKCFjYW52YXNTZXJ2aWNlKSB7XG4gICAgICAgICAgICBjYW52YXNTZXJ2aWNlID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgICAgICBjYW52YXNDdHggPSBjYW52YXNTZXJ2aWNlLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW1hZ2UgPSBuMjtcbiAgICAgICAgdmFyIGltYWdlU3JjID0gaW1hZ2UuY3VycmVudFNyYyB8fCBpbWFnZS5nZXRBdHRyaWJ1dGUoXCJzcmNcIikgfHwgXCI8dW5rbm93bi1zcmM+XCI7XG4gICAgICAgIHZhciBwcmlvckNyb3NzT3JpZ2luID0gaW1hZ2UuY3Jvc3NPcmlnaW47XG4gICAgICAgIHZhciByZWNvcmRJbmxpbmVJbWFnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaW1hZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgcmVjb3JkSW5saW5lSW1hZ2UpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjYW52YXNTZXJ2aWNlLndpZHRoID0gaW1hZ2UubmF0dXJhbFdpZHRoO1xuICAgICAgICAgICAgICAgIGNhbnZhc1NlcnZpY2UuaGVpZ2h0ID0gaW1hZ2UubmF0dXJhbEhlaWdodDtcbiAgICAgICAgICAgICAgICBjYW52YXNDdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwKTtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnJyX2RhdGFVUkwgPSBjYW52YXNTZXJ2aWNlLnRvRGF0YVVSTChkYXRhVVJMT3B0aW9ucy50eXBlLCBkYXRhVVJMT3B0aW9ucy5xdWFsaXR5KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChpbWFnZS5jcm9zc09yaWdpbiAhPT0gXCJhbm9ueW1vdXNcIikge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZS5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZS5jb21wbGV0ZSAmJiBpbWFnZS5uYXR1cmFsV2lkdGggIT09IDApIHJlY29yZElubGluZUltYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgcmVjb3JkSW5saW5lSW1hZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ2Fubm90IGlubGluZSBpbWcgc3JjPVwiICsgaW1hZ2VTcmMgKyBcIiEgRXJyb3I6IFwiICsgZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW1hZ2UuY3Jvc3NPcmlnaW4gPT09IFwiYW5vbnltb3VzXCIpIHtcbiAgICAgICAgICAgICAgICBwcmlvckNyb3NzT3JpZ2luID8gYXR0cmlidXRlcy5jcm9zc09yaWdpbiA9IHByaW9yQ3Jvc3NPcmlnaW4gOiBpbWFnZS5yZW1vdmVBdHRyaWJ1dGUoXCJjcm9zc29yaWdpblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGltYWdlLmNvbXBsZXRlICYmIGltYWdlLm5hdHVyYWxXaWR0aCAhPT0gMCkgcmVjb3JkSW5saW5lSW1hZ2UoKTtcbiAgICAgICAgZWxzZSBpbWFnZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCByZWNvcmRJbmxpbmVJbWFnZSk7XG4gICAgfVxuICAgIGlmICh0YWdOYW1lID09PSBcImF1ZGlvXCIgfHwgdGFnTmFtZSA9PT0gXCJ2aWRlb1wiKSB7XG4gICAgICAgIHZhciBtZWRpYUF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICBtZWRpYUF0dHJpYnV0ZXMucnJfbWVkaWFTdGF0ZSA9IG4yLnBhdXNlZCA/IFwicGF1c2VkXCIgOiBcInBsYXllZFwiO1xuICAgICAgICBtZWRpYUF0dHJpYnV0ZXMucnJfbWVkaWFDdXJyZW50VGltZSA9IG4yLmN1cnJlbnRUaW1lO1xuICAgICAgICBtZWRpYUF0dHJpYnV0ZXMucnJfbWVkaWFQbGF5YmFja1JhdGUgPSBuMi5wbGF5YmFja1JhdGU7XG4gICAgICAgIG1lZGlhQXR0cmlidXRlcy5ycl9tZWRpYU11dGVkID0gbjIubXV0ZWQ7XG4gICAgICAgIG1lZGlhQXR0cmlidXRlcy5ycl9tZWRpYUxvb3AgPSBuMi5sb29wO1xuICAgICAgICBtZWRpYUF0dHJpYnV0ZXMucnJfbWVkaWFWb2x1bWUgPSBuMi52b2x1bWU7XG4gICAgfVxuICAgIGlmICghbmV3bHlBZGRlZEVsZW1lbnQpIHtcbiAgICAgICAgaWYgKG4yLnNjcm9sbExlZnQpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMucnJfc2Nyb2xsTGVmdCA9IG4yLnNjcm9sbExlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4yLnNjcm9sbFRvcCkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5ycl9zY3JvbGxUb3AgPSBuMi5zY3JvbGxUb3A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5lZWRCbG9jaykge1xuICAgICAgICB2YXIgX24yX2dldEJvdW5kaW5nQ2xpZW50UmVjdCA9IG4yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB3aWR0aCA9IF9uMl9nZXRCb3VuZGluZ0NsaWVudFJlY3Qud2lkdGgsIGhlaWdodCA9IF9uMl9nZXRCb3VuZGluZ0NsaWVudFJlY3QuaGVpZ2h0O1xuICAgICAgICBhdHRyaWJ1dGVzID0ge1xuICAgICAgICAgICAgY2xhc3M6IGF0dHJpYnV0ZXMuY2xhc3MsXG4gICAgICAgICAgICBycl93aWR0aDogXCJcIiArIHdpZHRoICsgXCJweFwiLFxuICAgICAgICAgICAgcnJfaGVpZ2h0OiBcIlwiICsgaGVpZ2h0ICsgXCJweFwiXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0YWdOYW1lID09PSBcImlmcmFtZVwiICYmICFrZWVwSWZyYW1lU3JjRm4oYXR0cmlidXRlcy5zcmMpKSB7XG4gICAgICAgIGlmICghbjIuY29udGVudERvY3VtZW50KSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnJyX3NyYyA9IGF0dHJpYnV0ZXMuc3JjO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzLnNyYztcbiAgICB9XG4gICAgdmFyIGlzQ3VzdG9tRWxlbWVudDtcbiAgICB0cnkge1xuICAgICAgICBpZiAoY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSBpc0N1c3RvbUVsZW1lbnQgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGUyKSB7fVxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IE5vZGVUeXBlJDMuRWxlbWVudCxcbiAgICAgICAgdGFnTmFtZTogdGFnTmFtZSxcbiAgICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICAgICAgY2hpbGROb2RlczogW10sXG4gICAgICAgIGlzU1ZHOiBpc1NWR0VsZW1lbnQobjIpIHx8IHZvaWQgMCxcbiAgICAgICAgbmVlZEJsb2NrOiBuZWVkQmxvY2ssXG4gICAgICAgIHJvb3RJZDogcm9vdElkLFxuICAgICAgICBpc0N1c3RvbTogaXNDdXN0b21FbGVtZW50XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGxvd2VySWZFeGlzdHMobWF5YmVBdHRyKSB7XG4gICAgaWYgKG1heWJlQXR0ciA9PT0gdm9pZCAwIHx8IG1heWJlQXR0ciA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWF5YmVBdHRyLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2xpbURPTUV4Y2x1ZGVkKHNuLCBzbGltRE9NT3B0aW9ucykge1xuICAgIGlmIChzbGltRE9NT3B0aW9ucy5jb21tZW50ICYmIHNuLnR5cGUgPT09IE5vZGVUeXBlJDMuQ29tbWVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHNuLnR5cGUgPT09IE5vZGVUeXBlJDMuRWxlbWVudCkge1xuICAgICAgICBpZiAoc2xpbURPTU9wdGlvbnMuc2NyaXB0ICYmIC8vIHNjcmlwdCB0YWdcbiAgICAgICAgKHNuLnRhZ05hbWUgPT09IFwic2NyaXB0XCIgfHwgLy8gKG1vZHVsZSlwcmVsb2FkIGxpbmtcbiAgICAgICAgc24udGFnTmFtZSA9PT0gXCJsaW5rXCIgJiYgKHNuLmF0dHJpYnV0ZXMucmVsID09PSBcInByZWxvYWRcIiAmJiBzbi5hdHRyaWJ1dGVzLmFzID09PSBcInNjcmlwdFwiIHx8IHNuLmF0dHJpYnV0ZXMucmVsID09PSBcIm1vZHVsZXByZWxvYWRcIikgfHwgLy8gcHJlZmV0Y2ggbGlua1xuICAgICAgICBzbi50YWdOYW1lID09PSBcImxpbmtcIiAmJiBzbi5hdHRyaWJ1dGVzLnJlbCA9PT0gXCJwcmVmZXRjaFwiICYmIHR5cGVvZiBzbi5hdHRyaWJ1dGVzLmhyZWYgPT09IFwic3RyaW5nXCIgJiYgZXh0cmFjdEZpbGVFeHRlbnNpb24oc24uYXR0cmlidXRlcy5ocmVmKSA9PT0gXCJqc1wiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZEZhdmljb24gJiYgKHNuLnRhZ05hbWUgPT09IFwibGlua1wiICYmIHNuLmF0dHJpYnV0ZXMucmVsID09PSBcInNob3J0Y3V0IGljb25cIiB8fCBzbi50YWdOYW1lID09PSBcIm1ldGFcIiAmJiAobG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpLm1hdGNoKC9ebXNhcHBsaWNhdGlvbi10aWxlKGltYWdlfGNvbG9yKSQvKSB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwiYXBwbGljYXRpb24tbmFtZVwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5yZWwpID09PSBcImljb25cIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMucmVsKSA9PT0gXCJhcHBsZS10b3VjaC1pY29uXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLnJlbCkgPT09IFwic2hvcnRjdXQgaWNvblwiKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHNuLnRhZ05hbWUgPT09IFwibWV0YVwiKSB7XG4gICAgICAgICAgICBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZE1ldGFEZXNjS2V5d29yZHMgJiYgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpLm1hdGNoKC9eZGVzY3JpcHRpb258a2V5d29yZHMkLykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZE1ldGFTb2NpYWwgJiYgKGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5wcm9wZXJ0eSkubWF0Y2goL14ob2d8dHdpdHRlcnxmYik6LykgfHwgLy8gb2cgPSBvcGVuZ3JhcGggKGZhY2Vib29rKVxuICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpLm1hdGNoKC9eKG9nfHR3aXR0ZXIpOi8pIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJwaW50ZXJlc3RcIikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZE1ldGFSb2JvdHMgJiYgKGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJyb2JvdHNcIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwiZ29vZ2xlYm90XCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcImJpbmdib3RcIikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZE1ldGFIdHRwRXF1aXYgJiYgc24uYXR0cmlidXRlc1tcImh0dHAtZXF1aXZcIl0gIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkTWV0YUF1dGhvcnNoaXAgJiYgKGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJhdXRob3JcIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwiZ2VuZXJhdG9yXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcImZyYW1ld29ya1wiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJwdWJsaXNoZXJcIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwicHJvZ2lkXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLnByb3BlcnR5KS5tYXRjaCgvXmFydGljbGU6LykgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLnByb3BlcnR5KS5tYXRjaCgvXnByb2R1Y3Q6LykpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRNZXRhVmVyaWZpY2F0aW9uICYmIChsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwiZ29vZ2xlLXNpdGUtdmVyaWZpY2F0aW9uXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcInlhbmRleC12ZXJpZmljYXRpb25cIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwiY3NyZi10b2tlblwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJwOmRvbWFpbl92ZXJpZnlcIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwidmVyaWZ5LXYxXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcInZlcmlmaWNhdGlvblwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJzaG9waWZ5LWNoZWNrb3V0LWFwaS10b2tlblwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZU5vZGVXaXRoSWQobjIsIG9wdGlvbnMpIHtcbiAgICB2YXIgZG9jID0gb3B0aW9ucy5kb2MsIG1pcnJvcjIgPSBvcHRpb25zLm1pcnJvciwgYmxvY2tDbGFzcyA9IG9wdGlvbnMuYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciA9IG9wdGlvbnMuYmxvY2tTZWxlY3RvciwgbWFza1RleHRDbGFzcyA9IG9wdGlvbnMubWFza1RleHRDbGFzcywgbWFza1RleHRTZWxlY3RvciA9IG9wdGlvbnMubWFza1RleHRTZWxlY3RvciwgX29wdGlvbnNfc2tpcENoaWxkID0gb3B0aW9ucy5za2lwQ2hpbGQsIHNraXBDaGlsZCA9IF9vcHRpb25zX3NraXBDaGlsZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9uc19za2lwQ2hpbGQsIF9vcHRpb25zX2lubGluZVN0eWxlc2hlZXQgPSBvcHRpb25zLmlubGluZVN0eWxlc2hlZXQsIGlubGluZVN0eWxlc2hlZXQgPSBfb3B0aW9uc19pbmxpbmVTdHlsZXNoZWV0ID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnNfaW5saW5lU3R5bGVzaGVldCwgX29wdGlvbnNfbWFza0lucHV0T3B0aW9ucyA9IG9wdGlvbnMubWFza0lucHV0T3B0aW9ucywgbWFza0lucHV0T3B0aW9ucyA9IF9vcHRpb25zX21hc2tJbnB1dE9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX29wdGlvbnNfbWFza0lucHV0T3B0aW9ucywgbWFza1RleHRGbiA9IG9wdGlvbnMubWFza1RleHRGbiwgbWFza0lucHV0Rm4gPSBvcHRpb25zLm1hc2tJbnB1dEZuLCBzbGltRE9NT3B0aW9ucyA9IG9wdGlvbnMuc2xpbURPTU9wdGlvbnMsIF9vcHRpb25zX2RhdGFVUkxPcHRpb25zID0gb3B0aW9ucy5kYXRhVVJMT3B0aW9ucywgZGF0YVVSTE9wdGlvbnMgPSBfb3B0aW9uc19kYXRhVVJMT3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfb3B0aW9uc19kYXRhVVJMT3B0aW9ucywgX29wdGlvbnNfaW5saW5lSW1hZ2VzID0gb3B0aW9ucy5pbmxpbmVJbWFnZXMsIGlubGluZUltYWdlcyA9IF9vcHRpb25zX2lubGluZUltYWdlcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9uc19pbmxpbmVJbWFnZXMsIF9vcHRpb25zX3JlY29yZENhbnZhcyA9IG9wdGlvbnMucmVjb3JkQ2FudmFzLCByZWNvcmRDYW52YXMgPSBfb3B0aW9uc19yZWNvcmRDYW52YXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnNfcmVjb3JkQ2FudmFzLCBvblNlcmlhbGl6ZSA9IG9wdGlvbnMub25TZXJpYWxpemUsIG9uSWZyYW1lTG9hZCA9IG9wdGlvbnMub25JZnJhbWVMb2FkLCBfb3B0aW9uc19pZnJhbWVMb2FkVGltZW91dCA9IG9wdGlvbnMuaWZyYW1lTG9hZFRpbWVvdXQsIGlmcmFtZUxvYWRUaW1lb3V0ID0gX29wdGlvbnNfaWZyYW1lTG9hZFRpbWVvdXQgPT09IHZvaWQgMCA/IDVlMyA6IF9vcHRpb25zX2lmcmFtZUxvYWRUaW1lb3V0LCBvblN0eWxlc2hlZXRMb2FkID0gb3B0aW9ucy5vblN0eWxlc2hlZXRMb2FkLCBfb3B0aW9uc19zdHlsZXNoZWV0TG9hZFRpbWVvdXQgPSBvcHRpb25zLnN0eWxlc2hlZXRMb2FkVGltZW91dCwgc3R5bGVzaGVldExvYWRUaW1lb3V0ID0gX29wdGlvbnNfc3R5bGVzaGVldExvYWRUaW1lb3V0ID09PSB2b2lkIDAgPyA1ZTMgOiBfb3B0aW9uc19zdHlsZXNoZWV0TG9hZFRpbWVvdXQsIF9vcHRpb25zX2tlZXBJZnJhbWVTcmNGbiA9IG9wdGlvbnMua2VlcElmcmFtZVNyY0ZuLCBrZWVwSWZyYW1lU3JjRm4gPSBfb3B0aW9uc19rZWVwSWZyYW1lU3JjRm4gPT09IHZvaWQgMCA/IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSA6IF9vcHRpb25zX2tlZXBJZnJhbWVTcmNGbiwgX29wdGlvbnNfbmV3bHlBZGRlZEVsZW1lbnQgPSBvcHRpb25zLm5ld2x5QWRkZWRFbGVtZW50LCBuZXdseUFkZGVkRWxlbWVudCA9IF9vcHRpb25zX25ld2x5QWRkZWRFbGVtZW50ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zX25ld2x5QWRkZWRFbGVtZW50LCBfb3B0aW9uc19jc3NDYXB0dXJlZCA9IG9wdGlvbnMuY3NzQ2FwdHVyZWQsIGNzc0NhcHR1cmVkID0gX29wdGlvbnNfY3NzQ2FwdHVyZWQgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnNfY3NzQ2FwdHVyZWQ7XG4gICAgdmFyIG5lZWRzTWFzayA9IG9wdGlvbnMubmVlZHNNYXNrO1xuICAgIHZhciBfb3B0aW9uc19wcmVzZXJ2ZVdoaXRlU3BhY2UgPSBvcHRpb25zLnByZXNlcnZlV2hpdGVTcGFjZSwgcHJlc2VydmVXaGl0ZVNwYWNlID0gX29wdGlvbnNfcHJlc2VydmVXaGl0ZVNwYWNlID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnNfcHJlc2VydmVXaGl0ZVNwYWNlO1xuICAgIGlmICghbmVlZHNNYXNrKSB7XG4gICAgICAgIHZhciBjaGVja0FuY2VzdG9ycyA9IG5lZWRzTWFzayA9PT0gdm9pZCAwO1xuICAgICAgICBuZWVkc01hc2sgPSBuZWVkTWFza2luZ1RleHQobjIsIG1hc2tUZXh0Q2xhc3MsIG1hc2tUZXh0U2VsZWN0b3IsIGNoZWNrQW5jZXN0b3JzKTtcbiAgICB9XG4gICAgdmFyIF9zZXJpYWxpemVkTm9kZSA9IHNlcmlhbGl6ZU5vZGUobjIsIHtcbiAgICAgICAgZG9jOiBkb2MsXG4gICAgICAgIG1pcnJvcjogbWlycm9yMixcbiAgICAgICAgYmxvY2tDbGFzczogYmxvY2tDbGFzcyxcbiAgICAgICAgYmxvY2tTZWxlY3RvcjogYmxvY2tTZWxlY3RvcixcbiAgICAgICAgbmVlZHNNYXNrOiBuZWVkc01hc2ssXG4gICAgICAgIGlubGluZVN0eWxlc2hlZXQ6IGlubGluZVN0eWxlc2hlZXQsXG4gICAgICAgIG1hc2tJbnB1dE9wdGlvbnM6IG1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICAgIG1hc2tUZXh0Rm46IG1hc2tUZXh0Rm4sXG4gICAgICAgIG1hc2tJbnB1dEZuOiBtYXNrSW5wdXRGbixcbiAgICAgICAgZGF0YVVSTE9wdGlvbnM6IGRhdGFVUkxPcHRpb25zLFxuICAgICAgICBpbmxpbmVJbWFnZXM6IGlubGluZUltYWdlcyxcbiAgICAgICAgcmVjb3JkQ2FudmFzOiByZWNvcmRDYW52YXMsXG4gICAgICAgIGtlZXBJZnJhbWVTcmNGbjoga2VlcElmcmFtZVNyY0ZuLFxuICAgICAgICBuZXdseUFkZGVkRWxlbWVudDogbmV3bHlBZGRlZEVsZW1lbnQsXG4gICAgICAgIGNzc0NhcHR1cmVkOiBjc3NDYXB0dXJlZFxuICAgIH0pO1xuICAgIGlmICghX3NlcmlhbGl6ZWROb2RlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihuMiwgXCJub3Qgc2VyaWFsaXplZFwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBpZDtcbiAgICBpZiAobWlycm9yMi5oYXNOb2RlKG4yKSkge1xuICAgICAgICBpZCA9IG1pcnJvcjIuZ2V0SWQobjIpO1xuICAgIH0gZWxzZSBpZiAoc2xpbURPTUV4Y2x1ZGVkKF9zZXJpYWxpemVkTm9kZSwgc2xpbURPTU9wdGlvbnMpIHx8ICFwcmVzZXJ2ZVdoaXRlU3BhY2UgJiYgX3NlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlJDMuVGV4dCAmJiAhX3NlcmlhbGl6ZWROb2RlLnRleHRDb250ZW50LnJlcGxhY2UoL15cXHMrfFxccyskL2dtLCBcIlwiKS5sZW5ndGgpIHtcbiAgICAgICAgaWQgPSBJR05PUkVEX05PREU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWQgPSBnZW5JZCgpO1xuICAgIH1cbiAgICB2YXIgc2VyaWFsaXplZE5vZGUgPSBPYmplY3QuYXNzaWduKF9zZXJpYWxpemVkTm9kZSwge1xuICAgICAgICBpZDogaWRcbiAgICB9KTtcbiAgICBtaXJyb3IyLmFkZChuMiwgc2VyaWFsaXplZE5vZGUpO1xuICAgIGlmIChpZCA9PT0gSUdOT1JFRF9OT0RFKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAob25TZXJpYWxpemUpIHtcbiAgICAgICAgb25TZXJpYWxpemUobjIpO1xuICAgIH1cbiAgICB2YXIgcmVjb3JkQ2hpbGQgPSAhc2tpcENoaWxkO1xuICAgIGlmIChzZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZSQzLkVsZW1lbnQpIHtcbiAgICAgICAgcmVjb3JkQ2hpbGQgPSByZWNvcmRDaGlsZCAmJiAhc2VyaWFsaXplZE5vZGUubmVlZEJsb2NrO1xuICAgICAgICBkZWxldGUgc2VyaWFsaXplZE5vZGUubmVlZEJsb2NrO1xuICAgICAgICB2YXIgc2hhZG93Um9vdEVsID0gaW5kZXgkMS5zaGFkb3dSb290KG4yKTtcbiAgICAgICAgaWYgKHNoYWRvd1Jvb3RFbCAmJiBpc05hdGl2ZVNoYWRvd0RvbShzaGFkb3dSb290RWwpKSBzZXJpYWxpemVkTm9kZS5pc1NoYWRvd0hvc3QgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoKHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlJDMuRG9jdW1lbnQgfHwgc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUkMy5FbGVtZW50KSAmJiByZWNvcmRDaGlsZCkge1xuICAgICAgICBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZFdoaXRlc3BhY2UgJiYgc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUkMy5FbGVtZW50ICYmIHNlcmlhbGl6ZWROb2RlLnRhZ05hbWUgPT09IFwiaGVhZFwiKSB7XG4gICAgICAgICAgICBwcmVzZXJ2ZVdoaXRlU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnlwYXNzT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGRvYzogZG9jLFxuICAgICAgICAgICAgbWlycm9yOiBtaXJyb3IyLFxuICAgICAgICAgICAgYmxvY2tDbGFzczogYmxvY2tDbGFzcyxcbiAgICAgICAgICAgIGJsb2NrU2VsZWN0b3I6IGJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgICBuZWVkc01hc2s6IG5lZWRzTWFzayxcbiAgICAgICAgICAgIG1hc2tUZXh0Q2xhc3M6IG1hc2tUZXh0Q2xhc3MsXG4gICAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yOiBtYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgICAgICAgc2tpcENoaWxkOiBza2lwQ2hpbGQsXG4gICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0OiBpbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgICAgICAgbWFza0lucHV0T3B0aW9uczogbWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgICAgIG1hc2tUZXh0Rm46IG1hc2tUZXh0Rm4sXG4gICAgICAgICAgICBtYXNrSW5wdXRGbjogbWFza0lucHV0Rm4sXG4gICAgICAgICAgICBzbGltRE9NT3B0aW9uczogc2xpbURPTU9wdGlvbnMsXG4gICAgICAgICAgICBkYXRhVVJMT3B0aW9uczogZGF0YVVSTE9wdGlvbnMsXG4gICAgICAgICAgICBpbmxpbmVJbWFnZXM6IGlubGluZUltYWdlcyxcbiAgICAgICAgICAgIHJlY29yZENhbnZhczogcmVjb3JkQ2FudmFzLFxuICAgICAgICAgICAgcHJlc2VydmVXaGl0ZVNwYWNlOiBwcmVzZXJ2ZVdoaXRlU3BhY2UsXG4gICAgICAgICAgICBvblNlcmlhbGl6ZTogb25TZXJpYWxpemUsXG4gICAgICAgICAgICBvbklmcmFtZUxvYWQ6IG9uSWZyYW1lTG9hZCxcbiAgICAgICAgICAgIGlmcmFtZUxvYWRUaW1lb3V0OiBpZnJhbWVMb2FkVGltZW91dCxcbiAgICAgICAgICAgIG9uU3R5bGVzaGVldExvYWQ6IG9uU3R5bGVzaGVldExvYWQsXG4gICAgICAgICAgICBzdHlsZXNoZWV0TG9hZFRpbWVvdXQ6IHN0eWxlc2hlZXRMb2FkVGltZW91dCxcbiAgICAgICAgICAgIGtlZXBJZnJhbWVTcmNGbjoga2VlcElmcmFtZVNyY0ZuLFxuICAgICAgICAgICAgY3NzQ2FwdHVyZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChzZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZSQzLkVsZW1lbnQgJiYgc2VyaWFsaXplZE5vZGUudGFnTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICYmIHNlcmlhbGl6ZWROb2RlLmF0dHJpYnV0ZXMudmFsdWUgIT09IHZvaWQgMCkgO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZSQzLkVsZW1lbnQgJiYgc2VyaWFsaXplZE5vZGUuYXR0cmlidXRlcy5fY3NzVGV4dCAhPT0gdm9pZCAwICYmIHR5cGVvZiBzZXJpYWxpemVkTm9kZS5hdHRyaWJ1dGVzLl9jc3NUZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgYnlwYXNzT3B0aW9ucy5jc3NDYXB0dXJlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShBcnJheS5mcm9tKGluZGV4JDEuY2hpbGROb2RlcyhuMikpKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZE4gPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgc2VyaWFsaXplZENoaWxkTm9kZSA9IHNlcmlhbGl6ZU5vZGVXaXRoSWQoY2hpbGROLCBieXBhc3NPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VyaWFsaXplZENoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkTm9kZS5jaGlsZE5vZGVzLnB1c2goc2VyaWFsaXplZENoaWxkTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzaGFkb3dSb290RWwxID0gbnVsbDtcbiAgICAgICAgaWYgKGlzRWxlbWVudChuMikgJiYgKHNoYWRvd1Jvb3RFbDEgPSBpbmRleCQxLnNoYWRvd1Jvb3QobjIpKSkge1xuICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IxID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKEFycmF5LmZyb20oaW5kZXgkMS5jaGlsZE5vZGVzKHNoYWRvd1Jvb3RFbDEpKSksIF9zdGVwMTsgIShfc3RlcDEgPSBfaXRlcmF0b3IxKCkpLmRvbmU7KXtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGROMSA9IF9zdGVwMS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgc2VyaWFsaXplZENoaWxkTm9kZTEgPSBzZXJpYWxpemVOb2RlV2l0aElkKGNoaWxkTjEsIGJ5cGFzc09wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChzZXJpYWxpemVkQ2hpbGROb2RlMSkge1xuICAgICAgICAgICAgICAgICAgICBpc05hdGl2ZVNoYWRvd0RvbShzaGFkb3dSb290RWwxKSAmJiAoc2VyaWFsaXplZENoaWxkTm9kZTEuaXNTaGFkb3cgPSB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplZE5vZGUuY2hpbGROb2Rlcy5wdXNoKHNlcmlhbGl6ZWRDaGlsZE5vZGUxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHBhcmVudCA9IGluZGV4JDEucGFyZW50Tm9kZShuMik7XG4gICAgaWYgKHBhcmVudCAmJiBpc1NoYWRvd1Jvb3QocGFyZW50KSAmJiBpc05hdGl2ZVNoYWRvd0RvbShwYXJlbnQpKSB7XG4gICAgICAgIHNlcmlhbGl6ZWROb2RlLmlzU2hhZG93ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlJDMuRWxlbWVudCAmJiBzZXJpYWxpemVkTm9kZS50YWdOYW1lID09PSBcImlmcmFtZVwiKSB7XG4gICAgICAgIG9uY2VJZnJhbWVMb2FkZWQobjIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlmcmFtZURvYyA9IG4yLmNvbnRlbnREb2N1bWVudDtcbiAgICAgICAgICAgIGlmIChpZnJhbWVEb2MgJiYgb25JZnJhbWVMb2FkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZWRJZnJhbWVOb2RlID0gc2VyaWFsaXplTm9kZVdpdGhJZChpZnJhbWVEb2MsIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jOiBpZnJhbWVEb2MsXG4gICAgICAgICAgICAgICAgICAgIG1pcnJvcjogbWlycm9yMixcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tDbGFzczogYmxvY2tDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tTZWxlY3RvcjogYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICAgICAgICAgICAgbmVlZHNNYXNrOiBuZWVkc01hc2ssXG4gICAgICAgICAgICAgICAgICAgIG1hc2tUZXh0Q2xhc3M6IG1hc2tUZXh0Q2xhc3MsXG4gICAgICAgICAgICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3I6IG1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgICAgIHNraXBDaGlsZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQ6IGlubGluZVN0eWxlc2hlZXQsXG4gICAgICAgICAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnM6IG1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIG1hc2tUZXh0Rm46IG1hc2tUZXh0Rm4sXG4gICAgICAgICAgICAgICAgICAgIG1hc2tJbnB1dEZuOiBtYXNrSW5wdXRGbixcbiAgICAgICAgICAgICAgICAgICAgc2xpbURPTU9wdGlvbnM6IHNsaW1ET01PcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBkYXRhVVJMT3B0aW9uczogZGF0YVVSTE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGlubGluZUltYWdlczogaW5saW5lSW1hZ2VzLFxuICAgICAgICAgICAgICAgICAgICByZWNvcmRDYW52YXM6IHJlY29yZENhbnZhcyxcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VydmVXaGl0ZVNwYWNlOiBwcmVzZXJ2ZVdoaXRlU3BhY2UsXG4gICAgICAgICAgICAgICAgICAgIG9uU2VyaWFsaXplOiBvblNlcmlhbGl6ZSxcbiAgICAgICAgICAgICAgICAgICAgb25JZnJhbWVMb2FkOiBvbklmcmFtZUxvYWQsXG4gICAgICAgICAgICAgICAgICAgIGlmcmFtZUxvYWRUaW1lb3V0OiBpZnJhbWVMb2FkVGltZW91dCxcbiAgICAgICAgICAgICAgICAgICAgb25TdHlsZXNoZWV0TG9hZDogb25TdHlsZXNoZWV0TG9hZCxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzaGVldExvYWRUaW1lb3V0OiBzdHlsZXNoZWV0TG9hZFRpbWVvdXQsXG4gICAgICAgICAgICAgICAgICAgIGtlZXBJZnJhbWVTcmNGbjoga2VlcElmcmFtZVNyY0ZuXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZWRJZnJhbWVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uSWZyYW1lTG9hZChuMiwgc2VyaWFsaXplZElmcmFtZU5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaWZyYW1lTG9hZFRpbWVvdXQpO1xuICAgIH1cbiAgICBpZiAoc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUkMy5FbGVtZW50ICYmIHNlcmlhbGl6ZWROb2RlLnRhZ05hbWUgPT09IFwibGlua1wiICYmIHR5cGVvZiBzZXJpYWxpemVkTm9kZS5hdHRyaWJ1dGVzLnJlbCA9PT0gXCJzdHJpbmdcIiAmJiAoc2VyaWFsaXplZE5vZGUuYXR0cmlidXRlcy5yZWwgPT09IFwic3R5bGVzaGVldFwiIHx8IHNlcmlhbGl6ZWROb2RlLmF0dHJpYnV0ZXMucmVsID09PSBcInByZWxvYWRcIiAmJiB0eXBlb2Ygc2VyaWFsaXplZE5vZGUuYXR0cmlidXRlcy5ocmVmID09PSBcInN0cmluZ1wiICYmIGV4dHJhY3RGaWxlRXh0ZW5zaW9uKHNlcmlhbGl6ZWROb2RlLmF0dHJpYnV0ZXMuaHJlZikgPT09IFwiY3NzXCIpKSB7XG4gICAgICAgIG9uY2VTdHlsZXNoZWV0TG9hZGVkKG4yLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChvblN0eWxlc2hlZXRMb2FkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZWRMaW5rTm9kZSA9IHNlcmlhbGl6ZU5vZGVXaXRoSWQobjIsIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jOiBkb2MsXG4gICAgICAgICAgICAgICAgICAgIG1pcnJvcjogbWlycm9yMixcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tDbGFzczogYmxvY2tDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tTZWxlY3RvcjogYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICAgICAgICAgICAgbmVlZHNNYXNrOiBuZWVkc01hc2ssXG4gICAgICAgICAgICAgICAgICAgIG1hc2tUZXh0Q2xhc3M6IG1hc2tUZXh0Q2xhc3MsXG4gICAgICAgICAgICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3I6IG1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgICAgIHNraXBDaGlsZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQ6IGlubGluZVN0eWxlc2hlZXQsXG4gICAgICAgICAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnM6IG1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIG1hc2tUZXh0Rm46IG1hc2tUZXh0Rm4sXG4gICAgICAgICAgICAgICAgICAgIG1hc2tJbnB1dEZuOiBtYXNrSW5wdXRGbixcbiAgICAgICAgICAgICAgICAgICAgc2xpbURPTU9wdGlvbnM6IHNsaW1ET01PcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBkYXRhVVJMT3B0aW9uczogZGF0YVVSTE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGlubGluZUltYWdlczogaW5saW5lSW1hZ2VzLFxuICAgICAgICAgICAgICAgICAgICByZWNvcmRDYW52YXM6IHJlY29yZENhbnZhcyxcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VydmVXaGl0ZVNwYWNlOiBwcmVzZXJ2ZVdoaXRlU3BhY2UsXG4gICAgICAgICAgICAgICAgICAgIG9uU2VyaWFsaXplOiBvblNlcmlhbGl6ZSxcbiAgICAgICAgICAgICAgICAgICAgb25JZnJhbWVMb2FkOiBvbklmcmFtZUxvYWQsXG4gICAgICAgICAgICAgICAgICAgIGlmcmFtZUxvYWRUaW1lb3V0OiBpZnJhbWVMb2FkVGltZW91dCxcbiAgICAgICAgICAgICAgICAgICAgb25TdHlsZXNoZWV0TG9hZDogb25TdHlsZXNoZWV0TG9hZCxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzaGVldExvYWRUaW1lb3V0OiBzdHlsZXNoZWV0TG9hZFRpbWVvdXQsXG4gICAgICAgICAgICAgICAgICAgIGtlZXBJZnJhbWVTcmNGbjoga2VlcElmcmFtZVNyY0ZuXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZWRMaW5rTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBvblN0eWxlc2hlZXRMb2FkKG4yLCBzZXJpYWxpemVkTGlua05vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc3R5bGVzaGVldExvYWRUaW1lb3V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWROb2RlO1xufVxuZnVuY3Rpb24gc25hcHNob3QobjIsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3JlZiA9IG9wdGlvbnMgfHwge30sIHRtcCA9IF9yZWYubWlycm9yLCBtaXJyb3IyID0gdG1wID09PSB2b2lkIDAgPyBuZXcgTWlycm9yKCkgOiB0bXAsIF9yZWZfYmxvY2tDbGFzcyA9IF9yZWYuYmxvY2tDbGFzcywgYmxvY2tDbGFzcyA9IF9yZWZfYmxvY2tDbGFzcyA9PT0gdm9pZCAwID8gXCJyci1ibG9ja1wiIDogX3JlZl9ibG9ja0NsYXNzLCBfcmVmX2Jsb2NrU2VsZWN0b3IgPSBfcmVmLmJsb2NrU2VsZWN0b3IsIGJsb2NrU2VsZWN0b3IgPSBfcmVmX2Jsb2NrU2VsZWN0b3IgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmX2Jsb2NrU2VsZWN0b3IsIF9yZWZfbWFza1RleHRDbGFzcyA9IF9yZWYubWFza1RleHRDbGFzcywgbWFza1RleHRDbGFzcyA9IF9yZWZfbWFza1RleHRDbGFzcyA9PT0gdm9pZCAwID8gXCJyci1tYXNrXCIgOiBfcmVmX21hc2tUZXh0Q2xhc3MsIF9yZWZfbWFza1RleHRTZWxlY3RvciA9IF9yZWYubWFza1RleHRTZWxlY3RvciwgbWFza1RleHRTZWxlY3RvciA9IF9yZWZfbWFza1RleHRTZWxlY3RvciA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWZfbWFza1RleHRTZWxlY3RvciwgX3JlZl9pbmxpbmVTdHlsZXNoZWV0ID0gX3JlZi5pbmxpbmVTdHlsZXNoZWV0LCBpbmxpbmVTdHlsZXNoZWV0ID0gX3JlZl9pbmxpbmVTdHlsZXNoZWV0ID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZl9pbmxpbmVTdHlsZXNoZWV0LCBfcmVmX2lubGluZUltYWdlcyA9IF9yZWYuaW5saW5lSW1hZ2VzLCBpbmxpbmVJbWFnZXMgPSBfcmVmX2lubGluZUltYWdlcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmX2lubGluZUltYWdlcywgX3JlZl9yZWNvcmRDYW52YXMgPSBfcmVmLnJlY29yZENhbnZhcywgcmVjb3JkQ2FudmFzID0gX3JlZl9yZWNvcmRDYW52YXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZl9yZWNvcmRDYW52YXMsIF9yZWZfbWFza0FsbElucHV0cyA9IF9yZWYubWFza0FsbElucHV0cywgbWFza0FsbElucHV0cyA9IF9yZWZfbWFza0FsbElucHV0cyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmX21hc2tBbGxJbnB1dHMsIG1hc2tUZXh0Rm4gPSBfcmVmLm1hc2tUZXh0Rm4sIG1hc2tJbnB1dEZuID0gX3JlZi5tYXNrSW5wdXRGbiwgX3JlZl9zbGltRE9NID0gX3JlZi5zbGltRE9NLCBzbGltRE9NID0gX3JlZl9zbGltRE9NID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWZfc2xpbURPTSwgZGF0YVVSTE9wdGlvbnMgPSBfcmVmLmRhdGFVUkxPcHRpb25zLCBwcmVzZXJ2ZVdoaXRlU3BhY2UgPSBfcmVmLnByZXNlcnZlV2hpdGVTcGFjZSwgb25TZXJpYWxpemUgPSBfcmVmLm9uU2VyaWFsaXplLCBvbklmcmFtZUxvYWQgPSBfcmVmLm9uSWZyYW1lTG9hZCwgaWZyYW1lTG9hZFRpbWVvdXQgPSBfcmVmLmlmcmFtZUxvYWRUaW1lb3V0LCBvblN0eWxlc2hlZXRMb2FkID0gX3JlZi5vblN0eWxlc2hlZXRMb2FkLCBzdHlsZXNoZWV0TG9hZFRpbWVvdXQgPSBfcmVmLnN0eWxlc2hlZXRMb2FkVGltZW91dCwgX3JlZl9rZWVwSWZyYW1lU3JjRm4gPSBfcmVmLmtlZXBJZnJhbWVTcmNGbiwga2VlcElmcmFtZVNyY0ZuID0gX3JlZl9rZWVwSWZyYW1lU3JjRm4gPT09IHZvaWQgMCA/IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSA6IF9yZWZfa2VlcElmcmFtZVNyY0ZuO1xuICAgIHZhciBtYXNrSW5wdXRPcHRpb25zID0gbWFza0FsbElucHV0cyA9PT0gdHJ1ZSA/IHtcbiAgICAgICAgY29sb3I6IHRydWUsXG4gICAgICAgIGRhdGU6IHRydWUsXG4gICAgICAgIFwiZGF0ZXRpbWUtbG9jYWxcIjogdHJ1ZSxcbiAgICAgICAgZW1haWw6IHRydWUsXG4gICAgICAgIG1vbnRoOiB0cnVlLFxuICAgICAgICBudW1iZXI6IHRydWUsXG4gICAgICAgIHJhbmdlOiB0cnVlLFxuICAgICAgICBzZWFyY2g6IHRydWUsXG4gICAgICAgIHRlbDogdHJ1ZSxcbiAgICAgICAgdGV4dDogdHJ1ZSxcbiAgICAgICAgdGltZTogdHJ1ZSxcbiAgICAgICAgdXJsOiB0cnVlLFxuICAgICAgICB3ZWVrOiB0cnVlLFxuICAgICAgICB0ZXh0YXJlYTogdHJ1ZSxcbiAgICAgICAgc2VsZWN0OiB0cnVlLFxuICAgICAgICBwYXNzd29yZDogdHJ1ZSxcbiAgICAgICAgaGlkZGVuOiB0cnVlXG4gICAgfSA6IG1hc2tBbGxJbnB1dHMgPT09IGZhbHNlID8ge1xuICAgICAgICBwYXNzd29yZDogdHJ1ZVxuICAgIH0gOiBtYXNrQWxsSW5wdXRzO1xuICAgIHZhciBzbGltRE9NT3B0aW9ucyA9IHNsaW1ET00gPT09IHRydWUgfHwgc2xpbURPTSA9PT0gXCJhbGxcIiA/IC8vIGlmIHRydWU6IHNldCBvZiBzZW5zaWJsZSBvcHRpb25zIHRoYXQgc2hvdWxkIG5vdCB0aHJvdyBhd2F5IGFueSBpbmZvcm1hdGlvblxuICAgIHtcbiAgICAgICAgc2NyaXB0OiB0cnVlLFxuICAgICAgICBjb21tZW50OiB0cnVlLFxuICAgICAgICBoZWFkRmF2aWNvbjogdHJ1ZSxcbiAgICAgICAgaGVhZFdoaXRlc3BhY2U6IHRydWUsXG4gICAgICAgIGhlYWRNZXRhRGVzY0tleXdvcmRzOiBzbGltRE9NID09PSBcImFsbFwiLFxuICAgICAgICAvLyBkZXN0cnVjdGl2ZVxuICAgICAgICBoZWFkTWV0YVNvY2lhbDogdHJ1ZSxcbiAgICAgICAgaGVhZE1ldGFSb2JvdHM6IHRydWUsXG4gICAgICAgIGhlYWRNZXRhSHR0cEVxdWl2OiB0cnVlLFxuICAgICAgICBoZWFkTWV0YUF1dGhvcnNoaXA6IHRydWUsXG4gICAgICAgIGhlYWRNZXRhVmVyaWZpY2F0aW9uOiB0cnVlXG4gICAgfSA6IHNsaW1ET00gPT09IGZhbHNlID8ge30gOiBzbGltRE9NO1xuICAgIHJldHVybiBzZXJpYWxpemVOb2RlV2l0aElkKG4yLCB7XG4gICAgICAgIGRvYzogbjIsXG4gICAgICAgIG1pcnJvcjogbWlycm9yMixcbiAgICAgICAgYmxvY2tDbGFzczogYmxvY2tDbGFzcyxcbiAgICAgICAgYmxvY2tTZWxlY3RvcjogYmxvY2tTZWxlY3RvcixcbiAgICAgICAgbWFza1RleHRDbGFzczogbWFza1RleHRDbGFzcyxcbiAgICAgICAgbWFza1RleHRTZWxlY3RvcjogbWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgc2tpcENoaWxkOiBmYWxzZSxcbiAgICAgICAgaW5saW5lU3R5bGVzaGVldDogaW5saW5lU3R5bGVzaGVldCxcbiAgICAgICAgbWFza0lucHV0T3B0aW9uczogbWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgbWFza1RleHRGbjogbWFza1RleHRGbixcbiAgICAgICAgbWFza0lucHV0Rm46IG1hc2tJbnB1dEZuLFxuICAgICAgICBzbGltRE9NT3B0aW9uczogc2xpbURPTU9wdGlvbnMsXG4gICAgICAgIGRhdGFVUkxPcHRpb25zOiBkYXRhVVJMT3B0aW9ucyxcbiAgICAgICAgaW5saW5lSW1hZ2VzOiBpbmxpbmVJbWFnZXMsXG4gICAgICAgIHJlY29yZENhbnZhczogcmVjb3JkQ2FudmFzLFxuICAgICAgICBwcmVzZXJ2ZVdoaXRlU3BhY2U6IHByZXNlcnZlV2hpdGVTcGFjZSxcbiAgICAgICAgb25TZXJpYWxpemU6IG9uU2VyaWFsaXplLFxuICAgICAgICBvbklmcmFtZUxvYWQ6IG9uSWZyYW1lTG9hZCxcbiAgICAgICAgaWZyYW1lTG9hZFRpbWVvdXQ6IGlmcmFtZUxvYWRUaW1lb3V0LFxuICAgICAgICBvblN0eWxlc2hlZXRMb2FkOiBvblN0eWxlc2hlZXRMb2FkLFxuICAgICAgICBzdHlsZXNoZWV0TG9hZFRpbWVvdXQ6IHN0eWxlc2hlZXRMb2FkVGltZW91dCxcbiAgICAgICAga2VlcElmcmFtZVNyY0ZuOiBrZWVwSWZyYW1lU3JjRm4sXG4gICAgICAgIG5ld2x5QWRkZWRFbGVtZW50OiBmYWxzZVxuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMkMSh4Mikge1xuICAgIHJldHVybiB4MiAmJiB4Mi5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4MiwgXCJkZWZhdWx0XCIpID8geDJbXCJkZWZhdWx0XCJdIDogeDI7XG59XG5mdW5jdGlvbiBnZXRBdWdtZW50ZWROYW1lc3BhY2UkMShuMikge1xuICAgIGlmIChuMi5fX2VzTW9kdWxlKSByZXR1cm4gbjI7XG4gICAgdmFyIGYyID0gbjIuZGVmYXVsdDtcbiAgICBpZiAodHlwZW9mIGYyID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB2YXIgYTIgPSBmdW5jdGlvbiBhMjIoKSB7XG4gICAgICAgICAgICBpZiAoX2luc3RhbmNlb2YodGhpcywgYTIyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmNvbnN0cnVjdChmMiwgYXJndW1lbnRzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgICBhMi5wcm90b3R5cGUgPSBmMi5wcm90b3R5cGU7XG4gICAgfSBlbHNlIGEyID0ge307XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEyLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5rZXlzKG4yKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4yLCBrKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEyLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG4yW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gYTI7XG59XG52YXIgcGljb2NvbG9yc19icm93c2VyJDEgPSB7XG4gICAgZXhwb3J0czoge31cbn07XG52YXIgeCQxID0gU3RyaW5nO1xudmFyIGNyZWF0ZSQxID0gZnVuY3Rpb24gY3JlYXRlJDEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNDb2xvclN1cHBvcnRlZDogZmFsc2UsXG4gICAgICAgIHJlc2V0OiB4JDEsXG4gICAgICAgIGJvbGQ6IHgkMSxcbiAgICAgICAgZGltOiB4JDEsXG4gICAgICAgIGl0YWxpYzogeCQxLFxuICAgICAgICB1bmRlcmxpbmU6IHgkMSxcbiAgICAgICAgaW52ZXJzZTogeCQxLFxuICAgICAgICBoaWRkZW46IHgkMSxcbiAgICAgICAgc3RyaWtldGhyb3VnaDogeCQxLFxuICAgICAgICBibGFjazogeCQxLFxuICAgICAgICByZWQ6IHgkMSxcbiAgICAgICAgZ3JlZW46IHgkMSxcbiAgICAgICAgeWVsbG93OiB4JDEsXG4gICAgICAgIGJsdWU6IHgkMSxcbiAgICAgICAgbWFnZW50YTogeCQxLFxuICAgICAgICBjeWFuOiB4JDEsXG4gICAgICAgIHdoaXRlOiB4JDEsXG4gICAgICAgIGdyYXk6IHgkMSxcbiAgICAgICAgYmdCbGFjazogeCQxLFxuICAgICAgICBiZ1JlZDogeCQxLFxuICAgICAgICBiZ0dyZWVuOiB4JDEsXG4gICAgICAgIGJnWWVsbG93OiB4JDEsXG4gICAgICAgIGJnQmx1ZTogeCQxLFxuICAgICAgICBiZ01hZ2VudGE6IHgkMSxcbiAgICAgICAgYmdDeWFuOiB4JDEsXG4gICAgICAgIGJnV2hpdGU6IHgkMVxuICAgIH07XG59O1xucGljb2NvbG9yc19icm93c2VyJDEuZXhwb3J0cyA9IGNyZWF0ZSQxKCk7XG5waWNvY29sb3JzX2Jyb3dzZXIkMS5leHBvcnRzLmNyZWF0ZUNvbG9ycyA9IGNyZWF0ZSQxO1xudmFyIHBpY29jb2xvcnNfYnJvd3NlckV4cG9ydHMkMSA9IHBpY29jb2xvcnNfYnJvd3NlciQxLmV4cG9ydHM7XG52YXIgX192aXRlQnJvd3NlckV4dGVybmFsJDIgPSB7fTtcbnZhciBfX3ZpdGVCcm93c2VyRXh0ZXJuYWwkMSQxID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGRlZmF1bHQ6IF9fdml0ZUJyb3dzZXJFeHRlcm5hbCQyXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICB2YWx1ZTogXCJNb2R1bGVcIlxufSkpO1xudmFyIHJlcXVpcmUkJDIkMSA9IC8qIEBfX1BVUkVfXyAqLyBnZXRBdWdtZW50ZWROYW1lc3BhY2UkMShfX3ZpdGVCcm93c2VyRXh0ZXJuYWwkMSQxKTtcbnZhciBwaWNvJDEgPSBwaWNvY29sb3JzX2Jyb3dzZXJFeHBvcnRzJDE7XG52YXIgdGVybWluYWxIaWdobGlnaHQkMSQxID0gcmVxdWlyZSQkMiQxO1xudmFyIENzc1N5bnRheEVycm9yJDMkMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oRXJyb3IxKSB7XG4gICAgX2luaGVyaXRzKENzc1N5bnRheEVycm9yLCBFcnJvcjEpO1xuICAgIGZ1bmN0aW9uIENzc1N5bnRheEVycm9yKG1lc3NhZ2UsIGxpbmUsIGNvbHVtbiwgc291cmNlLCBmaWxlLCBwbHVnaW4yMikge1xuICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgIF90aGlzID0gRXJyb3IxLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9IFwiQ3NzU3ludGF4RXJyb3JcIjtcbiAgICAgICAgX3RoaXMucmVhc29uID0gbWVzc2FnZTtcbiAgICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgICAgIF90aGlzLmZpbGUgPSBmaWxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIF90aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGx1Z2luMjIpIHtcbiAgICAgICAgICAgIF90aGlzLnBsdWdpbiA9IHBsdWdpbjIyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbGluZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY29sdW1uICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxpbmUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5saW5lID0gbGluZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLmxpbmUgPSBsaW5lLmxpbmU7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29sdW1uID0gbGluZS5jb2x1bW47XG4gICAgICAgICAgICAgICAgX3RoaXMuZW5kTGluZSA9IGNvbHVtbi5saW5lO1xuICAgICAgICAgICAgICAgIF90aGlzLmVuZENvbHVtbiA9IGNvbHVtbi5jb2x1bW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuc2V0TWVzc2FnZSgpO1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKF90aGlzLCBDc3NTeW50YXhFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gQ3NzU3ludGF4RXJyb3IucHJvdG90eXBlO1xuICAgIF9wcm90by5zZXRNZXNzYWdlID0gZnVuY3Rpb24gc2V0TWVzc2FnZSgpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdGhpcy5wbHVnaW4gPyB0aGlzLnBsdWdpbiArIFwiOiBcIiA6IFwiXCI7XG4gICAgICAgIHRoaXMubWVzc2FnZSArPSB0aGlzLmZpbGUgPyB0aGlzLmZpbGUgOiBcIjxjc3MgaW5wdXQ+XCI7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5saW5lICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgKz0gXCI6XCIgKyB0aGlzLmxpbmUgKyBcIjpcIiArIHRoaXMuY29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVzc2FnZSArPSBcIjogXCIgKyB0aGlzLnJlYXNvbjtcbiAgICB9O1xuICAgIF9wcm90by5zaG93U291cmNlQ29kZSA9IGZ1bmN0aW9uIHNob3dTb3VyY2VDb2RlKGNvbG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5zb3VyY2UpIHJldHVybiBcIlwiO1xuICAgICAgICB2YXIgY3NzID0gdGhpcy5zb3VyY2U7XG4gICAgICAgIGlmIChjb2xvciA9PSBudWxsKSBjb2xvciA9IHBpY28kMS5pc0NvbG9yU3VwcG9ydGVkO1xuICAgICAgICBpZiAodGVybWluYWxIaWdobGlnaHQkMSQxKSB7XG4gICAgICAgICAgICBpZiAoY29sb3IpIGNzcyA9IHRlcm1pbmFsSGlnaGxpZ2h0JDEkMShjc3MpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaW5lcyA9IGNzcy5zcGxpdCgvXFxyP1xcbi8pO1xuICAgICAgICB2YXIgc3RhcnQgPSBNYXRoLm1heCh0aGlzLmxpbmUgLSAzLCAwKTtcbiAgICAgICAgdmFyIGVuZCA9IE1hdGgubWluKHRoaXMubGluZSArIDIsIGxpbmVzLmxlbmd0aCk7XG4gICAgICAgIHZhciBtYXhXaWR0aCA9IFN0cmluZyhlbmQpLmxlbmd0aDtcbiAgICAgICAgdmFyIG1hcmssIGFzaWRlO1xuICAgICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgIHZhciBfcGljbyQxX2NyZWF0ZUNvbG9ycyA9IHBpY28kMS5jcmVhdGVDb2xvcnModHJ1ZSksIGJvbGQgPSBfcGljbyQxX2NyZWF0ZUNvbG9ycy5ib2xkLCBncmF5ID0gX3BpY28kMV9jcmVhdGVDb2xvcnMuZ3JheSwgcmVkID0gX3BpY28kMV9jcmVhdGVDb2xvcnMucmVkO1xuICAgICAgICAgICAgbWFyayA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYm9sZChyZWQodGV4dCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFzaWRlID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBncmF5KHRleHQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hcmsgPSBhc2lkZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lcy5zbGljZShzdGFydCwgZW5kKS5tYXAoZnVuY3Rpb24obGluZSwgaW5kZXgyKSB7XG4gICAgICAgICAgICB2YXIgbnVtYmVyID0gc3RhcnQgKyAxICsgaW5kZXgyO1xuICAgICAgICAgICAgdmFyIGd1dHRlciA9IFwiIFwiICsgKFwiIFwiICsgbnVtYmVyKS5zbGljZSgtbWF4V2lkdGgpICsgXCIgfCBcIjtcbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09IF90aGlzLmxpbmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3BhY2luZyA9IGFzaWRlKGd1dHRlci5yZXBsYWNlKC9cXGQvZywgXCIgXCIpKSArIGxpbmUuc2xpY2UoMCwgX3RoaXMuY29sdW1uIC0gMSkucmVwbGFjZSgvW15cXHRdL2csIFwiIFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFyayhcIj5cIikgKyBhc2lkZShndXR0ZXIpICsgbGluZSArIFwiXFxuIFwiICsgc3BhY2luZyArIG1hcmsoXCJeXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwiIFwiICsgYXNpZGUoZ3V0dGVyKSArIGxpbmU7XG4gICAgICAgIH0pLmpvaW4oXCJcXG5cIik7XG4gICAgfTtcbiAgICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgdmFyIGNvZGUgPSB0aGlzLnNob3dTb3VyY2VDb2RlKCk7XG4gICAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgICAgICBjb2RlID0gXCJcXG5cXG5cIiArIGNvZGUgKyBcIlxcblwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2UgKyBjb2RlO1xuICAgIH07XG4gICAgcmV0dXJuIENzc1N5bnRheEVycm9yO1xufShfd3JhcF9uYXRpdmVfc3VwZXIoRXJyb3IpKTtcbnZhciBjc3NTeW50YXhFcnJvciQxID0gQ3NzU3ludGF4RXJyb3IkMyQxO1xuQ3NzU3ludGF4RXJyb3IkMyQxLmRlZmF1bHQgPSBDc3NTeW50YXhFcnJvciQzJDE7XG52YXIgc3ltYm9scyQxID0ge307XG5zeW1ib2xzJDEuaXNDbGVhbiA9IFN5bWJvbChcImlzQ2xlYW5cIik7XG5zeW1ib2xzJDEubXkgPSBTeW1ib2woXCJteVwiKTtcbnZhciBERUZBVUxUX1JBVyQxID0ge1xuICAgIGFmdGVyOiBcIlxcblwiLFxuICAgIGJlZm9yZUNsb3NlOiBcIlxcblwiLFxuICAgIGJlZm9yZUNvbW1lbnQ6IFwiXFxuXCIsXG4gICAgYmVmb3JlRGVjbDogXCJcXG5cIixcbiAgICBiZWZvcmVPcGVuOiBcIiBcIixcbiAgICBiZWZvcmVSdWxlOiBcIlxcblwiLFxuICAgIGNvbG9uOiBcIjogXCIsXG4gICAgY29tbWVudExlZnQ6IFwiIFwiLFxuICAgIGNvbW1lbnRSaWdodDogXCIgXCIsXG4gICAgZW1wdHlCb2R5OiBcIlwiLFxuICAgIGluZGVudDogXCIgICAgXCIsXG4gICAgc2VtaWNvbG9uOiBmYWxzZVxufTtcbmZ1bmN0aW9uIGNhcGl0YWxpemUkMShzdHIpIHtcbiAgICByZXR1cm4gc3RyWzBdLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59XG52YXIgU3RyaW5naWZpZXIkMiQxID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBTdHJpbmdpZmllcihidWlsZGVyKSB7XG4gICAgICAgIHRoaXMuYnVpbGRlciA9IGJ1aWxkZXI7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBTdHJpbmdpZmllci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmF0cnVsZSA9IGZ1bmN0aW9uIGF0cnVsZShub2RlMiwgc2VtaWNvbG9uKSB7XG4gICAgICAgIHZhciBuYW1lID0gXCJAXCIgKyBub2RlMi5uYW1lO1xuICAgICAgICB2YXIgcGFyYW1zID0gbm9kZTIucGFyYW1zID8gdGhpcy5yYXdWYWx1ZShub2RlMiwgXCJwYXJhbXNcIikgOiBcIlwiO1xuICAgICAgICBpZiAodHlwZW9mIG5vZGUyLnJhd3MuYWZ0ZXJOYW1lICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBuYW1lICs9IG5vZGUyLnJhd3MuYWZ0ZXJOYW1lO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcykge1xuICAgICAgICAgICAgbmFtZSArPSBcIiBcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZTIubm9kZXMpIHtcbiAgICAgICAgICAgIHRoaXMuYmxvY2sobm9kZTIsIG5hbWUgKyBwYXJhbXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGVuZCA9IChub2RlMi5yYXdzLmJldHdlZW4gfHwgXCJcIikgKyAoc2VtaWNvbG9uID8gXCI7XCIgOiBcIlwiKTtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRlcihuYW1lICsgcGFyYW1zICsgZW5kLCBub2RlMik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5iZWZvcmVBZnRlciA9IGZ1bmN0aW9uIGJlZm9yZUFmdGVyKG5vZGUyLCBkZXRlY3QpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICBpZiAobm9kZTIudHlwZSA9PT0gXCJkZWNsXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZTIsIG51bGwsIFwiYmVmb3JlRGVjbFwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlMi50eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJiZWZvcmVDb21tZW50XCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGRldGVjdCA9PT0gXCJiZWZvcmVcIikge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJiZWZvcmVSdWxlXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJiZWZvcmVDbG9zZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnVmID0gbm9kZTIucGFyZW50O1xuICAgICAgICB2YXIgZGVwdGggPSAwO1xuICAgICAgICB3aGlsZShidWYgJiYgYnVmLnR5cGUgIT09IFwicm9vdFwiKXtcbiAgICAgICAgICAgIGRlcHRoICs9IDE7XG4gICAgICAgICAgICBidWYgPSBidWYucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgICAgICAgdmFyIGluZGVudCA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImluZGVudFwiKTtcbiAgICAgICAgICAgIGlmIChpbmRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBzdGVwID0gMDsgc3RlcCA8IGRlcHRoOyBzdGVwKyspdmFsdWUgKz0gaW5kZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5ibG9jayA9IGZ1bmN0aW9uIGJsb2NrKG5vZGUyLCBzdGFydCkge1xuICAgICAgICB2YXIgYmV0d2VlbiA9IHRoaXMucmF3KG5vZGUyLCBcImJldHdlZW5cIiwgXCJiZWZvcmVPcGVuXCIpO1xuICAgICAgICB0aGlzLmJ1aWxkZXIoc3RhcnQgKyBiZXR3ZWVuICsgXCJ7XCIsIG5vZGUyLCBcInN0YXJ0XCIpO1xuICAgICAgICB2YXIgYWZ0ZXI7XG4gICAgICAgIGlmIChub2RlMi5ub2RlcyAmJiBub2RlMi5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYm9keShub2RlMik7XG4gICAgICAgICAgICBhZnRlciA9IHRoaXMucmF3KG5vZGUyLCBcImFmdGVyXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWZ0ZXIgPSB0aGlzLnJhdyhub2RlMiwgXCJhZnRlclwiLCBcImVtcHR5Qm9keVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWZ0ZXIpIHRoaXMuYnVpbGRlcihhZnRlcik7XG4gICAgICAgIHRoaXMuYnVpbGRlcihcIn1cIiwgbm9kZTIsIFwiZW5kXCIpO1xuICAgIH07XG4gICAgX3Byb3RvLmJvZHkgPSBmdW5jdGlvbiBib2R5KG5vZGUyKSB7XG4gICAgICAgIHZhciBsYXN0ID0gbm9kZTIubm9kZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUobGFzdCA+IDApe1xuICAgICAgICAgICAgaWYgKG5vZGUyLm5vZGVzW2xhc3RdLnR5cGUgIT09IFwiY29tbWVudFwiKSBicmVhaztcbiAgICAgICAgICAgIGxhc3QgLT0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VtaWNvbG9uID0gdGhpcy5yYXcobm9kZTIsIFwic2VtaWNvbG9uXCIpO1xuICAgICAgICBmb3IodmFyIGkyID0gMDsgaTIgPCBub2RlMi5ub2Rlcy5sZW5ndGg7IGkyKyspe1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gbm9kZTIubm9kZXNbaTJdO1xuICAgICAgICAgICAgdmFyIGJlZm9yZSA9IHRoaXMucmF3KGNoaWxkLCBcImJlZm9yZVwiKTtcbiAgICAgICAgICAgIGlmIChiZWZvcmUpIHRoaXMuYnVpbGRlcihiZWZvcmUpO1xuICAgICAgICAgICAgdGhpcy5zdHJpbmdpZnkoY2hpbGQsIGxhc3QgIT09IGkyIHx8IHNlbWljb2xvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5jb21tZW50ID0gZnVuY3Rpb24gY29tbWVudChub2RlMikge1xuICAgICAgICB2YXIgbGVmdCA9IHRoaXMucmF3KG5vZGUyLCBcImxlZnRcIiwgXCJjb21tZW50TGVmdFwiKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5yYXcobm9kZTIsIFwicmlnaHRcIiwgXCJjb21tZW50UmlnaHRcIik7XG4gICAgICAgIHRoaXMuYnVpbGRlcihcIi8qXCIgKyBsZWZ0ICsgbm9kZTIudGV4dCArIHJpZ2h0ICsgXCIqL1wiLCBub2RlMik7XG4gICAgfTtcbiAgICBfcHJvdG8uZGVjbCA9IGZ1bmN0aW9uIGRlY2wobm9kZTIsIHNlbWljb2xvbikge1xuICAgICAgICB2YXIgYmV0d2VlbiA9IHRoaXMucmF3KG5vZGUyLCBcImJldHdlZW5cIiwgXCJjb2xvblwiKTtcbiAgICAgICAgdmFyIHN0cmluZyA9IG5vZGUyLnByb3AgKyBiZXR3ZWVuICsgdGhpcy5yYXdWYWx1ZShub2RlMiwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgaWYgKG5vZGUyLmltcG9ydGFudCkge1xuICAgICAgICAgICAgc3RyaW5nICs9IG5vZGUyLnJhd3MuaW1wb3J0YW50IHx8IFwiICFpbXBvcnRhbnRcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VtaWNvbG9uKSBzdHJpbmcgKz0gXCI7XCI7XG4gICAgICAgIHRoaXMuYnVpbGRlcihzdHJpbmcsIG5vZGUyKTtcbiAgICB9O1xuICAgIF9wcm90by5kb2N1bWVudCA9IGZ1bmN0aW9uIGRvY3VtZW50MShub2RlMikge1xuICAgICAgICB0aGlzLmJvZHkobm9kZTIpO1xuICAgIH07XG4gICAgX3Byb3RvLnJhdyA9IGZ1bmN0aW9uIHJhdyhub2RlMiwgb3duLCBkZXRlY3QpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICBpZiAoIWRldGVjdCkgZGV0ZWN0ID0gb3duO1xuICAgICAgICBpZiAob3duKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG5vZGUyLnJhd3Nbb3duXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyZW50ID0gbm9kZTIucGFyZW50O1xuICAgICAgICBpZiAoZGV0ZWN0ID09PSBcImJlZm9yZVwiKSB7XG4gICAgICAgICAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQudHlwZSA9PT0gXCJyb290XCIgJiYgcGFyZW50LmZpcnN0ID09PSBub2RlMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQudHlwZSA9PT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJlbnQpIHJldHVybiBERUZBVUxUX1JBVyQxW2RldGVjdF07XG4gICAgICAgIHZhciByb290MiA9IG5vZGUyLnJvb3QoKTtcbiAgICAgICAgaWYgKCFyb290Mi5yYXdDYWNoZSkgcm9vdDIucmF3Q2FjaGUgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiByb290Mi5yYXdDYWNoZVtkZXRlY3RdICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDIucmF3Q2FjaGVbZGV0ZWN0XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGV0ZWN0ID09PSBcImJlZm9yZVwiIHx8IGRldGVjdCA9PT0gXCJhZnRlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVBZnRlcihub2RlMiwgZGV0ZWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBcInJhd1wiICsgY2FwaXRhbGl6ZSQxKGRldGVjdCk7XG4gICAgICAgICAgICBpZiAodGhpc1ttZXRob2RdKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzW21ldGhvZF0ocm9vdDIsIG5vZGUyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcm9vdDIud2FsayhmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3Nbb3duXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHZhbHVlID0gREVGQVVMVF9SQVckMVtkZXRlY3RdO1xuICAgICAgICByb290Mi5yYXdDYWNoZVtkZXRlY3RdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5yYXdCZWZvcmVDbG9zZSA9IGZ1bmN0aW9uIHJhd0JlZm9yZUNsb3NlKHJvb3QyKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgcm9vdDIud2FsayhmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgaWYgKGkyLm5vZGVzICYmIGkyLm5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYWZ0ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpMi5yYXdzLmFmdGVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW15cXG5dKyQvLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHZhbHVlKSB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcUy9nLCBcIlwiKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJhd0JlZm9yZUNvbW1lbnQgPSBmdW5jdGlvbiByYXdCZWZvcmVDb21tZW50KHJvb3QyLCBub2RlMikge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHJvb3QyLndhbGtDb21tZW50cyhmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpMi5yYXdzLmJlZm9yZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gaTIucmF3cy5iZWZvcmU7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW15cXG5dKyQvLCBcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJiZWZvcmVEZWNsXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcUy9nLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3QmVmb3JlRGVjbCA9IGZ1bmN0aW9uIHJhd0JlZm9yZURlY2wocm9vdDIsIG5vZGUyKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgcm9vdDIud2Fsa0RlY2xzKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmVmb3JlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpMi5yYXdzLmJlZm9yZTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcbl0rJC8sIFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImJlZm9yZVJ1bGVcIik7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxTL2csIFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5yYXdCZWZvcmVPcGVuID0gZnVuY3Rpb24gcmF3QmVmb3JlT3Blbihyb290Mikge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHJvb3QyLndhbGsoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIGlmIChpMi50eXBlICE9PSBcImRlY2xcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gaTIucmF3cy5iZXR3ZWVuO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5yYXdCZWZvcmVSdWxlID0gZnVuY3Rpb24gcmF3QmVmb3JlUnVsZShyb290Mikge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHJvb3QyLndhbGsoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIGlmIChpMi5ub2RlcyAmJiAoaTIucGFyZW50ICE9PSByb290MiB8fCByb290Mi5maXJzdCAhPT0gaTIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpMi5yYXdzLmJlZm9yZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYmVmb3JlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW15cXG5dKyQvLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHZhbHVlKSB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcUy9nLCBcIlwiKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJhd0NvbG9uID0gZnVuY3Rpb24gcmF3Q29sb24ocm9vdDIpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICByb290Mi53YWxrRGVjbHMoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5iZXR3ZWVuICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpMi5yYXdzLmJldHdlZW4ucmVwbGFjZSgvW15cXHM6XS9nLCBcIlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3RW1wdHlCb2R5ID0gZnVuY3Rpb24gcmF3RW1wdHlCb2R5KHJvb3QyKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgcm9vdDIud2FsayhmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgaWYgKGkyLm5vZGVzICYmIGkyLm5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gaTIucmF3cy5hZnRlcjtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3SW5kZW50ID0gZnVuY3Rpb24gcmF3SW5kZW50KHJvb3QyKSB7XG4gICAgICAgIGlmIChyb290Mi5yYXdzLmluZGVudCkgcmV0dXJuIHJvb3QyLnJhd3MuaW5kZW50O1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHJvb3QyLndhbGsoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIHZhciBwID0gaTIucGFyZW50O1xuICAgICAgICAgICAgaWYgKHAgJiYgcCAhPT0gcm9vdDIgJiYgcC5wYXJlbnQgJiYgcC5wYXJlbnQgPT09IHJvb3QyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpMi5yYXdzLmJlZm9yZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBpMi5yYXdzLmJlZm9yZS5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFMvZywgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3U2VtaWNvbG9uID0gZnVuY3Rpb24gcmF3U2VtaWNvbG9uKHJvb3QyKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgcm9vdDIud2FsayhmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgaWYgKGkyLm5vZGVzICYmIGkyLm5vZGVzLmxlbmd0aCAmJiBpMi5sYXN0LnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpMi5yYXdzLnNlbWljb2xvbjtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3VmFsdWUgPSBmdW5jdGlvbiByYXdWYWx1ZShub2RlMiwgcHJvcCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBub2RlMltwcm9wXTtcbiAgICAgICAgdmFyIHJhdyA9IG5vZGUyLnJhd3NbcHJvcF07XG4gICAgICAgIGlmIChyYXcgJiYgcmF3LnZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJhdy5yYXc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJvb3QgPSBmdW5jdGlvbiByb290KG5vZGUyKSB7XG4gICAgICAgIHRoaXMuYm9keShub2RlMik7XG4gICAgICAgIGlmIChub2RlMi5yYXdzLmFmdGVyKSB0aGlzLmJ1aWxkZXIobm9kZTIucmF3cy5hZnRlcik7XG4gICAgfTtcbiAgICBfcHJvdG8ucnVsZSA9IGZ1bmN0aW9uIHJ1bGUobm9kZTIpIHtcbiAgICAgICAgdGhpcy5ibG9jayhub2RlMiwgdGhpcy5yYXdWYWx1ZShub2RlMiwgXCJzZWxlY3RvclwiKSk7XG4gICAgICAgIGlmIChub2RlMi5yYXdzLm93blNlbWljb2xvbikge1xuICAgICAgICAgICAgdGhpcy5idWlsZGVyKG5vZGUyLnJhd3Mub3duU2VtaWNvbG9uLCBub2RlMiwgXCJlbmRcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5zdHJpbmdpZnkgPSBmdW5jdGlvbiBzdHJpbmdpZnkobm9kZTIsIHNlbWljb2xvbikge1xuICAgICAgICBpZiAoIXRoaXNbbm9kZTIudHlwZV0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gQVNUIG5vZGUgdHlwZSBcIiArIG5vZGUyLnR5cGUgKyBcIi4gTWF5YmUgeW91IG5lZWQgdG8gY2hhbmdlIFBvc3RDU1Mgc3RyaW5naWZpZXIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbbm9kZTIudHlwZV0obm9kZTIsIHNlbWljb2xvbik7XG4gICAgfTtcbiAgICByZXR1cm4gU3RyaW5naWZpZXI7XG59KCk7XG52YXIgc3RyaW5naWZpZXIkMSA9IFN0cmluZ2lmaWVyJDIkMTtcblN0cmluZ2lmaWVyJDIkMS5kZWZhdWx0ID0gU3RyaW5naWZpZXIkMiQxO1xudmFyIFN0cmluZ2lmaWVyJDEkMSA9IHN0cmluZ2lmaWVyJDE7XG5mdW5jdGlvbiBzdHJpbmdpZnkkNCQxKG5vZGUyLCBidWlsZGVyKSB7XG4gICAgdmFyIHN0ciA9IG5ldyBTdHJpbmdpZmllciQxJDEoYnVpbGRlcik7XG4gICAgc3RyLnN0cmluZ2lmeShub2RlMik7XG59XG52YXIgc3RyaW5naWZ5XzEkMSA9IHN0cmluZ2lmeSQ0JDE7XG5zdHJpbmdpZnkkNCQxLmRlZmF1bHQgPSBzdHJpbmdpZnkkNCQxO1xudmFyIGlzQ2xlYW4kMiQxID0gc3ltYm9scyQxLmlzQ2xlYW4sIG15JDIkMSA9IHN5bWJvbHMkMS5teTtcbnZhciBDc3NTeW50YXhFcnJvciQyJDEgPSBjc3NTeW50YXhFcnJvciQxO1xudmFyIFN0cmluZ2lmaWVyMiQxID0gc3RyaW5naWZpZXIkMTtcbnZhciBzdHJpbmdpZnkkMyQxID0gc3RyaW5naWZ5XzEkMTtcbmZ1bmN0aW9uIGNsb25lTm9kZSQxKG9iaiwgcGFyZW50KSB7XG4gICAgdmFyIGNsb25lZCA9IG5ldyBvYmouY29uc3RydWN0b3IoKTtcbiAgICBmb3IodmFyIGkyIGluIG9iail7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaTIpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaTIgPT09IFwicHJveHlDYWNoZVwiKSBjb250aW51ZTtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqW2kyXTtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YodmFsdWUpO1xuICAgICAgICBpZiAoaTIgPT09IFwicGFyZW50XCIgJiYgdHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKHBhcmVudCkgY2xvbmVkW2kyXSA9IHBhcmVudDtcbiAgICAgICAgfSBlbHNlIGlmIChpMiA9PT0gXCJzb3VyY2VcIikge1xuICAgICAgICAgICAgY2xvbmVkW2kyXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBjbG9uZWRbaTJdID0gdmFsdWUubWFwKGZ1bmN0aW9uKGopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVOb2RlJDEoaiwgY2xvbmVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHZhbHVlID0gY2xvbmVOb2RlJDEodmFsdWUpO1xuICAgICAgICAgICAgY2xvbmVkW2kyXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbG9uZWQ7XG59XG52YXIgTm9kZSQ0JDEgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIE5vZGUyKGRlZmF1bHRzKSB7XG4gICAgICAgIGlmIChkZWZhdWx0cyA9PT0gdm9pZCAwKSBkZWZhdWx0cyA9IHt9O1xuICAgICAgICB0aGlzLnJhd3MgPSB7fTtcbiAgICAgICAgdGhpc1tpc0NsZWFuJDIkMV0gPSBmYWxzZTtcbiAgICAgICAgdGhpc1tteSQyJDFdID0gdHJ1ZTtcbiAgICAgICAgZm9yKHZhciBuYW1lIGluIGRlZmF1bHRzKXtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSBcIm5vZGVzXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UoZGVmYXVsdHNbbmFtZV0pLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5vZGUyLmNsb25lID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kKG5vZGUyLmNsb25lKCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmQobm9kZTIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzW25hbWVdID0gZGVmYXVsdHNbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIF9wcm90byA9IE5vZGUyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uYWRkVG9FcnJvciA9IGZ1bmN0aW9uIGFkZFRvRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgZXJyb3IucG9zdGNzc05vZGUgPSB0aGlzO1xuICAgICAgICBpZiAoZXJyb3Iuc3RhY2sgJiYgdGhpcy5zb3VyY2UgJiYgL1xcblxcc3s0fWF0IC8udGVzdChlcnJvci5zdGFjaykpIHtcbiAgICAgICAgICAgIHZhciBzMiA9IHRoaXMuc291cmNlO1xuICAgICAgICAgICAgZXJyb3Iuc3RhY2sgPSBlcnJvci5zdGFjay5yZXBsYWNlKC9cXG5cXHN7NH1hdCAvLCBcIiQmXCIgKyBzMi5pbnB1dC5mcm9tICsgXCI6XCIgKyBzMi5zdGFydC5saW5lICsgXCI6XCIgKyBzMi5zdGFydC5jb2x1bW4gKyBcIiQmXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9O1xuICAgIF9wcm90by5hZnRlciA9IGZ1bmN0aW9uIGFmdGVyKGFkZCkge1xuICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRBZnRlcih0aGlzLCBhZGQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90by5hc3NpZ24gPSBmdW5jdGlvbiBhc3NpZ24ob3ZlcnJpZGVzKSB7XG4gICAgICAgIGlmIChvdmVycmlkZXMgPT09IHZvaWQgMCkgb3ZlcnJpZGVzID0ge307XG4gICAgICAgIGZvcih2YXIgbmFtZSBpbiBvdmVycmlkZXMpe1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IG92ZXJyaWRlc1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90by5iZWZvcmUgPSBmdW5jdGlvbiBiZWZvcmUoYWRkKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLCBhZGQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90by5jbGVhblJhd3MgPSBmdW5jdGlvbiBjbGVhblJhd3Moa2VlcEJldHdlZW4pIHtcbiAgICAgICAgZGVsZXRlIHRoaXMucmF3cy5iZWZvcmU7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnJhd3MuYWZ0ZXI7XG4gICAgICAgIGlmICgha2VlcEJldHdlZW4pIGRlbGV0ZSB0aGlzLnJhd3MuYmV0d2VlbjtcbiAgICB9O1xuICAgIF9wcm90by5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKG92ZXJyaWRlcykge1xuICAgICAgICBpZiAob3ZlcnJpZGVzID09PSB2b2lkIDApIG92ZXJyaWRlcyA9IHt9O1xuICAgICAgICB2YXIgY2xvbmVkID0gY2xvbmVOb2RlJDEodGhpcyk7XG4gICAgICAgIGZvcih2YXIgbmFtZSBpbiBvdmVycmlkZXMpe1xuICAgICAgICAgICAgY2xvbmVkW25hbWVdID0gb3ZlcnJpZGVzW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgfTtcbiAgICBfcHJvdG8uY2xvbmVBZnRlciA9IGZ1bmN0aW9uIGNsb25lQWZ0ZXIob3ZlcnJpZGVzKSB7XG4gICAgICAgIGlmIChvdmVycmlkZXMgPT09IHZvaWQgMCkgb3ZlcnJpZGVzID0ge307XG4gICAgICAgIHZhciBjbG9uZWQgPSB0aGlzLmNsb25lKG92ZXJyaWRlcyk7XG4gICAgICAgIHRoaXMucGFyZW50Lmluc2VydEFmdGVyKHRoaXMsIGNsb25lZCk7XG4gICAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgfTtcbiAgICBfcHJvdG8uY2xvbmVCZWZvcmUgPSBmdW5jdGlvbiBjbG9uZUJlZm9yZShvdmVycmlkZXMpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlcyA9PT0gdm9pZCAwKSBvdmVycmlkZXMgPSB7fTtcbiAgICAgICAgdmFyIGNsb25lZCA9IHRoaXMuY2xvbmUob3ZlcnJpZGVzKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMsIGNsb25lZCk7XG4gICAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgfTtcbiAgICBfcHJvdG8uZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihtZXNzYWdlLCBvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzID09PSB2b2lkIDApIG9wdHMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuc291cmNlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXNfcmFuZ2VCeSA9IHRoaXMucmFuZ2VCeShvcHRzKSwgZW5kID0gX3RoaXNfcmFuZ2VCeS5lbmQsIHN0YXJ0ID0gX3RoaXNfcmFuZ2VCeS5zdGFydDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5pbnB1dC5lcnJvcihtZXNzYWdlLCB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBzdGFydC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgbGluZTogc3RhcnQubGluZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGNvbHVtbjogZW5kLmNvbHVtbixcbiAgICAgICAgICAgICAgICBsaW5lOiBlbmQubGluZVxuICAgICAgICAgICAgfSwgb3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDc3NTeW50YXhFcnJvciQyJDEobWVzc2FnZSk7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0UHJveHlQcm9jZXNzb3IgPSBmdW5jdGlvbiBnZXRQcm94eVByb2Nlc3NvcigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KG5vZGUyLCBwcm9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgPT09IFwicHJveHlPZlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlMjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlMi5yb290KCkudG9Qcm94eSgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlMltwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobm9kZTIsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUyW3Byb3BdID09PSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgbm9kZTJbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0gXCJwcm9wXCIgfHwgcHJvcCA9PT0gXCJ2YWx1ZVwiIHx8IHByb3AgPT09IFwibmFtZVwiIHx8IHByb3AgPT09IFwicGFyYW1zXCIgfHwgcHJvcCA9PT0gXCJpbXBvcnRhbnRcIiB8fCAvKiBjOCBpZ25vcmUgbmV4dCAqLyBwcm9wID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgICAgICAgICBub2RlMi5tYXJrRGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8ubWFya0RpcnR5ID0gZnVuY3Rpb24gbWFya0RpcnR5KCkge1xuICAgICAgICBpZiAodGhpc1tpc0NsZWFuJDIkMV0pIHtcbiAgICAgICAgICAgIHRoaXNbaXNDbGVhbiQyJDFdID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZShuZXh0ID0gbmV4dC5wYXJlbnQpe1xuICAgICAgICAgICAgICAgIG5leHRbaXNDbGVhbiQyJDFdID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5uZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgdmFyIGluZGV4MiA9IHRoaXMucGFyZW50LmluZGV4KHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQubm9kZXNbaW5kZXgyICsgMV07XG4gICAgfTtcbiAgICBfcHJvdG8ucG9zaXRpb25CeSA9IGZ1bmN0aW9uIHBvc2l0aW9uQnkob3B0cywgc3RyaW5nUmVwcmVzZW50YXRpb24pIHtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuc291cmNlLnN0YXJ0O1xuICAgICAgICBpZiAob3B0cy5pbmRleCkge1xuICAgICAgICAgICAgcG9zID0gdGhpcy5wb3NpdGlvbkluc2lkZShvcHRzLmluZGV4LCBzdHJpbmdSZXByZXNlbnRhdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0cy53b3JkKSB7XG4gICAgICAgICAgICBzdHJpbmdSZXByZXNlbnRhdGlvbiA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHZhciBpbmRleDIgPSBzdHJpbmdSZXByZXNlbnRhdGlvbi5pbmRleE9mKG9wdHMud29yZCk7XG4gICAgICAgICAgICBpZiAoaW5kZXgyICE9PSAtMSkgcG9zID0gdGhpcy5wb3NpdGlvbkluc2lkZShpbmRleDIsIHN0cmluZ1JlcHJlc2VudGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH07XG4gICAgX3Byb3RvLnBvc2l0aW9uSW5zaWRlID0gZnVuY3Rpb24gcG9zaXRpb25JbnNpZGUoaW5kZXgyLCBzdHJpbmdSZXByZXNlbnRhdGlvbikge1xuICAgICAgICB2YXIgc3RyaW5nID0gc3RyaW5nUmVwcmVzZW50YXRpb24gfHwgdGhpcy50b1N0cmluZygpO1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5zb3VyY2Uuc3RhcnQuY29sdW1uO1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMuc291cmNlLnN0YXJ0LmxpbmU7XG4gICAgICAgIGZvcih2YXIgaTIgPSAwOyBpMiA8IGluZGV4MjsgaTIrKyl7XG4gICAgICAgICAgICBpZiAoc3RyaW5nW2kyXSA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IDE7XG4gICAgICAgICAgICAgICAgbGluZSArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4gKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICBsaW5lOiBsaW5lXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8ucHJldiA9IGZ1bmN0aW9uIHByZXYoKSB7XG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHJldHVybiB2b2lkIDA7XG4gICAgICAgIHZhciBpbmRleDIgPSB0aGlzLnBhcmVudC5pbmRleCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm5vZGVzW2luZGV4MiAtIDFdO1xuICAgIH07XG4gICAgX3Byb3RvLnJhbmdlQnkgPSBmdW5jdGlvbiByYW5nZUJ5KG9wdHMpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0ge1xuICAgICAgICAgICAgY29sdW1uOiB0aGlzLnNvdXJjZS5zdGFydC5jb2x1bW4sXG4gICAgICAgICAgICBsaW5lOiB0aGlzLnNvdXJjZS5zdGFydC5saW5lXG4gICAgICAgIH07XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnNvdXJjZS5lbmQgPyB7XG4gICAgICAgICAgICBjb2x1bW46IHRoaXMuc291cmNlLmVuZC5jb2x1bW4gKyAxLFxuICAgICAgICAgICAgbGluZTogdGhpcy5zb3VyY2UuZW5kLmxpbmVcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICAgIGNvbHVtbjogc3RhcnQuY29sdW1uICsgMSxcbiAgICAgICAgICAgIGxpbmU6IHN0YXJ0LmxpbmVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdHMud29yZCkge1xuICAgICAgICAgICAgdmFyIHN0cmluZ1JlcHJlc2VudGF0aW9uID0gdGhpcy50b1N0cmluZygpO1xuICAgICAgICAgICAgdmFyIGluZGV4MiA9IHN0cmluZ1JlcHJlc2VudGF0aW9uLmluZGV4T2Yob3B0cy53b3JkKTtcbiAgICAgICAgICAgIGlmIChpbmRleDIgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKGluZGV4Miwgc3RyaW5nUmVwcmVzZW50YXRpb24pO1xuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMucG9zaXRpb25JbnNpZGUoaW5kZXgyICsgb3B0cy53b3JkLmxlbmd0aCwgc3RyaW5nUmVwcmVzZW50YXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9wdHMuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBvcHRzLnN0YXJ0LmNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgbGluZTogb3B0cy5zdGFydC5saW5lXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0cy5pbmRleCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5wb3NpdGlvbkluc2lkZShvcHRzLmluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLmVuZCkge1xuICAgICAgICAgICAgICAgIGVuZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBvcHRzLmVuZC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IG9wdHMuZW5kLmxpbmVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cy5lbmRJbmRleCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMucG9zaXRpb25JbnNpZGUob3B0cy5lbmRJbmRleCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdHMuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKG9wdHMuaW5kZXggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kLmxpbmUgPCBzdGFydC5saW5lIHx8IGVuZC5saW5lID09PSBzdGFydC5saW5lICYmIGVuZC5jb2x1bW4gPD0gc3RhcnQuY29sdW1uKSB7XG4gICAgICAgICAgICBlbmQgPSB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBzdGFydC5jb2x1bW4gKyAxLFxuICAgICAgICAgICAgICAgIGxpbmU6IHN0YXJ0LmxpbmVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3ID0gZnVuY3Rpb24gcmF3KHByb3AsIGRlZmF1bHRUeXBlKSB7XG4gICAgICAgIHZhciBzdHIgPSBuZXcgU3RyaW5naWZpZXIyJDEoKTtcbiAgICAgICAgcmV0dXJuIHN0ci5yYXcodGhpcywgcHJvcCwgZGVmYXVsdFR5cGUpO1xuICAgIH07XG4gICAgX3Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcmVudCA9IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVwbGFjZVdpdGggPSBmdW5jdGlvbiByZXBsYWNlV2l0aCgpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbm9kZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIG5vZGVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdmFyIGJvb2ttYXJrID0gdGhpcztcbiAgICAgICAgICAgIHZhciBmb3VuZFNlbGYgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKG5vZGVzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgIHZhciBub2RlMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlMiA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZFNlbGYgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZm91bmRTZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Lmluc2VydEFmdGVyKGJvb2ttYXJrLCBub2RlMik7XG4gICAgICAgICAgICAgICAgICAgIGJvb2ttYXJrID0gbm9kZTI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKGJvb2ttYXJrLCBub2RlMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmb3VuZFNlbGYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLnJvb3QgPSBmdW5jdGlvbiByb290KCkge1xuICAgICAgICB2YXIgcmVzdWx0MiA9IHRoaXM7XG4gICAgICAgIHdoaWxlKHJlc3VsdDIucGFyZW50ICYmIHJlc3VsdDIucGFyZW50LnR5cGUgIT09IFwiZG9jdW1lbnRcIil7XG4gICAgICAgICAgICByZXN1bHQyID0gcmVzdWx0Mi5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgfTtcbiAgICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKF8sIGlucHV0cykge1xuICAgICAgICB2YXIgZml4ZWQgPSB7fTtcbiAgICAgICAgdmFyIGVtaXRJbnB1dHMgPSBpbnB1dHMgPT0gbnVsbDtcbiAgICAgICAgaW5wdXRzID0gaW5wdXRzIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBpbnB1dHNOZXh0SW5kZXggPSAwO1xuICAgICAgICBmb3IodmFyIG5hbWUgaW4gdGhpcyl7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBuYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwicGFyZW50XCIgfHwgbmFtZSA9PT0gXCJwcm94eUNhY2hlXCIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZpeGVkW25hbWVdID0gdmFsdWUubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIGkyID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKGkyKSkgPT09IFwib2JqZWN0XCIgJiYgaTIudG9KU09OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTIudG9KU09OKG51bGwsIGlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZih2YWx1ZSkpID09PSBcIm9iamVjdFwiICYmIHZhbHVlLnRvSlNPTikge1xuICAgICAgICAgICAgICAgIGZpeGVkW25hbWVdID0gdmFsdWUudG9KU09OKG51bGwsIGlucHV0cyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwic291cmNlXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXRJZCA9IGlucHV0cy5nZXQodmFsdWUuaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dElkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRJZCA9IGlucHV0c05leHRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzLnNldCh2YWx1ZS5pbnB1dCwgaW5wdXRzTmV4dEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzTmV4dEluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpeGVkW25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICBlbmQ6IHZhbHVlLmVuZCxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRJZDogaW5wdXRJZCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHZhbHVlLnN0YXJ0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZml4ZWRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW1pdElucHV0cykge1xuICAgICAgICAgICAgZml4ZWQuaW5wdXRzID0gW10uY29uY2F0KGlucHV0cy5rZXlzKCkpLm1hcChmdW5jdGlvbihpbnB1dDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQyLnRvSlNPTigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpeGVkO1xuICAgIH07XG4gICAgX3Byb3RvLnRvUHJveHkgPSBmdW5jdGlvbiB0b1Byb3h5KCkge1xuICAgICAgICBpZiAoIXRoaXMucHJveHlDYWNoZSkge1xuICAgICAgICAgICAgdGhpcy5wcm94eUNhY2hlID0gbmV3IFByb3h5KHRoaXMsIHRoaXMuZ2V0UHJveHlQcm9jZXNzb3IoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJveHlDYWNoZTtcbiAgICB9O1xuICAgIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKHN0cmluZ2lmaWVyMikge1xuICAgICAgICBpZiAoc3RyaW5naWZpZXIyID09PSB2b2lkIDApIHN0cmluZ2lmaWVyMiA9IHN0cmluZ2lmeSQzJDE7XG4gICAgICAgIGlmIChzdHJpbmdpZmllcjIuc3RyaW5naWZ5KSBzdHJpbmdpZmllcjIgPSBzdHJpbmdpZmllcjIuc3RyaW5naWZ5O1xuICAgICAgICB2YXIgcmVzdWx0MiA9IFwiXCI7XG4gICAgICAgIHN0cmluZ2lmaWVyMih0aGlzLCBmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgcmVzdWx0MiArPSBpMjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgIH07XG4gICAgX3Byb3RvLndhcm4gPSBmdW5jdGlvbiB3YXJuKHJlc3VsdDIsIHRleHQsIG9wdHMpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICBub2RlOiB0aGlzXG4gICAgICAgIH07XG4gICAgICAgIGZvcih2YXIgaTIgaW4gb3B0cylkYXRhW2kyXSA9IG9wdHNbaTJdO1xuICAgICAgICByZXR1cm4gcmVzdWx0Mi53YXJuKHRleHQsIGRhdGEpO1xuICAgIH07XG4gICAgX2NyZWF0ZV9jbGFzcyhOb2RlMiwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwicHJveHlPZlwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gTm9kZTI7XG59KCk7XG52YXIgbm9kZSQxID0gTm9kZSQ0JDE7XG5Ob2RlJDQkMS5kZWZhdWx0ID0gTm9kZSQ0JDE7XG52YXIgTm9kZSQzJDEgPSBub2RlJDE7XG52YXIgRGVjbGFyYXRpb24kNCQxID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihOb2RlJDMkMSkge1xuICAgIF9pbmhlcml0cyhEZWNsYXJhdGlvbiwgTm9kZSQzJDEpO1xuICAgIGZ1bmN0aW9uIERlY2xhcmF0aW9uKGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgaWYgKGRlZmF1bHRzICYmIHR5cGVvZiBkZWZhdWx0cy52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgZGVmYXVsdHMudmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGRlZmF1bHRzID0gX2V4dGVuZHMoe30sIGRlZmF1bHRzLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFN0cmluZyhkZWZhdWx0cy52YWx1ZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzID0gTm9kZSQzJDEuY2FsbCh0aGlzLCBkZWZhdWx0cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9IFwiZGVjbFwiO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIF9jcmVhdGVfY2xhc3MoRGVjbGFyYXRpb24sIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInZhcmlhYmxlXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wLnN0YXJ0c1dpdGgoXCItLVwiKSB8fCB0aGlzLnByb3BbMF0gPT09IFwiJFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIERlY2xhcmF0aW9uO1xufShOb2RlJDMkMSk7XG52YXIgZGVjbGFyYXRpb24kMSA9IERlY2xhcmF0aW9uJDQkMTtcbkRlY2xhcmF0aW9uJDQkMS5kZWZhdWx0ID0gRGVjbGFyYXRpb24kNCQxO1xudmFyIHVybEFscGhhYmV0JDEgPSBcInVzZWFuZG9tLTI2VDE5ODM0MFBYNzVweEpBQ0tWRVJZTUlOREJVU0hXT0xGX0dRWmJmZ2hqa2xxdnd5enJpY3RcIjtcbnZhciBuYW5vaWQkMSQxID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIGlmIChzaXplID09PSB2b2lkIDApIHNpemUgPSAyMTtcbiAgICB2YXIgaWQgPSBcIlwiO1xuICAgIHZhciBpMiA9IHNpemU7XG4gICAgd2hpbGUoaTItLSl7XG4gICAgICAgIGlkICs9IHVybEFscGhhYmV0JDFbTWF0aC5yYW5kb20oKSAqIDY0IHwgMF07XG4gICAgfVxuICAgIHJldHVybiBpZDtcbn07XG52YXIgbm9uU2VjdXJlJDEgPSB7XG4gICAgbmFub2lkOiBuYW5vaWQkMSQxXG59O1xudmFyIFNvdXJjZU1hcENvbnN1bWVyJDIkMSA9IHJlcXVpcmUkJDIkMS5Tb3VyY2VNYXBDb25zdW1lciwgU291cmNlTWFwR2VuZXJhdG9yJDIkMSA9IHJlcXVpcmUkJDIkMS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG52YXIgZXhpc3RzU3luYyQxID0gcmVxdWlyZSQkMiQxLmV4aXN0c1N5bmMsIHJlYWRGaWxlU3luYyQxID0gcmVxdWlyZSQkMiQxLnJlYWRGaWxlU3luYztcbnZhciBkaXJuYW1lJDEkMSA9IHJlcXVpcmUkJDIkMS5kaXJuYW1lLCBqb2luJDEgPSByZXF1aXJlJCQyJDEuam9pbjtcbmZ1bmN0aW9uIGZyb21CYXNlNjQkMShzdHIpIHtcbiAgICBpZiAoQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHIsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5hdG9iKHN0cik7XG4gICAgfVxufVxudmFyIFByZXZpb3VzTWFwJDIkMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gUHJldmlvdXNNYXAoY3NzLCBvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzLm1hcCA9PT0gZmFsc2UpIHJldHVybjtcbiAgICAgICAgdGhpcy5sb2FkQW5ub3RhdGlvbihjc3MpO1xuICAgICAgICB0aGlzLmlubGluZSA9IHRoaXMuc3RhcnRXaXRoKHRoaXMuYW5ub3RhdGlvbiwgXCJkYXRhOlwiKTtcbiAgICAgICAgdmFyIHByZXYgPSBvcHRzLm1hcCA/IG9wdHMubWFwLnByZXYgOiB2b2lkIDA7XG4gICAgICAgIHZhciB0ZXh0ID0gdGhpcy5sb2FkTWFwKG9wdHMuZnJvbSwgcHJldik7XG4gICAgICAgIGlmICghdGhpcy5tYXBGaWxlICYmIG9wdHMuZnJvbSkge1xuICAgICAgICAgICAgdGhpcy5tYXBGaWxlID0gb3B0cy5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hcEZpbGUpIHRoaXMucm9vdCA9IGRpcm5hbWUkMSQxKHRoaXMubWFwRmlsZSk7XG4gICAgICAgIGlmICh0ZXh0KSB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gUHJldmlvdXNNYXAucHJvdG90eXBlO1xuICAgIF9wcm90by5jb25zdW1lciA9IGZ1bmN0aW9uIGNvbnN1bWVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29uc3VtZXJDYWNoZSkge1xuICAgICAgICAgICAgdGhpcy5jb25zdW1lckNhY2hlID0gbmV3IFNvdXJjZU1hcENvbnN1bWVyJDIkMSh0aGlzLnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVyQ2FjaGU7XG4gICAgfTtcbiAgICBfcHJvdG8uZGVjb2RlSW5saW5lID0gZnVuY3Rpb24gZGVjb2RlSW5saW5lKHRleHQpIHtcbiAgICAgICAgdmFyIGJhc2VDaGFyc2V0VXJpID0gL15kYXRhOmFwcGxpY2F0aW9uXFwvanNvbjtjaGFyc2V0PXV0Zi0/ODtiYXNlNjQsLztcbiAgICAgICAgdmFyIGJhc2VVcmkgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uO2Jhc2U2NCwvO1xuICAgICAgICB2YXIgY2hhcnNldFVyaSA9IC9eZGF0YTphcHBsaWNhdGlvblxcL2pzb247Y2hhcnNldD11dGYtPzgsLztcbiAgICAgICAgdmFyIHVyaSA9IC9eZGF0YTphcHBsaWNhdGlvblxcL2pzb24sLztcbiAgICAgICAgaWYgKGNoYXJzZXRVcmkudGVzdCh0ZXh0KSB8fCB1cmkudGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudCh0ZXh0LnN1YnN0cihSZWdFeHAubGFzdE1hdGNoLmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlQ2hhcnNldFVyaS50ZXN0KHRleHQpIHx8IGJhc2VVcmkudGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21CYXNlNjQkMSh0ZXh0LnN1YnN0cihSZWdFeHAubGFzdE1hdGNoLmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbmNvZGluZyA9IHRleHQubWF0Y2goL2RhdGE6YXBwbGljYXRpb25cXC9qc29uOyhbXixdKyksLylbMV07XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHNvdXJjZSBtYXAgZW5jb2RpbmcgXCIgKyBlbmNvZGluZyk7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0QW5ub3RhdGlvblVSTCA9IGZ1bmN0aW9uIGdldEFubm90YXRpb25VUkwoc291cmNlTWFwU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2VNYXBTdHJpbmcucmVwbGFjZSgvXlxcL1xcKlxccyojIHNvdXJjZU1hcHBpbmdVUkw9LywgXCJcIikudHJpbSgpO1xuICAgIH07XG4gICAgX3Byb3RvLmlzTWFwID0gZnVuY3Rpb24gaXNNYXAobWFwKSB7XG4gICAgICAgIGlmICgodHlwZW9mIG1hcCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihtYXApKSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHlwZW9mIG1hcC5tYXBwaW5ncyA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgbWFwLl9tYXBwaW5ncyA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KG1hcC5zZWN0aW9ucyk7XG4gICAgfTtcbiAgICBfcHJvdG8ubG9hZEFubm90YXRpb24gPSBmdW5jdGlvbiBsb2FkQW5ub3RhdGlvbihjc3MpIHtcbiAgICAgICAgdmFyIGNvbW1lbnRzID0gY3NzLm1hdGNoKC9cXC9cXCpcXHMqIyBzb3VyY2VNYXBwaW5nVVJMPS9nbSk7XG4gICAgICAgIGlmICghY29tbWVudHMpIHJldHVybjtcbiAgICAgICAgdmFyIHN0YXJ0ID0gY3NzLmxhc3RJbmRleE9mKGNvbW1lbnRzLnBvcCgpKTtcbiAgICAgICAgdmFyIGVuZCA9IGNzcy5pbmRleE9mKFwiKi9cIiwgc3RhcnQpO1xuICAgICAgICBpZiAoc3RhcnQgPiAtMSAmJiBlbmQgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5hbm5vdGF0aW9uID0gdGhpcy5nZXRBbm5vdGF0aW9uVVJMKGNzcy5zdWJzdHJpbmcoc3RhcnQsIGVuZCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ubG9hZEZpbGUgPSBmdW5jdGlvbiBsb2FkRmlsZShwYXRoKSB7XG4gICAgICAgIHRoaXMucm9vdCA9IGRpcm5hbWUkMSQxKHBhdGgpO1xuICAgICAgICBpZiAoZXhpc3RzU3luYyQxKHBhdGgpKSB7XG4gICAgICAgICAgICB0aGlzLm1hcEZpbGUgPSBwYXRoO1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRGaWxlU3luYyQxKHBhdGgsIFwidXRmLThcIikudG9TdHJpbmcoKS50cmltKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5sb2FkTWFwID0gZnVuY3Rpb24gbG9hZE1hcChmaWxlLCBwcmV2KSB7XG4gICAgICAgIGlmIChwcmV2ID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmV2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcmV2ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldlBhdGggPSBwcmV2KGZpbGUpO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2UGF0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFwID0gdGhpcy5sb2FkRmlsZShwcmV2UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gbG9hZCBwcmV2aW91cyBzb3VyY2UgbWFwOiBcIiArIHByZXZQYXRoLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZihwcmV2LCBTb3VyY2VNYXBDb25zdW1lciQyJDEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNvdXJjZU1hcEdlbmVyYXRvciQyJDEuZnJvbVNvdXJjZU1hcChwcmV2KS50b1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZihwcmV2LCBTb3VyY2VNYXBHZW5lcmF0b3IkMiQxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNNYXAocHJldikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocHJldik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHByZXZpb3VzIHNvdXJjZSBtYXAgZm9ybWF0OiBcIiArIHByZXYudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pbmxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZUlubGluZSh0aGlzLmFubm90YXRpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYW5ub3RhdGlvbikge1xuICAgICAgICAgICAgdmFyIG1hcDEgPSB0aGlzLmFubm90YXRpb247XG4gICAgICAgICAgICBpZiAoZmlsZSkgbWFwMSA9IGpvaW4kMShkaXJuYW1lJDEkMShmaWxlKSwgbWFwMSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkRmlsZShtYXAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnN0YXJ0V2l0aCA9IGZ1bmN0aW9uIHN0YXJ0V2l0aChzdHJpbmcsIHN0YXJ0KSB7XG4gICAgICAgIGlmICghc3RyaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBzdHJpbmcuc3Vic3RyKDAsIHN0YXJ0Lmxlbmd0aCkgPT09IHN0YXJ0O1xuICAgIH07XG4gICAgX3Byb3RvLndpdGhDb250ZW50ID0gZnVuY3Rpb24gd2l0aENvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLmNvbnN1bWVyKCkuc291cmNlc0NvbnRlbnQgJiYgdGhpcy5jb25zdW1lcigpLnNvdXJjZXNDb250ZW50Lmxlbmd0aCA+IDApO1xuICAgIH07XG4gICAgcmV0dXJuIFByZXZpb3VzTWFwO1xufSgpO1xudmFyIHByZXZpb3VzTWFwJDEgPSBQcmV2aW91c01hcCQyJDE7XG5QcmV2aW91c01hcCQyJDEuZGVmYXVsdCA9IFByZXZpb3VzTWFwJDIkMTtcbnZhciBTb3VyY2VNYXBDb25zdW1lciQxJDEgPSByZXF1aXJlJCQyJDEuU291cmNlTWFwQ29uc3VtZXIsIFNvdXJjZU1hcEdlbmVyYXRvciQxJDEgPSByZXF1aXJlJCQyJDEuU291cmNlTWFwR2VuZXJhdG9yO1xudmFyIGZpbGVVUkxUb1BhdGgkMSA9IHJlcXVpcmUkJDIkMS5maWxlVVJMVG9QYXRoLCBwYXRoVG9GaWxlVVJMJDEkMSA9IHJlcXVpcmUkJDIkMS5wYXRoVG9GaWxlVVJMO1xudmFyIGlzQWJzb2x1dGUkMSA9IHJlcXVpcmUkJDIkMS5pc0Fic29sdXRlLCByZXNvbHZlJDEkMSA9IHJlcXVpcmUkJDIkMS5yZXNvbHZlO1xudmFyIG5hbm9pZCQyID0gbm9uU2VjdXJlJDEubmFub2lkO1xudmFyIHRlcm1pbmFsSGlnaGxpZ2h0JDIgPSByZXF1aXJlJCQyJDE7XG52YXIgQ3NzU3ludGF4RXJyb3IkMSQxID0gY3NzU3ludGF4RXJyb3IkMTtcbnZhciBQcmV2aW91c01hcCQxJDEgPSBwcmV2aW91c01hcCQxO1xudmFyIGZyb21PZmZzZXRDYWNoZSQxID0gU3ltYm9sKFwiZnJvbU9mZnNldENhY2hlXCIpO1xudmFyIHNvdXJjZU1hcEF2YWlsYWJsZSQxJDEgPSBCb29sZWFuKFNvdXJjZU1hcENvbnN1bWVyJDEkMSAmJiBTb3VyY2VNYXBHZW5lcmF0b3IkMSQxKTtcbnZhciBwYXRoQXZhaWxhYmxlJDEkMSA9IEJvb2xlYW4ocmVzb2x2ZSQxJDEgJiYgaXNBYnNvbHV0ZSQxKTtcbnZhciBJbnB1dCQ0JDEgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIElucHV0KGNzcywgb3B0cykge1xuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSBvcHRzID0ge307XG4gICAgICAgIGlmIChjc3MgPT09IG51bGwgfHwgdHlwZW9mIGNzcyA9PT0gXCJ1bmRlZmluZWRcIiB8fCAodHlwZW9mIGNzcyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihjc3MpKSA9PT0gXCJvYmplY3RcIiAmJiAhY3NzLnRvU3RyaW5nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb3N0Q1NTIHJlY2VpdmVkIFwiICsgY3NzICsgXCIgaW5zdGVhZCBvZiBDU1Mgc3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3NzID0gY3NzLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICh0aGlzLmNzc1swXSA9PT0gXCJcXHVGRUZGXCIgfHwgdGhpcy5jc3NbMF0gPT09IFwi77++XCIpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzQk9NID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY3NzID0gdGhpcy5jc3Muc2xpY2UoMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhc0JPTSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmZyb20pIHtcbiAgICAgICAgICAgIGlmICghcGF0aEF2YWlsYWJsZSQxJDEgfHwgL15cXHcrOlxcL1xcLy8udGVzdChvcHRzLmZyb20pIHx8IGlzQWJzb2x1dGUkMShvcHRzLmZyb20pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlID0gb3B0cy5mcm9tO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGUgPSByZXNvbHZlJDEkMShvcHRzLmZyb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoQXZhaWxhYmxlJDEkMSAmJiBzb3VyY2VNYXBBdmFpbGFibGUkMSQxKSB7XG4gICAgICAgICAgICB2YXIgbWFwID0gbmV3IFByZXZpb3VzTWFwJDEkMSh0aGlzLmNzcywgb3B0cyk7XG4gICAgICAgICAgICBpZiAobWFwLnRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcCA9IG1hcDtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZSA9IG1hcC5jb25zdW1lcigpLmZpbGU7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmZpbGUgJiYgZmlsZSkgdGhpcy5maWxlID0gdGhpcy5tYXBSZXNvbHZlKGZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5maWxlKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gXCI8aW5wdXQgY3NzIFwiICsgbmFub2lkJDIoNikgKyBcIj5cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXApIHRoaXMubWFwLmZpbGUgPSB0aGlzLmZyb207XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBJbnB1dC5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmVycm9yID0gZnVuY3Rpb24gZXJyb3IobWVzc2FnZSwgbGluZSwgY29sdW1uLCBvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzID09PSB2b2lkIDApIG9wdHMgPSB7fTtcbiAgICAgICAgdmFyIHJlc3VsdDIsIGVuZExpbmUsIGVuZENvbHVtbjtcbiAgICAgICAgaWYgKGxpbmUgJiYgKHR5cGVvZiBsaW5lID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKGxpbmUpKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gbGluZTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBjb2x1bW47XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0YXJ0Lm9mZnNldCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLmZyb21PZmZzZXQoc3RhcnQub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBsaW5lID0gcG9zLmxpbmU7XG4gICAgICAgICAgICAgICAgY29sdW1uID0gcG9zLmNvbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IHN0YXJ0LmxpbmU7XG4gICAgICAgICAgICAgICAgY29sdW1uID0gc3RhcnQuY29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmQub2Zmc2V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvczEgPSB0aGlzLmZyb21PZmZzZXQoZW5kLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgZW5kTGluZSA9IHBvczEubGluZTtcbiAgICAgICAgICAgICAgICBlbmRDb2x1bW4gPSBwb3MxLmNvbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kTGluZSA9IGVuZC5saW5lO1xuICAgICAgICAgICAgICAgIGVuZENvbHVtbiA9IGVuZC5jb2x1bW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWNvbHVtbikge1xuICAgICAgICAgICAgdmFyIHBvczIgPSB0aGlzLmZyb21PZmZzZXQobGluZSk7XG4gICAgICAgICAgICBsaW5lID0gcG9zMi5saW5lO1xuICAgICAgICAgICAgY29sdW1uID0gcG9zMi5jb2w7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9yaWdpbiA9IHRoaXMub3JpZ2luKGxpbmUsIGNvbHVtbiwgZW5kTGluZSwgZW5kQ29sdW1uKTtcbiAgICAgICAgaWYgKG9yaWdpbikge1xuICAgICAgICAgICAgcmVzdWx0MiA9IG5ldyBDc3NTeW50YXhFcnJvciQxJDEobWVzc2FnZSwgb3JpZ2luLmVuZExpbmUgPT09IHZvaWQgMCA/IG9yaWdpbi5saW5lIDoge1xuICAgICAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luLmNvbHVtbixcbiAgICAgICAgICAgICAgICBsaW5lOiBvcmlnaW4ubGluZVxuICAgICAgICAgICAgfSwgb3JpZ2luLmVuZExpbmUgPT09IHZvaWQgMCA/IG9yaWdpbi5jb2x1bW4gOiB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBvcmlnaW4uZW5kQ29sdW1uLFxuICAgICAgICAgICAgICAgIGxpbmU6IG9yaWdpbi5lbmRMaW5lXG4gICAgICAgICAgICB9LCBvcmlnaW4uc291cmNlLCBvcmlnaW4uZmlsZSwgb3B0cy5wbHVnaW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MiA9IG5ldyBDc3NTeW50YXhFcnJvciQxJDEobWVzc2FnZSwgZW5kTGluZSA9PT0gdm9pZCAwID8gbGluZSA6IHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgICAgICBsaW5lOiBsaW5lXG4gICAgICAgICAgICB9LCBlbmRMaW5lID09PSB2b2lkIDAgPyBjb2x1bW4gOiB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBlbmRDb2x1bW4sXG4gICAgICAgICAgICAgICAgbGluZTogZW5kTGluZVxuICAgICAgICAgICAgfSwgdGhpcy5jc3MsIHRoaXMuZmlsZSwgb3B0cy5wbHVnaW4pO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdDIuaW5wdXQgPSB7XG4gICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgIGVuZENvbHVtbjogZW5kQ29sdW1uLFxuICAgICAgICAgICAgZW5kTGluZTogZW5kTGluZSxcbiAgICAgICAgICAgIGxpbmU6IGxpbmUsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuY3NzXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmZpbGUpIHtcbiAgICAgICAgICAgIGlmIChwYXRoVG9GaWxlVVJMJDEkMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIuaW5wdXQudXJsID0gcGF0aFRvRmlsZVVSTCQxJDEodGhpcy5maWxlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0Mi5pbnB1dC5maWxlID0gdGhpcy5maWxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgIH07XG4gICAgX3Byb3RvLmZyb21PZmZzZXQgPSBmdW5jdGlvbiBmcm9tT2Zmc2V0KG9mZnNldCkge1xuICAgICAgICB2YXIgbGFzdExpbmUsIGxpbmVUb0luZGV4O1xuICAgICAgICBpZiAoIXRoaXNbZnJvbU9mZnNldENhY2hlJDFdKSB7XG4gICAgICAgICAgICB2YXIgbGluZXMgPSB0aGlzLmNzcy5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgIGxpbmVUb0luZGV4ID0gbmV3IEFycmF5KGxpbmVzLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgcHJldkluZGV4ID0gMDtcbiAgICAgICAgICAgIGZvcih2YXIgaTIgPSAwLCBsMiA9IGxpbmVzLmxlbmd0aDsgaTIgPCBsMjsgaTIrKyl7XG4gICAgICAgICAgICAgICAgbGluZVRvSW5kZXhbaTJdID0gcHJldkluZGV4O1xuICAgICAgICAgICAgICAgIHByZXZJbmRleCArPSBsaW5lc1tpMl0ubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbZnJvbU9mZnNldENhY2hlJDFdID0gbGluZVRvSW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaW5lVG9JbmRleCA9IHRoaXNbZnJvbU9mZnNldENhY2hlJDFdO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RMaW5lID0gbGluZVRvSW5kZXhbbGluZVRvSW5kZXgubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBtaW4gPSAwO1xuICAgICAgICBpZiAob2Zmc2V0ID49IGxhc3RMaW5lKSB7XG4gICAgICAgICAgICBtaW4gPSBsaW5lVG9JbmRleC5sZW5ndGggLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1heCA9IGxpbmVUb0luZGV4Lmxlbmd0aCAtIDI7XG4gICAgICAgICAgICB2YXIgbWlkO1xuICAgICAgICAgICAgd2hpbGUobWluIDwgbWF4KXtcbiAgICAgICAgICAgICAgICBtaWQgPSBtaW4gKyAobWF4IC0gbWluID4+IDEpO1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPCBsaW5lVG9JbmRleFttaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heCA9IG1pZCAtIDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvZmZzZXQgPj0gbGluZVRvSW5kZXhbbWlkICsgMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gbWlkICsgMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSBtaWQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29sOiBvZmZzZXQgLSBsaW5lVG9JbmRleFttaW5dICsgMSxcbiAgICAgICAgICAgIGxpbmU6IG1pbiArIDFcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIF9wcm90by5tYXBSZXNvbHZlID0gZnVuY3Rpb24gbWFwUmVzb2x2ZShmaWxlKSB7XG4gICAgICAgIGlmICgvXlxcdys6XFwvXFwvLy50ZXN0KGZpbGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZSQxJDEodGhpcy5tYXAuY29uc3VtZXIoKS5zb3VyY2VSb290IHx8IHRoaXMubWFwLnJvb3QgfHwgXCIuXCIsIGZpbGUpO1xuICAgIH07XG4gICAgX3Byb3RvLm9yaWdpbiA9IGZ1bmN0aW9uIG9yaWdpbihsaW5lLCBjb2x1bW4sIGVuZExpbmUsIGVuZENvbHVtbikge1xuICAgICAgICBpZiAoIXRoaXMubWFwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBjb25zdW1lciA9IHRoaXMubWFwLmNvbnN1bWVyKCk7XG4gICAgICAgIHZhciBmcm9tID0gY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgIGxpbmU6IGxpbmVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghZnJvbS5zb3VyY2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIHRvO1xuICAgICAgICBpZiAodHlwZW9mIGVuZExpbmUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRvID0gY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBlbmRDb2x1bW4sXG4gICAgICAgICAgICAgICAgbGluZTogZW5kTGluZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZyb21Vcmw7XG4gICAgICAgIGlmIChpc0Fic29sdXRlJDEoZnJvbS5zb3VyY2UpKSB7XG4gICAgICAgICAgICBmcm9tVXJsID0gcGF0aFRvRmlsZVVSTCQxJDEoZnJvbS5zb3VyY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJvbVVybCA9IG5ldyBVUkwoZnJvbS5zb3VyY2UsIHRoaXMubWFwLmNvbnN1bWVyKCkuc291cmNlUm9vdCB8fCBwYXRoVG9GaWxlVVJMJDEkMSh0aGlzLm1hcC5tYXBGaWxlKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdDIgPSB7XG4gICAgICAgICAgICBjb2x1bW46IGZyb20uY29sdW1uLFxuICAgICAgICAgICAgZW5kQ29sdW1uOiB0byAmJiB0by5jb2x1bW4sXG4gICAgICAgICAgICBlbmRMaW5lOiB0byAmJiB0by5saW5lLFxuICAgICAgICAgICAgbGluZTogZnJvbS5saW5lLFxuICAgICAgICAgICAgdXJsOiBmcm9tVXJsLnRvU3RyaW5nKClcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGZyb21VcmwucHJvdG9jb2wgPT09IFwiZmlsZTpcIikge1xuICAgICAgICAgICAgaWYgKGZpbGVVUkxUb1BhdGgkMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIuZmlsZSA9IGZpbGVVUkxUb1BhdGgkMShmcm9tVXJsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmlsZTogcHJvdG9jb2wgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIFBvc3RDU1MgYnVpbGRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNvdXJjZSA9IGNvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3IoZnJvbS5zb3VyY2UpO1xuICAgICAgICBpZiAoc291cmNlKSByZXN1bHQyLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgfTtcbiAgICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICB2YXIganNvbiA9IHt9O1xuICAgICAgICBmb3IodmFyIF9pID0gMCwgX2l0ZXIgPSBbXG4gICAgICAgICAgICBcImhhc0JPTVwiLFxuICAgICAgICAgICAgXCJjc3NcIixcbiAgICAgICAgICAgIFwiZmlsZVwiLFxuICAgICAgICAgICAgXCJpZFwiXG4gICAgICAgIF07IF9pIDwgX2l0ZXIubGVuZ3RoOyBfaSsrKXtcbiAgICAgICAgICAgIHZhciBuYW1lID0gX2l0ZXJbX2ldO1xuICAgICAgICAgICAgaWYgKHRoaXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGpzb25bbmFtZV0gPSB0aGlzW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hcCkge1xuICAgICAgICAgICAganNvbi5tYXAgPSBfZXh0ZW5kcyh7fSwgdGhpcy5tYXApO1xuICAgICAgICAgICAgaWYgKGpzb24ubWFwLmNvbnN1bWVyQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICBqc29uLm1hcC5jb25zdW1lckNhY2hlID0gdm9pZCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH07XG4gICAgX2NyZWF0ZV9jbGFzcyhJbnB1dCwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbVwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsZSB8fCB0aGlzLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIElucHV0O1xufSgpO1xudmFyIGlucHV0JDEgPSBJbnB1dCQ0JDE7XG5JbnB1dCQ0JDEuZGVmYXVsdCA9IElucHV0JDQkMTtcbmlmICh0ZXJtaW5hbEhpZ2hsaWdodCQyICYmIHRlcm1pbmFsSGlnaGxpZ2h0JDIucmVnaXN0ZXJJbnB1dCkge1xuICAgIHRlcm1pbmFsSGlnaGxpZ2h0JDIucmVnaXN0ZXJJbnB1dChJbnB1dCQ0JDEpO1xufVxudmFyIFNvdXJjZU1hcENvbnN1bWVyJDMgPSByZXF1aXJlJCQyJDEuU291cmNlTWFwQ29uc3VtZXIsIFNvdXJjZU1hcEdlbmVyYXRvciQzID0gcmVxdWlyZSQkMiQxLlNvdXJjZU1hcEdlbmVyYXRvcjtcbnZhciBkaXJuYW1lJDIgPSByZXF1aXJlJCQyJDEuZGlybmFtZSwgcmVsYXRpdmUkMSA9IHJlcXVpcmUkJDIkMS5yZWxhdGl2ZSwgcmVzb2x2ZSQyID0gcmVxdWlyZSQkMiQxLnJlc29sdmUsIHNlcCQxID0gcmVxdWlyZSQkMiQxLnNlcDtcbnZhciBwYXRoVG9GaWxlVVJMJDIgPSByZXF1aXJlJCQyJDEucGF0aFRvRmlsZVVSTDtcbnZhciBJbnB1dCQzJDEgPSBpbnB1dCQxO1xudmFyIHNvdXJjZU1hcEF2YWlsYWJsZSQyID0gQm9vbGVhbihTb3VyY2VNYXBDb25zdW1lciQzICYmIFNvdXJjZU1hcEdlbmVyYXRvciQzKTtcbnZhciBwYXRoQXZhaWxhYmxlJDIgPSBCb29sZWFuKGRpcm5hbWUkMiAmJiByZXNvbHZlJDIgJiYgcmVsYXRpdmUkMSAmJiBzZXAkMSk7XG52YXIgTWFwR2VuZXJhdG9yJDIkMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gTWFwR2VuZXJhdG9yKHN0cmluZ2lmeTIsIHJvb3QyLCBvcHRzLCBjc3NTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zdHJpbmdpZnkgPSBzdHJpbmdpZnkyO1xuICAgICAgICB0aGlzLm1hcE9wdHMgPSBvcHRzLm1hcCB8fCB7fTtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDI7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICAgIHRoaXMuY3NzID0gY3NzU3RyaW5nO1xuICAgICAgICB0aGlzLm9yaWdpbmFsQ1NTID0gY3NzU3RyaW5nO1xuICAgICAgICB0aGlzLnVzZXNGaWxlVXJscyA9ICF0aGlzLm1hcE9wdHMuZnJvbSAmJiB0aGlzLm1hcE9wdHMuYWJzb2x1dGU7XG4gICAgICAgIHRoaXMubWVtb2l6ZWRGaWxlVVJMcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubWVtb2l6ZWRQYXRocyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubWVtb2l6ZWRVUkxzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IE1hcEdlbmVyYXRvci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmFkZEFubm90YXRpb24gPSBmdW5jdGlvbiBhZGRBbm5vdGF0aW9uKCkge1xuICAgICAgICB2YXIgY29udGVudDtcbiAgICAgICAgaWYgKHRoaXMuaXNJbmxpbmUoKSkge1xuICAgICAgICAgICAgY29udGVudCA9IFwiZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIHRoaXMudG9CYXNlNjQodGhpcy5tYXAudG9TdHJpbmcoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gdGhpcy5tYXBPcHRzLmFubm90YXRpb247XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbih0aGlzLm9wdHMudG8sIHRoaXMucm9vdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZW50ID0gdGhpcy5vdXRwdXRGaWxlKCkgKyBcIi5tYXBcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW9sID0gXCJcXG5cIjtcbiAgICAgICAgaWYgKHRoaXMuY3NzLmluY2x1ZGVzKFwiXFxyXFxuXCIpKSBlb2wgPSBcIlxcclxcblwiO1xuICAgICAgICB0aGlzLmNzcyArPSBlb2wgKyBcIi8qIyBzb3VyY2VNYXBwaW5nVVJMPVwiICsgY29udGVudCArIFwiICovXCI7XG4gICAgfTtcbiAgICBfcHJvdG8uYXBwbHlQcmV2TWFwcyA9IGZ1bmN0aW9uIGFwcGx5UHJldk1hcHMoKSB7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHRoaXMucHJldmlvdXMoKSksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICB2YXIgZnJvbSA9IHRoaXMudG9VcmwodGhpcy5wYXRoKHByZXYuZmlsZSkpO1xuICAgICAgICAgICAgdmFyIHJvb3QyID0gcHJldi5yb290IHx8IGRpcm5hbWUkMihwcmV2LmZpbGUpO1xuICAgICAgICAgICAgdmFyIG1hcCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcE9wdHMuc291cmNlc0NvbnRlbnQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgbWFwID0gbmV3IFNvdXJjZU1hcENvbnN1bWVyJDMocHJldi50ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAobWFwLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcC5zb3VyY2VzQ29udGVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXAgPSBwcmV2LmNvbnN1bWVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1hcC5hcHBseVNvdXJjZU1hcChtYXAsIGZyb20sIHRoaXMudG9VcmwodGhpcy5wYXRoKHJvb3QyKSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uY2xlYXJBbm5vdGF0aW9uID0gZnVuY3Rpb24gY2xlYXJBbm5vdGF0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5tYXBPcHRzLmFubm90YXRpb24gPT09IGZhbHNlKSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgIHZhciBub2RlMjtcbiAgICAgICAgICAgIGZvcih2YXIgaTIgPSB0aGlzLnJvb3Qubm9kZXMubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSl7XG4gICAgICAgICAgICAgICAgbm9kZTIgPSB0aGlzLnJvb3Qubm9kZXNbaTJdO1xuICAgICAgICAgICAgICAgIGlmIChub2RlMi50eXBlICE9PSBcImNvbW1lbnRcIikgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUyLnRleHQuaW5kZXhPZihcIiMgc291cmNlTWFwcGluZ1VSTD1cIikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290LnJlbW92ZUNoaWxkKGkyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jc3MpIHtcbiAgICAgICAgICAgIHRoaXMuY3NzID0gdGhpcy5jc3MucmVwbGFjZSgvXFxuKj9cXC9cXCojW1xcU1xcc10qP1xcKlxcLyQvZ20sIFwiXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZ2VuZXJhdGUgPSBmdW5jdGlvbiBnZW5lcmF0ZSgpIHtcbiAgICAgICAgdGhpcy5jbGVhckFubm90YXRpb24oKTtcbiAgICAgICAgaWYgKHBhdGhBdmFpbGFibGUkMiAmJiBzb3VyY2VNYXBBdmFpbGFibGUkMiAmJiB0aGlzLmlzTWFwKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlTWFwKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MiA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLnN0cmluZ2lmeSh0aGlzLnJvb3QsIGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MiArPSBpMjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICByZXN1bHQyXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZ2VuZXJhdGVNYXAgPSBmdW5jdGlvbiBnZW5lcmF0ZU1hcCgpIHtcbiAgICAgICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZVN0cmluZygpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldmlvdXMoKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2aW91cygpWzBdLmNvbnN1bWVyKCk7XG4gICAgICAgICAgICBwcmV2LmZpbGUgPSB0aGlzLm91dHB1dEZpbGUoKTtcbiAgICAgICAgICAgIHRoaXMubWFwID0gU291cmNlTWFwR2VuZXJhdG9yJDMuZnJvbVNvdXJjZU1hcChwcmV2LCB7XG4gICAgICAgICAgICAgICAgaWdub3JlSW52YWxpZE1hcHBpbmc6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYXAgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yJDMoe1xuICAgICAgICAgICAgICAgIGZpbGU6IHRoaXMub3V0cHV0RmlsZSgpLFxuICAgICAgICAgICAgICAgIGlnbm9yZUludmFsaWRNYXBwaW5nOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IDAsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IDFcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbjogMCxcbiAgICAgICAgICAgICAgICAgICAgbGluZTogMVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc291cmNlOiB0aGlzLm9wdHMuZnJvbSA/IHRoaXMudG9VcmwodGhpcy5wYXRoKHRoaXMub3B0cy5mcm9tKSkgOiBcIjxubyBzb3VyY2U+XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzU291cmNlc0NvbnRlbnQoKSkgdGhpcy5zZXRTb3VyY2VzQ29udGVudCgpO1xuICAgICAgICBpZiAodGhpcy5yb290ICYmIHRoaXMucHJldmlvdXMoKS5sZW5ndGggPiAwKSB0aGlzLmFwcGx5UHJldk1hcHMoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNBbm5vdGF0aW9uKCkpIHRoaXMuYWRkQW5ub3RhdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5pc0lubGluZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHRoaXMuY3NzXG4gICAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB0aGlzLmNzcyxcbiAgICAgICAgICAgICAgICB0aGlzLm1hcFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmdlbmVyYXRlU3RyaW5nID0gZnVuY3Rpb24gZ2VuZXJhdGVTdHJpbmcoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY3NzID0gXCJcIjtcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yJDMoe1xuICAgICAgICAgICAgZmlsZTogdGhpcy5vdXRwdXRGaWxlKCksXG4gICAgICAgICAgICBpZ25vcmVJbnZhbGlkTWFwcGluZzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxpbmUgPSAxO1xuICAgICAgICB2YXIgY29sdW1uID0gMTtcbiAgICAgICAgdmFyIG5vU291cmNlID0gXCI8bm8gc291cmNlPlwiO1xuICAgICAgICB2YXIgbWFwcGluZyA9IHtcbiAgICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgICAgIGNvbHVtbjogMCxcbiAgICAgICAgICAgICAgICBsaW5lOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IDAsXG4gICAgICAgICAgICAgICAgbGluZTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNvdXJjZTogXCJcIlxuICAgICAgICB9O1xuICAgICAgICB2YXIgbGluZXMsIGxhc3Q7XG4gICAgICAgIHRoaXMuc3RyaW5naWZ5KHRoaXMucm9vdCwgZnVuY3Rpb24oc3RyLCBub2RlMiwgdHlwZSkge1xuICAgICAgICAgICAgX3RoaXMuY3NzICs9IHN0cjtcbiAgICAgICAgICAgIGlmIChub2RlMiAmJiB0eXBlICE9PSBcImVuZFwiKSB7XG4gICAgICAgICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQubGluZSA9IGxpbmU7XG4gICAgICAgICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQuY29sdW1uID0gY29sdW1uIC0gMTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZTIuc291cmNlICYmIG5vZGUyLnNvdXJjZS5zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IF90aGlzLnNvdXJjZVBhdGgobm9kZTIpO1xuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmxpbmUgPSBub2RlMi5zb3VyY2Uuc3RhcnQubGluZTtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5jb2x1bW4gPSBub2RlMi5zb3VyY2Uuc3RhcnQuY29sdW1uIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubWFwLmFkZE1hcHBpbmcobWFwcGluZyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBub1NvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5saW5lID0gMTtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5jb2x1bW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXAuYWRkTWFwcGluZyhtYXBwaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5lcyA9IHN0ci5tYXRjaCgvXFxuL2cpO1xuICAgICAgICAgICAgaWYgKGxpbmVzKSB7XG4gICAgICAgICAgICAgICAgbGluZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGFzdCA9IHN0ci5sYXN0SW5kZXhPZihcIlxcblwiKTtcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSBzdHIubGVuZ3RoIC0gbGFzdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29sdW1uICs9IHN0ci5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZTIgJiYgdHlwZSAhPT0gXCJzdGFydFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBub2RlMi5wYXJlbnQgfHwge1xuICAgICAgICAgICAgICAgICAgICByYXdzOiB7fVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkbGVzcyA9IG5vZGUyLnR5cGUgPT09IFwiZGVjbFwiIHx8IG5vZGUyLnR5cGUgPT09IFwiYXRydWxlXCIgJiYgIW5vZGUyLm5vZGVzO1xuICAgICAgICAgICAgICAgIGlmICghY2hpbGRsZXNzIHx8IG5vZGUyICE9PSBwLmxhc3QgfHwgcC5yYXdzLnNlbWljb2xvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZTIuc291cmNlICYmIG5vZGUyLnNvdXJjZS5lbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gX3RoaXMuc291cmNlUGF0aChub2RlMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmxpbmUgPSBub2RlMi5zb3VyY2UuZW5kLmxpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmNvbHVtbiA9IG5vZGUyLnNvdXJjZS5lbmQuY29sdW1uIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmxpbmUgPSBsaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQuY29sdW1uID0gY29sdW1uIC0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm1hcC5hZGRNYXBwaW5nKG1hcHBpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBub1NvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwubGluZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmNvbHVtbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZC5saW5lID0gbGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmNvbHVtbiA9IGNvbHVtbiAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXAuYWRkTWFwcGluZyhtYXBwaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8uaXNBbm5vdGF0aW9uID0gZnVuY3Rpb24gaXNBbm5vdGF0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5pc0lubGluZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXBPcHRzLmFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJldmlvdXMoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzKCkuc29tZShmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpMi5hbm5vdGF0aW9uO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBfcHJvdG8uaXNJbmxpbmUgPSBmdW5jdGlvbiBpc0lubGluZSgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuaW5saW5lICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXBPcHRzLmlubGluZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYW5ub3RhdGlvbiA9IHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uO1xuICAgICAgICBpZiAodHlwZW9mIGFubm90YXRpb24gIT09IFwidW5kZWZpbmVkXCIgJiYgYW5ub3RhdGlvbiAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91cygpLnNvbWUoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTIuaW5saW5lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBfcHJvdG8uaXNNYXAgPSBmdW5jdGlvbiBpc01hcCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdHMubWFwICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLm9wdHMubWFwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzKCkubGVuZ3RoID4gMDtcbiAgICB9O1xuICAgIF9wcm90by5pc1NvdXJjZXNDb250ZW50ID0gZnVuY3Rpb24gaXNTb3VyY2VzQ29udGVudCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuc291cmNlc0NvbnRlbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcE9wdHMuc291cmNlc0NvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJldmlvdXMoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzKCkuc29tZShmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpMi53aXRoQ29udGVudCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBfcHJvdG8ub3V0cHV0RmlsZSA9IGZ1bmN0aW9uIG91dHB1dEZpbGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdHMudG8pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhdGgodGhpcy5vcHRzLnRvKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdHMuZnJvbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGF0aCh0aGlzLm9wdHMuZnJvbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ0by5jc3NcIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnBhdGggPSBmdW5jdGlvbiBwYXRoKGZpbGUpIHtcbiAgICAgICAgaWYgKHRoaXMubWFwT3B0cy5hYnNvbHV0ZSkgcmV0dXJuIGZpbGU7XG4gICAgICAgIGlmIChmaWxlLmNoYXJDb2RlQXQoMCkgPT09IDYwKSByZXR1cm4gZmlsZTtcbiAgICAgICAgaWYgKC9eXFx3KzpcXC9cXC8vLnRlc3QoZmlsZSkpIHJldHVybiBmaWxlO1xuICAgICAgICB2YXIgY2FjaGVkID0gdGhpcy5tZW1vaXplZFBhdGhzLmdldChmaWxlKTtcbiAgICAgICAgaWYgKGNhY2hlZCkgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgdmFyIGZyb20gPSB0aGlzLm9wdHMudG8gPyBkaXJuYW1lJDIodGhpcy5vcHRzLnRvKSA6IFwiLlwiO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBmcm9tID0gZGlybmFtZSQyKHJlc29sdmUkMihmcm9tLCB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXRoID0gcmVsYXRpdmUkMShmcm9tLCBmaWxlKTtcbiAgICAgICAgdGhpcy5tZW1vaXplZFBhdGhzLnNldChmaWxlLCBwYXRoKTtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfTtcbiAgICBfcHJvdG8ucHJldmlvdXMgPSBmdW5jdGlvbiBwcmV2aW91cygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnByZXZpb3VzTWFwcykge1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c01hcHMgPSBbXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3Qud2FsayhmdW5jdGlvbihub2RlMikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZTIuc291cmNlICYmIG5vZGUyLnNvdXJjZS5pbnB1dC5tYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXAgPSBub2RlMi5zb3VyY2UuaW5wdXQubWFwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5wcmV2aW91c01hcHMuaW5jbHVkZXMobWFwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnByZXZpb3VzTWFwcy5wdXNoKG1hcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0MiA9IG5ldyBJbnB1dCQzJDEodGhpcy5vcmlnaW5hbENTUywgdGhpcy5vcHRzKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQyLm1hcCkgdGhpcy5wcmV2aW91c01hcHMucHVzaChpbnB1dDIubWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91c01hcHM7XG4gICAgfTtcbiAgICBfcHJvdG8uc2V0U291cmNlc0NvbnRlbnQgPSBmdW5jdGlvbiBzZXRTb3VyY2VzQ29udGVudCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFscmVhZHkgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgICAgICAgdGhpcy5yb290LndhbGsoZnVuY3Rpb24obm9kZTIpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZTIuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmcm9tID0gbm9kZTIuc291cmNlLmlucHV0LmZyb207XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcm9tICYmICFhbHJlYWR5W2Zyb21dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHJlYWR5W2Zyb21dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcm9tVXJsID0gX3RoaXMudXNlc0ZpbGVVcmxzID8gX3RoaXMudG9GaWxlVXJsKGZyb20pIDogX3RoaXMudG9VcmwoX3RoaXMucGF0aChmcm9tKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXAuc2V0U291cmNlQ29udGVudChmcm9tVXJsLCBub2RlMi5zb3VyY2UuaW5wdXQuY3NzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY3NzKSB7XG4gICAgICAgICAgICB2YXIgZnJvbSA9IHRoaXMub3B0cy5mcm9tID8gdGhpcy50b1VybCh0aGlzLnBhdGgodGhpcy5vcHRzLmZyb20pKSA6IFwiPG5vIHNvdXJjZT5cIjtcbiAgICAgICAgICAgIHRoaXMubWFwLnNldFNvdXJjZUNvbnRlbnQoZnJvbSwgdGhpcy5jc3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uc291cmNlUGF0aCA9IGZ1bmN0aW9uIHNvdXJjZVBhdGgobm9kZTIpIHtcbiAgICAgICAgaWYgKHRoaXMubWFwT3B0cy5mcm9tKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b1VybCh0aGlzLm1hcE9wdHMuZnJvbSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy51c2VzRmlsZVVybHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvRmlsZVVybChub2RlMi5zb3VyY2UuaW5wdXQuZnJvbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b1VybCh0aGlzLnBhdGgobm9kZTIuc291cmNlLmlucHV0LmZyb20pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnRvQmFzZTY0ID0gZnVuY3Rpb24gdG9CYXNlNjQoc3RyKSB7XG4gICAgICAgIGlmIChCdWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5idG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by50b0ZpbGVVcmwgPSBmdW5jdGlvbiB0b0ZpbGVVcmwocGF0aCkge1xuICAgICAgICB2YXIgY2FjaGVkID0gdGhpcy5tZW1vaXplZEZpbGVVUkxzLmdldChwYXRoKTtcbiAgICAgICAgaWYgKGNhY2hlZCkgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgaWYgKHBhdGhUb0ZpbGVVUkwkMikge1xuICAgICAgICAgICAgdmFyIGZpbGVVUkwgPSBwYXRoVG9GaWxlVVJMJDIocGF0aCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMubWVtb2l6ZWRGaWxlVVJMcy5zZXQocGF0aCwgZmlsZVVSTCk7XG4gICAgICAgICAgICByZXR1cm4gZmlsZVVSTDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImBtYXAuYWJzb2x1dGVgIG9wdGlvbiBpcyBub3QgYXZhaWxhYmxlIGluIHRoaXMgUG9zdENTUyBidWlsZFwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnRvVXJsID0gZnVuY3Rpb24gdG9VcmwocGF0aCkge1xuICAgICAgICB2YXIgY2FjaGVkID0gdGhpcy5tZW1vaXplZFVSTHMuZ2V0KHBhdGgpO1xuICAgICAgICBpZiAoY2FjaGVkKSByZXR1cm4gY2FjaGVkO1xuICAgICAgICBpZiAoc2VwJDEgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXJsID0gZW5jb2RlVVJJKHBhdGgpLnJlcGxhY2UoL1sjP10vZywgZW5jb2RlVVJJQ29tcG9uZW50KTtcbiAgICAgICAgdGhpcy5tZW1vaXplZFVSTHMuc2V0KHBhdGgsIHVybCk7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfTtcbiAgICByZXR1cm4gTWFwR2VuZXJhdG9yO1xufSgpO1xudmFyIG1hcEdlbmVyYXRvciQxID0gTWFwR2VuZXJhdG9yJDIkMTtcbnZhciBOb2RlJDIkMSA9IG5vZGUkMTtcbnZhciBDb21tZW50JDQkMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oTm9kZSQyJDEpIHtcbiAgICBfaW5oZXJpdHMoQ29tbWVudCwgTm9kZSQyJDEpO1xuICAgIGZ1bmN0aW9uIENvbW1lbnQoZGVmYXVsdHMpIHtcbiAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICBfdGhpcyA9IE5vZGUkMiQxLmNhbGwodGhpcywgZGVmYXVsdHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSBcImNvbW1lbnRcIjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ29tbWVudDtcbn0oTm9kZSQyJDEpO1xudmFyIGNvbW1lbnQkMSA9IENvbW1lbnQkNCQxO1xuQ29tbWVudCQ0JDEuZGVmYXVsdCA9IENvbW1lbnQkNCQxO1xudmFyIGlzQ2xlYW4kMSQxID0gc3ltYm9scyQxLmlzQ2xlYW4sIG15JDEkMSA9IHN5bWJvbHMkMS5teTtcbnZhciBEZWNsYXJhdGlvbiQzJDEgPSBkZWNsYXJhdGlvbiQxO1xudmFyIENvbW1lbnQkMyQxID0gY29tbWVudCQxO1xudmFyIE5vZGUkMSQxID0gbm9kZSQxO1xudmFyIHBhcnNlJDQkMSwgUnVsZSQ0JDEsIEF0UnVsZSQ0JDEsIFJvb3QkNiQxO1xuZnVuY3Rpb24gY2xlYW5Tb3VyY2UkMShub2Rlcykge1xuICAgIHJldHVybiBub2Rlcy5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgaWYgKGkyLm5vZGVzKSBpMi5ub2RlcyA9IGNsZWFuU291cmNlJDEoaTIubm9kZXMpO1xuICAgICAgICBkZWxldGUgaTIuc291cmNlO1xuICAgICAgICByZXR1cm4gaTI7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBtYXJrRGlydHlVcCQxKG5vZGUyKSB7XG4gICAgbm9kZTJbaXNDbGVhbiQxJDFdID0gZmFsc2U7XG4gICAgaWYgKG5vZGUyLnByb3h5T2Yubm9kZXMpIHtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uobm9kZTIucHJveHlPZi5ub2RlcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBpMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgbWFya0RpcnR5VXAkMShpMik7XG4gICAgICAgIH1cbiAgICB9XG59XG52YXIgQ29udGFpbmVyJDckMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oTm9kZSQxJDEpIHtcbiAgICBfaW5oZXJpdHMoQ29udGFpbmVyLCBOb2RlJDEkMSk7XG4gICAgZnVuY3Rpb24gQ29udGFpbmVyKCkge1xuICAgICAgICByZXR1cm4gTm9kZSQxJDEuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gQ29udGFpbmVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBjaGlsZHJlbiA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgY2hpbGRyZW5bX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UoY2hpbGRyZW4pLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIHZhciBub2RlcyA9IHRoaXMubm9ybWFsaXplKGNoaWxkLCB0aGlzLmxhc3QpO1xuICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IxID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKG5vZGVzKSwgX3N0ZXAxOyAhKF9zdGVwMSA9IF9pdGVyYXRvcjEoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgIHZhciBub2RlMiA9IF9zdGVwMS52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3h5T2Yubm9kZXMucHVzaChub2RlMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8uY2xlYW5SYXdzID0gZnVuY3Rpb24gY2xlYW5SYXdzKGtlZXBCZXR3ZWVuKSB7XG4gICAgICAgIE5vZGUkMSQxLnByb3RvdHlwZS5jbGVhblJhd3MuY2FsbCh0aGlzLCBrZWVwQmV0d2Vlbik7XG4gICAgICAgIGlmICh0aGlzLm5vZGVzKSB7XG4gICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZSh0aGlzLm5vZGVzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgIHZhciBub2RlMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgIG5vZGUyLmNsZWFuUmF3cyhrZWVwQmV0d2Vlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5lYWNoID0gZnVuY3Rpb24gZWFjaChjYWxsYmFjaykge1xuICAgICAgICBpZiAoIXRoaXMucHJveHlPZi5ub2RlcykgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5nZXRJdGVyYXRvcigpO1xuICAgICAgICB2YXIgaW5kZXgyLCByZXN1bHQyO1xuICAgICAgICB3aGlsZSh0aGlzLmluZGV4ZXNbaXRlcmF0b3JdIDwgdGhpcy5wcm94eU9mLm5vZGVzLmxlbmd0aCl7XG4gICAgICAgICAgICBpbmRleDIgPSB0aGlzLmluZGV4ZXNbaXRlcmF0b3JdO1xuICAgICAgICAgICAgcmVzdWx0MiA9IGNhbGxiYWNrKHRoaXMucHJveHlPZi5ub2Rlc1tpbmRleDJdLCBpbmRleDIpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDIgPT09IGZhbHNlKSBicmVhaztcbiAgICAgICAgICAgIHRoaXMuaW5kZXhlc1tpdGVyYXRvcl0gKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5pbmRleGVzW2l0ZXJhdG9yXTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgfTtcbiAgICBfcHJvdG8uZXZlcnkgPSBmdW5jdGlvbiBldmVyeShjb25kaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXMuZXZlcnkoY29uZGl0aW9uKTtcbiAgICB9O1xuICAgIF9wcm90by5nZXRJdGVyYXRvciA9IGZ1bmN0aW9uIGdldEl0ZXJhdG9yKCkge1xuICAgICAgICBpZiAoIXRoaXMubGFzdEVhY2gpIHRoaXMubGFzdEVhY2ggPSAwO1xuICAgICAgICBpZiAoIXRoaXMuaW5kZXhlcykgdGhpcy5pbmRleGVzID0ge307XG4gICAgICAgIHRoaXMubGFzdEVhY2ggKz0gMTtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5sYXN0RWFjaDtcbiAgICAgICAgdGhpcy5pbmRleGVzW2l0ZXJhdG9yXSA9IDA7XG4gICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9O1xuICAgIF9wcm90by5nZXRQcm94eVByb2Nlc3NvciA9IGZ1bmN0aW9uIGdldFByb3h5UHJvY2Vzc29yKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQobm9kZTIsIHByb3ApIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0gXCJwcm94eU9mXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIW5vZGUyW3Byb3BdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlMltwcm9wXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09IFwiZWFjaFwiIHx8IHR5cGVvZiBwcm9wID09PSBcInN0cmluZ1wiICYmIHByb3Auc3RhcnRzV2l0aChcIndhbGtcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX25vZGUyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfbm9kZTIgPSBub2RlMilbcHJvcF0uYXBwbHkoX25vZGUyLCBbXS5jb25jYXQoYXJncy5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNoaWxkLCBpbmRleDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpMihjaGlsZC50b1Byb3h5KCksIGluZGV4Mik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBcImV2ZXJ5XCIgfHwgcHJvcCA9PT0gXCJzb21lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTJbcHJvcF0oZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBvdGhlciA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IuYXBwbHkodm9pZCAwLCBbXS5jb25jYXQoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC50b1Byb3h5KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLCBvdGhlcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBcInJvb3RcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTIucm9vdCgpLnRvUHJveHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09IFwibm9kZXNcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTIubm9kZXMubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTIudG9Qcm94eSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09IFwiZmlyc3RcIiB8fCBwcm9wID09PSBcImxhc3RcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTJbcHJvcF0udG9Qcm94eSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlMltwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobm9kZTIsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUyW3Byb3BdID09PSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgbm9kZTJbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0gXCJuYW1lXCIgfHwgcHJvcCA9PT0gXCJwYXJhbXNcIiB8fCBwcm9wID09PSBcInNlbGVjdG9yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTIubWFya0RpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLmluZGV4ID0gZnVuY3Rpb24gaW5kZXgoY2hpbGQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIGNoaWxkO1xuICAgICAgICBpZiAoY2hpbGQucHJveHlPZikgY2hpbGQgPSBjaGlsZC5wcm94eU9mO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm94eU9mLm5vZGVzLmluZGV4T2YoY2hpbGQpO1xuICAgIH07XG4gICAgX3Byb3RvLmluc2VydEFmdGVyID0gZnVuY3Rpb24gaW5zZXJ0QWZ0ZXIoZXhpc3QsIGFkZCkge1xuICAgICAgICB2YXIgZXhpc3RJbmRleCA9IHRoaXMuaW5kZXgoZXhpc3QpO1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vcm1hbGl6ZShhZGQsIHRoaXMucHJveHlPZi5ub2Rlc1tleGlzdEluZGV4XSkucmV2ZXJzZSgpO1xuICAgICAgICBleGlzdEluZGV4ID0gdGhpcy5pbmRleChleGlzdCk7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKG5vZGVzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIG5vZGUyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICB0aGlzLnByb3h5T2Yubm9kZXMuc3BsaWNlKGV4aXN0SW5kZXggKyAxLCAwLCBub2RlMik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4MjtcbiAgICAgICAgZm9yKHZhciBpZCBpbiB0aGlzLmluZGV4ZXMpe1xuICAgICAgICAgICAgaW5kZXgyID0gdGhpcy5pbmRleGVzW2lkXTtcbiAgICAgICAgICAgIGlmIChleGlzdEluZGV4IDwgaW5kZXgyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleGVzW2lkXSA9IGluZGV4MiArIG5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90by5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiBpbnNlcnRCZWZvcmUoZXhpc3QsIGFkZCkge1xuICAgICAgICB2YXIgZXhpc3RJbmRleCA9IHRoaXMuaW5kZXgoZXhpc3QpO1xuICAgICAgICB2YXIgdHlwZSA9IGV4aXN0SW5kZXggPT09IDAgPyBcInByZXBlbmRcIiA6IGZhbHNlO1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vcm1hbGl6ZShhZGQsIHRoaXMucHJveHlPZi5ub2Rlc1tleGlzdEluZGV4XSwgdHlwZSkucmV2ZXJzZSgpO1xuICAgICAgICBleGlzdEluZGV4ID0gdGhpcy5pbmRleChleGlzdCk7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKG5vZGVzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIG5vZGUyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICB0aGlzLnByb3h5T2Yubm9kZXMuc3BsaWNlKGV4aXN0SW5kZXgsIDAsIG5vZGUyKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXgyO1xuICAgICAgICBmb3IodmFyIGlkIGluIHRoaXMuaW5kZXhlcyl7XG4gICAgICAgICAgICBpbmRleDIgPSB0aGlzLmluZGV4ZXNbaWRdO1xuICAgICAgICAgICAgaWYgKGV4aXN0SW5kZXggPD0gaW5kZXgyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleGVzW2lkXSA9IGluZGV4MiArIG5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90by5ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUobm9kZXMsIHNhbXBsZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIG5vZGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBub2RlcyA9IGNsZWFuU291cmNlJDEocGFyc2UkNCQxKG5vZGVzKS5ub2Rlcyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBub2RlcyA9IFtdO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobm9kZXMpKSB7XG4gICAgICAgICAgICBub2RlcyA9IG5vZGVzLnNsaWNlKDApO1xuICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uobm9kZXMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgdmFyIGkyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGkyLnBhcmVudCkgaTIucGFyZW50LnJlbW92ZUNoaWxkKGkyLCBcImlnbm9yZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChub2Rlcy50eXBlID09PSBcInJvb3RcIiAmJiB0aGlzLnR5cGUgIT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICAgICAgbm9kZXMgPSBub2Rlcy5ub2Rlcy5zbGljZSgwKTtcbiAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yMSA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShub2RlcyksIF9zdGVwMTsgIShfc3RlcDEgPSBfaXRlcmF0b3IxKCkpLmRvbmU7KXtcbiAgICAgICAgICAgICAgICB2YXIgaTIxID0gX3N0ZXAxLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChpMjEucGFyZW50KSBpMjEucGFyZW50LnJlbW92ZUNoaWxkKGkyMSwgXCJpZ25vcmVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZXMudHlwZSkge1xuICAgICAgICAgICAgbm9kZXMgPSBbXG4gICAgICAgICAgICAgICAgbm9kZXNcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZXMucHJvcCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBub2Rlcy52YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbHVlIGZpZWxkIGlzIG1pc3NlZCBpbiBub2RlIGNyZWF0aW9uXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZXMudmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBub2Rlcy52YWx1ZSA9IFN0cmluZyhub2Rlcy52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlcyA9IFtcbiAgICAgICAgICAgICAgICBuZXcgRGVjbGFyYXRpb24kMyQxKG5vZGVzKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIGlmIChub2Rlcy5zZWxlY3Rvcikge1xuICAgICAgICAgICAgbm9kZXMgPSBbXG4gICAgICAgICAgICAgICAgbmV3IFJ1bGUkNCQxKG5vZGVzKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIGlmIChub2Rlcy5uYW1lKSB7XG4gICAgICAgICAgICBub2RlcyA9IFtcbiAgICAgICAgICAgICAgICBuZXcgQXRSdWxlJDQkMShub2RlcylcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZXMudGV4dCkge1xuICAgICAgICAgICAgbm9kZXMgPSBbXG4gICAgICAgICAgICAgICAgbmV3IENvbW1lbnQkMyQxKG5vZGVzKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbm9kZSB0eXBlIGluIG5vZGUgY3JlYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb2Nlc3NlZCA9IG5vZGVzLm1hcChmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgaWYgKCFpMltteSQxJDFdKSBDb250YWluZXIucmVidWlsZChpMik7XG4gICAgICAgICAgICBpMiA9IGkyLnByb3h5T2Y7XG4gICAgICAgICAgICBpZiAoaTIucGFyZW50KSBpMi5wYXJlbnQucmVtb3ZlQ2hpbGQoaTIpO1xuICAgICAgICAgICAgaWYgKGkyW2lzQ2xlYW4kMSQxXSkgbWFya0RpcnR5VXAkMShpMik7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmVmb3JlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNhbXBsZSAmJiB0eXBlb2Ygc2FtcGxlLnJhd3MuYmVmb3JlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGkyLnJhd3MuYmVmb3JlID0gc2FtcGxlLnJhd3MuYmVmb3JlLnJlcGxhY2UoL1xcUy9nLCBcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpMi5wYXJlbnQgPSBfdGhpcy5wcm94eU9mO1xuICAgICAgICAgICAgcmV0dXJuIGkyO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZDtcbiAgICB9O1xuICAgIF9wcm90by5wcmVwZW5kID0gZnVuY3Rpb24gcHJlcGVuZCgpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgY2hpbGRyZW4gPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIGNoaWxkcmVuW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW4ucmV2ZXJzZSgpO1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShjaGlsZHJlbiksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub3JtYWxpemUoY2hpbGQsIHRoaXMuZmlyc3QsIFwicHJlcGVuZFwiKS5yZXZlcnNlKCk7XG4gICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvcjEgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uobm9kZXMpLCBfc3RlcDE7ICEoX3N0ZXAxID0gX2l0ZXJhdG9yMSgpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUyID0gX3N0ZXAxLnZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMucHJveHlPZi5ub2Rlcy51bnNoaWZ0KG5vZGUyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcih2YXIgaWQgaW4gdGhpcy5pbmRleGVzKXtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4ZXNbaWRdID0gdGhpcy5pbmRleGVzW2lkXSArIG5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90by5wdXNoID0gZnVuY3Rpb24gcHVzaChjaGlsZCkge1xuICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICB0aGlzLnByb3h5T2Yubm9kZXMucHVzaChjaGlsZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLnJlbW92ZUFsbCA9IGZ1bmN0aW9uIHJlbW92ZUFsbCgpIHtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UodGhpcy5wcm94eU9mLm5vZGVzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIG5vZGUyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICBub2RlMi5wYXJlbnQgPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm94eU9mLm5vZGVzID0gW107XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGQoY2hpbGQpIHtcbiAgICAgICAgY2hpbGQgPSB0aGlzLmluZGV4KGNoaWxkKTtcbiAgICAgICAgdGhpcy5wcm94eU9mLm5vZGVzW2NoaWxkXS5wYXJlbnQgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMucHJveHlPZi5ub2Rlcy5zcGxpY2UoY2hpbGQsIDEpO1xuICAgICAgICB2YXIgaW5kZXgyO1xuICAgICAgICBmb3IodmFyIGlkIGluIHRoaXMuaW5kZXhlcyl7XG4gICAgICAgICAgICBpbmRleDIgPSB0aGlzLmluZGV4ZXNbaWRdO1xuICAgICAgICAgICAgaWYgKGluZGV4MiA+PSBjaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhlc1tpZF0gPSBpbmRleDIgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLnJlcGxhY2VWYWx1ZXMgPSBmdW5jdGlvbiByZXBsYWNlVmFsdWVzKHBhdHRlcm4sIG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICAgICAgICAgIG9wdHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhbGtEZWNscyhmdW5jdGlvbihkZWNsKSB7XG4gICAgICAgICAgICBpZiAob3B0cy5wcm9wcyAmJiAhb3B0cy5wcm9wcy5pbmNsdWRlcyhkZWNsLnByb3ApKSByZXR1cm47XG4gICAgICAgICAgICBpZiAob3B0cy5mYXN0ICYmICFkZWNsLnZhbHVlLmluY2x1ZGVzKG9wdHMuZmFzdCkpIHJldHVybjtcbiAgICAgICAgICAgIGRlY2wudmFsdWUgPSBkZWNsLnZhbHVlLnJlcGxhY2UocGF0dGVybiwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8uc29tZSA9IGZ1bmN0aW9uIHNvbWUoY29uZGl0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLnNvbWUoY29uZGl0aW9uKTtcbiAgICB9O1xuICAgIF9wcm90by53YWxrID0gZnVuY3Rpb24gd2FsayhjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGNoaWxkLCBpMikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDI7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjaGlsZC5hZGRUb0Vycm9yKGUyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBmYWxzZSAmJiBjaGlsZC53YWxrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MiA9IGNoaWxkLndhbGsoY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLndhbGtBdFJ1bGVzID0gZnVuY3Rpb24gd2Fsa0F0UnVsZXMobmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBuYW1lO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJhdHJ1bGVcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2luc3RhbmNlb2YobmFtZSwgUmVnRXhwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJhdHJ1bGVcIiAmJiBuYW1lLnRlc3QoY2hpbGQubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImF0cnVsZVwiICYmIGNoaWxkLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8ud2Fsa0NvbW1lbnRzID0gZnVuY3Rpb24gd2Fsa0NvbW1lbnRzKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJjb21tZW50XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8ud2Fsa0RlY2xzID0gZnVuY3Rpb24gd2Fsa0RlY2xzKHByb3AsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gcHJvcDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfaW5zdGFuY2VvZihwcm9wLCBSZWdFeHApKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53YWxrKGZ1bmN0aW9uKGNoaWxkLCBpMikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImRlY2xcIiAmJiBwcm9wLnRlc3QoY2hpbGQucHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImRlY2xcIiAmJiBjaGlsZC5wcm9wID09PSBwcm9wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLndhbGtSdWxlcyA9IGZ1bmN0aW9uIHdhbGtSdWxlcyhzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBzZWxlY3RvcjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwicnVsZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfaW5zdGFuY2VvZihzZWxlY3RvciwgUmVnRXhwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJydWxlXCIgJiYgc2VsZWN0b3IudGVzdChjaGlsZC5zZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcInJ1bGVcIiAmJiBjaGlsZC5zZWxlY3RvciA9PT0gc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfY3JlYXRlX2NsYXNzKENvbnRhaW5lciwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZmlyc3RcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wcm94eU9mLm5vZGVzKSByZXR1cm4gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3h5T2Yubm9kZXNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJsYXN0XCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHJveHlPZi5ub2RlcykgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm94eU9mLm5vZGVzW3RoaXMucHJveHlPZi5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBDb250YWluZXI7XG59KE5vZGUkMSQxKTtcbkNvbnRhaW5lciQ3JDEucmVnaXN0ZXJQYXJzZSA9IGZ1bmN0aW9uKGRlcGVuZGFudCkge1xuICAgIHBhcnNlJDQkMSA9IGRlcGVuZGFudDtcbn07XG5Db250YWluZXIkNyQxLnJlZ2lzdGVyUnVsZSA9IGZ1bmN0aW9uKGRlcGVuZGFudCkge1xuICAgIFJ1bGUkNCQxID0gZGVwZW5kYW50O1xufTtcbkNvbnRhaW5lciQ3JDEucmVnaXN0ZXJBdFJ1bGUgPSBmdW5jdGlvbihkZXBlbmRhbnQpIHtcbiAgICBBdFJ1bGUkNCQxID0gZGVwZW5kYW50O1xufTtcbkNvbnRhaW5lciQ3JDEucmVnaXN0ZXJSb290ID0gZnVuY3Rpb24oZGVwZW5kYW50KSB7XG4gICAgUm9vdCQ2JDEgPSBkZXBlbmRhbnQ7XG59O1xudmFyIGNvbnRhaW5lciQxID0gQ29udGFpbmVyJDckMTtcbkNvbnRhaW5lciQ3JDEuZGVmYXVsdCA9IENvbnRhaW5lciQ3JDE7XG5Db250YWluZXIkNyQxLnJlYnVpbGQgPSBmdW5jdGlvbihub2RlMikge1xuICAgIGlmIChub2RlMi50eXBlID09PSBcImF0cnVsZVwiKSB7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihub2RlMiwgQXRSdWxlJDQkMS5wcm90b3R5cGUpO1xuICAgIH0gZWxzZSBpZiAobm9kZTIudHlwZSA9PT0gXCJydWxlXCIpIHtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5vZGUyLCBSdWxlJDQkMS5wcm90b3R5cGUpO1xuICAgIH0gZWxzZSBpZiAobm9kZTIudHlwZSA9PT0gXCJkZWNsXCIpIHtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5vZGUyLCBEZWNsYXJhdGlvbiQzJDEucHJvdG90eXBlKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihub2RlMiwgQ29tbWVudCQzJDEucHJvdG90eXBlKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwicm9vdFwiKSB7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihub2RlMiwgUm9vdCQ2JDEucHJvdG90eXBlKTtcbiAgICB9XG4gICAgbm9kZTJbbXkkMSQxXSA9IHRydWU7XG4gICAgaWYgKG5vZGUyLm5vZGVzKSB7XG4gICAgICAgIG5vZGUyLm5vZGVzLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgIENvbnRhaW5lciQ3JDEucmVidWlsZChjaGlsZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG52YXIgQ29udGFpbmVyJDYkMSA9IGNvbnRhaW5lciQxO1xudmFyIExhenlSZXN1bHQkNCQxLCBQcm9jZXNzb3IkMyQxO1xudmFyIERvY3VtZW50JDMkMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oQ29udGFpbmVyJDYkMSkge1xuICAgIF9pbmhlcml0cyhEb2N1bWVudDIsIENvbnRhaW5lciQ2JDEpO1xuICAgIGZ1bmN0aW9uIERvY3VtZW50MihkZWZhdWx0cykge1xuICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgIF90aGlzID0gQ29udGFpbmVyJDYkMS5jYWxsKHRoaXMsIF9leHRlbmRzKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZG9jdW1lbnRcIlxuICAgICAgICB9LCBkZWZhdWx0cykpIHx8IHRoaXM7XG4gICAgICAgIGlmICghX3RoaXMubm9kZXMpIHtcbiAgICAgICAgICAgIF90aGlzLm5vZGVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gRG9jdW1lbnQyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8udG9SZXN1bHQgPSBmdW5jdGlvbiB0b1Jlc3VsdChvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzID09PSB2b2lkIDApIG9wdHMgPSB7fTtcbiAgICAgICAgdmFyIGxhenkgPSBuZXcgTGF6eVJlc3VsdCQ0JDEobmV3IFByb2Nlc3NvciQzJDEoKSwgdGhpcywgb3B0cyk7XG4gICAgICAgIHJldHVybiBsYXp5LnN0cmluZ2lmeSgpO1xuICAgIH07XG4gICAgcmV0dXJuIERvY3VtZW50Mjtcbn0oQ29udGFpbmVyJDYkMSk7XG5Eb2N1bWVudCQzJDEucmVnaXN0ZXJMYXp5UmVzdWx0ID0gZnVuY3Rpb24oZGVwZW5kYW50KSB7XG4gICAgTGF6eVJlc3VsdCQ0JDEgPSBkZXBlbmRhbnQ7XG59O1xuRG9jdW1lbnQkMyQxLnJlZ2lzdGVyUHJvY2Vzc29yID0gZnVuY3Rpb24oZGVwZW5kYW50KSB7XG4gICAgUHJvY2Vzc29yJDMkMSA9IGRlcGVuZGFudDtcbn07XG52YXIgZG9jdW1lbnQkMSQxID0gRG9jdW1lbnQkMyQxO1xuRG9jdW1lbnQkMyQxLmRlZmF1bHQgPSBEb2N1bWVudCQzJDE7XG52YXIgcHJpbnRlZCQxID0ge307XG52YXIgd2Fybk9uY2UkMiQxID0gZnVuY3Rpb24gd2Fybk9uY2UobWVzc2FnZSkge1xuICAgIGlmIChwcmludGVkJDFbbWVzc2FnZV0pIHJldHVybjtcbiAgICBwcmludGVkJDFbbWVzc2FnZV0gPSB0cnVlO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH1cbn07XG52YXIgV2FybmluZyQyJDEgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFdhcm5pbmcodGV4dCwgb3B0cykge1xuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSBvcHRzID0ge307XG4gICAgICAgIHRoaXMudHlwZSA9IFwid2FybmluZ1wiO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICBpZiAob3B0cy5ub2RlICYmIG9wdHMubm9kZS5zb3VyY2UpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IG9wdHMubm9kZS5yYW5nZUJ5KG9wdHMpO1xuICAgICAgICAgICAgdGhpcy5saW5lID0gcmFuZ2Uuc3RhcnQubGluZTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uID0gcmFuZ2Uuc3RhcnQuY29sdW1uO1xuICAgICAgICAgICAgdGhpcy5lbmRMaW5lID0gcmFuZ2UuZW5kLmxpbmU7XG4gICAgICAgICAgICB0aGlzLmVuZENvbHVtbiA9IHJhbmdlLmVuZC5jb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHZhciBvcHQgaW4gb3B0cyl0aGlzW29wdF0gPSBvcHRzW29wdF07XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBXYXJuaW5nLnByb3RvdHlwZTtcbiAgICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5lcnJvcih0aGlzLnRleHQsIHtcbiAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCxcbiAgICAgICAgICAgICAgICBwbHVnaW46IHRoaXMucGx1Z2luLFxuICAgICAgICAgICAgICAgIHdvcmQ6IHRoaXMud29yZFxuICAgICAgICAgICAgfSkubWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wbHVnaW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBsdWdpbiArIFwiOiBcIiArIHRoaXMudGV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50ZXh0O1xuICAgIH07XG4gICAgcmV0dXJuIFdhcm5pbmc7XG59KCk7XG52YXIgd2FybmluZyQxID0gV2FybmluZyQyJDE7XG5XYXJuaW5nJDIkMS5kZWZhdWx0ID0gV2FybmluZyQyJDE7XG52YXIgV2FybmluZyQxJDEgPSB3YXJuaW5nJDE7XG52YXIgUmVzdWx0JDMkMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gUmVzdWx0KHByb2Nlc3NvcjIsIHJvb3QyLCBvcHRzKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc29yID0gcHJvY2Vzc29yMjtcbiAgICAgICAgdGhpcy5tZXNzYWdlcyA9IFtdO1xuICAgICAgICB0aGlzLnJvb3QgPSByb290MjtcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICAgICAgdGhpcy5jc3MgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMubWFwID0gdm9pZCAwO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gUmVzdWx0LnByb3RvdHlwZTtcbiAgICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3NzO1xuICAgIH07XG4gICAgX3Byb3RvLndhcm4gPSBmdW5jdGlvbiB3YXJuKHRleHQsIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgb3B0cyA9IHt9O1xuICAgICAgICBpZiAoIW9wdHMucGx1Z2luKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0UGx1Z2luICYmIHRoaXMubGFzdFBsdWdpbi5wb3N0Y3NzUGx1Z2luKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5wbHVnaW4gPSB0aGlzLmxhc3RQbHVnaW4ucG9zdGNzc1BsdWdpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgd2FybmluZzIgPSBuZXcgV2FybmluZyQxJDEodGV4dCwgb3B0cyk7XG4gICAgICAgIHRoaXMubWVzc2FnZXMucHVzaCh3YXJuaW5nMik7XG4gICAgICAgIHJldHVybiB3YXJuaW5nMjtcbiAgICB9O1xuICAgIF9wcm90by53YXJuaW5ncyA9IGZ1bmN0aW9uIHdhcm5pbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlcy5maWx0ZXIoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIHJldHVybiBpMi50eXBlID09PSBcIndhcm5pbmdcIjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfY3JlYXRlX2NsYXNzKFJlc3VsdCwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY29udGVudFwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3NzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIFJlc3VsdDtcbn0oKTtcbnZhciByZXN1bHQkMSA9IFJlc3VsdCQzJDE7XG5SZXN1bHQkMyQxLmRlZmF1bHQgPSBSZXN1bHQkMyQxO1xudmFyIFNJTkdMRV9RVU9URSQxID0gXCInXCIuY2hhckNvZGVBdCgwKTtcbnZhciBET1VCTEVfUVVPVEUkMSA9ICdcIicuY2hhckNvZGVBdCgwKTtcbnZhciBCQUNLU0xBU0gkMSA9IFwiXFxcXFwiLmNoYXJDb2RlQXQoMCk7XG52YXIgU0xBU0gkMSA9IFwiL1wiLmNoYXJDb2RlQXQoMCk7XG52YXIgTkVXTElORSQxID0gXCJcXG5cIi5jaGFyQ29kZUF0KDApO1xudmFyIFNQQUNFJDEgPSBcIiBcIi5jaGFyQ29kZUF0KDApO1xudmFyIEZFRUQkMSA9IFwiXFxmXCIuY2hhckNvZGVBdCgwKTtcbnZhciBUQUIkMSA9IFwiXHRcIi5jaGFyQ29kZUF0KDApO1xudmFyIENSJDEgPSBcIlxcclwiLmNoYXJDb2RlQXQoMCk7XG52YXIgT1BFTl9TUVVBUkUkMSA9IFwiW1wiLmNoYXJDb2RlQXQoMCk7XG52YXIgQ0xPU0VfU1FVQVJFJDEgPSBcIl1cIi5jaGFyQ29kZUF0KDApO1xudmFyIE9QRU5fUEFSRU5USEVTRVMkMSA9IFwiKFwiLmNoYXJDb2RlQXQoMCk7XG52YXIgQ0xPU0VfUEFSRU5USEVTRVMkMSA9IFwiKVwiLmNoYXJDb2RlQXQoMCk7XG52YXIgT1BFTl9DVVJMWSQxID0gXCJ7XCIuY2hhckNvZGVBdCgwKTtcbnZhciBDTE9TRV9DVVJMWSQxID0gXCJ9XCIuY2hhckNvZGVBdCgwKTtcbnZhciBTRU1JQ09MT04kMSA9IFwiO1wiLmNoYXJDb2RlQXQoMCk7XG52YXIgQVNURVJJU0skMSA9IFwiKlwiLmNoYXJDb2RlQXQoMCk7XG52YXIgQ09MT04kMSA9IFwiOlwiLmNoYXJDb2RlQXQoMCk7XG52YXIgQVQkMSA9IFwiQFwiLmNoYXJDb2RlQXQoMCk7XG52YXIgUkVfQVRfRU5EJDEgPSAvW1xcdFxcblxcZlxcciBcIiMnKCkvO1tcXFxcXFxde31dL2c7XG52YXIgUkVfV09SRF9FTkQkMSA9IC9bXFx0XFxuXFxmXFxyICFcIiMnKCk6O0BbXFxcXFxcXXt9XXxcXC8oPz1cXCopL2c7XG52YXIgUkVfQkFEX0JSQUNLRVQkMSA9IC8uW1xcclxcblwiJygvXFxcXF0vO1xudmFyIFJFX0hFWF9FU0NBUEUkMSA9IC9bXFxkYS1mXS9pO1xudmFyIHRva2VuaXplJDEgPSBmdW5jdGlvbiB0b2tlbml6ZXIoaW5wdXQyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBjc3MgPSBpbnB1dDIuY3NzLnZhbHVlT2YoKTtcbiAgICB2YXIgaWdub3JlID0gb3B0aW9ucy5pZ25vcmVFcnJvcnM7XG4gICAgdmFyIGNvZGUsIG5leHQsIHF1b3RlLCBjb250ZW50LCBlc2NhcGU7XG4gICAgdmFyIGVzY2FwZWQsIGVzY2FwZVBvcywgcHJldiwgbjIsIGN1cnJlbnRUb2tlbjtcbiAgICB2YXIgbGVuZ3RoID0gY3NzLmxlbmd0aDtcbiAgICB2YXIgcG9zID0gMDtcbiAgICB2YXIgYnVmZmVyID0gW107XG4gICAgdmFyIHJldHVybmVkID0gW107XG4gICAgZnVuY3Rpb24gcG9zaXRpb24oKSB7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuY2xvc2VkKHdoYXQpIHtcbiAgICAgICAgdGhyb3cgaW5wdXQyLmVycm9yKFwiVW5jbG9zZWQgXCIgKyB3aGF0LCBwb3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmRPZkZpbGUoKSB7XG4gICAgICAgIHJldHVybiByZXR1cm5lZC5sZW5ndGggPT09IDAgJiYgcG9zID49IGxlbmd0aDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbmV4dFRva2VuKG9wdHMpIHtcbiAgICAgICAgaWYgKHJldHVybmVkLmxlbmd0aCkgcmV0dXJuIHJldHVybmVkLnBvcCgpO1xuICAgICAgICBpZiAocG9zID49IGxlbmd0aCkgcmV0dXJuO1xuICAgICAgICB2YXIgaWdub3JlVW5jbG9zZWQgPSBvcHRzID8gb3B0cy5pZ25vcmVVbmNsb3NlZCA6IGZhbHNlO1xuICAgICAgICBjb2RlID0gY3NzLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgc3dpdGNoKGNvZGUpe1xuICAgICAgICAgICAgY2FzZSBORVdMSU5FJDE6XG4gICAgICAgICAgICBjYXNlIFNQQUNFJDE6XG4gICAgICAgICAgICBjYXNlIFRBQiQxOlxuICAgICAgICAgICAgY2FzZSBDUiQxOlxuICAgICAgICAgICAgY2FzZSBGRUVEJDE6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY3NzLmNoYXJDb2RlQXQobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH13aGlsZSAoY29kZSA9PT0gU1BBQ0UkMSB8fCBjb2RlID09PSBORVdMSU5FJDEgfHwgY29kZSA9PT0gVEFCJDEgfHwgY29kZSA9PT0gQ1IkMSB8fCBjb2RlID09PSBGRUVEJDEpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcInNwYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3Muc2xpY2UocG9zLCBuZXh0KVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBuZXh0IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBPUEVOX1NRVUFSRSQxOlxuICAgICAgICAgICAgY2FzZSBDTE9TRV9TUVVBUkUkMTpcbiAgICAgICAgICAgIGNhc2UgT1BFTl9DVVJMWSQxOlxuICAgICAgICAgICAgY2FzZSBDTE9TRV9DVVJMWSQxOlxuICAgICAgICAgICAgY2FzZSBDT0xPTiQxOlxuICAgICAgICAgICAgY2FzZSBTRU1JQ09MT04kMTpcbiAgICAgICAgICAgIGNhc2UgQ0xPU0VfUEFSRU5USEVTRVMkMTpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250cm9sQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xDaGFyLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbENoYXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBPUEVOX1BBUkVOVEhFU0VTJDE6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBwcmV2ID0gYnVmZmVyLmxlbmd0aCA/IGJ1ZmZlci5wb3AoKVsxXSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIG4yID0gY3NzLmNoYXJDb2RlQXQocG9zICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2ID09PSBcInVybFwiICYmIG4yICE9PSBTSU5HTEVfUVVPVEUkMSAmJiBuMiAhPT0gRE9VQkxFX1FVT1RFJDEgJiYgbjIgIT09IFNQQUNFJDEgJiYgbjIgIT09IE5FV0xJTkUkMSAmJiBuMiAhPT0gVEFCJDEgJiYgbjIgIT09IEZFRUQkMSAmJiBuMiAhPT0gQ1IkMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGNzcy5pbmRleE9mKFwiKVwiLCBuZXh0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZ25vcmUgfHwgaWdub3JlVW5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuY2xvc2VkKFwiYnJhY2tldFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVQb3MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKGNzcy5jaGFyQ29kZUF0KGVzY2FwZVBvcyAtIDEpID09PSBCQUNLU0xBU0gkMSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZVBvcyAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfXdoaWxlIChlc2NhcGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJyYWNrZXRzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBjc3MuaW5kZXhPZihcIilcIiwgcG9zICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT09IC0xIHx8IFJFX0JBRF9CUkFDS0VUJDEudGVzdChjb250ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYnJhY2tldHNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgU0lOR0xFX1FVT1RFJDE6XG4gICAgICAgICAgICBjYXNlIERPVUJMRV9RVU9URSQxOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcXVvdGUgPSBjb2RlID09PSBTSU5HTEVfUVVPVEUkMSA/IFwiJ1wiIDogJ1wiJztcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGNzcy5pbmRleE9mKHF1b3RlLCBuZXh0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlIHx8IGlnbm9yZVVuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBwb3MgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmNsb3NlZChcInN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVQb3MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUoY3NzLmNoYXJDb2RlQXQoZXNjYXBlUG9zIC0gMSkgPT09IEJBQ0tTTEFTSCQxKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVQb3MgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH13aGlsZSAoZXNjYXBlZCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQVQkMTpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFJFX0FUX0VORCQxLmxhc3RJbmRleCA9IHBvcyArIDE7XG4gICAgICAgICAgICAgICAgICAgIFJFX0FUX0VORCQxLnRlc3QoY3NzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFJFX0FUX0VORCQxLmxhc3RJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGNzcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IFJFX0FUX0VORCQxLmxhc3RJbmRleCAtIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJhdC13b3JkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQkFDS1NMQVNIJDE6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICBlc2NhcGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZShjc3MuY2hhckNvZGVBdChuZXh0ICsgMSkgPT09IEJBQ0tTTEFTSCQxKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZSA9ICFlc2NhcGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNzcy5jaGFyQ29kZUF0KG5leHQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVzY2FwZSAmJiBjb2RlICE9PSBTTEFTSCQxICYmIGNvZGUgIT09IFNQQUNFJDEgJiYgY29kZSAhPT0gTkVXTElORSQxICYmIGNvZGUgIT09IFRBQiQxICYmIGNvZGUgIT09IENSJDEgJiYgY29kZSAhPT0gRkVFRCQxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoUkVfSEVYX0VTQ0FQRSQxLnRlc3QoY3NzLmNoYXJBdChuZXh0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZShSRV9IRVhfRVNDQVBFJDEudGVzdChjc3MuY2hhckF0KG5leHQgKyAxKSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjc3MuY2hhckNvZGVBdChuZXh0ICsgMSkgPT09IFNQQUNFJDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcIndvcmRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlID09PSBTTEFTSCQxICYmIGNzcy5jaGFyQ29kZUF0KHBvcyArIDEpID09PSBBU1RFUklTSyQxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gY3NzLmluZGV4T2YoXCIqL1wiLCBwb3MgKyAyKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZ25vcmUgfHwgaWdub3JlVW5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGNzcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5jbG9zZWQoXCJjb21tZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbW1lbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgUkVfV09SRF9FTkQkMS5sYXN0SW5kZXggPSBwb3MgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgUkVfV09SRF9FTkQkMS50ZXN0KGNzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoUkVfV09SRF9FTkQkMS5sYXN0SW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gY3NzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBSRV9XT1JEX0VORCQxLmxhc3RJbmRleCAtIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3b3JkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLnB1c2goY3VycmVudFRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBvcysrO1xuICAgICAgICByZXR1cm4gY3VycmVudFRva2VuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiYWNrKHRva2VuKSB7XG4gICAgICAgIHJldHVybmVkLnB1c2godG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBiYWNrOiBiYWNrLFxuICAgICAgICBlbmRPZkZpbGU6IGVuZE9mRmlsZSxcbiAgICAgICAgbmV4dFRva2VuOiBuZXh0VG9rZW4sXG4gICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICAgIH07XG59O1xudmFyIENvbnRhaW5lciQ1JDEgPSBjb250YWluZXIkMTtcbnZhciBBdFJ1bGUkMyQxID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihDb250YWluZXIkNSQxKSB7XG4gICAgX2luaGVyaXRzKEF0UnVsZSwgQ29udGFpbmVyJDUkMSk7XG4gICAgZnVuY3Rpb24gQXRSdWxlKGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgX3RoaXMgPSBDb250YWluZXIkNSQxLmNhbGwodGhpcywgZGVmYXVsdHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSBcImF0cnVsZVwiO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBBdFJ1bGUucHJvdG90eXBlO1xuICAgIF9wcm90by5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQoKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGNoaWxkcmVuID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBjaGlsZHJlbltfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX0NvbnRhaW5lciQ1JDFfcHJvdG90eXBlX2FwcGVuZDtcbiAgICAgICAgaWYgKCF0aGlzLnByb3h5T2Yubm9kZXMpIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIChfQ29udGFpbmVyJDUkMV9wcm90b3R5cGVfYXBwZW5kID0gQ29udGFpbmVyJDUkMS5wcm90b3R5cGUuYXBwZW5kKS5jYWxsLmFwcGx5KF9Db250YWluZXIkNSQxX3Byb3RvdHlwZV9hcHBlbmQsIFtdLmNvbmNhdChbXG4gICAgICAgICAgICB0aGlzXG4gICAgICAgIF0sIGNoaWxkcmVuKSk7XG4gICAgfTtcbiAgICBfcHJvdG8ucHJlcGVuZCA9IGZ1bmN0aW9uIHByZXBlbmQoKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGNoaWxkcmVuID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBjaGlsZHJlbltfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX0NvbnRhaW5lciQ1JDFfcHJvdG90eXBlX3ByZXBlbmQ7XG4gICAgICAgIGlmICghdGhpcy5wcm94eU9mLm5vZGVzKSB0aGlzLm5vZGVzID0gW107XG4gICAgICAgIHJldHVybiAoX0NvbnRhaW5lciQ1JDFfcHJvdG90eXBlX3ByZXBlbmQgPSBDb250YWluZXIkNSQxLnByb3RvdHlwZS5wcmVwZW5kKS5jYWxsLmFwcGx5KF9Db250YWluZXIkNSQxX3Byb3RvdHlwZV9wcmVwZW5kLCBbXS5jb25jYXQoW1xuICAgICAgICAgICAgdGhpc1xuICAgICAgICBdLCBjaGlsZHJlbikpO1xuICAgIH07XG4gICAgcmV0dXJuIEF0UnVsZTtcbn0oQ29udGFpbmVyJDUkMSk7XG52YXIgYXRSdWxlJDEgPSBBdFJ1bGUkMyQxO1xuQXRSdWxlJDMkMS5kZWZhdWx0ID0gQXRSdWxlJDMkMTtcbkNvbnRhaW5lciQ1JDEucmVnaXN0ZXJBdFJ1bGUoQXRSdWxlJDMkMSk7XG52YXIgQ29udGFpbmVyJDQkMSA9IGNvbnRhaW5lciQxO1xudmFyIExhenlSZXN1bHQkMyQxLCBQcm9jZXNzb3IkMiQxO1xudmFyIFJvb3QkNSQxID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihDb250YWluZXIkNCQxKSB7XG4gICAgX2luaGVyaXRzKFJvb3QsIENvbnRhaW5lciQ0JDEpO1xuICAgIGZ1bmN0aW9uIFJvb3QoZGVmYXVsdHMpIHtcbiAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICBfdGhpcyA9IENvbnRhaW5lciQ0JDEuY2FsbCh0aGlzLCBkZWZhdWx0cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9IFwicm9vdFwiO1xuICAgICAgICBpZiAoIV90aGlzLm5vZGVzKSBfdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBSb290LnByb3RvdHlwZTtcbiAgICBfcHJvdG8ubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKGNoaWxkLCBzYW1wbGUsIHR5cGUpIHtcbiAgICAgICAgdmFyIG5vZGVzID0gQ29udGFpbmVyJDQkMS5wcm90b3R5cGUubm9ybWFsaXplLmNhbGwodGhpcywgY2hpbGQpO1xuICAgICAgICBpZiAoc2FtcGxlKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJwcmVwZW5kXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZS5yYXdzLmJlZm9yZSA9IHRoaXMubm9kZXNbMV0ucmF3cy5iZWZvcmU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNhbXBsZS5yYXdzLmJlZm9yZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZmlyc3QgIT09IHNhbXBsZSkge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKG5vZGVzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZTIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTIucmF3cy5iZWZvcmUgPSBzYW1wbGUucmF3cy5iZWZvcmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9O1xuICAgIF9wcm90by5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIHJlbW92ZUNoaWxkKGNoaWxkLCBpZ25vcmUpIHtcbiAgICAgICAgdmFyIGluZGV4MiA9IHRoaXMuaW5kZXgoY2hpbGQpO1xuICAgICAgICBpZiAoIWlnbm9yZSAmJiBpbmRleDIgPT09IDAgJiYgdGhpcy5ub2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVzWzFdLnJhd3MuYmVmb3JlID0gdGhpcy5ub2Rlc1tpbmRleDJdLnJhd3MuYmVmb3JlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDb250YWluZXIkNCQxLnByb3RvdHlwZS5yZW1vdmVDaGlsZC5jYWxsKHRoaXMsIGNoaWxkKTtcbiAgICB9O1xuICAgIF9wcm90by50b1Jlc3VsdCA9IGZ1bmN0aW9uIHRvUmVzdWx0KG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgb3B0cyA9IHt9O1xuICAgICAgICB2YXIgbGF6eSA9IG5ldyBMYXp5UmVzdWx0JDMkMShuZXcgUHJvY2Vzc29yJDIkMSgpLCB0aGlzLCBvcHRzKTtcbiAgICAgICAgcmV0dXJuIGxhenkuc3RyaW5naWZ5KCk7XG4gICAgfTtcbiAgICByZXR1cm4gUm9vdDtcbn0oQ29udGFpbmVyJDQkMSk7XG5Sb290JDUkMS5yZWdpc3RlckxhenlSZXN1bHQgPSBmdW5jdGlvbihkZXBlbmRhbnQpIHtcbiAgICBMYXp5UmVzdWx0JDMkMSA9IGRlcGVuZGFudDtcbn07XG5Sb290JDUkMS5yZWdpc3RlclByb2Nlc3NvciA9IGZ1bmN0aW9uKGRlcGVuZGFudCkge1xuICAgIFByb2Nlc3NvciQyJDEgPSBkZXBlbmRhbnQ7XG59O1xudmFyIHJvb3QkMSA9IFJvb3QkNSQxO1xuUm9vdCQ1JDEuZGVmYXVsdCA9IFJvb3QkNSQxO1xuQ29udGFpbmVyJDQkMS5yZWdpc3RlclJvb3QoUm9vdCQ1JDEpO1xudmFyIGxpc3QkMiQxID0ge1xuICAgIGNvbW1hOiBmdW5jdGlvbiBjb21tYShzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGxpc3QkMiQxLnNwbGl0KHN0cmluZywgW1xuICAgICAgICAgICAgXCIsXCJcbiAgICAgICAgXSwgdHJ1ZSk7XG4gICAgfSxcbiAgICBzcGFjZTogZnVuY3Rpb24gc3BhY2Uoc3RyaW5nKSB7XG4gICAgICAgIHZhciBzcGFjZXMgPSBbXG4gICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgIFwiXFxuXCIsXG4gICAgICAgICAgICBcIlx0XCJcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIGxpc3QkMiQxLnNwbGl0KHN0cmluZywgc3BhY2VzKTtcbiAgICB9LFxuICAgIHNwbGl0OiBmdW5jdGlvbiBzcGxpdChzdHJpbmcsIHNlcGFyYXRvcnMsIGxhc3QpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICAgIHZhciBjdXJyZW50ID0gXCJcIjtcbiAgICAgICAgdmFyIHNwbGl0ID0gZmFsc2U7XG4gICAgICAgIHZhciBmdW5jID0gMDtcbiAgICAgICAgdmFyIGluUXVvdGUgPSBmYWxzZTtcbiAgICAgICAgdmFyIHByZXZRdW90ZSA9IFwiXCI7XG4gICAgICAgIHZhciBlc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uoc3RyaW5nKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIGxldHRlciA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICAgICAgICAgIGVzY2FwZSA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsZXR0ZXIgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5RdW90ZSkge1xuICAgICAgICAgICAgICAgIGlmIChsZXR0ZXIgPT09IHByZXZRdW90ZSkge1xuICAgICAgICAgICAgICAgICAgICBpblF1b3RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChsZXR0ZXIgPT09ICdcIicgfHwgbGV0dGVyID09PSBcIidcIikge1xuICAgICAgICAgICAgICAgIGluUXVvdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByZXZRdW90ZSA9IGxldHRlcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSBcIihcIikge1xuICAgICAgICAgICAgICAgIGZ1bmMgKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSBcIilcIikge1xuICAgICAgICAgICAgICAgIGlmIChmdW5jID4gMCkgZnVuYyAtPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmdW5jID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlcGFyYXRvcnMuaW5jbHVkZXMobGV0dGVyKSkgc3BsaXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNwbGl0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgIT09IFwiXCIpIGFycmF5LnB1c2goY3VycmVudC50cmltKCkpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHNwbGl0ID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gbGV0dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0IHx8IGN1cnJlbnQgIT09IFwiXCIpIGFycmF5LnB1c2goY3VycmVudC50cmltKCkpO1xuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxufTtcbnZhciBsaXN0XzEkMSA9IGxpc3QkMiQxO1xubGlzdCQyJDEuZGVmYXVsdCA9IGxpc3QkMiQxO1xudmFyIENvbnRhaW5lciQzJDEgPSBjb250YWluZXIkMTtcbnZhciBsaXN0JDEkMSA9IGxpc3RfMSQxO1xudmFyIFJ1bGUkMyQxID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihDb250YWluZXIkMyQxKSB7XG4gICAgX2luaGVyaXRzKFJ1bGUsIENvbnRhaW5lciQzJDEpO1xuICAgIGZ1bmN0aW9uIFJ1bGUoZGVmYXVsdHMpIHtcbiAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICBfdGhpcyA9IENvbnRhaW5lciQzJDEuY2FsbCh0aGlzLCBkZWZhdWx0cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9IFwicnVsZVwiO1xuICAgICAgICBpZiAoIV90aGlzLm5vZGVzKSBfdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIF9jcmVhdGVfY2xhc3MoUnVsZSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwic2VsZWN0b3JzXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlzdCQxJDEuY29tbWEodGhpcy5zZWxlY3Rvcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gdGhpcy5zZWxlY3RvciA/IHRoaXMuc2VsZWN0b3IubWF0Y2goLyxcXHMqLykgOiBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBzZXAyID0gbWF0Y2ggPyBtYXRjaFswXSA6IFwiLFwiICsgdGhpcy5yYXcoXCJiZXR3ZWVuXCIsIFwiYmVmb3JlT3BlblwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gdmFsdWVzLmpvaW4oc2VwMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gUnVsZTtcbn0oQ29udGFpbmVyJDMkMSk7XG52YXIgcnVsZSQxID0gUnVsZSQzJDE7XG5SdWxlJDMkMS5kZWZhdWx0ID0gUnVsZSQzJDE7XG5Db250YWluZXIkMyQxLnJlZ2lzdGVyUnVsZShSdWxlJDMkMSk7XG52YXIgRGVjbGFyYXRpb24kMiQxID0gZGVjbGFyYXRpb24kMTtcbnZhciB0b2tlbml6ZXIyJDEgPSB0b2tlbml6ZSQxO1xudmFyIENvbW1lbnQkMiQxID0gY29tbWVudCQxO1xudmFyIEF0UnVsZSQyJDEgPSBhdFJ1bGUkMTtcbnZhciBSb290JDQkMSA9IHJvb3QkMTtcbnZhciBSdWxlJDIkMSA9IHJ1bGUkMTtcbnZhciBTQUZFX0NPTU1FTlRfTkVJR0hCT1IkMSA9IHtcbiAgICBlbXB0eTogdHJ1ZSxcbiAgICBzcGFjZTogdHJ1ZVxufTtcbmZ1bmN0aW9uIGZpbmRMYXN0V2l0aFBvc2l0aW9uJDEodG9rZW5zKSB7XG4gICAgZm9yKHZhciBpMiA9IHRva2Vucy5sZW5ndGggLSAxOyBpMiA+PSAwOyBpMi0tKXtcbiAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2kyXTtcbiAgICAgICAgdmFyIHBvcyA9IHRva2VuWzNdIHx8IHRva2VuWzJdO1xuICAgICAgICBpZiAocG9zKSByZXR1cm4gcG9zO1xuICAgIH1cbn1cbnZhciBQYXJzZXIkMSQxID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBQYXJzZXIoaW5wdXQyKSB7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDI7XG4gICAgICAgIHRoaXMucm9vdCA9IG5ldyBSb290JDQkMSgpO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLnJvb3Q7XG4gICAgICAgIHRoaXMuc3BhY2VzID0gXCJcIjtcbiAgICAgICAgdGhpcy5zZW1pY29sb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jcmVhdGVUb2tlbml6ZXIoKTtcbiAgICAgICAgdGhpcy5yb290LnNvdXJjZSA9IHtcbiAgICAgICAgICAgIGlucHV0OiBpbnB1dDIsXG4gICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgIGNvbHVtbjogMSxcbiAgICAgICAgICAgICAgICBsaW5lOiAxLFxuICAgICAgICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gUGFyc2VyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uYXRydWxlID0gZnVuY3Rpb24gYXRydWxlKHRva2VuKSB7XG4gICAgICAgIHZhciBub2RlMiA9IG5ldyBBdFJ1bGUkMiQxKCk7XG4gICAgICAgIG5vZGUyLm5hbWUgPSB0b2tlblsxXS5zbGljZSgxKTtcbiAgICAgICAgaWYgKG5vZGUyLm5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHRoaXMudW5uYW1lZEF0cnVsZShub2RlMiwgdG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdChub2RlMiwgdG9rZW5bMl0pO1xuICAgICAgICB2YXIgdHlwZTtcbiAgICAgICAgdmFyIHByZXY7XG4gICAgICAgIHZhciBzaGlmdDtcbiAgICAgICAgdmFyIGxhc3QgPSBmYWxzZTtcbiAgICAgICAgdmFyIG9wZW4gPSBmYWxzZTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgICAgICB2YXIgYnJhY2tldHMgPSBbXTtcbiAgICAgICAgd2hpbGUoIXRoaXMudG9rZW5pemVyLmVuZE9mRmlsZSgpKXtcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy50b2tlbml6ZXIubmV4dFRva2VuKCk7XG4gICAgICAgICAgICB0eXBlID0gdG9rZW5bMF07XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCIoXCIgfHwgdHlwZSA9PT0gXCJbXCIpIHtcbiAgICAgICAgICAgICAgICBicmFja2V0cy5wdXNoKHR5cGUgPT09IFwiKFwiID8gXCIpXCIgOiBcIl1cIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwie1wiICYmIGJyYWNrZXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBicmFja2V0cy5wdXNoKFwifVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gYnJhY2tldHNbYnJhY2tldHMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgICAgICBicmFja2V0cy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChicmFja2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCI7XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTIuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5bMl0pO1xuICAgICAgICAgICAgICAgICAgICBub2RlMi5zb3VyY2UuZW5kLm9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbWljb2xvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IHBhcmFtcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldiA9IHBhcmFtc1tzaGlmdF07XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZShwcmV2ICYmIHByZXZbMF0gPT09IFwic3BhY2VcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldiA9IHBhcmFtc1stLXNoaWZ0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTIuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24ocHJldlszXSB8fCBwcmV2WzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlMi5zb3VyY2UuZW5kLm9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudG9rZW5pemVyLmVuZE9mRmlsZSgpKSB7XG4gICAgICAgICAgICAgICAgbGFzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuID0gdGhpcy5zcGFjZXNBbmRDb21tZW50c0Zyb21FbmQocGFyYW1zKTtcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG5vZGUyLnJhd3MuYWZ0ZXJOYW1lID0gdGhpcy5zcGFjZXNBbmRDb21tZW50c0Zyb21TdGFydChwYXJhbXMpO1xuICAgICAgICAgICAgdGhpcy5yYXcobm9kZTIsIFwicGFyYW1zXCIsIHBhcmFtcyk7XG4gICAgICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgICAgIHRva2VuID0gcGFyYW1zW3BhcmFtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBub2RlMi5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbih0b2tlblszXSB8fCB0b2tlblsyXSk7XG4gICAgICAgICAgICAgICAgbm9kZTIuc291cmNlLmVuZC5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICB0aGlzLnNwYWNlcyA9IG5vZGUyLnJhd3MuYmV0d2VlbjtcbiAgICAgICAgICAgICAgICBub2RlMi5yYXdzLmJldHdlZW4gPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZTIucmF3cy5hZnRlck5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgbm9kZTIucGFyYW1zID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgbm9kZTIubm9kZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IG5vZGUyO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uY2hlY2tNaXNzZWRTZW1pY29sb24gPSBmdW5jdGlvbiBjaGVja01pc3NlZFNlbWljb2xvbih0b2tlbnMpIHtcbiAgICAgICAgdmFyIGNvbG9uID0gdGhpcy5jb2xvbih0b2tlbnMpO1xuICAgICAgICBpZiAoY29sb24gPT09IGZhbHNlKSByZXR1cm47XG4gICAgICAgIHZhciBmb3VuZGVkID0gMDtcbiAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICBmb3IodmFyIGogPSBjb2xvbiAtIDE7IGogPj0gMDsgai0tKXtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2pdO1xuICAgICAgICAgICAgaWYgKHRva2VuWzBdICE9PSBcInNwYWNlXCIpIHtcbiAgICAgICAgICAgICAgICBmb3VuZGVkICs9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kZWQgPT09IDIpIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXCJNaXNzZWQgc2VtaWNvbG9uXCIsIHRva2VuWzBdID09PSBcIndvcmRcIiA/IHRva2VuWzNdICsgMSA6IHRva2VuWzJdKTtcbiAgICB9O1xuICAgIF9wcm90by5jb2xvbiA9IGZ1bmN0aW9uIGNvbG9uKHRva2Vucykge1xuICAgICAgICB2YXIgYnJhY2tldHMgPSAwO1xuICAgICAgICB2YXIgdG9rZW4sIHR5cGUsIHByZXY7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHRva2Vucy5lbnRyaWVzKCkpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgX3N0ZXBfdmFsdWUgPSBfc3RlcC52YWx1ZSwgaTIgPSBfc3RlcF92YWx1ZVswXSwgZWxlbWVudCA9IF9zdGVwX3ZhbHVlWzFdO1xuICAgICAgICAgICAgdG9rZW4gPSBlbGVtZW50O1xuICAgICAgICAgICAgdHlwZSA9IHRva2VuWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiKFwiKSB7XG4gICAgICAgICAgICAgICAgYnJhY2tldHMgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcIilcIikge1xuICAgICAgICAgICAgICAgIGJyYWNrZXRzIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnJhY2tldHMgPT09IDAgJiYgdHlwZSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb3VibGVDb2xvbih0b2tlbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2WzBdID09PSBcIndvcmRcIiAmJiBwcmV2WzFdID09PSBcInByb2dpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2ID0gdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgX3Byb3RvLmNvbW1lbnQgPSBmdW5jdGlvbiBjb21tZW50KHRva2VuKSB7XG4gICAgICAgIHZhciBub2RlMiA9IG5ldyBDb21tZW50JDIkMSgpO1xuICAgICAgICB0aGlzLmluaXQobm9kZTIsIHRva2VuWzJdKTtcbiAgICAgICAgbm9kZTIuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5bM10gfHwgdG9rZW5bMl0pO1xuICAgICAgICBub2RlMi5zb3VyY2UuZW5kLm9mZnNldCsrO1xuICAgICAgICB2YXIgdGV4dCA9IHRva2VuWzFdLnNsaWNlKDIsIC0yKTtcbiAgICAgICAgaWYgKC9eXFxzKiQvLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgIG5vZGUyLnRleHQgPSBcIlwiO1xuICAgICAgICAgICAgbm9kZTIucmF3cy5sZWZ0ID0gdGV4dDtcbiAgICAgICAgICAgIG5vZGUyLnJhd3MucmlnaHQgPSBcIlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gdGV4dC5tYXRjaCgvXihcXHMqKShbXl0qXFxTKShcXHMqKSQvKTtcbiAgICAgICAgICAgIG5vZGUyLnRleHQgPSBtYXRjaFsyXTtcbiAgICAgICAgICAgIG5vZGUyLnJhd3MubGVmdCA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgbm9kZTIucmF3cy5yaWdodCA9IG1hdGNoWzNdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uY3JlYXRlVG9rZW5pemVyID0gZnVuY3Rpb24gY3JlYXRlVG9rZW5pemVyKCkge1xuICAgICAgICB0aGlzLnRva2VuaXplciA9IHRva2VuaXplcjIkMSh0aGlzLmlucHV0KTtcbiAgICB9O1xuICAgIF9wcm90by5kZWNsID0gZnVuY3Rpb24gZGVjbCh0b2tlbnMsIGN1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgIHZhciBub2RlMiA9IG5ldyBEZWNsYXJhdGlvbiQyJDEoKTtcbiAgICAgICAgdGhpcy5pbml0KG5vZGUyLCB0b2tlbnNbMF1bMl0pO1xuICAgICAgICB2YXIgbGFzdCA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0WzBdID09PSBcIjtcIikge1xuICAgICAgICAgICAgdGhpcy5zZW1pY29sb24gPSB0cnVlO1xuICAgICAgICAgICAgdG9rZW5zLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUyLnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKGxhc3RbM10gfHwgbGFzdFsyXSB8fCBmaW5kTGFzdFdpdGhQb3NpdGlvbiQxKHRva2VucykpO1xuICAgICAgICBub2RlMi5zb3VyY2UuZW5kLm9mZnNldCsrO1xuICAgICAgICB3aGlsZSh0b2tlbnNbMF1bMF0gIT09IFwid29yZFwiKXtcbiAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAxKSB0aGlzLnVua25vd25Xb3JkKHRva2Vucyk7XG4gICAgICAgICAgICBub2RlMi5yYXdzLmJlZm9yZSArPSB0b2tlbnMuc2hpZnQoKVsxXTtcbiAgICAgICAgfVxuICAgICAgICBub2RlMi5zb3VyY2Uuc3RhcnQgPSB0aGlzLmdldFBvc2l0aW9uKHRva2Vuc1swXVsyXSk7XG4gICAgICAgIG5vZGUyLnByb3AgPSBcIlwiO1xuICAgICAgICB3aGlsZSh0b2tlbnMubGVuZ3RoKXtcbiAgICAgICAgICAgIHZhciB0eXBlID0gdG9rZW5zWzBdWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiOlwiIHx8IHR5cGUgPT09IFwic3BhY2VcIiB8fCB0eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZTIucHJvcCArPSB0b2tlbnMuc2hpZnQoKVsxXTtcbiAgICAgICAgfVxuICAgICAgICBub2RlMi5yYXdzLmJldHdlZW4gPSBcIlwiO1xuICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgIHdoaWxlKHRva2Vucy5sZW5ndGgpe1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnMuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmICh0b2tlblswXSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICBub2RlMi5yYXdzLmJldHdlZW4gKz0gdG9rZW5bMV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlblswXSA9PT0gXCJ3b3JkXCIgJiYgL1xcdy8udGVzdCh0b2tlblsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bmtub3duV29yZChbXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlblxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuICs9IHRva2VuWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlMi5wcm9wWzBdID09PSBcIl9cIiB8fCBub2RlMi5wcm9wWzBdID09PSBcIipcIikge1xuICAgICAgICAgICAgbm9kZTIucmF3cy5iZWZvcmUgKz0gbm9kZTIucHJvcFswXTtcbiAgICAgICAgICAgIG5vZGUyLnByb3AgPSBub2RlMi5wcm9wLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaXJzdFNwYWNlcyA9IFtdO1xuICAgICAgICB2YXIgbmV4dDtcbiAgICAgICAgd2hpbGUodG9rZW5zLmxlbmd0aCl7XG4gICAgICAgICAgICBuZXh0ID0gdG9rZW5zWzBdWzBdO1xuICAgICAgICAgICAgaWYgKG5leHQgIT09IFwic3BhY2VcIiAmJiBuZXh0ICE9PSBcImNvbW1lbnRcIikgYnJlYWs7XG4gICAgICAgICAgICBmaXJzdFNwYWNlcy5wdXNoKHRva2Vucy5zaGlmdCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZWNoZWNrTWlzc2VkU2VtaWNvbG9uKHRva2Vucyk7XG4gICAgICAgIGZvcih2YXIgaTIgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSl7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpMl07XG4gICAgICAgICAgICBpZiAodG9rZW5bMV0udG9Mb3dlckNhc2UoKSA9PT0gXCIhaW1wb3J0YW50XCIpIHtcbiAgICAgICAgICAgICAgICBub2RlMi5pbXBvcnRhbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBzdHJpbmcgPSB0aGlzLnN0cmluZ0Zyb20odG9rZW5zLCBpMik7XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gdGhpcy5zcGFjZXNGcm9tRW5kKHRva2VucykgKyBzdHJpbmc7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmluZyAhPT0gXCIgIWltcG9ydGFudFwiKSBub2RlMi5yYXdzLmltcG9ydGFudCA9IHN0cmluZztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW5bMV0udG9Mb3dlckNhc2UoKSA9PT0gXCJpbXBvcnRhbnRcIikge1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZSA9IHRva2Vucy5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RyID0gXCJcIjtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGogPSBpMjsgaiA+IDA7IGotLSl7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlMSA9IGNhY2hlW2pdWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyLnRyaW0oKS5pbmRleE9mKFwiIVwiKSA9PT0gMCAmJiB0eXBlMSAhPT0gXCJzcGFjZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdHIgPSBjYWNoZS5wb3AoKVsxXSArIHN0cjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0ci50cmltKCkuaW5kZXhPZihcIiFcIikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTIuaW1wb3J0YW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTIucmF3cy5pbXBvcnRhbnQgPSBzdHI7XG4gICAgICAgICAgICAgICAgICAgIHRva2VucyA9IGNhY2hlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlblswXSAhPT0gXCJzcGFjZVwiICYmIHRva2VuWzBdICE9PSBcImNvbW1lbnRcIikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBoYXNXb3JkID0gdG9rZW5zLnNvbWUoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIHJldHVybiBpMlswXSAhPT0gXCJzcGFjZVwiICYmIGkyWzBdICE9PSBcImNvbW1lbnRcIjtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChoYXNXb3JkKSB7XG4gICAgICAgICAgICBub2RlMi5yYXdzLmJldHdlZW4gKz0gZmlyc3RTcGFjZXMubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkyWzFdO1xuICAgICAgICAgICAgfSkuam9pbihcIlwiKTtcbiAgICAgICAgICAgIGZpcnN0U3BhY2VzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yYXcobm9kZTIsIFwidmFsdWVcIiwgZmlyc3RTcGFjZXMuY29uY2F0KHRva2VucyksIGN1c3RvbVByb3BlcnR5KTtcbiAgICAgICAgaWYgKG5vZGUyLnZhbHVlLmluY2x1ZGVzKFwiOlwiKSAmJiAhY3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tNaXNzZWRTZW1pY29sb24odG9rZW5zKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmRvdWJsZUNvbG9uID0gZnVuY3Rpb24gZG91YmxlQ29sb24odG9rZW4pIHtcbiAgICAgICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcIkRvdWJsZSBjb2xvblwiLCB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRva2VuWzJdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG9mZnNldDogdG9rZW5bMl0gKyB0b2tlblsxXS5sZW5ndGhcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8uZW1wdHlSdWxlID0gZnVuY3Rpb24gZW1wdHlSdWxlKHRva2VuKSB7XG4gICAgICAgIHZhciBub2RlMiA9IG5ldyBSdWxlJDIkMSgpO1xuICAgICAgICB0aGlzLmluaXQobm9kZTIsIHRva2VuWzJdKTtcbiAgICAgICAgbm9kZTIuc2VsZWN0b3IgPSBcIlwiO1xuICAgICAgICBub2RlMi5yYXdzLmJldHdlZW4gPSBcIlwiO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBub2RlMjtcbiAgICB9O1xuICAgIF9wcm90by5lbmQgPSBmdW5jdGlvbiBlbmQodG9rZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudC5ub2RlcyAmJiB0aGlzLmN1cnJlbnQubm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQucmF3cy5zZW1pY29sb24gPSB0aGlzLnNlbWljb2xvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbWljb2xvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1cnJlbnQucmF3cy5hZnRlciA9ICh0aGlzLmN1cnJlbnQucmF3cy5hZnRlciB8fCBcIlwiKSArIHRoaXMuc3BhY2VzO1xuICAgICAgICB0aGlzLnNwYWNlcyA9IFwiXCI7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5bMl0pO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50LnNvdXJjZS5lbmQub2Zmc2V0Kys7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmN1cnJlbnQucGFyZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51bmV4cGVjdGVkQ2xvc2UodG9rZW4pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZW5kRmlsZSA9IGZ1bmN0aW9uIGVuZEZpbGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQucGFyZW50KSB0aGlzLnVuY2xvc2VkQmxvY2soKTtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudC5ub2RlcyAmJiB0aGlzLmN1cnJlbnQubm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQucmF3cy5zZW1pY29sb24gPSB0aGlzLnNlbWljb2xvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnQucmF3cy5hZnRlciA9ICh0aGlzLmN1cnJlbnQucmF3cy5hZnRlciB8fCBcIlwiKSArIHRoaXMuc3BhY2VzO1xuICAgICAgICB0aGlzLnJvb3Quc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odGhpcy50b2tlbml6ZXIucG9zaXRpb24oKSk7XG4gICAgfTtcbiAgICBfcHJvdG8uZnJlZVNlbWljb2xvbiA9IGZ1bmN0aW9uIGZyZWVTZW1pY29sb24odG9rZW4pIHtcbiAgICAgICAgdGhpcy5zcGFjZXMgKz0gdG9rZW5bMV07XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQubm9kZXMpIHtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gdGhpcy5jdXJyZW50Lm5vZGVzW3RoaXMuY3VycmVudC5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChwcmV2ICYmIHByZXYudHlwZSA9PT0gXCJydWxlXCIgJiYgIXByZXYucmF3cy5vd25TZW1pY29sb24pIHtcbiAgICAgICAgICAgICAgICBwcmV2LnJhd3Mub3duU2VtaWNvbG9uID0gdGhpcy5zcGFjZXM7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGFjZXMgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBIZWxwZXJzXG4gICAgX3Byb3RvLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gZ2V0UG9zaXRpb24ob2Zmc2V0KSB7XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLmlucHV0LmZyb21PZmZzZXQob2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbHVtbjogcG9zLmNvbCxcbiAgICAgICAgICAgIGxpbmU6IHBvcy5saW5lLFxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXRcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdChub2RlMiwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuY3VycmVudC5wdXNoKG5vZGUyKTtcbiAgICAgICAgbm9kZTIuc291cmNlID0ge1xuICAgICAgICAgICAgaW5wdXQ6IHRoaXMuaW5wdXQsXG4gICAgICAgICAgICBzdGFydDogdGhpcy5nZXRQb3NpdGlvbihvZmZzZXQpXG4gICAgICAgIH07XG4gICAgICAgIG5vZGUyLnJhd3MuYmVmb3JlID0gdGhpcy5zcGFjZXM7XG4gICAgICAgIHRoaXMuc3BhY2VzID0gXCJcIjtcbiAgICAgICAgaWYgKG5vZGUyLnR5cGUgIT09IFwiY29tbWVudFwiKSB0aGlzLnNlbWljb2xvbiA9IGZhbHNlO1xuICAgIH07XG4gICAgX3Byb3RvLm90aGVyID0gZnVuY3Rpb24gb3RoZXIoc3RhcnQpIHtcbiAgICAgICAgdmFyIGVuZCA9IGZhbHNlO1xuICAgICAgICB2YXIgdHlwZSA9IG51bGw7XG4gICAgICAgIHZhciBjb2xvbiA9IGZhbHNlO1xuICAgICAgICB2YXIgYnJhY2tldCA9IG51bGw7XG4gICAgICAgIHZhciBicmFja2V0cyA9IFtdO1xuICAgICAgICB2YXIgY3VzdG9tUHJvcGVydHkgPSBzdGFydFsxXS5zdGFydHNXaXRoKFwiLS1cIik7XG4gICAgICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICAgICAgdmFyIHRva2VuID0gc3RhcnQ7XG4gICAgICAgIHdoaWxlKHRva2VuKXtcbiAgICAgICAgICAgIHR5cGUgPSB0b2tlblswXTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcIihcIiB8fCB0eXBlID09PSBcIltcIikge1xuICAgICAgICAgICAgICAgIGlmICghYnJhY2tldCkgYnJhY2tldCA9IHRva2VuO1xuICAgICAgICAgICAgICAgIGJyYWNrZXRzLnB1c2godHlwZSA9PT0gXCIoXCIgPyBcIilcIiA6IFwiXVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VzdG9tUHJvcGVydHkgJiYgY29sb24gJiYgdHlwZSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJyYWNrZXQpIGJyYWNrZXQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBicmFja2V0cy5wdXNoKFwifVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYnJhY2tldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiO1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWNsKHRva2VucywgY3VzdG9tUHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwie1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVsZSh0b2tlbnMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRva2VuaXplci5iYWNrKHRva2Vucy5wb3AoKSk7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gYnJhY2tldHNbYnJhY2tldHMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgICAgICBicmFja2V0cy5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAoYnJhY2tldHMubGVuZ3RoID09PSAwKSBicmFja2V0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2VuID0gdGhpcy50b2tlbml6ZXIubmV4dFRva2VuKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudG9rZW5pemVyLmVuZE9mRmlsZSgpKSBlbmQgPSB0cnVlO1xuICAgICAgICBpZiAoYnJhY2tldHMubGVuZ3RoID4gMCkgdGhpcy51bmNsb3NlZEJyYWNrZXQoYnJhY2tldCk7XG4gICAgICAgIGlmIChlbmQgJiYgY29sb24pIHtcbiAgICAgICAgICAgIGlmICghY3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSh0b2tlbnMubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IFwic3BhY2VcIiAmJiB0b2tlbiAhPT0gXCJjb21tZW50XCIpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRva2VuaXplci5iYWNrKHRva2Vucy5wb3AoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kZWNsKHRva2VucywgY3VzdG9tUHJvcGVydHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51bmtub3duV29yZCh0b2tlbnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSgpIHtcbiAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICB3aGlsZSghdGhpcy50b2tlbml6ZXIuZW5kT2ZGaWxlKCkpe1xuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRva2VuaXplci5uZXh0VG9rZW4oKTtcbiAgICAgICAgICAgIHN3aXRjaCh0b2tlblswXSl7XG4gICAgICAgICAgICAgICAgY2FzZSBcInNwYWNlXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BhY2VzICs9IHRva2VuWzFdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiO1wiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyZWVTZW1pY29sb24odG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwifVwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb21tZW50XCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWVudCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJhdC13b3JkXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXRydWxlKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIntcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbXB0eVJ1bGUodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm90aGVyKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbmRGaWxlKCk7XG4gICAgfTtcbiAgICBfcHJvdG8ucHJlY2hlY2tNaXNzZWRTZW1pY29sb24gPSBmdW5jdGlvbiBwcmVjaGVja01pc3NlZFNlbWljb2xvbigpIHt9O1xuICAgIF9wcm90by5yYXcgPSBmdW5jdGlvbiByYXcobm9kZTIsIHByb3AsIHRva2VucywgY3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgdmFyIHRva2VuLCB0eXBlO1xuICAgICAgICB2YXIgbGVuZ3RoID0gdG9rZW5zLmxlbmd0aDtcbiAgICAgICAgdmFyIHZhbHVlID0gXCJcIjtcbiAgICAgICAgdmFyIGNsZWFuID0gdHJ1ZTtcbiAgICAgICAgdmFyIG5leHQsIHByZXY7XG4gICAgICAgIGZvcih2YXIgaTIgPSAwOyBpMiA8IGxlbmd0aDsgaTIgKz0gMSl7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpMl07XG4gICAgICAgICAgICB0eXBlID0gdG9rZW5bMF07XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJzcGFjZVwiICYmIGkyID09PSBsZW5ndGggLSAxICYmICFjdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgICAgICAgICAgICAgcHJldiA9IHRva2Vuc1tpMiAtIDFdID8gdG9rZW5zW2kyIC0gMV1bMF0gOiBcImVtcHR5XCI7XG4gICAgICAgICAgICAgICAgbmV4dCA9IHRva2Vuc1tpMiArIDFdID8gdG9rZW5zW2kyICsgMV1bMF0gOiBcImVtcHR5XCI7XG4gICAgICAgICAgICAgICAgaWYgKCFTQUZFX0NPTU1FTlRfTkVJR0hCT1IkMVtwcmV2XSAmJiAhU0FGRV9DT01NRU5UX05FSUdIQk9SJDFbbmV4dF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLnNsaWNlKC0xKSA9PT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSB0b2tlblsxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSB0b2tlblsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNsZWFuKSB7XG4gICAgICAgICAgICB2YXIgcmF3ID0gdG9rZW5zLnJlZHVjZShmdW5jdGlvbihhbGwsIGkyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFsbCArIGkyWzFdO1xuICAgICAgICAgICAgfSwgXCJcIik7XG4gICAgICAgICAgICBub2RlMi5yYXdzW3Byb3BdID0ge1xuICAgICAgICAgICAgICAgIHJhdzogcmF3LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBub2RlMltwcm9wXSA9IHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJ1bGUgPSBmdW5jdGlvbiBydWxlKHRva2Vucykge1xuICAgICAgICB0b2tlbnMucG9wKCk7XG4gICAgICAgIHZhciBub2RlMiA9IG5ldyBSdWxlJDIkMSgpO1xuICAgICAgICB0aGlzLmluaXQobm9kZTIsIHRva2Vuc1swXVsyXSk7XG4gICAgICAgIG5vZGUyLnJhd3MuYmV0d2VlbiA9IHRoaXMuc3BhY2VzQW5kQ29tbWVudHNGcm9tRW5kKHRva2Vucyk7XG4gICAgICAgIHRoaXMucmF3KG5vZGUyLCBcInNlbGVjdG9yXCIsIHRva2Vucyk7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IG5vZGUyO1xuICAgIH07XG4gICAgX3Byb3RvLnNwYWNlc0FuZENvbW1lbnRzRnJvbUVuZCA9IGZ1bmN0aW9uIHNwYWNlc0FuZENvbW1lbnRzRnJvbUVuZCh0b2tlbnMpIHtcbiAgICAgICAgdmFyIGxhc3RUb2tlblR5cGU7XG4gICAgICAgIHZhciBzcGFjZXMgPSBcIlwiO1xuICAgICAgICB3aGlsZSh0b2tlbnMubGVuZ3RoKXtcbiAgICAgICAgICAgIGxhc3RUb2tlblR5cGUgPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdWzBdO1xuICAgICAgICAgICAgaWYgKGxhc3RUb2tlblR5cGUgIT09IFwic3BhY2VcIiAmJiBsYXN0VG9rZW5UeXBlICE9PSBcImNvbW1lbnRcIikgYnJlYWs7XG4gICAgICAgICAgICBzcGFjZXMgPSB0b2tlbnMucG9wKClbMV0gKyBzcGFjZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwYWNlcztcbiAgICB9O1xuICAgIC8vIEVycm9yc1xuICAgIF9wcm90by5zcGFjZXNBbmRDb21tZW50c0Zyb21TdGFydCA9IGZ1bmN0aW9uIHNwYWNlc0FuZENvbW1lbnRzRnJvbVN0YXJ0KHRva2Vucykge1xuICAgICAgICB2YXIgbmV4dDtcbiAgICAgICAgdmFyIHNwYWNlcyA9IFwiXCI7XG4gICAgICAgIHdoaWxlKHRva2Vucy5sZW5ndGgpe1xuICAgICAgICAgICAgbmV4dCA9IHRva2Vuc1swXVswXTtcbiAgICAgICAgICAgIGlmIChuZXh0ICE9PSBcInNwYWNlXCIgJiYgbmV4dCAhPT0gXCJjb21tZW50XCIpIGJyZWFrO1xuICAgICAgICAgICAgc3BhY2VzICs9IHRva2Vucy5zaGlmdCgpWzFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFjZXM7XG4gICAgfTtcbiAgICBfcHJvdG8uc3BhY2VzRnJvbUVuZCA9IGZ1bmN0aW9uIHNwYWNlc0Zyb21FbmQodG9rZW5zKSB7XG4gICAgICAgIHZhciBsYXN0VG9rZW5UeXBlO1xuICAgICAgICB2YXIgc3BhY2VzID0gXCJcIjtcbiAgICAgICAgd2hpbGUodG9rZW5zLmxlbmd0aCl7XG4gICAgICAgICAgICBsYXN0VG9rZW5UeXBlID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXVswXTtcbiAgICAgICAgICAgIGlmIChsYXN0VG9rZW5UeXBlICE9PSBcInNwYWNlXCIpIGJyZWFrO1xuICAgICAgICAgICAgc3BhY2VzID0gdG9rZW5zLnBvcCgpWzFdICsgc3BhY2VzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFjZXM7XG4gICAgfTtcbiAgICBfcHJvdG8uc3RyaW5nRnJvbSA9IGZ1bmN0aW9uIHN0cmluZ0Zyb20odG9rZW5zLCBmcm9tKSB7XG4gICAgICAgIHZhciByZXN1bHQyID0gXCJcIjtcbiAgICAgICAgZm9yKHZhciBpMiA9IGZyb207IGkyIDwgdG9rZW5zLmxlbmd0aDsgaTIrKyl7XG4gICAgICAgICAgICByZXN1bHQyICs9IHRva2Vuc1tpMl1bMV07XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5zLnNwbGljZShmcm9tLCB0b2tlbnMubGVuZ3RoIC0gZnJvbSk7XG4gICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgIH07XG4gICAgX3Byb3RvLnVuY2xvc2VkQmxvY2sgPSBmdW5jdGlvbiB1bmNsb3NlZEJsb2NrKCkge1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5jdXJyZW50LnNvdXJjZS5zdGFydDtcbiAgICAgICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcIlVuY2xvc2VkIGJsb2NrXCIsIHBvcy5saW5lLCBwb3MuY29sdW1uKTtcbiAgICB9O1xuICAgIF9wcm90by51bmNsb3NlZEJyYWNrZXQgPSBmdW5jdGlvbiB1bmNsb3NlZEJyYWNrZXQoYnJhY2tldCkge1xuICAgICAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFwiVW5jbG9zZWQgYnJhY2tldFwiLCB7XG4gICAgICAgICAgICBvZmZzZXQ6IGJyYWNrZXRbMl1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgb2Zmc2V0OiBicmFja2V0WzJdICsgMVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by51bmV4cGVjdGVkQ2xvc2UgPSBmdW5jdGlvbiB1bmV4cGVjdGVkQ2xvc2UodG9rZW4pIHtcbiAgICAgICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcIlVuZXhwZWN0ZWQgfVwiLCB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRva2VuWzJdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG9mZnNldDogdG9rZW5bMl0gKyAxXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLnVua25vd25Xb3JkID0gZnVuY3Rpb24gdW5rbm93bldvcmQodG9rZW5zKSB7XG4gICAgICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXCJVbmtub3duIHdvcmRcIiwge1xuICAgICAgICAgICAgb2Zmc2V0OiB0b2tlbnNbMF1bMl1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgb2Zmc2V0OiB0b2tlbnNbMF1bMl0gKyB0b2tlbnNbMF1bMV0ubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLnVubmFtZWRBdHJ1bGUgPSBmdW5jdGlvbiB1bm5hbWVkQXRydWxlKG5vZGUyLCB0b2tlbikge1xuICAgICAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFwiQXQtcnVsZSB3aXRob3V0IG5hbWVcIiwge1xuICAgICAgICAgICAgb2Zmc2V0OiB0b2tlblsyXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRva2VuWzJdICsgdG9rZW5bMV0ubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFBhcnNlcjtcbn0oKTtcbnZhciBwYXJzZXIkMSA9IFBhcnNlciQxJDE7XG52YXIgQ29udGFpbmVyJDIkMSA9IGNvbnRhaW5lciQxO1xudmFyIFBhcnNlcjIkMSA9IHBhcnNlciQxO1xudmFyIElucHV0JDIkMSA9IGlucHV0JDE7XG5mdW5jdGlvbiBwYXJzZSQzJDEoY3NzLCBvcHRzKSB7XG4gICAgdmFyIGlucHV0MiA9IG5ldyBJbnB1dCQyJDEoY3NzLCBvcHRzKTtcbiAgICB2YXIgcGFyc2VyMiA9IG5ldyBQYXJzZXIyJDEoaW5wdXQyKTtcbiAgICB0cnkge1xuICAgICAgICBwYXJzZXIyLnBhcnNlKCk7XG4gICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKGUyLm5hbWUgPT09IFwiQ3NzU3ludGF4RXJyb3JcIiAmJiBvcHRzICYmIG9wdHMuZnJvbSkge1xuICAgICAgICAgICAgICAgIGlmICgvXFwuc2NzcyQvaS50ZXN0KG9wdHMuZnJvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZTIubWVzc2FnZSArPSBcIlxcbllvdSB0cmllZCB0byBwYXJzZSBTQ1NTIHdpdGggdGhlIHN0YW5kYXJkIENTUyBwYXJzZXI7IHRyeSBhZ2FpbiB3aXRoIHRoZSBwb3N0Y3NzLXNjc3MgcGFyc2VyXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgvXFwuc2Fzcy9pLnRlc3Qob3B0cy5mcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICBlMi5tZXNzYWdlICs9IFwiXFxuWW91IHRyaWVkIHRvIHBhcnNlIFNhc3Mgd2l0aCB0aGUgc3RhbmRhcmQgQ1NTIHBhcnNlcjsgdHJ5IGFnYWluIHdpdGggdGhlIHBvc3Rjc3Mtc2FzcyBwYXJzZXJcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKC9cXC5sZXNzJC9pLnRlc3Qob3B0cy5mcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICBlMi5tZXNzYWdlICs9IFwiXFxuWW91IHRyaWVkIHRvIHBhcnNlIExlc3Mgd2l0aCB0aGUgc3RhbmRhcmQgQ1NTIHBhcnNlcjsgdHJ5IGFnYWluIHdpdGggdGhlIHBvc3Rjc3MtbGVzcyBwYXJzZXJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTI7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZXIyLnJvb3Q7XG59XG52YXIgcGFyc2VfMSQxID0gcGFyc2UkMyQxO1xucGFyc2UkMyQxLmRlZmF1bHQgPSBwYXJzZSQzJDE7XG5Db250YWluZXIkMiQxLnJlZ2lzdGVyUGFyc2UocGFyc2UkMyQxKTtcbnZhciBpc0NsZWFuJDMgPSBzeW1ib2xzJDEuaXNDbGVhbiwgbXkkMyA9IHN5bWJvbHMkMS5teTtcbnZhciBNYXBHZW5lcmF0b3IkMSQxID0gbWFwR2VuZXJhdG9yJDE7XG52YXIgc3RyaW5naWZ5JDIkMSA9IHN0cmluZ2lmeV8xJDE7XG52YXIgQ29udGFpbmVyJDEkMSA9IGNvbnRhaW5lciQxO1xudmFyIERvY3VtZW50JDIkMSA9IGRvY3VtZW50JDEkMTtcbnZhciB3YXJuT25jZSQxJDEgPSB3YXJuT25jZSQyJDE7XG52YXIgUmVzdWx0JDIkMSA9IHJlc3VsdCQxO1xudmFyIHBhcnNlJDIkMSA9IHBhcnNlXzEkMTtcbnZhciBSb290JDMkMSA9IHJvb3QkMTtcbnZhciBUWVBFX1RPX0NMQVNTX05BTUUkMSA9IHtcbiAgICBhdHJ1bGU6IFwiQXRSdWxlXCIsXG4gICAgY29tbWVudDogXCJDb21tZW50XCIsXG4gICAgZGVjbDogXCJEZWNsYXJhdGlvblwiLFxuICAgIGRvY3VtZW50OiBcIkRvY3VtZW50XCIsXG4gICAgcm9vdDogXCJSb290XCIsXG4gICAgcnVsZTogXCJSdWxlXCJcbn07XG52YXIgUExVR0lOX1BST1BTJDEgPSB7XG4gICAgQXRSdWxlOiB0cnVlLFxuICAgIEF0UnVsZUV4aXQ6IHRydWUsXG4gICAgQ29tbWVudDogdHJ1ZSxcbiAgICBDb21tZW50RXhpdDogdHJ1ZSxcbiAgICBEZWNsYXJhdGlvbjogdHJ1ZSxcbiAgICBEZWNsYXJhdGlvbkV4aXQ6IHRydWUsXG4gICAgRG9jdW1lbnQ6IHRydWUsXG4gICAgRG9jdW1lbnRFeGl0OiB0cnVlLFxuICAgIE9uY2U6IHRydWUsXG4gICAgT25jZUV4aXQ6IHRydWUsXG4gICAgcG9zdGNzc1BsdWdpbjogdHJ1ZSxcbiAgICBwcmVwYXJlOiB0cnVlLFxuICAgIFJvb3Q6IHRydWUsXG4gICAgUm9vdEV4aXQ6IHRydWUsXG4gICAgUnVsZTogdHJ1ZSxcbiAgICBSdWxlRXhpdDogdHJ1ZVxufTtcbnZhciBOT1RfVklTSVRPUlMkMSA9IHtcbiAgICBPbmNlOiB0cnVlLFxuICAgIHBvc3Rjc3NQbHVnaW46IHRydWUsXG4gICAgcHJlcGFyZTogdHJ1ZVxufTtcbnZhciBDSElMRFJFTiQxID0gMDtcbmZ1bmN0aW9uIGlzUHJvbWlzZSQxKG9iaikge1xuICAgIHJldHVybiAodHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihvYmopKSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqLnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50cyQxKG5vZGUyKSB7XG4gICAgdmFyIGtleSA9IGZhbHNlO1xuICAgIHZhciB0eXBlID0gVFlQRV9UT19DTEFTU19OQU1FJDFbbm9kZTIudHlwZV07XG4gICAgaWYgKG5vZGUyLnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAgICAgIGtleSA9IG5vZGUyLnByb3AudG9Mb3dlckNhc2UoKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwiYXRydWxlXCIpIHtcbiAgICAgICAga2V5ID0gbm9kZTIubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBpZiAoa2V5ICYmIG5vZGUyLmFwcGVuZCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHR5cGUgKyBcIi1cIiArIGtleSxcbiAgICAgICAgICAgIENISUxEUkVOJDEsXG4gICAgICAgICAgICB0eXBlICsgXCJFeGl0XCIsXG4gICAgICAgICAgICB0eXBlICsgXCJFeGl0LVwiICsga2V5XG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICB0eXBlICsgXCItXCIgKyBrZXksXG4gICAgICAgICAgICB0eXBlICsgXCJFeGl0XCIsXG4gICAgICAgICAgICB0eXBlICsgXCJFeGl0LVwiICsga2V5XG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmIChub2RlMi5hcHBlbmQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBDSElMRFJFTiQxLFxuICAgICAgICAgICAgdHlwZSArIFwiRXhpdFwiXG4gICAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICB0eXBlICsgXCJFeGl0XCJcbiAgICAgICAgXTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b1N0YWNrJDEobm9kZTIpIHtcbiAgICB2YXIgZXZlbnRzO1xuICAgIGlmIChub2RlMi50eXBlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgZXZlbnRzID0gW1xuICAgICAgICAgICAgXCJEb2N1bWVudFwiLFxuICAgICAgICAgICAgQ0hJTERSRU4kMSxcbiAgICAgICAgICAgIFwiRG9jdW1lbnRFeGl0XCJcbiAgICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwicm9vdFwiKSB7XG4gICAgICAgIGV2ZW50cyA9IFtcbiAgICAgICAgICAgIFwiUm9vdFwiLFxuICAgICAgICAgICAgQ0hJTERSRU4kMSxcbiAgICAgICAgICAgIFwiUm9vdEV4aXRcIlxuICAgICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGV2ZW50cyA9IGdldEV2ZW50cyQxKG5vZGUyKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXZlbnRJbmRleDogMCxcbiAgICAgICAgZXZlbnRzOiBldmVudHMsXG4gICAgICAgIGl0ZXJhdG9yOiAwLFxuICAgICAgICBub2RlOiBub2RlMixcbiAgICAgICAgdmlzaXRvckluZGV4OiAwLFxuICAgICAgICB2aXNpdG9yczogW11cbiAgICB9O1xufVxuZnVuY3Rpb24gY2xlYW5NYXJrcyQxKG5vZGUyKSB7XG4gICAgbm9kZTJbaXNDbGVhbiQzXSA9IGZhbHNlO1xuICAgIGlmIChub2RlMi5ub2Rlcykgbm9kZTIubm9kZXMuZm9yRWFjaChmdW5jdGlvbihpMikge1xuICAgICAgICByZXR1cm4gY2xlYW5NYXJrcyQxKGkyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbm9kZTI7XG59XG52YXIgcG9zdGNzcyQyJDEgPSB7fTtcbnZhciBMYXp5UmVzdWx0JDIkMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gTGF6eVJlc3VsdChwcm9jZXNzb3IyLCBjc3MsIG9wdHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zdHJpbmdpZmllZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByb2Nlc3NlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgcm9vdDI7XG4gICAgICAgIGlmICgodHlwZW9mIGNzcyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihjc3MpKSA9PT0gXCJvYmplY3RcIiAmJiBjc3MgIT09IG51bGwgJiYgKGNzcy50eXBlID09PSBcInJvb3RcIiB8fCBjc3MudHlwZSA9PT0gXCJkb2N1bWVudFwiKSkge1xuICAgICAgICAgICAgcm9vdDIgPSBjbGVhbk1hcmtzJDEoY3NzKTtcbiAgICAgICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZihjc3MsIExhenlSZXN1bHQpIHx8IF9pbnN0YW5jZW9mKGNzcywgUmVzdWx0JDIkMSkpIHtcbiAgICAgICAgICAgIHJvb3QyID0gY2xlYW5NYXJrcyQxKGNzcy5yb290KTtcbiAgICAgICAgICAgIGlmIChjc3MubWFwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRzLm1hcCA9PT0gXCJ1bmRlZmluZWRcIikgb3B0cy5tYXAgPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdHMubWFwLmlubGluZSkgb3B0cy5tYXAuaW5saW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgb3B0cy5tYXAucHJldiA9IGNzcy5tYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VyMiA9IHBhcnNlJDIkMTtcbiAgICAgICAgICAgIGlmIChvcHRzLnN5bnRheCkgcGFyc2VyMiA9IG9wdHMuc3ludGF4LnBhcnNlO1xuICAgICAgICAgICAgaWYgKG9wdHMucGFyc2VyKSBwYXJzZXIyID0gb3B0cy5wYXJzZXI7XG4gICAgICAgICAgICBpZiAocGFyc2VyMi5wYXJzZSkgcGFyc2VyMiA9IHBhcnNlcjIucGFyc2U7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJvb3QyID0gcGFyc2VyMihjc3MsIG9wdHMpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvb3QyICYmICFyb290MltteSQzXSkge1xuICAgICAgICAgICAgICAgIENvbnRhaW5lciQxJDEucmVidWlsZChyb290Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXN1bHQgPSBuZXcgUmVzdWx0JDIkMShwcm9jZXNzb3IyLCByb290Miwgb3B0cyk7XG4gICAgICAgIHRoaXMuaGVscGVycyA9IF9leHRlbmRzKHt9LCBwb3N0Y3NzJDIkMSwge1xuICAgICAgICAgICAgcG9zdGNzczogcG9zdGNzcyQyJDEsXG4gICAgICAgICAgICByZXN1bHQ6IHRoaXMucmVzdWx0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSB0aGlzLnByb2Nlc3Nvci5wbHVnaW5zLm1hcChmdW5jdGlvbihwbHVnaW4yMikge1xuICAgICAgICAgICAgaWYgKCh0eXBlb2YgcGx1Z2luMjIgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YocGx1Z2luMjIpKSA9PT0gXCJvYmplY3RcIiAmJiBwbHVnaW4yMi5wcmVwYXJlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBwbHVnaW4yMiwgcGx1Z2luMjIucHJlcGFyZShfdGhpcy5yZXN1bHQpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbjIyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IExhenlSZXN1bHQucHJvdG90eXBlO1xuICAgIF9wcm90by5hc3luYyA9IGZ1bmN0aW9uIGFzeW5jKCkge1xuICAgICAgICBpZiAodGhpcy5lcnJvcikgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuZXJyb3IpO1xuICAgICAgICBpZiAodGhpcy5wcm9jZXNzZWQpIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5yZXN1bHQpO1xuICAgICAgICBpZiAoIXRoaXMucHJvY2Vzc2luZykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nID0gdGhpcy5ydW5Bc3luYygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3Npbmc7XG4gICAgfTtcbiAgICBfcHJvdG8uY2F0Y2ggPSBmdW5jdGlvbiBfY2F0Y2gob25SZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc3luYygpLmNhdGNoKG9uUmVqZWN0ZWQpO1xuICAgIH07XG4gICAgX3Byb3RvLmZpbmFsbHkgPSBmdW5jdGlvbiBfZmluYWxseShvbkZpbmFsbHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRmluYWxseSwgb25GaW5hbGx5KTtcbiAgICB9O1xuICAgIF9wcm90by5nZXRBc3luY0Vycm9yID0gZnVuY3Rpb24gZ2V0QXN5bmNFcnJvcigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVXNlIHByb2Nlc3MoY3NzKS50aGVuKGNiKSB0byB3b3JrIHdpdGggYXN5bmMgcGx1Z2luc1wiKTtcbiAgICB9O1xuICAgIF9wcm90by5oYW5kbGVFcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycm9yLCBub2RlMikge1xuICAgICAgICB2YXIgcGx1Z2luMjIgPSB0aGlzLnJlc3VsdC5sYXN0UGx1Z2luO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKG5vZGUyKSBub2RlMi5hZGRUb0Vycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIGlmIChlcnJvci5uYW1lID09PSBcIkNzc1N5bnRheEVycm9yXCIgJiYgIWVycm9yLnBsdWdpbikge1xuICAgICAgICAgICAgICAgIGVycm9yLnBsdWdpbiA9IHBsdWdpbjIyLnBvc3Rjc3NQbHVnaW47XG4gICAgICAgICAgICAgICAgZXJyb3Iuc2V0TWVzc2FnZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwbHVnaW4yMi5wb3N0Y3NzVmVyc2lvbikge1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBsdWdpbk5hbWUgPSBwbHVnaW4yMi5wb3N0Y3NzUGx1Z2luO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGx1Z2luVmVyID0gcGx1Z2luMjIucG9zdGNzc1ZlcnNpb247XG4gICAgICAgICAgICAgICAgICAgIHZhciBydW50aW1lVmVyID0gdGhpcy5yZXN1bHQucHJvY2Vzc29yLnZlcnNpb247XG4gICAgICAgICAgICAgICAgICAgIHZhciBhMiA9IHBsdWdpblZlci5zcGxpdChcIi5cIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gcnVudGltZVZlci5zcGxpdChcIi5cIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhMlswXSAhPT0gYlswXSB8fCBwYXJzZUludChhMlsxXSkgPiBwYXJzZUludChiWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlVua25vd24gZXJyb3IgZnJvbSBQb3N0Q1NTIHBsdWdpbi4gWW91ciBjdXJyZW50IFBvc3RDU1MgdmVyc2lvbiBpcyBcIiArIHJ1bnRpbWVWZXIgKyBcIiwgYnV0IFwiICsgcGx1Z2luTmFtZSArIFwiIHVzZXMgXCIgKyBwbHVnaW5WZXIgKyBcIi4gUGVyaGFwcyB0aGlzIGlzIHRoZSBzb3VyY2Ugb2YgdGhlIGVycm9yIGJlbG93LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLmVycm9yKSBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH07XG4gICAgX3Byb3RvLnByZXBhcmVWaXNpdG9ycyA9IGZ1bmN0aW9uIHByZXBhcmVWaXNpdG9ycygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgdmFyIGFkZCA9IGZ1bmN0aW9uKHBsdWdpbjIyLCB0eXBlLCBjYikge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5saXN0ZW5lcnNbdHlwZV0pIF90aGlzLmxpc3RlbmVyc1t0eXBlXSA9IFtdO1xuICAgICAgICAgICAgX3RoaXMubGlzdGVuZXJzW3R5cGVdLnB1c2goW1xuICAgICAgICAgICAgICAgIHBsdWdpbjIyLFxuICAgICAgICAgICAgICAgIGNiXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UodGhpcy5wbHVnaW5zKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIHBsdWdpbjIyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBwbHVnaW4yMiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihwbHVnaW4yMikpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBldmVudCBpbiBwbHVnaW4yMil7XG4gICAgICAgICAgICAgICAgICAgIGlmICghUExVR0lOX1BST1BTJDFbZXZlbnRdICYmIC9eW0EtWl0vLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGV2ZW50IFwiICsgZXZlbnQgKyBcIiBpbiBcIiArIHBsdWdpbjIyLnBvc3Rjc3NQbHVnaW4gKyBcIi4gVHJ5IHRvIHVwZGF0ZSBQb3N0Q1NTIChcIiArIHRoaXMucHJvY2Vzc29yLnZlcnNpb24gKyBcIiBub3cpLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIU5PVF9WSVNJVE9SUyQxW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90eXBlX29mKHBsdWdpbjIyW2V2ZW50XSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGZpbHRlciBpbiBwbHVnaW4yMltldmVudF0pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyID09PSBcIipcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkKHBsdWdpbjIyLCBldmVudCwgcGx1Z2luMjJbZXZlbnRdW2ZpbHRlcl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkKHBsdWdpbjIyLCBldmVudCArIFwiLVwiICsgZmlsdGVyLnRvTG93ZXJDYXNlKCksIHBsdWdpbjIyW2V2ZW50XVtmaWx0ZXJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbjIyW2V2ZW50XSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkKHBsdWdpbjIyLCBldmVudCwgcGx1Z2luMjJbZXZlbnRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhc0xpc3RlbmVyID0gT2JqZWN0LmtleXModGhpcy5saXN0ZW5lcnMpLmxlbmd0aCA+IDA7XG4gICAgfTtcbiAgICBfcHJvdG8ucnVuQXN5bmMgPSBmdW5jdGlvbiBydW5Bc3luYygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaTIsIHBsdWdpbjIyLCBwcm9taXNlLCBlcnJvciwgcm9vdDIsIHN0YWNrLCBwcm9taXNlMSwgZTIsIG5vZGUyLCBfbG9vcCwgX2l0ZXJhdG9yLCBfc3RlcDtcbiAgICAgICAgICAgIHJldHVybiBfdHNfZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKF9zdGF0ZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaChfc3RhdGUubGFiZWwpe1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wbHVnaW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaTIgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaTIgPCBfdGhpcy5wbHVnaW5zLmxlbmd0aCkpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA2XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luMjIgPSBfdGhpcy5wbHVnaW5zW2kyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBfdGhpcy5ydW5PblJvb3QocGx1Z2luMjIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Byb21pc2UkMShwcm9taXNlKSkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDVcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUudHJ5cy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDVcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBfc3RhdGUuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX3RoaXMuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBpMisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnByZXBhcmVWaXNpdG9ycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5oYXNMaXN0ZW5lcikgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE4XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdDIgPSBfdGhpcy5yZXN1bHQucm9vdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5sYWJlbCA9IDc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIXJvb3QyW2lzQ2xlYW4kM10pIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QyW2lzQ2xlYW4kM10gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9TdGFjayQxKHJvb3QyKVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5sYWJlbCA9IDg7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHN0YWNrLmxlbmd0aCA+IDApKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTNcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlMSA9IF90aGlzLnZpc2l0VGljayhzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUHJvbWlzZSQxKHByb21pc2UxKSkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEyXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLmxhYmVsID0gOTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnRyeXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UxXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMlxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGUyID0gX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUyID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0ubm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF90aGlzLmhhbmRsZUVycm9yKGUyLCBub2RlMik7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA3XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5saXN0ZW5lcnMuT25jZUV4aXQpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxOFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sb29wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9zdGVwX3ZhbHVlLCBwbHVnaW4yMiwgdmlzaXRvciwgcm9vdHMsIGUyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdHNfZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKF9zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2goX3N0YXRlLmxhYmVsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc3RlcF92YWx1ZSA9IF9zdGVwLnZhbHVlLCBwbHVnaW4yMiA9IF9zdGVwX3ZhbHVlWzBdLCB2aXNpdG9yID0gX3N0ZXBfdmFsdWVbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVzdWx0Lmxhc3RQbHVnaW4gPSBwbHVnaW4yMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS50cnlzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA2LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyb290Mi50eXBlID09PSBcImRvY3VtZW50XCIpKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290cyA9IHJvb3QyLm5vZGVzLm1hcChmdW5jdGlvbihzdWJSb290KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdG9yKHN1YlJvb3QsIF90aGlzLmhlbHBlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKHJvb3RzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpdG9yKHJvb3QyLCBfdGhpcy5oZWxwZXJzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUyID0gX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfdGhpcy5oYW5kbGVFcnJvcihlMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UoX3RoaXMubGlzdGVuZXJzLk9uY2VFeGl0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5sYWJlbCA9IDE1O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmUpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxOFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdHNfdmFsdWVzKF9sb29wKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5sYWJlbCA9IDE3O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE1XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdHJpbmdpZnkoKVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKTtcbiAgICB9O1xuICAgIF9wcm90by5ydW5PblJvb3QgPSBmdW5jdGlvbiBydW5PblJvb3QocGx1Z2luMjIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yZXN1bHQubGFzdFBsdWdpbiA9IHBsdWdpbjIyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCh0eXBlb2YgcGx1Z2luMjIgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YocGx1Z2luMjIpKSA9PT0gXCJvYmplY3RcIiAmJiBwbHVnaW4yMi5PbmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzdWx0LnJvb3QudHlwZSA9PT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByb290cyA9IHRoaXMucmVzdWx0LnJvb3Qubm9kZXMubWFwKGZ1bmN0aW9uKHJvb3QyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGx1Z2luMjIuT25jZShyb290MiwgX3RoaXMuaGVscGVycyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcm9taXNlJDEocm9vdHNbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocm9vdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb290cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbjIyLk9uY2UodGhpcy5yZXN1bHQucm9vdCwgdGhpcy5oZWxwZXJzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbjIyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGx1Z2luMjIodGhpcy5yZXN1bHQucm9vdCwgdGhpcy5yZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5zdHJpbmdpZnkgPSBmdW5jdGlvbiBzdHJpbmdpZnkoKSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9yKSB0aHJvdyB0aGlzLmVycm9yO1xuICAgICAgICBpZiAodGhpcy5zdHJpbmdpZmllZCkgcmV0dXJuIHRoaXMucmVzdWx0O1xuICAgICAgICB0aGlzLnN0cmluZ2lmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zeW5jKCk7XG4gICAgICAgIHZhciBvcHRzID0gdGhpcy5yZXN1bHQub3B0cztcbiAgICAgICAgdmFyIHN0ciA9IHN0cmluZ2lmeSQyJDE7XG4gICAgICAgIGlmIChvcHRzLnN5bnRheCkgc3RyID0gb3B0cy5zeW50YXguc3RyaW5naWZ5O1xuICAgICAgICBpZiAob3B0cy5zdHJpbmdpZmllcikgc3RyID0gb3B0cy5zdHJpbmdpZmllcjtcbiAgICAgICAgaWYgKHN0ci5zdHJpbmdpZnkpIHN0ciA9IHN0ci5zdHJpbmdpZnk7XG4gICAgICAgIHZhciBtYXAgPSBuZXcgTWFwR2VuZXJhdG9yJDEkMShzdHIsIHRoaXMucmVzdWx0LnJvb3QsIHRoaXMucmVzdWx0Lm9wdHMpO1xuICAgICAgICB2YXIgZGF0YSA9IG1hcC5nZW5lcmF0ZSgpO1xuICAgICAgICB0aGlzLnJlc3VsdC5jc3MgPSBkYXRhWzBdO1xuICAgICAgICB0aGlzLnJlc3VsdC5tYXAgPSBkYXRhWzFdO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQ7XG4gICAgfTtcbiAgICBfcHJvdG8uc3luYyA9IGZ1bmN0aW9uIHN5bmMoKSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9yKSB0aHJvdyB0aGlzLmVycm9yO1xuICAgICAgICBpZiAodGhpcy5wcm9jZXNzZWQpIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5wcm9jZXNzaW5nKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmdldEFzeW5jRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZSh0aGlzLnBsdWdpbnMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgcGx1Z2luMjIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gdGhpcy5ydW5PblJvb3QocGx1Z2luMjIpO1xuICAgICAgICAgICAgaWYgKGlzUHJvbWlzZSQxKHByb21pc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5nZXRBc3luY0Vycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVwYXJlVmlzaXRvcnMoKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHZhciByb290MiA9IHRoaXMucmVzdWx0LnJvb3Q7XG4gICAgICAgICAgICB3aGlsZSghcm9vdDJbaXNDbGVhbiQzXSl7XG4gICAgICAgICAgICAgICAgcm9vdDJbaXNDbGVhbiQzXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy53YWxrU3luYyhyb290Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5saXN0ZW5lcnMuT25jZUV4aXQpIHtcbiAgICAgICAgICAgICAgICBpZiAocm9vdDIudHlwZSA9PT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yMSA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShyb290Mi5ub2RlcyksIF9zdGVwMTsgIShfc3RlcDEgPSBfaXRlcmF0b3IxKCkpLmRvbmU7KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWJSb290ID0gX3N0ZXAxLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdFN5bmModGhpcy5saXN0ZW5lcnMuT25jZUV4aXQsIHN1YlJvb3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdFN5bmModGhpcy5saXN0ZW5lcnMuT25jZUV4aXQsIHJvb3QyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0O1xuICAgIH07XG4gICAgX3Byb3RvLnRoZW4gPSBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICghKFwiZnJvbVwiIGluIHRoaXMub3B0cykpIHtcbiAgICAgICAgICAgICAgICB3YXJuT25jZSQxJDEoXCJXaXRob3V0IGBmcm9tYCBvcHRpb24gUG9zdENTUyBjb3VsZCBnZW5lcmF0ZSB3cm9uZyBzb3VyY2UgbWFwIGFuZCB3aWxsIG5vdCBmaW5kIEJyb3dzZXJzbGlzdCBjb25maWcuIFNldCBpdCB0byBDU1MgZmlsZSBwYXRoIG9yIHRvIGB1bmRlZmluZWRgIHRvIHByZXZlbnQgdGhpcyB3YXJuaW5nLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hc3luYygpLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH07XG4gICAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNzcztcbiAgICB9O1xuICAgIF9wcm90by52aXNpdFN5bmMgPSBmdW5jdGlvbiB2aXNpdFN5bmModmlzaXRvcnMsIG5vZGUyKSB7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHZpc2l0b3JzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIF9zdGVwX3ZhbHVlID0gX3N0ZXAudmFsdWUsIHBsdWdpbjIyID0gX3N0ZXBfdmFsdWVbMF0sIHZpc2l0b3IgPSBfc3RlcF92YWx1ZVsxXTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0Lmxhc3RQbHVnaW4gPSBwbHVnaW4yMjtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gdm9pZCAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gdmlzaXRvcihub2RlMiwgdGhpcy5oZWxwZXJzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5oYW5kbGVFcnJvcihlMiwgbm9kZTIucHJveHlPZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZTIudHlwZSAhPT0gXCJyb290XCIgJiYgbm9kZTIudHlwZSAhPT0gXCJkb2N1bWVudFwiICYmICFub2RlMi5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1Byb21pc2UkMShwcm9taXNlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZ2V0QXN5bmNFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8udmlzaXRUaWNrID0gZnVuY3Rpb24gdmlzaXRUaWNrKHN0YWNrKSB7XG4gICAgICAgIHZhciB2aXNpdDIgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIG5vZGUyID0gdmlzaXQyLm5vZGUsIHZpc2l0b3JzID0gdmlzaXQyLnZpc2l0b3JzO1xuICAgICAgICBpZiAobm9kZTIudHlwZSAhPT0gXCJyb290XCIgJiYgbm9kZTIudHlwZSAhPT0gXCJkb2N1bWVudFwiICYmICFub2RlMi5wYXJlbnQpIHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aXNpdG9ycy5sZW5ndGggPiAwICYmIHZpc2l0Mi52aXNpdG9ySW5kZXggPCB2aXNpdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBfdmlzaXRvcnNfdmlzaXQyX3Zpc2l0b3JJbmRleCA9IHZpc2l0b3JzW3Zpc2l0Mi52aXNpdG9ySW5kZXhdLCBwbHVnaW4yMiA9IF92aXNpdG9yc192aXNpdDJfdmlzaXRvckluZGV4WzBdLCB2aXNpdG9yID0gX3Zpc2l0b3JzX3Zpc2l0Ml92aXNpdG9ySW5kZXhbMV07XG4gICAgICAgICAgICB2aXNpdDIudmlzaXRvckluZGV4ICs9IDE7XG4gICAgICAgICAgICBpZiAodmlzaXQyLnZpc2l0b3JJbmRleCA9PT0gdmlzaXRvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmlzaXQyLnZpc2l0b3JzID0gW107XG4gICAgICAgICAgICAgICAgdmlzaXQyLnZpc2l0b3JJbmRleCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5sYXN0UGx1Z2luID0gcGx1Z2luMjI7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdG9yKG5vZGUyLnRvUHJveHkoKSwgdGhpcy5oZWxwZXJzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5oYW5kbGVFcnJvcihlMiwgbm9kZTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2aXNpdDIuaXRlcmF0b3IgIT09IDApIHtcbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IHZpc2l0Mi5pdGVyYXRvcjtcbiAgICAgICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgICAgIHdoaWxlKGNoaWxkID0gbm9kZTIubm9kZXNbbm9kZTIuaW5kZXhlc1tpdGVyYXRvcl1dKXtcbiAgICAgICAgICAgICAgICBub2RlMi5pbmRleGVzW2l0ZXJhdG9yXSArPSAxO1xuICAgICAgICAgICAgICAgIGlmICghY2hpbGRbaXNDbGVhbiQzXSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFtpc0NsZWFuJDNdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh0b1N0YWNrJDEoY2hpbGQpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZpc2l0Mi5pdGVyYXRvciA9IDA7XG4gICAgICAgICAgICBkZWxldGUgbm9kZTIuaW5kZXhlc1tpdGVyYXRvcl07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50cyA9IHZpc2l0Mi5ldmVudHM7XG4gICAgICAgIHdoaWxlKHZpc2l0Mi5ldmVudEluZGV4IDwgZXZlbnRzLmxlbmd0aCl7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBldmVudHNbdmlzaXQyLmV2ZW50SW5kZXhdO1xuICAgICAgICAgICAgdmlzaXQyLmV2ZW50SW5kZXggKz0gMTtcbiAgICAgICAgICAgIGlmIChldmVudCA9PT0gQ0hJTERSRU4kMSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlMi5ub2RlcyAmJiBub2RlMi5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTJbaXNDbGVhbiQzXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZpc2l0Mi5pdGVyYXRvciA9IG5vZGUyLmdldEl0ZXJhdG9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5saXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICAgICAgICAgICAgdmlzaXQyLnZpc2l0b3JzID0gdGhpcy5saXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICB9O1xuICAgIF9wcm90by53YWxrU3luYyA9IGZ1bmN0aW9uIHdhbGtTeW5jKG5vZGUyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG5vZGUyW2lzQ2xlYW4kM10gPSB0cnVlO1xuICAgICAgICB2YXIgZXZlbnRzID0gZ2V0RXZlbnRzJDEobm9kZTIpO1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShldmVudHMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChldmVudCA9PT0gQ0hJTERSRU4kMSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlMi5ub2Rlcykge1xuICAgICAgICAgICAgICAgICAgICBub2RlMi5lYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkW2lzQ2xlYW4kM10pIF90aGlzLndhbGtTeW5jKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdmlzaXRvcnMgPSB0aGlzLmxpc3RlbmVyc1tldmVudF07XG4gICAgICAgICAgICAgICAgaWYgKHZpc2l0b3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpc2l0U3luYyh2aXNpdG9ycywgbm9kZTIudG9Qcm94eSgpKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLndhcm5pbmdzID0gZnVuY3Rpb24gd2FybmluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN5bmMoKS53YXJuaW5ncygpO1xuICAgIH07XG4gICAgX2NyZWF0ZV9jbGFzcyhMYXp5UmVzdWx0LCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjb250ZW50XCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmdpZnkoKS5jb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY3NzXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmdpZnkoKS5jc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJtYXBcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmluZ2lmeSgpLm1hcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcIm1lc3NhZ2VzXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zeW5jKCkubWVzc2FnZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJvcHRzXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQub3B0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInByb2Nlc3NvclwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0LnByb2Nlc3NvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInJvb3RcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN5bmMoKS5yb290O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFN5bWJvbC50b1N0cmluZ1RhZyxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIkxhenlSZXN1bHRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBMYXp5UmVzdWx0O1xufSgpO1xuTGF6eVJlc3VsdCQyJDEucmVnaXN0ZXJQb3N0Y3NzID0gZnVuY3Rpb24oZGVwZW5kYW50KSB7XG4gICAgcG9zdGNzcyQyJDEgPSBkZXBlbmRhbnQ7XG59O1xudmFyIGxhenlSZXN1bHQkMSA9IExhenlSZXN1bHQkMiQxO1xuTGF6eVJlc3VsdCQyJDEuZGVmYXVsdCA9IExhenlSZXN1bHQkMiQxO1xuUm9vdCQzJDEucmVnaXN0ZXJMYXp5UmVzdWx0KExhenlSZXN1bHQkMiQxKTtcbkRvY3VtZW50JDIkMS5yZWdpc3RlckxhenlSZXN1bHQoTGF6eVJlc3VsdCQyJDEpO1xudmFyIE1hcEdlbmVyYXRvcjIkMSA9IG1hcEdlbmVyYXRvciQxO1xudmFyIHN0cmluZ2lmeSQxJDEgPSBzdHJpbmdpZnlfMSQxO1xudmFyIHdhcm5PbmNlMiQxID0gd2Fybk9uY2UkMiQxO1xudmFyIHBhcnNlJDEkMSA9IHBhcnNlXzEkMTtcbnZhciBSZXN1bHQkMSQxID0gcmVzdWx0JDE7XG52YXIgTm9Xb3JrUmVzdWx0JDEkMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gTm9Xb3JrUmVzdWx0KHByb2Nlc3NvcjIsIGNzcywgb3B0cykge1xuICAgICAgICBjc3MgPSBjc3MudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5zdHJpbmdpZmllZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcm9jZXNzb3IgPSBwcm9jZXNzb3IyO1xuICAgICAgICB0aGlzLl9jc3MgPSBjc3M7XG4gICAgICAgIHRoaXMuX29wdHMgPSBvcHRzO1xuICAgICAgICB0aGlzLl9tYXAgPSB2b2lkIDA7XG4gICAgICAgIHZhciByb290MjtcbiAgICAgICAgdmFyIHN0ciA9IHN0cmluZ2lmeSQxJDE7XG4gICAgICAgIHRoaXMucmVzdWx0ID0gbmV3IFJlc3VsdCQxJDEodGhpcy5fcHJvY2Vzc29yLCByb290MiwgdGhpcy5fb3B0cyk7XG4gICAgICAgIHRoaXMucmVzdWx0LmNzcyA9IGNzcztcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5yZXN1bHQsIFwicm9vdFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5yb290O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG1hcCA9IG5ldyBNYXBHZW5lcmF0b3IyJDEoc3RyLCByb290MiwgdGhpcy5fb3B0cywgY3NzKTtcbiAgICAgICAgaWYgKG1hcC5pc01hcCgpKSB7XG4gICAgICAgICAgICB2YXIgX21hcF9nZW5lcmF0ZSA9IG1hcC5nZW5lcmF0ZSgpLCBnZW5lcmF0ZWRDU1MgPSBfbWFwX2dlbmVyYXRlWzBdLCBnZW5lcmF0ZWRNYXAgPSBfbWFwX2dlbmVyYXRlWzFdO1xuICAgICAgICAgICAgaWYgKGdlbmVyYXRlZENTUykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LmNzcyA9IGdlbmVyYXRlZENTUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZW5lcmF0ZWRNYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5tYXAgPSBnZW5lcmF0ZWRNYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXAuY2xlYXJBbm5vdGF0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5jc3MgPSBtYXAuY3NzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBOb1dvcmtSZXN1bHQucHJvdG90eXBlO1xuICAgIF9wcm90by5hc3luYyA9IGZ1bmN0aW9uIGFzeW5jKCkge1xuICAgICAgICBpZiAodGhpcy5lcnJvcikgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuZXJyb3IpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMucmVzdWx0KTtcbiAgICB9O1xuICAgIF9wcm90by5jYXRjaCA9IGZ1bmN0aW9uIF9jYXRjaChvblJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzeW5jKCkuY2F0Y2gob25SZWplY3RlZCk7XG4gICAgfTtcbiAgICBfcHJvdG8uZmluYWxseSA9IGZ1bmN0aW9uIF9maW5hbGx5KG9uRmluYWxseSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc3luYygpLnRoZW4ob25GaW5hbGx5LCBvbkZpbmFsbHkpO1xuICAgIH07XG4gICAgX3Byb3RvLnN5bmMgPSBmdW5jdGlvbiBzeW5jKCkge1xuICAgICAgICBpZiAodGhpcy5lcnJvcikgdGhyb3cgdGhpcy5lcnJvcjtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0O1xuICAgIH07XG4gICAgX3Byb3RvLnRoZW4gPSBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICghKFwiZnJvbVwiIGluIHRoaXMuX29wdHMpKSB7XG4gICAgICAgICAgICAgICAgd2Fybk9uY2UyJDEoXCJXaXRob3V0IGBmcm9tYCBvcHRpb24gUG9zdENTUyBjb3VsZCBnZW5lcmF0ZSB3cm9uZyBzb3VyY2UgbWFwIGFuZCB3aWxsIG5vdCBmaW5kIEJyb3dzZXJzbGlzdCBjb25maWcuIFNldCBpdCB0byBDU1MgZmlsZSBwYXRoIG9yIHRvIGB1bmRlZmluZWRgIHRvIHByZXZlbnQgdGhpcyB3YXJuaW5nLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hc3luYygpLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH07XG4gICAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jc3M7XG4gICAgfTtcbiAgICBfcHJvdG8ud2FybmluZ3MgPSBmdW5jdGlvbiB3YXJuaW5ncygpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH07XG4gICAgX2NyZWF0ZV9jbGFzcyhOb1dvcmtSZXN1bHQsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNvbnRlbnRcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdC5jc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjc3NcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdC5jc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJtYXBcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdC5tYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJtZXNzYWdlc1wiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwib3B0c1wiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0Lm9wdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJwcm9jZXNzb3JcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdC5wcm9jZXNzb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJyb290XCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcm9vdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9vdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJvb3QyO1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZXIyID0gcGFyc2UkMSQxO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QyID0gcGFyc2VyMih0aGlzLl9jc3MsIHRoaXMuX29wdHMpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5lcnJvcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yb290ID0gcm9vdDI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb290MjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogU3ltYm9sLnRvU3RyaW5nVGFnLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiTm9Xb3JrUmVzdWx0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gTm9Xb3JrUmVzdWx0O1xufSgpO1xudmFyIG5vV29ya1Jlc3VsdCQxID0gTm9Xb3JrUmVzdWx0JDEkMTtcbk5vV29ya1Jlc3VsdCQxJDEuZGVmYXVsdCA9IE5vV29ya1Jlc3VsdCQxJDE7XG52YXIgTm9Xb3JrUmVzdWx0MiQxID0gbm9Xb3JrUmVzdWx0JDE7XG52YXIgTGF6eVJlc3VsdCQxJDEgPSBsYXp5UmVzdWx0JDE7XG52YXIgRG9jdW1lbnQkMSQxID0gZG9jdW1lbnQkMSQxO1xudmFyIFJvb3QkMiQxID0gcm9vdCQxO1xudmFyIFByb2Nlc3NvciQxJDEgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFByb2Nlc3NvcihwbHVnaW5zKSB7XG4gICAgICAgIGlmIChwbHVnaW5zID09PSB2b2lkIDApIHBsdWdpbnMgPSBbXTtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gXCI4LjQuMzhcIjtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gdGhpcy5ub3JtYWxpemUocGx1Z2lucyk7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBQcm9jZXNzb3IucHJvdG90eXBlO1xuICAgIF9wcm90by5ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUocGx1Z2lucykge1xuICAgICAgICB2YXIgbm9ybWFsaXplZCA9IFtdO1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShwbHVnaW5zKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIGkyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICBpZiAoaTIucG9zdGNzcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGkyID0gaTIoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaTIucG9zdGNzcykge1xuICAgICAgICAgICAgICAgIGkyID0gaTIucG9zdGNzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodHlwZW9mIGkyID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKGkyKSkgPT09IFwib2JqZWN0XCIgJiYgQXJyYXkuaXNBcnJheShpMi5wbHVnaW5zKSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVkLmNvbmNhdChpMi5wbHVnaW5zKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBpMiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihpMikpID09PSBcIm9iamVjdFwiICYmIGkyLnBvc3Rjc3NQbHVnaW4pIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkLnB1c2goaTIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWQucHVzaChpMik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCh0eXBlb2YgaTIgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YoaTIpKSA9PT0gXCJvYmplY3RcIiAmJiAoaTIucGFyc2UgfHwgaTIuc3RyaW5naWZ5KSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9zdENTUyBzeW50YXhlcyBjYW5ub3QgYmUgdXNlZCBhcyBwbHVnaW5zLiBJbnN0ZWFkLCBwbGVhc2UgdXNlIG9uZSBvZiB0aGUgc3ludGF4L3BhcnNlci9zdHJpbmdpZmllciBvcHRpb25zIGFzIG91dGxpbmVkIGluIHlvdXIgUG9zdENTUyBydW5uZXIgZG9jdW1lbnRhdGlvbi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaTIgKyBcIiBpcyBub3QgYSBQb3N0Q1NTIHBsdWdpblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZDtcbiAgICB9O1xuICAgIF9wcm90by5wcm9jZXNzID0gZnVuY3Rpb24gcHJvY2VzczEoY3NzLCBvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzID09PSB2b2lkIDApIG9wdHMgPSB7fTtcbiAgICAgICAgaWYgKCF0aGlzLnBsdWdpbnMubGVuZ3RoICYmICFvcHRzLnBhcnNlciAmJiAhb3B0cy5zdHJpbmdpZmllciAmJiAhb3B0cy5zeW50YXgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm9Xb3JrUmVzdWx0MiQxKHRoaXMsIGNzcywgb3B0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExhenlSZXN1bHQkMSQxKHRoaXMsIGNzcywgb3B0cyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by51c2UgPSBmdW5jdGlvbiB1c2UocGx1Z2luMjIpIHtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gdGhpcy5wbHVnaW5zLmNvbmNhdCh0aGlzLm5vcm1hbGl6ZShbXG4gICAgICAgICAgICBwbHVnaW4yMlxuICAgICAgICBdKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIFByb2Nlc3Nvcjtcbn0oKTtcbnZhciBwcm9jZXNzb3IkMSA9IFByb2Nlc3NvciQxJDE7XG5Qcm9jZXNzb3IkMSQxLmRlZmF1bHQgPSBQcm9jZXNzb3IkMSQxO1xuUm9vdCQyJDEucmVnaXN0ZXJQcm9jZXNzb3IoUHJvY2Vzc29yJDEkMSk7XG5Eb2N1bWVudCQxJDEucmVnaXN0ZXJQcm9jZXNzb3IoUHJvY2Vzc29yJDEkMSk7XG52YXIgRGVjbGFyYXRpb24kMSQxID0gZGVjbGFyYXRpb24kMTtcbnZhciBQcmV2aW91c01hcDIkMSA9IHByZXZpb3VzTWFwJDE7XG52YXIgQ29tbWVudCQxJDEgPSBjb21tZW50JDE7XG52YXIgQXRSdWxlJDEkMSA9IGF0UnVsZSQxO1xudmFyIElucHV0JDEkMSA9IGlucHV0JDE7XG52YXIgUm9vdCQxJDEgPSByb290JDE7XG52YXIgUnVsZSQxJDEgPSBydWxlJDE7XG5mdW5jdGlvbiBmcm9tSlNPTiQxJDEoanNvbiwgaW5wdXRzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoanNvbikpIHJldHVybiBqc29uLm1hcChmdW5jdGlvbihuMikge1xuICAgICAgICByZXR1cm4gZnJvbUpTT04kMSQxKG4yKTtcbiAgICB9KTtcbiAgICB2YXIgb3duSW5wdXRzID0ganNvbi5pbnB1dHMsIGRlZmF1bHRzID0gX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UoanNvbiwgW1xuICAgICAgICBcImlucHV0c1wiXG4gICAgXSk7XG4gICAgaWYgKG93bklucHV0cykge1xuICAgICAgICBpbnB1dHMgPSBbXTtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uob3duSW5wdXRzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIGlucHV0MiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGlucHV0SHlkcmF0ZWQgPSBfZXh0ZW5kcyh7fSwgaW5wdXQyLCB7XG4gICAgICAgICAgICAgICAgX19wcm90b19fOiBJbnB1dCQxJDEucHJvdG90eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpbnB1dEh5ZHJhdGVkLm1hcCkge1xuICAgICAgICAgICAgICAgIGlucHV0SHlkcmF0ZWQubWFwID0gX2V4dGVuZHMoe30sIGlucHV0SHlkcmF0ZWQubWFwLCB7XG4gICAgICAgICAgICAgICAgICAgIF9fcHJvdG9fXzogUHJldmlvdXNNYXAyJDEucHJvdG90eXBlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dHMucHVzaChpbnB1dEh5ZHJhdGVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmYXVsdHMubm9kZXMpIHtcbiAgICAgICAgZGVmYXVsdHMubm9kZXMgPSBqc29uLm5vZGVzLm1hcChmdW5jdGlvbihuMikge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21KU09OJDEkMShuMiwgaW5wdXRzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChkZWZhdWx0cy5zb3VyY2UpIHtcbiAgICAgICAgdmFyIF9kZWZhdWx0c19zb3VyY2UgPSBkZWZhdWx0cy5zb3VyY2UsIGlucHV0SWQgPSBfZGVmYXVsdHNfc291cmNlLmlucHV0SWQsIHNvdXJjZSA9IF9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlKF9kZWZhdWx0c19zb3VyY2UsIFtcbiAgICAgICAgICAgIFwiaW5wdXRJZFwiXG4gICAgICAgIF0pO1xuICAgICAgICBkZWZhdWx0cy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIGlmIChpbnB1dElkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRlZmF1bHRzLnNvdXJjZS5pbnB1dCA9IGlucHV0c1tpbnB1dElkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmYXVsdHMudHlwZSA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSb290JDEkMShkZWZhdWx0cyk7XG4gICAgfSBlbHNlIGlmIChkZWZhdWx0cy50eXBlID09PSBcImRlY2xcIikge1xuICAgICAgICByZXR1cm4gbmV3IERlY2xhcmF0aW9uJDEkMShkZWZhdWx0cyk7XG4gICAgfSBlbHNlIGlmIChkZWZhdWx0cy50eXBlID09PSBcInJ1bGVcIikge1xuICAgICAgICByZXR1cm4gbmV3IFJ1bGUkMSQxKGRlZmF1bHRzKTtcbiAgICB9IGVsc2UgaWYgKGRlZmF1bHRzLnR5cGUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tbWVudCQxJDEoZGVmYXVsdHMpO1xuICAgIH0gZWxzZSBpZiAoZGVmYXVsdHMudHlwZSA9PT0gXCJhdHJ1bGVcIikge1xuICAgICAgICByZXR1cm4gbmV3IEF0UnVsZSQxJDEoZGVmYXVsdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbm9kZSB0eXBlOiBcIiArIGpzb24udHlwZSk7XG4gICAgfVxufVxudmFyIGZyb21KU09OXzEkMSA9IGZyb21KU09OJDEkMTtcbmZyb21KU09OJDEkMS5kZWZhdWx0ID0gZnJvbUpTT04kMSQxO1xudmFyIENzc1N5bnRheEVycm9yMiQxID0gY3NzU3ludGF4RXJyb3IkMTtcbnZhciBEZWNsYXJhdGlvbjIkMSA9IGRlY2xhcmF0aW9uJDE7XG52YXIgTGF6eVJlc3VsdDIkMSA9IGxhenlSZXN1bHQkMTtcbnZhciBDb250YWluZXIyJDEgPSBjb250YWluZXIkMTtcbnZhciBQcm9jZXNzb3IyJDEgPSBwcm9jZXNzb3IkMTtcbnZhciBzdHJpbmdpZnkkNSA9IHN0cmluZ2lmeV8xJDE7XG52YXIgZnJvbUpTT04kMiA9IGZyb21KU09OXzEkMTtcbnZhciBEb2N1bWVudDIyID0gZG9jdW1lbnQkMSQxO1xudmFyIFdhcm5pbmcyJDEgPSB3YXJuaW5nJDE7XG52YXIgQ29tbWVudDIkMSA9IGNvbW1lbnQkMTtcbnZhciBBdFJ1bGUyJDEgPSBhdFJ1bGUkMTtcbnZhciBSZXN1bHQyJDEgPSByZXN1bHQkMTtcbnZhciBJbnB1dDIkMSA9IGlucHV0JDE7XG52YXIgcGFyc2UkNSA9IHBhcnNlXzEkMTtcbnZhciBsaXN0JDMgPSBsaXN0XzEkMTtcbnZhciBSdWxlMiQxID0gcnVsZSQxO1xudmFyIFJvb3QyJDEgPSByb290JDE7XG52YXIgTm9kZTIkMSA9IG5vZGUkMTtcbmZ1bmN0aW9uIHBvc3Rjc3MkMygpIHtcbiAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwbHVnaW5zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgIHBsdWdpbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIGlmIChwbHVnaW5zLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KHBsdWdpbnNbMF0pKSB7XG4gICAgICAgIHBsdWdpbnMgPSBwbHVnaW5zWzBdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb2Nlc3NvcjIkMShwbHVnaW5zKTtcbn1cbnBvc3Rjc3MkMy5wbHVnaW4gPSBmdW5jdGlvbiBwbHVnaW4obmFtZSwgaW5pdGlhbGl6ZXIpIHtcbiAgICB2YXIgd2FybmluZ1ByaW50ZWQgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBjcmVhdG9yKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybiAmJiAhd2FybmluZ1ByaW50ZWQpIHtcbiAgICAgICAgICAgIHdhcm5pbmdQcmludGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihuYW1lICsgXCI6IHBvc3Rjc3MucGx1Z2luIHdhcyBkZXByZWNhdGVkLiBNaWdyYXRpb24gZ3VpZGU6XFxuaHR0cHM6Ly9ldmlsbWFydGlhbnMuY29tL2Nocm9uaWNsZXMvcG9zdGNzcy04LXBsdWdpbi1taWdyYXRpb25cIik7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTEFORyAmJiBwcm9jZXNzLmVudi5MQU5HLnN0YXJ0c1dpdGgoXCJjblwiKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihuYW1lICsgXCI6IOmHjOmdoiBwb3N0Y3NzLnBsdWdpbiDooqvlvIPnlKguIOi/geenu+aMh+WNlzpcXG5odHRwczovL3d3dy53M2N0ZWNoLmNvbS90b3BpYy8yMjI2XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lciA9IGluaXRpYWxpemVyLmFwcGx5KHZvaWQgMCwgW10uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgdHJhbnNmb3JtZXIucG9zdGNzc1BsdWdpbiA9IG5hbWU7XG4gICAgICAgIHRyYW5zZm9ybWVyLnBvc3Rjc3NWZXJzaW9uID0gbmV3IFByb2Nlc3NvcjIkMSgpLnZlcnNpb247XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lcjtcbiAgICB9XG4gICAgdmFyIGNhY2hlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdG9yLCBcInBvc3Rjc3NcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGUpIGNhY2hlID0gY3JlYXRvcigpO1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY3JlYXRvci5wcm9jZXNzID0gZnVuY3Rpb24oY3NzLCBwcm9jZXNzT3B0cywgcGx1Z2luT3B0cykge1xuICAgICAgICByZXR1cm4gcG9zdGNzcyQzKFtcbiAgICAgICAgICAgIGNyZWF0b3IocGx1Z2luT3B0cylcbiAgICAgICAgXSkucHJvY2Vzcyhjc3MsIHByb2Nlc3NPcHRzKTtcbiAgICB9O1xuICAgIHJldHVybiBjcmVhdG9yO1xufTtcbnBvc3Rjc3MkMy5zdHJpbmdpZnkgPSBzdHJpbmdpZnkkNTtcbnBvc3Rjc3MkMy5wYXJzZSA9IHBhcnNlJDU7XG5wb3N0Y3NzJDMuZnJvbUpTT04gPSBmcm9tSlNPTiQyO1xucG9zdGNzcyQzLmxpc3QgPSBsaXN0JDM7XG5wb3N0Y3NzJDMuY29tbWVudCA9IGZ1bmN0aW9uKGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIG5ldyBDb21tZW50MiQxKGRlZmF1bHRzKTtcbn07XG5wb3N0Y3NzJDMuYXRSdWxlID0gZnVuY3Rpb24oZGVmYXVsdHMpIHtcbiAgICByZXR1cm4gbmV3IEF0UnVsZTIkMShkZWZhdWx0cyk7XG59O1xucG9zdGNzcyQzLmRlY2wgPSBmdW5jdGlvbihkZWZhdWx0cykge1xuICAgIHJldHVybiBuZXcgRGVjbGFyYXRpb24yJDEoZGVmYXVsdHMpO1xufTtcbnBvc3Rjc3MkMy5ydWxlID0gZnVuY3Rpb24oZGVmYXVsdHMpIHtcbiAgICByZXR1cm4gbmV3IFJ1bGUyJDEoZGVmYXVsdHMpO1xufTtcbnBvc3Rjc3MkMy5yb290ID0gZnVuY3Rpb24oZGVmYXVsdHMpIHtcbiAgICByZXR1cm4gbmV3IFJvb3QyJDEoZGVmYXVsdHMpO1xufTtcbnBvc3Rjc3MkMy5kb2N1bWVudCA9IGZ1bmN0aW9uKGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIG5ldyBEb2N1bWVudDIyKGRlZmF1bHRzKTtcbn07XG5wb3N0Y3NzJDMuQ3NzU3ludGF4RXJyb3IgPSBDc3NTeW50YXhFcnJvcjIkMTtcbnBvc3Rjc3MkMy5EZWNsYXJhdGlvbiA9IERlY2xhcmF0aW9uMiQxO1xucG9zdGNzcyQzLkNvbnRhaW5lciA9IENvbnRhaW5lcjIkMTtcbnBvc3Rjc3MkMy5Qcm9jZXNzb3IgPSBQcm9jZXNzb3IyJDE7XG5wb3N0Y3NzJDMuRG9jdW1lbnQgPSBEb2N1bWVudDIyO1xucG9zdGNzcyQzLkNvbW1lbnQgPSBDb21tZW50MiQxO1xucG9zdGNzcyQzLldhcm5pbmcgPSBXYXJuaW5nMiQxO1xucG9zdGNzcyQzLkF0UnVsZSA9IEF0UnVsZTIkMTtcbnBvc3Rjc3MkMy5SZXN1bHQgPSBSZXN1bHQyJDE7XG5wb3N0Y3NzJDMuSW5wdXQgPSBJbnB1dDIkMTtcbnBvc3Rjc3MkMy5SdWxlID0gUnVsZTIkMTtcbnBvc3Rjc3MkMy5Sb290ID0gUm9vdDIkMTtcbnBvc3Rjc3MkMy5Ob2RlID0gTm9kZTIkMTtcbkxhenlSZXN1bHQyJDEucmVnaXN0ZXJQb3N0Y3NzKHBvc3Rjc3MkMyk7XG52YXIgcG9zdGNzc18xJDEgPSBwb3N0Y3NzJDM7XG5wb3N0Y3NzJDMuZGVmYXVsdCA9IHBvc3Rjc3MkMztcbnZhciBwb3N0Y3NzJDEkMSA9IC8qIEBfX1BVUkVfXyAqLyBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyQxKHBvc3Rjc3NfMSQxKTtcbnBvc3Rjc3MkMSQxLnN0cmluZ2lmeTtcbnBvc3Rjc3MkMSQxLmZyb21KU09OO1xucG9zdGNzcyQxJDEucGx1Z2luO1xucG9zdGNzcyQxJDEucGFyc2U7XG5wb3N0Y3NzJDEkMS5saXN0O1xucG9zdGNzcyQxJDEuZG9jdW1lbnQ7XG5wb3N0Y3NzJDEkMS5jb21tZW50O1xucG9zdGNzcyQxJDEuYXRSdWxlO1xucG9zdGNzcyQxJDEucnVsZTtcbnBvc3Rjc3MkMSQxLmRlY2w7XG5wb3N0Y3NzJDEkMS5yb290O1xucG9zdGNzcyQxJDEuQ3NzU3ludGF4RXJyb3I7XG5wb3N0Y3NzJDEkMS5EZWNsYXJhdGlvbjtcbnBvc3Rjc3MkMSQxLkNvbnRhaW5lcjtcbnBvc3Rjc3MkMSQxLlByb2Nlc3NvcjtcbnBvc3Rjc3MkMSQxLkRvY3VtZW50O1xucG9zdGNzcyQxJDEuQ29tbWVudDtcbnBvc3Rjc3MkMSQxLldhcm5pbmc7XG5wb3N0Y3NzJDEkMS5BdFJ1bGU7XG5wb3N0Y3NzJDEkMS5SZXN1bHQ7XG5wb3N0Y3NzJDEkMS5JbnB1dDtcbnBvc3Rjc3MkMSQxLlJ1bGU7XG5wb3N0Y3NzJDEkMS5Sb290O1xucG9zdGNzcyQxJDEuTm9kZTtcbnZhciBfX2RlZlByb3AyID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcDIgPSBmdW5jdGlvbihvYmosIGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcDIob2JqLCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xufTtcbnZhciBfX3B1YmxpY0ZpZWxkMiA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBfX2RlZk5vcm1hbFByb3AyKG9iaiwgKHR5cGVvZiBrZXkgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2Yoa2V5KSkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG59O1xuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoeDIpIHtcbiAgICByZXR1cm4geDIgJiYgeDIuX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeDIsIFwiZGVmYXVsdFwiKSA/IHgyW1wiZGVmYXVsdFwiXSA6IHgyO1xufVxuZnVuY3Rpb24gZ2V0QXVnbWVudGVkTmFtZXNwYWNlKG4yKSB7XG4gICAgaWYgKG4yLl9fZXNNb2R1bGUpIHJldHVybiBuMjtcbiAgICB2YXIgZjIgPSBuMi5kZWZhdWx0O1xuICAgIGlmICh0eXBlb2YgZjIgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHZhciBhMiA9IGZ1bmN0aW9uIGEyMigpIHtcbiAgICAgICAgICAgIGlmIChfaW5zdGFuY2VvZih0aGlzLCBhMjIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuY29uc3RydWN0KGYyLCBhcmd1bWVudHMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICAgIGEyLnByb3RvdHlwZSA9IGYyLnByb3RvdHlwZTtcbiAgICB9IGVsc2UgYTIgPSB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYTIsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmtleXMobjIpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgICB2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobjIsIGspO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYTIsIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbjJba107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBhMjtcbn1cbnZhciBwaWNvY29sb3JzX2Jyb3dzZXIgPSB7XG4gICAgZXhwb3J0czoge31cbn07XG52YXIgeCA9IFN0cmluZztcbnZhciBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNDb2xvclN1cHBvcnRlZDogZmFsc2UsXG4gICAgICAgIHJlc2V0OiB4LFxuICAgICAgICBib2xkOiB4LFxuICAgICAgICBkaW06IHgsXG4gICAgICAgIGl0YWxpYzogeCxcbiAgICAgICAgdW5kZXJsaW5lOiB4LFxuICAgICAgICBpbnZlcnNlOiB4LFxuICAgICAgICBoaWRkZW46IHgsXG4gICAgICAgIHN0cmlrZXRocm91Z2g6IHgsXG4gICAgICAgIGJsYWNrOiB4LFxuICAgICAgICByZWQ6IHgsXG4gICAgICAgIGdyZWVuOiB4LFxuICAgICAgICB5ZWxsb3c6IHgsXG4gICAgICAgIGJsdWU6IHgsXG4gICAgICAgIG1hZ2VudGE6IHgsXG4gICAgICAgIGN5YW46IHgsXG4gICAgICAgIHdoaXRlOiB4LFxuICAgICAgICBncmF5OiB4LFxuICAgICAgICBiZ0JsYWNrOiB4LFxuICAgICAgICBiZ1JlZDogeCxcbiAgICAgICAgYmdHcmVlbjogeCxcbiAgICAgICAgYmdZZWxsb3c6IHgsXG4gICAgICAgIGJnQmx1ZTogeCxcbiAgICAgICAgYmdNYWdlbnRhOiB4LFxuICAgICAgICBiZ0N5YW46IHgsXG4gICAgICAgIGJnV2hpdGU6IHhcbiAgICB9O1xufTtcbnBpY29jb2xvcnNfYnJvd3Nlci5leHBvcnRzID0gY3JlYXRlKCk7XG5waWNvY29sb3JzX2Jyb3dzZXIuZXhwb3J0cy5jcmVhdGVDb2xvcnMgPSBjcmVhdGU7XG52YXIgcGljb2NvbG9yc19icm93c2VyRXhwb3J0cyA9IHBpY29jb2xvcnNfYnJvd3Nlci5leHBvcnRzO1xudmFyIF9fdml0ZUJyb3dzZXJFeHRlcm5hbCA9IHt9O1xudmFyIF9fdml0ZUJyb3dzZXJFeHRlcm5hbCQxID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGRlZmF1bHQ6IF9fdml0ZUJyb3dzZXJFeHRlcm5hbFxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgdmFsdWU6IFwiTW9kdWxlXCJcbn0pKTtcbnZhciByZXF1aXJlJCQyID0gLyogQF9fUFVSRV9fICovIGdldEF1Z21lbnRlZE5hbWVzcGFjZShfX3ZpdGVCcm93c2VyRXh0ZXJuYWwkMSk7XG52YXIgcGljbyA9IHBpY29jb2xvcnNfYnJvd3NlckV4cG9ydHM7XG52YXIgdGVybWluYWxIaWdobGlnaHQkMSA9IHJlcXVpcmUkJDI7XG52YXIgQ3NzU3ludGF4RXJyb3IkMyA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oRXJyb3IxKSB7XG4gICAgX2luaGVyaXRzKENzc1N5bnRheEVycm9yMiwgRXJyb3IxKTtcbiAgICBmdW5jdGlvbiBDc3NTeW50YXhFcnJvcjIobWVzc2FnZSwgbGluZSwgY29sdW1uLCBzb3VyY2UsIGZpbGUsIHBsdWdpbjIyKSB7XG4gICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgX3RoaXMgPSBFcnJvcjEuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gXCJDc3NTeW50YXhFcnJvclwiO1xuICAgICAgICBfdGhpcy5yZWFzb24gPSBtZXNzYWdlO1xuICAgICAgICBpZiAoZmlsZSkge1xuICAgICAgICAgICAgX3RoaXMuZmlsZSA9IGZpbGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgX3RoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwbHVnaW4yMikge1xuICAgICAgICAgICAgX3RoaXMucGx1Z2luID0gcGx1Z2luMjI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsaW5lICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBjb2x1bW4gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGluZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIF90aGlzLmxpbmUgPSBsaW5lO1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubGluZSA9IGxpbmUubGluZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb2x1bW4gPSBsaW5lLmNvbHVtbjtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbmRMaW5lID0gY29sdW1uLmxpbmU7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW5kQ29sdW1uID0gY29sdW1uLmNvbHVtbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5zZXRNZXNzYWdlKCk7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoX3RoaXMsIENzc1N5bnRheEVycm9yMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gQ3NzU3ludGF4RXJyb3IyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uc2V0TWVzc2FnZSA9IGZ1bmN0aW9uIHNldE1lc3NhZ2UoKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHRoaXMucGx1Z2luID8gdGhpcy5wbHVnaW4gKyBcIjogXCIgOiBcIlwiO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgKz0gdGhpcy5maWxlID8gdGhpcy5maWxlIDogXCI8Y3NzIGlucHV0PlwiO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMubGluZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlICs9IFwiOlwiICsgdGhpcy5saW5lICsgXCI6XCIgKyB0aGlzLmNvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lc3NhZ2UgKz0gXCI6IFwiICsgdGhpcy5yZWFzb247XG4gICAgfTtcbiAgICBfcHJvdG8uc2hvd1NvdXJjZUNvZGUgPSBmdW5jdGlvbiBzaG93U291cmNlQ29kZShjb2xvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuc291cmNlKSByZXR1cm4gXCJcIjtcbiAgICAgICAgdmFyIGNzcyA9IHRoaXMuc291cmNlO1xuICAgICAgICBpZiAoY29sb3IgPT0gbnVsbCkgY29sb3IgPSBwaWNvLmlzQ29sb3JTdXBwb3J0ZWQ7XG4gICAgICAgIGlmICh0ZXJtaW5hbEhpZ2hsaWdodCQxKSB7XG4gICAgICAgICAgICBpZiAoY29sb3IpIGNzcyA9IHRlcm1pbmFsSGlnaGxpZ2h0JDEoY3NzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGluZXMgPSBjc3Muc3BsaXQoL1xccj9cXG4vKTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgodGhpcy5saW5lIC0gMywgMCk7XG4gICAgICAgIHZhciBlbmQgPSBNYXRoLm1pbih0aGlzLmxpbmUgKyAyLCBsaW5lcy5sZW5ndGgpO1xuICAgICAgICB2YXIgbWF4V2lkdGggPSBTdHJpbmcoZW5kKS5sZW5ndGg7XG4gICAgICAgIHZhciBtYXJrLCBhc2lkZTtcbiAgICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgICAgICB2YXIgX3BpY29fY3JlYXRlQ29sb3JzID0gcGljby5jcmVhdGVDb2xvcnModHJ1ZSksIGJvbGQgPSBfcGljb19jcmVhdGVDb2xvcnMuYm9sZCwgZ3JheSA9IF9waWNvX2NyZWF0ZUNvbG9ycy5ncmF5LCByZWQgPSBfcGljb19jcmVhdGVDb2xvcnMucmVkO1xuICAgICAgICAgICAgbWFyayA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYm9sZChyZWQodGV4dCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFzaWRlID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBncmF5KHRleHQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hcmsgPSBhc2lkZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lcy5zbGljZShzdGFydCwgZW5kKS5tYXAoZnVuY3Rpb24obGluZSwgaW5kZXgyKSB7XG4gICAgICAgICAgICB2YXIgbnVtYmVyID0gc3RhcnQgKyAxICsgaW5kZXgyO1xuICAgICAgICAgICAgdmFyIGd1dHRlciA9IFwiIFwiICsgKFwiIFwiICsgbnVtYmVyKS5zbGljZSgtbWF4V2lkdGgpICsgXCIgfCBcIjtcbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09IF90aGlzLmxpbmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3BhY2luZyA9IGFzaWRlKGd1dHRlci5yZXBsYWNlKC9cXGQvZywgXCIgXCIpKSArIGxpbmUuc2xpY2UoMCwgX3RoaXMuY29sdW1uIC0gMSkucmVwbGFjZSgvW15cXHRdL2csIFwiIFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFyayhcIj5cIikgKyBhc2lkZShndXR0ZXIpICsgbGluZSArIFwiXFxuIFwiICsgc3BhY2luZyArIG1hcmsoXCJeXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwiIFwiICsgYXNpZGUoZ3V0dGVyKSArIGxpbmU7XG4gICAgICAgIH0pLmpvaW4oXCJcXG5cIik7XG4gICAgfTtcbiAgICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgdmFyIGNvZGUgPSB0aGlzLnNob3dTb3VyY2VDb2RlKCk7XG4gICAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgICAgICBjb2RlID0gXCJcXG5cXG5cIiArIGNvZGUgKyBcIlxcblwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2UgKyBjb2RlO1xuICAgIH07XG4gICAgcmV0dXJuIENzc1N5bnRheEVycm9yMjtcbn0oX3dyYXBfbmF0aXZlX3N1cGVyKEVycm9yKSk7XG52YXIgY3NzU3ludGF4RXJyb3IgPSBDc3NTeW50YXhFcnJvciQzO1xuQ3NzU3ludGF4RXJyb3IkMy5kZWZhdWx0ID0gQ3NzU3ludGF4RXJyb3IkMztcbnZhciBzeW1ib2xzID0ge307XG5zeW1ib2xzLmlzQ2xlYW4gPSBTeW1ib2woXCJpc0NsZWFuXCIpO1xuc3ltYm9scy5teSA9IFN5bWJvbChcIm15XCIpO1xudmFyIERFRkFVTFRfUkFXID0ge1xuICAgIGFmdGVyOiBcIlxcblwiLFxuICAgIGJlZm9yZUNsb3NlOiBcIlxcblwiLFxuICAgIGJlZm9yZUNvbW1lbnQ6IFwiXFxuXCIsXG4gICAgYmVmb3JlRGVjbDogXCJcXG5cIixcbiAgICBiZWZvcmVPcGVuOiBcIiBcIixcbiAgICBiZWZvcmVSdWxlOiBcIlxcblwiLFxuICAgIGNvbG9uOiBcIjogXCIsXG4gICAgY29tbWVudExlZnQ6IFwiIFwiLFxuICAgIGNvbW1lbnRSaWdodDogXCIgXCIsXG4gICAgZW1wdHlCb2R5OiBcIlwiLFxuICAgIGluZGVudDogXCIgICAgXCIsXG4gICAgc2VtaWNvbG9uOiBmYWxzZVxufTtcbmZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyKSB7XG4gICAgcmV0dXJuIHN0clswXS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufVxudmFyIFN0cmluZ2lmaWVyJDIgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFN0cmluZ2lmaWVyMihidWlsZGVyKSB7XG4gICAgICAgIHRoaXMuYnVpbGRlciA9IGJ1aWxkZXI7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBTdHJpbmdpZmllcjIucHJvdG90eXBlO1xuICAgIF9wcm90by5hdHJ1bGUgPSBmdW5jdGlvbiBhdHJ1bGUobm9kZTIsIHNlbWljb2xvbikge1xuICAgICAgICB2YXIgbmFtZSA9IFwiQFwiICsgbm9kZTIubmFtZTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IG5vZGUyLnBhcmFtcyA/IHRoaXMucmF3VmFsdWUobm9kZTIsIFwicGFyYW1zXCIpIDogXCJcIjtcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlMi5yYXdzLmFmdGVyTmFtZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbmFtZSArPSBub2RlMi5yYXdzLmFmdGVyTmFtZTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICAgIG5hbWUgKz0gXCIgXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUyLm5vZGVzKSB7XG4gICAgICAgICAgICB0aGlzLmJsb2NrKG5vZGUyLCBuYW1lICsgcGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBlbmQgPSAobm9kZTIucmF3cy5iZXR3ZWVuIHx8IFwiXCIpICsgKHNlbWljb2xvbiA/IFwiO1wiIDogXCJcIik7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkZXIobmFtZSArIHBhcmFtcyArIGVuZCwgbm9kZTIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uYmVmb3JlQWZ0ZXIgPSBmdW5jdGlvbiBiZWZvcmVBZnRlcihub2RlMiwgZGV0ZWN0KSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgaWYgKG5vZGUyLnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImJlZm9yZURlY2xcIik7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZTIudHlwZSA9PT0gXCJjb21tZW50XCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZTIsIG51bGwsIFwiYmVmb3JlQ29tbWVudFwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChkZXRlY3QgPT09IFwiYmVmb3JlXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZTIsIG51bGwsIFwiYmVmb3JlUnVsZVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZTIsIG51bGwsIFwiYmVmb3JlQ2xvc2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ1ZiA9IG5vZGUyLnBhcmVudDtcbiAgICAgICAgdmFyIGRlcHRoID0gMDtcbiAgICAgICAgd2hpbGUoYnVmICYmIGJ1Zi50eXBlICE9PSBcInJvb3RcIil7XG4gICAgICAgICAgICBkZXB0aCArPSAxO1xuICAgICAgICAgICAgYnVmID0gYnVmLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgICAgICAgIHZhciBpbmRlbnQgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJpbmRlbnRcIik7XG4gICAgICAgICAgICBpZiAoaW5kZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgc3RlcCA9IDA7IHN0ZXAgPCBkZXB0aDsgc3RlcCsrKXZhbHVlICs9IGluZGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8uYmxvY2sgPSBmdW5jdGlvbiBibG9jayhub2RlMiwgc3RhcnQpIHtcbiAgICAgICAgdmFyIGJldHdlZW4gPSB0aGlzLnJhdyhub2RlMiwgXCJiZXR3ZWVuXCIsIFwiYmVmb3JlT3BlblwiKTtcbiAgICAgICAgdGhpcy5idWlsZGVyKHN0YXJ0ICsgYmV0d2VlbiArIFwie1wiLCBub2RlMiwgXCJzdGFydFwiKTtcbiAgICAgICAgdmFyIGFmdGVyO1xuICAgICAgICBpZiAobm9kZTIubm9kZXMgJiYgbm9kZTIubm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmJvZHkobm9kZTIpO1xuICAgICAgICAgICAgYWZ0ZXIgPSB0aGlzLnJhdyhub2RlMiwgXCJhZnRlclwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFmdGVyID0gdGhpcy5yYXcobm9kZTIsIFwiYWZ0ZXJcIiwgXCJlbXB0eUJvZHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFmdGVyKSB0aGlzLmJ1aWxkZXIoYWZ0ZXIpO1xuICAgICAgICB0aGlzLmJ1aWxkZXIoXCJ9XCIsIG5vZGUyLCBcImVuZFwiKTtcbiAgICB9O1xuICAgIF9wcm90by5ib2R5ID0gZnVuY3Rpb24gYm9keShub2RlMikge1xuICAgICAgICB2YXIgbGFzdCA9IG5vZGUyLm5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlKGxhc3QgPiAwKXtcbiAgICAgICAgICAgIGlmIChub2RlMi5ub2Rlc1tsYXN0XS50eXBlICE9PSBcImNvbW1lbnRcIikgYnJlYWs7XG4gICAgICAgICAgICBsYXN0IC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbWljb2xvbiA9IHRoaXMucmF3KG5vZGUyLCBcInNlbWljb2xvblwiKTtcbiAgICAgICAgZm9yKHZhciBpMiA9IDA7IGkyIDwgbm9kZTIubm9kZXMubGVuZ3RoOyBpMisrKXtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGUyLm5vZGVzW2kyXTtcbiAgICAgICAgICAgIHZhciBiZWZvcmUgPSB0aGlzLnJhdyhjaGlsZCwgXCJiZWZvcmVcIik7XG4gICAgICAgICAgICBpZiAoYmVmb3JlKSB0aGlzLmJ1aWxkZXIoYmVmb3JlKTtcbiAgICAgICAgICAgIHRoaXMuc3RyaW5naWZ5KGNoaWxkLCBsYXN0ICE9PSBpMiB8fCBzZW1pY29sb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uY29tbWVudCA9IGZ1bmN0aW9uIGNvbW1lbnQobm9kZTIpIHtcbiAgICAgICAgdmFyIGxlZnQgPSB0aGlzLnJhdyhub2RlMiwgXCJsZWZ0XCIsIFwiY29tbWVudExlZnRcIik7XG4gICAgICAgIHZhciByaWdodCA9IHRoaXMucmF3KG5vZGUyLCBcInJpZ2h0XCIsIFwiY29tbWVudFJpZ2h0XCIpO1xuICAgICAgICB0aGlzLmJ1aWxkZXIoXCIvKlwiICsgbGVmdCArIG5vZGUyLnRleHQgKyByaWdodCArIFwiKi9cIiwgbm9kZTIpO1xuICAgIH07XG4gICAgX3Byb3RvLmRlY2wgPSBmdW5jdGlvbiBkZWNsKG5vZGUyLCBzZW1pY29sb24pIHtcbiAgICAgICAgdmFyIGJldHdlZW4gPSB0aGlzLnJhdyhub2RlMiwgXCJiZXR3ZWVuXCIsIFwiY29sb25cIik7XG4gICAgICAgIHZhciBzdHJpbmcgPSBub2RlMi5wcm9wICsgYmV0d2VlbiArIHRoaXMucmF3VmFsdWUobm9kZTIsIFwidmFsdWVcIik7XG4gICAgICAgIGlmIChub2RlMi5pbXBvcnRhbnQpIHtcbiAgICAgICAgICAgIHN0cmluZyArPSBub2RlMi5yYXdzLmltcG9ydGFudCB8fCBcIiAhaW1wb3J0YW50XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbWljb2xvbikgc3RyaW5nICs9IFwiO1wiO1xuICAgICAgICB0aGlzLmJ1aWxkZXIoc3RyaW5nLCBub2RlMik7XG4gICAgfTtcbiAgICBfcHJvdG8uZG9jdW1lbnQgPSBmdW5jdGlvbiBkb2N1bWVudDEobm9kZTIpIHtcbiAgICAgICAgdGhpcy5ib2R5KG5vZGUyKTtcbiAgICB9O1xuICAgIF9wcm90by5yYXcgPSBmdW5jdGlvbiByYXcobm9kZTIsIG93biwgZGV0ZWN0KSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgaWYgKCFkZXRlY3QpIGRldGVjdCA9IG93bjtcbiAgICAgICAgaWYgKG93bikge1xuICAgICAgICAgICAgdmFsdWUgPSBub2RlMi5yYXdzW293bl07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcmVudCA9IG5vZGUyLnBhcmVudDtcbiAgICAgICAgaWYgKGRldGVjdCA9PT0gXCJiZWZvcmVcIikge1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50LnR5cGUgPT09IFwicm9vdFwiICYmIHBhcmVudC5maXJzdCA9PT0gbm9kZTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LnR5cGUgPT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50KSByZXR1cm4gREVGQVVMVF9SQVdbZGV0ZWN0XTtcbiAgICAgICAgdmFyIHJvb3QyID0gbm9kZTIucm9vdCgpO1xuICAgICAgICBpZiAoIXJvb3QyLnJhd0NhY2hlKSByb290Mi5yYXdDYWNoZSA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHJvb3QyLnJhd0NhY2hlW2RldGVjdF0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiByb290Mi5yYXdDYWNoZVtkZXRlY3RdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXRlY3QgPT09IFwiYmVmb3JlXCIgfHwgZGV0ZWN0ID09PSBcImFmdGVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJlZm9yZUFmdGVyKG5vZGUyLCBkZXRlY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IFwicmF3XCIgKyBjYXBpdGFsaXplKGRldGVjdCk7XG4gICAgICAgICAgICBpZiAodGhpc1ttZXRob2RdKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzW21ldGhvZF0ocm9vdDIsIG5vZGUyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcm9vdDIud2FsayhmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3Nbb3duXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHZhbHVlID0gREVGQVVMVF9SQVdbZGV0ZWN0XTtcbiAgICAgICAgcm9vdDIucmF3Q2FjaGVbZGV0ZWN0XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3QmVmb3JlQ2xvc2UgPSBmdW5jdGlvbiByYXdCZWZvcmVDbG9zZShyb290Mikge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHJvb3QyLndhbGsoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIGlmIChpMi5ub2RlcyAmJiBpMi5ub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpMi5yYXdzLmFmdGVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaTIucmF3cy5hZnRlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1teXFxuXSskLywgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh2YWx1ZSkgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFMvZywgXCJcIik7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5yYXdCZWZvcmVDb21tZW50ID0gZnVuY3Rpb24gcmF3QmVmb3JlQ29tbWVudChyb290Miwgbm9kZTIpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICByb290Mi53YWxrQ29tbWVudHMoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5iZWZvcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYmVmb3JlO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1teXFxuXSskLywgXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZTIsIG51bGwsIFwiYmVmb3JlRGVjbFwiKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFMvZywgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJhd0JlZm9yZURlY2wgPSBmdW5jdGlvbiByYXdCZWZvcmVEZWNsKHJvb3QyLCBub2RlMikge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHJvb3QyLndhbGtEZWNscyhmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpMi5yYXdzLmJlZm9yZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gaTIucmF3cy5iZWZvcmU7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW15cXG5dKyQvLCBcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJiZWZvcmVSdWxlXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcUy9nLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3QmVmb3JlT3BlbiA9IGZ1bmN0aW9uIHJhd0JlZm9yZU9wZW4ocm9vdDIpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICByb290Mi53YWxrKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICBpZiAoaTIudHlwZSAhPT0gXCJkZWNsXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYmV0d2VlbjtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3QmVmb3JlUnVsZSA9IGZ1bmN0aW9uIHJhd0JlZm9yZVJ1bGUocm9vdDIpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICByb290Mi53YWxrKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICBpZiAoaTIubm9kZXMgJiYgKGkyLnBhcmVudCAhPT0gcm9vdDIgfHwgcm9vdDIuZmlyc3QgIT09IGkyKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5iZWZvcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpMi5yYXdzLmJlZm9yZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1teXFxuXSskLywgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh2YWx1ZSkgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFMvZywgXCJcIik7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5yYXdDb2xvbiA9IGZ1bmN0aW9uIHJhd0NvbG9uKHJvb3QyKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgcm9vdDIud2Fsa0RlY2xzKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmV0d2VlbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gaTIucmF3cy5iZXR3ZWVuLnJlcGxhY2UoL1teXFxzOl0vZywgXCJcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJhd0VtcHR5Qm9keSA9IGZ1bmN0aW9uIHJhd0VtcHR5Qm9keShyb290Mikge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHJvb3QyLndhbGsoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIGlmIChpMi5ub2RlcyAmJiBpMi5ub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYWZ0ZXI7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJhd0luZGVudCA9IGZ1bmN0aW9uIHJhd0luZGVudChyb290Mikge1xuICAgICAgICBpZiAocm9vdDIucmF3cy5pbmRlbnQpIHJldHVybiByb290Mi5yYXdzLmluZGVudDtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICByb290Mi53YWxrKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICB2YXIgcCA9IGkyLnBhcmVudDtcbiAgICAgICAgICAgIGlmIChwICYmIHAgIT09IHJvb3QyICYmIHAucGFyZW50ICYmIHAucGFyZW50ID09PSByb290Mikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5iZWZvcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gaTIucmF3cy5iZWZvcmUuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxTL2csIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJhd1NlbWljb2xvbiA9IGZ1bmN0aW9uIHJhd1NlbWljb2xvbihyb290Mikge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHJvb3QyLndhbGsoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIGlmIChpMi5ub2RlcyAmJiBpMi5ub2Rlcy5sZW5ndGggJiYgaTIubGFzdC50eXBlID09PSBcImRlY2xcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gaTIucmF3cy5zZW1pY29sb247XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJhd1ZhbHVlID0gZnVuY3Rpb24gcmF3VmFsdWUobm9kZTIsIHByb3ApIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbm9kZTJbcHJvcF07XG4gICAgICAgIHZhciByYXcgPSBub2RlMi5yYXdzW3Byb3BdO1xuICAgICAgICBpZiAocmF3ICYmIHJhdy52YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiByYXcucmF3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5yb290ID0gZnVuY3Rpb24gcm9vdChub2RlMikge1xuICAgICAgICB0aGlzLmJvZHkobm9kZTIpO1xuICAgICAgICBpZiAobm9kZTIucmF3cy5hZnRlcikgdGhpcy5idWlsZGVyKG5vZGUyLnJhd3MuYWZ0ZXIpO1xuICAgIH07XG4gICAgX3Byb3RvLnJ1bGUgPSBmdW5jdGlvbiBydWxlKG5vZGUyKSB7XG4gICAgICAgIHRoaXMuYmxvY2sobm9kZTIsIHRoaXMucmF3VmFsdWUobm9kZTIsIFwic2VsZWN0b3JcIikpO1xuICAgICAgICBpZiAobm9kZTIucmF3cy5vd25TZW1pY29sb24pIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRlcihub2RlMi5yYXdzLm93blNlbWljb2xvbiwgbm9kZTIsIFwiZW5kXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uc3RyaW5naWZ5ID0gZnVuY3Rpb24gc3RyaW5naWZ5KG5vZGUyLCBzZW1pY29sb24pIHtcbiAgICAgICAgaWYgKCF0aGlzW25vZGUyLnR5cGVdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIEFTVCBub2RlIHR5cGUgXCIgKyBub2RlMi50eXBlICsgXCIuIE1heWJlIHlvdSBuZWVkIHRvIGNoYW5nZSBQb3N0Q1NTIHN0cmluZ2lmaWVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW25vZGUyLnR5cGVdKG5vZGUyLCBzZW1pY29sb24pO1xuICAgIH07XG4gICAgcmV0dXJuIFN0cmluZ2lmaWVyMjtcbn0oKTtcbnZhciBzdHJpbmdpZmllciA9IFN0cmluZ2lmaWVyJDI7XG5TdHJpbmdpZmllciQyLmRlZmF1bHQgPSBTdHJpbmdpZmllciQyO1xudmFyIFN0cmluZ2lmaWVyJDEgPSBzdHJpbmdpZmllcjtcbmZ1bmN0aW9uIHN0cmluZ2lmeSQ0KG5vZGUyLCBidWlsZGVyKSB7XG4gICAgdmFyIHN0ciA9IG5ldyBTdHJpbmdpZmllciQxKGJ1aWxkZXIpO1xuICAgIHN0ci5zdHJpbmdpZnkobm9kZTIpO1xufVxudmFyIHN0cmluZ2lmeV8xID0gc3RyaW5naWZ5JDQ7XG5zdHJpbmdpZnkkNC5kZWZhdWx0ID0gc3RyaW5naWZ5JDQ7XG52YXIgaXNDbGVhbiQyID0gc3ltYm9scy5pc0NsZWFuLCBteSQyID0gc3ltYm9scy5teTtcbnZhciBDc3NTeW50YXhFcnJvciQyID0gY3NzU3ludGF4RXJyb3I7XG52YXIgU3RyaW5naWZpZXIyMiA9IHN0cmluZ2lmaWVyO1xudmFyIHN0cmluZ2lmeSQzID0gc3RyaW5naWZ5XzE7XG5mdW5jdGlvbiBjbG9uZU5vZGUob2JqLCBwYXJlbnQpIHtcbiAgICB2YXIgY2xvbmVkID0gbmV3IG9iai5jb25zdHJ1Y3RvcigpO1xuICAgIGZvcih2YXIgaTIgaW4gb2JqKXtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpMikpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpMiA9PT0gXCJwcm94eUNhY2hlXCIpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmpbaTJdO1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZih2YWx1ZSk7XG4gICAgICAgIGlmIChpMiA9PT0gXCJwYXJlbnRcIiAmJiB0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50KSBjbG9uZWRbaTJdID0gcGFyZW50O1xuICAgICAgICB9IGVsc2UgaWYgKGkyID09PSBcInNvdXJjZVwiKSB7XG4gICAgICAgICAgICBjbG9uZWRbaTJdID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNsb25lZFtpMl0gPSB2YWx1ZS5tYXAoZnVuY3Rpb24oaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZU5vZGUoaiwgY2xvbmVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHZhbHVlID0gY2xvbmVOb2RlKHZhbHVlKTtcbiAgICAgICAgICAgIGNsb25lZFtpMl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xvbmVkO1xufVxudmFyIE5vZGUkNCA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gTm9kZTMoZGVmYXVsdHMpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRzID09PSB2b2lkIDApIGRlZmF1bHRzID0ge307XG4gICAgICAgIHRoaXMucmF3cyA9IHt9O1xuICAgICAgICB0aGlzW2lzQ2xlYW4kMl0gPSBmYWxzZTtcbiAgICAgICAgdGhpc1tteSQyXSA9IHRydWU7XG4gICAgICAgIGZvcih2YXIgbmFtZSBpbiBkZWZhdWx0cyl7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJub2Rlc1wiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKGRlZmF1bHRzW25hbWVdKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZTIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlMi5jbG9uZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZChub2RlMi5jbG9uZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kKG5vZGUyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1tuYW1lXSA9IGRlZmF1bHRzW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBOb2RlMy5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmFkZFRvRXJyb3IgPSBmdW5jdGlvbiBhZGRUb0Vycm9yKGVycm9yKSB7XG4gICAgICAgIGVycm9yLnBvc3Rjc3NOb2RlID0gdGhpcztcbiAgICAgICAgaWYgKGVycm9yLnN0YWNrICYmIHRoaXMuc291cmNlICYmIC9cXG5cXHN7NH1hdCAvLnRlc3QoZXJyb3Iuc3RhY2spKSB7XG4gICAgICAgICAgICB2YXIgczIgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgICAgIGVycm9yLnN0YWNrID0gZXJyb3Iuc3RhY2sucmVwbGFjZSgvXFxuXFxzezR9YXQgLywgXCIkJlwiICsgczIuaW5wdXQuZnJvbSArIFwiOlwiICsgczIuc3RhcnQubGluZSArIFwiOlwiICsgczIuc3RhcnQuY29sdW1uICsgXCIkJlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfTtcbiAgICBfcHJvdG8uYWZ0ZXIgPSBmdW5jdGlvbiBhZnRlcihhZGQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QWZ0ZXIodGhpcywgYWRkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8uYXNzaWduID0gZnVuY3Rpb24gYXNzaWduKG92ZXJyaWRlcykge1xuICAgICAgICBpZiAob3ZlcnJpZGVzID09PSB2b2lkIDApIG92ZXJyaWRlcyA9IHt9O1xuICAgICAgICBmb3IodmFyIG5hbWUgaW4gb3ZlcnJpZGVzKXtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSBvdmVycmlkZXNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8uYmVmb3JlID0gZnVuY3Rpb24gYmVmb3JlKGFkZCkge1xuICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUodGhpcywgYWRkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8uY2xlYW5SYXdzID0gZnVuY3Rpb24gY2xlYW5SYXdzKGtlZXBCZXR3ZWVuKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnJhd3MuYmVmb3JlO1xuICAgICAgICBkZWxldGUgdGhpcy5yYXdzLmFmdGVyO1xuICAgICAgICBpZiAoIWtlZXBCZXR3ZWVuKSBkZWxldGUgdGhpcy5yYXdzLmJldHdlZW47XG4gICAgfTtcbiAgICBfcHJvdG8uY2xvbmUgPSBmdW5jdGlvbiBjbG9uZShvdmVycmlkZXMpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlcyA9PT0gdm9pZCAwKSBvdmVycmlkZXMgPSB7fTtcbiAgICAgICAgdmFyIGNsb25lZCA9IGNsb25lTm9kZSh0aGlzKTtcbiAgICAgICAgZm9yKHZhciBuYW1lIGluIG92ZXJyaWRlcyl7XG4gICAgICAgICAgICBjbG9uZWRbbmFtZV0gPSBvdmVycmlkZXNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9O1xuICAgIF9wcm90by5jbG9uZUFmdGVyID0gZnVuY3Rpb24gY2xvbmVBZnRlcihvdmVycmlkZXMpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlcyA9PT0gdm9pZCAwKSBvdmVycmlkZXMgPSB7fTtcbiAgICAgICAgdmFyIGNsb25lZCA9IHRoaXMuY2xvbmUob3ZlcnJpZGVzKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QWZ0ZXIodGhpcywgY2xvbmVkKTtcbiAgICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9O1xuICAgIF9wcm90by5jbG9uZUJlZm9yZSA9IGZ1bmN0aW9uIGNsb25lQmVmb3JlKG92ZXJyaWRlcykge1xuICAgICAgICBpZiAob3ZlcnJpZGVzID09PSB2b2lkIDApIG92ZXJyaWRlcyA9IHt9O1xuICAgICAgICB2YXIgY2xvbmVkID0gdGhpcy5jbG9uZShvdmVycmlkZXMpO1xuICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUodGhpcywgY2xvbmVkKTtcbiAgICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9O1xuICAgIF9wcm90by5lcnJvciA9IGZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UsIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgb3B0cyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5zb3VyY2UpIHtcbiAgICAgICAgICAgIHZhciBfdGhpc19yYW5nZUJ5ID0gdGhpcy5yYW5nZUJ5KG9wdHMpLCBlbmQgPSBfdGhpc19yYW5nZUJ5LmVuZCwgc3RhcnQgPSBfdGhpc19yYW5nZUJ5LnN0YXJ0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmlucHV0LmVycm9yKG1lc3NhZ2UsIHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IHN0YXJ0LmNvbHVtbixcbiAgICAgICAgICAgICAgICBsaW5lOiBzdGFydC5saW5lXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBlbmQuY29sdW1uLFxuICAgICAgICAgICAgICAgIGxpbmU6IGVuZC5saW5lXG4gICAgICAgICAgICB9LCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENzc1N5bnRheEVycm9yJDIobWVzc2FnZSk7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0UHJveHlQcm9jZXNzb3IgPSBmdW5jdGlvbiBnZXRQcm94eVByb2Nlc3NvcigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KG5vZGUyLCBwcm9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgPT09IFwicHJveHlPZlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlMjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlMi5yb290KCkudG9Qcm94eSgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlMltwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobm9kZTIsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUyW3Byb3BdID09PSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgbm9kZTJbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0gXCJwcm9wXCIgfHwgcHJvcCA9PT0gXCJ2YWx1ZVwiIHx8IHByb3AgPT09IFwibmFtZVwiIHx8IHByb3AgPT09IFwicGFyYW1zXCIgfHwgcHJvcCA9PT0gXCJpbXBvcnRhbnRcIiB8fCAvKiBjOCBpZ25vcmUgbmV4dCAqLyBwcm9wID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgICAgICAgICBub2RlMi5tYXJrRGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8ubWFya0RpcnR5ID0gZnVuY3Rpb24gbWFya0RpcnR5KCkge1xuICAgICAgICBpZiAodGhpc1tpc0NsZWFuJDJdKSB7XG4gICAgICAgICAgICB0aGlzW2lzQ2xlYW4kMl0gPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpcztcbiAgICAgICAgICAgIHdoaWxlKG5leHQgPSBuZXh0LnBhcmVudCl7XG4gICAgICAgICAgICAgICAgbmV4dFtpc0NsZWFuJDJdID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5uZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgdmFyIGluZGV4MiA9IHRoaXMucGFyZW50LmluZGV4KHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQubm9kZXNbaW5kZXgyICsgMV07XG4gICAgfTtcbiAgICBfcHJvdG8ucG9zaXRpb25CeSA9IGZ1bmN0aW9uIHBvc2l0aW9uQnkob3B0cywgc3RyaW5nUmVwcmVzZW50YXRpb24pIHtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuc291cmNlLnN0YXJ0O1xuICAgICAgICBpZiAob3B0cy5pbmRleCkge1xuICAgICAgICAgICAgcG9zID0gdGhpcy5wb3NpdGlvbkluc2lkZShvcHRzLmluZGV4LCBzdHJpbmdSZXByZXNlbnRhdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0cy53b3JkKSB7XG4gICAgICAgICAgICBzdHJpbmdSZXByZXNlbnRhdGlvbiA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHZhciBpbmRleDIgPSBzdHJpbmdSZXByZXNlbnRhdGlvbi5pbmRleE9mKG9wdHMud29yZCk7XG4gICAgICAgICAgICBpZiAoaW5kZXgyICE9PSAtMSkgcG9zID0gdGhpcy5wb3NpdGlvbkluc2lkZShpbmRleDIsIHN0cmluZ1JlcHJlc2VudGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH07XG4gICAgX3Byb3RvLnBvc2l0aW9uSW5zaWRlID0gZnVuY3Rpb24gcG9zaXRpb25JbnNpZGUoaW5kZXgyLCBzdHJpbmdSZXByZXNlbnRhdGlvbikge1xuICAgICAgICB2YXIgc3RyaW5nID0gc3RyaW5nUmVwcmVzZW50YXRpb24gfHwgdGhpcy50b1N0cmluZygpO1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5zb3VyY2Uuc3RhcnQuY29sdW1uO1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMuc291cmNlLnN0YXJ0LmxpbmU7XG4gICAgICAgIGZvcih2YXIgaTIgPSAwOyBpMiA8IGluZGV4MjsgaTIrKyl7XG4gICAgICAgICAgICBpZiAoc3RyaW5nW2kyXSA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IDE7XG4gICAgICAgICAgICAgICAgbGluZSArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4gKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICBsaW5lOiBsaW5lXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8ucHJldiA9IGZ1bmN0aW9uIHByZXYoKSB7XG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHJldHVybiB2b2lkIDA7XG4gICAgICAgIHZhciBpbmRleDIgPSB0aGlzLnBhcmVudC5pbmRleCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm5vZGVzW2luZGV4MiAtIDFdO1xuICAgIH07XG4gICAgX3Byb3RvLnJhbmdlQnkgPSBmdW5jdGlvbiByYW5nZUJ5KG9wdHMpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0ge1xuICAgICAgICAgICAgY29sdW1uOiB0aGlzLnNvdXJjZS5zdGFydC5jb2x1bW4sXG4gICAgICAgICAgICBsaW5lOiB0aGlzLnNvdXJjZS5zdGFydC5saW5lXG4gICAgICAgIH07XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnNvdXJjZS5lbmQgPyB7XG4gICAgICAgICAgICBjb2x1bW46IHRoaXMuc291cmNlLmVuZC5jb2x1bW4gKyAxLFxuICAgICAgICAgICAgbGluZTogdGhpcy5zb3VyY2UuZW5kLmxpbmVcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICAgIGNvbHVtbjogc3RhcnQuY29sdW1uICsgMSxcbiAgICAgICAgICAgIGxpbmU6IHN0YXJ0LmxpbmVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdHMud29yZCkge1xuICAgICAgICAgICAgdmFyIHN0cmluZ1JlcHJlc2VudGF0aW9uID0gdGhpcy50b1N0cmluZygpO1xuICAgICAgICAgICAgdmFyIGluZGV4MiA9IHN0cmluZ1JlcHJlc2VudGF0aW9uLmluZGV4T2Yob3B0cy53b3JkKTtcbiAgICAgICAgICAgIGlmIChpbmRleDIgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKGluZGV4Miwgc3RyaW5nUmVwcmVzZW50YXRpb24pO1xuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMucG9zaXRpb25JbnNpZGUoaW5kZXgyICsgb3B0cy53b3JkLmxlbmd0aCwgc3RyaW5nUmVwcmVzZW50YXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9wdHMuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBvcHRzLnN0YXJ0LmNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgbGluZTogb3B0cy5zdGFydC5saW5lXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0cy5pbmRleCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5wb3NpdGlvbkluc2lkZShvcHRzLmluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLmVuZCkge1xuICAgICAgICAgICAgICAgIGVuZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBvcHRzLmVuZC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IG9wdHMuZW5kLmxpbmVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cy5lbmRJbmRleCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMucG9zaXRpb25JbnNpZGUob3B0cy5lbmRJbmRleCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdHMuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKG9wdHMuaW5kZXggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kLmxpbmUgPCBzdGFydC5saW5lIHx8IGVuZC5saW5lID09PSBzdGFydC5saW5lICYmIGVuZC5jb2x1bW4gPD0gc3RhcnQuY29sdW1uKSB7XG4gICAgICAgICAgICBlbmQgPSB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBzdGFydC5jb2x1bW4gKyAxLFxuICAgICAgICAgICAgICAgIGxpbmU6IHN0YXJ0LmxpbmVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3ID0gZnVuY3Rpb24gcmF3KHByb3AsIGRlZmF1bHRUeXBlKSB7XG4gICAgICAgIHZhciBzdHIgPSBuZXcgU3RyaW5naWZpZXIyMigpO1xuICAgICAgICByZXR1cm4gc3RyLnJhdyh0aGlzLCBwcm9wLCBkZWZhdWx0VHlwZSk7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyZW50ID0gdm9pZCAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90by5yZXBsYWNlV2l0aCA9IGZ1bmN0aW9uIHJlcGxhY2VXaXRoKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBub2RlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgbm9kZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgYm9va21hcmsgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGZvdW5kU2VsZiA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uobm9kZXMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUyID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kU2VsZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmb3VuZFNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QWZ0ZXIoYm9va21hcmssIG5vZGUyKTtcbiAgICAgICAgICAgICAgICAgICAgYm9va21hcmsgPSBub2RlMjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUoYm9va21hcmssIG5vZGUyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWZvdW5kU2VsZikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8ucm9vdCA9IGZ1bmN0aW9uIHJvb3QoKSB7XG4gICAgICAgIHZhciByZXN1bHQyID0gdGhpcztcbiAgICAgICAgd2hpbGUocmVzdWx0Mi5wYXJlbnQgJiYgcmVzdWx0Mi5wYXJlbnQudHlwZSAhPT0gXCJkb2N1bWVudFwiKXtcbiAgICAgICAgICAgIHJlc3VsdDIgPSByZXN1bHQyLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICB9O1xuICAgIF9wcm90by50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oXywgaW5wdXRzKSB7XG4gICAgICAgIHZhciBmaXhlZCA9IHt9O1xuICAgICAgICB2YXIgZW1pdElucHV0cyA9IGlucHV0cyA9PSBudWxsO1xuICAgICAgICBpbnB1dHMgPSBpbnB1dHMgfHwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIGlucHV0c05leHRJbmRleCA9IDA7XG4gICAgICAgIGZvcih2YXIgbmFtZSBpbiB0aGlzKXtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJwYXJlbnRcIiB8fCBuYW1lID09PSBcInByb3h5Q2FjaGVcIikgY29udGludWU7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzW25hbWVdO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZml4ZWRbbmFtZV0gPSB2YWx1ZS5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0eXBlb2YgaTIgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YoaTIpKSA9PT0gXCJvYmplY3RcIiAmJiBpMi50b0pTT04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpMi50b0pTT04obnVsbCwgaW5wdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKHZhbHVlKSkgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUudG9KU09OKSB7XG4gICAgICAgICAgICAgICAgZml4ZWRbbmFtZV0gPSB2YWx1ZS50b0pTT04obnVsbCwgaW5wdXRzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJzb3VyY2VcIikge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dElkID0gaW5wdXRzLmdldCh2YWx1ZS5pbnB1dCk7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0SWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dElkID0gaW5wdXRzTmV4dEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBpbnB1dHMuc2V0KHZhbHVlLmlucHV0LCBpbnB1dHNOZXh0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dHNOZXh0SW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZml4ZWRbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZDogdmFsdWUuZW5kLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dElkOiBpbnB1dElkLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogdmFsdWUuc3RhcnRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaXhlZFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbWl0SW5wdXRzKSB7XG4gICAgICAgICAgICBmaXhlZC5pbnB1dHMgPSBbXS5jb25jYXQoaW5wdXRzLmtleXMoKSkubWFwKGZ1bmN0aW9uKGlucHV0Mikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dDIudG9KU09OKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZml4ZWQ7XG4gICAgfTtcbiAgICBfcHJvdG8udG9Qcm94eSA9IGZ1bmN0aW9uIHRvUHJveHkoKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm94eUNhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLnByb3h5Q2FjaGUgPSBuZXcgUHJveHkodGhpcywgdGhpcy5nZXRQcm94eVByb2Nlc3NvcigpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm94eUNhY2hlO1xuICAgIH07XG4gICAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoc3RyaW5naWZpZXIyKSB7XG4gICAgICAgIGlmIChzdHJpbmdpZmllcjIgPT09IHZvaWQgMCkgc3RyaW5naWZpZXIyID0gc3RyaW5naWZ5JDM7XG4gICAgICAgIGlmIChzdHJpbmdpZmllcjIuc3RyaW5naWZ5KSBzdHJpbmdpZmllcjIgPSBzdHJpbmdpZmllcjIuc3RyaW5naWZ5O1xuICAgICAgICB2YXIgcmVzdWx0MiA9IFwiXCI7XG4gICAgICAgIHN0cmluZ2lmaWVyMih0aGlzLCBmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgcmVzdWx0MiArPSBpMjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgIH07XG4gICAgX3Byb3RvLndhcm4gPSBmdW5jdGlvbiB3YXJuKHJlc3VsdDIsIHRleHQsIG9wdHMpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICBub2RlOiB0aGlzXG4gICAgICAgIH07XG4gICAgICAgIGZvcih2YXIgaTIgaW4gb3B0cylkYXRhW2kyXSA9IG9wdHNbaTJdO1xuICAgICAgICByZXR1cm4gcmVzdWx0Mi53YXJuKHRleHQsIGRhdGEpO1xuICAgIH07XG4gICAgX2NyZWF0ZV9jbGFzcyhOb2RlMywgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwicHJveHlPZlwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gTm9kZTM7XG59KCk7XG52YXIgbm9kZSA9IE5vZGUkNDtcbk5vZGUkNC5kZWZhdWx0ID0gTm9kZSQ0O1xudmFyIE5vZGUkMyA9IG5vZGU7XG52YXIgRGVjbGFyYXRpb24kNCA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oTm9kZSQzKSB7XG4gICAgX2luaGVyaXRzKERlY2xhcmF0aW9uMiwgTm9kZSQzKTtcbiAgICBmdW5jdGlvbiBEZWNsYXJhdGlvbjIoZGVmYXVsdHMpIHtcbiAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICBpZiAoZGVmYXVsdHMgJiYgdHlwZW9mIGRlZmF1bHRzLnZhbHVlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBkZWZhdWx0cy52YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZGVmYXVsdHMgPSBfZXh0ZW5kcyh7fSwgZGVmYXVsdHMsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogU3RyaW5nKGRlZmF1bHRzLnZhbHVlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMgPSBOb2RlJDMuY2FsbCh0aGlzLCBkZWZhdWx0cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9IFwiZGVjbFwiO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIF9jcmVhdGVfY2xhc3MoRGVjbGFyYXRpb24yLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJ2YXJpYWJsZVwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcC5zdGFydHNXaXRoKFwiLS1cIikgfHwgdGhpcy5wcm9wWzBdID09PSBcIiRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBEZWNsYXJhdGlvbjI7XG59KE5vZGUkMyk7XG52YXIgZGVjbGFyYXRpb24gPSBEZWNsYXJhdGlvbiQ0O1xuRGVjbGFyYXRpb24kNC5kZWZhdWx0ID0gRGVjbGFyYXRpb24kNDtcbnZhciB1cmxBbHBoYWJldCA9IFwidXNlYW5kb20tMjZUMTk4MzQwUFg3NXB4SkFDS1ZFUllNSU5EQlVTSFdPTEZfR1FaYmZnaGprbHF2d3l6cmljdFwiO1xudmFyIG5hbm9pZCQxID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIGlmIChzaXplID09PSB2b2lkIDApIHNpemUgPSAyMTtcbiAgICB2YXIgaWQgPSBcIlwiO1xuICAgIHZhciBpMiA9IHNpemU7XG4gICAgd2hpbGUoaTItLSl7XG4gICAgICAgIGlkICs9IHVybEFscGhhYmV0W01hdGgucmFuZG9tKCkgKiA2NCB8IDBdO1xuICAgIH1cbiAgICByZXR1cm4gaWQ7XG59O1xudmFyIG5vblNlY3VyZSA9IHtcbiAgICBuYW5vaWQ6IG5hbm9pZCQxXG59O1xudmFyIFNvdXJjZU1hcENvbnN1bWVyJDIgPSByZXF1aXJlJCQyLlNvdXJjZU1hcENvbnN1bWVyLCBTb3VyY2VNYXBHZW5lcmF0b3IkMiA9IHJlcXVpcmUkJDIuU291cmNlTWFwR2VuZXJhdG9yO1xudmFyIGV4aXN0c1N5bmMgPSByZXF1aXJlJCQyLmV4aXN0c1N5bmMsIHJlYWRGaWxlU3luYyA9IHJlcXVpcmUkJDIucmVhZEZpbGVTeW5jO1xudmFyIGRpcm5hbWUkMSA9IHJlcXVpcmUkJDIuZGlybmFtZSwgam9pbiA9IHJlcXVpcmUkJDIuam9pbjtcbmZ1bmN0aW9uIGZyb21CYXNlNjQoc3RyKSB7XG4gICAgaWYgKEJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oc3RyLCBcImJhc2U2NFwiKS50b1N0cmluZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuYXRvYihzdHIpO1xuICAgIH1cbn1cbnZhciBQcmV2aW91c01hcCQyID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBQcmV2aW91c01hcDIoY3NzLCBvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzLm1hcCA9PT0gZmFsc2UpIHJldHVybjtcbiAgICAgICAgdGhpcy5sb2FkQW5ub3RhdGlvbihjc3MpO1xuICAgICAgICB0aGlzLmlubGluZSA9IHRoaXMuc3RhcnRXaXRoKHRoaXMuYW5ub3RhdGlvbiwgXCJkYXRhOlwiKTtcbiAgICAgICAgdmFyIHByZXYgPSBvcHRzLm1hcCA/IG9wdHMubWFwLnByZXYgOiB2b2lkIDA7XG4gICAgICAgIHZhciB0ZXh0ID0gdGhpcy5sb2FkTWFwKG9wdHMuZnJvbSwgcHJldik7XG4gICAgICAgIGlmICghdGhpcy5tYXBGaWxlICYmIG9wdHMuZnJvbSkge1xuICAgICAgICAgICAgdGhpcy5tYXBGaWxlID0gb3B0cy5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hcEZpbGUpIHRoaXMucm9vdCA9IGRpcm5hbWUkMSh0aGlzLm1hcEZpbGUpO1xuICAgICAgICBpZiAodGV4dCkgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFByZXZpb3VzTWFwMi5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmNvbnN1bWVyID0gZnVuY3Rpb24gY29uc3VtZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25zdW1lckNhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVyQ2FjaGUgPSBuZXcgU291cmNlTWFwQ29uc3VtZXIkMih0aGlzLnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVyQ2FjaGU7XG4gICAgfTtcbiAgICBfcHJvdG8uZGVjb2RlSW5saW5lID0gZnVuY3Rpb24gZGVjb2RlSW5saW5lKHRleHQpIHtcbiAgICAgICAgdmFyIGJhc2VDaGFyc2V0VXJpID0gL15kYXRhOmFwcGxpY2F0aW9uXFwvanNvbjtjaGFyc2V0PXV0Zi0/ODtiYXNlNjQsLztcbiAgICAgICAgdmFyIGJhc2VVcmkgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uO2Jhc2U2NCwvO1xuICAgICAgICB2YXIgY2hhcnNldFVyaSA9IC9eZGF0YTphcHBsaWNhdGlvblxcL2pzb247Y2hhcnNldD11dGYtPzgsLztcbiAgICAgICAgdmFyIHVyaSA9IC9eZGF0YTphcHBsaWNhdGlvblxcL2pzb24sLztcbiAgICAgICAgaWYgKGNoYXJzZXRVcmkudGVzdCh0ZXh0KSB8fCB1cmkudGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudCh0ZXh0LnN1YnN0cihSZWdFeHAubGFzdE1hdGNoLmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlQ2hhcnNldFVyaS50ZXN0KHRleHQpIHx8IGJhc2VVcmkudGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21CYXNlNjQodGV4dC5zdWJzdHIoUmVnRXhwLmxhc3RNYXRjaC5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW5jb2RpbmcgPSB0ZXh0Lm1hdGNoKC9kYXRhOmFwcGxpY2F0aW9uXFwvanNvbjsoW14sXSspLC8pWzFdO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBzb3VyY2UgbWFwIGVuY29kaW5nIFwiICsgZW5jb2RpbmcpO1xuICAgIH07XG4gICAgX3Byb3RvLmdldEFubm90YXRpb25VUkwgPSBmdW5jdGlvbiBnZXRBbm5vdGF0aW9uVVJMKHNvdXJjZU1hcFN0cmluZykge1xuICAgICAgICByZXR1cm4gc291cmNlTWFwU3RyaW5nLnJlcGxhY2UoL15cXC9cXCpcXHMqIyBzb3VyY2VNYXBwaW5nVVJMPS8sIFwiXCIpLnRyaW0oKTtcbiAgICB9O1xuICAgIF9wcm90by5pc01hcCA9IGZ1bmN0aW9uIGlzTWFwKG1hcCkge1xuICAgICAgICBpZiAoKHR5cGVvZiBtYXAgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YobWFwKSkgIT09IFwib2JqZWN0XCIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBtYXAubWFwcGluZ3MgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG1hcC5fbWFwcGluZ3MgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheShtYXAuc2VjdGlvbnMpO1xuICAgIH07XG4gICAgX3Byb3RvLmxvYWRBbm5vdGF0aW9uID0gZnVuY3Rpb24gbG9hZEFubm90YXRpb24oY3NzKSB7XG4gICAgICAgIHZhciBjb21tZW50cyA9IGNzcy5tYXRjaCgvXFwvXFwqXFxzKiMgc291cmNlTWFwcGluZ1VSTD0vZ20pO1xuICAgICAgICBpZiAoIWNvbW1lbnRzKSByZXR1cm47XG4gICAgICAgIHZhciBzdGFydCA9IGNzcy5sYXN0SW5kZXhPZihjb21tZW50cy5wb3AoKSk7XG4gICAgICAgIHZhciBlbmQgPSBjc3MuaW5kZXhPZihcIiovXCIsIHN0YXJ0KTtcbiAgICAgICAgaWYgKHN0YXJ0ID4gLTEgJiYgZW5kID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuYW5ub3RhdGlvbiA9IHRoaXMuZ2V0QW5ub3RhdGlvblVSTChjc3Muc3Vic3RyaW5nKHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmxvYWRGaWxlID0gZnVuY3Rpb24gbG9hZEZpbGUocGF0aCkge1xuICAgICAgICB0aGlzLnJvb3QgPSBkaXJuYW1lJDEocGF0aCk7XG4gICAgICAgIGlmIChleGlzdHNTeW5jKHBhdGgpKSB7XG4gICAgICAgICAgICB0aGlzLm1hcEZpbGUgPSBwYXRoO1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRGaWxlU3luYyhwYXRoLCBcInV0Zi04XCIpLnRvU3RyaW5nKCkudHJpbSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ubG9hZE1hcCA9IGZ1bmN0aW9uIGxvYWRNYXAoZmlsZSwgcHJldikge1xuICAgICAgICBpZiAocHJldiA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJldiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcHJldiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZQYXRoID0gcHJldihmaWxlKTtcbiAgICAgICAgICAgICAgICBpZiAocHJldlBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hcCA9IHRoaXMubG9hZEZpbGUocHJldlBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGxvYWQgcHJldmlvdXMgc291cmNlIG1hcDogXCIgKyBwcmV2UGF0aC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX2luc3RhbmNlb2YocHJldiwgU291cmNlTWFwQ29uc3VtZXIkMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU291cmNlTWFwR2VuZXJhdG9yJDIuZnJvbVNvdXJjZU1hcChwcmV2KS50b1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZihwcmV2LCBTb3VyY2VNYXBHZW5lcmF0b3IkMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldi50b1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzTWFwKHByZXYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHByZXYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBwcmV2aW91cyBzb3VyY2UgbWFwIGZvcm1hdDogXCIgKyBwcmV2LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaW5saW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVJbmxpbmUodGhpcy5hbm5vdGF0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmFubm90YXRpb24pIHtcbiAgICAgICAgICAgIHZhciBtYXAxID0gdGhpcy5hbm5vdGF0aW9uO1xuICAgICAgICAgICAgaWYgKGZpbGUpIG1hcDEgPSBqb2luKGRpcm5hbWUkMShmaWxlKSwgbWFwMSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkRmlsZShtYXAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnN0YXJ0V2l0aCA9IGZ1bmN0aW9uIHN0YXJ0V2l0aChzdHJpbmcsIHN0YXJ0KSB7XG4gICAgICAgIGlmICghc3RyaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBzdHJpbmcuc3Vic3RyKDAsIHN0YXJ0Lmxlbmd0aCkgPT09IHN0YXJ0O1xuICAgIH07XG4gICAgX3Byb3RvLndpdGhDb250ZW50ID0gZnVuY3Rpb24gd2l0aENvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLmNvbnN1bWVyKCkuc291cmNlc0NvbnRlbnQgJiYgdGhpcy5jb25zdW1lcigpLnNvdXJjZXNDb250ZW50Lmxlbmd0aCA+IDApO1xuICAgIH07XG4gICAgcmV0dXJuIFByZXZpb3VzTWFwMjtcbn0oKTtcbnZhciBwcmV2aW91c01hcCA9IFByZXZpb3VzTWFwJDI7XG5QcmV2aW91c01hcCQyLmRlZmF1bHQgPSBQcmV2aW91c01hcCQyO1xudmFyIFNvdXJjZU1hcENvbnN1bWVyJDEgPSByZXF1aXJlJCQyLlNvdXJjZU1hcENvbnN1bWVyLCBTb3VyY2VNYXBHZW5lcmF0b3IkMSA9IHJlcXVpcmUkJDIuU291cmNlTWFwR2VuZXJhdG9yO1xudmFyIGZpbGVVUkxUb1BhdGggPSByZXF1aXJlJCQyLmZpbGVVUkxUb1BhdGgsIHBhdGhUb0ZpbGVVUkwkMSA9IHJlcXVpcmUkJDIucGF0aFRvRmlsZVVSTDtcbnZhciBpc0Fic29sdXRlID0gcmVxdWlyZSQkMi5pc0Fic29sdXRlLCByZXNvbHZlJDEgPSByZXF1aXJlJCQyLnJlc29sdmU7XG52YXIgbmFub2lkID0gbm9uU2VjdXJlLm5hbm9pZDtcbnZhciB0ZXJtaW5hbEhpZ2hsaWdodCA9IHJlcXVpcmUkJDI7XG52YXIgQ3NzU3ludGF4RXJyb3IkMSA9IGNzc1N5bnRheEVycm9yO1xudmFyIFByZXZpb3VzTWFwJDEgPSBwcmV2aW91c01hcDtcbnZhciBmcm9tT2Zmc2V0Q2FjaGUgPSBTeW1ib2woXCJmcm9tT2Zmc2V0Q2FjaGVcIik7XG52YXIgc291cmNlTWFwQXZhaWxhYmxlJDEgPSBCb29sZWFuKFNvdXJjZU1hcENvbnN1bWVyJDEgJiYgU291cmNlTWFwR2VuZXJhdG9yJDEpO1xudmFyIHBhdGhBdmFpbGFibGUkMSA9IEJvb2xlYW4ocmVzb2x2ZSQxICYmIGlzQWJzb2x1dGUpO1xudmFyIElucHV0JDQgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIElucHV0Mihjc3MsIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgb3B0cyA9IHt9O1xuICAgICAgICBpZiAoY3NzID09PSBudWxsIHx8IHR5cGVvZiBjc3MgPT09IFwidW5kZWZpbmVkXCIgfHwgKHR5cGVvZiBjc3MgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YoY3NzKSkgPT09IFwib2JqZWN0XCIgJiYgIWNzcy50b1N0cmluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9zdENTUyByZWNlaXZlZCBcIiArIGNzcyArIFwiIGluc3RlYWQgb2YgQ1NTIHN0cmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNzcyA9IGNzcy50b1N0cmluZygpO1xuICAgICAgICBpZiAodGhpcy5jc3NbMF0gPT09IFwiXFx1RkVGRlwiIHx8IHRoaXMuY3NzWzBdID09PSBcIu+/vlwiKSB7XG4gICAgICAgICAgICB0aGlzLmhhc0JPTSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNzcyA9IHRoaXMuY3NzLnNsaWNlKDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYXNCT00gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5mcm9tKSB7XG4gICAgICAgICAgICBpZiAoIXBhdGhBdmFpbGFibGUkMSB8fCAvXlxcdys6XFwvXFwvLy50ZXN0KG9wdHMuZnJvbSkgfHwgaXNBYnNvbHV0ZShvcHRzLmZyb20pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlID0gb3B0cy5mcm9tO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGUgPSByZXNvbHZlJDEob3B0cy5mcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aEF2YWlsYWJsZSQxICYmIHNvdXJjZU1hcEF2YWlsYWJsZSQxKSB7XG4gICAgICAgICAgICB2YXIgbWFwID0gbmV3IFByZXZpb3VzTWFwJDEodGhpcy5jc3MsIG9wdHMpO1xuICAgICAgICAgICAgaWYgKG1hcC50ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGUgPSBtYXAuY29uc3VtZXIoKS5maWxlO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5maWxlICYmIGZpbGUpIHRoaXMuZmlsZSA9IHRoaXMubWFwUmVzb2x2ZShmaWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZmlsZSkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IFwiPGlucHV0IGNzcyBcIiArIG5hbm9pZCg2KSArIFwiPlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hcCkgdGhpcy5tYXAuZmlsZSA9IHRoaXMuZnJvbTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IElucHV0Mi5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmVycm9yID0gZnVuY3Rpb24gZXJyb3IobWVzc2FnZSwgbGluZSwgY29sdW1uLCBvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzID09PSB2b2lkIDApIG9wdHMgPSB7fTtcbiAgICAgICAgdmFyIHJlc3VsdDIsIGVuZExpbmUsIGVuZENvbHVtbjtcbiAgICAgICAgaWYgKGxpbmUgJiYgKHR5cGVvZiBsaW5lID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKGxpbmUpKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gbGluZTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBjb2x1bW47XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0YXJ0Lm9mZnNldCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLmZyb21PZmZzZXQoc3RhcnQub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBsaW5lID0gcG9zLmxpbmU7XG4gICAgICAgICAgICAgICAgY29sdW1uID0gcG9zLmNvbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IHN0YXJ0LmxpbmU7XG4gICAgICAgICAgICAgICAgY29sdW1uID0gc3RhcnQuY29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmQub2Zmc2V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvczEgPSB0aGlzLmZyb21PZmZzZXQoZW5kLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgZW5kTGluZSA9IHBvczEubGluZTtcbiAgICAgICAgICAgICAgICBlbmRDb2x1bW4gPSBwb3MxLmNvbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kTGluZSA9IGVuZC5saW5lO1xuICAgICAgICAgICAgICAgIGVuZENvbHVtbiA9IGVuZC5jb2x1bW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWNvbHVtbikge1xuICAgICAgICAgICAgdmFyIHBvczIgPSB0aGlzLmZyb21PZmZzZXQobGluZSk7XG4gICAgICAgICAgICBsaW5lID0gcG9zMi5saW5lO1xuICAgICAgICAgICAgY29sdW1uID0gcG9zMi5jb2w7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9yaWdpbiA9IHRoaXMub3JpZ2luKGxpbmUsIGNvbHVtbiwgZW5kTGluZSwgZW5kQ29sdW1uKTtcbiAgICAgICAgaWYgKG9yaWdpbikge1xuICAgICAgICAgICAgcmVzdWx0MiA9IG5ldyBDc3NTeW50YXhFcnJvciQxKG1lc3NhZ2UsIG9yaWdpbi5lbmRMaW5lID09PSB2b2lkIDAgPyBvcmlnaW4ubGluZSA6IHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IG9yaWdpbi5jb2x1bW4sXG4gICAgICAgICAgICAgICAgbGluZTogb3JpZ2luLmxpbmVcbiAgICAgICAgICAgIH0sIG9yaWdpbi5lbmRMaW5lID09PSB2b2lkIDAgPyBvcmlnaW4uY29sdW1uIDoge1xuICAgICAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luLmVuZENvbHVtbixcbiAgICAgICAgICAgICAgICBsaW5lOiBvcmlnaW4uZW5kTGluZVxuICAgICAgICAgICAgfSwgb3JpZ2luLnNvdXJjZSwgb3JpZ2luLmZpbGUsIG9wdHMucGx1Z2luKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBuZXcgQ3NzU3ludGF4RXJyb3IkMShtZXNzYWdlLCBlbmRMaW5lID09PSB2b2lkIDAgPyBsaW5lIDoge1xuICAgICAgICAgICAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVcbiAgICAgICAgICAgIH0sIGVuZExpbmUgPT09IHZvaWQgMCA/IGNvbHVtbiA6IHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IGVuZENvbHVtbixcbiAgICAgICAgICAgICAgICBsaW5lOiBlbmRMaW5lXG4gICAgICAgICAgICB9LCB0aGlzLmNzcywgdGhpcy5maWxlLCBvcHRzLnBsdWdpbik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Mi5pbnB1dCA9IHtcbiAgICAgICAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgICAgICAgZW5kQ29sdW1uOiBlbmRDb2x1bW4sXG4gICAgICAgICAgICBlbmRMaW5lOiBlbmRMaW5lLFxuICAgICAgICAgICAgbGluZTogbGluZSxcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcy5jc3NcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuZmlsZSkge1xuICAgICAgICAgICAgaWYgKHBhdGhUb0ZpbGVVUkwkMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIuaW5wdXQudXJsID0gcGF0aFRvRmlsZVVSTCQxKHRoaXMuZmlsZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdDIuaW5wdXQuZmlsZSA9IHRoaXMuZmlsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICB9O1xuICAgIF9wcm90by5mcm9tT2Zmc2V0ID0gZnVuY3Rpb24gZnJvbU9mZnNldChvZmZzZXQpIHtcbiAgICAgICAgdmFyIGxhc3RMaW5lLCBsaW5lVG9JbmRleDtcbiAgICAgICAgaWYgKCF0aGlzW2Zyb21PZmZzZXRDYWNoZV0pIHtcbiAgICAgICAgICAgIHZhciBsaW5lcyA9IHRoaXMuY3NzLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgICAgbGluZVRvSW5kZXggPSBuZXcgQXJyYXkobGluZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBwcmV2SW5kZXggPSAwO1xuICAgICAgICAgICAgZm9yKHZhciBpMiA9IDAsIGwyID0gbGluZXMubGVuZ3RoOyBpMiA8IGwyOyBpMisrKXtcbiAgICAgICAgICAgICAgICBsaW5lVG9JbmRleFtpMl0gPSBwcmV2SW5kZXg7XG4gICAgICAgICAgICAgICAgcHJldkluZGV4ICs9IGxpbmVzW2kyXS5sZW5ndGggKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc1tmcm9tT2Zmc2V0Q2FjaGVdID0gbGluZVRvSW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaW5lVG9JbmRleCA9IHRoaXNbZnJvbU9mZnNldENhY2hlXTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0TGluZSA9IGxpbmVUb0luZGV4W2xpbmVUb0luZGV4Lmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgbWluID0gMDtcbiAgICAgICAgaWYgKG9mZnNldCA+PSBsYXN0TGluZSkge1xuICAgICAgICAgICAgbWluID0gbGluZVRvSW5kZXgubGVuZ3RoIC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtYXggPSBsaW5lVG9JbmRleC5sZW5ndGggLSAyO1xuICAgICAgICAgICAgdmFyIG1pZDtcbiAgICAgICAgICAgIHdoaWxlKG1pbiA8IG1heCl7XG4gICAgICAgICAgICAgICAgbWlkID0gbWluICsgKG1heCAtIG1pbiA+PiAxKTtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDwgbGluZVRvSW5kZXhbbWlkXSkge1xuICAgICAgICAgICAgICAgICAgICBtYXggPSBtaWQgLSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob2Zmc2V0ID49IGxpbmVUb0luZGV4W21pZCArIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IG1pZCArIDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gbWlkO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbDogb2Zmc2V0IC0gbGluZVRvSW5kZXhbbWluXSArIDEsXG4gICAgICAgICAgICBsaW5lOiBtaW4gKyAxXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8ubWFwUmVzb2x2ZSA9IGZ1bmN0aW9uIG1hcFJlc29sdmUoZmlsZSkge1xuICAgICAgICBpZiAoL15cXHcrOlxcL1xcLy8udGVzdChmaWxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUkMSh0aGlzLm1hcC5jb25zdW1lcigpLnNvdXJjZVJvb3QgfHwgdGhpcy5tYXAucm9vdCB8fCBcIi5cIiwgZmlsZSk7XG4gICAgfTtcbiAgICBfcHJvdG8ub3JpZ2luID0gZnVuY3Rpb24gb3JpZ2luKGxpbmUsIGNvbHVtbiwgZW5kTGluZSwgZW5kQ29sdW1uKSB7XG4gICAgICAgIGlmICghdGhpcy5tYXApIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGNvbnN1bWVyID0gdGhpcy5tYXAuY29uc3VtZXIoKTtcbiAgICAgICAgdmFyIGZyb20gPSBjb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgICAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgICAgICAgbGluZTogbGluZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFmcm9tLnNvdXJjZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgdG87XG4gICAgICAgIGlmICh0eXBlb2YgZW5kTGluZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdG8gPSBjb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IGVuZENvbHVtbixcbiAgICAgICAgICAgICAgICBsaW5lOiBlbmRMaW5lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnJvbVVybDtcbiAgICAgICAgaWYgKGlzQWJzb2x1dGUoZnJvbS5zb3VyY2UpKSB7XG4gICAgICAgICAgICBmcm9tVXJsID0gcGF0aFRvRmlsZVVSTCQxKGZyb20uc291cmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyb21VcmwgPSBuZXcgVVJMKGZyb20uc291cmNlLCB0aGlzLm1hcC5jb25zdW1lcigpLnNvdXJjZVJvb3QgfHwgcGF0aFRvRmlsZVVSTCQxKHRoaXMubWFwLm1hcEZpbGUpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0MiA9IHtcbiAgICAgICAgICAgIGNvbHVtbjogZnJvbS5jb2x1bW4sXG4gICAgICAgICAgICBlbmRDb2x1bW46IHRvICYmIHRvLmNvbHVtbixcbiAgICAgICAgICAgIGVuZExpbmU6IHRvICYmIHRvLmxpbmUsXG4gICAgICAgICAgICBsaW5lOiBmcm9tLmxpbmUsXG4gICAgICAgICAgICB1cmw6IGZyb21VcmwudG9TdHJpbmcoKVxuICAgICAgICB9O1xuICAgICAgICBpZiAoZnJvbVVybC5wcm90b2NvbCA9PT0gXCJmaWxlOlwiKSB7XG4gICAgICAgICAgICBpZiAoZmlsZVVSTFRvUGF0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIuZmlsZSA9IGZpbGVVUkxUb1BhdGgoZnJvbVVybCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZpbGU6IHByb3RvY29sIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBQb3N0Q1NTIGJ1aWxkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzb3VyY2UgPSBjb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKGZyb20uc291cmNlKTtcbiAgICAgICAgaWYgKHNvdXJjZSkgcmVzdWx0Mi5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgIH07XG4gICAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgdmFyIGpzb24gPSB7fTtcbiAgICAgICAgZm9yKHZhciBfaSA9IDAsIF9pdGVyID0gW1xuICAgICAgICAgICAgXCJoYXNCT01cIixcbiAgICAgICAgICAgIFwiY3NzXCIsXG4gICAgICAgICAgICBcImZpbGVcIixcbiAgICAgICAgICAgIFwiaWRcIlxuICAgICAgICBdOyBfaSA8IF9pdGVyLmxlbmd0aDsgX2krKyl7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IF9pdGVyW19pXTtcbiAgICAgICAgICAgIGlmICh0aGlzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBqc29uW25hbWVdID0gdGhpc1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXApIHtcbiAgICAgICAgICAgIGpzb24ubWFwID0gX2V4dGVuZHMoe30sIHRoaXMubWFwKTtcbiAgICAgICAgICAgIGlmIChqc29uLm1hcC5jb25zdW1lckNhY2hlKSB7XG4gICAgICAgICAgICAgICAganNvbi5tYXAuY29uc3VtZXJDYWNoZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9O1xuICAgIF9jcmVhdGVfY2xhc3MoSW5wdXQyLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmcm9tXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWxlIHx8IHRoaXMuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gSW5wdXQyO1xufSgpO1xudmFyIGlucHV0ID0gSW5wdXQkNDtcbklucHV0JDQuZGVmYXVsdCA9IElucHV0JDQ7XG5pZiAodGVybWluYWxIaWdobGlnaHQgJiYgdGVybWluYWxIaWdobGlnaHQucmVnaXN0ZXJJbnB1dCkge1xuICAgIHRlcm1pbmFsSGlnaGxpZ2h0LnJlZ2lzdGVySW5wdXQoSW5wdXQkNCk7XG59XG52YXIgU291cmNlTWFwQ29uc3VtZXIgPSByZXF1aXJlJCQyLlNvdXJjZU1hcENvbnN1bWVyLCBTb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlJCQyLlNvdXJjZU1hcEdlbmVyYXRvcjtcbnZhciBkaXJuYW1lID0gcmVxdWlyZSQkMi5kaXJuYW1lLCByZWxhdGl2ZSA9IHJlcXVpcmUkJDIucmVsYXRpdmUsIHJlc29sdmUkMyA9IHJlcXVpcmUkJDIucmVzb2x2ZSwgc2VwID0gcmVxdWlyZSQkMi5zZXA7XG52YXIgcGF0aFRvRmlsZVVSTCA9IHJlcXVpcmUkJDIucGF0aFRvRmlsZVVSTDtcbnZhciBJbnB1dCQzID0gaW5wdXQ7XG52YXIgc291cmNlTWFwQXZhaWxhYmxlID0gQm9vbGVhbihTb3VyY2VNYXBDb25zdW1lciAmJiBTb3VyY2VNYXBHZW5lcmF0b3IpO1xudmFyIHBhdGhBdmFpbGFibGUgPSBCb29sZWFuKGRpcm5hbWUgJiYgcmVzb2x2ZSQzICYmIHJlbGF0aXZlICYmIHNlcCk7XG52YXIgTWFwR2VuZXJhdG9yJDIgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIE1hcEdlbmVyYXRvcjIoc3RyaW5naWZ5Miwgcm9vdDIsIG9wdHMsIGNzc1N0cmluZykge1xuICAgICAgICB0aGlzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTI7XG4gICAgICAgIHRoaXMubWFwT3B0cyA9IG9wdHMubWFwIHx8IHt9O1xuICAgICAgICB0aGlzLnJvb3QgPSByb290MjtcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICAgICAgdGhpcy5jc3MgPSBjc3NTdHJpbmc7XG4gICAgICAgIHRoaXMub3JpZ2luYWxDU1MgPSBjc3NTdHJpbmc7XG4gICAgICAgIHRoaXMudXNlc0ZpbGVVcmxzID0gIXRoaXMubWFwT3B0cy5mcm9tICYmIHRoaXMubWFwT3B0cy5hYnNvbHV0ZTtcbiAgICAgICAgdGhpcy5tZW1vaXplZEZpbGVVUkxzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5tZW1vaXplZFBhdGhzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5tZW1vaXplZFVSTHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gTWFwR2VuZXJhdG9yMi5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmFkZEFubm90YXRpb24gPSBmdW5jdGlvbiBhZGRBbm5vdGF0aW9uKCkge1xuICAgICAgICB2YXIgY29udGVudDtcbiAgICAgICAgaWYgKHRoaXMuaXNJbmxpbmUoKSkge1xuICAgICAgICAgICAgY29udGVudCA9IFwiZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIHRoaXMudG9CYXNlNjQodGhpcy5tYXAudG9TdHJpbmcoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gdGhpcy5tYXBPcHRzLmFubm90YXRpb247XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbih0aGlzLm9wdHMudG8sIHRoaXMucm9vdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZW50ID0gdGhpcy5vdXRwdXRGaWxlKCkgKyBcIi5tYXBcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW9sID0gXCJcXG5cIjtcbiAgICAgICAgaWYgKHRoaXMuY3NzLmluY2x1ZGVzKFwiXFxyXFxuXCIpKSBlb2wgPSBcIlxcclxcblwiO1xuICAgICAgICB0aGlzLmNzcyArPSBlb2wgKyBcIi8qIyBzb3VyY2VNYXBwaW5nVVJMPVwiICsgY29udGVudCArIFwiICovXCI7XG4gICAgfTtcbiAgICBfcHJvdG8uYXBwbHlQcmV2TWFwcyA9IGZ1bmN0aW9uIGFwcGx5UHJldk1hcHMoKSB7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHRoaXMucHJldmlvdXMoKSksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICB2YXIgZnJvbSA9IHRoaXMudG9VcmwodGhpcy5wYXRoKHByZXYuZmlsZSkpO1xuICAgICAgICAgICAgdmFyIHJvb3QyID0gcHJldi5yb290IHx8IGRpcm5hbWUocHJldi5maWxlKTtcbiAgICAgICAgICAgIHZhciBtYXAgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXBPcHRzLnNvdXJjZXNDb250ZW50ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG1hcCA9IG5ldyBTb3VyY2VNYXBDb25zdW1lcihwcmV2LnRleHQpO1xuICAgICAgICAgICAgICAgIGlmIChtYXAuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwLnNvdXJjZXNDb250ZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hcCA9IHByZXYuY29uc3VtZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWFwLmFwcGx5U291cmNlTWFwKG1hcCwgZnJvbSwgdGhpcy50b1VybCh0aGlzLnBhdGgocm9vdDIpKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5jbGVhckFubm90YXRpb24gPSBmdW5jdGlvbiBjbGVhckFubm90YXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbiA9PT0gZmFsc2UpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgICAgICAgdmFyIG5vZGUyO1xuICAgICAgICAgICAgZm9yKHZhciBpMiA9IHRoaXMucm9vdC5ub2Rlcy5sZW5ndGggLSAxOyBpMiA+PSAwOyBpMi0tKXtcbiAgICAgICAgICAgICAgICBub2RlMiA9IHRoaXMucm9vdC5ub2Rlc1tpMl07XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUyLnR5cGUgIT09IFwiY29tbWVudFwiKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZTIudGV4dC5pbmRleE9mKFwiIyBzb3VyY2VNYXBwaW5nVVJMPVwiKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3QucmVtb3ZlQ2hpbGQoaTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNzcykge1xuICAgICAgICAgICAgdGhpcy5jc3MgPSB0aGlzLmNzcy5yZXBsYWNlKC9cXG4qP1xcL1xcKiNbXFxTXFxzXSo/XFwqXFwvJC9nbSwgXCJcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5nZW5lcmF0ZSA9IGZ1bmN0aW9uIGdlbmVyYXRlKCkge1xuICAgICAgICB0aGlzLmNsZWFyQW5ub3RhdGlvbigpO1xuICAgICAgICBpZiAocGF0aEF2YWlsYWJsZSAmJiBzb3VyY2VNYXBBdmFpbGFibGUgJiYgdGhpcy5pc01hcCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZU1hcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDIgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5zdHJpbmdpZnkodGhpcy5yb290LCBmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIgKz0gaTI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgcmVzdWx0MlxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmdlbmVyYXRlTWFwID0gZnVuY3Rpb24gZ2VuZXJhdGVNYXAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVTdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXZpb3VzKCkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB2YXIgcHJldiA9IHRoaXMucHJldmlvdXMoKVswXS5jb25zdW1lcigpO1xuICAgICAgICAgICAgcHJldi5maWxlID0gdGhpcy5vdXRwdXRGaWxlKCk7XG4gICAgICAgICAgICB0aGlzLm1hcCA9IFNvdXJjZU1hcEdlbmVyYXRvci5mcm9tU291cmNlTWFwKHByZXYsIHtcbiAgICAgICAgICAgICAgICBpZ25vcmVJbnZhbGlkTWFwcGluZzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1hcCA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3Ioe1xuICAgICAgICAgICAgICAgIGZpbGU6IHRoaXMub3V0cHV0RmlsZSgpLFxuICAgICAgICAgICAgICAgIGlnbm9yZUludmFsaWRNYXBwaW5nOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IDAsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IDFcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbjogMCxcbiAgICAgICAgICAgICAgICAgICAgbGluZTogMVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc291cmNlOiB0aGlzLm9wdHMuZnJvbSA/IHRoaXMudG9VcmwodGhpcy5wYXRoKHRoaXMub3B0cy5mcm9tKSkgOiBcIjxubyBzb3VyY2U+XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzU291cmNlc0NvbnRlbnQoKSkgdGhpcy5zZXRTb3VyY2VzQ29udGVudCgpO1xuICAgICAgICBpZiAodGhpcy5yb290ICYmIHRoaXMucHJldmlvdXMoKS5sZW5ndGggPiAwKSB0aGlzLmFwcGx5UHJldk1hcHMoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNBbm5vdGF0aW9uKCkpIHRoaXMuYWRkQW5ub3RhdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5pc0lubGluZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHRoaXMuY3NzXG4gICAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB0aGlzLmNzcyxcbiAgICAgICAgICAgICAgICB0aGlzLm1hcFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmdlbmVyYXRlU3RyaW5nID0gZnVuY3Rpb24gZ2VuZXJhdGVTdHJpbmcoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY3NzID0gXCJcIjtcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKHtcbiAgICAgICAgICAgIGZpbGU6IHRoaXMub3V0cHV0RmlsZSgpLFxuICAgICAgICAgICAgaWdub3JlSW52YWxpZE1hcHBpbmc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBsaW5lID0gMTtcbiAgICAgICAgdmFyIGNvbHVtbiA9IDE7XG4gICAgICAgIHZhciBub1NvdXJjZSA9IFwiPG5vIHNvdXJjZT5cIjtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSB7XG4gICAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IDAsXG4gICAgICAgICAgICAgICAgbGluZTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiAwLFxuICAgICAgICAgICAgICAgIGxpbmU6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzb3VyY2U6IFwiXCJcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGxpbmVzLCBsYXN0O1xuICAgICAgICB0aGlzLnN0cmluZ2lmeSh0aGlzLnJvb3QsIGZ1bmN0aW9uKHN0ciwgbm9kZTIsIHR5cGUpIHtcbiAgICAgICAgICAgIF90aGlzLmNzcyArPSBzdHI7XG4gICAgICAgICAgICBpZiAobm9kZTIgJiYgdHlwZSAhPT0gXCJlbmRcIikge1xuICAgICAgICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmxpbmUgPSBsaW5lO1xuICAgICAgICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmNvbHVtbiA9IGNvbHVtbiAtIDE7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUyLnNvdXJjZSAmJiBub2RlMi5zb3VyY2Uuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBfdGhpcy5zb3VyY2VQYXRoKG5vZGUyKTtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5saW5lID0gbm9kZTIuc291cmNlLnN0YXJ0LmxpbmU7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwuY29sdW1uID0gbm9kZTIuc291cmNlLnN0YXJ0LmNvbHVtbiAtIDE7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm1hcC5hZGRNYXBwaW5nKG1hcHBpbmcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gbm9Tb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwubGluZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwuY29sdW1uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubWFwLmFkZE1hcHBpbmcobWFwcGluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGluZXMgPSBzdHIubWF0Y2goL1xcbi9nKTtcbiAgICAgICAgICAgIGlmIChsaW5lcykge1xuICAgICAgICAgICAgICAgIGxpbmUgKz0gbGluZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxhc3QgPSBzdHIubGFzdEluZGV4T2YoXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgY29sdW1uID0gc3RyLmxlbmd0aCAtIGxhc3Q7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbHVtbiArPSBzdHIubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUyICYmIHR5cGUgIT09IFwic3RhcnRcIikge1xuICAgICAgICAgICAgICAgIHZhciBwID0gbm9kZTIucGFyZW50IHx8IHtcbiAgICAgICAgICAgICAgICAgICAgcmF3czoge31cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZGxlc3MgPSBub2RlMi50eXBlID09PSBcImRlY2xcIiB8fCBub2RlMi50eXBlID09PSBcImF0cnVsZVwiICYmICFub2RlMi5ub2RlcztcbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkbGVzcyB8fCBub2RlMiAhPT0gcC5sYXN0IHx8IHAucmF3cy5zZW1pY29sb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUyLnNvdXJjZSAmJiBub2RlMi5zb3VyY2UuZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IF90aGlzLnNvdXJjZVBhdGgobm9kZTIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5saW5lID0gbm9kZTIuc291cmNlLmVuZC5saW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5jb2x1bW4gPSBub2RlMi5zb3VyY2UuZW5kLmNvbHVtbiAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZC5saW5lID0gbGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmNvbHVtbiA9IGNvbHVtbiAtIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXAuYWRkTWFwcGluZyhtYXBwaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gbm9Tb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmxpbmUgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5jb2x1bW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQubGluZSA9IGxpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZC5jb2x1bW4gPSBjb2x1bW4gLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubWFwLmFkZE1hcHBpbmcobWFwcGluZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmlzQW5ub3RhdGlvbiA9IGZ1bmN0aW9uIGlzQW5ub3RhdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNJbmxpbmUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91cygpLnNvbWUoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTIuYW5ub3RhdGlvbjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgX3Byb3RvLmlzSW5saW5lID0gZnVuY3Rpb24gaXNJbmxpbmUoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLmlubGluZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwT3B0cy5pbmxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFubm90YXRpb24gPSB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbjtcbiAgICAgICAgaWYgKHR5cGVvZiBhbm5vdGF0aW9uICE9PSBcInVuZGVmaW5lZFwiICYmIGFubm90YXRpb24gIT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcmV2aW91cygpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXMoKS5zb21lKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkyLmlubGluZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgX3Byb3RvLmlzTWFwID0gZnVuY3Rpb24gaXNNYXAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRzLm1hcCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5vcHRzLm1hcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91cygpLmxlbmd0aCA+IDA7XG4gICAgfTtcbiAgICBfcHJvdG8uaXNTb3VyY2VzQ29udGVudCA9IGZ1bmN0aW9uIGlzU291cmNlc0NvbnRlbnQoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLnNvdXJjZXNDb250ZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXBPcHRzLnNvdXJjZXNDb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91cygpLnNvbWUoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTIud2l0aENvbnRlbnQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgX3Byb3RvLm91dHB1dEZpbGUgPSBmdW5jdGlvbiBvdXRwdXRGaWxlKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRzLnRvKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXRoKHRoaXMub3B0cy50byk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRzLmZyb20pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhdGgodGhpcy5vcHRzLmZyb20pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwidG8uY3NzXCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5wYXRoID0gZnVuY3Rpb24gcGF0aChmaWxlKSB7XG4gICAgICAgIGlmICh0aGlzLm1hcE9wdHMuYWJzb2x1dGUpIHJldHVybiBmaWxlO1xuICAgICAgICBpZiAoZmlsZS5jaGFyQ29kZUF0KDApID09PSA2MCkgcmV0dXJuIGZpbGU7XG4gICAgICAgIGlmICgvXlxcdys6XFwvXFwvLy50ZXN0KGZpbGUpKSByZXR1cm4gZmlsZTtcbiAgICAgICAgdmFyIGNhY2hlZCA9IHRoaXMubWVtb2l6ZWRQYXRocy5nZXQoZmlsZSk7XG4gICAgICAgIGlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIHZhciBmcm9tID0gdGhpcy5vcHRzLnRvID8gZGlybmFtZSh0aGlzLm9wdHMudG8pIDogXCIuXCI7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLmFubm90YXRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGZyb20gPSBkaXJuYW1lKHJlc29sdmUkMyhmcm9tLCB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXRoID0gcmVsYXRpdmUoZnJvbSwgZmlsZSk7XG4gICAgICAgIHRoaXMubWVtb2l6ZWRQYXRocy5zZXQoZmlsZSwgcGF0aCk7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH07XG4gICAgX3Byb3RvLnByZXZpb3VzID0gZnVuY3Rpb24gcHJldmlvdXMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5wcmV2aW91c01hcHMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNNYXBzID0gW107XG4gICAgICAgICAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290LndhbGsoZnVuY3Rpb24obm9kZTIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUyLnNvdXJjZSAmJiBub2RlMi5zb3VyY2UuaW5wdXQubWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFwID0gbm9kZTIuc291cmNlLmlucHV0Lm1hcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMucHJldmlvdXNNYXBzLmluY2x1ZGVzKG1hcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcmV2aW91c01hcHMucHVzaChtYXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dDIgPSBuZXcgSW5wdXQkMyh0aGlzLm9yaWdpbmFsQ1NTLCB0aGlzLm9wdHMpO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dDIubWFwKSB0aGlzLnByZXZpb3VzTWFwcy5wdXNoKGlucHV0Mi5tYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzTWFwcztcbiAgICB9O1xuICAgIF9wcm90by5zZXRTb3VyY2VzQ29udGVudCA9IGZ1bmN0aW9uIHNldFNvdXJjZXNDb250ZW50KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYWxyZWFkeSA9IHt9O1xuICAgICAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICAgICAgICB0aGlzLnJvb3Qud2FsayhmdW5jdGlvbihub2RlMikge1xuICAgICAgICAgICAgICAgIGlmIChub2RlMi5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyb20gPSBub2RlMi5zb3VyY2UuaW5wdXQuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gJiYgIWFscmVhZHlbZnJvbV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscmVhZHlbZnJvbV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyb21VcmwgPSBfdGhpcy51c2VzRmlsZVVybHMgPyBfdGhpcy50b0ZpbGVVcmwoZnJvbSkgOiBfdGhpcy50b1VybChfdGhpcy5wYXRoKGZyb20pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm1hcC5zZXRTb3VyY2VDb250ZW50KGZyb21VcmwsIG5vZGUyLnNvdXJjZS5pbnB1dC5jc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jc3MpIHtcbiAgICAgICAgICAgIHZhciBmcm9tID0gdGhpcy5vcHRzLmZyb20gPyB0aGlzLnRvVXJsKHRoaXMucGF0aCh0aGlzLm9wdHMuZnJvbSkpIDogXCI8bm8gc291cmNlPlwiO1xuICAgICAgICAgICAgdGhpcy5tYXAuc2V0U291cmNlQ29udGVudChmcm9tLCB0aGlzLmNzcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5zb3VyY2VQYXRoID0gZnVuY3Rpb24gc291cmNlUGF0aChub2RlMikge1xuICAgICAgICBpZiAodGhpcy5tYXBPcHRzLmZyb20pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvVXJsKHRoaXMubWFwT3B0cy5mcm9tKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnVzZXNGaWxlVXJscykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9GaWxlVXJsKG5vZGUyLnNvdXJjZS5pbnB1dC5mcm9tKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvVXJsKHRoaXMucGF0aChub2RlMi5zb3VyY2UuaW5wdXQuZnJvbSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8udG9CYXNlNjQgPSBmdW5jdGlvbiB0b0Jhc2U2NChzdHIpIHtcbiAgICAgICAgaWYgKEJ1ZmZlcikge1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0cikudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LmJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnRvRmlsZVVybCA9IGZ1bmN0aW9uIHRvRmlsZVVybChwYXRoKSB7XG4gICAgICAgIHZhciBjYWNoZWQgPSB0aGlzLm1lbW9pemVkRmlsZVVSTHMuZ2V0KHBhdGgpO1xuICAgICAgICBpZiAoY2FjaGVkKSByZXR1cm4gY2FjaGVkO1xuICAgICAgICBpZiAocGF0aFRvRmlsZVVSTCkge1xuICAgICAgICAgICAgdmFyIGZpbGVVUkwgPSBwYXRoVG9GaWxlVVJMKHBhdGgpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB0aGlzLm1lbW9pemVkRmlsZVVSTHMuc2V0KHBhdGgsIGZpbGVVUkwpO1xuICAgICAgICAgICAgcmV0dXJuIGZpbGVVUkw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgbWFwLmFic29sdXRlYCBvcHRpb24gaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIFBvc3RDU1MgYnVpbGRcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by50b1VybCA9IGZ1bmN0aW9uIHRvVXJsKHBhdGgpIHtcbiAgICAgICAgdmFyIGNhY2hlZCA9IHRoaXMubWVtb2l6ZWRVUkxzLmdldChwYXRoKTtcbiAgICAgICAgaWYgKGNhY2hlZCkgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgaWYgKHNlcCA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1cmwgPSBlbmNvZGVVUkkocGF0aCkucmVwbGFjZSgvWyM/XS9nLCBlbmNvZGVVUklDb21wb25lbnQpO1xuICAgICAgICB0aGlzLm1lbW9pemVkVVJMcy5zZXQocGF0aCwgdXJsKTtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9O1xuICAgIHJldHVybiBNYXBHZW5lcmF0b3IyO1xufSgpO1xudmFyIG1hcEdlbmVyYXRvciA9IE1hcEdlbmVyYXRvciQyO1xudmFyIE5vZGUkMiA9IG5vZGU7XG52YXIgQ29tbWVudCQ0ID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihOb2RlJDIpIHtcbiAgICBfaW5oZXJpdHMoQ29tbWVudDIsIE5vZGUkMik7XG4gICAgZnVuY3Rpb24gQ29tbWVudDIoZGVmYXVsdHMpIHtcbiAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICBfdGhpcyA9IE5vZGUkMi5jYWxsKHRoaXMsIGRlZmF1bHRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlID0gXCJjb21tZW50XCI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENvbW1lbnQyO1xufShOb2RlJDIpO1xudmFyIGNvbW1lbnQgPSBDb21tZW50JDQ7XG5Db21tZW50JDQuZGVmYXVsdCA9IENvbW1lbnQkNDtcbnZhciBpc0NsZWFuJDEgPSBzeW1ib2xzLmlzQ2xlYW4sIG15JDEgPSBzeW1ib2xzLm15O1xudmFyIERlY2xhcmF0aW9uJDMgPSBkZWNsYXJhdGlvbjtcbnZhciBDb21tZW50JDMgPSBjb21tZW50O1xudmFyIE5vZGUkMSA9IG5vZGU7XG52YXIgcGFyc2UkNCwgUnVsZSQ0LCBBdFJ1bGUkNCwgUm9vdCQ2O1xuZnVuY3Rpb24gY2xlYW5Tb3VyY2Uobm9kZXMpIHtcbiAgICByZXR1cm4gbm9kZXMubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgIGlmIChpMi5ub2RlcykgaTIubm9kZXMgPSBjbGVhblNvdXJjZShpMi5ub2Rlcyk7XG4gICAgICAgIGRlbGV0ZSBpMi5zb3VyY2U7XG4gICAgICAgIHJldHVybiBpMjtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG1hcmtEaXJ0eVVwKG5vZGUyKSB7XG4gICAgbm9kZTJbaXNDbGVhbiQxXSA9IGZhbHNlO1xuICAgIGlmIChub2RlMi5wcm94eU9mLm5vZGVzKSB7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKG5vZGUyLnByb3h5T2Yubm9kZXMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgaTIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIG1hcmtEaXJ0eVVwKGkyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbnZhciBDb250YWluZXIkNyA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oTm9kZSQxKSB7XG4gICAgX2luaGVyaXRzKENvbnRhaW5lcjIsIE5vZGUkMSk7XG4gICAgZnVuY3Rpb24gQ29udGFpbmVyMigpIHtcbiAgICAgICAgcmV0dXJuIE5vZGUkMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBDb250YWluZXIyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBjaGlsZHJlbiA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgY2hpbGRyZW5bX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UoY2hpbGRyZW4pLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIHZhciBub2RlcyA9IHRoaXMubm9ybWFsaXplKGNoaWxkLCB0aGlzLmxhc3QpO1xuICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IxID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKG5vZGVzKSwgX3N0ZXAxOyAhKF9zdGVwMSA9IF9pdGVyYXRvcjEoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgIHZhciBub2RlMiA9IF9zdGVwMS52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3h5T2Yubm9kZXMucHVzaChub2RlMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8uY2xlYW5SYXdzID0gZnVuY3Rpb24gY2xlYW5SYXdzKGtlZXBCZXR3ZWVuKSB7XG4gICAgICAgIE5vZGUkMS5wcm90b3R5cGUuY2xlYW5SYXdzLmNhbGwodGhpcywga2VlcEJldHdlZW4pO1xuICAgICAgICBpZiAodGhpcy5ub2Rlcykge1xuICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UodGhpcy5ub2RlcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZTIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICBub2RlMi5jbGVhblJhd3Moa2VlcEJldHdlZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZWFjaCA9IGZ1bmN0aW9uIGVhY2goY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3h5T2Yubm9kZXMpIHJldHVybiB2b2lkIDA7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuZ2V0SXRlcmF0b3IoKTtcbiAgICAgICAgdmFyIGluZGV4MiwgcmVzdWx0MjtcbiAgICAgICAgd2hpbGUodGhpcy5pbmRleGVzW2l0ZXJhdG9yXSA8IHRoaXMucHJveHlPZi5ub2Rlcy5sZW5ndGgpe1xuICAgICAgICAgICAgaW5kZXgyID0gdGhpcy5pbmRleGVzW2l0ZXJhdG9yXTtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBjYWxsYmFjayh0aGlzLnByb3h5T2Yubm9kZXNbaW5kZXgyXSwgaW5kZXgyKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQyID09PSBmYWxzZSkgYnJlYWs7XG4gICAgICAgICAgICB0aGlzLmluZGV4ZXNbaXRlcmF0b3JdICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMuaW5kZXhlc1tpdGVyYXRvcl07XG4gICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgIH07XG4gICAgX3Byb3RvLmV2ZXJ5ID0gZnVuY3Rpb24gZXZlcnkoY29uZGl0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLmV2ZXJ5KGNvbmRpdGlvbik7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0SXRlcmF0b3IgPSBmdW5jdGlvbiBnZXRJdGVyYXRvcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxhc3RFYWNoKSB0aGlzLmxhc3RFYWNoID0gMDtcbiAgICAgICAgaWYgKCF0aGlzLmluZGV4ZXMpIHRoaXMuaW5kZXhlcyA9IHt9O1xuICAgICAgICB0aGlzLmxhc3RFYWNoICs9IDE7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMubGFzdEVhY2g7XG4gICAgICAgIHRoaXMuaW5kZXhlc1tpdGVyYXRvcl0gPSAwO1xuICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0UHJveHlQcm9jZXNzb3IgPSBmdW5jdGlvbiBnZXRQcm94eVByb2Nlc3NvcigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KG5vZGUyLCBwcm9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgPT09IFwicHJveHlPZlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlMjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFub2RlMltwcm9wXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTJbcHJvcF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBcImVhY2hcIiB8fCB0eXBlb2YgcHJvcCA9PT0gXCJzdHJpbmdcIiAmJiBwcm9wLnN0YXJ0c1dpdGgoXCJ3YWxrXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9ub2RlMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoX25vZGUyID0gbm9kZTIpW3Byb3BdLmFwcGx5KF9ub2RlMiwgW10uY29uY2F0KGFyZ3MubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihjaGlsZCwgaW5kZXgyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTIoY2hpbGQudG9Qcm94eSgpLCBpbmRleDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJldmVyeVwiIHx8IHByb3AgPT09IFwic29tZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihjYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUyW3Byb3BdKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgb3RoZXIgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiLmFwcGx5KHZvaWQgMCwgW10uY29uY2F0KFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQudG9Qcm94eSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwgb3RoZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUyLnJvb3QoKS50b1Byb3h5KCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBcIm5vZGVzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUyLm5vZGVzLm1hcChmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkyLnRvUHJveHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBcImZpcnN0XCIgfHwgcHJvcCA9PT0gXCJsYXN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUyW3Byb3BdLnRvUHJveHkoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTJbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KG5vZGUyLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlMltwcm9wXSA9PT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIG5vZGUyW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgPT09IFwibmFtZVwiIHx8IHByb3AgPT09IFwicGFyYW1zXCIgfHwgcHJvcCA9PT0gXCJzZWxlY3RvclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUyLm1hcmtEaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIF9wcm90by5pbmRleCA9IGZ1bmN0aW9uIGluZGV4KGNoaWxkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09IFwibnVtYmVyXCIpIHJldHVybiBjaGlsZDtcbiAgICAgICAgaWYgKGNoaWxkLnByb3h5T2YpIGNoaWxkID0gY2hpbGQucHJveHlPZjtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJveHlPZi5ub2Rlcy5pbmRleE9mKGNoaWxkKTtcbiAgICB9O1xuICAgIF9wcm90by5pbnNlcnRBZnRlciA9IGZ1bmN0aW9uIGluc2VydEFmdGVyKGV4aXN0LCBhZGQpIHtcbiAgICAgICAgdmFyIGV4aXN0SW5kZXggPSB0aGlzLmluZGV4KGV4aXN0KTtcbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub3JtYWxpemUoYWRkLCB0aGlzLnByb3h5T2Yubm9kZXNbZXhpc3RJbmRleF0pLnJldmVyc2UoKTtcbiAgICAgICAgZXhpc3RJbmRleCA9IHRoaXMuaW5kZXgoZXhpc3QpO1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShub2RlcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBub2RlMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5wcm94eU9mLm5vZGVzLnNwbGljZShleGlzdEluZGV4ICsgMSwgMCwgbm9kZTIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleDI7XG4gICAgICAgIGZvcih2YXIgaWQgaW4gdGhpcy5pbmRleGVzKXtcbiAgICAgICAgICAgIGluZGV4MiA9IHRoaXMuaW5kZXhlc1tpZF07XG4gICAgICAgICAgICBpZiAoZXhpc3RJbmRleCA8IGluZGV4Mikge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhlc1tpZF0gPSBpbmRleDIgKyBub2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8uaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKGV4aXN0LCBhZGQpIHtcbiAgICAgICAgdmFyIGV4aXN0SW5kZXggPSB0aGlzLmluZGV4KGV4aXN0KTtcbiAgICAgICAgdmFyIHR5cGUgPSBleGlzdEluZGV4ID09PSAwID8gXCJwcmVwZW5kXCIgOiBmYWxzZTtcbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub3JtYWxpemUoYWRkLCB0aGlzLnByb3h5T2Yubm9kZXNbZXhpc3RJbmRleF0sIHR5cGUpLnJldmVyc2UoKTtcbiAgICAgICAgZXhpc3RJbmRleCA9IHRoaXMuaW5kZXgoZXhpc3QpO1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShub2RlcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBub2RlMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5wcm94eU9mLm5vZGVzLnNwbGljZShleGlzdEluZGV4LCAwLCBub2RlMik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4MjtcbiAgICAgICAgZm9yKHZhciBpZCBpbiB0aGlzLmluZGV4ZXMpe1xuICAgICAgICAgICAgaW5kZXgyID0gdGhpcy5pbmRleGVzW2lkXTtcbiAgICAgICAgICAgIGlmIChleGlzdEluZGV4IDw9IGluZGV4Mikge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhlc1tpZF0gPSBpbmRleDIgKyBub2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8ubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKG5vZGVzLCBzYW1wbGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbm9kZXMgPSBjbGVhblNvdXJjZShwYXJzZSQ0KG5vZGVzKS5ub2Rlcyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBub2RlcyA9IFtdO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobm9kZXMpKSB7XG4gICAgICAgICAgICBub2RlcyA9IG5vZGVzLnNsaWNlKDApO1xuICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uobm9kZXMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgdmFyIGkyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGkyLnBhcmVudCkgaTIucGFyZW50LnJlbW92ZUNoaWxkKGkyLCBcImlnbm9yZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChub2Rlcy50eXBlID09PSBcInJvb3RcIiAmJiB0aGlzLnR5cGUgIT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICAgICAgbm9kZXMgPSBub2Rlcy5ub2Rlcy5zbGljZSgwKTtcbiAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yMSA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShub2RlcyksIF9zdGVwMTsgIShfc3RlcDEgPSBfaXRlcmF0b3IxKCkpLmRvbmU7KXtcbiAgICAgICAgICAgICAgICB2YXIgaTIxID0gX3N0ZXAxLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChpMjEucGFyZW50KSBpMjEucGFyZW50LnJlbW92ZUNoaWxkKGkyMSwgXCJpZ25vcmVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZXMudHlwZSkge1xuICAgICAgICAgICAgbm9kZXMgPSBbXG4gICAgICAgICAgICAgICAgbm9kZXNcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZXMucHJvcCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBub2Rlcy52YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbHVlIGZpZWxkIGlzIG1pc3NlZCBpbiBub2RlIGNyZWF0aW9uXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZXMudmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBub2Rlcy52YWx1ZSA9IFN0cmluZyhub2Rlcy52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlcyA9IFtcbiAgICAgICAgICAgICAgICBuZXcgRGVjbGFyYXRpb24kMyhub2RlcylcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZXMuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIG5vZGVzID0gW1xuICAgICAgICAgICAgICAgIG5ldyBSdWxlJDQobm9kZXMpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGVzLm5hbWUpIHtcbiAgICAgICAgICAgIG5vZGVzID0gW1xuICAgICAgICAgICAgICAgIG5ldyBBdFJ1bGUkNChub2RlcylcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZXMudGV4dCkge1xuICAgICAgICAgICAgbm9kZXMgPSBbXG4gICAgICAgICAgICAgICAgbmV3IENvbW1lbnQkMyhub2RlcylcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG5vZGUgdHlwZSBpbiBub2RlIGNyZWF0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9jZXNzZWQgPSBub2Rlcy5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIGlmICghaTJbbXkkMV0pIENvbnRhaW5lcjIucmVidWlsZChpMik7XG4gICAgICAgICAgICBpMiA9IGkyLnByb3h5T2Y7XG4gICAgICAgICAgICBpZiAoaTIucGFyZW50KSBpMi5wYXJlbnQucmVtb3ZlQ2hpbGQoaTIpO1xuICAgICAgICAgICAgaWYgKGkyW2lzQ2xlYW4kMV0pIG1hcmtEaXJ0eVVwKGkyKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5iZWZvcmUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2FtcGxlICYmIHR5cGVvZiBzYW1wbGUucmF3cy5iZWZvcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaTIucmF3cy5iZWZvcmUgPSBzYW1wbGUucmF3cy5iZWZvcmUucmVwbGFjZSgvXFxTL2csIFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkyLnBhcmVudCA9IF90aGlzLnByb3h5T2Y7XG4gICAgICAgICAgICByZXR1cm4gaTI7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkO1xuICAgIH07XG4gICAgX3Byb3RvLnByZXBlbmQgPSBmdW5jdGlvbiBwcmVwZW5kKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBjaGlsZHJlbiA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgY2hpbGRyZW5bX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5yZXZlcnNlKCk7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKGNoaWxkcmVuKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vcm1hbGl6ZShjaGlsZCwgdGhpcy5maXJzdCwgXCJwcmVwZW5kXCIpLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yMSA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShub2RlcyksIF9zdGVwMTsgIShfc3RlcDEgPSBfaXRlcmF0b3IxKCkpLmRvbmU7KXtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZTIgPSBfc3RlcDEudmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm94eU9mLm5vZGVzLnVuc2hpZnQobm9kZTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yKHZhciBpZCBpbiB0aGlzLmluZGV4ZXMpe1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhlc1tpZF0gPSB0aGlzLmluZGV4ZXNbaWRdICsgbm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLnB1c2ggPSBmdW5jdGlvbiBwdXNoKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgICAgIHRoaXMucHJveHlPZi5ub2Rlcy5wdXNoKGNoaWxkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVtb3ZlQWxsID0gZnVuY3Rpb24gcmVtb3ZlQWxsKCkge1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZSh0aGlzLnByb3h5T2Yubm9kZXMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgbm9kZTIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIG5vZGUyLnBhcmVudCA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb3h5T2Yubm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiByZW1vdmVDaGlsZChjaGlsZCkge1xuICAgICAgICBjaGlsZCA9IHRoaXMuaW5kZXgoY2hpbGQpO1xuICAgICAgICB0aGlzLnByb3h5T2Yubm9kZXNbY2hpbGRdLnBhcmVudCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5wcm94eU9mLm5vZGVzLnNwbGljZShjaGlsZCwgMSk7XG4gICAgICAgIHZhciBpbmRleDI7XG4gICAgICAgIGZvcih2YXIgaWQgaW4gdGhpcy5pbmRleGVzKXtcbiAgICAgICAgICAgIGluZGV4MiA9IHRoaXMuaW5kZXhlc1tpZF07XG4gICAgICAgICAgICBpZiAoaW5kZXgyID49IGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleGVzW2lkXSA9IGluZGV4MiAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVwbGFjZVZhbHVlcyA9IGZ1bmN0aW9uIHJlcGxhY2VWYWx1ZXMocGF0dGVybiwgb3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgICAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2Fsa0RlY2xzKGZ1bmN0aW9uKGRlY2wpIHtcbiAgICAgICAgICAgIGlmIChvcHRzLnByb3BzICYmICFvcHRzLnByb3BzLmluY2x1ZGVzKGRlY2wucHJvcCkpIHJldHVybjtcbiAgICAgICAgICAgIGlmIChvcHRzLmZhc3QgJiYgIWRlY2wudmFsdWUuaW5jbHVkZXMob3B0cy5mYXN0KSkgcmV0dXJuO1xuICAgICAgICAgICAgZGVjbC52YWx1ZSA9IGRlY2wudmFsdWUucmVwbGFjZShwYXR0ZXJuLCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90by5zb21lID0gZnVuY3Rpb24gc29tZShjb25kaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXMuc29tZShjb25kaXRpb24pO1xuICAgIH07XG4gICAgX3Byb3RvLndhbGsgPSBmdW5jdGlvbiB3YWxrKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MiA9IGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICAgICAgICAgIHRocm93IGNoaWxkLmFkZFRvRXJyb3IoZTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IGZhbHNlICYmIGNoaWxkLndhbGspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyID0gY2hpbGQud2FsayhjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8ud2Fsa0F0UnVsZXMgPSBmdW5jdGlvbiB3YWxrQXRSdWxlcyhuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IG5hbWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53YWxrKGZ1bmN0aW9uKGNoaWxkLCBpMikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImF0cnVsZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfaW5zdGFuY2VvZihuYW1lLCBSZWdFeHApKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53YWxrKGZ1bmN0aW9uKGNoaWxkLCBpMikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImF0cnVsZVwiICYmIG5hbWUudGVzdChjaGlsZC5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy53YWxrKGZ1bmN0aW9uKGNoaWxkLCBpMikge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiYXRydWxlXCIgJiYgY2hpbGQubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by53YWxrQ29tbWVudHMgPSBmdW5jdGlvbiB3YWxrQ29tbWVudHMoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by53YWxrRGVjbHMgPSBmdW5jdGlvbiB3YWxrRGVjbHMocHJvcCwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBwcm9wO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJkZWNsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9pbnN0YW5jZW9mKHByb3AsIFJlZ0V4cCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiZGVjbFwiICYmIHByb3AudGVzdChjaGlsZC5wcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy53YWxrKGZ1bmN0aW9uKGNoaWxkLCBpMikge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiZGVjbFwiICYmIGNoaWxkLnByb3AgPT09IHByb3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8ud2Fsa1J1bGVzID0gZnVuY3Rpb24gd2Fsa1J1bGVzKHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJydWxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9pbnN0YW5jZW9mKHNlbGVjdG9yLCBSZWdFeHApKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53YWxrKGZ1bmN0aW9uKGNoaWxkLCBpMikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcInJ1bGVcIiAmJiBzZWxlY3Rvci50ZXN0KGNoaWxkLnNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy53YWxrKGZ1bmN0aW9uKGNoaWxkLCBpMikge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwicnVsZVwiICYmIGNoaWxkLnNlbGVjdG9yID09PSBzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9jcmVhdGVfY2xhc3MoQ29udGFpbmVyMiwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZmlyc3RcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wcm94eU9mLm5vZGVzKSByZXR1cm4gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3h5T2Yubm9kZXNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJsYXN0XCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHJveHlPZi5ub2RlcykgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm94eU9mLm5vZGVzW3RoaXMucHJveHlPZi5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBDb250YWluZXIyO1xufShOb2RlJDEpO1xuQ29udGFpbmVyJDcucmVnaXN0ZXJQYXJzZSA9IGZ1bmN0aW9uKGRlcGVuZGFudCkge1xuICAgIHBhcnNlJDQgPSBkZXBlbmRhbnQ7XG59O1xuQ29udGFpbmVyJDcucmVnaXN0ZXJSdWxlID0gZnVuY3Rpb24oZGVwZW5kYW50KSB7XG4gICAgUnVsZSQ0ID0gZGVwZW5kYW50O1xufTtcbkNvbnRhaW5lciQ3LnJlZ2lzdGVyQXRSdWxlID0gZnVuY3Rpb24oZGVwZW5kYW50KSB7XG4gICAgQXRSdWxlJDQgPSBkZXBlbmRhbnQ7XG59O1xuQ29udGFpbmVyJDcucmVnaXN0ZXJSb290ID0gZnVuY3Rpb24oZGVwZW5kYW50KSB7XG4gICAgUm9vdCQ2ID0gZGVwZW5kYW50O1xufTtcbnZhciBjb250YWluZXIgPSBDb250YWluZXIkNztcbkNvbnRhaW5lciQ3LmRlZmF1bHQgPSBDb250YWluZXIkNztcbkNvbnRhaW5lciQ3LnJlYnVpbGQgPSBmdW5jdGlvbihub2RlMikge1xuICAgIGlmIChub2RlMi50eXBlID09PSBcImF0cnVsZVwiKSB7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihub2RlMiwgQXRSdWxlJDQucHJvdG90eXBlKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwicnVsZVwiKSB7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihub2RlMiwgUnVsZSQ0LnByb3RvdHlwZSk7XG4gICAgfSBlbHNlIGlmIChub2RlMi50eXBlID09PSBcImRlY2xcIikge1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZTIsIERlY2xhcmF0aW9uJDMucHJvdG90eXBlKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihub2RlMiwgQ29tbWVudCQzLnByb3RvdHlwZSk7XG4gICAgfSBlbHNlIGlmIChub2RlMi50eXBlID09PSBcInJvb3RcIikge1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZTIsIFJvb3QkNi5wcm90b3R5cGUpO1xuICAgIH1cbiAgICBub2RlMltteSQxXSA9IHRydWU7XG4gICAgaWYgKG5vZGUyLm5vZGVzKSB7XG4gICAgICAgIG5vZGUyLm5vZGVzLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgIENvbnRhaW5lciQ3LnJlYnVpbGQoY2hpbGQpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xudmFyIENvbnRhaW5lciQ2ID0gY29udGFpbmVyO1xudmFyIExhenlSZXN1bHQkNCwgUHJvY2Vzc29yJDM7XG52YXIgRG9jdW1lbnQkMyA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oQ29udGFpbmVyJDYpIHtcbiAgICBfaW5oZXJpdHMoRG9jdW1lbnQyMywgQ29udGFpbmVyJDYpO1xuICAgIGZ1bmN0aW9uIERvY3VtZW50MjMoZGVmYXVsdHMpIHtcbiAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICBfdGhpcyA9IENvbnRhaW5lciQ2LmNhbGwodGhpcywgX2V4dGVuZHMoe1xuICAgICAgICAgICAgdHlwZTogXCJkb2N1bWVudFwiXG4gICAgICAgIH0sIGRlZmF1bHRzKSkgfHwgdGhpcztcbiAgICAgICAgaWYgKCFfdGhpcy5ub2Rlcykge1xuICAgICAgICAgICAgX3RoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBEb2N1bWVudDIzLnByb3RvdHlwZTtcbiAgICBfcHJvdG8udG9SZXN1bHQgPSBmdW5jdGlvbiB0b1Jlc3VsdChvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzID09PSB2b2lkIDApIG9wdHMgPSB7fTtcbiAgICAgICAgdmFyIGxhenkgPSBuZXcgTGF6eVJlc3VsdCQ0KG5ldyBQcm9jZXNzb3IkMygpLCB0aGlzLCBvcHRzKTtcbiAgICAgICAgcmV0dXJuIGxhenkuc3RyaW5naWZ5KCk7XG4gICAgfTtcbiAgICByZXR1cm4gRG9jdW1lbnQyMztcbn0oQ29udGFpbmVyJDYpO1xuRG9jdW1lbnQkMy5yZWdpc3RlckxhenlSZXN1bHQgPSBmdW5jdGlvbihkZXBlbmRhbnQpIHtcbiAgICBMYXp5UmVzdWx0JDQgPSBkZXBlbmRhbnQ7XG59O1xuRG9jdW1lbnQkMy5yZWdpc3RlclByb2Nlc3NvciA9IGZ1bmN0aW9uKGRlcGVuZGFudCkge1xuICAgIFByb2Nlc3NvciQzID0gZGVwZW5kYW50O1xufTtcbnZhciBkb2N1bWVudCQxJDIgPSBEb2N1bWVudCQzO1xuRG9jdW1lbnQkMy5kZWZhdWx0ID0gRG9jdW1lbnQkMztcbnZhciBwcmludGVkID0ge307XG52YXIgd2Fybk9uY2UkMiA9IGZ1bmN0aW9uIHdhcm5PbmNlMihtZXNzYWdlKSB7XG4gICAgaWYgKHByaW50ZWRbbWVzc2FnZV0pIHJldHVybjtcbiAgICBwcmludGVkW21lc3NhZ2VdID0gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG59O1xudmFyIFdhcm5pbmckMiA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gV2FybmluZzIodGV4dCwgb3B0cykge1xuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSBvcHRzID0ge307XG4gICAgICAgIHRoaXMudHlwZSA9IFwid2FybmluZ1wiO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICBpZiAob3B0cy5ub2RlICYmIG9wdHMubm9kZS5zb3VyY2UpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IG9wdHMubm9kZS5yYW5nZUJ5KG9wdHMpO1xuICAgICAgICAgICAgdGhpcy5saW5lID0gcmFuZ2Uuc3RhcnQubGluZTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uID0gcmFuZ2Uuc3RhcnQuY29sdW1uO1xuICAgICAgICAgICAgdGhpcy5lbmRMaW5lID0gcmFuZ2UuZW5kLmxpbmU7XG4gICAgICAgICAgICB0aGlzLmVuZENvbHVtbiA9IHJhbmdlLmVuZC5jb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHZhciBvcHQgaW4gb3B0cyl0aGlzW29wdF0gPSBvcHRzW29wdF07XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBXYXJuaW5nMi5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGUuZXJyb3IodGhpcy50ZXh0LCB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsXG4gICAgICAgICAgICAgICAgcGx1Z2luOiB0aGlzLnBsdWdpbixcbiAgICAgICAgICAgICAgICB3b3JkOiB0aGlzLndvcmRcbiAgICAgICAgICAgIH0pLm1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGx1Z2luKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wbHVnaW4gKyBcIjogXCIgKyB0aGlzLnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICB9O1xuICAgIHJldHVybiBXYXJuaW5nMjtcbn0oKTtcbnZhciB3YXJuaW5nID0gV2FybmluZyQyO1xuV2FybmluZyQyLmRlZmF1bHQgPSBXYXJuaW5nJDI7XG52YXIgV2FybmluZyQxID0gd2FybmluZztcbnZhciBSZXN1bHQkMyA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gUmVzdWx0Mihwcm9jZXNzb3IyLCByb290Miwgb3B0cykge1xuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjI7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBbXTtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDI7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICAgIHRoaXMuY3NzID0gdm9pZCAwO1xuICAgICAgICB0aGlzLm1hcCA9IHZvaWQgMDtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFJlc3VsdDIucHJvdG90eXBlO1xuICAgIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jc3M7XG4gICAgfTtcbiAgICBfcHJvdG8ud2FybiA9IGZ1bmN0aW9uIHdhcm4odGV4dCwgb3B0cykge1xuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSBvcHRzID0ge307XG4gICAgICAgIGlmICghb3B0cy5wbHVnaW4pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxhc3RQbHVnaW4gJiYgdGhpcy5sYXN0UGx1Z2luLnBvc3Rjc3NQbHVnaW4pIHtcbiAgICAgICAgICAgICAgICBvcHRzLnBsdWdpbiA9IHRoaXMubGFzdFBsdWdpbi5wb3N0Y3NzUGx1Z2luO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB3YXJuaW5nMiA9IG5ldyBXYXJuaW5nJDEodGV4dCwgb3B0cyk7XG4gICAgICAgIHRoaXMubWVzc2FnZXMucHVzaCh3YXJuaW5nMik7XG4gICAgICAgIHJldHVybiB3YXJuaW5nMjtcbiAgICB9O1xuICAgIF9wcm90by53YXJuaW5ncyA9IGZ1bmN0aW9uIHdhcm5pbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlcy5maWx0ZXIoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIHJldHVybiBpMi50eXBlID09PSBcIndhcm5pbmdcIjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfY3JlYXRlX2NsYXNzKFJlc3VsdDIsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNvbnRlbnRcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBSZXN1bHQyO1xufSgpO1xudmFyIHJlc3VsdCA9IFJlc3VsdCQzO1xuUmVzdWx0JDMuZGVmYXVsdCA9IFJlc3VsdCQzO1xudmFyIFNJTkdMRV9RVU9URSA9IFwiJ1wiLmNoYXJDb2RlQXQoMCk7XG52YXIgRE9VQkxFX1FVT1RFID0gJ1wiJy5jaGFyQ29kZUF0KDApO1xudmFyIEJBQ0tTTEFTSCA9IFwiXFxcXFwiLmNoYXJDb2RlQXQoMCk7XG52YXIgU0xBU0ggPSBcIi9cIi5jaGFyQ29kZUF0KDApO1xudmFyIE5FV0xJTkUgPSBcIlxcblwiLmNoYXJDb2RlQXQoMCk7XG52YXIgU1BBQ0UgPSBcIiBcIi5jaGFyQ29kZUF0KDApO1xudmFyIEZFRUQgPSBcIlxcZlwiLmNoYXJDb2RlQXQoMCk7XG52YXIgVEFCID0gXCJcdFwiLmNoYXJDb2RlQXQoMCk7XG52YXIgQ1IgPSBcIlxcclwiLmNoYXJDb2RlQXQoMCk7XG52YXIgT1BFTl9TUVVBUkUgPSBcIltcIi5jaGFyQ29kZUF0KDApO1xudmFyIENMT1NFX1NRVUFSRSA9IFwiXVwiLmNoYXJDb2RlQXQoMCk7XG52YXIgT1BFTl9QQVJFTlRIRVNFUyA9IFwiKFwiLmNoYXJDb2RlQXQoMCk7XG52YXIgQ0xPU0VfUEFSRU5USEVTRVMgPSBcIilcIi5jaGFyQ29kZUF0KDApO1xudmFyIE9QRU5fQ1VSTFkgPSBcIntcIi5jaGFyQ29kZUF0KDApO1xudmFyIENMT1NFX0NVUkxZID0gXCJ9XCIuY2hhckNvZGVBdCgwKTtcbnZhciBTRU1JQ09MT04gPSBcIjtcIi5jaGFyQ29kZUF0KDApO1xudmFyIEFTVEVSSVNLID0gXCIqXCIuY2hhckNvZGVBdCgwKTtcbnZhciBDT0xPTiA9IFwiOlwiLmNoYXJDb2RlQXQoMCk7XG52YXIgQVQgPSBcIkBcIi5jaGFyQ29kZUF0KDApO1xudmFyIFJFX0FUX0VORCA9IC9bXFx0XFxuXFxmXFxyIFwiIycoKS87W1xcXFxcXF17fV0vZztcbnZhciBSRV9XT1JEX0VORCA9IC9bXFx0XFxuXFxmXFxyICFcIiMnKCk6O0BbXFxcXFxcXXt9XXxcXC8oPz1cXCopL2c7XG52YXIgUkVfQkFEX0JSQUNLRVQgPSAvLltcXHJcXG5cIicoL1xcXFxdLztcbnZhciBSRV9IRVhfRVNDQVBFID0gL1tcXGRhLWZdL2k7XG52YXIgdG9rZW5pemUgPSBmdW5jdGlvbiB0b2tlbml6ZXIyKGlucHV0Miwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgY3NzID0gaW5wdXQyLmNzcy52YWx1ZU9mKCk7XG4gICAgdmFyIGlnbm9yZSA9IG9wdGlvbnMuaWdub3JlRXJyb3JzO1xuICAgIHZhciBjb2RlLCBuZXh0LCBxdW90ZSwgY29udGVudCwgZXNjYXBlO1xuICAgIHZhciBlc2NhcGVkLCBlc2NhcGVQb3MsIHByZXYsIG4yLCBjdXJyZW50VG9rZW47XG4gICAgdmFyIGxlbmd0aCA9IGNzcy5sZW5ndGg7XG4gICAgdmFyIHBvcyA9IDA7XG4gICAgdmFyIGJ1ZmZlciA9IFtdO1xuICAgIHZhciByZXR1cm5lZCA9IFtdO1xuICAgIGZ1bmN0aW9uIHBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bmNsb3NlZCh3aGF0KSB7XG4gICAgICAgIHRocm93IGlucHV0Mi5lcnJvcihcIlVuY2xvc2VkIFwiICsgd2hhdCwgcG9zKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5kT2ZGaWxlKCkge1xuICAgICAgICByZXR1cm4gcmV0dXJuZWQubGVuZ3RoID09PSAwICYmIHBvcyA+PSBsZW5ndGg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5leHRUb2tlbihvcHRzKSB7XG4gICAgICAgIGlmIChyZXR1cm5lZC5sZW5ndGgpIHJldHVybiByZXR1cm5lZC5wb3AoKTtcbiAgICAgICAgaWYgKHBvcyA+PSBsZW5ndGgpIHJldHVybjtcbiAgICAgICAgdmFyIGlnbm9yZVVuY2xvc2VkID0gb3B0cyA/IG9wdHMuaWdub3JlVW5jbG9zZWQgOiBmYWxzZTtcbiAgICAgICAgY29kZSA9IGNzcy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIHN3aXRjaChjb2RlKXtcbiAgICAgICAgICAgIGNhc2UgTkVXTElORTpcbiAgICAgICAgICAgIGNhc2UgU1BBQ0U6XG4gICAgICAgICAgICBjYXNlIFRBQjpcbiAgICAgICAgICAgIGNhc2UgQ1I6XG4gICAgICAgICAgICBjYXNlIEZFRUQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY3NzLmNoYXJDb2RlQXQobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH13aGlsZSAoY29kZSA9PT0gU1BBQ0UgfHwgY29kZSA9PT0gTkVXTElORSB8fCBjb2RlID09PSBUQUIgfHwgY29kZSA9PT0gQ1IgfHwgY29kZSA9PT0gRkVFRCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3BhY2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzcy5zbGljZShwb3MsIG5leHQpXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IG5leHQgLSAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIE9QRU5fU1FVQVJFOlxuICAgICAgICAgICAgY2FzZSBDTE9TRV9TUVVBUkU6XG4gICAgICAgICAgICBjYXNlIE9QRU5fQ1VSTFk6XG4gICAgICAgICAgICBjYXNlIENMT1NFX0NVUkxZOlxuICAgICAgICAgICAgY2FzZSBDT0xPTjpcbiAgICAgICAgICAgIGNhc2UgU0VNSUNPTE9OOlxuICAgICAgICAgICAgY2FzZSBDTE9TRV9QQVJFTlRIRVNFUzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250cm9sQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xDaGFyLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbENoYXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBPUEVOX1BBUkVOVEhFU0VTOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldiA9IGJ1ZmZlci5sZW5ndGggPyBidWZmZXIucG9wKClbMV0gOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBuMiA9IGNzcy5jaGFyQ29kZUF0KHBvcyArIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldiA9PT0gXCJ1cmxcIiAmJiBuMiAhPT0gU0lOR0xFX1FVT1RFICYmIG4yICE9PSBET1VCTEVfUVVPVEUgJiYgbjIgIT09IFNQQUNFICYmIG4yICE9PSBORVdMSU5FICYmIG4yICE9PSBUQUIgJiYgbjIgIT09IEZFRUQgJiYgbjIgIT09IENSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gY3NzLmluZGV4T2YoXCIpXCIsIG5leHQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlnbm9yZSB8fCBpZ25vcmVVbmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5jbG9zZWQoXCJicmFja2V0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZVBvcyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUoY3NzLmNoYXJDb2RlQXQoZXNjYXBlUG9zIC0gMSkgPT09IEJBQ0tTTEFTSCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZVBvcyAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfXdoaWxlIChlc2NhcGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJyYWNrZXRzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBjc3MuaW5kZXhPZihcIilcIiwgcG9zICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT09IC0xIHx8IFJFX0JBRF9CUkFDS0VULnRlc3QoY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIihcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJyYWNrZXRzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFNJTkdMRV9RVU9URTpcbiAgICAgICAgICAgIGNhc2UgRE9VQkxFX1FVT1RFOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcXVvdGUgPSBjb2RlID09PSBTSU5HTEVfUVVPVEUgPyBcIidcIiA6ICdcIic7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBjc3MuaW5kZXhPZihxdW90ZSwgbmV4dCArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlnbm9yZSB8fCBpZ25vcmVVbmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gcG9zICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5jbG9zZWQoXCJzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlUG9zID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKGNzcy5jaGFyQ29kZUF0KGVzY2FwZVBvcyAtIDEpID09PSBCQUNLU0xBU0gpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZVBvcyAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfXdoaWxlIChlc2NhcGVkKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBBVDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFJFX0FUX0VORC5sYXN0SW5kZXggPSBwb3MgKyAxO1xuICAgICAgICAgICAgICAgICAgICBSRV9BVF9FTkQudGVzdChjc3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoUkVfQVRfRU5ELmxhc3RJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGNzcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IFJFX0FUX0VORC5sYXN0SW5kZXggLSAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYXQtd29yZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEJBQ0tTTEFTSDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKGNzcy5jaGFyQ29kZUF0KG5leHQgKyAxKSA9PT0gQkFDS1NMQVNIKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZSA9ICFlc2NhcGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNzcy5jaGFyQ29kZUF0KG5leHQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVzY2FwZSAmJiBjb2RlICE9PSBTTEFTSCAmJiBjb2RlICE9PSBTUEFDRSAmJiBjb2RlICE9PSBORVdMSU5FICYmIGNvZGUgIT09IFRBQiAmJiBjb2RlICE9PSBDUiAmJiBjb2RlICE9PSBGRUVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoUkVfSEVYX0VTQ0FQRS50ZXN0KGNzcy5jaGFyQXQobmV4dCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUoUkVfSEVYX0VTQ0FQRS50ZXN0KGNzcy5jaGFyQXQobmV4dCArIDEpKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNzcy5jaGFyQ29kZUF0KG5leHQgKyAxKSA9PT0gU1BBQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcIndvcmRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlID09PSBTTEFTSCAmJiBjc3MuY2hhckNvZGVBdChwb3MgKyAxKSA9PT0gQVNURVJJU0spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBjc3MuaW5kZXhPZihcIiovXCIsIHBvcyArIDIpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlnbm9yZSB8fCBpZ25vcmVVbmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gY3NzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmNsb3NlZChcImNvbW1lbnRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29tbWVudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBSRV9XT1JEX0VORC5sYXN0SW5kZXggPSBwb3MgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgUkVfV09SRF9FTkQudGVzdChjc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFJFX1dPUkRfRU5ELmxhc3RJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBjc3MubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IFJFX1dPUkRfRU5ELmxhc3RJbmRleCAtIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3b3JkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLnB1c2goY3VycmVudFRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBvcysrO1xuICAgICAgICByZXR1cm4gY3VycmVudFRva2VuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiYWNrKHRva2VuKSB7XG4gICAgICAgIHJldHVybmVkLnB1c2godG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBiYWNrOiBiYWNrLFxuICAgICAgICBlbmRPZkZpbGU6IGVuZE9mRmlsZSxcbiAgICAgICAgbmV4dFRva2VuOiBuZXh0VG9rZW4sXG4gICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICAgIH07XG59O1xudmFyIENvbnRhaW5lciQ1ID0gY29udGFpbmVyO1xudmFyIEF0UnVsZSQzID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihDb250YWluZXIkNSkge1xuICAgIF9pbmhlcml0cyhBdFJ1bGUyLCBDb250YWluZXIkNSk7XG4gICAgZnVuY3Rpb24gQXRSdWxlMihkZWZhdWx0cykge1xuICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgIF90aGlzID0gQ29udGFpbmVyJDUuY2FsbCh0aGlzLCBkZWZhdWx0cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9IFwiYXRydWxlXCI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IEF0UnVsZTIucHJvdG90eXBlO1xuICAgIF9wcm90by5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQoKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGNoaWxkcmVuID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBjaGlsZHJlbltfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX0NvbnRhaW5lciQ1X3Byb3RvdHlwZV9hcHBlbmQ7XG4gICAgICAgIGlmICghdGhpcy5wcm94eU9mLm5vZGVzKSB0aGlzLm5vZGVzID0gW107XG4gICAgICAgIHJldHVybiAoX0NvbnRhaW5lciQ1X3Byb3RvdHlwZV9hcHBlbmQgPSBDb250YWluZXIkNS5wcm90b3R5cGUuYXBwZW5kKS5jYWxsLmFwcGx5KF9Db250YWluZXIkNV9wcm90b3R5cGVfYXBwZW5kLCBbXS5jb25jYXQoW1xuICAgICAgICAgICAgdGhpc1xuICAgICAgICBdLCBjaGlsZHJlbikpO1xuICAgIH07XG4gICAgX3Byb3RvLnByZXBlbmQgPSBmdW5jdGlvbiBwcmVwZW5kKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBjaGlsZHJlbiA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgY2hpbGRyZW5bX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9Db250YWluZXIkNV9wcm90b3R5cGVfcHJlcGVuZDtcbiAgICAgICAgaWYgKCF0aGlzLnByb3h5T2Yubm9kZXMpIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIChfQ29udGFpbmVyJDVfcHJvdG90eXBlX3ByZXBlbmQgPSBDb250YWluZXIkNS5wcm90b3R5cGUucHJlcGVuZCkuY2FsbC5hcHBseShfQ29udGFpbmVyJDVfcHJvdG90eXBlX3ByZXBlbmQsIFtdLmNvbmNhdChbXG4gICAgICAgICAgICB0aGlzXG4gICAgICAgIF0sIGNoaWxkcmVuKSk7XG4gICAgfTtcbiAgICByZXR1cm4gQXRSdWxlMjtcbn0oQ29udGFpbmVyJDUpO1xudmFyIGF0UnVsZSA9IEF0UnVsZSQzO1xuQXRSdWxlJDMuZGVmYXVsdCA9IEF0UnVsZSQzO1xuQ29udGFpbmVyJDUucmVnaXN0ZXJBdFJ1bGUoQXRSdWxlJDMpO1xudmFyIENvbnRhaW5lciQ0ID0gY29udGFpbmVyO1xudmFyIExhenlSZXN1bHQkMywgUHJvY2Vzc29yJDI7XG52YXIgUm9vdCQ1ID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihDb250YWluZXIkNCkge1xuICAgIF9pbmhlcml0cyhSb290MiwgQ29udGFpbmVyJDQpO1xuICAgIGZ1bmN0aW9uIFJvb3QyKGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgX3RoaXMgPSBDb250YWluZXIkNC5jYWxsKHRoaXMsIGRlZmF1bHRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlID0gXCJyb290XCI7XG4gICAgICAgIGlmICghX3RoaXMubm9kZXMpIF90aGlzLm5vZGVzID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFJvb3QyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8ubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKGNoaWxkLCBzYW1wbGUsIHR5cGUpIHtcbiAgICAgICAgdmFyIG5vZGVzID0gQ29udGFpbmVyJDQucHJvdG90eXBlLm5vcm1hbGl6ZS5jYWxsKHRoaXMsIGNoaWxkKTtcbiAgICAgICAgaWYgKHNhbXBsZSkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwicHJlcGVuZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBzYW1wbGUucmF3cy5iZWZvcmUgPSB0aGlzLm5vZGVzWzFdLnJhd3MuYmVmb3JlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzYW1wbGUucmF3cy5iZWZvcmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZpcnN0ICE9PSBzYW1wbGUpIHtcbiAgICAgICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShub2RlcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUyLnJhd3MuYmVmb3JlID0gc2FtcGxlLnJhd3MuYmVmb3JlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiByZW1vdmVDaGlsZChjaGlsZCwgaWdub3JlKSB7XG4gICAgICAgIHZhciBpbmRleDIgPSB0aGlzLmluZGV4KGNoaWxkKTtcbiAgICAgICAgaWYgKCFpZ25vcmUgJiYgaW5kZXgyID09PSAwICYmIHRoaXMubm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhpcy5ub2Rlc1sxXS5yYXdzLmJlZm9yZSA9IHRoaXMubm9kZXNbaW5kZXgyXS5yYXdzLmJlZm9yZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ29udGFpbmVyJDQucHJvdG90eXBlLnJlbW92ZUNoaWxkLmNhbGwodGhpcywgY2hpbGQpO1xuICAgIH07XG4gICAgX3Byb3RvLnRvUmVzdWx0ID0gZnVuY3Rpb24gdG9SZXN1bHQob3B0cykge1xuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSBvcHRzID0ge307XG4gICAgICAgIHZhciBsYXp5ID0gbmV3IExhenlSZXN1bHQkMyhuZXcgUHJvY2Vzc29yJDIoKSwgdGhpcywgb3B0cyk7XG4gICAgICAgIHJldHVybiBsYXp5LnN0cmluZ2lmeSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFJvb3QyO1xufShDb250YWluZXIkNCk7XG5Sb290JDUucmVnaXN0ZXJMYXp5UmVzdWx0ID0gZnVuY3Rpb24oZGVwZW5kYW50KSB7XG4gICAgTGF6eVJlc3VsdCQzID0gZGVwZW5kYW50O1xufTtcblJvb3QkNS5yZWdpc3RlclByb2Nlc3NvciA9IGZ1bmN0aW9uKGRlcGVuZGFudCkge1xuICAgIFByb2Nlc3NvciQyID0gZGVwZW5kYW50O1xufTtcbnZhciByb290ID0gUm9vdCQ1O1xuUm9vdCQ1LmRlZmF1bHQgPSBSb290JDU7XG5Db250YWluZXIkNC5yZWdpc3RlclJvb3QoUm9vdCQ1KTtcbnZhciBsaXN0JDIgPSB7XG4gICAgY29tbWE6IGZ1bmN0aW9uIGNvbW1hKHN0cmluZykge1xuICAgICAgICByZXR1cm4gbGlzdCQyLnNwbGl0KHN0cmluZywgW1xuICAgICAgICAgICAgXCIsXCJcbiAgICAgICAgXSwgdHJ1ZSk7XG4gICAgfSxcbiAgICBzcGFjZTogZnVuY3Rpb24gc3BhY2Uoc3RyaW5nKSB7XG4gICAgICAgIHZhciBzcGFjZXMgPSBbXG4gICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgIFwiXFxuXCIsXG4gICAgICAgICAgICBcIlx0XCJcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIGxpc3QkMi5zcGxpdChzdHJpbmcsIHNwYWNlcyk7XG4gICAgfSxcbiAgICBzcGxpdDogZnVuY3Rpb24gc3BsaXQoc3RyaW5nLCBzZXBhcmF0b3JzLCBsYXN0KSB7XG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgICB2YXIgY3VycmVudCA9IFwiXCI7XG4gICAgICAgIHZhciBzcGxpdCA9IGZhbHNlO1xuICAgICAgICB2YXIgZnVuYyA9IDA7XG4gICAgICAgIHZhciBpblF1b3RlID0gZmFsc2U7XG4gICAgICAgIHZhciBwcmV2UXVvdGUgPSBcIlwiO1xuICAgICAgICB2YXIgZXNjYXBlID0gZmFsc2U7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHN0cmluZyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBsZXR0ZXIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgICAgICAgICBlc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgIGVzY2FwZSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluUXVvdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobGV0dGVyID09PSBwcmV2UXVvdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5RdW90ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSAnXCInIHx8IGxldHRlciA9PT0gXCInXCIpIHtcbiAgICAgICAgICAgICAgICBpblF1b3RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcmV2UXVvdGUgPSBsZXR0ZXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxldHRlciA9PT0gXCIoXCIpIHtcbiAgICAgICAgICAgICAgICBmdW5jICs9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxldHRlciA9PT0gXCIpXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnVuYyA+IDApIGZ1bmMgLT0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZnVuYyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChzZXBhcmF0b3JzLmluY2x1ZGVzKGxldHRlcikpIHNwbGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcGxpdCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBcIlwiKSBhcnJheS5wdXNoKGN1cnJlbnQudHJpbSgpKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBzcGxpdCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ICs9IGxldHRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdCB8fCBjdXJyZW50ICE9PSBcIlwiKSBhcnJheS5wdXNoKGN1cnJlbnQudHJpbSgpKTtcbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbn07XG52YXIgbGlzdF8xID0gbGlzdCQyO1xubGlzdCQyLmRlZmF1bHQgPSBsaXN0JDI7XG52YXIgQ29udGFpbmVyJDMgPSBjb250YWluZXI7XG52YXIgbGlzdCQxID0gbGlzdF8xO1xudmFyIFJ1bGUkMyA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oQ29udGFpbmVyJDMpIHtcbiAgICBfaW5oZXJpdHMoUnVsZTIsIENvbnRhaW5lciQzKTtcbiAgICBmdW5jdGlvbiBSdWxlMihkZWZhdWx0cykge1xuICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgIF90aGlzID0gQ29udGFpbmVyJDMuY2FsbCh0aGlzLCBkZWZhdWx0cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9IFwicnVsZVwiO1xuICAgICAgICBpZiAoIV90aGlzLm5vZGVzKSBfdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIF9jcmVhdGVfY2xhc3MoUnVsZTIsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInNlbGVjdG9yc1wiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3QkMS5jb21tYSh0aGlzLnNlbGVjdG9yKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSB0aGlzLnNlbGVjdG9yID8gdGhpcy5zZWxlY3Rvci5tYXRjaCgvLFxccyovKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIHNlcDIgPSBtYXRjaCA/IG1hdGNoWzBdIDogXCIsXCIgKyB0aGlzLnJhdyhcImJldHdlZW5cIiwgXCJiZWZvcmVPcGVuXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IgPSB2YWx1ZXMuam9pbihzZXAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBSdWxlMjtcbn0oQ29udGFpbmVyJDMpO1xudmFyIHJ1bGUgPSBSdWxlJDM7XG5SdWxlJDMuZGVmYXVsdCA9IFJ1bGUkMztcbkNvbnRhaW5lciQzLnJlZ2lzdGVyUnVsZShSdWxlJDMpO1xudmFyIERlY2xhcmF0aW9uJDIgPSBkZWNsYXJhdGlvbjtcbnZhciB0b2tlbml6ZXIyMiA9IHRva2VuaXplO1xudmFyIENvbW1lbnQkMiA9IGNvbW1lbnQ7XG52YXIgQXRSdWxlJDIgPSBhdFJ1bGU7XG52YXIgUm9vdCQ0ID0gcm9vdDtcbnZhciBSdWxlJDIgPSBydWxlO1xudmFyIFNBRkVfQ09NTUVOVF9ORUlHSEJPUiA9IHtcbiAgICBlbXB0eTogdHJ1ZSxcbiAgICBzcGFjZTogdHJ1ZVxufTtcbmZ1bmN0aW9uIGZpbmRMYXN0V2l0aFBvc2l0aW9uKHRva2Vucykge1xuICAgIGZvcih2YXIgaTIgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSl7XG4gICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpMl07XG4gICAgICAgIHZhciBwb3MgPSB0b2tlblszXSB8fCB0b2tlblsyXTtcbiAgICAgICAgaWYgKHBvcykgcmV0dXJuIHBvcztcbiAgICB9XG59XG52YXIgUGFyc2VyJDEgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFBhcnNlcjIoaW5wdXQyKSB7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDI7XG4gICAgICAgIHRoaXMucm9vdCA9IG5ldyBSb290JDQoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5yb290O1xuICAgICAgICB0aGlzLnNwYWNlcyA9IFwiXCI7XG4gICAgICAgIHRoaXMuc2VtaWNvbG9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3JlYXRlVG9rZW5pemVyKCk7XG4gICAgICAgIHRoaXMucm9vdC5zb3VyY2UgPSB7XG4gICAgICAgICAgICBpbnB1dDogaW5wdXQyLFxuICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IDEsXG4gICAgICAgICAgICAgICAgbGluZTogMSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFBhcnNlcjIucHJvdG90eXBlO1xuICAgIF9wcm90by5hdHJ1bGUgPSBmdW5jdGlvbiBhdHJ1bGUodG9rZW4pIHtcbiAgICAgICAgdmFyIG5vZGUyID0gbmV3IEF0UnVsZSQyKCk7XG4gICAgICAgIG5vZGUyLm5hbWUgPSB0b2tlblsxXS5zbGljZSgxKTtcbiAgICAgICAgaWYgKG5vZGUyLm5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHRoaXMudW5uYW1lZEF0cnVsZShub2RlMiwgdG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdChub2RlMiwgdG9rZW5bMl0pO1xuICAgICAgICB2YXIgdHlwZTtcbiAgICAgICAgdmFyIHByZXY7XG4gICAgICAgIHZhciBzaGlmdDtcbiAgICAgICAgdmFyIGxhc3QgPSBmYWxzZTtcbiAgICAgICAgdmFyIG9wZW4gPSBmYWxzZTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgICAgICB2YXIgYnJhY2tldHMgPSBbXTtcbiAgICAgICAgd2hpbGUoIXRoaXMudG9rZW5pemVyLmVuZE9mRmlsZSgpKXtcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy50b2tlbml6ZXIubmV4dFRva2VuKCk7XG4gICAgICAgICAgICB0eXBlID0gdG9rZW5bMF07XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCIoXCIgfHwgdHlwZSA9PT0gXCJbXCIpIHtcbiAgICAgICAgICAgICAgICBicmFja2V0cy5wdXNoKHR5cGUgPT09IFwiKFwiID8gXCIpXCIgOiBcIl1cIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwie1wiICYmIGJyYWNrZXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBicmFja2V0cy5wdXNoKFwifVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gYnJhY2tldHNbYnJhY2tldHMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgICAgICBicmFja2V0cy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChicmFja2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCI7XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTIuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5bMl0pO1xuICAgICAgICAgICAgICAgICAgICBub2RlMi5zb3VyY2UuZW5kLm9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbWljb2xvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IHBhcmFtcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldiA9IHBhcmFtc1tzaGlmdF07XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZShwcmV2ICYmIHByZXZbMF0gPT09IFwic3BhY2VcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldiA9IHBhcmFtc1stLXNoaWZ0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTIuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24ocHJldlszXSB8fCBwcmV2WzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlMi5zb3VyY2UuZW5kLm9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudG9rZW5pemVyLmVuZE9mRmlsZSgpKSB7XG4gICAgICAgICAgICAgICAgbGFzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuID0gdGhpcy5zcGFjZXNBbmRDb21tZW50c0Zyb21FbmQocGFyYW1zKTtcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG5vZGUyLnJhd3MuYWZ0ZXJOYW1lID0gdGhpcy5zcGFjZXNBbmRDb21tZW50c0Zyb21TdGFydChwYXJhbXMpO1xuICAgICAgICAgICAgdGhpcy5yYXcobm9kZTIsIFwicGFyYW1zXCIsIHBhcmFtcyk7XG4gICAgICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgICAgIHRva2VuID0gcGFyYW1zW3BhcmFtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBub2RlMi5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbih0b2tlblszXSB8fCB0b2tlblsyXSk7XG4gICAgICAgICAgICAgICAgbm9kZTIuc291cmNlLmVuZC5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICB0aGlzLnNwYWNlcyA9IG5vZGUyLnJhd3MuYmV0d2VlbjtcbiAgICAgICAgICAgICAgICBub2RlMi5yYXdzLmJldHdlZW4gPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZTIucmF3cy5hZnRlck5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgbm9kZTIucGFyYW1zID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgbm9kZTIubm9kZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IG5vZGUyO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uY2hlY2tNaXNzZWRTZW1pY29sb24gPSBmdW5jdGlvbiBjaGVja01pc3NlZFNlbWljb2xvbih0b2tlbnMpIHtcbiAgICAgICAgdmFyIGNvbG9uID0gdGhpcy5jb2xvbih0b2tlbnMpO1xuICAgICAgICBpZiAoY29sb24gPT09IGZhbHNlKSByZXR1cm47XG4gICAgICAgIHZhciBmb3VuZGVkID0gMDtcbiAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICBmb3IodmFyIGogPSBjb2xvbiAtIDE7IGogPj0gMDsgai0tKXtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2pdO1xuICAgICAgICAgICAgaWYgKHRva2VuWzBdICE9PSBcInNwYWNlXCIpIHtcbiAgICAgICAgICAgICAgICBmb3VuZGVkICs9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kZWQgPT09IDIpIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXCJNaXNzZWQgc2VtaWNvbG9uXCIsIHRva2VuWzBdID09PSBcIndvcmRcIiA/IHRva2VuWzNdICsgMSA6IHRva2VuWzJdKTtcbiAgICB9O1xuICAgIF9wcm90by5jb2xvbiA9IGZ1bmN0aW9uIGNvbG9uKHRva2Vucykge1xuICAgICAgICB2YXIgYnJhY2tldHMgPSAwO1xuICAgICAgICB2YXIgdG9rZW4sIHR5cGUsIHByZXY7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHRva2Vucy5lbnRyaWVzKCkpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgX3N0ZXBfdmFsdWUgPSBfc3RlcC52YWx1ZSwgaTIgPSBfc3RlcF92YWx1ZVswXSwgZWxlbWVudCA9IF9zdGVwX3ZhbHVlWzFdO1xuICAgICAgICAgICAgdG9rZW4gPSBlbGVtZW50O1xuICAgICAgICAgICAgdHlwZSA9IHRva2VuWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiKFwiKSB7XG4gICAgICAgICAgICAgICAgYnJhY2tldHMgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcIilcIikge1xuICAgICAgICAgICAgICAgIGJyYWNrZXRzIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnJhY2tldHMgPT09IDAgJiYgdHlwZSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb3VibGVDb2xvbih0b2tlbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2WzBdID09PSBcIndvcmRcIiAmJiBwcmV2WzFdID09PSBcInByb2dpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2ID0gdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgX3Byb3RvLmNvbW1lbnQgPSBmdW5jdGlvbiBjb21tZW50KHRva2VuKSB7XG4gICAgICAgIHZhciBub2RlMiA9IG5ldyBDb21tZW50JDIoKTtcbiAgICAgICAgdGhpcy5pbml0KG5vZGUyLCB0b2tlblsyXSk7XG4gICAgICAgIG5vZGUyLnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKHRva2VuWzNdIHx8IHRva2VuWzJdKTtcbiAgICAgICAgbm9kZTIuc291cmNlLmVuZC5vZmZzZXQrKztcbiAgICAgICAgdmFyIHRleHQgPSB0b2tlblsxXS5zbGljZSgyLCAtMik7XG4gICAgICAgIGlmICgvXlxccyokLy50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICBub2RlMi50ZXh0ID0gXCJcIjtcbiAgICAgICAgICAgIG5vZGUyLnJhd3MubGVmdCA9IHRleHQ7XG4gICAgICAgICAgICBub2RlMi5yYXdzLnJpZ2h0ID0gXCJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IHRleHQubWF0Y2goL14oXFxzKikoW15dKlxcUykoXFxzKikkLyk7XG4gICAgICAgICAgICBub2RlMi50ZXh0ID0gbWF0Y2hbMl07XG4gICAgICAgICAgICBub2RlMi5yYXdzLmxlZnQgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIG5vZGUyLnJhd3MucmlnaHQgPSBtYXRjaFszXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmNyZWF0ZVRva2VuaXplciA9IGZ1bmN0aW9uIGNyZWF0ZVRva2VuaXplcigpIHtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIgPSB0b2tlbml6ZXIyMih0aGlzLmlucHV0KTtcbiAgICB9O1xuICAgIF9wcm90by5kZWNsID0gZnVuY3Rpb24gZGVjbCh0b2tlbnMsIGN1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgIHZhciBub2RlMiA9IG5ldyBEZWNsYXJhdGlvbiQyKCk7XG4gICAgICAgIHRoaXMuaW5pdChub2RlMiwgdG9rZW5zWzBdWzJdKTtcbiAgICAgICAgdmFyIGxhc3QgPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdFswXSA9PT0gXCI7XCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2VtaWNvbG9uID0gdHJ1ZTtcbiAgICAgICAgICAgIHRva2Vucy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlMi5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbihsYXN0WzNdIHx8IGxhc3RbMl0gfHwgZmluZExhc3RXaXRoUG9zaXRpb24odG9rZW5zKSk7XG4gICAgICAgIG5vZGUyLnNvdXJjZS5lbmQub2Zmc2V0Kys7XG4gICAgICAgIHdoaWxlKHRva2Vuc1swXVswXSAhPT0gXCJ3b3JkXCIpe1xuICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDEpIHRoaXMudW5rbm93bldvcmQodG9rZW5zKTtcbiAgICAgICAgICAgIG5vZGUyLnJhd3MuYmVmb3JlICs9IHRva2Vucy5zaGlmdCgpWzFdO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUyLnNvdXJjZS5zdGFydCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5zWzBdWzJdKTtcbiAgICAgICAgbm9kZTIucHJvcCA9IFwiXCI7XG4gICAgICAgIHdoaWxlKHRva2Vucy5sZW5ndGgpe1xuICAgICAgICAgICAgdmFyIHR5cGUgPSB0b2tlbnNbMF1bMF07XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCI6XCIgfHwgdHlwZSA9PT0gXCJzcGFjZVwiIHx8IHR5cGUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlMi5wcm9wICs9IHRva2Vucy5zaGlmdCgpWzFdO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUyLnJhd3MuYmV0d2VlbiA9IFwiXCI7XG4gICAgICAgIHZhciB0b2tlbjtcbiAgICAgICAgd2hpbGUodG9rZW5zLmxlbmd0aCl7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vucy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKHRva2VuWzBdID09PSBcIjpcIikge1xuICAgICAgICAgICAgICAgIG5vZGUyLnJhd3MuYmV0d2VlbiArPSB0b2tlblsxXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuWzBdID09PSBcIndvcmRcIiAmJiAvXFx3Ly50ZXN0KHRva2VuWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVua25vd25Xb3JkKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlMi5yYXdzLmJldHdlZW4gKz0gdG9rZW5bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUyLnByb3BbMF0gPT09IFwiX1wiIHx8IG5vZGUyLnByb3BbMF0gPT09IFwiKlwiKSB7XG4gICAgICAgICAgICBub2RlMi5yYXdzLmJlZm9yZSArPSBub2RlMi5wcm9wWzBdO1xuICAgICAgICAgICAgbm9kZTIucHJvcCA9IG5vZGUyLnByb3Auc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpcnN0U3BhY2VzID0gW107XG4gICAgICAgIHZhciBuZXh0O1xuICAgICAgICB3aGlsZSh0b2tlbnMubGVuZ3RoKXtcbiAgICAgICAgICAgIG5leHQgPSB0b2tlbnNbMF1bMF07XG4gICAgICAgICAgICBpZiAobmV4dCAhPT0gXCJzcGFjZVwiICYmIG5leHQgIT09IFwiY29tbWVudFwiKSBicmVhaztcbiAgICAgICAgICAgIGZpcnN0U3BhY2VzLnB1c2godG9rZW5zLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlY2hlY2tNaXNzZWRTZW1pY29sb24odG9rZW5zKTtcbiAgICAgICAgZm9yKHZhciBpMiA9IHRva2Vucy5sZW5ndGggLSAxOyBpMiA+PSAwOyBpMi0tKXtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2kyXTtcbiAgICAgICAgICAgIGlmICh0b2tlblsxXS50b0xvd2VyQ2FzZSgpID09PSBcIiFpbXBvcnRhbnRcIikge1xuICAgICAgICAgICAgICAgIG5vZGUyLmltcG9ydGFudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIHN0cmluZyA9IHRoaXMuc3RyaW5nRnJvbSh0b2tlbnMsIGkyKTtcbiAgICAgICAgICAgICAgICBzdHJpbmcgPSB0aGlzLnNwYWNlc0Zyb21FbmQodG9rZW5zKSArIHN0cmluZztcbiAgICAgICAgICAgICAgICBpZiAoc3RyaW5nICE9PSBcIiAhaW1wb3J0YW50XCIpIG5vZGUyLnJhd3MuaW1wb3J0YW50ID0gc3RyaW5nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlblsxXS50b0xvd2VyQ2FzZSgpID09PSBcImltcG9ydGFudFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlID0gdG9rZW5zLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgIHZhciBzdHIgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaiA9IGkyOyBqID4gMDsgai0tKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUxID0gY2FjaGVbal1bMF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHIudHJpbSgpLmluZGV4T2YoXCIhXCIpID09PSAwICYmIHR5cGUxICE9PSBcInNwYWNlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IGNhY2hlLnBvcCgpWzFdICsgc3RyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RyLnRyaW0oKS5pbmRleE9mKFwiIVwiKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlMi5pbXBvcnRhbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBub2RlMi5yYXdzLmltcG9ydGFudCA9IHN0cjtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zID0gY2FjaGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2VuWzBdICE9PSBcInNwYWNlXCIgJiYgdG9rZW5bMF0gIT09IFwiY29tbWVudFwiKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhhc1dvcmQgPSB0b2tlbnMuc29tZShmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgcmV0dXJuIGkyWzBdICE9PSBcInNwYWNlXCIgJiYgaTJbMF0gIT09IFwiY29tbWVudFwiO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGhhc1dvcmQpIHtcbiAgICAgICAgICAgIG5vZGUyLnJhd3MuYmV0d2VlbiArPSBmaXJzdFNwYWNlcy5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTJbMV07XG4gICAgICAgICAgICB9KS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgZmlyc3RTcGFjZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJhdyhub2RlMiwgXCJ2YWx1ZVwiLCBmaXJzdFNwYWNlcy5jb25jYXQodG9rZW5zKSwgY3VzdG9tUHJvcGVydHkpO1xuICAgICAgICBpZiAobm9kZTIudmFsdWUuaW5jbHVkZXMoXCI6XCIpICYmICFjdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5jaGVja01pc3NlZFNlbWljb2xvbih0b2tlbnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZG91YmxlQ29sb24gPSBmdW5jdGlvbiBkb3VibGVDb2xvbih0b2tlbikge1xuICAgICAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFwiRG91YmxlIGNvbG9uXCIsIHtcbiAgICAgICAgICAgIG9mZnNldDogdG9rZW5bMl1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgb2Zmc2V0OiB0b2tlblsyXSArIHRva2VuWzFdLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5lbXB0eVJ1bGUgPSBmdW5jdGlvbiBlbXB0eVJ1bGUodG9rZW4pIHtcbiAgICAgICAgdmFyIG5vZGUyID0gbmV3IFJ1bGUkMigpO1xuICAgICAgICB0aGlzLmluaXQobm9kZTIsIHRva2VuWzJdKTtcbiAgICAgICAgbm9kZTIuc2VsZWN0b3IgPSBcIlwiO1xuICAgICAgICBub2RlMi5yYXdzLmJldHdlZW4gPSBcIlwiO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBub2RlMjtcbiAgICB9O1xuICAgIF9wcm90by5lbmQgPSBmdW5jdGlvbiBlbmQodG9rZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudC5ub2RlcyAmJiB0aGlzLmN1cnJlbnQubm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQucmF3cy5zZW1pY29sb24gPSB0aGlzLnNlbWljb2xvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbWljb2xvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1cnJlbnQucmF3cy5hZnRlciA9ICh0aGlzLmN1cnJlbnQucmF3cy5hZnRlciB8fCBcIlwiKSArIHRoaXMuc3BhY2VzO1xuICAgICAgICB0aGlzLnNwYWNlcyA9IFwiXCI7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5bMl0pO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50LnNvdXJjZS5lbmQub2Zmc2V0Kys7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmN1cnJlbnQucGFyZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51bmV4cGVjdGVkQ2xvc2UodG9rZW4pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZW5kRmlsZSA9IGZ1bmN0aW9uIGVuZEZpbGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQucGFyZW50KSB0aGlzLnVuY2xvc2VkQmxvY2soKTtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudC5ub2RlcyAmJiB0aGlzLmN1cnJlbnQubm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQucmF3cy5zZW1pY29sb24gPSB0aGlzLnNlbWljb2xvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnQucmF3cy5hZnRlciA9ICh0aGlzLmN1cnJlbnQucmF3cy5hZnRlciB8fCBcIlwiKSArIHRoaXMuc3BhY2VzO1xuICAgICAgICB0aGlzLnJvb3Quc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odGhpcy50b2tlbml6ZXIucG9zaXRpb24oKSk7XG4gICAgfTtcbiAgICBfcHJvdG8uZnJlZVNlbWljb2xvbiA9IGZ1bmN0aW9uIGZyZWVTZW1pY29sb24odG9rZW4pIHtcbiAgICAgICAgdGhpcy5zcGFjZXMgKz0gdG9rZW5bMV07XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQubm9kZXMpIHtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gdGhpcy5jdXJyZW50Lm5vZGVzW3RoaXMuY3VycmVudC5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChwcmV2ICYmIHByZXYudHlwZSA9PT0gXCJydWxlXCIgJiYgIXByZXYucmF3cy5vd25TZW1pY29sb24pIHtcbiAgICAgICAgICAgICAgICBwcmV2LnJhd3Mub3duU2VtaWNvbG9uID0gdGhpcy5zcGFjZXM7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGFjZXMgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBIZWxwZXJzXG4gICAgX3Byb3RvLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gZ2V0UG9zaXRpb24ob2Zmc2V0KSB7XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLmlucHV0LmZyb21PZmZzZXQob2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbHVtbjogcG9zLmNvbCxcbiAgICAgICAgICAgIGxpbmU6IHBvcy5saW5lLFxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXRcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdChub2RlMiwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuY3VycmVudC5wdXNoKG5vZGUyKTtcbiAgICAgICAgbm9kZTIuc291cmNlID0ge1xuICAgICAgICAgICAgaW5wdXQ6IHRoaXMuaW5wdXQsXG4gICAgICAgICAgICBzdGFydDogdGhpcy5nZXRQb3NpdGlvbihvZmZzZXQpXG4gICAgICAgIH07XG4gICAgICAgIG5vZGUyLnJhd3MuYmVmb3JlID0gdGhpcy5zcGFjZXM7XG4gICAgICAgIHRoaXMuc3BhY2VzID0gXCJcIjtcbiAgICAgICAgaWYgKG5vZGUyLnR5cGUgIT09IFwiY29tbWVudFwiKSB0aGlzLnNlbWljb2xvbiA9IGZhbHNlO1xuICAgIH07XG4gICAgX3Byb3RvLm90aGVyID0gZnVuY3Rpb24gb3RoZXIoc3RhcnQpIHtcbiAgICAgICAgdmFyIGVuZCA9IGZhbHNlO1xuICAgICAgICB2YXIgdHlwZSA9IG51bGw7XG4gICAgICAgIHZhciBjb2xvbiA9IGZhbHNlO1xuICAgICAgICB2YXIgYnJhY2tldCA9IG51bGw7XG4gICAgICAgIHZhciBicmFja2V0cyA9IFtdO1xuICAgICAgICB2YXIgY3VzdG9tUHJvcGVydHkgPSBzdGFydFsxXS5zdGFydHNXaXRoKFwiLS1cIik7XG4gICAgICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICAgICAgdmFyIHRva2VuID0gc3RhcnQ7XG4gICAgICAgIHdoaWxlKHRva2VuKXtcbiAgICAgICAgICAgIHR5cGUgPSB0b2tlblswXTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcIihcIiB8fCB0eXBlID09PSBcIltcIikge1xuICAgICAgICAgICAgICAgIGlmICghYnJhY2tldCkgYnJhY2tldCA9IHRva2VuO1xuICAgICAgICAgICAgICAgIGJyYWNrZXRzLnB1c2godHlwZSA9PT0gXCIoXCIgPyBcIilcIiA6IFwiXVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VzdG9tUHJvcGVydHkgJiYgY29sb24gJiYgdHlwZSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJyYWNrZXQpIGJyYWNrZXQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBicmFja2V0cy5wdXNoKFwifVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYnJhY2tldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiO1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWNsKHRva2VucywgY3VzdG9tUHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwie1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVsZSh0b2tlbnMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRva2VuaXplci5iYWNrKHRva2Vucy5wb3AoKSk7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gYnJhY2tldHNbYnJhY2tldHMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgICAgICBicmFja2V0cy5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAoYnJhY2tldHMubGVuZ3RoID09PSAwKSBicmFja2V0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2VuID0gdGhpcy50b2tlbml6ZXIubmV4dFRva2VuKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudG9rZW5pemVyLmVuZE9mRmlsZSgpKSBlbmQgPSB0cnVlO1xuICAgICAgICBpZiAoYnJhY2tldHMubGVuZ3RoID4gMCkgdGhpcy51bmNsb3NlZEJyYWNrZXQoYnJhY2tldCk7XG4gICAgICAgIGlmIChlbmQgJiYgY29sb24pIHtcbiAgICAgICAgICAgIGlmICghY3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSh0b2tlbnMubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IFwic3BhY2VcIiAmJiB0b2tlbiAhPT0gXCJjb21tZW50XCIpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRva2VuaXplci5iYWNrKHRva2Vucy5wb3AoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kZWNsKHRva2VucywgY3VzdG9tUHJvcGVydHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51bmtub3duV29yZCh0b2tlbnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSgpIHtcbiAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICB3aGlsZSghdGhpcy50b2tlbml6ZXIuZW5kT2ZGaWxlKCkpe1xuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRva2VuaXplci5uZXh0VG9rZW4oKTtcbiAgICAgICAgICAgIHN3aXRjaCh0b2tlblswXSl7XG4gICAgICAgICAgICAgICAgY2FzZSBcInNwYWNlXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BhY2VzICs9IHRva2VuWzFdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiO1wiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyZWVTZW1pY29sb24odG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwifVwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb21tZW50XCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWVudCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJhdC13b3JkXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXRydWxlKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIntcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbXB0eVJ1bGUodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm90aGVyKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbmRGaWxlKCk7XG4gICAgfTtcbiAgICBfcHJvdG8ucHJlY2hlY2tNaXNzZWRTZW1pY29sb24gPSBmdW5jdGlvbiBwcmVjaGVja01pc3NlZFNlbWljb2xvbigpIHt9O1xuICAgIF9wcm90by5yYXcgPSBmdW5jdGlvbiByYXcobm9kZTIsIHByb3AsIHRva2VucywgY3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgdmFyIHRva2VuLCB0eXBlO1xuICAgICAgICB2YXIgbGVuZ3RoID0gdG9rZW5zLmxlbmd0aDtcbiAgICAgICAgdmFyIHZhbHVlID0gXCJcIjtcbiAgICAgICAgdmFyIGNsZWFuID0gdHJ1ZTtcbiAgICAgICAgdmFyIG5leHQsIHByZXY7XG4gICAgICAgIGZvcih2YXIgaTIgPSAwOyBpMiA8IGxlbmd0aDsgaTIgKz0gMSl7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpMl07XG4gICAgICAgICAgICB0eXBlID0gdG9rZW5bMF07XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJzcGFjZVwiICYmIGkyID09PSBsZW5ndGggLSAxICYmICFjdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgICAgICAgICAgICAgcHJldiA9IHRva2Vuc1tpMiAtIDFdID8gdG9rZW5zW2kyIC0gMV1bMF0gOiBcImVtcHR5XCI7XG4gICAgICAgICAgICAgICAgbmV4dCA9IHRva2Vuc1tpMiArIDFdID8gdG9rZW5zW2kyICsgMV1bMF0gOiBcImVtcHR5XCI7XG4gICAgICAgICAgICAgICAgaWYgKCFTQUZFX0NPTU1FTlRfTkVJR0hCT1JbcHJldl0gJiYgIVNBRkVfQ09NTUVOVF9ORUlHSEJPUltuZXh0XSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuc2xpY2UoLTEpID09PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHRva2VuWzFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlICs9IHRva2VuWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghY2xlYW4pIHtcbiAgICAgICAgICAgIHZhciByYXcgPSB0b2tlbnMucmVkdWNlKGZ1bmN0aW9uKGFsbCwgaTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxsICsgaTJbMV07XG4gICAgICAgICAgICB9LCBcIlwiKTtcbiAgICAgICAgICAgIG5vZGUyLnJhd3NbcHJvcF0gPSB7XG4gICAgICAgICAgICAgICAgcmF3OiByYXcsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIG5vZGUyW3Byb3BdID0gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8ucnVsZSA9IGZ1bmN0aW9uIHJ1bGUodG9rZW5zKSB7XG4gICAgICAgIHRva2Vucy5wb3AoKTtcbiAgICAgICAgdmFyIG5vZGUyID0gbmV3IFJ1bGUkMigpO1xuICAgICAgICB0aGlzLmluaXQobm9kZTIsIHRva2Vuc1swXVsyXSk7XG4gICAgICAgIG5vZGUyLnJhd3MuYmV0d2VlbiA9IHRoaXMuc3BhY2VzQW5kQ29tbWVudHNGcm9tRW5kKHRva2Vucyk7XG4gICAgICAgIHRoaXMucmF3KG5vZGUyLCBcInNlbGVjdG9yXCIsIHRva2Vucyk7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IG5vZGUyO1xuICAgIH07XG4gICAgX3Byb3RvLnNwYWNlc0FuZENvbW1lbnRzRnJvbUVuZCA9IGZ1bmN0aW9uIHNwYWNlc0FuZENvbW1lbnRzRnJvbUVuZCh0b2tlbnMpIHtcbiAgICAgICAgdmFyIGxhc3RUb2tlblR5cGU7XG4gICAgICAgIHZhciBzcGFjZXMgPSBcIlwiO1xuICAgICAgICB3aGlsZSh0b2tlbnMubGVuZ3RoKXtcbiAgICAgICAgICAgIGxhc3RUb2tlblR5cGUgPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdWzBdO1xuICAgICAgICAgICAgaWYgKGxhc3RUb2tlblR5cGUgIT09IFwic3BhY2VcIiAmJiBsYXN0VG9rZW5UeXBlICE9PSBcImNvbW1lbnRcIikgYnJlYWs7XG4gICAgICAgICAgICBzcGFjZXMgPSB0b2tlbnMucG9wKClbMV0gKyBzcGFjZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwYWNlcztcbiAgICB9O1xuICAgIC8vIEVycm9yc1xuICAgIF9wcm90by5zcGFjZXNBbmRDb21tZW50c0Zyb21TdGFydCA9IGZ1bmN0aW9uIHNwYWNlc0FuZENvbW1lbnRzRnJvbVN0YXJ0KHRva2Vucykge1xuICAgICAgICB2YXIgbmV4dDtcbiAgICAgICAgdmFyIHNwYWNlcyA9IFwiXCI7XG4gICAgICAgIHdoaWxlKHRva2Vucy5sZW5ndGgpe1xuICAgICAgICAgICAgbmV4dCA9IHRva2Vuc1swXVswXTtcbiAgICAgICAgICAgIGlmIChuZXh0ICE9PSBcInNwYWNlXCIgJiYgbmV4dCAhPT0gXCJjb21tZW50XCIpIGJyZWFrO1xuICAgICAgICAgICAgc3BhY2VzICs9IHRva2Vucy5zaGlmdCgpWzFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFjZXM7XG4gICAgfTtcbiAgICBfcHJvdG8uc3BhY2VzRnJvbUVuZCA9IGZ1bmN0aW9uIHNwYWNlc0Zyb21FbmQodG9rZW5zKSB7XG4gICAgICAgIHZhciBsYXN0VG9rZW5UeXBlO1xuICAgICAgICB2YXIgc3BhY2VzID0gXCJcIjtcbiAgICAgICAgd2hpbGUodG9rZW5zLmxlbmd0aCl7XG4gICAgICAgICAgICBsYXN0VG9rZW5UeXBlID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXVswXTtcbiAgICAgICAgICAgIGlmIChsYXN0VG9rZW5UeXBlICE9PSBcInNwYWNlXCIpIGJyZWFrO1xuICAgICAgICAgICAgc3BhY2VzID0gdG9rZW5zLnBvcCgpWzFdICsgc3BhY2VzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFjZXM7XG4gICAgfTtcbiAgICBfcHJvdG8uc3RyaW5nRnJvbSA9IGZ1bmN0aW9uIHN0cmluZ0Zyb20odG9rZW5zLCBmcm9tKSB7XG4gICAgICAgIHZhciByZXN1bHQyID0gXCJcIjtcbiAgICAgICAgZm9yKHZhciBpMiA9IGZyb207IGkyIDwgdG9rZW5zLmxlbmd0aDsgaTIrKyl7XG4gICAgICAgICAgICByZXN1bHQyICs9IHRva2Vuc1tpMl1bMV07XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5zLnNwbGljZShmcm9tLCB0b2tlbnMubGVuZ3RoIC0gZnJvbSk7XG4gICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgIH07XG4gICAgX3Byb3RvLnVuY2xvc2VkQmxvY2sgPSBmdW5jdGlvbiB1bmNsb3NlZEJsb2NrKCkge1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5jdXJyZW50LnNvdXJjZS5zdGFydDtcbiAgICAgICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcIlVuY2xvc2VkIGJsb2NrXCIsIHBvcy5saW5lLCBwb3MuY29sdW1uKTtcbiAgICB9O1xuICAgIF9wcm90by51bmNsb3NlZEJyYWNrZXQgPSBmdW5jdGlvbiB1bmNsb3NlZEJyYWNrZXQoYnJhY2tldCkge1xuICAgICAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFwiVW5jbG9zZWQgYnJhY2tldFwiLCB7XG4gICAgICAgICAgICBvZmZzZXQ6IGJyYWNrZXRbMl1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgb2Zmc2V0OiBicmFja2V0WzJdICsgMVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by51bmV4cGVjdGVkQ2xvc2UgPSBmdW5jdGlvbiB1bmV4cGVjdGVkQ2xvc2UodG9rZW4pIHtcbiAgICAgICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcIlVuZXhwZWN0ZWQgfVwiLCB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRva2VuWzJdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG9mZnNldDogdG9rZW5bMl0gKyAxXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLnVua25vd25Xb3JkID0gZnVuY3Rpb24gdW5rbm93bldvcmQodG9rZW5zKSB7XG4gICAgICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXCJVbmtub3duIHdvcmRcIiwge1xuICAgICAgICAgICAgb2Zmc2V0OiB0b2tlbnNbMF1bMl1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgb2Zmc2V0OiB0b2tlbnNbMF1bMl0gKyB0b2tlbnNbMF1bMV0ubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLnVubmFtZWRBdHJ1bGUgPSBmdW5jdGlvbiB1bm5hbWVkQXRydWxlKG5vZGUyLCB0b2tlbikge1xuICAgICAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFwiQXQtcnVsZSB3aXRob3V0IG5hbWVcIiwge1xuICAgICAgICAgICAgb2Zmc2V0OiB0b2tlblsyXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRva2VuWzJdICsgdG9rZW5bMV0ubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFBhcnNlcjI7XG59KCk7XG52YXIgcGFyc2VyID0gUGFyc2VyJDE7XG52YXIgQ29udGFpbmVyJDIgPSBjb250YWluZXI7XG52YXIgUGFyc2VyMjIgPSBwYXJzZXI7XG52YXIgSW5wdXQkMiA9IGlucHV0O1xuZnVuY3Rpb24gcGFyc2UkMyhjc3MsIG9wdHMpIHtcbiAgICB2YXIgaW5wdXQyID0gbmV3IElucHV0JDIoY3NzLCBvcHRzKTtcbiAgICB2YXIgcGFyc2VyMiA9IG5ldyBQYXJzZXIyMihpbnB1dDIpO1xuICAgIHRyeSB7XG4gICAgICAgIHBhcnNlcjIucGFyc2UoKTtcbiAgICB9IGNhdGNoIChlMikge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAoZTIubmFtZSA9PT0gXCJDc3NTeW50YXhFcnJvclwiICYmIG9wdHMgJiYgb3B0cy5mcm9tKSB7XG4gICAgICAgICAgICAgICAgaWYgKC9cXC5zY3NzJC9pLnRlc3Qob3B0cy5mcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICBlMi5tZXNzYWdlICs9IFwiXFxuWW91IHRyaWVkIHRvIHBhcnNlIFNDU1Mgd2l0aCB0aGUgc3RhbmRhcmQgQ1NTIHBhcnNlcjsgdHJ5IGFnYWluIHdpdGggdGhlIHBvc3Rjc3Mtc2NzcyBwYXJzZXJcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKC9cXC5zYXNzL2kudGVzdChvcHRzLmZyb20pKSB7XG4gICAgICAgICAgICAgICAgICAgIGUyLm1lc3NhZ2UgKz0gXCJcXG5Zb3UgdHJpZWQgdG8gcGFyc2UgU2FzcyB3aXRoIHRoZSBzdGFuZGFyZCBDU1MgcGFyc2VyOyB0cnkgYWdhaW4gd2l0aCB0aGUgcG9zdGNzcy1zYXNzIHBhcnNlclwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoL1xcLmxlc3MkL2kudGVzdChvcHRzLmZyb20pKSB7XG4gICAgICAgICAgICAgICAgICAgIGUyLm1lc3NhZ2UgKz0gXCJcXG5Zb3UgdHJpZWQgdG8gcGFyc2UgTGVzcyB3aXRoIHRoZSBzdGFuZGFyZCBDU1MgcGFyc2VyOyB0cnkgYWdhaW4gd2l0aCB0aGUgcG9zdGNzcy1sZXNzIHBhcnNlclwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlMjtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlcjIucm9vdDtcbn1cbnZhciBwYXJzZV8xID0gcGFyc2UkMztcbnBhcnNlJDMuZGVmYXVsdCA9IHBhcnNlJDM7XG5Db250YWluZXIkMi5yZWdpc3RlclBhcnNlKHBhcnNlJDMpO1xudmFyIGlzQ2xlYW4gPSBzeW1ib2xzLmlzQ2xlYW4sIG15ID0gc3ltYm9scy5teTtcbnZhciBNYXBHZW5lcmF0b3IkMSA9IG1hcEdlbmVyYXRvcjtcbnZhciBzdHJpbmdpZnkkMiA9IHN0cmluZ2lmeV8xO1xudmFyIENvbnRhaW5lciQxID0gY29udGFpbmVyO1xudmFyIERvY3VtZW50JDIgPSBkb2N1bWVudCQxJDI7XG52YXIgd2Fybk9uY2UkMSA9IHdhcm5PbmNlJDI7XG52YXIgUmVzdWx0JDIgPSByZXN1bHQ7XG52YXIgcGFyc2UkMiA9IHBhcnNlXzE7XG52YXIgUm9vdCQzID0gcm9vdDtcbnZhciBUWVBFX1RPX0NMQVNTX05BTUUgPSB7XG4gICAgYXRydWxlOiBcIkF0UnVsZVwiLFxuICAgIGNvbW1lbnQ6IFwiQ29tbWVudFwiLFxuICAgIGRlY2w6IFwiRGVjbGFyYXRpb25cIixcbiAgICBkb2N1bWVudDogXCJEb2N1bWVudFwiLFxuICAgIHJvb3Q6IFwiUm9vdFwiLFxuICAgIHJ1bGU6IFwiUnVsZVwiXG59O1xudmFyIFBMVUdJTl9QUk9QUyA9IHtcbiAgICBBdFJ1bGU6IHRydWUsXG4gICAgQXRSdWxlRXhpdDogdHJ1ZSxcbiAgICBDb21tZW50OiB0cnVlLFxuICAgIENvbW1lbnRFeGl0OiB0cnVlLFxuICAgIERlY2xhcmF0aW9uOiB0cnVlLFxuICAgIERlY2xhcmF0aW9uRXhpdDogdHJ1ZSxcbiAgICBEb2N1bWVudDogdHJ1ZSxcbiAgICBEb2N1bWVudEV4aXQ6IHRydWUsXG4gICAgT25jZTogdHJ1ZSxcbiAgICBPbmNlRXhpdDogdHJ1ZSxcbiAgICBwb3N0Y3NzUGx1Z2luOiB0cnVlLFxuICAgIHByZXBhcmU6IHRydWUsXG4gICAgUm9vdDogdHJ1ZSxcbiAgICBSb290RXhpdDogdHJ1ZSxcbiAgICBSdWxlOiB0cnVlLFxuICAgIFJ1bGVFeGl0OiB0cnVlXG59O1xudmFyIE5PVF9WSVNJVE9SUyA9IHtcbiAgICBPbmNlOiB0cnVlLFxuICAgIHBvc3Rjc3NQbHVnaW46IHRydWUsXG4gICAgcHJlcGFyZTogdHJ1ZVxufTtcbnZhciBDSElMRFJFTiA9IDA7XG5mdW5jdGlvbiBpc1Byb21pc2Uob2JqKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKG9iaikpID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmoudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRzKG5vZGUyKSB7XG4gICAgdmFyIGtleSA9IGZhbHNlO1xuICAgIHZhciB0eXBlID0gVFlQRV9UT19DTEFTU19OQU1FW25vZGUyLnR5cGVdO1xuICAgIGlmIChub2RlMi50eXBlID09PSBcImRlY2xcIikge1xuICAgICAgICBrZXkgPSBub2RlMi5wcm9wLnRvTG93ZXJDYXNlKCk7XG4gICAgfSBlbHNlIGlmIChub2RlMi50eXBlID09PSBcImF0cnVsZVwiKSB7XG4gICAgICAgIGtleSA9IG5vZGUyLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgaWYgKGtleSAmJiBub2RlMi5hcHBlbmQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICB0eXBlICsgXCItXCIgKyBrZXksXG4gICAgICAgICAgICBDSElMRFJFTixcbiAgICAgICAgICAgIHR5cGUgKyBcIkV4aXRcIixcbiAgICAgICAgICAgIHR5cGUgKyBcIkV4aXQtXCIgKyBrZXlcbiAgICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKGtleSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHR5cGUgKyBcIi1cIiArIGtleSxcbiAgICAgICAgICAgIHR5cGUgKyBcIkV4aXRcIixcbiAgICAgICAgICAgIHR5cGUgKyBcIkV4aXQtXCIgKyBrZXlcbiAgICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKG5vZGUyLmFwcGVuZCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIENISUxEUkVOLFxuICAgICAgICAgICAgdHlwZSArIFwiRXhpdFwiXG4gICAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICB0eXBlICsgXCJFeGl0XCJcbiAgICAgICAgXTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b1N0YWNrKG5vZGUyKSB7XG4gICAgdmFyIGV2ZW50cztcbiAgICBpZiAobm9kZTIudHlwZSA9PT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICAgIGV2ZW50cyA9IFtcbiAgICAgICAgICAgIFwiRG9jdW1lbnRcIixcbiAgICAgICAgICAgIENISUxEUkVOLFxuICAgICAgICAgICAgXCJEb2N1bWVudEV4aXRcIlxuICAgICAgICBdO1xuICAgIH0gZWxzZSBpZiAobm9kZTIudHlwZSA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgZXZlbnRzID0gW1xuICAgICAgICAgICAgXCJSb290XCIsXG4gICAgICAgICAgICBDSElMRFJFTixcbiAgICAgICAgICAgIFwiUm9vdEV4aXRcIlxuICAgICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGV2ZW50cyA9IGdldEV2ZW50cyhub2RlMik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGV2ZW50SW5kZXg6IDAsXG4gICAgICAgIGV2ZW50czogZXZlbnRzLFxuICAgICAgICBpdGVyYXRvcjogMCxcbiAgICAgICAgbm9kZTogbm9kZTIsXG4gICAgICAgIHZpc2l0b3JJbmRleDogMCxcbiAgICAgICAgdmlzaXRvcnM6IFtdXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNsZWFuTWFya3Mobm9kZTIpIHtcbiAgICBub2RlMltpc0NsZWFuXSA9IGZhbHNlO1xuICAgIGlmIChub2RlMi5ub2Rlcykgbm9kZTIubm9kZXMuZm9yRWFjaChmdW5jdGlvbihpMikge1xuICAgICAgICByZXR1cm4gY2xlYW5NYXJrcyhpMik7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5vZGUyO1xufVxudmFyIHBvc3Rjc3MkMiA9IHt9O1xudmFyIExhenlSZXN1bHQkMiA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gTGF6eVJlc3VsdDIocHJvY2Vzc29yMiwgY3NzLCBvcHRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc3RyaW5naWZpZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHJvb3QyO1xuICAgICAgICBpZiAoKHR5cGVvZiBjc3MgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YoY3NzKSkgPT09IFwib2JqZWN0XCIgJiYgY3NzICE9PSBudWxsICYmIChjc3MudHlwZSA9PT0gXCJyb290XCIgfHwgY3NzLnR5cGUgPT09IFwiZG9jdW1lbnRcIikpIHtcbiAgICAgICAgICAgIHJvb3QyID0gY2xlYW5NYXJrcyhjc3MpO1xuICAgICAgICB9IGVsc2UgaWYgKF9pbnN0YW5jZW9mKGNzcywgTGF6eVJlc3VsdDIpIHx8IF9pbnN0YW5jZW9mKGNzcywgUmVzdWx0JDIpKSB7XG4gICAgICAgICAgICByb290MiA9IGNsZWFuTWFya3MoY3NzLnJvb3QpO1xuICAgICAgICAgICAgaWYgKGNzcy5tYXApIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdHMubWFwID09PSBcInVuZGVmaW5lZFwiKSBvcHRzLm1hcCA9IHt9O1xuICAgICAgICAgICAgICAgIGlmICghb3B0cy5tYXAuaW5saW5lKSBvcHRzLm1hcC5pbmxpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBvcHRzLm1hcC5wcmV2ID0gY3NzLm1hcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwYXJzZXIyID0gcGFyc2UkMjtcbiAgICAgICAgICAgIGlmIChvcHRzLnN5bnRheCkgcGFyc2VyMiA9IG9wdHMuc3ludGF4LnBhcnNlO1xuICAgICAgICAgICAgaWYgKG9wdHMucGFyc2VyKSBwYXJzZXIyID0gb3B0cy5wYXJzZXI7XG4gICAgICAgICAgICBpZiAocGFyc2VyMi5wYXJzZSkgcGFyc2VyMiA9IHBhcnNlcjIucGFyc2U7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJvb3QyID0gcGFyc2VyMihjc3MsIG9wdHMpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvb3QyICYmICFyb290MltteV0pIHtcbiAgICAgICAgICAgICAgICBDb250YWluZXIkMS5yZWJ1aWxkKHJvb3QyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc3VsdCA9IG5ldyBSZXN1bHQkMihwcm9jZXNzb3IyLCByb290Miwgb3B0cyk7XG4gICAgICAgIHRoaXMuaGVscGVycyA9IF9leHRlbmRzKHt9LCBwb3N0Y3NzJDIsIHtcbiAgICAgICAgICAgIHBvc3Rjc3M6IHBvc3Rjc3MkMixcbiAgICAgICAgICAgIHJlc3VsdDogdGhpcy5yZXN1bHRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IHRoaXMucHJvY2Vzc29yLnBsdWdpbnMubWFwKGZ1bmN0aW9uKHBsdWdpbjIyKSB7XG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBwbHVnaW4yMiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihwbHVnaW4yMikpID09PSBcIm9iamVjdFwiICYmIHBsdWdpbjIyLnByZXBhcmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHBsdWdpbjIyLCBwbHVnaW4yMi5wcmVwYXJlKF90aGlzLnJlc3VsdCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGx1Z2luMjI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gTGF6eVJlc3VsdDIucHJvdG90eXBlO1xuICAgIF9wcm90by5hc3luYyA9IGZ1bmN0aW9uIGFzeW5jKCkge1xuICAgICAgICBpZiAodGhpcy5lcnJvcikgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuZXJyb3IpO1xuICAgICAgICBpZiAodGhpcy5wcm9jZXNzZWQpIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5yZXN1bHQpO1xuICAgICAgICBpZiAoIXRoaXMucHJvY2Vzc2luZykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nID0gdGhpcy5ydW5Bc3luYygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3Npbmc7XG4gICAgfTtcbiAgICBfcHJvdG8uY2F0Y2ggPSBmdW5jdGlvbiBfY2F0Y2gob25SZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc3luYygpLmNhdGNoKG9uUmVqZWN0ZWQpO1xuICAgIH07XG4gICAgX3Byb3RvLmZpbmFsbHkgPSBmdW5jdGlvbiBfZmluYWxseShvbkZpbmFsbHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRmluYWxseSwgb25GaW5hbGx5KTtcbiAgICB9O1xuICAgIF9wcm90by5nZXRBc3luY0Vycm9yID0gZnVuY3Rpb24gZ2V0QXN5bmNFcnJvcigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVXNlIHByb2Nlc3MoY3NzKS50aGVuKGNiKSB0byB3b3JrIHdpdGggYXN5bmMgcGx1Z2luc1wiKTtcbiAgICB9O1xuICAgIF9wcm90by5oYW5kbGVFcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycm9yLCBub2RlMikge1xuICAgICAgICB2YXIgcGx1Z2luMjIgPSB0aGlzLnJlc3VsdC5sYXN0UGx1Z2luO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKG5vZGUyKSBub2RlMi5hZGRUb0Vycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIGlmIChlcnJvci5uYW1lID09PSBcIkNzc1N5bnRheEVycm9yXCIgJiYgIWVycm9yLnBsdWdpbikge1xuICAgICAgICAgICAgICAgIGVycm9yLnBsdWdpbiA9IHBsdWdpbjIyLnBvc3Rjc3NQbHVnaW47XG4gICAgICAgICAgICAgICAgZXJyb3Iuc2V0TWVzc2FnZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwbHVnaW4yMi5wb3N0Y3NzVmVyc2lvbikge1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBsdWdpbk5hbWUgPSBwbHVnaW4yMi5wb3N0Y3NzUGx1Z2luO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGx1Z2luVmVyID0gcGx1Z2luMjIucG9zdGNzc1ZlcnNpb247XG4gICAgICAgICAgICAgICAgICAgIHZhciBydW50aW1lVmVyID0gdGhpcy5yZXN1bHQucHJvY2Vzc29yLnZlcnNpb247XG4gICAgICAgICAgICAgICAgICAgIHZhciBhMiA9IHBsdWdpblZlci5zcGxpdChcIi5cIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gcnVudGltZVZlci5zcGxpdChcIi5cIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhMlswXSAhPT0gYlswXSB8fCBwYXJzZUludChhMlsxXSkgPiBwYXJzZUludChiWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlVua25vd24gZXJyb3IgZnJvbSBQb3N0Q1NTIHBsdWdpbi4gWW91ciBjdXJyZW50IFBvc3RDU1MgdmVyc2lvbiBpcyBcIiArIHJ1bnRpbWVWZXIgKyBcIiwgYnV0IFwiICsgcGx1Z2luTmFtZSArIFwiIHVzZXMgXCIgKyBwbHVnaW5WZXIgKyBcIi4gUGVyaGFwcyB0aGlzIGlzIHRoZSBzb3VyY2Ugb2YgdGhlIGVycm9yIGJlbG93LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLmVycm9yKSBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH07XG4gICAgX3Byb3RvLnByZXBhcmVWaXNpdG9ycyA9IGZ1bmN0aW9uIHByZXBhcmVWaXNpdG9ycygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgdmFyIGFkZCA9IGZ1bmN0aW9uKHBsdWdpbjIyLCB0eXBlLCBjYikge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5saXN0ZW5lcnNbdHlwZV0pIF90aGlzLmxpc3RlbmVyc1t0eXBlXSA9IFtdO1xuICAgICAgICAgICAgX3RoaXMubGlzdGVuZXJzW3R5cGVdLnB1c2goW1xuICAgICAgICAgICAgICAgIHBsdWdpbjIyLFxuICAgICAgICAgICAgICAgIGNiXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UodGhpcy5wbHVnaW5zKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIHBsdWdpbjIyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBwbHVnaW4yMiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihwbHVnaW4yMikpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBldmVudCBpbiBwbHVnaW4yMil7XG4gICAgICAgICAgICAgICAgICAgIGlmICghUExVR0lOX1BST1BTW2V2ZW50XSAmJiAvXltBLVpdLy50ZXN0KGV2ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBldmVudCBcIiArIGV2ZW50ICsgXCIgaW4gXCIgKyBwbHVnaW4yMi5wb3N0Y3NzUGx1Z2luICsgXCIuIFRyeSB0byB1cGRhdGUgUG9zdENTUyAoXCIgKyB0aGlzLnByb2Nlc3Nvci52ZXJzaW9uICsgXCIgbm93KS5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFOT1RfVklTSVRPUlNbZXZlbnRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3R5cGVfb2YocGx1Z2luMjJbZXZlbnRdKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgZmlsdGVyIGluIHBsdWdpbjIyW2V2ZW50XSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIgPT09IFwiKlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGQocGx1Z2luMjIsIGV2ZW50LCBwbHVnaW4yMltldmVudF1bZmlsdGVyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGQocGx1Z2luMjIsIGV2ZW50ICsgXCItXCIgKyBmaWx0ZXIudG9Mb3dlckNhc2UoKSwgcGx1Z2luMjJbZXZlbnRdW2ZpbHRlcl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luMjJbZXZlbnRdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGQocGx1Z2luMjIsIGV2ZW50LCBwbHVnaW4yMltldmVudF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFzTGlzdGVuZXIgPSBPYmplY3Qua2V5cyh0aGlzLmxpc3RlbmVycykubGVuZ3RoID4gMDtcbiAgICB9O1xuICAgIF9wcm90by5ydW5Bc3luYyA9IGZ1bmN0aW9uIHJ1bkFzeW5jKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpMiwgcGx1Z2luMjIsIHByb21pc2UsIGVycm9yLCByb290Miwgc3RhY2ssIHByb21pc2UxLCBlMiwgbm9kZTIsIF9sb29wLCBfaXRlcmF0b3IsIF9zdGVwO1xuICAgICAgICAgICAgcmV0dXJuIF90c19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24oX3N0YXRlKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoKF9zdGF0ZS5sYWJlbCl7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnBsdWdpbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpMiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpMiA8IF90aGlzLnBsdWdpbnMubGVuZ3RoKSkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDZcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBwbHVnaW4yMiA9IF90aGlzLnBsdWdpbnNbaTJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IF90aGlzLnJ1bk9uUm9vdChwbHVnaW4yMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUHJvbWlzZShwcm9taXNlKSkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDVcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUudHJ5cy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDVcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBfc3RhdGUuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX3RoaXMuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBpMisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnByZXBhcmVWaXNpdG9ycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5oYXNMaXN0ZW5lcikgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE4XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdDIgPSBfdGhpcy5yZXN1bHQucm9vdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5sYWJlbCA9IDc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIXJvb3QyW2lzQ2xlYW5dKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTRcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICByb290Mltpc0NsZWFuXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjayA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1N0YWNrKHJvb3QyKVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5sYWJlbCA9IDg7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHN0YWNrLmxlbmd0aCA+IDApKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTNcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlMSA9IF90aGlzLnZpc2l0VGljayhzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUHJvbWlzZShwcm9taXNlMSkpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMlxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5sYWJlbCA9IDk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS50cnlzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEyXG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlMVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTJcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgICAgICBlMiA9IF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlMiA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLm5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfdGhpcy5oYW5kbGVFcnJvcihlMiwgbm9kZTIpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDhcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgN1xuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMubGlzdGVuZXJzLk9uY2VFeGl0KSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMThcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBfbG9vcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfc3RlcF92YWx1ZSwgcGx1Z2luMjIsIHZpc2l0b3IsIHJvb3RzLCBlMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RzX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbihfc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoKF9zdGF0ZS5sYWJlbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3N0ZXBfdmFsdWUgPSBfc3RlcC52YWx1ZSwgcGx1Z2luMjIgPSBfc3RlcF92YWx1ZVswXSwgdmlzaXRvciA9IF9zdGVwX3ZhbHVlWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc3VsdC5sYXN0UGx1Z2luID0gcGx1Z2luMjI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUudHJ5cy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocm9vdDIudHlwZSA9PT0gXCJkb2N1bWVudFwiKSkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgM1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdHMgPSByb290Mi5ub2Rlcy5tYXAoZnVuY3Rpb24oc3ViUm9vdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRvcihzdWJSb290LCBfdGhpcy5oZWxwZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChyb290cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRvcihyb290MiwgX3RoaXMuaGVscGVycylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLmxhYmVsID0gNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlMiA9IF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX3RoaXMuaGFuZGxlRXJyb3IoZTIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKF90aGlzLmxpc3RlbmVycy5PbmNlRXhpdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUubGFiZWwgPSAxNTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMThcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RzX3ZhbHVlcyhfbG9vcCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUubGFiZWwgPSAxNztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnByb2Nlc3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RyaW5naWZ5KClcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKCk7XG4gICAgfTtcbiAgICBfcHJvdG8ucnVuT25Sb290ID0gZnVuY3Rpb24gcnVuT25Sb290KHBsdWdpbjIyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucmVzdWx0Lmxhc3RQbHVnaW4gPSBwbHVnaW4yMjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICgodHlwZW9mIHBsdWdpbjIyID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKHBsdWdpbjIyKSkgPT09IFwib2JqZWN0XCIgJiYgcGx1Z2luMjIuT25jZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc3VsdC5yb290LnR5cGUgPT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm9vdHMgPSB0aGlzLnJlc3VsdC5yb290Lm5vZGVzLm1hcChmdW5jdGlvbihyb290Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbjIyLk9uY2Uocm9vdDIsIF90aGlzLmhlbHBlcnMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJvbWlzZShyb290c1swXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChyb290cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvb3RzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGx1Z2luMjIuT25jZSh0aGlzLnJlc3VsdC5yb290LCB0aGlzLmhlbHBlcnMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luMjIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwbHVnaW4yMih0aGlzLnJlc3VsdC5yb290LCB0aGlzLnJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIHN0cmluZ2lmeSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHRocm93IHRoaXMuZXJyb3I7XG4gICAgICAgIGlmICh0aGlzLnN0cmluZ2lmaWVkKSByZXR1cm4gdGhpcy5yZXN1bHQ7XG4gICAgICAgIHRoaXMuc3RyaW5naWZpZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnN5bmMoKTtcbiAgICAgICAgdmFyIG9wdHMgPSB0aGlzLnJlc3VsdC5vcHRzO1xuICAgICAgICB2YXIgc3RyID0gc3RyaW5naWZ5JDI7XG4gICAgICAgIGlmIChvcHRzLnN5bnRheCkgc3RyID0gb3B0cy5zeW50YXguc3RyaW5naWZ5O1xuICAgICAgICBpZiAob3B0cy5zdHJpbmdpZmllcikgc3RyID0gb3B0cy5zdHJpbmdpZmllcjtcbiAgICAgICAgaWYgKHN0ci5zdHJpbmdpZnkpIHN0ciA9IHN0ci5zdHJpbmdpZnk7XG4gICAgICAgIHZhciBtYXAgPSBuZXcgTWFwR2VuZXJhdG9yJDEoc3RyLCB0aGlzLnJlc3VsdC5yb290LCB0aGlzLnJlc3VsdC5vcHRzKTtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXAuZ2VuZXJhdGUoKTtcbiAgICAgICAgdGhpcy5yZXN1bHQuY3NzID0gZGF0YVswXTtcbiAgICAgICAgdGhpcy5yZXN1bHQubWFwID0gZGF0YVsxXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0O1xuICAgIH07XG4gICAgX3Byb3RvLnN5bmMgPSBmdW5jdGlvbiBzeW5jKCkge1xuICAgICAgICBpZiAodGhpcy5lcnJvcikgdGhyb3cgdGhpcy5lcnJvcjtcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2VkKSByZXR1cm4gdGhpcy5yZXN1bHQ7XG4gICAgICAgIHRoaXMucHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2luZykge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5nZXRBc3luY0Vycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UodGhpcy5wbHVnaW5zKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIHBsdWdpbjIyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMucnVuT25Sb290KHBsdWdpbjIyKTtcbiAgICAgICAgICAgIGlmIChpc1Byb21pc2UocHJvbWlzZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmdldEFzeW5jRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXBhcmVWaXNpdG9ycygpO1xuICAgICAgICBpZiAodGhpcy5oYXNMaXN0ZW5lcikge1xuICAgICAgICAgICAgdmFyIHJvb3QyID0gdGhpcy5yZXN1bHQucm9vdDtcbiAgICAgICAgICAgIHdoaWxlKCFyb290Mltpc0NsZWFuXSl7XG4gICAgICAgICAgICAgICAgcm9vdDJbaXNDbGVhbl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMud2Fsa1N5bmMocm9vdDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJzLk9uY2VFeGl0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvb3QyLnR5cGUgPT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvcjEgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uocm9vdDIubm9kZXMpLCBfc3RlcDE7ICEoX3N0ZXAxID0gX2l0ZXJhdG9yMSgpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ViUm9vdCA9IF9zdGVwMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXRTeW5jKHRoaXMubGlzdGVuZXJzLk9uY2VFeGl0LCBzdWJSb290KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXRTeW5jKHRoaXMubGlzdGVuZXJzLk9uY2VFeGl0LCByb290Mik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgICB9O1xuICAgIF9wcm90by50aGVuID0gZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAoIShcImZyb21cIiBpbiB0aGlzLm9wdHMpKSB7XG4gICAgICAgICAgICAgICAgd2Fybk9uY2UkMShcIldpdGhvdXQgYGZyb21gIG9wdGlvbiBQb3N0Q1NTIGNvdWxkIGdlbmVyYXRlIHdyb25nIHNvdXJjZSBtYXAgYW5kIHdpbGwgbm90IGZpbmQgQnJvd3NlcnNsaXN0IGNvbmZpZy4gU2V0IGl0IHRvIENTUyBmaWxlIHBhdGggb3IgdG8gYHVuZGVmaW5lZGAgdG8gcHJldmVudCB0aGlzIHdhcm5pbmcuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFzeW5jKCkudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gICAgfTtcbiAgICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3NzO1xuICAgIH07XG4gICAgX3Byb3RvLnZpc2l0U3luYyA9IGZ1bmN0aW9uIHZpc2l0U3luYyh2aXNpdG9ycywgbm9kZTIpIHtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UodmlzaXRvcnMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgX3N0ZXBfdmFsdWUgPSBfc3RlcC52YWx1ZSwgcGx1Z2luMjIgPSBfc3RlcF92YWx1ZVswXSwgdmlzaXRvciA9IF9zdGVwX3ZhbHVlWzFdO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQubGFzdFBsdWdpbiA9IHBsdWdpbjIyO1xuICAgICAgICAgICAgdmFyIHByb21pc2UgPSB2b2lkIDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHByb21pc2UgPSB2aXNpdG9yKG5vZGUyLCB0aGlzLmhlbHBlcnMpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmhhbmRsZUVycm9yKGUyLCBub2RlMi5wcm94eU9mKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlMi50eXBlICE9PSBcInJvb3RcIiAmJiBub2RlMi50eXBlICE9PSBcImRvY3VtZW50XCIgJiYgIW5vZGUyLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUHJvbWlzZShwcm9taXNlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZ2V0QXN5bmNFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8udmlzaXRUaWNrID0gZnVuY3Rpb24gdmlzaXRUaWNrKHN0YWNrKSB7XG4gICAgICAgIHZhciB2aXNpdDIgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIG5vZGUyID0gdmlzaXQyLm5vZGUsIHZpc2l0b3JzID0gdmlzaXQyLnZpc2l0b3JzO1xuICAgICAgICBpZiAobm9kZTIudHlwZSAhPT0gXCJyb290XCIgJiYgbm9kZTIudHlwZSAhPT0gXCJkb2N1bWVudFwiICYmICFub2RlMi5wYXJlbnQpIHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aXNpdG9ycy5sZW5ndGggPiAwICYmIHZpc2l0Mi52aXNpdG9ySW5kZXggPCB2aXNpdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBfdmlzaXRvcnNfdmlzaXQyX3Zpc2l0b3JJbmRleCA9IHZpc2l0b3JzW3Zpc2l0Mi52aXNpdG9ySW5kZXhdLCBwbHVnaW4yMiA9IF92aXNpdG9yc192aXNpdDJfdmlzaXRvckluZGV4WzBdLCB2aXNpdG9yID0gX3Zpc2l0b3JzX3Zpc2l0Ml92aXNpdG9ySW5kZXhbMV07XG4gICAgICAgICAgICB2aXNpdDIudmlzaXRvckluZGV4ICs9IDE7XG4gICAgICAgICAgICBpZiAodmlzaXQyLnZpc2l0b3JJbmRleCA9PT0gdmlzaXRvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmlzaXQyLnZpc2l0b3JzID0gW107XG4gICAgICAgICAgICAgICAgdmlzaXQyLnZpc2l0b3JJbmRleCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5sYXN0UGx1Z2luID0gcGx1Z2luMjI7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdG9yKG5vZGUyLnRvUHJveHkoKSwgdGhpcy5oZWxwZXJzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5oYW5kbGVFcnJvcihlMiwgbm9kZTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2aXNpdDIuaXRlcmF0b3IgIT09IDApIHtcbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IHZpc2l0Mi5pdGVyYXRvcjtcbiAgICAgICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgICAgIHdoaWxlKGNoaWxkID0gbm9kZTIubm9kZXNbbm9kZTIuaW5kZXhlc1tpdGVyYXRvcl1dKXtcbiAgICAgICAgICAgICAgICBub2RlMi5pbmRleGVzW2l0ZXJhdG9yXSArPSAxO1xuICAgICAgICAgICAgICAgIGlmICghY2hpbGRbaXNDbGVhbl0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRbaXNDbGVhbl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHRvU3RhY2soY2hpbGQpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZpc2l0Mi5pdGVyYXRvciA9IDA7XG4gICAgICAgICAgICBkZWxldGUgbm9kZTIuaW5kZXhlc1tpdGVyYXRvcl07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50cyA9IHZpc2l0Mi5ldmVudHM7XG4gICAgICAgIHdoaWxlKHZpc2l0Mi5ldmVudEluZGV4IDwgZXZlbnRzLmxlbmd0aCl7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBldmVudHNbdmlzaXQyLmV2ZW50SW5kZXhdO1xuICAgICAgICAgICAgdmlzaXQyLmV2ZW50SW5kZXggKz0gMTtcbiAgICAgICAgICAgIGlmIChldmVudCA9PT0gQ0hJTERSRU4pIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZTIubm9kZXMgJiYgbm9kZTIubm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUyW2lzQ2xlYW5dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmlzaXQyLml0ZXJhdG9yID0gbm9kZTIuZ2V0SXRlcmF0b3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxpc3RlbmVyc1tldmVudF0pIHtcbiAgICAgICAgICAgICAgICB2aXNpdDIudmlzaXRvcnMgPSB0aGlzLmxpc3RlbmVyc1tldmVudF07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgIH07XG4gICAgX3Byb3RvLndhbGtTeW5jID0gZnVuY3Rpb24gd2Fsa1N5bmMobm9kZTIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbm9kZTJbaXNDbGVhbl0gPSB0cnVlO1xuICAgICAgICB2YXIgZXZlbnRzID0gZ2V0RXZlbnRzKG5vZGUyKTtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UoZXZlbnRzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICBpZiAoZXZlbnQgPT09IENISUxEUkVOKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUyLm5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUyLmVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGRbaXNDbGVhbl0pIF90aGlzLndhbGtTeW5jKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdmlzaXRvcnMgPSB0aGlzLmxpc3RlbmVyc1tldmVudF07XG4gICAgICAgICAgICAgICAgaWYgKHZpc2l0b3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpc2l0U3luYyh2aXNpdG9ycywgbm9kZTIudG9Qcm94eSgpKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLndhcm5pbmdzID0gZnVuY3Rpb24gd2FybmluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN5bmMoKS53YXJuaW5ncygpO1xuICAgIH07XG4gICAgX2NyZWF0ZV9jbGFzcyhMYXp5UmVzdWx0MiwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY29udGVudFwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5KCkuY29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNzc1wiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5KCkuY3NzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwibWFwXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmdpZnkoKS5tYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJtZXNzYWdlc1wiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3luYygpLm1lc3NhZ2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwib3B0c1wiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0Lm9wdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJwcm9jZXNzb3JcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdC5wcm9jZXNzb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJyb290XCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zeW5jKCkucm9vdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBTeW1ib2wudG9TdHJpbmdUYWcsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJMYXp5UmVzdWx0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gTGF6eVJlc3VsdDI7XG59KCk7XG5MYXp5UmVzdWx0JDIucmVnaXN0ZXJQb3N0Y3NzID0gZnVuY3Rpb24oZGVwZW5kYW50KSB7XG4gICAgcG9zdGNzcyQyID0gZGVwZW5kYW50O1xufTtcbnZhciBsYXp5UmVzdWx0ID0gTGF6eVJlc3VsdCQyO1xuTGF6eVJlc3VsdCQyLmRlZmF1bHQgPSBMYXp5UmVzdWx0JDI7XG5Sb290JDMucmVnaXN0ZXJMYXp5UmVzdWx0KExhenlSZXN1bHQkMik7XG5Eb2N1bWVudCQyLnJlZ2lzdGVyTGF6eVJlc3VsdChMYXp5UmVzdWx0JDIpO1xudmFyIE1hcEdlbmVyYXRvcjIyID0gbWFwR2VuZXJhdG9yO1xudmFyIHN0cmluZ2lmeSQxID0gc3RyaW5naWZ5XzE7XG52YXIgd2Fybk9uY2UyMiA9IHdhcm5PbmNlJDI7XG52YXIgcGFyc2UkMSA9IHBhcnNlXzE7XG52YXIgUmVzdWx0JDEgPSByZXN1bHQ7XG52YXIgTm9Xb3JrUmVzdWx0JDEgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIE5vV29ya1Jlc3VsdDIocHJvY2Vzc29yMiwgY3NzLCBvcHRzKSB7XG4gICAgICAgIGNzcyA9IGNzcy50b1N0cmluZygpO1xuICAgICAgICB0aGlzLnN0cmluZ2lmaWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NvciA9IHByb2Nlc3NvcjI7XG4gICAgICAgIHRoaXMuX2NzcyA9IGNzcztcbiAgICAgICAgdGhpcy5fb3B0cyA9IG9wdHM7XG4gICAgICAgIHRoaXMuX21hcCA9IHZvaWQgMDtcbiAgICAgICAgdmFyIHJvb3QyO1xuICAgICAgICB2YXIgc3RyID0gc3RyaW5naWZ5JDE7XG4gICAgICAgIHRoaXMucmVzdWx0ID0gbmV3IFJlc3VsdCQxKHRoaXMuX3Byb2Nlc3Nvciwgcm9vdDIsIHRoaXMuX29wdHMpO1xuICAgICAgICB0aGlzLnJlc3VsdC5jc3MgPSBjc3M7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMucmVzdWx0LCBcInJvb3RcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucm9vdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBtYXAgPSBuZXcgTWFwR2VuZXJhdG9yMjIoc3RyLCByb290MiwgdGhpcy5fb3B0cywgY3NzKTtcbiAgICAgICAgaWYgKG1hcC5pc01hcCgpKSB7XG4gICAgICAgICAgICB2YXIgX21hcF9nZW5lcmF0ZSA9IG1hcC5nZW5lcmF0ZSgpLCBnZW5lcmF0ZWRDU1MgPSBfbWFwX2dlbmVyYXRlWzBdLCBnZW5lcmF0ZWRNYXAgPSBfbWFwX2dlbmVyYXRlWzFdO1xuICAgICAgICAgICAgaWYgKGdlbmVyYXRlZENTUykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LmNzcyA9IGdlbmVyYXRlZENTUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZW5lcmF0ZWRNYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5tYXAgPSBnZW5lcmF0ZWRNYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXAuY2xlYXJBbm5vdGF0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5jc3MgPSBtYXAuY3NzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBOb1dvcmtSZXN1bHQyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uYXN5bmMgPSBmdW5jdGlvbiBhc3luYygpIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmVycm9yKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnJlc3VsdCk7XG4gICAgfTtcbiAgICBfcHJvdG8uY2F0Y2ggPSBmdW5jdGlvbiBfY2F0Y2gob25SZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc3luYygpLmNhdGNoKG9uUmVqZWN0ZWQpO1xuICAgIH07XG4gICAgX3Byb3RvLmZpbmFsbHkgPSBmdW5jdGlvbiBfZmluYWxseShvbkZpbmFsbHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRmluYWxseSwgb25GaW5hbGx5KTtcbiAgICB9O1xuICAgIF9wcm90by5zeW5jID0gZnVuY3Rpb24gc3luYygpIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHRocm93IHRoaXMuZXJyb3I7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgICB9O1xuICAgIF9wcm90by50aGVuID0gZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAoIShcImZyb21cIiBpbiB0aGlzLl9vcHRzKSkge1xuICAgICAgICAgICAgICAgIHdhcm5PbmNlMjIoXCJXaXRob3V0IGBmcm9tYCBvcHRpb24gUG9zdENTUyBjb3VsZCBnZW5lcmF0ZSB3cm9uZyBzb3VyY2UgbWFwIGFuZCB3aWxsIG5vdCBmaW5kIEJyb3dzZXJzbGlzdCBjb25maWcuIFNldCBpdCB0byBDU1MgZmlsZSBwYXRoIG9yIHRvIGB1bmRlZmluZWRgIHRvIHByZXZlbnQgdGhpcyB3YXJuaW5nLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hc3luYygpLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH07XG4gICAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jc3M7XG4gICAgfTtcbiAgICBfcHJvdG8ud2FybmluZ3MgPSBmdW5jdGlvbiB3YXJuaW5ncygpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH07XG4gICAgX2NyZWF0ZV9jbGFzcyhOb1dvcmtSZXN1bHQyLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjb250ZW50XCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQuY3NzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY3NzXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQuY3NzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwibWFwXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQubWFwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwibWVzc2FnZXNcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcIm9wdHNcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdC5vcHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwicHJvY2Vzc29yXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQucHJvY2Vzc29yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwicm9vdFwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Jvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByb290MjtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VyMiA9IHBhcnNlJDE7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdDIgPSBwYXJzZXIyKHRoaXMuX2NzcywgdGhpcy5fb3B0cyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmVycm9yO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSByb290MjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvb3QyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBTeW1ib2wudG9TdHJpbmdUYWcsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJOb1dvcmtSZXN1bHRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBOb1dvcmtSZXN1bHQyO1xufSgpO1xudmFyIG5vV29ya1Jlc3VsdCA9IE5vV29ya1Jlc3VsdCQxO1xuTm9Xb3JrUmVzdWx0JDEuZGVmYXVsdCA9IE5vV29ya1Jlc3VsdCQxO1xudmFyIE5vV29ya1Jlc3VsdDIyID0gbm9Xb3JrUmVzdWx0O1xudmFyIExhenlSZXN1bHQkMSA9IGxhenlSZXN1bHQ7XG52YXIgRG9jdW1lbnQkMSA9IGRvY3VtZW50JDEkMjtcbnZhciBSb290JDIgPSByb290O1xudmFyIFByb2Nlc3NvciQxID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBQcm9jZXNzb3IyKHBsdWdpbnMpIHtcbiAgICAgICAgaWYgKHBsdWdpbnMgPT09IHZvaWQgMCkgcGx1Z2lucyA9IFtdO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSBcIjguNC4zOFwiO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSB0aGlzLm5vcm1hbGl6ZShwbHVnaW5zKTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFByb2Nlc3NvcjIucHJvdG90eXBlO1xuICAgIF9wcm90by5ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUocGx1Z2lucykge1xuICAgICAgICB2YXIgbm9ybWFsaXplZCA9IFtdO1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShwbHVnaW5zKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIGkyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICBpZiAoaTIucG9zdGNzcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGkyID0gaTIoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaTIucG9zdGNzcykge1xuICAgICAgICAgICAgICAgIGkyID0gaTIucG9zdGNzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodHlwZW9mIGkyID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKGkyKSkgPT09IFwib2JqZWN0XCIgJiYgQXJyYXkuaXNBcnJheShpMi5wbHVnaW5zKSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVkLmNvbmNhdChpMi5wbHVnaW5zKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBpMiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihpMikpID09PSBcIm9iamVjdFwiICYmIGkyLnBvc3Rjc3NQbHVnaW4pIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkLnB1c2goaTIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWQucHVzaChpMik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCh0eXBlb2YgaTIgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YoaTIpKSA9PT0gXCJvYmplY3RcIiAmJiAoaTIucGFyc2UgfHwgaTIuc3RyaW5naWZ5KSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9zdENTUyBzeW50YXhlcyBjYW5ub3QgYmUgdXNlZCBhcyBwbHVnaW5zLiBJbnN0ZWFkLCBwbGVhc2UgdXNlIG9uZSBvZiB0aGUgc3ludGF4L3BhcnNlci9zdHJpbmdpZmllciBvcHRpb25zIGFzIG91dGxpbmVkIGluIHlvdXIgUG9zdENTUyBydW5uZXIgZG9jdW1lbnRhdGlvbi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaTIgKyBcIiBpcyBub3QgYSBQb3N0Q1NTIHBsdWdpblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZDtcbiAgICB9O1xuICAgIF9wcm90by5wcm9jZXNzID0gZnVuY3Rpb24gcHJvY2VzczEoY3NzLCBvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzID09PSB2b2lkIDApIG9wdHMgPSB7fTtcbiAgICAgICAgaWYgKCF0aGlzLnBsdWdpbnMubGVuZ3RoICYmICFvcHRzLnBhcnNlciAmJiAhb3B0cy5zdHJpbmdpZmllciAmJiAhb3B0cy5zeW50YXgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm9Xb3JrUmVzdWx0MjIodGhpcywgY3NzLCBvcHRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGF6eVJlc3VsdCQxKHRoaXMsIGNzcywgb3B0cyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by51c2UgPSBmdW5jdGlvbiB1c2UocGx1Z2luMjIpIHtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gdGhpcy5wbHVnaW5zLmNvbmNhdCh0aGlzLm5vcm1hbGl6ZShbXG4gICAgICAgICAgICBwbHVnaW4yMlxuICAgICAgICBdKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIFByb2Nlc3NvcjI7XG59KCk7XG52YXIgcHJvY2Vzc29yID0gUHJvY2Vzc29yJDE7XG5Qcm9jZXNzb3IkMS5kZWZhdWx0ID0gUHJvY2Vzc29yJDE7XG5Sb290JDIucmVnaXN0ZXJQcm9jZXNzb3IoUHJvY2Vzc29yJDEpO1xuRG9jdW1lbnQkMS5yZWdpc3RlclByb2Nlc3NvcihQcm9jZXNzb3IkMSk7XG52YXIgRGVjbGFyYXRpb24kMSA9IGRlY2xhcmF0aW9uO1xudmFyIFByZXZpb3VzTWFwMjIgPSBwcmV2aW91c01hcDtcbnZhciBDb21tZW50JDEgPSBjb21tZW50O1xudmFyIEF0UnVsZSQxID0gYXRSdWxlO1xudmFyIElucHV0JDEgPSBpbnB1dDtcbnZhciBSb290JDEgPSByb290O1xudmFyIFJ1bGUkMSA9IHJ1bGU7XG5mdW5jdGlvbiBmcm9tSlNPTiQxKGpzb24sIGlucHV0cykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGpzb24pKSByZXR1cm4ganNvbi5tYXAoZnVuY3Rpb24objIpIHtcbiAgICAgICAgcmV0dXJuIGZyb21KU09OJDEobjIpO1xuICAgIH0pO1xuICAgIHZhciBvd25JbnB1dHMgPSBqc29uLmlucHV0cywgZGVmYXVsdHMgPSBfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZShqc29uLCBbXG4gICAgICAgIFwiaW5wdXRzXCJcbiAgICBdKTtcbiAgICBpZiAob3duSW5wdXRzKSB7XG4gICAgICAgIGlucHV0cyA9IFtdO1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShvd25JbnB1dHMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgaW5wdXQyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICB2YXIgaW5wdXRIeWRyYXRlZCA9IF9leHRlbmRzKHt9LCBpbnB1dDIsIHtcbiAgICAgICAgICAgICAgICBfX3Byb3RvX186IElucHV0JDEucHJvdG90eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpbnB1dEh5ZHJhdGVkLm1hcCkge1xuICAgICAgICAgICAgICAgIGlucHV0SHlkcmF0ZWQubWFwID0gX2V4dGVuZHMoe30sIGlucHV0SHlkcmF0ZWQubWFwLCB7XG4gICAgICAgICAgICAgICAgICAgIF9fcHJvdG9fXzogUHJldmlvdXNNYXAyMi5wcm90b3R5cGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlucHV0cy5wdXNoKGlucHV0SHlkcmF0ZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkZWZhdWx0cy5ub2Rlcykge1xuICAgICAgICBkZWZhdWx0cy5ub2RlcyA9IGpzb24ubm9kZXMubWFwKGZ1bmN0aW9uKG4yKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbUpTT04kMShuMiwgaW5wdXRzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChkZWZhdWx0cy5zb3VyY2UpIHtcbiAgICAgICAgdmFyIF9kZWZhdWx0c19zb3VyY2UgPSBkZWZhdWx0cy5zb3VyY2UsIGlucHV0SWQgPSBfZGVmYXVsdHNfc291cmNlLmlucHV0SWQsIHNvdXJjZSA9IF9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlKF9kZWZhdWx0c19zb3VyY2UsIFtcbiAgICAgICAgICAgIFwiaW5wdXRJZFwiXG4gICAgICAgIF0pO1xuICAgICAgICBkZWZhdWx0cy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIGlmIChpbnB1dElkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRlZmF1bHRzLnNvdXJjZS5pbnB1dCA9IGlucHV0c1tpbnB1dElkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmYXVsdHMudHlwZSA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSb290JDEoZGVmYXVsdHMpO1xuICAgIH0gZWxzZSBpZiAoZGVmYXVsdHMudHlwZSA9PT0gXCJkZWNsXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNsYXJhdGlvbiQxKGRlZmF1bHRzKTtcbiAgICB9IGVsc2UgaWYgKGRlZmF1bHRzLnR5cGUgPT09IFwicnVsZVwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgUnVsZSQxKGRlZmF1bHRzKTtcbiAgICB9IGVsc2UgaWYgKGRlZmF1bHRzLnR5cGUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tbWVudCQxKGRlZmF1bHRzKTtcbiAgICB9IGVsc2UgaWYgKGRlZmF1bHRzLnR5cGUgPT09IFwiYXRydWxlXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdFJ1bGUkMShkZWZhdWx0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBub2RlIHR5cGU6IFwiICsganNvbi50eXBlKTtcbiAgICB9XG59XG52YXIgZnJvbUpTT05fMSA9IGZyb21KU09OJDE7XG5mcm9tSlNPTiQxLmRlZmF1bHQgPSBmcm9tSlNPTiQxO1xudmFyIENzc1N5bnRheEVycm9yMjIgPSBjc3NTeW50YXhFcnJvcjtcbnZhciBEZWNsYXJhdGlvbjIyID0gZGVjbGFyYXRpb247XG52YXIgTGF6eVJlc3VsdDIyID0gbGF6eVJlc3VsdDtcbnZhciBDb250YWluZXIyMiA9IGNvbnRhaW5lcjtcbnZhciBQcm9jZXNzb3IyMiA9IHByb2Nlc3NvcjtcbnZhciBzdHJpbmdpZnkkNiA9IHN0cmluZ2lmeV8xO1xudmFyIGZyb21KU09OID0gZnJvbUpTT05fMTtcbnZhciBEb2N1bWVudDIyMiA9IGRvY3VtZW50JDEkMjtcbnZhciBXYXJuaW5nMjIgPSB3YXJuaW5nO1xudmFyIENvbW1lbnQyMiA9IGNvbW1lbnQ7XG52YXIgQXRSdWxlMjIgPSBhdFJ1bGU7XG52YXIgUmVzdWx0MjIgPSByZXN1bHQ7XG52YXIgSW5wdXQyMiA9IGlucHV0O1xudmFyIHBhcnNlID0gcGFyc2VfMTtcbnZhciBsaXN0ID0gbGlzdF8xO1xudmFyIFJ1bGUyMiA9IHJ1bGU7XG52YXIgUm9vdDIyID0gcm9vdDtcbnZhciBOb2RlMjIgPSBub2RlO1xuZnVuY3Rpb24gcG9zdGNzcygpIHtcbiAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwbHVnaW5zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgIHBsdWdpbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIGlmIChwbHVnaW5zLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KHBsdWdpbnNbMF0pKSB7XG4gICAgICAgIHBsdWdpbnMgPSBwbHVnaW5zWzBdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb2Nlc3NvcjIyKHBsdWdpbnMpO1xufVxucG9zdGNzcy5wbHVnaW4gPSBmdW5jdGlvbiBwbHVnaW4yKG5hbWUsIGluaXRpYWxpemVyKSB7XG4gICAgdmFyIHdhcm5pbmdQcmludGVkID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gY3JlYXRvcigpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4gJiYgIXdhcm5pbmdQcmludGVkKSB7XG4gICAgICAgICAgICB3YXJuaW5nUHJpbnRlZCA9IHRydWU7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4obmFtZSArIFwiOiBwb3N0Y3NzLnBsdWdpbiB3YXMgZGVwcmVjYXRlZC4gTWlncmF0aW9uIGd1aWRlOlxcbmh0dHBzOi8vZXZpbG1hcnRpYW5zLmNvbS9jaHJvbmljbGVzL3Bvc3Rjc3MtOC1wbHVnaW4tbWlncmF0aW9uXCIpO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52LkxBTkcgJiYgcHJvY2Vzcy5lbnYuTEFORy5zdGFydHNXaXRoKFwiY25cIikpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4obmFtZSArIFwiOiDph4zpnaIgcG9zdGNzcy5wbHVnaW4g6KKr5byD55SoLiDov4Hnp7vmjIfljZc6XFxuaHR0cHM6Ly93d3cudzNjdGVjaC5jb20vdG9waWMvMjIyNlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdHJhbnNmb3JtZXIgPSBpbml0aWFsaXplci5hcHBseSh2b2lkIDAsIFtdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIHRyYW5zZm9ybWVyLnBvc3Rjc3NQbHVnaW4gPSBuYW1lO1xuICAgICAgICB0cmFuc2Zvcm1lci5wb3N0Y3NzVmVyc2lvbiA9IG5ldyBQcm9jZXNzb3IyMigpLnZlcnNpb247XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lcjtcbiAgICB9XG4gICAgdmFyIGNhY2hlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdG9yLCBcInBvc3Rjc3NcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGUpIGNhY2hlID0gY3JlYXRvcigpO1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY3JlYXRvci5wcm9jZXNzID0gZnVuY3Rpb24oY3NzLCBwcm9jZXNzT3B0cywgcGx1Z2luT3B0cykge1xuICAgICAgICByZXR1cm4gcG9zdGNzcyhbXG4gICAgICAgICAgICBjcmVhdG9yKHBsdWdpbk9wdHMpXG4gICAgICAgIF0pLnByb2Nlc3MoY3NzLCBwcm9jZXNzT3B0cyk7XG4gICAgfTtcbiAgICByZXR1cm4gY3JlYXRvcjtcbn07XG5wb3N0Y3NzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeSQ2O1xucG9zdGNzcy5wYXJzZSA9IHBhcnNlO1xucG9zdGNzcy5mcm9tSlNPTiA9IGZyb21KU09OO1xucG9zdGNzcy5saXN0ID0gbGlzdDtcbnBvc3Rjc3MuY29tbWVudCA9IGZ1bmN0aW9uKGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIG5ldyBDb21tZW50MjIoZGVmYXVsdHMpO1xufTtcbnBvc3Rjc3MuYXRSdWxlID0gZnVuY3Rpb24oZGVmYXVsdHMpIHtcbiAgICByZXR1cm4gbmV3IEF0UnVsZTIyKGRlZmF1bHRzKTtcbn07XG5wb3N0Y3NzLmRlY2wgPSBmdW5jdGlvbihkZWZhdWx0cykge1xuICAgIHJldHVybiBuZXcgRGVjbGFyYXRpb24yMihkZWZhdWx0cyk7XG59O1xucG9zdGNzcy5ydWxlID0gZnVuY3Rpb24oZGVmYXVsdHMpIHtcbiAgICByZXR1cm4gbmV3IFJ1bGUyMihkZWZhdWx0cyk7XG59O1xucG9zdGNzcy5yb290ID0gZnVuY3Rpb24oZGVmYXVsdHMpIHtcbiAgICByZXR1cm4gbmV3IFJvb3QyMihkZWZhdWx0cyk7XG59O1xucG9zdGNzcy5kb2N1bWVudCA9IGZ1bmN0aW9uKGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIG5ldyBEb2N1bWVudDIyMihkZWZhdWx0cyk7XG59O1xucG9zdGNzcy5Dc3NTeW50YXhFcnJvciA9IENzc1N5bnRheEVycm9yMjI7XG5wb3N0Y3NzLkRlY2xhcmF0aW9uID0gRGVjbGFyYXRpb24yMjtcbnBvc3Rjc3MuQ29udGFpbmVyID0gQ29udGFpbmVyMjI7XG5wb3N0Y3NzLlByb2Nlc3NvciA9IFByb2Nlc3NvcjIyO1xucG9zdGNzcy5Eb2N1bWVudCA9IERvY3VtZW50MjIyO1xucG9zdGNzcy5Db21tZW50ID0gQ29tbWVudDIyO1xucG9zdGNzcy5XYXJuaW5nID0gV2FybmluZzIyO1xucG9zdGNzcy5BdFJ1bGUgPSBBdFJ1bGUyMjtcbnBvc3Rjc3MuUmVzdWx0ID0gUmVzdWx0MjI7XG5wb3N0Y3NzLklucHV0ID0gSW5wdXQyMjtcbnBvc3Rjc3MuUnVsZSA9IFJ1bGUyMjtcbnBvc3Rjc3MuUm9vdCA9IFJvb3QyMjtcbnBvc3Rjc3MuTm9kZSA9IE5vZGUyMjtcbkxhenlSZXN1bHQyMi5yZWdpc3RlclBvc3Rjc3MocG9zdGNzcyk7XG52YXIgcG9zdGNzc18xID0gcG9zdGNzcztcbnBvc3Rjc3MuZGVmYXVsdCA9IHBvc3Rjc3M7XG52YXIgcG9zdGNzcyQxID0gLyogQF9fUFVSRV9fICovIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHBvc3Rjc3NfMSk7XG5wb3N0Y3NzJDEuc3RyaW5naWZ5O1xucG9zdGNzcyQxLmZyb21KU09OO1xucG9zdGNzcyQxLnBsdWdpbjtcbnBvc3Rjc3MkMS5wYXJzZTtcbnBvc3Rjc3MkMS5saXN0O1xucG9zdGNzcyQxLmRvY3VtZW50O1xucG9zdGNzcyQxLmNvbW1lbnQ7XG5wb3N0Y3NzJDEuYXRSdWxlO1xucG9zdGNzcyQxLnJ1bGU7XG5wb3N0Y3NzJDEuZGVjbDtcbnBvc3Rjc3MkMS5yb290O1xucG9zdGNzcyQxLkNzc1N5bnRheEVycm9yO1xucG9zdGNzcyQxLkRlY2xhcmF0aW9uO1xucG9zdGNzcyQxLkNvbnRhaW5lcjtcbnBvc3Rjc3MkMS5Qcm9jZXNzb3I7XG5wb3N0Y3NzJDEuRG9jdW1lbnQ7XG5wb3N0Y3NzJDEuQ29tbWVudDtcbnBvc3Rjc3MkMS5XYXJuaW5nO1xucG9zdGNzcyQxLkF0UnVsZTtcbnBvc3Rjc3MkMS5SZXN1bHQ7XG5wb3N0Y3NzJDEuSW5wdXQ7XG5wb3N0Y3NzJDEuUnVsZTtcbnBvc3Rjc3MkMS5Sb290O1xucG9zdGNzcyQxLk5vZGU7XG52YXIgQmFzZVJSTm9kZSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gQmFzZVJSTm9kZSgpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIF9hcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwicGFyZW50RWxlbWVudFwiLCBudWxsKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZDIodGhpcywgXCJwYXJlbnROb2RlXCIsIG51bGwpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkMih0aGlzLCBcIm93bmVyRG9jdW1lbnRcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwiZmlyc3RDaGlsZFwiLCBudWxsKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZDIodGhpcywgXCJsYXN0Q2hpbGRcIiwgbnVsbCk7XG4gICAgICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwicHJldmlvdXNTaWJsaW5nXCIsIG51bGwpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkMih0aGlzLCBcIm5leHRTaWJsaW5nXCIsIG51bGwpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkMih0aGlzLCBcIkVMRU1FTlRfTk9ERVwiLCAxKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZDIodGhpcywgXCJURVhUX05PREVcIiwgMyk7XG4gICAgICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwibm9kZVR5cGVcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwibm9kZU5hbWVcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwiUlJOb2RlVHlwZVwiKTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IEJhc2VSUk5vZGUucHJvdG90eXBlO1xuICAgIF9wcm90by5jb250YWlucyA9IGZ1bmN0aW9uIGNvbnRhaW5zKG5vZGUyKSB7XG4gICAgICAgIGlmICghX2luc3RhbmNlb2Yobm9kZTIsIEJhc2VSUk5vZGUpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUyLm93bmVyRG9jdW1lbnQgIT09IHRoaXMub3duZXJEb2N1bWVudCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBlbHNlIGlmIChub2RlMiA9PT0gdGhpcykgcmV0dXJuIHRydWU7XG4gICAgICAgIHdoaWxlKG5vZGUyLnBhcmVudE5vZGUpe1xuICAgICAgICAgICAgaWYgKG5vZGUyLnBhcmVudE5vZGUgPT09IHRoaXMpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgbm9kZTIgPSBub2RlMi5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBfcHJvdG8uYXBwZW5kQ2hpbGQgPSBmdW5jdGlvbiBhcHBlbmRDaGlsZChfbmV3Q2hpbGQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUlJEb21FeGNlcHRpb246IEZhaWxlZCB0byBleGVjdXRlICdhcHBlbmRDaGlsZCcgb24gJ1JSTm9kZSc6IFRoaXMgUlJOb2RlIHR5cGUgZG9lcyBub3Qgc3VwcG9ydCB0aGlzIG1ldGhvZC5cIik7XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgX3Byb3RvLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIGluc2VydEJlZm9yZShfbmV3Q2hpbGQsIF9yZWZDaGlsZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSUkRvbUV4Y2VwdGlvbjogRmFpbGVkIHRvIGV4ZWN1dGUgJ2luc2VydEJlZm9yZScgb24gJ1JSTm9kZSc6IFRoaXMgUlJOb2RlIHR5cGUgZG9lcyBub3Qgc3VwcG9ydCB0aGlzIG1ldGhvZC5cIik7XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgX3Byb3RvLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGQoX25vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUlJEb21FeGNlcHRpb246IEZhaWxlZCB0byBleGVjdXRlICdyZW1vdmVDaGlsZCcgb24gJ1JSTm9kZSc6IFRoaXMgUlJOb2RlIHR5cGUgZG9lcyBub3Qgc3VwcG9ydCB0aGlzIG1ldGhvZC5cIik7XG4gICAgfTtcbiAgICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFwiUlJOb2RlXCI7XG4gICAgfTtcbiAgICBfY3JlYXRlX2NsYXNzKEJhc2VSUk5vZGUsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNoaWxkTm9kZXNcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZE5vZGVzMiA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZEl0ZXJhdG9yID0gdGhpcy5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIHdoaWxlKGNoaWxkSXRlcmF0b3Ipe1xuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzMi5wdXNoKGNoaWxkSXRlcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZEl0ZXJhdG9yID0gY2hpbGRJdGVyYXRvci5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkTm9kZXMyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIEJhc2VSUk5vZGU7XG59KCk7XG52YXIgdGVzdGFibGVBY2Nlc3NvcnMgPSB7XG4gICAgTm9kZTogW1xuICAgICAgICBcImNoaWxkTm9kZXNcIixcbiAgICAgICAgXCJwYXJlbnROb2RlXCIsXG4gICAgICAgIFwicGFyZW50RWxlbWVudFwiLFxuICAgICAgICBcInRleHRDb250ZW50XCJcbiAgICBdLFxuICAgIFNoYWRvd1Jvb3Q6IFtcbiAgICAgICAgXCJob3N0XCIsXG4gICAgICAgIFwic3R5bGVTaGVldHNcIlxuICAgIF0sXG4gICAgRWxlbWVudDogW1xuICAgICAgICBcInNoYWRvd1Jvb3RcIixcbiAgICAgICAgXCJxdWVyeVNlbGVjdG9yXCIsXG4gICAgICAgIFwicXVlcnlTZWxlY3RvckFsbFwiXG4gICAgXSxcbiAgICBNdXRhdGlvbk9ic2VydmVyOiBbXVxufTtcbnZhciB0ZXN0YWJsZU1ldGhvZHMgPSB7XG4gICAgTm9kZTogW1xuICAgICAgICBcImNvbnRhaW5zXCIsXG4gICAgICAgIFwiZ2V0Um9vdE5vZGVcIlxuICAgIF0sXG4gICAgU2hhZG93Um9vdDogW1xuICAgICAgICBcImdldFNlbGVjdGlvblwiXG4gICAgXSxcbiAgICBFbGVtZW50OiBbXSxcbiAgICBNdXRhdGlvbk9ic2VydmVyOiBbXG4gICAgICAgIFwiY29uc3RydWN0b3JcIlxuICAgIF1cbn07XG52YXIgdW50YWludGVkQmFzZVByb3RvdHlwZSA9IHt9O1xudmFyIGlzQW5ndWxhclpvbmVQcmVzZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhZ2xvYmFsVGhpcy5ab25lO1xufTtcbmZ1bmN0aW9uIGdldFVudGFpbnRlZFByb3RvdHlwZShrZXkpIHtcbiAgICBpZiAodW50YWludGVkQmFzZVByb3RvdHlwZVtrZXldKSByZXR1cm4gdW50YWludGVkQmFzZVByb3RvdHlwZVtrZXldO1xuICAgIHZhciBkZWZhdWx0T2JqID0gZ2xvYmFsVGhpc1trZXldO1xuICAgIHZhciBkZWZhdWx0UHJvdG90eXBlID0gZGVmYXVsdE9iai5wcm90b3R5cGU7XG4gICAgdmFyIGFjY2Vzc29yTmFtZXMgPSBrZXkgaW4gdGVzdGFibGVBY2Nlc3NvcnMgPyB0ZXN0YWJsZUFjY2Vzc29yc1trZXldIDogdm9pZCAwO1xuICAgIHZhciBpc1VudGFpbnRlZEFjY2Vzc29ycyA9IEJvb2xlYW4oYWNjZXNzb3JOYW1lcyAmJiAvLyBAdHMtZXhwZWN0LWVycm9yIDIzNDVcbiAgICBhY2Nlc3Nvck5hbWVzLmV2ZXJ5KGZ1bmN0aW9uKGFjY2Vzc29yKSB7XG4gICAgICAgIHZhciBfYTIsIF9iO1xuICAgICAgICByZXR1cm4gQm9vbGVhbigoX2IgPSAoX2EyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihkZWZhdWx0UHJvdG90eXBlLCBhY2Nlc3NvcikpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX2IudG9TdHJpbmcoKS5pbmNsdWRlcyhcIltuYXRpdmUgY29kZV1cIikpO1xuICAgIH0pKTtcbiAgICB2YXIgbWV0aG9kTmFtZXMgPSBrZXkgaW4gdGVzdGFibGVNZXRob2RzID8gdGVzdGFibGVNZXRob2RzW2tleV0gOiB2b2lkIDA7XG4gICAgdmFyIGlzVW50YWludGVkTWV0aG9kcyA9IEJvb2xlYW4obWV0aG9kTmFtZXMgJiYgbWV0aG9kTmFtZXMuZXZlcnkoLy8gQHRzLWV4cGVjdC1lcnJvciAyMzQ1XG4gICAgZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZGVmYXVsdFByb3RvdHlwZVttZXRob2RdID09PSBcImZ1bmN0aW9uXCIgJiYgKChfYTIgPSBkZWZhdWx0UHJvdG90eXBlW21ldGhvZF0pID09IG51bGwgPyB2b2lkIDAgOiBfYTIudG9TdHJpbmcoKS5pbmNsdWRlcyhcIltuYXRpdmUgY29kZV1cIikpO1xuICAgIH0pKTtcbiAgICBpZiAoaXNVbnRhaW50ZWRBY2Nlc3NvcnMgJiYgaXNVbnRhaW50ZWRNZXRob2RzICYmICFpc0FuZ3VsYXJab25lUHJlc2VudCgpKSB7XG4gICAgICAgIHVudGFpbnRlZEJhc2VQcm90b3R5cGVba2V5XSA9IGRlZmF1bHRPYmoucHJvdG90eXBlO1xuICAgICAgICByZXR1cm4gZGVmYXVsdE9iai5wcm90b3R5cGU7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHZhciBpZnJhbWVFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lRWwpO1xuICAgICAgICB2YXIgd2luID0gaWZyYW1lRWwuY29udGVudFdpbmRvdztcbiAgICAgICAgaWYgKCF3aW4pIHJldHVybiBkZWZhdWx0T2JqLnByb3RvdHlwZTtcbiAgICAgICAgdmFyIHVudGFpbnRlZE9iamVjdCA9IHdpbltrZXldLnByb3RvdHlwZTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpZnJhbWVFbCk7XG4gICAgICAgIGlmICghdW50YWludGVkT2JqZWN0KSByZXR1cm4gZGVmYXVsdFByb3RvdHlwZTtcbiAgICAgICAgcmV0dXJuIHVudGFpbnRlZEJhc2VQcm90b3R5cGVba2V5XSA9IHVudGFpbnRlZE9iamVjdDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0UHJvdG90eXBlO1xuICAgIH1cbn1cbnZhciB1bnRhaW50ZWRBY2Nlc3NvckNhY2hlID0ge307XG5mdW5jdGlvbiBnZXRVbnRhaW50ZWRBY2Nlc3NvcihrZXksIGluc3RhbmNlLCBhY2Nlc3Nvcikge1xuICAgIHZhciBfYTI7XG4gICAgdmFyIGNhY2hlS2V5ID0ga2V5ICsgXCIuXCIgKyBTdHJpbmcoYWNjZXNzb3IpO1xuICAgIGlmICh1bnRhaW50ZWRBY2Nlc3NvckNhY2hlW2NhY2hlS2V5XSkgcmV0dXJuIHVudGFpbnRlZEFjY2Vzc29yQ2FjaGVbY2FjaGVLZXldLmNhbGwoaW5zdGFuY2UpO1xuICAgIHZhciB1bnRhaW50ZWRQcm90b3R5cGUgPSBnZXRVbnRhaW50ZWRQcm90b3R5cGUoa2V5KTtcbiAgICB2YXIgdW50YWludGVkQWNjZXNzb3IgPSAoX2EyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih1bnRhaW50ZWRQcm90b3R5cGUsIGFjY2Vzc29yKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5nZXQ7XG4gICAgaWYgKCF1bnRhaW50ZWRBY2Nlc3NvcikgcmV0dXJuIGluc3RhbmNlW2FjY2Vzc29yXTtcbiAgICB1bnRhaW50ZWRBY2Nlc3NvckNhY2hlW2NhY2hlS2V5XSA9IHVudGFpbnRlZEFjY2Vzc29yO1xuICAgIHJldHVybiB1bnRhaW50ZWRBY2Nlc3Nvci5jYWxsKGluc3RhbmNlKTtcbn1cbnZhciB1bnRhaW50ZWRNZXRob2RDYWNoZSA9IHt9O1xuZnVuY3Rpb24gZ2V0VW50YWludGVkTWV0aG9kKGtleSwgaW5zdGFuY2UsIG1ldGhvZCkge1xuICAgIHZhciBjYWNoZUtleSA9IGtleSArIFwiLlwiICsgU3RyaW5nKG1ldGhvZCk7XG4gICAgaWYgKHVudGFpbnRlZE1ldGhvZENhY2hlW2NhY2hlS2V5XSkgcmV0dXJuIHVudGFpbnRlZE1ldGhvZENhY2hlW2NhY2hlS2V5XS5iaW5kKGluc3RhbmNlKTtcbiAgICB2YXIgdW50YWludGVkUHJvdG90eXBlID0gZ2V0VW50YWludGVkUHJvdG90eXBlKGtleSk7XG4gICAgdmFyIHVudGFpbnRlZE1ldGhvZCA9IHVudGFpbnRlZFByb3RvdHlwZVttZXRob2RdO1xuICAgIGlmICh0eXBlb2YgdW50YWludGVkTWV0aG9kICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBpbnN0YW5jZVttZXRob2RdO1xuICAgIHVudGFpbnRlZE1ldGhvZENhY2hlW2NhY2hlS2V5XSA9IHVudGFpbnRlZE1ldGhvZDtcbiAgICByZXR1cm4gdW50YWludGVkTWV0aG9kLmJpbmQoaW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gY2hpbGROb2RlcyhuMikge1xuICAgIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvcihcIk5vZGVcIiwgbjIsIFwiY2hpbGROb2Rlc1wiKTtcbn1cbmZ1bmN0aW9uIHBhcmVudE5vZGUobjIpIHtcbiAgICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IoXCJOb2RlXCIsIG4yLCBcInBhcmVudE5vZGVcIik7XG59XG5mdW5jdGlvbiBwYXJlbnRFbGVtZW50KG4yKSB7XG4gICAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yKFwiTm9kZVwiLCBuMiwgXCJwYXJlbnRFbGVtZW50XCIpO1xufVxuZnVuY3Rpb24gdGV4dENvbnRlbnQobjIpIHtcbiAgICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IoXCJOb2RlXCIsIG4yLCBcInRleHRDb250ZW50XCIpO1xufVxuZnVuY3Rpb24gY29udGFpbnMobjIsIG90aGVyKSB7XG4gICAgcmV0dXJuIGdldFVudGFpbnRlZE1ldGhvZChcIk5vZGVcIiwgbjIsIFwiY29udGFpbnNcIikob3RoZXIpO1xufVxuZnVuY3Rpb24gZ2V0Um9vdE5vZGUobjIpIHtcbiAgICByZXR1cm4gZ2V0VW50YWludGVkTWV0aG9kKFwiTm9kZVwiLCBuMiwgXCJnZXRSb290Tm9kZVwiKSgpO1xufVxuZnVuY3Rpb24gaG9zdChuMikge1xuICAgIGlmICghbjIgfHwgIShcImhvc3RcIiBpbiBuMikpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvcihcIlNoYWRvd1Jvb3RcIiwgbjIsIFwiaG9zdFwiKTtcbn1cbmZ1bmN0aW9uIHN0eWxlU2hlZXRzKG4yKSB7XG4gICAgcmV0dXJuIG4yLnN0eWxlU2hlZXRzO1xufVxuZnVuY3Rpb24gc2hhZG93Um9vdChuMikge1xuICAgIGlmICghbjIgfHwgIShcInNoYWRvd1Jvb3RcIiBpbiBuMikpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvcihcIkVsZW1lbnRcIiwgbjIsIFwic2hhZG93Um9vdFwiKTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3IobjIsIHNlbGVjdG9ycykge1xuICAgIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvcihcIkVsZW1lbnRcIiwgbjIsIFwicXVlcnlTZWxlY3RvclwiKShzZWxlY3RvcnMpO1xufVxuZnVuY3Rpb24gcXVlcnlTZWxlY3RvckFsbChuMiwgc2VsZWN0b3JzKSB7XG4gICAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yKFwiRWxlbWVudFwiLCBuMiwgXCJxdWVyeVNlbGVjdG9yQWxsXCIpKHNlbGVjdG9ycyk7XG59XG5mdW5jdGlvbiBtdXRhdGlvbk9ic2VydmVyQ3RvcigpIHtcbiAgICByZXR1cm4gZ2V0VW50YWludGVkUHJvdG90eXBlKFwiTXV0YXRpb25PYnNlcnZlclwiKS5jb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIHBhdGNoJDIoc291cmNlLCBuYW1lLCByZXBsYWNlbWVudCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghKG5hbWUgaW4gc291cmNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge307XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9yaWdpbmFsID0gc291cmNlW25hbWVdO1xuICAgICAgICB2YXIgd3JhcHBlZCA9IHJlcGxhY2VtZW50KG9yaWdpbmFsKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3cmFwcGVkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHdyYXBwZWQucHJvdG90eXBlID0gd3JhcHBlZC5wcm90b3R5cGUgfHwge307XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh3cmFwcGVkLCB7XG4gICAgICAgICAgICAgICAgX19ycndlYl9vcmlnaW5hbF9fOiB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3JpZ2luYWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2VbbmFtZV0gPSB3cmFwcGVkO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzb3VyY2VbbmFtZV0gPSBvcmlnaW5hbDtcbiAgICAgICAgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHt9O1xuICAgIH1cbn1cbnZhciBpbmRleCA9IHtcbiAgICBjaGlsZE5vZGVzOiBjaGlsZE5vZGVzLFxuICAgIHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG4gICAgcGFyZW50RWxlbWVudDogcGFyZW50RWxlbWVudCxcbiAgICB0ZXh0Q29udGVudDogdGV4dENvbnRlbnQsXG4gICAgY29udGFpbnM6IGNvbnRhaW5zLFxuICAgIGdldFJvb3ROb2RlOiBnZXRSb290Tm9kZSxcbiAgICBob3N0OiBob3N0LFxuICAgIHN0eWxlU2hlZXRzOiBzdHlsZVNoZWV0cyxcbiAgICBzaGFkb3dSb290OiBzaGFkb3dSb290LFxuICAgIHF1ZXJ5U2VsZWN0b3I6IHF1ZXJ5U2VsZWN0b3IsXG4gICAgcXVlcnlTZWxlY3RvckFsbDogcXVlcnlTZWxlY3RvckFsbCxcbiAgICBtdXRhdGlvbk9ic2VydmVyOiBtdXRhdGlvbk9ic2VydmVyQ3RvcixcbiAgICBwYXRjaDogcGF0Y2gkMlxufTtcbmZ1bmN0aW9uIG9uKHR5cGUsIGZuLCB0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHRhcmdldCA9IGRvY3VtZW50O1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfTtcbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIG9wdGlvbnMpO1xuICAgIH07XG59XG52YXIgREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HID0gXCJQbGVhc2Ugc3RvcCBpbXBvcnQgbWlycm9yIGRpcmVjdGx5LiBJbnN0ZWFkIG9mIHRoYXQsXFxyXFxubm93IHlvdSBjYW4gdXNlIHJlcGxheWVyLmdldE1pcnJvcigpIHRvIGFjY2VzcyB0aGUgbWlycm9yIGluc3RhbmNlIG9mIGEgcmVwbGF5ZXIsXFxyXFxub3IgeW91IGNhbiB1c2UgcmVjb3JkLm1pcnJvciB0byBhY2Nlc3MgdGhlIG1pcnJvciBpbnN0YW5jZSBkdXJpbmcgcmVjb3JkaW5nLlwiO1xudmFyIF9taXJyb3IgPSB7XG4gICAgbWFwOiB7fSxcbiAgICBnZXRJZDogZnVuY3Rpb24gZ2V0SWQoKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH0sXG4gICAgZ2V0Tm9kZTogZnVuY3Rpb24gZ2V0Tm9kZSgpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHJlbW92ZU5vZGVGcm9tTWFwOiBmdW5jdGlvbiByZW1vdmVOb2RlRnJvbU1hcCgpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcpO1xuICAgIH0sXG4gICAgaGFzOiBmdW5jdGlvbiBoYXMoKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XG4gICAgfVxufTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5Qcm94eSAmJiB3aW5kb3cuUmVmbGVjdCkge1xuICAgIF9taXJyb3IgPSBuZXcgUHJveHkoX21pcnJvciwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gXCJtYXBcIikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgfSBlbHNlIGlmICghdGltZW91dCAmJiBvcHRpb25zLnRyYWlsaW5nICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgIH0sIHJlbWFpbmluZyk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gaG9va1NldHRlcih0YXJnZXQsIGtleSwgZCwgaXNSZXZva2VkLCB3aW4pIHtcbiAgICBpZiAod2luID09PSB2b2lkIDApIHdpbiA9IHdpbmRvdztcbiAgICB2YXIgb3JpZ2luYWwgPSB3aW4uT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XG4gICAgd2luLk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgaXNSZXZva2VkID8gZCA6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGQuc2V0LmNhbGwoX3RoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsICYmIG9yaWdpbmFsLnNldCkge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsLnNldC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGhvb2tTZXR0ZXIodGFyZ2V0LCBrZXksIG9yaWdpbmFsIHx8IHt9LCB0cnVlKTtcbiAgICB9O1xufVxudmFyIG5vd1RpbWVzdGFtcCA9IERhdGUubm93O1xuaWYgKCEvKiBAX19QVVJFX18gKi8gL1sxLTldWzAtOV17MTJ9Ly50ZXN0KERhdGUubm93KCkudG9TdHJpbmcoKSkpIHtcbiAgICBub3dUaW1lc3RhbXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsKHdpbikge1xuICAgIHZhciBfYTIsIF9iLCBfYywgX2Q7XG4gICAgdmFyIGRvYyA9IHdpbi5kb2N1bWVudDtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBkb2Muc2Nyb2xsaW5nRWxlbWVudCA/IGRvYy5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbExlZnQgOiB3aW4ucGFnZVhPZmZzZXQgIT09IHZvaWQgMCA/IHdpbi5wYWdlWE9mZnNldCA6IGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCAoZG9jID09IG51bGwgPyB2b2lkIDAgOiBkb2MuYm9keSkgJiYgKChfYTIgPSBpbmRleC5wYXJlbnRFbGVtZW50KGRvYy5ib2R5KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5zY3JvbGxMZWZ0KSB8fCAoKF9iID0gZG9jID09IG51bGwgPyB2b2lkIDAgOiBkb2MuYm9keSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnNjcm9sbExlZnQpIHx8IDAsXG4gICAgICAgIHRvcDogZG9jLnNjcm9sbGluZ0VsZW1lbnQgPyBkb2Muc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxUb3AgOiB3aW4ucGFnZVlPZmZzZXQgIT09IHZvaWQgMCA/IHdpbi5wYWdlWU9mZnNldCA6IChkb2MgPT0gbnVsbCA/IHZvaWQgMCA6IGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wKSB8fCAoZG9jID09IG51bGwgPyB2b2lkIDAgOiBkb2MuYm9keSkgJiYgKChfYyA9IGluZGV4LnBhcmVudEVsZW1lbnQoZG9jLmJvZHkpKSA9PSBudWxsID8gdm9pZCAwIDogX2Muc2Nyb2xsVG9wKSB8fCAoKF9kID0gZG9jID09IG51bGwgPyB2b2lkIDAgOiBkb2MuYm9keSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLnNjcm9sbFRvcCkgfHwgMFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRXaW5kb3dIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCB8fCBkb2N1bWVudC5ib2R5ICYmIGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0O1xufVxuZnVuY3Rpb24gZ2V0V2luZG93V2lkdGgoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggfHwgZG9jdW1lbnQuYm9keSAmJiBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoO1xufVxuZnVuY3Rpb24gY2xvc2VzdEVsZW1lbnRPZk5vZGUobm9kZTIpIHtcbiAgICBpZiAoIW5vZGUyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgZWwgPSBub2RlMi5ub2RlVHlwZSA9PT0gbm9kZTIuRUxFTUVOVF9OT0RFID8gbm9kZTIgOiBpbmRleC5wYXJlbnRFbGVtZW50KG5vZGUyKTtcbiAgICByZXR1cm4gZWw7XG59XG5mdW5jdGlvbiBpc0Jsb2NrZWQobm9kZTIsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIGNoZWNrQW5jZXN0b3JzKSB7XG4gICAgaWYgKCFub2RlMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBlbCA9IGNsb3Nlc3RFbGVtZW50T2ZOb2RlKG5vZGUyKTtcbiAgICBpZiAoIWVsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBibG9ja0NsYXNzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGJsb2NrQ2xhc3MpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChjaGVja0FuY2VzdG9ycyAmJiBlbC5jbG9zZXN0KFwiLlwiICsgYmxvY2tDbGFzcykgIT09IG51bGwpIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNsYXNzTWF0Y2hlc1JlZ2V4KGVsLCBibG9ja0NsYXNzLCBjaGVja0FuY2VzdG9ycykpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZTIpIHt9XG4gICAgaWYgKGJsb2NrU2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKGVsLm1hdGNoZXMoYmxvY2tTZWxlY3RvcikpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoY2hlY2tBbmNlc3RvcnMgJiYgZWwuY2xvc2VzdChibG9ja1NlbGVjdG9yKSAhPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzU2VyaWFsaXplZChuMiwgbWlycm9yMikge1xuICAgIHJldHVybiBtaXJyb3IyLmdldElkKG4yKSAhPT0gLTE7XG59XG5mdW5jdGlvbiBpc0lnbm9yZWQobjIsIG1pcnJvcjIsIHNsaW1ET01PcHRpb25zKSB7XG4gICAgaWYgKG4yLnRhZ05hbWUgPT09IFwiVElUTEVcIiAmJiBzbGltRE9NT3B0aW9ucy5oZWFkVGl0bGVNdXRhdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBtaXJyb3IyLmdldElkKG4yKSA9PT0gSUdOT1JFRF9OT0RFO1xufVxuZnVuY3Rpb24gaXNBbmNlc3RvclJlbW92ZWQodGFyZ2V0LCBtaXJyb3IyKSB7XG4gICAgaWYgKGlzU2hhZG93Um9vdCh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGlkID0gbWlycm9yMi5nZXRJZCh0YXJnZXQpO1xuICAgIGlmICghbWlycm9yMi5oYXMoaWQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgcGFyZW50ID0gaW5kZXgucGFyZW50Tm9kZSh0YXJnZXQpO1xuICAgIGlmIChwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlID09PSB0YXJnZXQuRE9DVU1FTlRfTk9ERSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaXNBbmNlc3RvclJlbW92ZWQocGFyZW50LCBtaXJyb3IyKTtcbn1cbmZ1bmN0aW9uIGxlZ2FjeV9pc1RvdWNoRXZlbnQoZXZlbnQpIHtcbiAgICByZXR1cm4gQm9vbGVhbihldmVudC5jaGFuZ2VkVG91Y2hlcyk7XG59XG5mdW5jdGlvbiBwb2x5ZmlsbCQxKHdpbikge1xuICAgIGlmICh3aW4gPT09IHZvaWQgMCkgd2luID0gd2luZG93O1xuICAgIGlmIChcIk5vZGVMaXN0XCIgaW4gd2luICYmICF3aW4uTm9kZUxpc3QucHJvdG90eXBlLmZvckVhY2gpIHtcbiAgICAgICAgd2luLk5vZGVMaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2g7XG4gICAgfVxuICAgIGlmIChcIkRPTVRva2VuTGlzdFwiIGluIHdpbiAmJiAhd2luLkRPTVRva2VuTGlzdC5wcm90b3R5cGUuZm9yRWFjaCkge1xuICAgICAgICB3aW4uRE9NVG9rZW5MaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2g7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNTZXJpYWxpemVkSWZyYW1lKG4yLCBtaXJyb3IyKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4objIubm9kZU5hbWUgPT09IFwiSUZSQU1FXCIgJiYgbWlycm9yMi5nZXRNZXRhKG4yKSk7XG59XG5mdW5jdGlvbiBpc1NlcmlhbGl6ZWRTdHlsZXNoZWV0KG4yLCBtaXJyb3IyKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4objIubm9kZU5hbWUgPT09IFwiTElOS1wiICYmIG4yLm5vZGVUeXBlID09PSBuMi5FTEVNRU5UX05PREUgJiYgbjIuZ2V0QXR0cmlidXRlICYmIG4yLmdldEF0dHJpYnV0ZShcInJlbFwiKSA9PT0gXCJzdHlsZXNoZWV0XCIgJiYgbWlycm9yMi5nZXRNZXRhKG4yKSk7XG59XG5mdW5jdGlvbiBoYXNTaGFkb3dSb290KG4yKSB7XG4gICAgaWYgKCFuMikgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChfaW5zdGFuY2VvZihuMiwgQmFzZVJSTm9kZSkgJiYgXCJzaGFkb3dSb290XCIgaW4gbjIpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4objIuc2hhZG93Um9vdCk7XG4gICAgfVxuICAgIHJldHVybiBCb29sZWFuKGluZGV4LnNoYWRvd1Jvb3QobjIpKTtcbn1cbnZhciBTdHlsZVNoZWV0TWlycm9yID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBTdHlsZVNoZWV0TWlycm9yKCkge1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJpZFwiLCAxKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwic3R5bGVJRE1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImlkU3R5bGVNYXBcIiwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBTdHlsZVNoZWV0TWlycm9yLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uZ2V0SWQgPSBmdW5jdGlvbiBnZXRJZChzdHlsZXNoZWV0KSB7XG4gICAgICAgIHZhciBfdGhpc19zdHlsZUlETWFwX2dldDtcbiAgICAgICAgcmV0dXJuIChfdGhpc19zdHlsZUlETWFwX2dldCA9IHRoaXMuc3R5bGVJRE1hcC5nZXQoc3R5bGVzaGVldCkpICE9IG51bGwgPyBfdGhpc19zdHlsZUlETWFwX2dldCA6IC0xO1xuICAgIH07XG4gICAgX3Byb3RvLmhhcyA9IGZ1bmN0aW9uIGhhcyhzdHlsZXNoZWV0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlSURNYXAuaGFzKHN0eWxlc2hlZXQpO1xuICAgIH07XG4gICAgLyoqXG4gICAqIEByZXR1cm5zIElmIHRoZSBzdHlsZXNoZWV0IGlzIGluIHRoZSBtaXJyb3IsIHJldHVybnMgdGhlIGlkIG9mIHRoZSBzdHlsZXNoZWV0LiBJZiBub3QsIHJldHVybiB0aGUgbmV3IGFzc2lnbmVkIGlkLlxuICAgKi8gX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZChzdHlsZXNoZWV0LCBpZCkge1xuICAgICAgICBpZiAodGhpcy5oYXMoc3R5bGVzaGVldCkpIHJldHVybiB0aGlzLmdldElkKHN0eWxlc2hlZXQpO1xuICAgICAgICB2YXIgbmV3SWQ7XG4gICAgICAgIGlmIChpZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBuZXdJZCA9IHRoaXMuaWQrKztcbiAgICAgICAgfSBlbHNlIG5ld0lkID0gaWQ7XG4gICAgICAgIHRoaXMuc3R5bGVJRE1hcC5zZXQoc3R5bGVzaGVldCwgbmV3SWQpO1xuICAgICAgICB0aGlzLmlkU3R5bGVNYXAuc2V0KG5ld0lkLCBzdHlsZXNoZWV0KTtcbiAgICAgICAgcmV0dXJuIG5ld0lkO1xuICAgIH07XG4gICAgX3Byb3RvLmdldFN0eWxlID0gZnVuY3Rpb24gZ2V0U3R5bGUoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWRTdHlsZU1hcC5nZXQoaWQpIHx8IG51bGw7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgdGhpcy5zdHlsZUlETWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHRoaXMuaWRTdHlsZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuaWQgPSAxO1xuICAgIH07XG4gICAgX3Byb3RvLmdlbmVyYXRlSWQgPSBmdW5jdGlvbiBnZW5lcmF0ZUlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZCsrO1xuICAgIH07XG4gICAgcmV0dXJuIFN0eWxlU2hlZXRNaXJyb3I7XG59KCk7XG5mdW5jdGlvbiBnZXRTaGFkb3dIb3N0KG4yKSB7XG4gICAgdmFyIF9hMjtcbiAgICB2YXIgc2hhZG93SG9zdCA9IG51bGw7XG4gICAgaWYgKFwiZ2V0Um9vdE5vZGVcIiBpbiBuMiAmJiAoKF9hMiA9IGluZGV4LmdldFJvb3ROb2RlKG4yKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5ub2RlVHlwZSkgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSAmJiBpbmRleC5ob3N0KGluZGV4LmdldFJvb3ROb2RlKG4yKSkpIHNoYWRvd0hvc3QgPSBpbmRleC5ob3N0KGluZGV4LmdldFJvb3ROb2RlKG4yKSk7XG4gICAgcmV0dXJuIHNoYWRvd0hvc3Q7XG59XG5mdW5jdGlvbiBnZXRSb290U2hhZG93SG9zdChuMikge1xuICAgIHZhciByb290U2hhZG93SG9zdCA9IG4yO1xuICAgIHZhciBzaGFkb3dIb3N0O1xuICAgIHdoaWxlKHNoYWRvd0hvc3QgPSBnZXRTaGFkb3dIb3N0KHJvb3RTaGFkb3dIb3N0KSlyb290U2hhZG93SG9zdCA9IHNoYWRvd0hvc3Q7XG4gICAgcmV0dXJuIHJvb3RTaGFkb3dIb3N0O1xufVxuZnVuY3Rpb24gc2hhZG93SG9zdEluRG9tKG4yKSB7XG4gICAgdmFyIGRvYyA9IG4yLm93bmVyRG9jdW1lbnQ7XG4gICAgaWYgKCFkb2MpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgc2hhZG93SG9zdCA9IGdldFJvb3RTaGFkb3dIb3N0KG4yKTtcbiAgICByZXR1cm4gaW5kZXguY29udGFpbnMoZG9jLCBzaGFkb3dIb3N0KTtcbn1cbmZ1bmN0aW9uIGluRG9tKG4yKSB7XG4gICAgdmFyIGRvYyA9IG4yLm93bmVyRG9jdW1lbnQ7XG4gICAgaWYgKCFkb2MpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gaW5kZXguY29udGFpbnMoZG9jLCBuMikgfHwgc2hhZG93SG9zdEluRG9tKG4yKTtcbn1cbnZhciBFdmVudFR5cGUgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oRXZlbnRUeXBlMikge1xuICAgIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkRvbUNvbnRlbnRMb2FkZWRcIl0gPSAwXSA9IFwiRG9tQ29udGVudExvYWRlZFwiO1xuICAgIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkxvYWRcIl0gPSAxXSA9IFwiTG9hZFwiO1xuICAgIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkZ1bGxTbmFwc2hvdFwiXSA9IDJdID0gXCJGdWxsU25hcHNob3RcIjtcbiAgICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJJbmNyZW1lbnRhbFNuYXBzaG90XCJdID0gM10gPSBcIkluY3JlbWVudGFsU25hcHNob3RcIjtcbiAgICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJNZXRhXCJdID0gNF0gPSBcIk1ldGFcIjtcbiAgICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJDdXN0b21cIl0gPSA1XSA9IFwiQ3VzdG9tXCI7XG4gICAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiUGx1Z2luXCJdID0gNl0gPSBcIlBsdWdpblwiO1xuICAgIHJldHVybiBFdmVudFR5cGUyO1xufShFdmVudFR5cGUgfHwge30pO1xudmFyIEluY3JlbWVudGFsU291cmNlID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKEluY3JlbWVudGFsU291cmNlMikge1xuICAgIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJNdXRhdGlvblwiXSA9IDBdID0gXCJNdXRhdGlvblwiO1xuICAgIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJNb3VzZU1vdmVcIl0gPSAxXSA9IFwiTW91c2VNb3ZlXCI7XG4gICAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIk1vdXNlSW50ZXJhY3Rpb25cIl0gPSAyXSA9IFwiTW91c2VJbnRlcmFjdGlvblwiO1xuICAgIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJTY3JvbGxcIl0gPSAzXSA9IFwiU2Nyb2xsXCI7XG4gICAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlZpZXdwb3J0UmVzaXplXCJdID0gNF0gPSBcIlZpZXdwb3J0UmVzaXplXCI7XG4gICAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIklucHV0XCJdID0gNV0gPSBcIklucHV0XCI7XG4gICAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlRvdWNoTW92ZVwiXSA9IDZdID0gXCJUb3VjaE1vdmVcIjtcbiAgICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTWVkaWFJbnRlcmFjdGlvblwiXSA9IDddID0gXCJNZWRpYUludGVyYWN0aW9uXCI7XG4gICAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlN0eWxlU2hlZXRSdWxlXCJdID0gOF0gPSBcIlN0eWxlU2hlZXRSdWxlXCI7XG4gICAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkNhbnZhc011dGF0aW9uXCJdID0gOV0gPSBcIkNhbnZhc011dGF0aW9uXCI7XG4gICAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkZvbnRcIl0gPSAxMF0gPSBcIkZvbnRcIjtcbiAgICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTG9nXCJdID0gMTFdID0gXCJMb2dcIjtcbiAgICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiRHJhZ1wiXSA9IDEyXSA9IFwiRHJhZ1wiO1xuICAgIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJTdHlsZURlY2xhcmF0aW9uXCJdID0gMTNdID0gXCJTdHlsZURlY2xhcmF0aW9uXCI7XG4gICAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlNlbGVjdGlvblwiXSA9IDE0XSA9IFwiU2VsZWN0aW9uXCI7XG4gICAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkFkb3B0ZWRTdHlsZVNoZWV0XCJdID0gMTVdID0gXCJBZG9wdGVkU3R5bGVTaGVldFwiO1xuICAgIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJDdXN0b21FbGVtZW50XCJdID0gMTZdID0gXCJDdXN0b21FbGVtZW50XCI7XG4gICAgcmV0dXJuIEluY3JlbWVudGFsU291cmNlMjtcbn0oSW5jcmVtZW50YWxTb3VyY2UgfHwge30pO1xudmFyIE1vdXNlSW50ZXJhY3Rpb25zID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKE1vdXNlSW50ZXJhY3Rpb25zMikge1xuICAgIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJNb3VzZVVwXCJdID0gMF0gPSBcIk1vdXNlVXBcIjtcbiAgICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiTW91c2VEb3duXCJdID0gMV0gPSBcIk1vdXNlRG93blwiO1xuICAgIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJDbGlja1wiXSA9IDJdID0gXCJDbGlja1wiO1xuICAgIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJDb250ZXh0TWVudVwiXSA9IDNdID0gXCJDb250ZXh0TWVudVwiO1xuICAgIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJEYmxDbGlja1wiXSA9IDRdID0gXCJEYmxDbGlja1wiO1xuICAgIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJGb2N1c1wiXSA9IDVdID0gXCJGb2N1c1wiO1xuICAgIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJCbHVyXCJdID0gNl0gPSBcIkJsdXJcIjtcbiAgICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiVG91Y2hTdGFydFwiXSA9IDddID0gXCJUb3VjaFN0YXJ0XCI7XG4gICAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIlRvdWNoTW92ZV9EZXBhcnRlZFwiXSA9IDhdID0gXCJUb3VjaE1vdmVfRGVwYXJ0ZWRcIjtcbiAgICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiVG91Y2hFbmRcIl0gPSA5XSA9IFwiVG91Y2hFbmRcIjtcbiAgICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiVG91Y2hDYW5jZWxcIl0gPSAxMF0gPSBcIlRvdWNoQ2FuY2VsXCI7XG4gICAgcmV0dXJuIE1vdXNlSW50ZXJhY3Rpb25zMjtcbn0oTW91c2VJbnRlcmFjdGlvbnMgfHwge30pO1xudmFyIFBvaW50ZXJUeXBlcyA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbihQb2ludGVyVHlwZXMyKSB7XG4gICAgUG9pbnRlclR5cGVzMltQb2ludGVyVHlwZXMyW1wiTW91c2VcIl0gPSAwXSA9IFwiTW91c2VcIjtcbiAgICBQb2ludGVyVHlwZXMyW1BvaW50ZXJUeXBlczJbXCJQZW5cIl0gPSAxXSA9IFwiUGVuXCI7XG4gICAgUG9pbnRlclR5cGVzMltQb2ludGVyVHlwZXMyW1wiVG91Y2hcIl0gPSAyXSA9IFwiVG91Y2hcIjtcbiAgICByZXR1cm4gUG9pbnRlclR5cGVzMjtcbn0oUG9pbnRlclR5cGVzIHx8IHt9KTtcbnZhciBDYW52YXNDb250ZXh0ID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKENhbnZhc0NvbnRleHQyKSB7XG4gICAgQ2FudmFzQ29udGV4dDJbQ2FudmFzQ29udGV4dDJbXCIyRFwiXSA9IDBdID0gXCIyRFwiO1xuICAgIENhbnZhc0NvbnRleHQyW0NhbnZhc0NvbnRleHQyW1wiV2ViR0xcIl0gPSAxXSA9IFwiV2ViR0xcIjtcbiAgICBDYW52YXNDb250ZXh0MltDYW52YXNDb250ZXh0MltcIldlYkdMMlwiXSA9IDJdID0gXCJXZWJHTDJcIjtcbiAgICByZXR1cm4gQ2FudmFzQ29udGV4dDI7XG59KENhbnZhc0NvbnRleHQgfHwge30pO1xudmFyIE1lZGlhSW50ZXJhY3Rpb25zID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKE1lZGlhSW50ZXJhY3Rpb25zMikge1xuICAgIE1lZGlhSW50ZXJhY3Rpb25zMltNZWRpYUludGVyYWN0aW9uczJbXCJQbGF5XCJdID0gMF0gPSBcIlBsYXlcIjtcbiAgICBNZWRpYUludGVyYWN0aW9uczJbTWVkaWFJbnRlcmFjdGlvbnMyW1wiUGF1c2VcIl0gPSAxXSA9IFwiUGF1c2VcIjtcbiAgICBNZWRpYUludGVyYWN0aW9uczJbTWVkaWFJbnRlcmFjdGlvbnMyW1wiU2Vla2VkXCJdID0gMl0gPSBcIlNlZWtlZFwiO1xuICAgIE1lZGlhSW50ZXJhY3Rpb25zMltNZWRpYUludGVyYWN0aW9uczJbXCJWb2x1bWVDaGFuZ2VcIl0gPSAzXSA9IFwiVm9sdW1lQ2hhbmdlXCI7XG4gICAgTWVkaWFJbnRlcmFjdGlvbnMyW01lZGlhSW50ZXJhY3Rpb25zMltcIlJhdGVDaGFuZ2VcIl0gPSA0XSA9IFwiUmF0ZUNoYW5nZVwiO1xuICAgIHJldHVybiBNZWRpYUludGVyYWN0aW9uczI7XG59KE1lZGlhSW50ZXJhY3Rpb25zIHx8IHt9KTtcbnZhciBOb2RlVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbihOb2RlVHlwZTIpIHtcbiAgICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiRG9jdW1lbnRcIl0gPSAwXSA9IFwiRG9jdW1lbnRcIjtcbiAgICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiRG9jdW1lbnRUeXBlXCJdID0gMV0gPSBcIkRvY3VtZW50VHlwZVwiO1xuICAgIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJFbGVtZW50XCJdID0gMl0gPSBcIkVsZW1lbnRcIjtcbiAgICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiVGV4dFwiXSA9IDNdID0gXCJUZXh0XCI7XG4gICAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkNEQVRBXCJdID0gNF0gPSBcIkNEQVRBXCI7XG4gICAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkNvbW1lbnRcIl0gPSA1XSA9IFwiQ29tbWVudFwiO1xuICAgIHJldHVybiBOb2RlVHlwZTI7XG59KE5vZGVUeXBlIHx8IHt9KTtcbmZ1bmN0aW9uIGlzTm9kZUluTGlua2VkTGlzdChuMikge1xuICAgIHJldHVybiBcIl9fbG5cIiBpbiBuMjtcbn1cbnZhciBEb3VibGVMaW5rZWRMaXN0ID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBEb3VibGVMaW5rZWRMaXN0KCkge1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJsZW5ndGhcIiwgMCk7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImhlYWRcIiwgbnVsbCk7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcInRhaWxcIiwgbnVsbCk7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBEb3VibGVMaW5rZWRMaXN0LnByb3RvdHlwZTtcbiAgICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KHBvc2l0aW9uKSB7XG4gICAgICAgIGlmIChwb3NpdGlvbiA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9zaXRpb24gb3V0c2lkZSBvZiBsaXN0IHJhbmdlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5oZWFkO1xuICAgICAgICBmb3IodmFyIGluZGV4MiA9IDA7IGluZGV4MiA8IHBvc2l0aW9uOyBpbmRleDIrKyl7XG4gICAgICAgICAgICBjdXJyZW50ID0gKGN1cnJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGN1cnJlbnQubmV4dCkgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9O1xuICAgIF9wcm90by5hZGROb2RlID0gZnVuY3Rpb24gYWRkTm9kZShuMikge1xuICAgICAgICB2YXIgbm9kZTIgPSB7XG4gICAgICAgICAgICB2YWx1ZTogbjIsXG4gICAgICAgICAgICBwcmV2aW91czogbnVsbCxcbiAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgbjIuX19sbiA9IG5vZGUyO1xuICAgICAgICBpZiAobjIucHJldmlvdXNTaWJsaW5nICYmIGlzTm9kZUluTGlua2VkTGlzdChuMi5wcmV2aW91c1NpYmxpbmcpKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IG4yLnByZXZpb3VzU2libGluZy5fX2xuLm5leHQ7XG4gICAgICAgICAgICBub2RlMi5uZXh0ID0gY3VycmVudDtcbiAgICAgICAgICAgIG5vZGUyLnByZXZpb3VzID0gbjIucHJldmlvdXNTaWJsaW5nLl9fbG47XG4gICAgICAgICAgICBuMi5wcmV2aW91c1NpYmxpbmcuX19sbi5uZXh0ID0gbm9kZTI7XG4gICAgICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQucHJldmlvdXMgPSBub2RlMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChuMi5uZXh0U2libGluZyAmJiBpc05vZGVJbkxpbmtlZExpc3QobjIubmV4dFNpYmxpbmcpICYmIG4yLm5leHRTaWJsaW5nLl9fbG4ucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50MSA9IG4yLm5leHRTaWJsaW5nLl9fbG4ucHJldmlvdXM7XG4gICAgICAgICAgICBub2RlMi5wcmV2aW91cyA9IGN1cnJlbnQxO1xuICAgICAgICAgICAgbm9kZTIubmV4dCA9IG4yLm5leHRTaWJsaW5nLl9fbG47XG4gICAgICAgICAgICBuMi5uZXh0U2libGluZy5fX2xuLnByZXZpb3VzID0gbm9kZTI7XG4gICAgICAgICAgICBpZiAoY3VycmVudDEpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50MS5uZXh0ID0gbm9kZTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oZWFkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkLnByZXZpb3VzID0gbm9kZTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlMi5uZXh0ID0gdGhpcy5oZWFkO1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gbm9kZTI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUyLm5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IG5vZGUyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVtb3ZlTm9kZSA9IGZ1bmN0aW9uIHJlbW92ZU5vZGUobjIpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBuMi5fX2xuO1xuICAgICAgICBpZiAoIXRoaXMuaGVhZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3VycmVudC5wcmV2aW91cykge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgaWYgKHRoaXMuaGVhZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhZC5wcmV2aW91cyA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50LnByZXZpb3VzLm5leHQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICBpZiAoY3VycmVudC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgY3VycmVudC5uZXh0LnByZXZpb3VzID0gY3VycmVudC5wcmV2aW91cztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YWlsID0gY3VycmVudC5wcmV2aW91cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobjIuX19sbikge1xuICAgICAgICAgICAgZGVsZXRlIG4yLl9fbG47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICB9O1xuICAgIHJldHVybiBEb3VibGVMaW5rZWRMaXN0O1xufSgpO1xudmFyIG1vdmVLZXkgPSBmdW5jdGlvbihpZCwgcGFyZW50SWQpIHtcbiAgICByZXR1cm4gaWQgKyBcIkBcIiArIHBhcmVudElkO1xufTtcbnZhciBNdXRhdGlvbkJ1ZmZlciA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gTXV0YXRpb25CdWZmZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImZyb3plblwiLCBmYWxzZSk7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImxvY2tlZFwiLCBmYWxzZSk7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcInRleHRzXCIsIFtdKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiYXR0cmlidXRlc1wiLCBbXSk7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImF0dHJpYnV0ZU1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcInJlbW92ZXNcIiwgW10pO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJtYXBSZW1vdmVzXCIsIFtdKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwibW92ZWRNYXBcIiwge30pO1xuICAgICAgICAvKipcbiAgICAgKiB0aGUgYnJvd3NlciBNdXRhdGlvbk9ic2VydmVyIGVtaXRzIG11bHRpcGxlIG11dGF0aW9ucyBhZnRlclxuICAgICAqIGEgZGVsYXkgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIG1ha2luZyB0cmFjaW5nIGFkZGVkIG5vZGVzIGhhcmRcbiAgICAgKiBpbiBvdXIgYHByb2Nlc3NNdXRhdGlvbnNgIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIEZvciBleGFtcGxlLCBpZiB3ZSBhcHBlbmQgYW4gZWxlbWVudCBlbF8xIGludG8gYm9keSwgYW5kIHRoZW4gYXBwZW5kXG4gICAgICogYW5vdGhlciBlbGVtZW50IGVsXzIgaW50byBlbF8xLCB0aGVzZSB0d28gbXV0YXRpb25zIG1heSBiZSBwYXNzZWQgdG8gdGhlXG4gICAgICogY2FsbGJhY2sgZnVuY3Rpb24gdG9nZXRoZXIgd2hlbiB0aGUgdHdvIG9wZXJhdGlvbnMgd2VyZSBkb25lLlxuICAgICAqIEdlbmVyYWxseSB3ZSBuZWVkIHRvIHRyYWNlIGNoaWxkIG5vZGVzIG9mIG5ld2x5IGFkZGVkIG5vZGVzLCBidXQgaW4gdGhpc1xuICAgICAqIGNhc2UgaWYgd2UgY291bnQgZWxfMiBhcyBlbF8xJ3MgY2hpbGQgbm9kZSBpbiB0aGUgZmlyc3QgbXV0YXRpb24gcmVjb3JkLFxuICAgICAqIHRoZW4gd2Ugd2lsbCBjb3VudCBlbF8yIGFnYWluIGluIHRoZSBzZWNvbmQgbXV0YXRpb24gcmVjb3JkIHdoaWNoIHdhc1xuICAgICAqIGR1cGxpY2F0ZWQuXG4gICAgICogVG8gYXZvaWQgb2YgZHVwbGljYXRlIGNvdW50aW5nIGFkZGVkIG5vZGVzLCB3ZSB1c2UgYSBTZXQgdG8gc3RvcmVcbiAgICAgKiBhZGRlZCBub2RlcyBhbmQgaXRzIGNoaWxkIG5vZGVzIGR1cmluZyBpdGVyYXRlIG11dGF0aW9uIHJlY29yZHMuIFRoZW5cbiAgICAgKiBjb2xsZWN0IGFkZGVkIG5vZGVzIGZyb20gdGhlIFNldCB3aGljaCBoYXZlIG5vIGR1cGxpY2F0ZSBjb3B5LiBCdXRcbiAgICAgKiB0aGlzIGFsc28gY2F1c2VzIG5ld2x5IGFkZGVkIG5vZGVzIHdpbGwgbm90IGJlIHNlcmlhbGl6ZWQgd2l0aCBpZCBBU0FQLFxuICAgICAqIHdoaWNoIG1lYW5zIGFsbCB0aGUgaWQgcmVsYXRlZCBjYWxjdWxhdGlvbiBzaG91bGQgYmUgbGF6eSB0b28uXG4gICAgICovIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImFkZGVkU2V0XCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJtb3ZlZFNldFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiZHJvcHBlZFNldFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwicmVtb3Zlc1N1YlRyZWVDYWNoZVwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwibXV0YXRpb25DYlwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiYmxvY2tDbGFzc1wiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiYmxvY2tTZWxlY3RvclwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwibWFza1RleHRDbGFzc1wiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwibWFza1RleHRTZWxlY3RvclwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiaW5saW5lU3R5bGVzaGVldFwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwibWFza0lucHV0T3B0aW9uc1wiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwibWFza1RleHRGblwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwibWFza0lucHV0Rm5cIik7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImtlZXBJZnJhbWVTcmNGblwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwicmVjb3JkQ2FudmFzXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJpbmxpbmVJbWFnZXNcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcInNsaW1ET01PcHRpb25zXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJkYXRhVVJMT3B0aW9uc1wiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiZG9jXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJtaXJyb3JcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImlmcmFtZU1hbmFnZXJcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcInN0eWxlc2hlZXRNYW5hZ2VyXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJzaGFkb3dEb21NYW5hZ2VyXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJjYW52YXNNYW5hZ2VyXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJwcm9jZXNzZWROb2RlTWFuYWdlclwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwidW5hdHRhY2hlZERvY1wiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwicHJvY2Vzc011dGF0aW9uc1wiLCBmdW5jdGlvbihtdXRhdGlvbnMpIHtcbiAgICAgICAgICAgIG11dGF0aW9ucy5mb3JFYWNoKF90aGlzLnByb2Nlc3NNdXRhdGlvbik7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJlbWl0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmZyb3plbiB8fCBfdGhpcy5sb2NrZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYWRkcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGFkZGVkSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgICAgIHZhciBhZGRMaXN0ID0gbmV3IERvdWJsZUxpbmtlZExpc3QoKTtcbiAgICAgICAgICAgIHZhciBnZXROZXh0SWQgPSBmdW5jdGlvbihuMikge1xuICAgICAgICAgICAgICAgIHZhciBucyA9IG4yO1xuICAgICAgICAgICAgICAgIHZhciBuZXh0SWQgPSBJR05PUkVEX05PREU7XG4gICAgICAgICAgICAgICAgd2hpbGUobmV4dElkID09PSBJR05PUkVEX05PREUpe1xuICAgICAgICAgICAgICAgICAgICBucyA9IG5zICYmIG5zLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBuZXh0SWQgPSBucyAmJiBfdGhpcy5taXJyb3IuZ2V0SWQobnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dElkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBwdXNoQWRkID0gZnVuY3Rpb24objIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gaW5kZXgucGFyZW50Tm9kZShuMik7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnQgfHwgIWluRG9tKG4yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjc3NDYXB0dXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChuMi5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudC50YWdOYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50VGFnID09PSBcIlRFWFRBUkVBXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJlbnRUYWcgPT09IFwiU1RZTEVcIiAmJiBfdGhpcy5hZGRlZFNldC5oYXMocGFyZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3NzQ2FwdHVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRJZCA9IGlzU2hhZG93Um9vdChwYXJlbnQpID8gX3RoaXMubWlycm9yLmdldElkKGdldFNoYWRvd0hvc3QobjIpKSA6IF90aGlzLm1pcnJvci5nZXRJZChwYXJlbnQpO1xuICAgICAgICAgICAgICAgIHZhciBuZXh0SWQgPSBnZXROZXh0SWQobjIpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRJZCA9PT0gLTEgfHwgbmV4dElkID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkTGlzdC5hZGROb2RlKG4yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHNuID0gc2VyaWFsaXplTm9kZVdpdGhJZChuMiwge1xuICAgICAgICAgICAgICAgICAgICBkb2M6IF90aGlzLmRvYyxcbiAgICAgICAgICAgICAgICAgICAgbWlycm9yOiBfdGhpcy5taXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrQ2xhc3M6IF90aGlzLmJsb2NrQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrU2VsZWN0b3I6IF90aGlzLmJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgICAgIG1hc2tUZXh0Q2xhc3M6IF90aGlzLm1hc2tUZXh0Q2xhc3MsXG4gICAgICAgICAgICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3I6IF90aGlzLm1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgICAgIHNraXBDaGlsZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbmV3bHlBZGRlZEVsZW1lbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQ6IF90aGlzLmlubGluZVN0eWxlc2hlZXQsXG4gICAgICAgICAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnM6IF90aGlzLm1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIG1hc2tUZXh0Rm46IF90aGlzLm1hc2tUZXh0Rm4sXG4gICAgICAgICAgICAgICAgICAgIG1hc2tJbnB1dEZuOiBfdGhpcy5tYXNrSW5wdXRGbixcbiAgICAgICAgICAgICAgICAgICAgc2xpbURPTU9wdGlvbnM6IF90aGlzLnNsaW1ET01PcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBkYXRhVVJMT3B0aW9uczogX3RoaXMuZGF0YVVSTE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZENhbnZhczogX3RoaXMucmVjb3JkQ2FudmFzLFxuICAgICAgICAgICAgICAgICAgICBpbmxpbmVJbWFnZXM6IF90aGlzLmlubGluZUltYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgb25TZXJpYWxpemU6IGZ1bmN0aW9uKGN1cnJlbnROKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTZXJpYWxpemVkSWZyYW1lKGN1cnJlbnROLCBfdGhpcy5taXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaWZyYW1lTWFuYWdlci5hZGRJZnJhbWUoY3VycmVudE4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2VyaWFsaXplZFN0eWxlc2hlZXQoY3VycmVudE4sIF90aGlzLm1pcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdHlsZXNoZWV0TWFuYWdlci50cmFja0xpbmtFbGVtZW50KGN1cnJlbnROKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNTaGFkb3dSb290KG4yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNoYWRvd0RvbU1hbmFnZXIuYWRkU2hhZG93Um9vdChpbmRleC5zaGFkb3dSb290KG4yKSwgX3RoaXMuZG9jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25JZnJhbWVMb2FkOiBmdW5jdGlvbihpZnJhbWUsIGNoaWxkU24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmlmcmFtZU1hbmFnZXIuYXR0YWNoSWZyYW1lKGlmcmFtZSwgY2hpbGRTbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zaGFkb3dEb21NYW5hZ2VyLm9ic2VydmVBdHRhY2hTaGFkb3coaWZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25TdHlsZXNoZWV0TG9hZDogZnVuY3Rpb24obGluaywgY2hpbGRTbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3R5bGVzaGVldE1hbmFnZXIuYXR0YWNoTGlua0VsZW1lbnQobGluaywgY2hpbGRTbik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNzc0NhcHR1cmVkOiBjc3NDYXB0dXJlZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzbikge1xuICAgICAgICAgICAgICAgICAgICBhZGRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQ6IHBhcmVudElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dElkOiBuZXh0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlOiBzblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkZWRJZHMuYWRkKHNuLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2hpbGUoX3RoaXMubWFwUmVtb3Zlcy5sZW5ndGgpe1xuICAgICAgICAgICAgICAgIF90aGlzLm1pcnJvci5yZW1vdmVOb2RlRnJvbU1hcChfdGhpcy5tYXBSZW1vdmVzLnNoaWZ0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UoX3RoaXMubW92ZWRTZXQpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgdmFyIG4yID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGlzUGFyZW50UmVtb3ZlZChfdGhpcy5yZW1vdmVzU3ViVHJlZUNhY2hlLCBuMiwgX3RoaXMubWlycm9yKSAmJiAhX3RoaXMubW92ZWRTZXQuaGFzKGluZGV4LnBhcmVudE5vZGUobjIpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHVzaEFkZChuMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvcjEgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UoX3RoaXMuYWRkZWRTZXQpLCBfc3RlcDE7ICEoX3N0ZXAxID0gX2l0ZXJhdG9yMSgpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgdmFyIG4yMSA9IF9zdGVwMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQW5jZXN0b3JJblNldChfdGhpcy5kcm9wcGVkU2V0LCBuMjEpICYmICFpc1BhcmVudFJlbW92ZWQoX3RoaXMucmVtb3Zlc1N1YlRyZWVDYWNoZSwgbjIxLCBfdGhpcy5taXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2hBZGQobjIxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzQW5jZXN0b3JJblNldChfdGhpcy5tb3ZlZFNldCwgbjIxKSkge1xuICAgICAgICAgICAgICAgICAgICBwdXNoQWRkKG4yMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZHJvcHBlZFNldC5hZGQobjIxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gbnVsbDtcbiAgICAgICAgICAgIHdoaWxlKGFkZExpc3QubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZTIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChjYW5kaWRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudElkID0gX3RoaXMubWlycm9yLmdldElkKGluZGV4LnBhcmVudE5vZGUoY2FuZGlkYXRlLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0SWQgPSBnZXROZXh0SWQoY2FuZGlkYXRlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudElkICE9PSAtMSAmJiBuZXh0SWQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlMiA9IGNhbmRpZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWlsTm9kZSA9IGFkZExpc3QudGFpbDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUodGFpbE5vZGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9ub2RlID0gdGFpbE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWlsTm9kZSA9IHRhaWxOb2RlLnByZXZpb3VzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9ub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudElkMSA9IF90aGlzLm1pcnJvci5nZXRJZChpbmRleC5wYXJlbnROb2RlKF9ub2RlLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRJZDEgPSBnZXROZXh0SWQoX25vZGUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0SWQxID09PSAtMSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyZW50SWQxICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlMiA9IF9ub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdW5oYW5kbGVkTm9kZSA9IF9ub2RlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gaW5kZXgucGFyZW50Tm9kZSh1bmhhbmRsZWROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNoYWRvd0hvc3QgPSBpbmRleC5ob3N0KHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50SWQyID0gX3RoaXMubWlycm9yLmdldElkKHNoYWRvd0hvc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudElkMiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlMiA9IF9ub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbm9kZTIpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUoYWRkTGlzdC5oZWFkKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZExpc3QucmVtb3ZlTm9kZShhZGRMaXN0LmhlYWQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYW5kaWRhdGUgPSBub2RlMi5wcmV2aW91cztcbiAgICAgICAgICAgICAgICBhZGRMaXN0LnJlbW92ZU5vZGUobm9kZTIudmFsdWUpO1xuICAgICAgICAgICAgICAgIHB1c2hBZGQobm9kZTIudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgdGV4dHM6IF90aGlzLnRleHRzLm1hcChmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuMiA9IHRleHQubm9kZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGluZGV4LnBhcmVudE5vZGUobjIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC50YWdOYW1lID09PSBcIlRFWFRBUkVBXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmdlblRleHRBcmVhVmFsdWVNdXRhdGlvbihwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogX3RoaXMubWlycm9yLmdldElkKG4yKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0ZXh0LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFhZGRlZElkcy5oYXModGV4dC5pZCk7XG4gICAgICAgICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm1pcnJvci5oYXModGV4dC5pZCk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogX3RoaXMuYXR0cmlidXRlcy5tYXAoZnVuY3Rpb24oYXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gYXR0cmlidXRlLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXR0cmlidXRlcy5zdHlsZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpZmZBc1N0ciA9IEpTT04uc3RyaW5naWZ5KGF0dHJpYnV0ZS5zdHlsZURpZmYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVuY2hhbmdlZEFzU3RyID0gSlNPTi5zdHJpbmdpZnkoYXR0cmlidXRlLl91bmNoYW5nZWRTdHlsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpZmZBc1N0ci5sZW5ndGggPCBhdHRyaWJ1dGVzLnN0eWxlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZGlmZkFzU3RyICsgdW5jaGFuZ2VkQXNTdHIpLnNwbGl0KFwidmFyKFwiKS5sZW5ndGggPT09IGF0dHJpYnV0ZXMuc3R5bGUuc3BsaXQoXCJ2YXIoXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnN0eWxlID0gYXR0cmlidXRlLnN0eWxlRGlmZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBfdGhpcy5taXJyb3IuZ2V0SWQoYXR0cmlidXRlLm5vZGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbihhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFhZGRlZElkcy5oYXMoYXR0cmlidXRlLmlkKTtcbiAgICAgICAgICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24oYXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5taXJyb3IuaGFzKGF0dHJpYnV0ZS5pZCk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgcmVtb3ZlczogX3RoaXMucmVtb3ZlcyxcbiAgICAgICAgICAgICAgICBhZGRzOiBhZGRzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCFwYXlsb2FkLnRleHRzLmxlbmd0aCAmJiAhcGF5bG9hZC5hdHRyaWJ1dGVzLmxlbmd0aCAmJiAhcGF5bG9hZC5yZW1vdmVzLmxlbmd0aCAmJiAhcGF5bG9hZC5hZGRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnRleHRzID0gW107XG4gICAgICAgICAgICBfdGhpcy5hdHRyaWJ1dGVzID0gW107XG4gICAgICAgICAgICBfdGhpcy5hdHRyaWJ1dGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgICAgIF90aGlzLnJlbW92ZXMgPSBbXTtcbiAgICAgICAgICAgIF90aGlzLmFkZGVkU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgICAgIF90aGlzLm1vdmVkU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgICAgIF90aGlzLmRyb3BwZWRTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICAgICAgX3RoaXMucmVtb3Zlc1N1YlRyZWVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICAgICAgICBfdGhpcy5tb3ZlZE1hcCA9IHt9O1xuICAgICAgICAgICAgX3RoaXMubXV0YXRpb25DYihwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImdlblRleHRBcmVhVmFsdWVNdXRhdGlvblwiLCBmdW5jdGlvbih0ZXh0YXJlYSkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBfdGhpcy5hdHRyaWJ1dGVNYXAuZ2V0KHRleHRhcmVhKTtcbiAgICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IHRleHRhcmVhLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVEaWZmOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgX3VuY2hhbmdlZFN0eWxlczoge31cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF90aGlzLmF0dHJpYnV0ZXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hdHRyaWJ1dGVNYXAuc2V0KHRleHRhcmVhLCBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IEFycmF5LmZyb20oaW5kZXguY2hpbGROb2Rlcyh0ZXh0YXJlYSksIGZ1bmN0aW9uKGNuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4LnRleHRDb250ZW50KGNuKSB8fCBcIlwiO1xuICAgICAgICAgICAgfSkuam9pbihcIlwiKTtcbiAgICAgICAgICAgIGl0ZW0uYXR0cmlidXRlcy52YWx1ZSA9IG1hc2tJbnB1dFZhbHVlKHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiB0ZXh0YXJlYSxcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiBfdGhpcy5tYXNrSW5wdXRPcHRpb25zLFxuICAgICAgICAgICAgICAgIHRhZ05hbWU6IHRleHRhcmVhLnRhZ05hbWUsXG4gICAgICAgICAgICAgICAgdHlwZTogZ2V0SW5wdXRUeXBlKHRleHRhcmVhKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgbWFza0lucHV0Rm46IF90aGlzLm1hc2tJbnB1dEZuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcInByb2Nlc3NNdXRhdGlvblwiLCBmdW5jdGlvbihtKSB7XG4gICAgICAgICAgICBpZiAoaXNJZ25vcmVkKG0udGFyZ2V0LCBfdGhpcy5taXJyb3IsIF90aGlzLnNsaW1ET01PcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaChtLnR5cGUpe1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjaGFyYWN0ZXJEYXRhXCI6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGluZGV4LnRleHRDb250ZW50KG0udGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNCbG9ja2VkKG0udGFyZ2V0LCBfdGhpcy5ibG9ja0NsYXNzLCBfdGhpcy5ibG9ja1NlbGVjdG9yLCBmYWxzZSkgJiYgdmFsdWUgIT09IG0ub2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy50ZXh0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5lZWRNYXNraW5nVGV4dChtLnRhcmdldCwgX3RoaXMubWFza1RleHRDbGFzcywgX3RoaXMubWFza1RleHRTZWxlY3RvciwgdHJ1ZSkgJiYgdmFsdWUgPyBfdGhpcy5tYXNrVGV4dEZuID8gX3RoaXMubWFza1RleHRGbih2YWx1ZSwgY2xvc2VzdEVsZW1lbnRPZk5vZGUobS50YXJnZXQpKSA6IHZhbHVlLnJlcGxhY2UoL1tcXFNdL2csIFwiKlwiKSA6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlOiBtLnRhcmdldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiYXR0cmlidXRlc1wiOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gbS50YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IG0uYXR0cmlidXRlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTEgPSBtLnRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSA9PT0gXCJ2YWx1ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBnZXRJbnB1dFR5cGUodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTEgPSBtYXNrSW5wdXRWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFza0lucHV0T3B0aW9uczogX3RoaXMubWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnTmFtZTogdGFyZ2V0LnRhZ05hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tJbnB1dEZuOiBfdGhpcy5tYXNrSW5wdXRGblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQmxvY2tlZChtLnRhcmdldCwgX3RoaXMuYmxvY2tDbGFzcywgX3RoaXMuYmxvY2tTZWxlY3RvciwgZmFsc2UpIHx8IHZhbHVlMSA9PT0gbS5vbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gX3RoaXMuYXR0cmlidXRlTWFwLmdldChtLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LnRhZ05hbWUgPT09IFwiSUZSQU1FXCIgJiYgYXR0cmlidXRlTmFtZSA9PT0gXCJzcmNcIiAmJiAhX3RoaXMua2VlcElmcmFtZVNyY0ZuKHZhbHVlMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldC5jb250ZW50RG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZSA9IFwicnJfc3JjXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IG0udGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVEaWZmOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3VuY2hhbmdlZFN0eWxlczoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJpYnV0ZXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRyaWJ1dGVNYXAuc2V0KG0udGFyZ2V0LCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVOYW1lID09PSBcInR5cGVcIiAmJiB0YXJnZXQudGFnTmFtZSA9PT0gXCJJTlBVVFwiICYmIChtLm9sZFZhbHVlIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkgPT09IFwicGFzc3dvcmRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXJyLWlzLXBhc3N3b3JkXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaWdub3JlQXR0cmlidXRlKHRhcmdldC50YWdOYW1lLCBhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSA9IHRyYW5zZm9ybUF0dHJpYnV0ZShfdGhpcy5kb2MsIHRvTG93ZXJDYXNlKHRhcmdldC50YWdOYW1lKSwgdG9Mb3dlckNhc2UoYXR0cmlidXRlTmFtZSksIHZhbHVlMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUgPT09IFwic3R5bGVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnVuYXR0YWNoZWREb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudW5hdHRhY2hlZERvYyA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy51bmF0dGFjaGVkRG9jID0gX3RoaXMuZG9jO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbGQgPSBfdGhpcy51bmF0dGFjaGVkRG9jLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobS5vbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIG0ub2xkVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKEFycmF5LmZyb20odGFyZ2V0LnN0eWxlKSksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwbmFtZSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gdGFyZ2V0LnN0eWxlLmdldFByb3BlcnR5VmFsdWUocG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1ByaW9yaXR5ID0gdGFyZ2V0LnN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkocG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBvbGQuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwbmFtZSkgfHwgbmV3UHJpb3JpdHkgIT09IG9sZC5zdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KHBuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdQcmlvcml0eSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnN0eWxlRGlmZltwbmFtZV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnN0eWxlRGlmZltwbmFtZV0gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ByaW9yaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLl91bmNoYW5nZWRTdHlsZXNbcG5hbWVdID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJpb3JpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yMSA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShBcnJheS5mcm9tKG9sZC5zdHlsZSkpLCBfc3RlcDE7ICEoX3N0ZXAxID0gX2l0ZXJhdG9yMSgpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG5hbWUxID0gX3N0ZXAxLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHBuYW1lMSkgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnN0eWxlRGlmZltwbmFtZTFdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZU5hbWUgPT09IFwib3BlblwiICYmIHRhcmdldC50YWdOYW1lID09PSBcIkRJQUxPR1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQubWF0Y2hlcyhcImRpYWxvZzptb2RhbFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5hdHRyaWJ1dGVzW1wicnJfb3Blbl9tb2RlXCJdID0gXCJtb2RhbFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5hdHRyaWJ1dGVzW1wicnJfb3Blbl9tb2RlXCJdID0gXCJub24tbW9kYWxcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkTGlzdFwiOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNCbG9ja2VkKG0udGFyZ2V0LCBfdGhpcy5ibG9ja0NsYXNzLCBfdGhpcy5ibG9ja1NlbGVjdG9yLCB0cnVlKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0udGFyZ2V0LnRhZ05hbWUgPT09IFwiVEVYVEFSRUFcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmdlblRleHRBcmVhVmFsdWVNdXRhdGlvbihtLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbS5hZGRlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24objIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2VuQWRkcyhuMiwgbS50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnJlbW92ZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG4yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVJZCA9IF90aGlzLm1pcnJvci5nZXRJZChuMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudElkID0gaXNTaGFkb3dSb290KG0udGFyZ2V0KSA/IF90aGlzLm1pcnJvci5nZXRJZChpbmRleC5ob3N0KG0udGFyZ2V0KSkgOiBfdGhpcy5taXJyb3IuZ2V0SWQobS50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Jsb2NrZWQobS50YXJnZXQsIF90aGlzLmJsb2NrQ2xhc3MsIF90aGlzLmJsb2NrU2VsZWN0b3IsIGZhbHNlKSB8fCBpc0lnbm9yZWQobjIsIF90aGlzLm1pcnJvciwgX3RoaXMuc2xpbURPTU9wdGlvbnMpIHx8ICFpc1NlcmlhbGl6ZWQobjIsIF90aGlzLm1pcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYWRkZWRTZXQuaGFzKG4yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWVwRGVsZXRlKF90aGlzLmFkZGVkU2V0LCBuMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmRyb3BwZWRTZXQuYWRkKG4yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKF90aGlzLmFkZGVkU2V0LmhhcyhtLnRhcmdldCkgJiYgbm9kZUlkID09PSAtMSkgO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzQW5jZXN0b3JSZW1vdmVkKG0udGFyZ2V0LCBfdGhpcy5taXJyb3IpKSA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMubW92ZWRTZXQuaGFzKG4yKSAmJiBfdGhpcy5tb3ZlZE1hcFttb3ZlS2V5KG5vZGVJZCwgcGFyZW50SWQpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWVwRGVsZXRlKF90aGlzLm1vdmVkU2V0LCBuMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVtb3Zlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiBwYXJlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBub2RlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1NoYWRvdzogaXNTaGFkb3dSb290KG0udGFyZ2V0KSAmJiBpc05hdGl2ZVNoYWRvd0RvbShtLnRhcmdldCkgPyB0cnVlIDogdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzUmVtb3ZlcyhuMiwgX3RoaXMucmVtb3Zlc1N1YlRyZWVDYWNoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm1hcFJlbW92ZXMucHVzaChuMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgKiBNYWtlIHN1cmUgeW91IGNoZWNrIGlmIGBuYCdzIHBhcmVudCBpcyBibG9ja2VkIGJlZm9yZSBjYWxsaW5nIHRoaXMgZnVuY3Rpb25cbiAgICAgKiAqLyBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJnZW5BZGRzXCIsIGZ1bmN0aW9uKG4yLCB0YXJnZXQpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9jZXNzZWROb2RlTWFuYWdlci5pbk90aGVyQnVmZmVyKG4yLCBfdGhpcykpIHJldHVybjtcbiAgICAgICAgICAgIGlmIChfdGhpcy5hZGRlZFNldC5oYXMobjIpIHx8IF90aGlzLm1vdmVkU2V0LmhhcyhuMikpIHJldHVybjtcbiAgICAgICAgICAgIGlmIChfdGhpcy5taXJyb3IuaGFzTm9kZShuMikpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNJZ25vcmVkKG4yLCBfdGhpcy5taXJyb3IsIF90aGlzLnNsaW1ET01PcHRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLm1vdmVkU2V0LmFkZChuMik7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldElkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ICYmIF90aGlzLm1pcnJvci5oYXNOb2RlKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0SWQgPSBfdGhpcy5taXJyb3IuZ2V0SWQodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldElkICYmIHRhcmdldElkICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5tb3ZlZE1hcFttb3ZlS2V5KF90aGlzLm1pcnJvci5nZXRJZChuMiksIHRhcmdldElkKV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWRkZWRTZXQuYWRkKG4yKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5kcm9wcGVkU2V0LmRlbGV0ZShuMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzQmxvY2tlZChuMiwgX3RoaXMuYmxvY2tDbGFzcywgX3RoaXMuYmxvY2tTZWxlY3RvciwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXguY2hpbGROb2RlcyhuMikuZm9yRWFjaChmdW5jdGlvbihjaGlsZE4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdlbkFkZHMoY2hpbGROKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzU2hhZG93Um9vdChuMikpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXguY2hpbGROb2RlcyhpbmRleC5zaGFkb3dSb290KG4yKSkuZm9yRWFjaChmdW5jdGlvbihjaGlsZE4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnByb2Nlc3NlZE5vZGVNYW5hZ2VyLmFkZChjaGlsZE4sIF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmdlbkFkZHMoY2hpbGROLCBuMik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBNdXRhdGlvbkJ1ZmZlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmluaXQgPSBmdW5jdGlvbiBpbml0KG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgW1xuICAgICAgICAgICAgXCJtdXRhdGlvbkNiXCIsXG4gICAgICAgICAgICBcImJsb2NrQ2xhc3NcIixcbiAgICAgICAgICAgIFwiYmxvY2tTZWxlY3RvclwiLFxuICAgICAgICAgICAgXCJtYXNrVGV4dENsYXNzXCIsXG4gICAgICAgICAgICBcIm1hc2tUZXh0U2VsZWN0b3JcIixcbiAgICAgICAgICAgIFwiaW5saW5lU3R5bGVzaGVldFwiLFxuICAgICAgICAgICAgXCJtYXNrSW5wdXRPcHRpb25zXCIsXG4gICAgICAgICAgICBcIm1hc2tUZXh0Rm5cIixcbiAgICAgICAgICAgIFwibWFza0lucHV0Rm5cIixcbiAgICAgICAgICAgIFwia2VlcElmcmFtZVNyY0ZuXCIsXG4gICAgICAgICAgICBcInJlY29yZENhbnZhc1wiLFxuICAgICAgICAgICAgXCJpbmxpbmVJbWFnZXNcIixcbiAgICAgICAgICAgIFwic2xpbURPTU9wdGlvbnNcIixcbiAgICAgICAgICAgIFwiZGF0YVVSTE9wdGlvbnNcIixcbiAgICAgICAgICAgIFwiZG9jXCIsXG4gICAgICAgICAgICBcIm1pcnJvclwiLFxuICAgICAgICAgICAgXCJpZnJhbWVNYW5hZ2VyXCIsXG4gICAgICAgICAgICBcInN0eWxlc2hlZXRNYW5hZ2VyXCIsXG4gICAgICAgICAgICBcInNoYWRvd0RvbU1hbmFnZXJcIixcbiAgICAgICAgICAgIFwiY2FudmFzTWFuYWdlclwiLFxuICAgICAgICAgICAgXCJwcm9jZXNzZWROb2RlTWFuYWdlclwiXG4gICAgICAgIF0uZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIF90aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmZyZWV6ZSA9IGZ1bmN0aW9uIGZyZWV6ZSgpIHtcbiAgICAgICAgdGhpcy5mcm96ZW4gPSB0cnVlO1xuICAgICAgICB0aGlzLmNhbnZhc01hbmFnZXIuZnJlZXplKCk7XG4gICAgfTtcbiAgICBfcHJvdG8udW5mcmVlemUgPSBmdW5jdGlvbiB1bmZyZWV6ZSgpIHtcbiAgICAgICAgdGhpcy5mcm96ZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYW52YXNNYW5hZ2VyLnVuZnJlZXplKCk7XG4gICAgICAgIHRoaXMuZW1pdCgpO1xuICAgIH07XG4gICAgX3Byb3RvLmlzRnJvemVuID0gZnVuY3Rpb24gaXNGcm96ZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb3plbjtcbiAgICB9O1xuICAgIF9wcm90by5sb2NrID0gZnVuY3Rpb24gbG9jaygpIHtcbiAgICAgICAgdGhpcy5sb2NrZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNhbnZhc01hbmFnZXIubG9jaygpO1xuICAgIH07XG4gICAgX3Byb3RvLnVubG9jayA9IGZ1bmN0aW9uIHVubG9jaygpIHtcbiAgICAgICAgdGhpcy5sb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYW52YXNNYW5hZ2VyLnVubG9jaygpO1xuICAgICAgICB0aGlzLmVtaXQoKTtcbiAgICB9O1xuICAgIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnNoYWRvd0RvbU1hbmFnZXIucmVzZXQoKTtcbiAgICAgICAgdGhpcy5jYW52YXNNYW5hZ2VyLnJlc2V0KCk7XG4gICAgfTtcbiAgICByZXR1cm4gTXV0YXRpb25CdWZmZXI7XG59KCk7XG5mdW5jdGlvbiBkZWVwRGVsZXRlKGFkZHNTZXQsIG4yKSB7XG4gICAgYWRkc1NldC5kZWxldGUobjIpO1xuICAgIGluZGV4LmNoaWxkTm9kZXMobjIpLmZvckVhY2goZnVuY3Rpb24oY2hpbGROKSB7XG4gICAgICAgIHJldHVybiBkZWVwRGVsZXRlKGFkZHNTZXQsIGNoaWxkTik7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBwcm9jZXNzUmVtb3ZlcyhuMiwgY2FjaGUpIHtcbiAgICB2YXIgcXVldWUgPSBbXG4gICAgICAgIG4yXG4gICAgXTtcbiAgICB3aGlsZShxdWV1ZS5sZW5ndGgpe1xuICAgICAgICB2YXIgbmV4dCA9IHF1ZXVlLnBvcCgpO1xuICAgICAgICBpZiAoY2FjaGUuaGFzKG5leHQpKSBjb250aW51ZTtcbiAgICAgICAgY2FjaGUuYWRkKG5leHQpO1xuICAgICAgICBpbmRleC5jaGlsZE5vZGVzKG5leHQpLmZvckVhY2goZnVuY3Rpb24objIyKSB7XG4gICAgICAgICAgICByZXR1cm4gcXVldWUucHVzaChuMjIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuO1xufVxuZnVuY3Rpb24gaXNQYXJlbnRSZW1vdmVkKHJlbW92ZXMsIG4yLCBtaXJyb3IyKSB7XG4gICAgaWYgKHJlbW92ZXMuc2l6ZSA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBfaXNQYXJlbnRSZW1vdmVkKHJlbW92ZXMsIG4yKTtcbn1cbmZ1bmN0aW9uIF9pc1BhcmVudFJlbW92ZWQocmVtb3ZlcywgbjIsIF9taXJyb3IyKSB7XG4gICAgdmFyIG5vZGUyID0gaW5kZXgucGFyZW50Tm9kZShuMik7XG4gICAgaWYgKCFub2RlMikgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiByZW1vdmVzLmhhcyhub2RlMik7XG59XG5mdW5jdGlvbiBpc0FuY2VzdG9ySW5TZXQoc2V0LCBuMikge1xuICAgIGlmIChzZXQuc2l6ZSA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBfaXNBbmNlc3RvckluU2V0KHNldCwgbjIpO1xufVxuZnVuY3Rpb24gX2lzQW5jZXN0b3JJblNldChzZXQsIG4yKSB7XG4gICAgdmFyIHBhcmVudCA9IGluZGV4LnBhcmVudE5vZGUobjIpO1xuICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHNldC5oYXMocGFyZW50KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIF9pc0FuY2VzdG9ySW5TZXQoc2V0LCBwYXJlbnQpO1xufVxudmFyIGVycm9ySGFuZGxlcjtcbmZ1bmN0aW9uIHJlZ2lzdGVyRXJyb3JIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICBlcnJvckhhbmRsZXIgPSBoYW5kbGVyO1xufVxuZnVuY3Rpb24gdW5yZWdpc3RlckVycm9ySGFuZGxlcigpIHtcbiAgICBlcnJvckhhbmRsZXIgPSB2b2lkIDA7XG59XG52YXIgY2FsbGJhY2tXcmFwcGVyID0gZnVuY3Rpb24oY2IpIHtcbiAgICBpZiAoIWVycm9ySGFuZGxlcikge1xuICAgICAgICByZXR1cm4gY2I7XG4gICAgfVxuICAgIHZhciBycndlYldyYXBwZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgcmVzdFtfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGNiLmFwcGx5KHZvaWQgMCwgW10uY29uY2F0KHJlc3QpKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvckhhbmRsZXIgJiYgZXJyb3JIYW5kbGVyKGVycm9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcnJ3ZWJXcmFwcGVkO1xufTtcbnZhciBtdXRhdGlvbkJ1ZmZlcnMgPSBbXTtcbmZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0KGV2ZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKFwiY29tcG9zZWRQYXRoXCIgaW4gZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoKCk7XG4gICAgICAgICAgICBpZiAocGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChcInBhdGhcIiBpbiBldmVudCAmJiBldmVudC5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnBhdGhbMF07XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBldmVudCAmJiBldmVudC50YXJnZXQ7XG59XG5mdW5jdGlvbiBpbml0TXV0YXRpb25PYnNlcnZlcihvcHRpb25zLCByb290RWwpIHtcbiAgICB2YXIgbXV0YXRpb25CdWZmZXIgPSBuZXcgTXV0YXRpb25CdWZmZXIoKTtcbiAgICBtdXRhdGlvbkJ1ZmZlcnMucHVzaChtdXRhdGlvbkJ1ZmZlcik7XG4gICAgbXV0YXRpb25CdWZmZXIuaW5pdChvcHRpb25zKTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgKG11dGF0aW9uT2JzZXJ2ZXJDdG9yKCkpKGNhbGxiYWNrV3JhcHBlcihtdXRhdGlvbkJ1ZmZlci5wcm9jZXNzTXV0YXRpb25zLmJpbmQobXV0YXRpb25CdWZmZXIpKSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShyb290RWwsIHtcbiAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgYXR0cmlidXRlT2xkVmFsdWU6IHRydWUsXG4gICAgICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gICAgICAgIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogdHJ1ZSxcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIG9ic2VydmVyO1xufVxuZnVuY3Rpb24gaW5pdE1vdmVPYnNlcnZlcihwYXJhbSkge1xuICAgIHZhciBtb3VzZW1vdmVDYiA9IHBhcmFtLm1vdXNlbW92ZUNiLCBzYW1wbGluZyA9IHBhcmFtLnNhbXBsaW5nLCBkb2MgPSBwYXJhbS5kb2MsIG1pcnJvcjIgPSBwYXJhbS5taXJyb3I7XG4gICAgaWYgKHNhbXBsaW5nLm1vdXNlbW92ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge307XG4gICAgfVxuICAgIHZhciB0aHJlc2hvbGQgPSB0eXBlb2Ygc2FtcGxpbmcubW91c2Vtb3ZlID09PSBcIm51bWJlclwiID8gc2FtcGxpbmcubW91c2Vtb3ZlIDogNTA7XG4gICAgdmFyIGNhbGxiYWNrVGhyZXNob2xkID0gdHlwZW9mIHNhbXBsaW5nLm1vdXNlbW92ZUNhbGxiYWNrID09PSBcIm51bWJlclwiID8gc2FtcGxpbmcubW91c2Vtb3ZlQ2FsbGJhY2sgOiA1MDA7XG4gICAgdmFyIHBvc2l0aW9ucyA9IFtdO1xuICAgIHZhciB0aW1lQmFzZWxpbmU7XG4gICAgdmFyIHdyYXBwZWRDYiA9IHRocm90dGxlKGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgdmFyIHRvdGFsT2Zmc2V0ID0gRGF0ZS5ub3coKSAtIHRpbWVCYXNlbGluZTtcbiAgICAgICAgbW91c2Vtb3ZlQ2IocG9zaXRpb25zLm1hcChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICBwLnRpbWVPZmZzZXQgLT0gdG90YWxPZmZzZXQ7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSksIHNvdXJjZSk7XG4gICAgICAgIHBvc2l0aW9ucyA9IFtdO1xuICAgICAgICB0aW1lQmFzZWxpbmUgPSBudWxsO1xuICAgIH0pLCBjYWxsYmFja1RocmVzaG9sZCk7XG4gICAgdmFyIHVwZGF0ZVBvc2l0aW9uID0gY2FsbGJhY2tXcmFwcGVyKHRocm90dGxlKGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbihldnQpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2dCk7XG4gICAgICAgIHZhciBfcmVmID0gbGVnYWN5X2lzVG91Y2hFdmVudChldnQpID8gZXZ0LmNoYW5nZWRUb3VjaGVzWzBdIDogZXZ0LCBjbGllbnRYID0gX3JlZi5jbGllbnRYLCBjbGllbnRZID0gX3JlZi5jbGllbnRZO1xuICAgICAgICBpZiAoIXRpbWVCYXNlbGluZSkge1xuICAgICAgICAgICAgdGltZUJhc2VsaW5lID0gbm93VGltZXN0YW1wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpb25zLnB1c2goe1xuICAgICAgICAgICAgeDogY2xpZW50WCxcbiAgICAgICAgICAgIHk6IGNsaWVudFksXG4gICAgICAgICAgICBpZDogbWlycm9yMi5nZXRJZCh0YXJnZXQpLFxuICAgICAgICAgICAgdGltZU9mZnNldDogbm93VGltZXN0YW1wKCkgLSB0aW1lQmFzZWxpbmVcbiAgICAgICAgfSk7XG4gICAgICAgIHdyYXBwZWRDYih0eXBlb2YgRHJhZ0V2ZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIF9pbnN0YW5jZW9mKGV2dCwgRHJhZ0V2ZW50KSA/IEluY3JlbWVudGFsU291cmNlLkRyYWcgOiBfaW5zdGFuY2VvZihldnQsIE1vdXNlRXZlbnQpID8gSW5jcmVtZW50YWxTb3VyY2UuTW91c2VNb3ZlIDogSW5jcmVtZW50YWxTb3VyY2UuVG91Y2hNb3ZlKTtcbiAgICB9KSwgdGhyZXNob2xkLCB7XG4gICAgICAgIHRyYWlsaW5nOiBmYWxzZVxuICAgIH0pKTtcbiAgICB2YXIgaGFuZGxlcnMgPSBbXG4gICAgICAgIG9uKFwibW91c2Vtb3ZlXCIsIHVwZGF0ZVBvc2l0aW9uLCBkb2MpLFxuICAgICAgICBvbihcInRvdWNobW92ZVwiLCB1cGRhdGVQb3NpdGlvbiwgZG9jKSxcbiAgICAgICAgb24oXCJkcmFnXCIsIHVwZGF0ZVBvc2l0aW9uLCBkb2MpXG4gICAgXTtcbiAgICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgIHJldHVybiBoKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaW5pdE1vdXNlSW50ZXJhY3Rpb25PYnNlcnZlcihwYXJhbSkge1xuICAgIHZhciBtb3VzZUludGVyYWN0aW9uQ2IgPSBwYXJhbS5tb3VzZUludGVyYWN0aW9uQ2IsIGRvYyA9IHBhcmFtLmRvYywgbWlycm9yMiA9IHBhcmFtLm1pcnJvciwgYmxvY2tDbGFzcyA9IHBhcmFtLmJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IgPSBwYXJhbS5ibG9ja1NlbGVjdG9yLCBzYW1wbGluZyA9IHBhcmFtLnNhbXBsaW5nO1xuICAgIGlmIChzYW1wbGluZy5tb3VzZUludGVyYWN0aW9uID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gICAgdmFyIGRpc2FibGVNYXAgPSBzYW1wbGluZy5tb3VzZUludGVyYWN0aW9uID09PSB0cnVlIHx8IHNhbXBsaW5nLm1vdXNlSW50ZXJhY3Rpb24gPT09IHZvaWQgMCA/IHt9IDogc2FtcGxpbmcubW91c2VJbnRlcmFjdGlvbjtcbiAgICB2YXIgaGFuZGxlcnMgPSBbXTtcbiAgICB2YXIgY3VycmVudFBvaW50ZXJUeXBlID0gbnVsbDtcbiAgICB2YXIgZ2V0SGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50S2V5KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcbiAgICAgICAgICAgIGlmIChpc0Jsb2NrZWQodGFyZ2V0LCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwb2ludGVyVHlwZSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgdGhpc0V2ZW50S2V5ID0gZXZlbnRLZXk7XG4gICAgICAgICAgICBpZiAoXCJwb2ludGVyVHlwZVwiIGluIGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoKGV2ZW50LnBvaW50ZXJUeXBlKXtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1vdXNlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZSA9IFBvaW50ZXJUeXBlcy5Nb3VzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidG91Y2hcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlID0gUG9pbnRlclR5cGVzLlRvdWNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJwZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlID0gUG9pbnRlclR5cGVzLlBlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9pbnRlclR5cGUgPT09IFBvaW50ZXJUeXBlcy5Ub3VjaCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoTW91c2VJbnRlcmFjdGlvbnNbZXZlbnRLZXldID09PSBNb3VzZUludGVyYWN0aW9ucy5Nb3VzZURvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNFdmVudEtleSA9IFwiVG91Y2hTdGFydFwiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKE1vdXNlSW50ZXJhY3Rpb25zW2V2ZW50S2V5XSA9PT0gTW91c2VJbnRlcmFjdGlvbnMuTW91c2VVcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0V2ZW50S2V5ID0gXCJUb3VjaEVuZFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwb2ludGVyVHlwZSA9PT0gUG9pbnRlclR5cGVzLlBlbikgO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsZWdhY3lfaXNUb3VjaEV2ZW50KGV2ZW50KSkge1xuICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlID0gUG9pbnRlclR5cGVzLlRvdWNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvaW50ZXJUeXBlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFBvaW50ZXJUeXBlID0gcG9pbnRlclR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNFdmVudEtleS5zdGFydHNXaXRoKFwiVG91Y2hcIikgJiYgcG9pbnRlclR5cGUgPT09IFBvaW50ZXJUeXBlcy5Ub3VjaCB8fCB0aGlzRXZlbnRLZXkuc3RhcnRzV2l0aChcIk1vdXNlXCIpICYmIHBvaW50ZXJUeXBlID09PSBQb2ludGVyVHlwZXMuTW91c2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTW91c2VJbnRlcmFjdGlvbnNbZXZlbnRLZXldID09PSBNb3VzZUludGVyYWN0aW9ucy5DbGljaykge1xuICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlID0gY3VycmVudFBvaW50ZXJUeXBlO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQb2ludGVyVHlwZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZTIgPSBsZWdhY3lfaXNUb3VjaEV2ZW50KGV2ZW50KSA/IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdIDogZXZlbnQ7XG4gICAgICAgICAgICBpZiAoIWUyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGlkID0gbWlycm9yMi5nZXRJZCh0YXJnZXQpO1xuICAgICAgICAgICAgdmFyIGNsaWVudFggPSBlMi5jbGllbnRYLCBjbGllbnRZID0gZTIuY2xpZW50WTtcbiAgICAgICAgICAgIGNhbGxiYWNrV3JhcHBlcihtb3VzZUludGVyYWN0aW9uQ2IpKF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBNb3VzZUludGVyYWN0aW9uc1t0aGlzRXZlbnRLZXldLFxuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICB4OiBjbGllbnRYLFxuICAgICAgICAgICAgICAgIHk6IGNsaWVudFlcbiAgICAgICAgICAgIH0sIHBvaW50ZXJUeXBlICE9PSBudWxsICYmIHtcbiAgICAgICAgICAgICAgICBwb2ludGVyVHlwZTogcG9pbnRlclR5cGVcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE9iamVjdC5rZXlzKE1vdXNlSW50ZXJhY3Rpb25zKS5maWx0ZXIoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIuaXNOYU4oTnVtYmVyKGtleSkpICYmICFrZXkuZW5kc1dpdGgoXCJfRGVwYXJ0ZWRcIikgJiYgZGlzYWJsZU1hcFtrZXldICE9PSBmYWxzZTtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50S2V5KSB7XG4gICAgICAgIHZhciBldmVudE5hbWUgPSB0b0xvd2VyQ2FzZShldmVudEtleSk7XG4gICAgICAgIHZhciBoYW5kbGVyID0gZ2V0SGFuZGxlcihldmVudEtleSk7XG4gICAgICAgIGlmICh3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG4gICAgICAgICAgICBzd2l0Y2goTW91c2VJbnRlcmFjdGlvbnNbZXZlbnRLZXldKXtcbiAgICAgICAgICAgICAgICBjYXNlIE1vdXNlSW50ZXJhY3Rpb25zLk1vdXNlRG93bjpcbiAgICAgICAgICAgICAgICBjYXNlIE1vdXNlSW50ZXJhY3Rpb25zLk1vdXNlVXA6XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZS5yZXBsYWNlKFwibW91c2VcIiwgXCJwb2ludGVyXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIE1vdXNlSW50ZXJhY3Rpb25zLlRvdWNoU3RhcnQ6XG4gICAgICAgICAgICAgICAgY2FzZSBNb3VzZUludGVyYWN0aW9ucy5Ub3VjaEVuZDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGhhbmRsZXJzLnB1c2gob24oZXZlbnROYW1lLCBoYW5kbGVyLCBkb2MpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgIHJldHVybiBoKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaW5pdFNjcm9sbE9ic2VydmVyKHBhcmFtKSB7XG4gICAgdmFyIHNjcm9sbENiID0gcGFyYW0uc2Nyb2xsQ2IsIGRvYyA9IHBhcmFtLmRvYywgbWlycm9yMiA9IHBhcmFtLm1pcnJvciwgYmxvY2tDbGFzcyA9IHBhcmFtLmJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IgPSBwYXJhbS5ibG9ja1NlbGVjdG9yLCBzYW1wbGluZyA9IHBhcmFtLnNhbXBsaW5nO1xuICAgIHZhciB1cGRhdGVQb3NpdGlvbiA9IGNhbGxiYWNrV3JhcHBlcih0aHJvdHRsZShjYWxsYmFja1dyYXBwZXIoZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldnQpO1xuICAgICAgICBpZiAoIXRhcmdldCB8fCBpc0Jsb2NrZWQodGFyZ2V0LCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpZCA9IG1pcnJvcjIuZ2V0SWQodGFyZ2V0KTtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gZG9jICYmIGRvYy5kZWZhdWx0Vmlldykge1xuICAgICAgICAgICAgdmFyIHNjcm9sbExlZnRUb3AgPSBnZXRXaW5kb3dTY3JvbGwoZG9jLmRlZmF1bHRWaWV3KTtcbiAgICAgICAgICAgIHNjcm9sbENiKHtcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgeDogc2Nyb2xsTGVmdFRvcC5sZWZ0LFxuICAgICAgICAgICAgICAgIHk6IHNjcm9sbExlZnRUb3AudG9wXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNjcm9sbENiKHtcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgeDogdGFyZ2V0LnNjcm9sbExlZnQsXG4gICAgICAgICAgICAgICAgeTogdGFyZ2V0LnNjcm9sbFRvcFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KSwgc2FtcGxpbmcuc2Nyb2xsIHx8IDEwMCkpO1xuICAgIHJldHVybiBvbihcInNjcm9sbFwiLCB1cGRhdGVQb3NpdGlvbiwgZG9jKTtcbn1cbmZ1bmN0aW9uIGluaXRWaWV3cG9ydFJlc2l6ZU9ic2VydmVyKHBhcmFtLCBwYXJhbTEpIHtcbiAgICB2YXIgdmlld3BvcnRSZXNpemVDYiA9IHBhcmFtLnZpZXdwb3J0UmVzaXplQ2I7XG4gICAgdmFyIHdpbiA9IHBhcmFtMS53aW47XG4gICAgdmFyIGxhc3RIID0gLTE7XG4gICAgdmFyIGxhc3RXID0gLTE7XG4gICAgdmFyIHVwZGF0ZURpbWVuc2lvbiA9IGNhbGxiYWNrV3JhcHBlcih0aHJvdHRsZShjYWxsYmFja1dyYXBwZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSBnZXRXaW5kb3dIZWlnaHQoKTtcbiAgICAgICAgdmFyIHdpZHRoID0gZ2V0V2luZG93V2lkdGgoKTtcbiAgICAgICAgaWYgKGxhc3RIICE9PSBoZWlnaHQgfHwgbGFzdFcgIT09IHdpZHRoKSB7XG4gICAgICAgICAgICB2aWV3cG9ydFJlc2l6ZUNiKHtcbiAgICAgICAgICAgICAgICB3aWR0aDogTnVtYmVyKHdpZHRoKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IE51bWJlcihoZWlnaHQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxhc3RIID0gaGVpZ2h0O1xuICAgICAgICAgICAgbGFzdFcgPSB3aWR0aDtcbiAgICAgICAgfVxuICAgIH0pLCAyMDApKTtcbiAgICByZXR1cm4gb24oXCJyZXNpemVcIiwgdXBkYXRlRGltZW5zaW9uLCB3aW4pO1xufVxudmFyIElOUFVUX1RBR1MgPSBbXG4gICAgXCJJTlBVVFwiLFxuICAgIFwiVEVYVEFSRUFcIixcbiAgICBcIlNFTEVDVFwiXG5dO1xudmFyIGxhc3RJbnB1dFZhbHVlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBpbml0SW5wdXRPYnNlcnZlcihwYXJhbSkge1xuICAgIHZhciBpbnB1dENiID0gcGFyYW0uaW5wdXRDYiwgZG9jID0gcGFyYW0uZG9jLCBtaXJyb3IyID0gcGFyYW0ubWlycm9yLCBibG9ja0NsYXNzID0gcGFyYW0uYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciA9IHBhcmFtLmJsb2NrU2VsZWN0b3IsIGlnbm9yZUNsYXNzID0gcGFyYW0uaWdub3JlQ2xhc3MsIGlnbm9yZVNlbGVjdG9yID0gcGFyYW0uaWdub3JlU2VsZWN0b3IsIG1hc2tJbnB1dE9wdGlvbnMgPSBwYXJhbS5tYXNrSW5wdXRPcHRpb25zLCBtYXNrSW5wdXRGbiA9IHBhcmFtLm1hc2tJbnB1dEZuLCBzYW1wbGluZyA9IHBhcmFtLnNhbXBsaW5nLCB1c2VyVHJpZ2dlcmVkT25JbnB1dCA9IHBhcmFtLnVzZXJUcmlnZ2VyZWRPbklucHV0O1xuICAgIGZ1bmN0aW9uIGV2ZW50SGFuZGxlcihldmVudCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpO1xuICAgICAgICB2YXIgdXNlclRyaWdnZXJlZCA9IGV2ZW50LmlzVHJ1c3RlZDtcbiAgICAgICAgdmFyIHRhZ05hbWUgPSB0YXJnZXQgJiYgdGFyZ2V0LnRhZ05hbWU7XG4gICAgICAgIGlmICh0YXJnZXQgJiYgdGFnTmFtZSA9PT0gXCJPUFRJT05cIikge1xuICAgICAgICAgICAgdGFyZ2V0ID0gaW5kZXgucGFyZW50RWxlbWVudCh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGFyZ2V0IHx8ICF0YWdOYW1lIHx8IElOUFVUX1RBR1MuaW5kZXhPZih0YWdOYW1lKSA8IDAgfHwgaXNCbG9ja2VkKHRhcmdldCwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhpZ25vcmVDbGFzcykgfHwgaWdub3JlU2VsZWN0b3IgJiYgdGFyZ2V0Lm1hdGNoZXMoaWdub3JlU2VsZWN0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRleHQgPSB0YXJnZXQudmFsdWU7XG4gICAgICAgIHZhciBpc0NoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHR5cGUgPSBnZXRJbnB1dFR5cGUodGFyZ2V0KSB8fCBcIlwiO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJyYWRpb1wiIHx8IHR5cGUgPT09IFwiY2hlY2tib3hcIikge1xuICAgICAgICAgICAgaXNDaGVja2VkID0gdGFyZ2V0LmNoZWNrZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAobWFza0lucHV0T3B0aW9uc1t0YWdOYW1lLnRvTG93ZXJDYXNlKCldIHx8IG1hc2tJbnB1dE9wdGlvbnNbdHlwZV0pIHtcbiAgICAgICAgICAgIHRleHQgPSBtYXNrSW5wdXRWYWx1ZSh7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogdGFyZ2V0LFxuICAgICAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnM6IG1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgdGFnTmFtZTogdGFnTmFtZSxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0ZXh0LFxuICAgICAgICAgICAgICAgIG1hc2tJbnB1dEZuOiBtYXNrSW5wdXRGblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2JXaXRoRGVkdXAodGFyZ2V0LCB1c2VyVHJpZ2dlcmVkT25JbnB1dCA/IHtcbiAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICBpc0NoZWNrZWQ6IGlzQ2hlY2tlZCxcbiAgICAgICAgICAgIHVzZXJUcmlnZ2VyZWQ6IHVzZXJUcmlnZ2VyZWRcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICBpc0NoZWNrZWQ6IGlzQ2hlY2tlZFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG5hbWUgPSB0YXJnZXQubmFtZTtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwicmFkaW9cIiAmJiBuYW1lICYmIGlzQ2hlY2tlZCkge1xuICAgICAgICAgICAgZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJyYWRpb1wiXVtuYW1lPVwiJyArIG5hbWUgKyAnXCJdJykuZm9yRWFjaChmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAgIGlmIChlbCAhPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0MiA9IGVsLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBjYldpdGhEZWR1cChlbCwgdXNlclRyaWdnZXJlZE9uSW5wdXQgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0MixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQ2hlY2tlZDogIWlzQ2hlY2tlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJUcmlnZ2VyZWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0MixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQ2hlY2tlZDogIWlzQ2hlY2tlZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjYldpdGhEZWR1cCh0YXJnZXQsIHYyKSB7XG4gICAgICAgIHZhciBsYXN0SW5wdXRWYWx1ZSA9IGxhc3RJbnB1dFZhbHVlTWFwLmdldCh0YXJnZXQpO1xuICAgICAgICBpZiAoIWxhc3RJbnB1dFZhbHVlIHx8IGxhc3RJbnB1dFZhbHVlLnRleHQgIT09IHYyLnRleHQgfHwgbGFzdElucHV0VmFsdWUuaXNDaGVja2VkICE9PSB2Mi5pc0NoZWNrZWQpIHtcbiAgICAgICAgICAgIGxhc3RJbnB1dFZhbHVlTWFwLnNldCh0YXJnZXQsIHYyKTtcbiAgICAgICAgICAgIHZhciBpZCA9IG1pcnJvcjIuZ2V0SWQodGFyZ2V0KTtcbiAgICAgICAgICAgIGNhbGxiYWNrV3JhcHBlcihpbnB1dENiKShfZXh0ZW5kcyh7fSwgdjIsIHtcbiAgICAgICAgICAgICAgICBpZDogaWRcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgZXZlbnRzID0gc2FtcGxpbmcuaW5wdXQgPT09IFwibGFzdFwiID8gW1xuICAgICAgICBcImNoYW5nZVwiXG4gICAgXSA6IFtcbiAgICAgICAgXCJpbnB1dFwiLFxuICAgICAgICBcImNoYW5nZVwiXG4gICAgXTtcbiAgICB2YXIgaGFuZGxlcnMgPSBldmVudHMubWFwKGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgICByZXR1cm4gb24oZXZlbnROYW1lLCBjYWxsYmFja1dyYXBwZXIoZXZlbnRIYW5kbGVyKSwgZG9jKTtcbiAgICB9KTtcbiAgICB2YXIgY3VycmVudFdpbmRvdyA9IGRvYy5kZWZhdWx0VmlldztcbiAgICBpZiAoIWN1cnJlbnRXaW5kb3cpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGgoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgcHJvcGVydHlEZXNjcmlwdG9yID0gY3VycmVudFdpbmRvdy5PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGN1cnJlbnRXaW5kb3cuSFRNTElucHV0RWxlbWVudC5wcm90b3R5cGUsIFwidmFsdWVcIik7XG4gICAgdmFyIGhvb2tQcm9wZXJ0aWVzID0gW1xuICAgICAgICBbXG4gICAgICAgICAgICBjdXJyZW50V2luZG93LkhUTUxJbnB1dEVsZW1lbnQucHJvdG90eXBlLFxuICAgICAgICAgICAgXCJ2YWx1ZVwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICAgIGN1cnJlbnRXaW5kb3cuSFRNTElucHV0RWxlbWVudC5wcm90b3R5cGUsXG4gICAgICAgICAgICBcImNoZWNrZWRcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICBjdXJyZW50V2luZG93LkhUTUxTZWxlY3RFbGVtZW50LnByb3RvdHlwZSxcbiAgICAgICAgICAgIFwidmFsdWVcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICBjdXJyZW50V2luZG93LkhUTUxUZXh0QXJlYUVsZW1lbnQucHJvdG90eXBlLFxuICAgICAgICAgICAgXCJ2YWx1ZVwiXG4gICAgICAgIF0sXG4gICAgICAgIC8vIFNvbWUgVUkgbGlicmFyeSB1c2Ugc2VsZWN0ZWRJbmRleCB0byBzZXQgc2VsZWN0IHZhbHVlXG4gICAgICAgIFtcbiAgICAgICAgICAgIGN1cnJlbnRXaW5kb3cuSFRNTFNlbGVjdEVsZW1lbnQucHJvdG90eXBlLFxuICAgICAgICAgICAgXCJzZWxlY3RlZEluZGV4XCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgY3VycmVudFdpbmRvdy5IVE1MT3B0aW9uRWxlbWVudC5wcm90b3R5cGUsXG4gICAgICAgICAgICBcInNlbGVjdGVkXCJcbiAgICAgICAgXVxuICAgIF07XG4gICAgaWYgKHByb3BlcnR5RGVzY3JpcHRvciAmJiBwcm9wZXJ0eURlc2NyaXB0b3Iuc2V0KSB7XG4gICAgICAgIHZhciBfaGFuZGxlcnM7XG4gICAgICAgIChfaGFuZGxlcnMgPSBoYW5kbGVycykucHVzaC5hcHBseShfaGFuZGxlcnMsIFtdLmNvbmNhdChob29rUHJvcGVydGllcy5tYXAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgcmV0dXJuIGhvb2tTZXR0ZXIocFswXSwgcFsxXSwge1xuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja1dyYXBwZXIoZXZlbnRIYW5kbGVyKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1RydXN0ZWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGZhbHNlLCBjdXJyZW50V2luZG93KTtcbiAgICAgICAgfSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbigpIHtcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICByZXR1cm4gaCgpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldE5lc3RlZENTU1J1bGVQb3NpdGlvbnMocnVsZTIpIHtcbiAgICB2YXIgcG9zaXRpb25zID0gW107XG4gICAgZnVuY3Rpb24gcmVjdXJzZShjaGlsZFJ1bGUsIHBvcykge1xuICAgICAgICBpZiAoaGFzTmVzdGVkQ1NTUnVsZShcIkNTU0dyb3VwaW5nUnVsZVwiKSAmJiBfaW5zdGFuY2VvZihjaGlsZFJ1bGUucGFyZW50UnVsZSwgQ1NTR3JvdXBpbmdSdWxlKSB8fCBoYXNOZXN0ZWRDU1NSdWxlKFwiQ1NTTWVkaWFSdWxlXCIpICYmIF9pbnN0YW5jZW9mKGNoaWxkUnVsZS5wYXJlbnRSdWxlLCBDU1NNZWRpYVJ1bGUpIHx8IGhhc05lc3RlZENTU1J1bGUoXCJDU1NTdXBwb3J0c1J1bGVcIikgJiYgX2luc3RhbmNlb2YoY2hpbGRSdWxlLnBhcmVudFJ1bGUsIENTU1N1cHBvcnRzUnVsZSkgfHwgaGFzTmVzdGVkQ1NTUnVsZShcIkNTU0NvbmRpdGlvblJ1bGVcIikgJiYgX2luc3RhbmNlb2YoY2hpbGRSdWxlLnBhcmVudFJ1bGUsIENTU0NvbmRpdGlvblJ1bGUpKSB7XG4gICAgICAgICAgICB2YXIgcnVsZXMyID0gQXJyYXkuZnJvbShjaGlsZFJ1bGUucGFyZW50UnVsZS5jc3NSdWxlcyk7XG4gICAgICAgICAgICB2YXIgaW5kZXgyID0gcnVsZXMyLmluZGV4T2YoY2hpbGRSdWxlKTtcbiAgICAgICAgICAgIHBvcy51bnNoaWZ0KGluZGV4Mik7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hpbGRSdWxlLnBhcmVudFN0eWxlU2hlZXQpIHtcbiAgICAgICAgICAgIHZhciBydWxlczIxID0gQXJyYXkuZnJvbShjaGlsZFJ1bGUucGFyZW50U3R5bGVTaGVldC5jc3NSdWxlcyk7XG4gICAgICAgICAgICB2YXIgaW5kZXgyMSA9IHJ1bGVzMjEuaW5kZXhPZihjaGlsZFJ1bGUpO1xuICAgICAgICAgICAgcG9zLnVuc2hpZnQoaW5kZXgyMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgcmV0dXJuIHJlY3Vyc2UocnVsZTIsIHBvc2l0aW9ucyk7XG59XG5mdW5jdGlvbiBnZXRJZEFuZFN0eWxlSWQoc2hlZXQsIG1pcnJvcjIsIHN0eWxlTWlycm9yKSB7XG4gICAgdmFyIGlkLCBzdHlsZUlkO1xuICAgIGlmICghc2hlZXQpIHJldHVybiB7fTtcbiAgICBpZiAoc2hlZXQub3duZXJOb2RlKSBpZCA9IG1pcnJvcjIuZ2V0SWQoc2hlZXQub3duZXJOb2RlKTtcbiAgICBlbHNlIHN0eWxlSWQgPSBzdHlsZU1pcnJvci5nZXRJZChzaGVldCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3R5bGVJZDogc3R5bGVJZCxcbiAgICAgICAgaWQ6IGlkXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGluaXRTdHlsZVNoZWV0T2JzZXJ2ZXIocGFyYW0sIHBhcmFtMSkge1xuICAgIHZhciBzdHlsZVNoZWV0UnVsZUNiID0gcGFyYW0uc3R5bGVTaGVldFJ1bGVDYiwgbWlycm9yMiA9IHBhcmFtLm1pcnJvciwgc3R5bGVzaGVldE1hbmFnZXIgPSBwYXJhbS5zdHlsZXNoZWV0TWFuYWdlcjtcbiAgICB2YXIgd2luID0gcGFyYW0xLndpbjtcbiAgICBpZiAoIXdpbi5DU1NTdHlsZVNoZWV0IHx8ICF3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge307XG4gICAgfVxuICAgIHZhciBpbnNlcnRSdWxlID0gd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmluc2VydFJ1bGU7XG4gICAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmluc2VydFJ1bGUgPSBuZXcgUHJveHkoaW5zZXJ0UnVsZSwge1xuICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkge1xuICAgICAgICAgICAgdmFyIHJ1bGUyID0gYXJndW1lbnRzTGlzdFswXSwgaW5kZXgyID0gYXJndW1lbnRzTGlzdFsxXTtcbiAgICAgICAgICAgIHZhciBfZ2V0SWRBbmRTdHlsZUlkID0gZ2V0SWRBbmRTdHlsZUlkKHRoaXNBcmcsIG1pcnJvcjIsIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yKSwgaWQgPSBfZ2V0SWRBbmRTdHlsZUlkLmlkLCBzdHlsZUlkID0gX2dldElkQW5kU3R5bGVJZC5zdHlsZUlkO1xuICAgICAgICAgICAgaWYgKGlkICYmIGlkICE9PSAtMSB8fCBzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldFJ1bGVDYih7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVJZDogc3R5bGVJZCxcbiAgICAgICAgICAgICAgICAgICAgYWRkczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IHJ1bGUyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleDJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcbiAgICAgICAgfSlcbiAgICB9KTtcbiAgICB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuYWRkUnVsZSA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBzdHlsZUJsb2NrLCBpbmRleDIpIHtcbiAgICAgICAgaWYgKGluZGV4MiA9PT0gdm9pZCAwKSBpbmRleDIgPSB0aGlzLmNzc1J1bGVzLmxlbmd0aDtcbiAgICAgICAgdmFyIHJ1bGUyID0gc2VsZWN0b3IgKyBcIiB7IFwiICsgc3R5bGVCbG9jayArIFwiIH1cIjtcbiAgICAgICAgcmV0dXJuIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5pbnNlcnRSdWxlLmFwcGx5KHRoaXMsIFtcbiAgICAgICAgICAgIHJ1bGUyLFxuICAgICAgICAgICAgaW5kZXgyXG4gICAgICAgIF0pO1xuICAgIH07XG4gICAgdmFyIGRlbGV0ZVJ1bGUgPSB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuZGVsZXRlUnVsZTtcbiAgICB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuZGVsZXRlUnVsZSA9IG5ldyBQcm94eShkZWxldGVSdWxlLCB7XG4gICAgICAgIGFwcGx5OiBjYWxsYmFja1dyYXBwZXIoZnVuY3Rpb24odGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSB7XG4gICAgICAgICAgICB2YXIgaW5kZXgyID0gYXJndW1lbnRzTGlzdFswXTtcbiAgICAgICAgICAgIHZhciBfZ2V0SWRBbmRTdHlsZUlkID0gZ2V0SWRBbmRTdHlsZUlkKHRoaXNBcmcsIG1pcnJvcjIsIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yKSwgaWQgPSBfZ2V0SWRBbmRTdHlsZUlkLmlkLCBzdHlsZUlkID0gX2dldElkQW5kU3R5bGVJZC5zdHlsZUlkO1xuICAgICAgICAgICAgaWYgKGlkICYmIGlkICE9PSAtMSB8fCBzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldFJ1bGVDYih7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVJZDogc3R5bGVJZCxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleDJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcbiAgICAgICAgfSlcbiAgICB9KTtcbiAgICB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUucmVtb3ZlUnVsZSA9IGZ1bmN0aW9uKGluZGV4Mikge1xuICAgICAgICByZXR1cm4gd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmRlbGV0ZVJ1bGUuYXBwbHkodGhpcywgW1xuICAgICAgICAgICAgaW5kZXgyXG4gICAgICAgIF0pO1xuICAgIH07XG4gICAgdmFyIHJlcGxhY2U7XG4gICAgaWYgKHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlKSB7XG4gICAgICAgIHJlcGxhY2UgPSB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUucmVwbGFjZTtcbiAgICAgICAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2UgPSBuZXcgUHJveHkocmVwbGFjZSwge1xuICAgICAgICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbih0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IGFyZ3VtZW50c0xpc3RbMF07XG4gICAgICAgICAgICAgICAgdmFyIF9nZXRJZEFuZFN0eWxlSWQgPSBnZXRJZEFuZFN0eWxlSWQodGhpc0FyZywgbWlycm9yMiwgc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3IpLCBpZCA9IF9nZXRJZEFuZFN0eWxlSWQuaWQsIHN0eWxlSWQgPSBfZ2V0SWRBbmRTdHlsZUlkLnN0eWxlSWQ7XG4gICAgICAgICAgICAgICAgaWYgKGlkICYmIGlkICE9PSAtMSB8fCBzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVJZDogc3R5bGVJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2U6IHRleHRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHJlcGxhY2VTeW5jO1xuICAgIGlmICh3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUucmVwbGFjZVN5bmMpIHtcbiAgICAgICAgcmVwbGFjZVN5bmMgPSB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUucmVwbGFjZVN5bmM7XG4gICAgICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlU3luYyA9IG5ldyBQcm94eShyZXBsYWNlU3luYywge1xuICAgICAgICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbih0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IGFyZ3VtZW50c0xpc3RbMF07XG4gICAgICAgICAgICAgICAgdmFyIF9nZXRJZEFuZFN0eWxlSWQgPSBnZXRJZEFuZFN0eWxlSWQodGhpc0FyZywgbWlycm9yMiwgc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3IpLCBpZCA9IF9nZXRJZEFuZFN0eWxlSWQuaWQsIHN0eWxlSWQgPSBfZ2V0SWRBbmRTdHlsZUlkLnN0eWxlSWQ7XG4gICAgICAgICAgICAgICAgaWYgKGlkICYmIGlkICE9PSAtMSB8fCBzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVJZDogc3R5bGVJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VTeW5jOiB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMgPSB7fTtcbiAgICBpZiAoY2FuTW9ua2V5UGF0Y2hOZXN0ZWRDU1NSdWxlKFwiQ1NTR3JvdXBpbmdSdWxlXCIpKSB7XG4gICAgICAgIHN1cHBvcnRlZE5lc3RlZENTU1J1bGVUeXBlcy5DU1NHcm91cGluZ1J1bGUgPSB3aW4uQ1NTR3JvdXBpbmdSdWxlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjYW5Nb25rZXlQYXRjaE5lc3RlZENTU1J1bGUoXCJDU1NNZWRpYVJ1bGVcIikpIHtcbiAgICAgICAgICAgIHN1cHBvcnRlZE5lc3RlZENTU1J1bGVUeXBlcy5DU1NNZWRpYVJ1bGUgPSB3aW4uQ1NTTWVkaWFSdWxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW5Nb25rZXlQYXRjaE5lc3RlZENTU1J1bGUoXCJDU1NDb25kaXRpb25SdWxlXCIpKSB7XG4gICAgICAgICAgICBzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMuQ1NTQ29uZGl0aW9uUnVsZSA9IHdpbi5DU1NDb25kaXRpb25SdWxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW5Nb25rZXlQYXRjaE5lc3RlZENTU1J1bGUoXCJDU1NTdXBwb3J0c1J1bGVcIikpIHtcbiAgICAgICAgICAgIHN1cHBvcnRlZE5lc3RlZENTU1J1bGVUeXBlcy5DU1NTdXBwb3J0c1J1bGUgPSB3aW4uQ1NTU3VwcG9ydHNSdWxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciB1bm1vZGlmaWVkRnVuY3Rpb25zID0ge307XG4gICAgT2JqZWN0LmVudHJpZXMoc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICAgIHZhciB0eXBlS2V5ID0gcGFyYW1bMF0sIHR5cGUgPSBwYXJhbVsxXTtcbiAgICAgICAgdW5tb2RpZmllZEZ1bmN0aW9uc1t0eXBlS2V5XSA9IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgICAgICAgIGluc2VydFJ1bGU6IHR5cGUucHJvdG90eXBlLmluc2VydFJ1bGUsXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgICAgICAgICBkZWxldGVSdWxlOiB0eXBlLnByb3RvdHlwZS5kZWxldGVSdWxlXG4gICAgICAgIH07XG4gICAgICAgIHR5cGUucHJvdG90eXBlLmluc2VydFJ1bGUgPSBuZXcgUHJveHkodW5tb2RpZmllZEZ1bmN0aW9uc1t0eXBlS2V5XS5pbnNlcnRSdWxlLCB7XG4gICAgICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkge1xuICAgICAgICAgICAgICAgIHZhciBydWxlMiA9IGFyZ3VtZW50c0xpc3RbMF0sIGluZGV4MiA9IGFyZ3VtZW50c0xpc3RbMV07XG4gICAgICAgICAgICAgICAgdmFyIF9nZXRJZEFuZFN0eWxlSWQgPSBnZXRJZEFuZFN0eWxlSWQodGhpc0FyZy5wYXJlbnRTdHlsZVNoZWV0LCBtaXJyb3IyLCBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvciksIGlkID0gX2dldElkQW5kU3R5bGVJZC5pZCwgc3R5bGVJZCA9IF9nZXRJZEFuZFN0eWxlSWQuc3R5bGVJZDtcbiAgICAgICAgICAgICAgICBpZiAoaWQgJiYgaWQgIT09IC0xIHx8IHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTaGVldFJ1bGVDYih7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZUlkOiBzdHlsZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogcnVsZTIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBbXS5jb25jYXQoZ2V0TmVzdGVkQ1NTUnVsZVBvc2l0aW9ucyh0aGlzQXJnKSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgyIHx8IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIHR5cGUucHJvdG90eXBlLmRlbGV0ZVJ1bGUgPSBuZXcgUHJveHkodW5tb2RpZmllZEZ1bmN0aW9uc1t0eXBlS2V5XS5kZWxldGVSdWxlLCB7XG4gICAgICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleDIgPSBhcmd1bWVudHNMaXN0WzBdO1xuICAgICAgICAgICAgICAgIHZhciBfZ2V0SWRBbmRTdHlsZUlkID0gZ2V0SWRBbmRTdHlsZUlkKHRoaXNBcmcucGFyZW50U3R5bGVTaGVldCwgbWlycm9yMiwgc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3IpLCBpZCA9IF9nZXRJZEFuZFN0eWxlSWQuaWQsIHN0eWxlSWQgPSBfZ2V0SWRBbmRTdHlsZUlkLnN0eWxlSWQ7XG4gICAgICAgICAgICAgICAgaWYgKGlkICYmIGlkICE9PSAtMSB8fCBzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVJZDogc3R5bGVJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBbXS5jb25jYXQoZ2V0TmVzdGVkQ1NTUnVsZVBvc2l0aW9ucyh0aGlzQXJnKSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5pbnNlcnRSdWxlID0gaW5zZXJ0UnVsZTtcbiAgICAgICAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmRlbGV0ZVJ1bGUgPSBkZWxldGVSdWxlO1xuICAgICAgICByZXBsYWNlICYmICh3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUucmVwbGFjZSA9IHJlcGxhY2UpO1xuICAgICAgICByZXBsYWNlU3luYyAmJiAod2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2VTeW5jID0gcmVwbGFjZVN5bmMpO1xuICAgICAgICBPYmplY3QuZW50cmllcyhzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMpLmZvckVhY2goZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgICAgIHZhciB0eXBlS2V5ID0gcGFyYW1bMF0sIHR5cGUgPSBwYXJhbVsxXTtcbiAgICAgICAgICAgIHR5cGUucHJvdG90eXBlLmluc2VydFJ1bGUgPSB1bm1vZGlmaWVkRnVuY3Rpb25zW3R5cGVLZXldLmluc2VydFJ1bGU7XG4gICAgICAgICAgICB0eXBlLnByb3RvdHlwZS5kZWxldGVSdWxlID0gdW5tb2RpZmllZEZ1bmN0aW9uc1t0eXBlS2V5XS5kZWxldGVSdWxlO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRBZG9wdGVkU3R5bGVTaGVldE9ic2VydmVyKHBhcmFtLCBob3N0Mikge1xuICAgIHZhciBtaXJyb3IyID0gcGFyYW0ubWlycm9yLCBzdHlsZXNoZWV0TWFuYWdlciA9IHBhcmFtLnN0eWxlc2hlZXRNYW5hZ2VyO1xuICAgIHZhciBfYTIsIF9iLCBfYztcbiAgICB2YXIgaG9zdElkID0gbnVsbDtcbiAgICBpZiAoaG9zdDIubm9kZU5hbWUgPT09IFwiI2RvY3VtZW50XCIpIGhvc3RJZCA9IG1pcnJvcjIuZ2V0SWQoaG9zdDIpO1xuICAgIGVsc2UgaG9zdElkID0gbWlycm9yMi5nZXRJZChpbmRleC5ob3N0KGhvc3QyKSk7XG4gICAgdmFyIHBhdGNoVGFyZ2V0ID0gaG9zdDIubm9kZU5hbWUgPT09IFwiI2RvY3VtZW50XCIgPyAoX2EyID0gaG9zdDIuZGVmYXVsdFZpZXcpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuRG9jdW1lbnQgOiAoX2MgPSAoX2IgPSBob3N0Mi5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2IuZGVmYXVsdFZpZXcpID09IG51bGwgPyB2b2lkIDAgOiBfYy5TaGFkb3dSb290O1xuICAgIHZhciBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvciA9IChwYXRjaFRhcmdldCA9PSBudWxsID8gdm9pZCAwIDogcGF0Y2hUYXJnZXQucHJvdG90eXBlKSA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocGF0Y2hUYXJnZXQgPT0gbnVsbCA/IHZvaWQgMCA6IHBhdGNoVGFyZ2V0LnByb3RvdHlwZSwgXCJhZG9wdGVkU3R5bGVTaGVldHNcIikgOiB2b2lkIDA7XG4gICAgaWYgKGhvc3RJZCA9PT0gbnVsbCB8fCBob3N0SWQgPT09IC0xIHx8ICFwYXRjaFRhcmdldCB8fCAhb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IpIHJldHVybiBmdW5jdGlvbigpIHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShob3N0MiwgXCJhZG9wdGVkU3R5bGVTaGVldHNcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgZW51bWVyYWJsZTogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICB2YXIgX2EzO1xuICAgICAgICAgICAgcmV0dXJuIChfYTMgPSBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvci5nZXQpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuY2FsbCh0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoc2hlZXRzKSB7XG4gICAgICAgICAgICB2YXIgX2EzO1xuICAgICAgICAgICAgdmFyIHJlc3VsdDIgPSAoX2EzID0gb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3Iuc2V0KSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmNhbGwodGhpcywgc2hlZXRzKTtcbiAgICAgICAgICAgIGlmIChob3N0SWQgIT09IG51bGwgJiYgaG9zdElkICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLmFkb3B0U3R5bGVTaGVldHMoc2hlZXRzLCBob3N0SWQpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUyKSB7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaG9zdDIsIFwiYWRvcHRlZFN0eWxlU2hlZXRzXCIsIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuY29uZmlndXJhYmxlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgICAgICAgIGdldDogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuZ2V0LFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgICAgICAgc2V0OiBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvci5zZXRcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpbml0U3R5bGVEZWNsYXJhdGlvbk9ic2VydmVyKHBhcmFtLCBwYXJhbTEpIHtcbiAgICB2YXIgc3R5bGVEZWNsYXJhdGlvbkNiID0gcGFyYW0uc3R5bGVEZWNsYXJhdGlvbkNiLCBtaXJyb3IyID0gcGFyYW0ubWlycm9yLCBpZ25vcmVDU1NBdHRyaWJ1dGVzID0gcGFyYW0uaWdub3JlQ1NTQXR0cmlidXRlcywgc3R5bGVzaGVldE1hbmFnZXIgPSBwYXJhbS5zdHlsZXNoZWV0TWFuYWdlcjtcbiAgICB2YXIgd2luID0gcGFyYW0xLndpbjtcbiAgICB2YXIgc2V0UHJvcGVydHkgPSB3aW4uQ1NTU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUuc2V0UHJvcGVydHk7XG4gICAgd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnNldFByb3BlcnR5ID0gbmV3IFByb3h5KHNldFByb3BlcnR5LCB7XG4gICAgICAgIGFwcGx5OiBjYWxsYmFja1dyYXBwZXIoZnVuY3Rpb24odGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSB7XG4gICAgICAgICAgICB2YXIgX2EyO1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gYXJndW1lbnRzTGlzdFswXSwgdmFsdWUgPSBhcmd1bWVudHNMaXN0WzFdLCBwcmlvcml0eSA9IGFyZ3VtZW50c0xpc3RbMl07XG4gICAgICAgICAgICBpZiAoaWdub3JlQ1NTQXR0cmlidXRlcy5oYXMocHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldFByb3BlcnR5LmFwcGx5KHRoaXNBcmcsIFtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBwcmlvcml0eVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9nZXRJZEFuZFN0eWxlSWQgPSBnZXRJZEFuZFN0eWxlSWQoKF9hMiA9IHRoaXNBcmcucGFyZW50UnVsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5wYXJlbnRTdHlsZVNoZWV0LCBtaXJyb3IyLCBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvciksIGlkID0gX2dldElkQW5kU3R5bGVJZC5pZCwgc3R5bGVJZCA9IF9nZXRJZEFuZFN0eWxlSWQuc3R5bGVJZDtcbiAgICAgICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHN0eWxlRGVjbGFyYXRpb25DYih7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVJZDogc3R5bGVJZCxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogcHJpb3JpdHlcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGdldE5lc3RlZENTU1J1bGVQb3NpdGlvbnModGhpc0FyZy5wYXJlbnRSdWxlKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcbiAgICAgICAgfSlcbiAgICB9KTtcbiAgICB2YXIgcmVtb3ZlUHJvcGVydHkgPSB3aW4uQ1NTU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUucmVtb3ZlUHJvcGVydHk7XG4gICAgd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnJlbW92ZVByb3BlcnR5ID0gbmV3IFByb3h5KHJlbW92ZVByb3BlcnR5LCB7XG4gICAgICAgIGFwcGx5OiBjYWxsYmFja1dyYXBwZXIoZnVuY3Rpb24odGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSB7XG4gICAgICAgICAgICB2YXIgX2EyO1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gYXJndW1lbnRzTGlzdFswXTtcbiAgICAgICAgICAgIGlmIChpZ25vcmVDU1NBdHRyaWJ1dGVzLmhhcyhwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlUHJvcGVydHkuYXBwbHkodGhpc0FyZywgW1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9nZXRJZEFuZFN0eWxlSWQgPSBnZXRJZEFuZFN0eWxlSWQoKF9hMiA9IHRoaXNBcmcucGFyZW50UnVsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5wYXJlbnRTdHlsZVNoZWV0LCBtaXJyb3IyLCBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvciksIGlkID0gX2dldElkQW5kU3R5bGVJZC5pZCwgc3R5bGVJZCA9IF9nZXRJZEFuZFN0eWxlSWQuc3R5bGVJZDtcbiAgICAgICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHN0eWxlRGVjbGFyYXRpb25DYih7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVJZDogc3R5bGVJZCxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGdldE5lc3RlZENTU1J1bGVQb3NpdGlvbnModGhpc0FyZy5wYXJlbnRSdWxlKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcbiAgICAgICAgfSlcbiAgICB9KTtcbiAgICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICB3aW4uQ1NTU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSBzZXRQcm9wZXJ0eTtcbiAgICAgICAgd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnJlbW92ZVByb3BlcnR5ID0gcmVtb3ZlUHJvcGVydHk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpbml0TWVkaWFJbnRlcmFjdGlvbk9ic2VydmVyKHBhcmFtKSB7XG4gICAgdmFyIG1lZGlhSW50ZXJhY3Rpb25DYiA9IHBhcmFtLm1lZGlhSW50ZXJhY3Rpb25DYiwgYmxvY2tDbGFzcyA9IHBhcmFtLmJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IgPSBwYXJhbS5ibG9ja1NlbGVjdG9yLCBtaXJyb3IyID0gcGFyYW0ubWlycm9yLCBzYW1wbGluZyA9IHBhcmFtLnNhbXBsaW5nLCBkb2MgPSBwYXJhbS5kb2M7XG4gICAgdmFyIGhhbmRsZXIgPSBjYWxsYmFja1dyYXBwZXIoZnVuY3Rpb24odHlwZSkge1xuICAgICAgICByZXR1cm4gdGhyb3R0bGUoY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQgfHwgaXNCbG9ja2VkKHRhcmdldCwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSB0YXJnZXQuY3VycmVudFRpbWUsIHZvbHVtZSA9IHRhcmdldC52b2x1bWUsIG11dGVkID0gdGFyZ2V0Lm11dGVkLCBwbGF5YmFja1JhdGUgPSB0YXJnZXQucGxheWJhY2tSYXRlLCBsb29wID0gdGFyZ2V0Lmxvb3A7XG4gICAgICAgICAgICBtZWRpYUludGVyYWN0aW9uQ2Ioe1xuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgaWQ6IG1pcnJvcjIuZ2V0SWQodGFyZ2V0KSxcbiAgICAgICAgICAgICAgICBjdXJyZW50VGltZTogY3VycmVudFRpbWUsXG4gICAgICAgICAgICAgICAgdm9sdW1lOiB2b2x1bWUsXG4gICAgICAgICAgICAgICAgbXV0ZWQ6IG11dGVkLFxuICAgICAgICAgICAgICAgIHBsYXliYWNrUmF0ZTogcGxheWJhY2tSYXRlLFxuICAgICAgICAgICAgICAgIGxvb3A6IGxvb3BcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSwgc2FtcGxpbmcubWVkaWEgfHwgNTAwKTtcbiAgICB9KTtcbiAgICB2YXIgaGFuZGxlcnMgPSBbXG4gICAgICAgIG9uKFwicGxheVwiLCBoYW5kbGVyKE1lZGlhSW50ZXJhY3Rpb25zLlBsYXkpLCBkb2MpLFxuICAgICAgICBvbihcInBhdXNlXCIsIGhhbmRsZXIoTWVkaWFJbnRlcmFjdGlvbnMuUGF1c2UpLCBkb2MpLFxuICAgICAgICBvbihcInNlZWtlZFwiLCBoYW5kbGVyKE1lZGlhSW50ZXJhY3Rpb25zLlNlZWtlZCksIGRvYyksXG4gICAgICAgIG9uKFwidm9sdW1lY2hhbmdlXCIsIGhhbmRsZXIoTWVkaWFJbnRlcmFjdGlvbnMuVm9sdW1lQ2hhbmdlKSwgZG9jKSxcbiAgICAgICAgb24oXCJyYXRlY2hhbmdlXCIsIGhhbmRsZXIoTWVkaWFJbnRlcmFjdGlvbnMuUmF0ZUNoYW5nZSksIGRvYylcbiAgICBdO1xuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgcmV0dXJuIGgoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpbml0Rm9udE9ic2VydmVyKHBhcmFtKSB7XG4gICAgdmFyIGZvbnRDYiA9IHBhcmFtLmZvbnRDYiwgZG9jID0gcGFyYW0uZG9jO1xuICAgIHZhciB3aW4gPSBkb2MuZGVmYXVsdFZpZXc7XG4gICAgaWYgKCF3aW4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge307XG4gICAgfVxuICAgIHZhciBoYW5kbGVycyA9IFtdO1xuICAgIHZhciBmb250TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgdmFyIG9yaWdpbmFsRm9udEZhY2UgPSB3aW4uRm9udEZhY2U7XG4gICAgd2luLkZvbnRGYWNlID0gZnVuY3Rpb24gRm9udEZhY2UyKGZhbWlseSwgc291cmNlLCBkZXNjcmlwdG9ycykge1xuICAgICAgICB2YXIgZm9udEZhY2UgPSBuZXcgb3JpZ2luYWxGb250RmFjZShmYW1pbHksIHNvdXJjZSwgZGVzY3JpcHRvcnMpO1xuICAgICAgICBmb250TWFwLnNldChmb250RmFjZSwge1xuICAgICAgICAgICAgZmFtaWx5OiBmYW1pbHksXG4gICAgICAgICAgICBidWZmZXI6IHR5cGVvZiBzb3VyY2UgIT09IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBkZXNjcmlwdG9yczogZGVzY3JpcHRvcnMsXG4gICAgICAgICAgICBmb250U291cmNlOiB0eXBlb2Ygc291cmNlID09PSBcInN0cmluZ1wiID8gc291cmNlIDogSlNPTi5zdHJpbmdpZnkoQXJyYXkuZnJvbShuZXcgVWludDhBcnJheShzb3VyY2UpKSlcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmb250RmFjZTtcbiAgICB9O1xuICAgIHZhciByZXN0b3JlSGFuZGxlciA9IHBhdGNoJDIoZG9jLmZvbnRzLCBcImFkZFwiLCBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZm9udEZhY2UpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBwID0gZm9udE1hcC5nZXQoZm9udEZhY2UpO1xuICAgICAgICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnRDYihwKTtcbiAgICAgICAgICAgICAgICAgICAgZm9udE1hcC5kZWxldGUoZm9udEZhY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbXG4gICAgICAgICAgICAgICAgZm9udEZhY2VcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIGhhbmRsZXJzLnB1c2goZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbi5Gb250RmFjZSA9IG9yaWdpbmFsRm9udEZhY2U7XG4gICAgfSk7XG4gICAgaGFuZGxlcnMucHVzaChyZXN0b3JlSGFuZGxlcik7XG4gICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbigpIHtcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICByZXR1cm4gaCgpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRTZWxlY3Rpb25PYnNlcnZlcihwYXJhbSkge1xuICAgIHZhciBkb2MgPSBwYXJhbS5kb2MsIG1pcnJvcjIgPSBwYXJhbS5taXJyb3IsIGJsb2NrQ2xhc3MgPSBwYXJhbS5ibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yID0gcGFyYW0uYmxvY2tTZWxlY3Rvciwgc2VsZWN0aW9uQ2IgPSBwYXJhbS5zZWxlY3Rpb25DYjtcbiAgICB2YXIgY29sbGFwc2VkID0gdHJ1ZTtcbiAgICB2YXIgdXBkYXRlU2VsZWN0aW9uID0gY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gZG9jLmdldFNlbGVjdGlvbigpO1xuICAgICAgICBpZiAoIXNlbGVjdGlvbiB8fCBjb2xsYXBzZWQgJiYgKHNlbGVjdGlvbiA9PSBudWxsID8gdm9pZCAwIDogc2VsZWN0aW9uLmlzQ29sbGFwc2VkKSkgcmV0dXJuO1xuICAgICAgICBjb2xsYXBzZWQgPSBzZWxlY3Rpb24uaXNDb2xsYXBzZWQgfHwgZmFsc2U7XG4gICAgICAgIHZhciByYW5nZXMgPSBbXTtcbiAgICAgICAgdmFyIGNvdW50ID0gc2VsZWN0aW9uLnJhbmdlQ291bnQgfHwgMDtcbiAgICAgICAgZm9yKHZhciBpMiA9IDA7IGkyIDwgY291bnQ7IGkyKyspe1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoaTIpO1xuICAgICAgICAgICAgdmFyIHN0YXJ0Q29udGFpbmVyID0gcmFuZ2Uuc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0ID0gcmFuZ2Uuc3RhcnRPZmZzZXQsIGVuZENvbnRhaW5lciA9IHJhbmdlLmVuZENvbnRhaW5lciwgZW5kT2Zmc2V0ID0gcmFuZ2UuZW5kT2Zmc2V0O1xuICAgICAgICAgICAgdmFyIGJsb2NrZWQgPSBpc0Jsb2NrZWQoc3RhcnRDb250YWluZXIsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpIHx8IGlzQmxvY2tlZChlbmRDb250YWluZXIsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGJsb2NrZWQpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBtaXJyb3IyLmdldElkKHN0YXJ0Q29udGFpbmVyKSxcbiAgICAgICAgICAgICAgICBzdGFydE9mZnNldDogc3RhcnRPZmZzZXQsXG4gICAgICAgICAgICAgICAgZW5kOiBtaXJyb3IyLmdldElkKGVuZENvbnRhaW5lciksXG4gICAgICAgICAgICAgICAgZW5kT2Zmc2V0OiBlbmRPZmZzZXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGlvbkNiKHtcbiAgICAgICAgICAgIHJhbmdlczogcmFuZ2VzXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHVwZGF0ZVNlbGVjdGlvbigpO1xuICAgIHJldHVybiBvbihcInNlbGVjdGlvbmNoYW5nZVwiLCB1cGRhdGVTZWxlY3Rpb24pO1xufVxuZnVuY3Rpb24gaW5pdEN1c3RvbUVsZW1lbnRPYnNlcnZlcihwYXJhbSkge1xuICAgIHZhciBkb2MgPSBwYXJhbS5kb2MsIGN1c3RvbUVsZW1lbnRDYiA9IHBhcmFtLmN1c3RvbUVsZW1lbnRDYjtcbiAgICB2YXIgd2luID0gZG9jLmRlZmF1bHRWaWV3O1xuICAgIGlmICghd2luIHx8ICF3aW4uY3VzdG9tRWxlbWVudHMpIHJldHVybiBmdW5jdGlvbigpIHt9O1xuICAgIHZhciByZXN0b3JlSGFuZGxlciA9IHBhdGNoJDIod2luLmN1c3RvbUVsZW1lbnRzLCBcImRlZmluZVwiLCBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24obmFtZSwgY29uc3RydWN0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tRWxlbWVudENiKHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ3VzdG9tIGVsZW1lbnQgY2FsbGJhY2sgZmFpbGVkIGZvciBcIiArIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIFtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiByZXN0b3JlSGFuZGxlcjtcbn1cbmZ1bmN0aW9uIG1lcmdlSG9va3MobzIsIGhvb2tzKSB7XG4gICAgdmFyIG11dGF0aW9uQ2IgPSBvMi5tdXRhdGlvbkNiLCBtb3VzZW1vdmVDYiA9IG8yLm1vdXNlbW92ZUNiLCBtb3VzZUludGVyYWN0aW9uQ2IgPSBvMi5tb3VzZUludGVyYWN0aW9uQ2IsIHNjcm9sbENiID0gbzIuc2Nyb2xsQ2IsIHZpZXdwb3J0UmVzaXplQ2IgPSBvMi52aWV3cG9ydFJlc2l6ZUNiLCBpbnB1dENiID0gbzIuaW5wdXRDYiwgbWVkaWFJbnRlcmFjdGlvbkNiID0gbzIubWVkaWFJbnRlcmFjdGlvbkNiLCBzdHlsZVNoZWV0UnVsZUNiID0gbzIuc3R5bGVTaGVldFJ1bGVDYiwgc3R5bGVEZWNsYXJhdGlvbkNiID0gbzIuc3R5bGVEZWNsYXJhdGlvbkNiLCBjYW52YXNNdXRhdGlvbkNiID0gbzIuY2FudmFzTXV0YXRpb25DYiwgZm9udENiID0gbzIuZm9udENiLCBzZWxlY3Rpb25DYiA9IG8yLnNlbGVjdGlvbkNiLCBjdXN0b21FbGVtZW50Q2IgPSBvMi5jdXN0b21FbGVtZW50Q2I7XG4gICAgbzIubXV0YXRpb25DYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBwW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob29rcy5tdXRhdGlvbikge1xuICAgICAgICAgICAgdmFyIF9ob29rcztcbiAgICAgICAgICAgIChfaG9va3MgPSBob29rcykubXV0YXRpb24uYXBwbHkoX2hvb2tzLCBbXS5jb25jYXQocCkpO1xuICAgICAgICB9XG4gICAgICAgIG11dGF0aW9uQ2IuYXBwbHkodm9pZCAwLCBbXS5jb25jYXQocCkpO1xuICAgIH07XG4gICAgbzIubW91c2Vtb3ZlQ2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcCA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgcFtfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9va3MubW91c2Vtb3ZlKSB7XG4gICAgICAgICAgICB2YXIgX2hvb2tzO1xuICAgICAgICAgICAgKF9ob29rcyA9IGhvb2tzKS5tb3VzZW1vdmUuYXBwbHkoX2hvb2tzLCBbXS5jb25jYXQocCkpO1xuICAgICAgICB9XG4gICAgICAgIG1vdXNlbW92ZUNiLmFwcGx5KHZvaWQgMCwgW10uY29uY2F0KHApKTtcbiAgICB9O1xuICAgIG8yLm1vdXNlSW50ZXJhY3Rpb25DYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBwW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob29rcy5tb3VzZUludGVyYWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgX2hvb2tzO1xuICAgICAgICAgICAgKF9ob29rcyA9IGhvb2tzKS5tb3VzZUludGVyYWN0aW9uLmFwcGx5KF9ob29rcywgW10uY29uY2F0KHApKTtcbiAgICAgICAgfVxuICAgICAgICBtb3VzZUludGVyYWN0aW9uQ2IuYXBwbHkodm9pZCAwLCBbXS5jb25jYXQocCkpO1xuICAgIH07XG4gICAgbzIuc2Nyb2xsQ2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcCA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgcFtfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9va3Muc2Nyb2xsKSB7XG4gICAgICAgICAgICB2YXIgX2hvb2tzO1xuICAgICAgICAgICAgKF9ob29rcyA9IGhvb2tzKS5zY3JvbGwuYXBwbHkoX2hvb2tzLCBbXS5jb25jYXQocCkpO1xuICAgICAgICB9XG4gICAgICAgIHNjcm9sbENiLmFwcGx5KHZvaWQgMCwgW10uY29uY2F0KHApKTtcbiAgICB9O1xuICAgIG8yLnZpZXdwb3J0UmVzaXplQ2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcCA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgcFtfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9va3Mudmlld3BvcnRSZXNpemUpIHtcbiAgICAgICAgICAgIHZhciBfaG9va3M7XG4gICAgICAgICAgICAoX2hvb2tzID0gaG9va3MpLnZpZXdwb3J0UmVzaXplLmFwcGx5KF9ob29rcywgW10uY29uY2F0KHApKTtcbiAgICAgICAgfVxuICAgICAgICB2aWV3cG9ydFJlc2l6ZUNiLmFwcGx5KHZvaWQgMCwgW10uY29uY2F0KHApKTtcbiAgICB9O1xuICAgIG8yLmlucHV0Q2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcCA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgcFtfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9va3MuaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBfaG9va3M7XG4gICAgICAgICAgICAoX2hvb2tzID0gaG9va3MpLmlucHV0LmFwcGx5KF9ob29rcywgW10uY29uY2F0KHApKTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dENiLmFwcGx5KHZvaWQgMCwgW10uY29uY2F0KHApKTtcbiAgICB9O1xuICAgIG8yLm1lZGlhSW50ZXJhY3Rpb25DYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBwW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob29rcy5tZWRpYUludGVhY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBfaG9va3M7XG4gICAgICAgICAgICAoX2hvb2tzID0gaG9va3MpLm1lZGlhSW50ZWFjdGlvbi5hcHBseShfaG9va3MsIFtdLmNvbmNhdChwKSk7XG4gICAgICAgIH1cbiAgICAgICAgbWVkaWFJbnRlcmFjdGlvbkNiLmFwcGx5KHZvaWQgMCwgW10uY29uY2F0KHApKTtcbiAgICB9O1xuICAgIG8yLnN0eWxlU2hlZXRSdWxlQ2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcCA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgcFtfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9va3Muc3R5bGVTaGVldFJ1bGUpIHtcbiAgICAgICAgICAgIHZhciBfaG9va3M7XG4gICAgICAgICAgICAoX2hvb2tzID0gaG9va3MpLnN0eWxlU2hlZXRSdWxlLmFwcGx5KF9ob29rcywgW10uY29uY2F0KHApKTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZVNoZWV0UnVsZUNiLmFwcGx5KHZvaWQgMCwgW10uY29uY2F0KHApKTtcbiAgICB9O1xuICAgIG8yLnN0eWxlRGVjbGFyYXRpb25DYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBwW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob29rcy5zdHlsZURlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgX2hvb2tzO1xuICAgICAgICAgICAgKF9ob29rcyA9IGhvb2tzKS5zdHlsZURlY2xhcmF0aW9uLmFwcGx5KF9ob29rcywgW10uY29uY2F0KHApKTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZURlY2xhcmF0aW9uQ2IuYXBwbHkodm9pZCAwLCBbXS5jb25jYXQocCkpO1xuICAgIH07XG4gICAgbzIuY2FudmFzTXV0YXRpb25DYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBwW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob29rcy5jYW52YXNNdXRhdGlvbikge1xuICAgICAgICAgICAgdmFyIF9ob29rcztcbiAgICAgICAgICAgIChfaG9va3MgPSBob29rcykuY2FudmFzTXV0YXRpb24uYXBwbHkoX2hvb2tzLCBbXS5jb25jYXQocCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhbnZhc011dGF0aW9uQ2IuYXBwbHkodm9pZCAwLCBbXS5jb25jYXQocCkpO1xuICAgIH07XG4gICAgbzIuZm9udENiID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHAgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIHBbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvb2tzLmZvbnQpIHtcbiAgICAgICAgICAgIHZhciBfaG9va3M7XG4gICAgICAgICAgICAoX2hvb2tzID0gaG9va3MpLmZvbnQuYXBwbHkoX2hvb2tzLCBbXS5jb25jYXQocCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvbnRDYi5hcHBseSh2b2lkIDAsIFtdLmNvbmNhdChwKSk7XG4gICAgfTtcbiAgICBvMi5zZWxlY3Rpb25DYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBwW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob29rcy5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBfaG9va3M7XG4gICAgICAgICAgICAoX2hvb2tzID0gaG9va3MpLnNlbGVjdGlvbi5hcHBseShfaG9va3MsIFtdLmNvbmNhdChwKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0aW9uQ2IuYXBwbHkodm9pZCAwLCBbXS5jb25jYXQocCkpO1xuICAgIH07XG4gICAgbzIuY3VzdG9tRWxlbWVudENiID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGMyID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBjMltfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9va3MuY3VzdG9tRWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIF9ob29rcztcbiAgICAgICAgICAgIChfaG9va3MgPSBob29rcykuY3VzdG9tRWxlbWVudC5hcHBseShfaG9va3MsIFtdLmNvbmNhdChjMikpO1xuICAgICAgICB9XG4gICAgICAgIGN1c3RvbUVsZW1lbnRDYi5hcHBseSh2b2lkIDAsIFtdLmNvbmNhdChjMikpO1xuICAgIH07XG59XG5mdW5jdGlvbiBpbml0T2JzZXJ2ZXJzKG8yLCBob29rcykge1xuICAgIGlmIChob29rcyA9PT0gdm9pZCAwKSBob29rcyA9IHt9O1xuICAgIHZhciBjdXJyZW50V2luZG93ID0gbzIuZG9jLmRlZmF1bHRWaWV3O1xuICAgIGlmICghY3VycmVudFdpbmRvdykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gICAgbWVyZ2VIb29rcyhvMiwgaG9va3MpO1xuICAgIHZhciBtdXRhdGlvbk9ic2VydmVyO1xuICAgIGlmIChvMi5yZWNvcmRET00pIHtcbiAgICAgICAgbXV0YXRpb25PYnNlcnZlciA9IGluaXRNdXRhdGlvbk9ic2VydmVyKG8yLCBvMi5kb2MpO1xuICAgIH1cbiAgICB2YXIgbW91c2Vtb3ZlSGFuZGxlciA9IGluaXRNb3ZlT2JzZXJ2ZXIobzIpO1xuICAgIHZhciBtb3VzZUludGVyYWN0aW9uSGFuZGxlciA9IGluaXRNb3VzZUludGVyYWN0aW9uT2JzZXJ2ZXIobzIpO1xuICAgIHZhciBzY3JvbGxIYW5kbGVyID0gaW5pdFNjcm9sbE9ic2VydmVyKG8yKTtcbiAgICB2YXIgdmlld3BvcnRSZXNpemVIYW5kbGVyID0gaW5pdFZpZXdwb3J0UmVzaXplT2JzZXJ2ZXIobzIsIHtcbiAgICAgICAgd2luOiBjdXJyZW50V2luZG93XG4gICAgfSk7XG4gICAgdmFyIGlucHV0SGFuZGxlciA9IGluaXRJbnB1dE9ic2VydmVyKG8yKTtcbiAgICB2YXIgbWVkaWFJbnRlcmFjdGlvbkhhbmRsZXIgPSBpbml0TWVkaWFJbnRlcmFjdGlvbk9ic2VydmVyKG8yKTtcbiAgICB2YXIgc3R5bGVTaGVldE9ic2VydmVyID0gZnVuY3Rpb24oKSB7fTtcbiAgICB2YXIgYWRvcHRlZFN0eWxlU2hlZXRPYnNlcnZlciA9IGZ1bmN0aW9uKCkge307XG4gICAgdmFyIHN0eWxlRGVjbGFyYXRpb25PYnNlcnZlciA9IGZ1bmN0aW9uKCkge307XG4gICAgdmFyIGZvbnRPYnNlcnZlciA9IGZ1bmN0aW9uKCkge307XG4gICAgaWYgKG8yLnJlY29yZERPTSkge1xuICAgICAgICBzdHlsZVNoZWV0T2JzZXJ2ZXIgPSBpbml0U3R5bGVTaGVldE9ic2VydmVyKG8yLCB7XG4gICAgICAgICAgICB3aW46IGN1cnJlbnRXaW5kb3dcbiAgICAgICAgfSk7XG4gICAgICAgIGFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIgPSBpbml0QWRvcHRlZFN0eWxlU2hlZXRPYnNlcnZlcihvMiwgbzIuZG9jKTtcbiAgICAgICAgc3R5bGVEZWNsYXJhdGlvbk9ic2VydmVyID0gaW5pdFN0eWxlRGVjbGFyYXRpb25PYnNlcnZlcihvMiwge1xuICAgICAgICAgICAgd2luOiBjdXJyZW50V2luZG93XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobzIuY29sbGVjdEZvbnRzKSB7XG4gICAgICAgICAgICBmb250T2JzZXJ2ZXIgPSBpbml0Rm9udE9ic2VydmVyKG8yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgc2VsZWN0aW9uT2JzZXJ2ZXIgPSBpbml0U2VsZWN0aW9uT2JzZXJ2ZXIobzIpO1xuICAgIHZhciBjdXN0b21FbGVtZW50T2JzZXJ2ZXIgPSBpbml0Q3VzdG9tRWxlbWVudE9ic2VydmVyKG8yKTtcbiAgICB2YXIgcGx1Z2luSGFuZGxlcnMgPSBbXTtcbiAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShvMi5wbHVnaW5zKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICB2YXIgcGx1Z2luMyA9IF9zdGVwLnZhbHVlO1xuICAgICAgICBwbHVnaW5IYW5kbGVycy5wdXNoKHBsdWdpbjMub2JzZXJ2ZXIocGx1Z2luMy5jYWxsYmFjaywgY3VycmVudFdpbmRvdywgcGx1Z2luMy5vcHRpb25zKSk7XG4gICAgfVxuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIG11dGF0aW9uQnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLnJlc2V0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBtdXRhdGlvbk9ic2VydmVyID09IG51bGwgPyB2b2lkIDAgOiBtdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgbW91c2Vtb3ZlSGFuZGxlcigpO1xuICAgICAgICBtb3VzZUludGVyYWN0aW9uSGFuZGxlcigpO1xuICAgICAgICBzY3JvbGxIYW5kbGVyKCk7XG4gICAgICAgIHZpZXdwb3J0UmVzaXplSGFuZGxlcigpO1xuICAgICAgICBpbnB1dEhhbmRsZXIoKTtcbiAgICAgICAgbWVkaWFJbnRlcmFjdGlvbkhhbmRsZXIoKTtcbiAgICAgICAgc3R5bGVTaGVldE9ic2VydmVyKCk7XG4gICAgICAgIGFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIoKTtcbiAgICAgICAgc3R5bGVEZWNsYXJhdGlvbk9ic2VydmVyKCk7XG4gICAgICAgIGZvbnRPYnNlcnZlcigpO1xuICAgICAgICBzZWxlY3Rpb25PYnNlcnZlcigpO1xuICAgICAgICBjdXN0b21FbGVtZW50T2JzZXJ2ZXIoKTtcbiAgICAgICAgcGx1Z2luSGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICByZXR1cm4gaCgpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGhhc05lc3RlZENTU1J1bGUocHJvcCkge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93W3Byb3BdICE9PSBcInVuZGVmaW5lZFwiO1xufVxuZnVuY3Rpb24gY2FuTW9ua2V5UGF0Y2hOZXN0ZWRDU1NSdWxlKHByb3ApIHtcbiAgICByZXR1cm4gQm9vbGVhbih0eXBlb2Ygd2luZG93W3Byb3BdICE9PSBcInVuZGVmaW5lZFwiICYmIC8vIE5vdGU6IEdlbmVyYWxseSwgdGhpcyBjaGVjayBfc2hvdWxkbid0XyBiZSBuZWNlc3NhcnlcbiAgICAvLyBIb3dldmVyLCBpbiBzb21lIHNjZW5hcmlvcyAoZS5nLiBqc2RvbSkgdGhpcyBjYW4gc29tZXRpbWVzIGZhaWwsIHNvIHdlIGNoZWNrIGZvciBpdCBoZXJlXG4gICAgd2luZG93W3Byb3BdLnByb3RvdHlwZSAmJiBcImluc2VydFJ1bGVcIiBpbiB3aW5kb3dbcHJvcF0ucHJvdG90eXBlICYmIFwiZGVsZXRlUnVsZVwiIGluIHdpbmRvd1twcm9wXS5wcm90b3R5cGUpO1xufVxudmFyIENyb3NzT3JpZ2luSWZyYW1lTWlycm9yID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBDcm9zc09yaWdpbklmcmFtZU1pcnJvcihnZW5lcmF0ZUlkRm4pIHtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiaWZyYW1lSWRUb1JlbW90ZUlkTWFwXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiaWZyYW1lUmVtb3RlSWRUb0lkTWFwXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpKTtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUlkRm4gPSBnZW5lcmF0ZUlkRm47XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBDcm9zc09yaWdpbklmcmFtZU1pcnJvci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmdldElkID0gZnVuY3Rpb24gZ2V0SWQoaWZyYW1lLCByZW1vdGVJZCwgaWRUb1JlbW90ZU1hcCwgcmVtb3RlVG9JZE1hcCkge1xuICAgICAgICB2YXIgaWRUb1JlbW90ZUlkTWFwID0gaWRUb1JlbW90ZU1hcCB8fCB0aGlzLmdldElkVG9SZW1vdGVJZE1hcChpZnJhbWUpO1xuICAgICAgICB2YXIgcmVtb3RlSWRUb0lkTWFwID0gcmVtb3RlVG9JZE1hcCB8fCB0aGlzLmdldFJlbW90ZUlkVG9JZE1hcChpZnJhbWUpO1xuICAgICAgICB2YXIgaWQgPSBpZFRvUmVtb3RlSWRNYXAuZ2V0KHJlbW90ZUlkKTtcbiAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgaWQgPSB0aGlzLmdlbmVyYXRlSWRGbigpO1xuICAgICAgICAgICAgaWRUb1JlbW90ZUlkTWFwLnNldChyZW1vdGVJZCwgaWQpO1xuICAgICAgICAgICAgcmVtb3RlSWRUb0lkTWFwLnNldChpZCwgcmVtb3RlSWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9O1xuICAgIF9wcm90by5nZXRJZHMgPSBmdW5jdGlvbiBnZXRJZHMoaWZyYW1lLCByZW1vdGVJZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaWRUb1JlbW90ZUlkTWFwID0gdGhpcy5nZXRJZFRvUmVtb3RlSWRNYXAoaWZyYW1lKTtcbiAgICAgICAgdmFyIHJlbW90ZUlkVG9JZE1hcCA9IHRoaXMuZ2V0UmVtb3RlSWRUb0lkTWFwKGlmcmFtZSk7XG4gICAgICAgIHJldHVybiByZW1vdGVJZC5tYXAoZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRJZChpZnJhbWUsIGlkLCBpZFRvUmVtb3RlSWRNYXAsIHJlbW90ZUlkVG9JZE1hcCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmdldFJlbW90ZUlkID0gZnVuY3Rpb24gZ2V0UmVtb3RlSWQoaWZyYW1lLCBpZCwgbWFwKSB7XG4gICAgICAgIHZhciByZW1vdGVJZFRvSWRNYXAgPSBtYXAgfHwgdGhpcy5nZXRSZW1vdGVJZFRvSWRNYXAoaWZyYW1lKTtcbiAgICAgICAgaWYgKHR5cGVvZiBpZCAhPT0gXCJudW1iZXJcIikgcmV0dXJuIGlkO1xuICAgICAgICB2YXIgcmVtb3RlSWQgPSByZW1vdGVJZFRvSWRNYXAuZ2V0KGlkKTtcbiAgICAgICAgaWYgKCFyZW1vdGVJZCkgcmV0dXJuIC0xO1xuICAgICAgICByZXR1cm4gcmVtb3RlSWQ7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0UmVtb3RlSWRzID0gZnVuY3Rpb24gZ2V0UmVtb3RlSWRzKGlmcmFtZSwgaWRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciByZW1vdGVJZFRvSWRNYXAgPSB0aGlzLmdldFJlbW90ZUlkVG9JZE1hcChpZnJhbWUpO1xuICAgICAgICByZXR1cm4gaWRzLm1hcChmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldFJlbW90ZUlkKGlmcmFtZSwgaWQsIHJlbW90ZUlkVG9JZE1hcCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoaWZyYW1lKSB7XG4gICAgICAgIGlmICghaWZyYW1lKSB7XG4gICAgICAgICAgICB0aGlzLmlmcmFtZUlkVG9SZW1vdGVJZE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgICAgICAgICAgdGhpcy5pZnJhbWVSZW1vdGVJZFRvSWRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlmcmFtZUlkVG9SZW1vdGVJZE1hcC5kZWxldGUoaWZyYW1lKTtcbiAgICAgICAgdGhpcy5pZnJhbWVSZW1vdGVJZFRvSWRNYXAuZGVsZXRlKGlmcmFtZSk7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0SWRUb1JlbW90ZUlkTWFwID0gZnVuY3Rpb24gZ2V0SWRUb1JlbW90ZUlkTWFwKGlmcmFtZSkge1xuICAgICAgICB2YXIgaWRUb1JlbW90ZUlkTWFwID0gdGhpcy5pZnJhbWVJZFRvUmVtb3RlSWRNYXAuZ2V0KGlmcmFtZSk7XG4gICAgICAgIGlmICghaWRUb1JlbW90ZUlkTWFwKSB7XG4gICAgICAgICAgICBpZFRvUmVtb3RlSWRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5pZnJhbWVJZFRvUmVtb3RlSWRNYXAuc2V0KGlmcmFtZSwgaWRUb1JlbW90ZUlkTWFwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRUb1JlbW90ZUlkTWFwO1xuICAgIH07XG4gICAgX3Byb3RvLmdldFJlbW90ZUlkVG9JZE1hcCA9IGZ1bmN0aW9uIGdldFJlbW90ZUlkVG9JZE1hcChpZnJhbWUpIHtcbiAgICAgICAgdmFyIHJlbW90ZUlkVG9JZE1hcCA9IHRoaXMuaWZyYW1lUmVtb3RlSWRUb0lkTWFwLmdldChpZnJhbWUpO1xuICAgICAgICBpZiAoIXJlbW90ZUlkVG9JZE1hcCkge1xuICAgICAgICAgICAgcmVtb3RlSWRUb0lkTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuaWZyYW1lUmVtb3RlSWRUb0lkTWFwLnNldChpZnJhbWUsIHJlbW90ZUlkVG9JZE1hcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbW90ZUlkVG9JZE1hcDtcbiAgICB9O1xuICAgIHJldHVybiBDcm9zc09yaWdpbklmcmFtZU1pcnJvcjtcbn0oKTtcbnZhciBJZnJhbWVNYW5hZ2VyID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBJZnJhbWVNYW5hZ2VyKG9wdGlvbnMpIHtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiaWZyYW1lc1wiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImNyb3NzT3JpZ2luSWZyYW1lTWFwXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiY3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3JcIiwgbmV3IENyb3NzT3JpZ2luSWZyYW1lTWlycm9yKGdlbklkKSk7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImNyb3NzT3JpZ2luSWZyYW1lU3R5bGVNaXJyb3JcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImNyb3NzT3JpZ2luSWZyYW1lUm9vdElkTWFwXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwibWlycm9yXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJtdXRhdGlvbkNiXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJ3cmFwcGVkRW1pdFwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwibG9hZExpc3RlbmVyXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJzdHlsZXNoZWV0TWFuYWdlclwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwicmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzXCIpO1xuICAgICAgICB0aGlzLm11dGF0aW9uQ2IgPSBvcHRpb25zLm11dGF0aW9uQ2I7XG4gICAgICAgIHRoaXMud3JhcHBlZEVtaXQgPSBvcHRpb25zLndyYXBwZWRFbWl0O1xuICAgICAgICB0aGlzLnN0eWxlc2hlZXRNYW5hZ2VyID0gb3B0aW9ucy5zdHlsZXNoZWV0TWFuYWdlcjtcbiAgICAgICAgdGhpcy5yZWNvcmRDcm9zc09yaWdpbklmcmFtZXMgPSBvcHRpb25zLnJlY29yZENyb3NzT3JpZ2luSWZyYW1lcztcbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbklmcmFtZVN0eWxlTWlycm9yID0gbmV3IENyb3NzT3JpZ2luSWZyYW1lTWlycm9yKHRoaXMuc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3IuZ2VuZXJhdGVJZC5iaW5kKHRoaXMuc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3IpKTtcbiAgICAgICAgdGhpcy5taXJyb3IgPSBvcHRpb25zLm1pcnJvcjtcbiAgICAgICAgaWYgKHRoaXMucmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzKSB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5oYW5kbGVNZXNzYWdlLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBJZnJhbWVNYW5hZ2VyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uYWRkSWZyYW1lID0gZnVuY3Rpb24gYWRkSWZyYW1lKGlmcmFtZUVsKSB7XG4gICAgICAgIHRoaXMuaWZyYW1lcy5zZXQoaWZyYW1lRWwsIHRydWUpO1xuICAgICAgICBpZiAoaWZyYW1lRWwuY29udGVudFdpbmRvdykgdGhpcy5jcm9zc09yaWdpbklmcmFtZU1hcC5zZXQoaWZyYW1lRWwuY29udGVudFdpbmRvdywgaWZyYW1lRWwpO1xuICAgIH07XG4gICAgX3Byb3RvLmFkZExvYWRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExvYWRMaXN0ZW5lcihjYikge1xuICAgICAgICB0aGlzLmxvYWRMaXN0ZW5lciA9IGNiO1xuICAgIH07XG4gICAgX3Byb3RvLmF0dGFjaElmcmFtZSA9IGZ1bmN0aW9uIGF0dGFjaElmcmFtZShpZnJhbWVFbCwgY2hpbGRTbikge1xuICAgICAgICB2YXIgX2EyLCBfYjtcbiAgICAgICAgdGhpcy5tdXRhdGlvbkNiKHtcbiAgICAgICAgICAgIGFkZHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiB0aGlzLm1pcnJvci5nZXRJZChpZnJhbWVFbCksXG4gICAgICAgICAgICAgICAgICAgIG5leHRJZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogY2hpbGRTblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICByZW1vdmVzOiBbXSxcbiAgICAgICAgICAgIHRleHRzOiBbXSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFtdLFxuICAgICAgICAgICAgaXNBdHRhY2hJZnJhbWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLnJlY29yZENyb3NzT3JpZ2luSWZyYW1lcykgKF9hMiA9IGlmcmFtZUVsLmNvbnRlbnRXaW5kb3cpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5oYW5kbGVNZXNzYWdlLmJpbmQodGhpcykpO1xuICAgICAgICAoX2IgPSB0aGlzLmxvYWRMaXN0ZW5lcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwodGhpcywgaWZyYW1lRWwpO1xuICAgICAgICBpZiAoaWZyYW1lRWwuY29udGVudERvY3VtZW50ICYmIGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudC5hZG9wdGVkU3R5bGVTaGVldHMgJiYgaWZyYW1lRWwuY29udGVudERvY3VtZW50LmFkb3B0ZWRTdHlsZVNoZWV0cy5sZW5ndGggPiAwKSB0aGlzLnN0eWxlc2hlZXRNYW5hZ2VyLmFkb3B0U3R5bGVTaGVldHMoaWZyYW1lRWwuY29udGVudERvY3VtZW50LmFkb3B0ZWRTdHlsZVNoZWV0cywgdGhpcy5taXJyb3IuZ2V0SWQoaWZyYW1lRWwuY29udGVudERvY3VtZW50KSk7XG4gICAgfTtcbiAgICBfcHJvdG8uaGFuZGxlTWVzc2FnZSA9IGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICB2YXIgY3Jvc3NPcmlnaW5NZXNzYWdlRXZlbnQgPSBtZXNzYWdlO1xuICAgICAgICBpZiAoY3Jvc3NPcmlnaW5NZXNzYWdlRXZlbnQuZGF0YS50eXBlICE9PSBcInJyd2ViXCIgfHwgLy8gVG8gZmlsdGVyIG91dCB0aGUgcnJ3ZWIgbWVzc2FnZXMgd2hpY2ggYXJlIGZvcndhcmRlZCBieSBzb21lIHNpdGVzLlxuICAgICAgICBjcm9zc09yaWdpbk1lc3NhZ2VFdmVudC5vcmlnaW4gIT09IGNyb3NzT3JpZ2luTWVzc2FnZUV2ZW50LmRhdGEub3JpZ2luKSByZXR1cm47XG4gICAgICAgIHZhciBpZnJhbWVTb3VyY2VXaW5kb3cgPSBtZXNzYWdlLnNvdXJjZTtcbiAgICAgICAgaWYgKCFpZnJhbWVTb3VyY2VXaW5kb3cpIHJldHVybjtcbiAgICAgICAgdmFyIGlmcmFtZUVsID0gdGhpcy5jcm9zc09yaWdpbklmcmFtZU1hcC5nZXQobWVzc2FnZS5zb3VyY2UpO1xuICAgICAgICBpZiAoIWlmcmFtZUVsKSByZXR1cm47XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lZEV2ZW50ID0gdGhpcy50cmFuc2Zvcm1Dcm9zc09yaWdpbkV2ZW50KGlmcmFtZUVsLCBjcm9zc09yaWdpbk1lc3NhZ2VFdmVudC5kYXRhLmV2ZW50KTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybWVkRXZlbnQpIHRoaXMud3JhcHBlZEVtaXQodHJhbnNmb3JtZWRFdmVudCwgY3Jvc3NPcmlnaW5NZXNzYWdlRXZlbnQuZGF0YS5pc0NoZWNrb3V0KTtcbiAgICB9O1xuICAgIF9wcm90by50cmFuc2Zvcm1Dcm9zc09yaWdpbkV2ZW50ID0gZnVuY3Rpb24gdHJhbnNmb3JtQ3Jvc3NPcmlnaW5FdmVudChpZnJhbWVFbCwgZTIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgc3dpdGNoKGUyLnR5cGUpe1xuICAgICAgICAgICAgY2FzZSBFdmVudFR5cGUuRnVsbFNuYXBzaG90OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcm9zc09yaWdpbklmcmFtZU1pcnJvci5yZXNldChpZnJhbWVFbCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVTdHlsZU1pcnJvci5yZXNldChpZnJhbWVFbCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkT25Ob2RlKGUyLmRhdGEubm9kZSwgaWZyYW1lRWwpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm9vdElkID0gZTIuZGF0YS5ub2RlLmlkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lUm9vdElkTWFwLnNldChpZnJhbWVFbCwgcm9vdElkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRjaFJvb3RJZE9uTm9kZShlMi5kYXRhLm5vZGUsIHJvb3RJZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IGUyLnRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuTXV0YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZDogdGhpcy5taXJyb3IuZ2V0SWQoaWZyYW1lRWwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dElkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTogZTIuZGF0YS5ub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0F0dGFjaElmcmFtZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgRXZlbnRUeXBlLk1ldGE6XG4gICAgICAgICAgICBjYXNlIEV2ZW50VHlwZS5Mb2FkOlxuICAgICAgICAgICAgY2FzZSBFdmVudFR5cGUuRG9tQ29udGVudExvYWRlZDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEV2ZW50VHlwZS5QbHVnaW46XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBFdmVudFR5cGUuQ3VzdG9tOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRzKGUyLmRhdGEucGF5bG9hZCwgaWZyYW1lRWwsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicGFyZW50SWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicHJldmlvdXNJZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJuZXh0SWRcIlxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3Q6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goZTIuZGF0YS5zb3VyY2Upe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5NdXRhdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUyLmRhdGEuYWRkcy5mb3JFYWNoKGZ1bmN0aW9uKG4yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXBsYWNlSWRzKG4yLCBpZnJhbWVFbCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicGFyZW50SWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm5leHRJZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicHJldmlvdXNJZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlcGxhY2VJZE9uTm9kZShuMi5ub2RlLCBpZnJhbWVFbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm9vdElkID0gX3RoaXMuY3Jvc3NPcmlnaW5JZnJhbWVSb290SWRNYXAuZ2V0KGlmcmFtZUVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RJZCAmJiBfdGhpcy5wYXRjaFJvb3RJZE9uTm9kZShuMi5ub2RlLCByb290SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZTIuZGF0YS5yZW1vdmVzLmZvckVhY2goZnVuY3Rpb24objIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlcGxhY2VJZHMobjIsIGlmcmFtZUVsLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwYXJlbnRJZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlMi5kYXRhLmF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbihuMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVwbGFjZUlkcyhuMiwgaWZyYW1lRWwsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZTIuZGF0YS50ZXh0cy5mb3JFYWNoKGZ1bmN0aW9uKG4yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXBsYWNlSWRzKG4yLCBpZnJhbWVFbCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5EcmFnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5Ub3VjaE1vdmU6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLk1vdXNlTW92ZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUyLmRhdGEucG9zaXRpb25zLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVwbGFjZUlkcyhwLCBpZnJhbWVFbCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5WaWV3cG9ydFJlc2l6ZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLk1lZGlhSW50ZXJhY3Rpb246XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLk1vdXNlSW50ZXJhY3Rpb246XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLlNjcm9sbDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuQ2FudmFzTXV0YXRpb246XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLklucHV0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRzKGUyLmRhdGEsIGlmcmFtZUVsLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLlN0eWxlU2hlZXRSdWxlOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5TdHlsZURlY2xhcmF0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRzKGUyLmRhdGEsIGlmcmFtZUVsLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZVN0eWxlSWRzKGUyLmRhdGEsIGlmcmFtZUVsLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInN0eWxlSWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuRm9udDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLlNlbGVjdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUyLmRhdGEucmFuZ2VzLmZvckVhY2goZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlcGxhY2VJZHMocmFuZ2UsIGlmcmFtZUVsLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzdGFydFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZW5kXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuQWRvcHRlZFN0eWxlU2hlZXQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMoZTIuZGF0YSwgaWZyYW1lRWwsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlU3R5bGVJZHMoZTIuZGF0YSwgaWZyYW1lRWwsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic3R5bGVJZHNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9hMiA9IGUyLmRhdGEuc3R5bGVzKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmZvckVhY2goZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlcGxhY2VTdHlsZUlkcyhzdHlsZSwgaWZyYW1lRWwsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInN0eWxlSWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIF9wcm90by5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShpZnJhbWVNaXJyb3IsIG9iaiwgaWZyYW1lRWwsIGtleXMpIHtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uoa2V5cyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBrZXkgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmpba2V5XSkgJiYgdHlwZW9mIG9ialtrZXldICE9PSBcIm51bWJlclwiKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtrZXldKSkge1xuICAgICAgICAgICAgICAgIG9ialtrZXldID0gaWZyYW1lTWlycm9yLmdldElkcyhpZnJhbWVFbCwgb2JqW2tleV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IGlmcmFtZU1pcnJvci5nZXRJZChpZnJhbWVFbCwgb2JqW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVwbGFjZUlkcyA9IGZ1bmN0aW9uIHJlcGxhY2VJZHMob2JqLCBpZnJhbWVFbCwga2V5cykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3IsIG9iaiwgaWZyYW1lRWwsIGtleXMpO1xuICAgIH07XG4gICAgX3Byb3RvLnJlcGxhY2VTdHlsZUlkcyA9IGZ1bmN0aW9uIHJlcGxhY2VTdHlsZUlkcyhvYmosIGlmcmFtZUVsLCBrZXlzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2UodGhpcy5jcm9zc09yaWdpbklmcmFtZVN0eWxlTWlycm9yLCBvYmosIGlmcmFtZUVsLCBrZXlzKTtcbiAgICB9O1xuICAgIF9wcm90by5yZXBsYWNlSWRPbk5vZGUgPSBmdW5jdGlvbiByZXBsYWNlSWRPbk5vZGUobm9kZTIsIGlmcmFtZUVsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucmVwbGFjZUlkcyhub2RlMiwgaWZyYW1lRWwsIFtcbiAgICAgICAgICAgIFwiaWRcIixcbiAgICAgICAgICAgIFwicm9vdElkXCJcbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChcImNoaWxkTm9kZXNcIiBpbiBub2RlMikge1xuICAgICAgICAgICAgbm9kZTIuY2hpbGROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVwbGFjZUlkT25Ob2RlKGNoaWxkLCBpZnJhbWVFbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnBhdGNoUm9vdElkT25Ob2RlID0gZnVuY3Rpb24gcGF0Y2hSb290SWRPbk5vZGUobm9kZTIsIHJvb3RJZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobm9kZTIudHlwZSAhPT0gTm9kZVR5cGUuRG9jdW1lbnQgJiYgIW5vZGUyLnJvb3RJZCkgbm9kZTIucm9vdElkID0gcm9vdElkO1xuICAgICAgICBpZiAoXCJjaGlsZE5vZGVzXCIgaW4gbm9kZTIpIHtcbiAgICAgICAgICAgIG5vZGUyLmNoaWxkTm9kZXMuZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnBhdGNoUm9vdElkT25Ob2RlKGNoaWxkLCByb290SWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBJZnJhbWVNYW5hZ2VyO1xufSgpO1xudmFyIFNoYWRvd0RvbU1hbmFnZXIgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFNoYWRvd0RvbU1hbmFnZXIob3B0aW9ucykge1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJzaGFkb3dEb21zXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwibXV0YXRpb25DYlwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwic2Nyb2xsQ2JcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImJ5cGFzc09wdGlvbnNcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcIm1pcnJvclwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwicmVzdG9yZUhhbmRsZXJzXCIsIFtdKTtcbiAgICAgICAgdGhpcy5tdXRhdGlvbkNiID0gb3B0aW9ucy5tdXRhdGlvbkNiO1xuICAgICAgICB0aGlzLnNjcm9sbENiID0gb3B0aW9ucy5zY3JvbGxDYjtcbiAgICAgICAgdGhpcy5ieXBhc3NPcHRpb25zID0gb3B0aW9ucy5ieXBhc3NPcHRpb25zO1xuICAgICAgICB0aGlzLm1pcnJvciA9IG9wdGlvbnMubWlycm9yO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFNoYWRvd0RvbU1hbmFnZXIucHJvdG90eXBlO1xuICAgIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLnBhdGNoQXR0YWNoU2hhZG93KEVsZW1lbnQsIGRvY3VtZW50KTtcbiAgICB9O1xuICAgIF9wcm90by5hZGRTaGFkb3dSb290ID0gZnVuY3Rpb24gYWRkU2hhZG93Um9vdChzaGFkb3dSb290MiwgZG9jKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghaXNOYXRpdmVTaGFkb3dEb20oc2hhZG93Um9vdDIpKSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnNoYWRvd0RvbXMuaGFzKHNoYWRvd1Jvb3QyKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLnNoYWRvd0RvbXMuYWRkKHNoYWRvd1Jvb3QyKTtcbiAgICAgICAgdmFyIG9ic2VydmVyID0gaW5pdE11dGF0aW9uT2JzZXJ2ZXIoX2V4dGVuZHMoe30sIHRoaXMuYnlwYXNzT3B0aW9ucywge1xuICAgICAgICAgICAgZG9jOiBkb2MsXG4gICAgICAgICAgICBtdXRhdGlvbkNiOiB0aGlzLm11dGF0aW9uQ2IsXG4gICAgICAgICAgICBtaXJyb3I6IHRoaXMubWlycm9yLFxuICAgICAgICAgICAgc2hhZG93RG9tTWFuYWdlcjogdGhpc1xuICAgICAgICB9KSwgc2hhZG93Um9vdDIpO1xuICAgICAgICB0aGlzLnJlc3RvcmVIYW5kbGVycy5wdXNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzLnB1c2goaW5pdFNjcm9sbE9ic2VydmVyKF9leHRlbmRzKHt9LCB0aGlzLmJ5cGFzc09wdGlvbnMsIHtcbiAgICAgICAgICAgIHNjcm9sbENiOiB0aGlzLnNjcm9sbENiLFxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcHJhdmVlbnB1Z2xpYS8wODMyZGE2ODdlZDVhNWQ3YTA5MDcwNDZjOWVmMTgxM1xuICAgICAgICAgICAgLy8gc2Nyb2xsIGlzIG5vdCBhbGxvd2VkIHRvIHBhc3MgdGhlIGJvdW5kYXJ5LCBzbyB3ZSBuZWVkIHRvIGxpc3RlbiB0aGUgc2hhZG93IGRvY3VtZW50XG4gICAgICAgICAgICBkb2M6IHNoYWRvd1Jvb3QyLFxuICAgICAgICAgICAgbWlycm9yOiB0aGlzLm1pcnJvclxuICAgICAgICB9KSkpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHNoYWRvd1Jvb3QyLmFkb3B0ZWRTdHlsZVNoZWV0cyAmJiBzaGFkb3dSb290Mi5hZG9wdGVkU3R5bGVTaGVldHMubGVuZ3RoID4gMCkgX3RoaXMuYnlwYXNzT3B0aW9ucy5zdHlsZXNoZWV0TWFuYWdlci5hZG9wdFN0eWxlU2hlZXRzKHNoYWRvd1Jvb3QyLmFkb3B0ZWRTdHlsZVNoZWV0cywgX3RoaXMubWlycm9yLmdldElkKGluZGV4Lmhvc3Qoc2hhZG93Um9vdDIpKSk7XG4gICAgICAgICAgICBfdGhpcy5yZXN0b3JlSGFuZGxlcnMucHVzaChpbml0QWRvcHRlZFN0eWxlU2hlZXRPYnNlcnZlcih7XG4gICAgICAgICAgICAgICAgbWlycm9yOiBfdGhpcy5taXJyb3IsXG4gICAgICAgICAgICAgICAgc3R5bGVzaGVldE1hbmFnZXI6IF90aGlzLmJ5cGFzc09wdGlvbnMuc3R5bGVzaGVldE1hbmFnZXJcbiAgICAgICAgICAgIH0sIHNoYWRvd1Jvb3QyKSk7XG4gICAgICAgIH0sIDApO1xuICAgIH07XG4gICAgLyoqXG4gICAqIE1vbmtleSBwYXRjaCAnYXR0YWNoU2hhZG93JyBvZiBhbiBJRnJhbWVFbGVtZW50IHRvIG9ic2VydmUgbmV3bHkgYWRkZWQgc2hhZG93IGRvbXMuXG4gICAqLyBfcHJvdG8ub2JzZXJ2ZUF0dGFjaFNoYWRvdyA9IGZ1bmN0aW9uIG9ic2VydmVBdHRhY2hTaGFkb3coaWZyYW1lRWxlbWVudCkge1xuICAgICAgICBpZiAoIWlmcmFtZUVsZW1lbnQuY29udGVudFdpbmRvdyB8fCAhaWZyYW1lRWxlbWVudC5jb250ZW50RG9jdW1lbnQpIHJldHVybjtcbiAgICAgICAgdGhpcy5wYXRjaEF0dGFjaFNoYWRvdyhpZnJhbWVFbGVtZW50LmNvbnRlbnRXaW5kb3cuRWxlbWVudCwgaWZyYW1lRWxlbWVudC5jb250ZW50RG9jdW1lbnQpO1xuICAgIH07XG4gICAgLyoqXG4gICAqIFBhdGNoICdhdHRhY2hTaGFkb3cnIHRvIG9ic2VydmUgbmV3bHkgYWRkZWQgc2hhZG93IGRvbXMuXG4gICAqLyBfcHJvdG8ucGF0Y2hBdHRhY2hTaGFkb3cgPSBmdW5jdGlvbiBwYXRjaEF0dGFjaFNoYWRvdyhlbGVtZW50LCBkb2MpIHtcbiAgICAgICAgdmFyIG1hbmFnZXIgPSB0aGlzO1xuICAgICAgICB0aGlzLnJlc3RvcmVIYW5kbGVycy5wdXNoKHBhdGNoJDIoZWxlbWVudC5wcm90b3R5cGUsIFwiYXR0YWNoU2hhZG93XCIsIGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNSb290ID0gb3JpZ2luYWwuY2FsbCh0aGlzLCBvcHRpb24pO1xuICAgICAgICAgICAgICAgIHZhciBzaGFkb3dSb290RWwgPSBpbmRleC5zaGFkb3dSb290KHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmIChzaGFkb3dSb290RWwgJiYgaW5Eb20odGhpcykpIG1hbmFnZXIuYWRkU2hhZG93Um9vdChzaGFkb3dSb290RWwsIGRvYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNSb290O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkpO1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlMikge31cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzID0gW107XG4gICAgICAgIHRoaXMuc2hhZG93RG9tcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICAgIH07XG4gICAgcmV0dXJuIFNoYWRvd0RvbU1hbmFnZXI7XG59KCk7XG52YXIgY2hhcnMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtcbnZhciBsb29rdXAgPSB0eXBlb2YgVWludDhBcnJheSA9PT0gXCJ1bmRlZmluZWRcIiA/IFtdIDogbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbmZvcih2YXIgaSQxID0gMDsgaSQxIDwgY2hhcnMubGVuZ3RoOyBpJDErKyl7XG4gICAgbG9va3VwW2NoYXJzLmNoYXJDb2RlQXQoaSQxKV0gPSBpJDE7XG59XG52YXIgZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGFycmF5YnVmZmVyKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpLCBpMiwgbGVuID0gYnl0ZXMubGVuZ3RoLCBiYXNlNjQgPSBcIlwiO1xuICAgIGZvcihpMiA9IDA7IGkyIDwgbGVuOyBpMiArPSAzKXtcbiAgICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kyXSA+PiAyXTtcbiAgICAgICAgYmFzZTY0ICs9IGNoYXJzWyhieXRlc1tpMl0gJiAzKSA8PCA0IHwgYnl0ZXNbaTIgKyAxXSA+PiA0XTtcbiAgICAgICAgYmFzZTY0ICs9IGNoYXJzWyhieXRlc1tpMiArIDFdICYgMTUpIDw8IDIgfCBieXRlc1tpMiArIDJdID4+IDZdO1xuICAgICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaTIgKyAyXSAmIDYzXTtcbiAgICB9XG4gICAgaWYgKGxlbiAlIDMgPT09IDIpIHtcbiAgICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMSkgKyBcIj1cIjtcbiAgICB9IGVsc2UgaWYgKGxlbiAlIDMgPT09IDEpIHtcbiAgICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMikgKyBcIj09XCI7XG4gICAgfVxuICAgIHJldHVybiBiYXNlNjQ7XG59O1xudmFyIGNhbnZhc1Zhck1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiB2YXJpYWJsZUxpc3RGb3IkMShjdHgsIGN0b3IpIHtcbiAgICB2YXIgY29udGV4dE1hcCA9IGNhbnZhc1Zhck1hcC5nZXQoY3R4KTtcbiAgICBpZiAoIWNvbnRleHRNYXApIHtcbiAgICAgICAgY29udGV4dE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGNhbnZhc1Zhck1hcC5zZXQoY3R4LCBjb250ZXh0TWFwKTtcbiAgICB9XG4gICAgaWYgKCFjb250ZXh0TWFwLmhhcyhjdG9yKSkge1xuICAgICAgICBjb250ZXh0TWFwLnNldChjdG9yLCBbXSk7XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0TWFwLmdldChjdG9yKTtcbn1cbnZhciBzYXZlV2ViR0xWYXIgPSBmdW5jdGlvbih2YWx1ZSwgd2luLCBjdHgpIHtcbiAgICBpZiAoIXZhbHVlIHx8ICEoaXNJbnN0YW5jZU9mV2ViR0xPYmplY3QodmFsdWUsIHdpbikgfHwgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZih2YWx1ZSkpID09PSBcIm9iamVjdFwiKSkgcmV0dXJuO1xuICAgIHZhciBuYW1lID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgICB2YXIgbGlzdDIgPSB2YXJpYWJsZUxpc3RGb3IkMShjdHgsIG5hbWUpO1xuICAgIHZhciBpbmRleDIgPSBsaXN0Mi5pbmRleE9mKHZhbHVlKTtcbiAgICBpZiAoaW5kZXgyID09PSAtMSkge1xuICAgICAgICBpbmRleDIgPSBsaXN0Mi5sZW5ndGg7XG4gICAgICAgIGxpc3QyLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZXgyO1xufTtcbmZ1bmN0aW9uIHNlcmlhbGl6ZUFyZyh2YWx1ZSwgd2luLCBjdHgpIHtcbiAgICBpZiAoX2luc3RhbmNlb2YodmFsdWUsIEFycmF5KSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uKGFyZykge1xuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZUFyZyhhcmcsIHdpbiwgY3R4KTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZih2YWx1ZSwgRmxvYXQzMkFycmF5KSB8fCBfaW5zdGFuY2VvZih2YWx1ZSwgRmxvYXQ2NEFycmF5KSB8fCBfaW5zdGFuY2VvZih2YWx1ZSwgSW50MzJBcnJheSkgfHwgX2luc3RhbmNlb2YodmFsdWUsIFVpbnQzMkFycmF5KSB8fCBfaW5zdGFuY2VvZih2YWx1ZSwgVWludDhBcnJheSkgfHwgX2luc3RhbmNlb2YodmFsdWUsIFVpbnQxNkFycmF5KSB8fCBfaW5zdGFuY2VvZih2YWx1ZSwgSW50MTZBcnJheSkgfHwgX2luc3RhbmNlb2YodmFsdWUsIEludDhBcnJheSkgfHwgX2luc3RhbmNlb2YodmFsdWUsIFVpbnQ4Q2xhbXBlZEFycmF5KSkge1xuICAgICAgICB2YXIgbmFtZSA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBycl90eXBlOiBuYW1lLFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIE9iamVjdC52YWx1ZXModmFsdWUpXG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmICgvLyBTaGFyZWRBcnJheUJ1ZmZlciBkaXNhYmxlZCBvbiBtb3N0IGJyb3dzZXJzIGR1ZSB0byBzcGVjdHJlLlxuICAgIC8vIE1vcmUgaW5mbzogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU2hhcmVkQXJyYXlCdWZmZXIvU2hhcmVkQXJyYXlCdWZmZXJcbiAgICAvLyB2YWx1ZSBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyIHx8XG4gICAgX2luc3RhbmNlb2YodmFsdWUsIEFycmF5QnVmZmVyKSkge1xuICAgICAgICB2YXIgbmFtZTEgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICB2YXIgYmFzZTY0ID0gZW5jb2RlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJyX3R5cGU6IG5hbWUxLFxuICAgICAgICAgICAgYmFzZTY0OiBiYXNlNjRcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKF9pbnN0YW5jZW9mKHZhbHVlLCBEYXRhVmlldykpIHtcbiAgICAgICAgdmFyIG5hbWUyID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJyX3R5cGU6IG5hbWUyLFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZUFyZyh2YWx1ZS5idWZmZXIsIHdpbiwgY3R4KSxcbiAgICAgICAgICAgICAgICB2YWx1ZS5ieXRlT2Zmc2V0LFxuICAgICAgICAgICAgICAgIHZhbHVlLmJ5dGVMZW5ndGhcbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKF9pbnN0YW5jZW9mKHZhbHVlLCBIVE1MSW1hZ2VFbGVtZW50KSkge1xuICAgICAgICB2YXIgbmFtZTMgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICB2YXIgc3JjID0gdmFsdWUuc3JjO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcnJfdHlwZTogbmFtZTMsXG4gICAgICAgICAgICBzcmM6IHNyY1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoX2luc3RhbmNlb2YodmFsdWUsIEhUTUxDYW52YXNFbGVtZW50KSkge1xuICAgICAgICB2YXIgbmFtZTQgPSBcIkhUTUxJbWFnZUVsZW1lbnRcIjtcbiAgICAgICAgdmFyIHNyYzEgPSB2YWx1ZS50b0RhdGFVUkwoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJyX3R5cGU6IG5hbWU0LFxuICAgICAgICAgICAgc3JjOiBzcmMxXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZih2YWx1ZSwgSW1hZ2VEYXRhKSkge1xuICAgICAgICB2YXIgbmFtZTUgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcnJfdHlwZTogbmFtZTUsXG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplQXJnKHZhbHVlLmRhdGEsIHdpbiwgY3R4KSxcbiAgICAgICAgICAgICAgICB2YWx1ZS53aWR0aCxcbiAgICAgICAgICAgICAgICB2YWx1ZS5oZWlnaHRcbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGlzSW5zdGFuY2VPZldlYkdMT2JqZWN0KHZhbHVlLCB3aW4pIHx8ICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YodmFsdWUpKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB2YXIgbmFtZTYgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICB2YXIgaW5kZXgyID0gc2F2ZVdlYkdMVmFyKHZhbHVlLCB3aW4sIGN0eCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBycl90eXBlOiBuYW1lNixcbiAgICAgICAgICAgIGluZGV4OiBpbmRleDJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxudmFyIHNlcmlhbGl6ZUFyZ3MgPSBmdW5jdGlvbihhcmdzLCB3aW4sIGN0eCkge1xuICAgIHJldHVybiBhcmdzLm1hcChmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZUFyZyhhcmcsIHdpbiwgY3R4KTtcbiAgICB9KTtcbn07XG52YXIgaXNJbnN0YW5jZU9mV2ViR0xPYmplY3QgPSBmdW5jdGlvbih2YWx1ZSwgd2luKSB7XG4gICAgdmFyIHdlYkdMQ29uc3RydWN0b3JOYW1lcyA9IFtcbiAgICAgICAgXCJXZWJHTEFjdGl2ZUluZm9cIixcbiAgICAgICAgXCJXZWJHTEJ1ZmZlclwiLFxuICAgICAgICBcIldlYkdMRnJhbWVidWZmZXJcIixcbiAgICAgICAgXCJXZWJHTFByb2dyYW1cIixcbiAgICAgICAgXCJXZWJHTFJlbmRlcmJ1ZmZlclwiLFxuICAgICAgICBcIldlYkdMU2hhZGVyXCIsXG4gICAgICAgIFwiV2ViR0xTaGFkZXJQcmVjaXNpb25Gb3JtYXRcIixcbiAgICAgICAgXCJXZWJHTFRleHR1cmVcIixcbiAgICAgICAgXCJXZWJHTFVuaWZvcm1Mb2NhdGlvblwiLFxuICAgICAgICBcIldlYkdMVmVydGV4QXJyYXlPYmplY3RcIixcbiAgICAgICAgLy8gSW4gb2xkIENocm9tZSB2ZXJzaW9ucywgdmFsdWUgd29uJ3QgYmUgYW4gaW5zdGFuY2VvZiBXZWJHTFZlcnRleEFycmF5T2JqZWN0LlxuICAgICAgICBcIldlYkdMVmVydGV4QXJyYXlPYmplY3RPRVNcIlxuICAgIF07XG4gICAgdmFyIHN1cHBvcnRlZFdlYkdMQ29uc3RydWN0b3JOYW1lcyA9IHdlYkdMQ29uc3RydWN0b3JOYW1lcy5maWx0ZXIoZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHdpbltuYW1lXSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIH0pO1xuICAgIHJldHVybiBCb29sZWFuKHN1cHBvcnRlZFdlYkdMQ29uc3RydWN0b3JOYW1lcy5maW5kKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF9pbnN0YW5jZW9mKHZhbHVlLCB3aW5bbmFtZV0pO1xuICAgIH0pKTtcbn07XG5mdW5jdGlvbiBpbml0Q2FudmFzMkRNdXRhdGlvbk9ic2VydmVyKGNiLCB3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpIHtcbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHByb3AgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luLkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGVbcHJvcF0gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdG9yZUhhbmRsZXIgPSBwYXRjaCQyKHdpbi5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLCBwcm9wLCBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQmxvY2tlZCh0aGlzLmNhbnZhcywgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlY29yZEFyZ3MgPSBzZXJpYWxpemVBcmdzKGFyZ3MsIHdpbiwgX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiKF90aGlzLmNhbnZhcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBDYW52YXNDb250ZXh0W1wiMkRcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiByZWNvcmRBcmdzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChyZXN0b3JlSGFuZGxlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHZhciBob29rSGFuZGxlciA9IGhvb2tTZXR0ZXIod2luLkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUsIHByb3AsIHtcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2Mikge1xuICAgICAgICAgICAgICAgICAgICBjYih0aGlzLmNhbnZhcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQ2FudmFzQ29udGV4dFtcIjJEXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHByb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0ZXI6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBoYW5kbGVycy5wdXNoKGhvb2tIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGhhbmRsZXJzID0gW107XG4gICAgdmFyIHByb3BzMkQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW4uQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZSk7XG4gICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UocHJvcHMyRCksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KV9sb29wKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgIHJldHVybiBoKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiBnZXROb3JtYWxpemVkQ29udGV4dE5hbWUoY29udGV4dFR5cGUpIHtcbiAgICByZXR1cm4gY29udGV4dFR5cGUgPT09IFwiZXhwZXJpbWVudGFsLXdlYmdsXCIgPyBcIndlYmdsXCIgOiBjb250ZXh0VHlwZTtcbn1cbmZ1bmN0aW9uIGluaXRDYW52YXNDb250ZXh0T2JzZXJ2ZXIod2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBzZXRQcmVzZXJ2ZURyYXdpbmdCdWZmZXJUb1RydWUpIHtcbiAgICB2YXIgaGFuZGxlcnMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdG9yZUhhbmRsZXIgPSBwYXRjaCQyKHdpbi5IVE1MQ2FudmFzRWxlbWVudC5wcm90b3R5cGUsIFwiZ2V0Q29udGV4dFwiLCBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbnRleHRUeXBlKSB7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNCbG9ja2VkKHRoaXMsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHhOYW1lID0gZ2V0Tm9ybWFsaXplZENvbnRleHROYW1lKGNvbnRleHRUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoXCJfX2NvbnRleHRcIiBpbiB0aGlzKSkgdGhpcy5fX2NvbnRleHQgPSBjdHhOYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0UHJlc2VydmVEcmF3aW5nQnVmZmVyVG9UcnVlICYmIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwid2ViZ2xcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwid2ViZ2wyXCJcbiAgICAgICAgICAgICAgICAgICAgXS5pbmNsdWRlcyhjdHhOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3NbMF0gJiYgX3R5cGVfb2YoYXJnc1swXSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dEF0dHJpYnV0ZXMgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29udGV4dEF0dHJpYnV0ZXMucHJlc2VydmVEcmF3aW5nQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRBdHRyaWJ1dGVzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnNwbGljZSgwLCAxLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbXS5jb25jYXQoW1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0VHlwZVxuICAgICAgICAgICAgICAgIF0sIGFyZ3MpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBoYW5kbGVycy5wdXNoKHJlc3RvcmVIYW5kbGVyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJmYWlsZWQgdG8gcGF0Y2ggSFRNTENhbnZhc0VsZW1lbnQucHJvdG90eXBlLmdldENvbnRleHRcIik7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICByZXR1cm4gaCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gcGF0Y2hHTFByb3RvdHlwZShwcm90b3R5cGUsIHR5cGUsIGNiLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB3aW4pIHtcbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHByb3AgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgaWYgKC8vcHJvcC5zdGFydHNXaXRoKCdnZXQnKSB8fCAgLy8gZS5nLiBnZXRQcm9ncmFtUGFyYW1ldGVyLCBidXQgdG9vIHJpc2t5XG4gICAgICAgIFtcbiAgICAgICAgICAgIFwiaXNDb250ZXh0TG9zdFwiLFxuICAgICAgICAgICAgXCJjYW52YXNcIixcbiAgICAgICAgICAgIFwiZHJhd2luZ0J1ZmZlcldpZHRoXCIsXG4gICAgICAgICAgICBcImRyYXdpbmdCdWZmZXJIZWlnaHRcIlxuICAgICAgICBdLmluY2x1ZGVzKHByb3ApKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3RvdHlwZVtwcm9wXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN0b3JlSGFuZGxlciA9IHBhdGNoJDIocHJvdG90eXBlLCBwcm9wLCBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MiA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICBzYXZlV2ViR0xWYXIocmVzdWx0Miwgd2luLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwidGFnTmFtZVwiIGluIHRoaXMuY2FudmFzICYmICFpc0Jsb2NrZWQodGhpcy5jYW52YXMsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjb3JkQXJncyA9IHNlcmlhbGl6ZUFyZ3MoYXJncywgd2luLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtdXRhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IHJlY29yZEFyZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYih0aGlzLmNhbnZhcywgbXV0YXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhhbmRsZXJzLnB1c2gocmVzdG9yZUhhbmRsZXIpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB2YXIgaG9va0hhbmRsZXIgPSBob29rU2V0dGVyKHByb3RvdHlwZSwgcHJvcCwge1xuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHYyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiKHRoaXMuY2FudmFzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHByb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0ZXI6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBoYW5kbGVycy5wdXNoKGhvb2tIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGhhbmRsZXJzID0gW107XG4gICAgdmFyIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG90eXBlKTtcbiAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShwcm9wcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KV9sb29wKCk7XG4gICAgcmV0dXJuIGhhbmRsZXJzO1xufVxuZnVuY3Rpb24gaW5pdENhbnZhc1dlYkdMTXV0YXRpb25PYnNlcnZlcihjYiwgd2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKSB7XG4gICAgdmFyIF9oYW5kbGVycztcbiAgICB2YXIgaGFuZGxlcnMgPSBbXTtcbiAgICAoX2hhbmRsZXJzID0gaGFuZGxlcnMpLnB1c2guYXBwbHkoX2hhbmRsZXJzLCBbXS5jb25jYXQocGF0Y2hHTFByb3RvdHlwZSh3aW4uV2ViR0xSZW5kZXJpbmdDb250ZXh0LnByb3RvdHlwZSwgQ2FudmFzQ29udGV4dC5XZWJHTCwgY2IsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHdpbikpKTtcbiAgICBpZiAodHlwZW9mIHdpbi5XZWJHTDJSZW5kZXJpbmdDb250ZXh0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHZhciBfaGFuZGxlcnMxO1xuICAgICAgICAoX2hhbmRsZXJzMSA9IGhhbmRsZXJzKS5wdXNoLmFwcGx5KF9oYW5kbGVyczEsIFtdLmNvbmNhdChwYXRjaEdMUHJvdG90eXBlKHdpbi5XZWJHTDJSZW5kZXJpbmdDb250ZXh0LnByb3RvdHlwZSwgQ2FudmFzQ29udGV4dC5XZWJHTDIsIGNiLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB3aW4pKSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICByZXR1cm4gaCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxudmFyIGVuY29kZWRKcyA9IFwiS0daMWJtTjBhVzl1S0NrZ2V3b2dJQ0oxYzJVZ2MzUnlhV04wSWpzS0lDQjJZWElnWTJoaGNuTWdQU0FpUVVKRFJFVkdSMGhKU2t0TVRVNVBVRkZTVTFSVlZsZFlXVnBoWW1Oa1pXWm5hR2xxYTJ4dGJtOXdjWEp6ZEhWMmQzaDVlakF4TWpNME5UWTNPRGtyTHlJN0NpQWdkbUZ5SUd4dmIydDFjQ0E5SUhSNWNHVnZaaUJWYVc1ME9FRnljbUY1SUQwOVBTQWlkVzVrWldacGJtVmtJaUEvSUZ0ZElEb2dibVYzSUZWcGJuUTRRWEp5WVhrb01qVTJLVHNLSUNCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElHTm9ZWEp6TG14bGJtZDBhRHNnYVNzcktTQjdDaUFnSUNCc2IyOXJkWEJiWTJoaGNuTXVZMmhoY2tOdlpHVkJkQ2hwS1YwZ1BTQnBPd29nSUgwS0lDQjJZWElnWlc1amIyUmxJRDBnWm5WdVkzUnBiMjRvWVhKeVlYbGlkV1ptWlhJcElIc0tJQ0FnSUhaaGNpQmllWFJsY3lBOUlHNWxkeUJWYVc1ME9FRnljbUY1S0dGeWNtRjVZblZtWm1WeUtTd2dhVElzSUd4bGJpQTlJR0o1ZEdWekxteGxibWQwYUN3Z1ltRnpaVFkwSUQwZ0lpSTdDaUFnSUNCbWIzSWdLR2t5SUQwZ01Ec2dhVElnUENCc1pXNDdJR2t5SUNzOUlETXBJSHNLSUNBZ0lDQWdZbUZ6WlRZMElDczlJR05vWVhKelcySjVkR1Z6VzJreVhTQStQaUF5WFRzS0lDQWdJQ0FnWW1GelpUWTBJQ3M5SUdOb1lYSnpXeWhpZVhSbGMxdHBNbDBnSmlBektTQThQQ0EwSUh3Z1lubDBaWE5iYVRJZ0t5QXhYU0ErUGlBMFhUc0tJQ0FnSUNBZ1ltRnpaVFkwSUNzOUlHTm9ZWEp6V3loaWVYUmxjMXRwTWlBcklERmRJQ1lnTVRVcElEdzhJRElnZkNCaWVYUmxjMXRwTWlBcklESmRJRDQrSURaZE93b2dJQ0FnSUNCaVlYTmxOalFnS3owZ1kyaGhjbk5iWW5sMFpYTmJhVElnS3lBeVhTQW1JRFl6WFRzS0lDQWdJSDBLSUNBZ0lHbG1JQ2hzWlc0Z0pTQXpJRDA5UFNBeUtTQjdDaUFnSUNBZ0lHSmhjMlUyTkNBOUlHSmhjMlUyTkM1emRXSnpkSEpwYm1jb01Dd2dZbUZ6WlRZMExteGxibWQwYUNBdElERXBJQ3NnSWowaU93b2dJQ0FnZlNCbGJITmxJR2xtSUNoc1pXNGdKU0F6SUQwOVBTQXhLU0I3Q2lBZ0lDQWdJR0poYzJVMk5DQTlJR0poYzJVMk5DNXpkV0p6ZEhKcGJtY29NQ3dnWW1GelpUWTBMbXhsYm1kMGFDQXRJRElwSUNzZ0lqMDlJanNLSUNBZ0lIMEtJQ0FnSUhKbGRIVnliaUJpWVhObE5qUTdDaUFnZlRzS0lDQmpiMjV6ZENCc1lYTjBRbXh2WWsxaGNDQTlJQzhxSUVCZlgxQlZVa1ZmWHlBcUx5QnVaWGNnVFdGd0tDazdDaUFnWTI5dWMzUWdkSEpoYm5Od1lYSmxiblJDYkc5aVRXRndJRDBnTHlvZ1FGOWZVRlZTUlY5ZklDb3ZJRzVsZHlCTllYQW9LVHNLSUNCaGMzbHVZeUJtZFc1amRHbHZiaUJuWlhSVWNtRnVjM0JoY21WdWRFSnNiMkpHYjNJb2QybGtkR2dzSUdobGFXZG9kQ3dnWkdGMFlWVlNURTl3ZEdsdmJuTXBJSHNLSUNBZ0lHTnZibk4wSUdsa0lEMGdZQ1I3ZDJsa2RHaDlMU1I3YUdWcFoyaDBmV0E3Q2lBZ0lDQnBaaUFvSWs5bVpuTmpjbVZsYmtOaGJuWmhjeUlnYVc0Z1oyeHZZbUZzVkdocGN5a2dld29nSUNBZ0lDQnBaaUFvZEhKaGJuTndZWEpsYm5SQ2JHOWlUV0Z3TG1oaGN5aHBaQ2twSUhKbGRIVnliaUIwY21GdWMzQmhjbVZ1ZEVKc2IySk5ZWEF1WjJWMEtHbGtLVHNLSUNBZ0lDQWdZMjl1YzNRZ2IyWm1jMk55WldWdUlEMGdibVYzSUU5bVpuTmpjbVZsYmtOaGJuWmhjeWgzYVdSMGFDd2dhR1ZwWjJoMEtUc0tJQ0FnSUNBZ2IyWm1jMk55WldWdUxtZGxkRU52Ym5SbGVIUW9JakprSWlrN0NpQWdJQ0FnSUdOdmJuTjBJR0pzYjJJZ1BTQmhkMkZwZENCdlptWnpZM0psWlc0dVkyOXVkbVZ5ZEZSdlFteHZZaWhrWVhSaFZWSk1UM0IwYVc5dWN5azdDaUFnSUNBZ0lHTnZibk4wSUdGeWNtRjVRblZtWm1WeUlEMGdZWGRoYVhRZ1lteHZZaTVoY25KaGVVSjFabVpsY2lncE93b2dJQ0FnSUNCamIyNXpkQ0JpWVhObE5qUWdQU0JsYm1OdlpHVW9ZWEp5WVhsQ2RXWm1aWElwT3dvZ0lDQWdJQ0IwY21GdWMzQmhjbVZ1ZEVKc2IySk5ZWEF1YzJWMEtHbGtMQ0JpWVhObE5qUXBPd29nSUNBZ0lDQnlaWFIxY200Z1ltRnpaVFkwT3dvZ0lDQWdmU0JsYkhObElIc0tJQ0FnSUNBZ2NtVjBkWEp1SUNJaU93b2dJQ0FnZlFvZ0lIMEtJQ0JqYjI1emRDQjNiM0pyWlhJZ1BTQnpaV3htT3dvZ0lIZHZjbXRsY2k1dmJtMWxjM05oWjJVZ1BTQmhjM2x1WXlCbWRXNWpkR2x2YmlobEtTQjdDaUFnSUNCcFppQW9JazltWm5OamNtVmxia05oYm5aaGN5SWdhVzRnWjJ4dlltRnNWR2hwY3lrZ2V3b2dJQ0FnSUNCamIyNXpkQ0I3SUdsa0xDQmlhWFJ0WVhBc0lIZHBaSFJvTENCb1pXbG5hSFFzSUdSaGRHRlZVa3hQY0hScGIyNXpJSDBnUFNCbExtUmhkR0U3Q2lBZ0lDQWdJR052Ym5OMElIUnlZVzV6Y0dGeVpXNTBRbUZ6WlRZMElEMGdaMlYwVkhKaGJuTndZWEpsYm5SQ2JHOWlSbTl5S0FvZ0lDQWdJQ0FnSUhkcFpIUm9MQW9nSUNBZ0lDQWdJR2hsYVdkb2RDd0tJQ0FnSUNBZ0lDQmtZWFJoVlZKTVQzQjBhVzl1Y3dvZ0lDQWdJQ0FwT3dvZ0lDQWdJQ0JqYjI1emRDQnZabVp6WTNKbFpXNGdQU0J1WlhjZ1QyWm1jMk55WldWdVEyRnVkbUZ6S0hkcFpIUm9MQ0JvWldsbmFIUXBPd29nSUNBZ0lDQmpiMjV6ZENCamRIZ2dQU0J2Wm1aelkzSmxaVzR1WjJWMFEyOXVkR1Y0ZENnaU1tUWlLVHNLSUNBZ0lDQWdZM1I0TG1SeVlYZEpiV0ZuWlNoaWFYUnRZWEFzSURBc0lEQXBPd29nSUNBZ0lDQmlhWFJ0WVhBdVkyeHZjMlVvS1RzS0lDQWdJQ0FnWTI5dWMzUWdZbXh2WWlBOUlHRjNZV2wwSUc5bVpuTmpjbVZsYmk1amIyNTJaWEowVkc5Q2JHOWlLR1JoZEdGVlVreFBjSFJwYjI1ektUc0tJQ0FnSUNBZ1kyOXVjM1FnZEhsd1pTQTlJR0pzYjJJdWRIbHdaVHNLSUNBZ0lDQWdZMjl1YzNRZ1lYSnlZWGxDZFdabVpYSWdQU0JoZDJGcGRDQmliRzlpTG1GeWNtRjVRblZtWm1WeUtDazdDaUFnSUNBZ0lHTnZibk4wSUdKaGMyVTJOQ0E5SUdWdVkyOWtaU2hoY25KaGVVSjFabVpsY2lrN0NpQWdJQ0FnSUdsbUlDZ2hiR0Z6ZEVKc2IySk5ZWEF1YUdGektHbGtLU0FtSmlCaGQyRnBkQ0IwY21GdWMzQmhjbVZ1ZEVKaGMyVTJOQ0E5UFQwZ1ltRnpaVFkwS1NCN0NpQWdJQ0FnSUNBZ2JHRnpkRUpzYjJKTllYQXVjMlYwS0dsa0xDQmlZWE5sTmpRcE93b2dJQ0FnSUNBZ0lISmxkSFZ5YmlCM2IzSnJaWEl1Y0c5emRFMWxjM05oWjJVb2V5QnBaQ0I5S1RzS0lDQWdJQ0FnZlFvZ0lDQWdJQ0JwWmlBb2JHRnpkRUpzYjJKTllYQXVaMlYwS0dsa0tTQTlQVDBnWW1GelpUWTBLU0J5WlhSMWNtNGdkMjl5YTJWeUxuQnZjM1JOWlhOellXZGxLSHNnYVdRZ2ZTazdDaUFnSUNBZ0lIZHZjbXRsY2k1d2IzTjBUV1Z6YzJGblpTaDdDaUFnSUNBZ0lDQWdhV1FzQ2lBZ0lDQWdJQ0FnZEhsd1pTd0tJQ0FnSUNBZ0lDQmlZWE5sTmpRc0NpQWdJQ0FnSUNBZ2QybGtkR2dzQ2lBZ0lDQWdJQ0FnYUdWcFoyaDBDaUFnSUNBZ0lIMHBPd29nSUNBZ0lDQnNZWE4wUW14dllrMWhjQzV6WlhRb2FXUXNJR0poYzJVMk5DazdDaUFnSUNCOUlHVnNjMlVnZXdvZ0lDQWdJQ0J5WlhSMWNtNGdkMjl5YTJWeUxuQnZjM1JOWlhOellXZGxLSHNnYVdRNklHVXVaR0YwWVM1cFpDQjlLVHNLSUNBZ0lIMEtJQ0I5T3dwOUtTZ3BPd292THlNZ2MyOTFjbU5sVFdGd2NHbHVaMVZTVEQxcGJXRm5aUzFpYVhSdFlYQXRaR0YwWVMxMWNtd3RkMjl5YTJWeUxVbEtjRU0zWjE5aUxtcHpMbTFoY0FvPVwiO1xudmFyIGRlY29kZUJhc2U2NCA9IGZ1bmN0aW9uKGJhc2U2NCkge1xuICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oYXRvYihiYXNlNjQpLCBmdW5jdGlvbihjMikge1xuICAgICAgICByZXR1cm4gYzIuY2hhckNvZGVBdCgwKTtcbiAgICB9KTtcbn07XG52YXIgYmxvYiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LkJsb2IgJiYgbmV3IEJsb2IoW1xuICAgIGRlY29kZUJhc2U2NChlbmNvZGVkSnMpXG5dLCB7XG4gICAgdHlwZTogXCJ0ZXh0L2phdmFzY3JpcHQ7Y2hhcnNldD11dGYtOFwiXG59KTtcbmZ1bmN0aW9uIFdvcmtlcldyYXBwZXIob3B0aW9ucykge1xuICAgIHZhciBvYmpVUkw7XG4gICAgdHJ5IHtcbiAgICAgICAgb2JqVVJMID0gYmxvYiAmJiAod2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMKS5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgIGlmICghb2JqVVJMKSB0aHJvdyBcIlwiO1xuICAgICAgICB2YXIgd29ya2VyID0gbmV3IFdvcmtlcihvYmpVUkwsIHtcbiAgICAgICAgICAgIG5hbWU6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICh3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwpLnJldm9rZU9iamVjdFVSTChvYmpVUkwpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHdvcmtlcjtcbiAgICB9IGNhdGNoIChlMikge1xuICAgICAgICByZXR1cm4gbmV3IFdvcmtlcihcImRhdGE6dGV4dC9qYXZhc2NyaXB0O2Jhc2U2NCxcIiArIGVuY29kZWRKcywge1xuICAgICAgICAgICAgbmFtZTogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5uYW1lXG4gICAgICAgIH0pO1xuICAgIH0gZmluYWxseXtcbiAgICAgICAgb2JqVVJMICYmICh3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwpLnJldm9rZU9iamVjdFVSTChvYmpVUkwpO1xuICAgIH1cbn1cbnZhciBDYW52YXNNYW5hZ2VyID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBDYW52YXNNYW5hZ2VyKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwicGVuZGluZ0NhbnZhc011dGF0aW9uc1wiLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwicmFmU3RhbXBzXCIsIHtcbiAgICAgICAgICAgIGxhdGVzdElkOiAwLFxuICAgICAgICAgICAgaW52b2tlSWQ6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcIm1pcnJvclwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwibXV0YXRpb25DYlwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwicmVzZXRPYnNlcnZlcnNcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImZyb3plblwiLCBmYWxzZSk7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImxvY2tlZFwiLCBmYWxzZSk7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcInByb2Nlc3NNdXRhdGlvblwiLCBmdW5jdGlvbih0YXJnZXQsIG11dGF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbmV3RnJhbWUgPSBfdGhpcy5yYWZTdGFtcHMuaW52b2tlSWQgJiYgX3RoaXMucmFmU3RhbXBzLmxhdGVzdElkICE9PSBfdGhpcy5yYWZTdGFtcHMuaW52b2tlSWQ7XG4gICAgICAgICAgICBpZiAobmV3RnJhbWUgfHwgIV90aGlzLnJhZlN0YW1wcy5pbnZva2VJZCkgX3RoaXMucmFmU3RhbXBzLmludm9rZUlkID0gX3RoaXMucmFmU3RhbXBzLmxhdGVzdElkO1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zLmhhcyh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucy5zZXQodGFyZ2V0LCBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zLmdldCh0YXJnZXQpLnB1c2gobXV0YXRpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIF9vcHRpb25zX3NhbXBsaW5nID0gb3B0aW9ucy5zYW1wbGluZywgc2FtcGxpbmcgPSBfb3B0aW9uc19zYW1wbGluZyA9PT0gdm9pZCAwID8gXCJhbGxcIiA6IF9vcHRpb25zX3NhbXBsaW5nLCB3aW4gPSBvcHRpb25zLndpbiwgYmxvY2tDbGFzcyA9IG9wdGlvbnMuYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciA9IG9wdGlvbnMuYmxvY2tTZWxlY3RvciwgcmVjb3JkQ2FudmFzID0gb3B0aW9ucy5yZWNvcmRDYW52YXMsIGRhdGFVUkxPcHRpb25zID0gb3B0aW9ucy5kYXRhVVJMT3B0aW9ucztcbiAgICAgICAgdGhpcy5tdXRhdGlvbkNiID0gb3B0aW9ucy5tdXRhdGlvbkNiO1xuICAgICAgICB0aGlzLm1pcnJvciA9IG9wdGlvbnMubWlycm9yO1xuICAgICAgICBpZiAocmVjb3JkQ2FudmFzICYmIHNhbXBsaW5nID09PSBcImFsbFwiKSB0aGlzLmluaXRDYW52YXNNdXRhdGlvbk9ic2VydmVyKHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvcik7XG4gICAgICAgIGlmIChyZWNvcmRDYW52YXMgJiYgdHlwZW9mIHNhbXBsaW5nID09PSBcIm51bWJlclwiKSB0aGlzLmluaXRDYW52YXNGUFNPYnNlcnZlcihzYW1wbGluZywgd2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB7XG4gICAgICAgICAgICBkYXRhVVJMT3B0aW9uczogZGF0YVVSTE9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBDYW52YXNNYW5hZ2VyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zLmNsZWFyKCk7XG4gICAgICAgIHRoaXMucmVzZXRPYnNlcnZlcnMgJiYgdGhpcy5yZXNldE9ic2VydmVycygpO1xuICAgIH07XG4gICAgX3Byb3RvLmZyZWV6ZSA9IGZ1bmN0aW9uIGZyZWV6ZSgpIHtcbiAgICAgICAgdGhpcy5mcm96ZW4gPSB0cnVlO1xuICAgIH07XG4gICAgX3Byb3RvLnVuZnJlZXplID0gZnVuY3Rpb24gdW5mcmVlemUoKSB7XG4gICAgICAgIHRoaXMuZnJvemVuID0gZmFsc2U7XG4gICAgfTtcbiAgICBfcHJvdG8ubG9jayA9IGZ1bmN0aW9uIGxvY2soKSB7XG4gICAgICAgIHRoaXMubG9ja2VkID0gdHJ1ZTtcbiAgICB9O1xuICAgIF9wcm90by51bmxvY2sgPSBmdW5jdGlvbiB1bmxvY2soKSB7XG4gICAgICAgIHRoaXMubG9ja2VkID0gZmFsc2U7XG4gICAgfTtcbiAgICBfcHJvdG8uaW5pdENhbnZhc0ZQU09ic2VydmVyID0gZnVuY3Rpb24gaW5pdENhbnZhc0ZQU09ic2VydmVyKGZwcywgd2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjYW52YXNDb250ZXh0UmVzZXQgPSBpbml0Q2FudmFzQ29udGV4dE9ic2VydmVyKHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSk7XG4gICAgICAgIHZhciBzbmFwc2hvdEluUHJvZ3Jlc3NNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgd29ya2VyID0gbmV3IFdvcmtlcldyYXBwZXIoKTtcbiAgICAgICAgd29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBlMi5kYXRhLmlkO1xuICAgICAgICAgICAgc25hcHNob3RJblByb2dyZXNzTWFwLnNldChpZCwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKCEoXCJiYXNlNjRcIiBpbiBlMi5kYXRhKSkgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIF9lMl9kYXRhID0gZTIuZGF0YSwgYmFzZTY0ID0gX2UyX2RhdGEuYmFzZTY0LCB0eXBlID0gX2UyX2RhdGEudHlwZSwgd2lkdGggPSBfZTJfZGF0YS53aWR0aCwgaGVpZ2h0ID0gX2UyX2RhdGEuaGVpZ2h0O1xuICAgICAgICAgICAgX3RoaXMubXV0YXRpb25DYih7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIHR5cGU6IENhbnZhc0NvbnRleHRbXCIyRFwiXSxcbiAgICAgICAgICAgICAgICBjb21tYW5kczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogXCJjbGVhclJlY3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpcGUgY2FudmFzXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogXCJkcmF3SW1hZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRyYXdzIChzZW1pLXRyYW5zcGFyZW50KSBpbWFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnJfdHlwZTogXCJJbWFnZUJpdG1hcFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnJfdHlwZTogXCJCbG9iXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBycl90eXBlOiBcIkFycmF5QnVmZmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlNjQ6IGJhc2U2NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0aW1lQmV0d2VlblNuYXBzaG90cyA9IDFlMyAvIGZwcztcbiAgICAgICAgdmFyIGxhc3RTbmFwc2hvdFRpbWUgPSAwO1xuICAgICAgICB2YXIgcmFmSWQ7XG4gICAgICAgIHZhciBnZXRDYW52YXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGVkQ2FudmFzID0gW107XG4gICAgICAgICAgICB3aW4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImNhbnZhc1wiKS5mb3JFYWNoKGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgICAgICAgICAgIGlmICghaXNCbG9ja2VkKGNhbnZhcywgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZENhbnZhcy5wdXNoKGNhbnZhcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlZENhbnZhcztcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRha2VDYW52YXNTbmFwc2hvdHMgPSBmdW5jdGlvbih0aW1lc3RhbXApIHtcbiAgICAgICAgICAgIGlmIChsYXN0U25hcHNob3RUaW1lICYmIHRpbWVzdGFtcCAtIGxhc3RTbmFwc2hvdFRpbWUgPCB0aW1lQmV0d2VlblNuYXBzaG90cykge1xuICAgICAgICAgICAgICAgIHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRha2VDYW52YXNTbmFwc2hvdHMpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RTbmFwc2hvdFRpbWUgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgICB2YXIgX3RoaXMxID0gX3RoaXM7XG4gICAgICAgICAgICBnZXRDYW52YXMoKS5mb3JFYWNoKC8qI19fUFVSRV9fKi8gX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbihjYW52YXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EyLCBpZCwgY29udGV4dCwgYml0bWFwO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdHNfZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKF9zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goX3N0YXRlLmxhYmVsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCA9IF90aGlzMS5taXJyb3IuZ2V0SWQoY2FudmFzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc25hcHNob3RJblByb2dyZXNzTWFwLmdldChpZCkpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW52YXMud2lkdGggPT09IDAgfHwgY2FudmFzLmhlaWdodCA9PT0gMCkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc25hcHNob3RJblByb2dyZXNzTWFwLnNldChpZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3ZWJnbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndlYmdsMlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXS5pbmNsdWRlcyhjYW52YXMuX19jb250ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoY2FudmFzLl9fY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoKF9hMiA9IGNvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRleHQuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5jbGVhcihjb250ZXh0LkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUltYWdlQml0bWFwKGNhbnZhcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdG1hcCA9IF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRtYXA6IGJpdG1hcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVVJMT3B0aW9uczogb3B0aW9ucy5kYXRhVVJMT3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0bWFwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRha2VDYW52YXNTbmFwc2hvdHMpO1xuICAgICAgICB9O1xuICAgICAgICByYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0YWtlQ2FudmFzU25hcHNob3RzKTtcbiAgICAgICAgdGhpcy5yZXNldE9ic2VydmVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2FudmFzQ29udGV4dFJlc2V0KCk7XG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZJZCk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8uaW5pdENhbnZhc011dGF0aW9uT2JzZXJ2ZXIgPSBmdW5jdGlvbiBpbml0Q2FudmFzTXV0YXRpb25PYnNlcnZlcih3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5zdGFydFJBRlRpbWVzdGFtcGluZygpO1xuICAgICAgICB0aGlzLnN0YXJ0UGVuZGluZ0NhbnZhc011dGF0aW9uRmx1c2hlcigpO1xuICAgICAgICB2YXIgY2FudmFzQ29udGV4dFJlc2V0ID0gaW5pdENhbnZhc0NvbnRleHRPYnNlcnZlcih3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIGZhbHNlKTtcbiAgICAgICAgdmFyIGNhbnZhczJEUmVzZXQgPSBpbml0Q2FudmFzMkRNdXRhdGlvbk9ic2VydmVyKHRoaXMucHJvY2Vzc011dGF0aW9uLmJpbmQodGhpcyksIHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvcik7XG4gICAgICAgIHZhciBjYW52YXNXZWJHTDFhbmQyUmVzZXQgPSBpbml0Q2FudmFzV2ViR0xNdXRhdGlvbk9ic2VydmVyKHRoaXMucHJvY2Vzc011dGF0aW9uLmJpbmQodGhpcyksIHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvcik7XG4gICAgICAgIHRoaXMucmVzZXRPYnNlcnZlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHRSZXNldCgpO1xuICAgICAgICAgICAgY2FudmFzMkRSZXNldCgpO1xuICAgICAgICAgICAgY2FudmFzV2ViR0wxYW5kMlJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8uc3RhcnRQZW5kaW5nQ2FudmFzTXV0YXRpb25GbHVzaGVyID0gZnVuY3Rpb24gc3RhcnRQZW5kaW5nQ2FudmFzTXV0YXRpb25GbHVzaGVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25zKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLnN0YXJ0UkFGVGltZXN0YW1waW5nID0gZnVuY3Rpb24gc3RhcnRSQUZUaW1lc3RhbXBpbmcoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzZXRMYXRlc3RSQUZUaW1lc3RhbXAgPSBmdW5jdGlvbih0aW1lc3RhbXApIHtcbiAgICAgICAgICAgIF90aGlzLnJhZlN0YW1wcy5sYXRlc3RJZCA9IHRpbWVzdGFtcDtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzZXRMYXRlc3RSQUZUaW1lc3RhbXApO1xuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2V0TGF0ZXN0UkFGVGltZXN0YW1wKTtcbiAgICB9O1xuICAgIF9wcm90by5mbHVzaFBlbmRpbmdDYW52YXNNdXRhdGlvbnMgPSBmdW5jdGlvbiBmbHVzaFBlbmRpbmdDYW52YXNNdXRhdGlvbnMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKF92YWx1ZXMsIGNhbnZhcykge1xuICAgICAgICAgICAgdmFyIGlkID0gX3RoaXMubWlycm9yLmdldElkKGNhbnZhcyk7XG4gICAgICAgICAgICBfdGhpcy5mbHVzaFBlbmRpbmdDYW52YXNNdXRhdGlvbkZvcihjYW52YXMsIGlkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5mbHVzaFBlbmRpbmdDYW52YXNNdXRhdGlvbnMoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8uZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25Gb3IgPSBmdW5jdGlvbiBmbHVzaFBlbmRpbmdDYW52YXNNdXRhdGlvbkZvcihjYW52YXMsIGlkKSB7XG4gICAgICAgIGlmICh0aGlzLmZyb3plbiB8fCB0aGlzLmxvY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZXNXaXRoVHlwZSA9IHRoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucy5nZXQoY2FudmFzKTtcbiAgICAgICAgaWYgKCF2YWx1ZXNXaXRoVHlwZSB8fCBpZCA9PT0gLTEpIHJldHVybjtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHZhbHVlc1dpdGhUeXBlLm1hcChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUudHlwZTsgdmFyIHJlc3QgPSBfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZSh2YWx1ZSwgW1xuICAgICAgICAgICAgICAgIFwidHlwZVwiXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHJldHVybiByZXN0O1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHR5cGUgPSB2YWx1ZXNXaXRoVHlwZVswXS50eXBlO1xuICAgICAgICB0aGlzLm11dGF0aW9uQ2Ioe1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGNvbW1hbmRzOiB2YWx1ZXNcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucy5kZWxldGUoY2FudmFzKTtcbiAgICB9O1xuICAgIHJldHVybiBDYW52YXNNYW5hZ2VyO1xufSgpO1xudmFyIFN0eWxlc2hlZXRNYW5hZ2VyID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBTdHlsZXNoZWV0TWFuYWdlcihvcHRpb25zKSB7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcInRyYWNrZWRMaW5rRWxlbWVudHNcIiwgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCkpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJtdXRhdGlvbkNiXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJhZG9wdGVkU3R5bGVTaGVldENiXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJzdHlsZU1pcnJvclwiLCBuZXcgU3R5bGVTaGVldE1pcnJvcigpKTtcbiAgICAgICAgdGhpcy5tdXRhdGlvbkNiID0gb3B0aW9ucy5tdXRhdGlvbkNiO1xuICAgICAgICB0aGlzLmFkb3B0ZWRTdHlsZVNoZWV0Q2IgPSBvcHRpb25zLmFkb3B0ZWRTdHlsZVNoZWV0Q2I7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBTdHlsZXNoZWV0TWFuYWdlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmF0dGFjaExpbmtFbGVtZW50ID0gZnVuY3Rpb24gYXR0YWNoTGlua0VsZW1lbnQobGlua0VsLCBjaGlsZFNuKSB7XG4gICAgICAgIGlmIChcIl9jc3NUZXh0XCIgaW4gY2hpbGRTbi5hdHRyaWJ1dGVzKSB0aGlzLm11dGF0aW9uQ2Ioe1xuICAgICAgICAgICAgYWRkczogW10sXG4gICAgICAgICAgICByZW1vdmVzOiBbXSxcbiAgICAgICAgICAgIHRleHRzOiBbXSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBjaGlsZFNuLmlkLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBjaGlsZFNuLmF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyYWNrTGlua0VsZW1lbnQobGlua0VsKTtcbiAgICB9O1xuICAgIF9wcm90by50cmFja0xpbmtFbGVtZW50ID0gZnVuY3Rpb24gdHJhY2tMaW5rRWxlbWVudChsaW5rRWwpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhY2tlZExpbmtFbGVtZW50cy5oYXMobGlua0VsKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLnRyYWNrZWRMaW5rRWxlbWVudHMuYWRkKGxpbmtFbCk7XG4gICAgICAgIHRoaXMudHJhY2tTdHlsZXNoZWV0SW5MaW5rRWxlbWVudChsaW5rRWwpO1xuICAgIH07XG4gICAgX3Byb3RvLmFkb3B0U3R5bGVTaGVldHMgPSBmdW5jdGlvbiBhZG9wdFN0eWxlU2hlZXRzKHNoZWV0cywgaG9zdElkKSB7XG4gICAgICAgIHZhciBfdGhpcywgX2xvb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzaGVldCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgdmFyIHN0eWxlSWQgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoIV90aGlzLnN0eWxlTWlycm9yLmhhcyhzaGVldCkpIHtcbiAgICAgICAgICAgICAgICBzdHlsZUlkID0gX3RoaXMuc3R5bGVNaXJyb3IuYWRkKHNoZWV0KTtcbiAgICAgICAgICAgICAgICBzdHlsZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlSWQ6IHN0eWxlSWQsXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzOiBBcnJheS5mcm9tKHNoZWV0LnJ1bGVzIHx8IENTU1J1bGUsIGZ1bmN0aW9uKHIyLCBpbmRleDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogc3RyaW5naWZ5UnVsZShyMiwgc2hlZXQuaHJlZiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4MlxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBzdHlsZUlkID0gX3RoaXMuc3R5bGVNaXJyb3IuZ2V0SWQoc2hlZXQpO1xuICAgICAgICAgICAgYWRvcHRlZFN0eWxlU2hlZXREYXRhLnN0eWxlSWRzLnB1c2goc3R5bGVJZCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzaGVldHMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICAgIHZhciBhZG9wdGVkU3R5bGVTaGVldERhdGEgPSB7XG4gICAgICAgICAgICBpZDogaG9zdElkLFxuICAgICAgICAgICAgc3R5bGVJZHM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdHlsZXMgPSBbXTtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uoc2hlZXRzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspX3RoaXMgPSB0aGlzLCBfbG9vcCgpO1xuICAgICAgICBpZiAoc3R5bGVzLmxlbmd0aCA+IDApIGFkb3B0ZWRTdHlsZVNoZWV0RGF0YS5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICAgIHRoaXMuYWRvcHRlZFN0eWxlU2hlZXRDYihhZG9wdGVkU3R5bGVTaGVldERhdGEpO1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuc3R5bGVNaXJyb3IucmVzZXQoKTtcbiAgICAgICAgdGhpcy50cmFja2VkTGlua0VsZW1lbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG4gICAgfTtcbiAgICAvLyBUT0RPOiB0YWtlIHNuYXBzaG90IG9uIHN0eWxlc2hlZXQgcmVsb2FkIGJ5IGFwcGx5aW5nIGV2ZW50IGxpc3RlbmVyXG4gICAgX3Byb3RvLnRyYWNrU3R5bGVzaGVldEluTGlua0VsZW1lbnQgPSBmdW5jdGlvbiB0cmFja1N0eWxlc2hlZXRJbkxpbmtFbGVtZW50KF9saW5rRWwpIHt9O1xuICAgIHJldHVybiBTdHlsZXNoZWV0TWFuYWdlcjtcbn0oKTtcbnZhciBQcm9jZXNzZWROb2RlTWFuYWdlciA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gUHJvY2Vzc2VkTm9kZU1hbmFnZXIoKSB7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcIm5vZGVNYXBcIiwgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJhY3RpdmVcIiwgZmFsc2UpO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gUHJvY2Vzc2VkTm9kZU1hbmFnZXIucHJvdG90eXBlO1xuICAgIF9wcm90by5pbk90aGVyQnVmZmVyID0gZnVuY3Rpb24gaW5PdGhlckJ1ZmZlcihub2RlMiwgdGhpc0J1ZmZlcikge1xuICAgICAgICB2YXIgYnVmZmVycyA9IHRoaXMubm9kZU1hcC5nZXQobm9kZTIpO1xuICAgICAgICByZXR1cm4gYnVmZmVycyAmJiBBcnJheS5mcm9tKGJ1ZmZlcnMpLnNvbWUoZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyICE9PSB0aGlzQnVmZmVyO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5hZGQgPSBmdW5jdGlvbiBhZGQobm9kZTIsIGJ1ZmZlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubm9kZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlTWFwLnNldChub2RlMiwgKHRoaXMubm9kZU1hcC5nZXQobm9kZTIpIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpLmFkZChidWZmZXIpKTtcbiAgICB9O1xuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHt9O1xuICAgIHJldHVybiBQcm9jZXNzZWROb2RlTWFuYWdlcjtcbn0oKTtcbnZhciB3cmFwcGVkRW1pdDtcbnZhciB0YWtlRnVsbFNuYXBzaG90JDE7XG52YXIgY2FudmFzTWFuYWdlcjtcbnZhciByZWNvcmRpbmcgPSBmYWxzZTtcbnRyeSB7XG4gICAgaWYgKEFycmF5LmZyb20oW1xuICAgICAgICAxXG4gICAgXSwgZnVuY3Rpb24oeDIpIHtcbiAgICAgICAgcmV0dXJuIHgyICogMjtcbiAgICB9KVswXSAhPT0gMikge1xuICAgICAgICB2YXIgY2xlYW5GcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2xlYW5GcmFtZSk7XG4gICAgICAgIEFycmF5LmZyb20gPSAoKF9hID0gY2xlYW5GcmFtZS5jb250ZW50V2luZG93KSA9PSBudWxsID8gdm9pZCAwIDogX2EuQXJyYXkuZnJvbSkgfHwgQXJyYXkuZnJvbTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChjbGVhbkZyYW1lKTtcbiAgICB9XG59IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmRlYnVnKFwiVW5hYmxlIHRvIG92ZXJyaWRlIEFycmF5LmZyb21cIiwgZXJyKTtcbn1cbnZhciBtaXJyb3IgPSBjcmVhdGVNaXJyb3IkMigpO1xuZnVuY3Rpb24gcmVjb3JkKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSBvcHRpb25zID0ge307XG4gICAgdmFyIGVtaXQgPSBvcHRpb25zLmVtaXQsIGNoZWNrb3V0RXZlcnlObXMgPSBvcHRpb25zLmNoZWNrb3V0RXZlcnlObXMsIGNoZWNrb3V0RXZlcnlOdGggPSBvcHRpb25zLmNoZWNrb3V0RXZlcnlOdGgsIF9vcHRpb25zX2Jsb2NrQ2xhc3MgPSBvcHRpb25zLmJsb2NrQ2xhc3MsIGJsb2NrQ2xhc3MgPSBfb3B0aW9uc19ibG9ja0NsYXNzID09PSB2b2lkIDAgPyBcInJyLWJsb2NrXCIgOiBfb3B0aW9uc19ibG9ja0NsYXNzLCBfb3B0aW9uc19ibG9ja1NlbGVjdG9yID0gb3B0aW9ucy5ibG9ja1NlbGVjdG9yLCBibG9ja1NlbGVjdG9yID0gX29wdGlvbnNfYmxvY2tTZWxlY3RvciA9PT0gdm9pZCAwID8gbnVsbCA6IF9vcHRpb25zX2Jsb2NrU2VsZWN0b3IsIF9vcHRpb25zX2lnbm9yZUNsYXNzID0gb3B0aW9ucy5pZ25vcmVDbGFzcywgaWdub3JlQ2xhc3MgPSBfb3B0aW9uc19pZ25vcmVDbGFzcyA9PT0gdm9pZCAwID8gXCJyci1pZ25vcmVcIiA6IF9vcHRpb25zX2lnbm9yZUNsYXNzLCBfb3B0aW9uc19pZ25vcmVTZWxlY3RvciA9IG9wdGlvbnMuaWdub3JlU2VsZWN0b3IsIGlnbm9yZVNlbGVjdG9yID0gX29wdGlvbnNfaWdub3JlU2VsZWN0b3IgPT09IHZvaWQgMCA/IG51bGwgOiBfb3B0aW9uc19pZ25vcmVTZWxlY3RvciwgX29wdGlvbnNfbWFza1RleHRDbGFzcyA9IG9wdGlvbnMubWFza1RleHRDbGFzcywgbWFza1RleHRDbGFzcyA9IF9vcHRpb25zX21hc2tUZXh0Q2xhc3MgPT09IHZvaWQgMCA/IFwicnItbWFza1wiIDogX29wdGlvbnNfbWFza1RleHRDbGFzcywgX29wdGlvbnNfbWFza1RleHRTZWxlY3RvciA9IG9wdGlvbnMubWFza1RleHRTZWxlY3RvciwgbWFza1RleHRTZWxlY3RvciA9IF9vcHRpb25zX21hc2tUZXh0U2VsZWN0b3IgPT09IHZvaWQgMCA/IG51bGwgOiBfb3B0aW9uc19tYXNrVGV4dFNlbGVjdG9yLCBfb3B0aW9uc19pbmxpbmVTdHlsZXNoZWV0ID0gb3B0aW9ucy5pbmxpbmVTdHlsZXNoZWV0LCBpbmxpbmVTdHlsZXNoZWV0ID0gX29wdGlvbnNfaW5saW5lU3R5bGVzaGVldCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zX2lubGluZVN0eWxlc2hlZXQsIG1hc2tBbGxJbnB1dHMgPSBvcHRpb25zLm1hc2tBbGxJbnB1dHMsIF9tYXNrSW5wdXRPcHRpb25zID0gb3B0aW9ucy5tYXNrSW5wdXRPcHRpb25zLCBfc2xpbURPTU9wdGlvbnMgPSBvcHRpb25zLnNsaW1ET01PcHRpb25zLCBtYXNrSW5wdXRGbiA9IG9wdGlvbnMubWFza0lucHV0Rm4sIG1hc2tUZXh0Rm4gPSBvcHRpb25zLm1hc2tUZXh0Rm4sIGhvb2tzID0gb3B0aW9ucy5ob29rcywgcGFja0ZuID0gb3B0aW9ucy5wYWNrRm4sIF9vcHRpb25zX3NhbXBsaW5nID0gb3B0aW9ucy5zYW1wbGluZywgc2FtcGxpbmcgPSBfb3B0aW9uc19zYW1wbGluZyA9PT0gdm9pZCAwID8ge30gOiBfb3B0aW9uc19zYW1wbGluZywgX29wdGlvbnNfZGF0YVVSTE9wdGlvbnMgPSBvcHRpb25zLmRhdGFVUkxPcHRpb25zLCBkYXRhVVJMT3B0aW9ucyA9IF9vcHRpb25zX2RhdGFVUkxPcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9vcHRpb25zX2RhdGFVUkxPcHRpb25zLCBtb3VzZW1vdmVXYWl0ID0gb3B0aW9ucy5tb3VzZW1vdmVXYWl0LCBfb3B0aW9uc19yZWNvcmRET00gPSBvcHRpb25zLnJlY29yZERPTSwgcmVjb3JkRE9NID0gX29wdGlvbnNfcmVjb3JkRE9NID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnNfcmVjb3JkRE9NLCBfb3B0aW9uc19yZWNvcmRDYW52YXMgPSBvcHRpb25zLnJlY29yZENhbnZhcywgcmVjb3JkQ2FudmFzID0gX29wdGlvbnNfcmVjb3JkQ2FudmFzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zX3JlY29yZENhbnZhcywgX29wdGlvbnNfcmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzID0gb3B0aW9ucy5yZWNvcmRDcm9zc09yaWdpbklmcmFtZXMsIHJlY29yZENyb3NzT3JpZ2luSWZyYW1lcyA9IF9vcHRpb25zX3JlY29yZENyb3NzT3JpZ2luSWZyYW1lcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9uc19yZWNvcmRDcm9zc09yaWdpbklmcmFtZXMsIF9vcHRpb25zX3JlY29yZEFmdGVyID0gb3B0aW9ucy5yZWNvcmRBZnRlciwgcmVjb3JkQWZ0ZXIgPSBfb3B0aW9uc19yZWNvcmRBZnRlciA9PT0gdm9pZCAwID8gb3B0aW9ucy5yZWNvcmRBZnRlciA9PT0gXCJET01Db250ZW50TG9hZGVkXCIgPyBvcHRpb25zLnJlY29yZEFmdGVyIDogXCJsb2FkXCIgOiBfb3B0aW9uc19yZWNvcmRBZnRlciwgX29wdGlvbnNfdXNlclRyaWdnZXJlZE9uSW5wdXQgPSBvcHRpb25zLnVzZXJUcmlnZ2VyZWRPbklucHV0LCB1c2VyVHJpZ2dlcmVkT25JbnB1dCA9IF9vcHRpb25zX3VzZXJUcmlnZ2VyZWRPbklucHV0ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zX3VzZXJUcmlnZ2VyZWRPbklucHV0LCBfb3B0aW9uc19jb2xsZWN0Rm9udHMgPSBvcHRpb25zLmNvbGxlY3RGb250cywgY29sbGVjdEZvbnRzID0gX29wdGlvbnNfY29sbGVjdEZvbnRzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zX2NvbGxlY3RGb250cywgX29wdGlvbnNfaW5saW5lSW1hZ2VzID0gb3B0aW9ucy5pbmxpbmVJbWFnZXMsIGlubGluZUltYWdlcyA9IF9vcHRpb25zX2lubGluZUltYWdlcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9uc19pbmxpbmVJbWFnZXMsIHBsdWdpbnMgPSBvcHRpb25zLnBsdWdpbnMsIF9vcHRpb25zX2tlZXBJZnJhbWVTcmNGbiA9IG9wdGlvbnMua2VlcElmcmFtZVNyY0ZuLCBrZWVwSWZyYW1lU3JjRm4gPSBfb3B0aW9uc19rZWVwSWZyYW1lU3JjRm4gPT09IHZvaWQgMCA/IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSA6IF9vcHRpb25zX2tlZXBJZnJhbWVTcmNGbiwgX29wdGlvbnNfaWdub3JlQ1NTQXR0cmlidXRlcyA9IG9wdGlvbnMuaWdub3JlQ1NTQXR0cmlidXRlcywgaWdub3JlQ1NTQXR0cmlidXRlcyA9IF9vcHRpb25zX2lnbm9yZUNTU0F0dHJpYnV0ZXMgPT09IHZvaWQgMCA/IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtdKSA6IF9vcHRpb25zX2lnbm9yZUNTU0F0dHJpYnV0ZXMsIGVycm9ySGFuZGxlcjIgPSBvcHRpb25zLmVycm9ySGFuZGxlcjtcbiAgICByZWdpc3RlckVycm9ySGFuZGxlcihlcnJvckhhbmRsZXIyKTtcbiAgICB2YXIgaW5FbWl0dGluZ0ZyYW1lID0gcmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzID8gd2luZG93LnBhcmVudCA9PT0gd2luZG93IDogdHJ1ZTtcbiAgICB2YXIgcGFzc0VtaXRzVG9QYXJlbnQgPSBmYWxzZTtcbiAgICBpZiAoIWluRW1pdHRpbmdGcmFtZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5wYXJlbnQuZG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICBwYXNzRW1pdHNUb1BhcmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICAgICAgcGFzc0VtaXRzVG9QYXJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpbkVtaXR0aW5nRnJhbWUgJiYgIWVtaXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW1pdCBmdW5jdGlvbiBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgaWYgKCFpbkVtaXR0aW5nRnJhbWUgJiYgIXBhc3NFbWl0c1RvUGFyZW50KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgICBpZiAobW91c2Vtb3ZlV2FpdCAhPT0gdm9pZCAwICYmIHNhbXBsaW5nLm1vdXNlbW92ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHNhbXBsaW5nLm1vdXNlbW92ZSA9IG1vdXNlbW92ZVdhaXQ7XG4gICAgfVxuICAgIG1pcnJvci5yZXNldCgpO1xuICAgIHZhciBtYXNrSW5wdXRPcHRpb25zID0gbWFza0FsbElucHV0cyA9PT0gdHJ1ZSA/IHtcbiAgICAgICAgY29sb3I6IHRydWUsXG4gICAgICAgIGRhdGU6IHRydWUsXG4gICAgICAgIFwiZGF0ZXRpbWUtbG9jYWxcIjogdHJ1ZSxcbiAgICAgICAgZW1haWw6IHRydWUsXG4gICAgICAgIG1vbnRoOiB0cnVlLFxuICAgICAgICBudW1iZXI6IHRydWUsXG4gICAgICAgIHJhbmdlOiB0cnVlLFxuICAgICAgICBzZWFyY2g6IHRydWUsXG4gICAgICAgIHRlbDogdHJ1ZSxcbiAgICAgICAgdGV4dDogdHJ1ZSxcbiAgICAgICAgdGltZTogdHJ1ZSxcbiAgICAgICAgdXJsOiB0cnVlLFxuICAgICAgICB3ZWVrOiB0cnVlLFxuICAgICAgICB0ZXh0YXJlYTogdHJ1ZSxcbiAgICAgICAgc2VsZWN0OiB0cnVlLFxuICAgICAgICBwYXNzd29yZDogdHJ1ZSxcbiAgICAgICAgaGlkZGVuOiB0cnVlXG4gICAgfSA6IF9tYXNrSW5wdXRPcHRpb25zICE9PSB2b2lkIDAgPyBfbWFza0lucHV0T3B0aW9ucyA6IHtcbiAgICAgICAgcGFzc3dvcmQ6IHRydWVcbiAgICB9O1xuICAgIHZhciBzbGltRE9NT3B0aW9ucyA9IF9zbGltRE9NT3B0aW9ucyA9PT0gdHJ1ZSB8fCBfc2xpbURPTU9wdGlvbnMgPT09IFwiYWxsXCIgPyB7XG4gICAgICAgIHNjcmlwdDogdHJ1ZSxcbiAgICAgICAgY29tbWVudDogdHJ1ZSxcbiAgICAgICAgaGVhZEZhdmljb246IHRydWUsXG4gICAgICAgIGhlYWRXaGl0ZXNwYWNlOiB0cnVlLFxuICAgICAgICBoZWFkTWV0YVNvY2lhbDogdHJ1ZSxcbiAgICAgICAgaGVhZE1ldGFSb2JvdHM6IHRydWUsXG4gICAgICAgIGhlYWRNZXRhSHR0cEVxdWl2OiB0cnVlLFxuICAgICAgICBoZWFkTWV0YVZlcmlmaWNhdGlvbjogdHJ1ZSxcbiAgICAgICAgLy8gdGhlIGZvbGxvd2luZyBhcmUgb2ZmIGZvciBzbGltRE9NT3B0aW9ucyA9PT0gdHJ1ZSxcbiAgICAgICAgLy8gYXMgdGhleSBkZXN0cm95IHNvbWUgKGhpZGRlbikgaW5mbzpcbiAgICAgICAgaGVhZE1ldGFBdXRob3JzaGlwOiBfc2xpbURPTU9wdGlvbnMgPT09IFwiYWxsXCIsXG4gICAgICAgIGhlYWRNZXRhRGVzY0tleXdvcmRzOiBfc2xpbURPTU9wdGlvbnMgPT09IFwiYWxsXCIsXG4gICAgICAgIGhlYWRUaXRsZU11dGF0aW9uczogX3NsaW1ET01PcHRpb25zID09PSBcImFsbFwiXG4gICAgfSA6IF9zbGltRE9NT3B0aW9ucyA/IF9zbGltRE9NT3B0aW9ucyA6IHt9O1xuICAgIHBvbHlmaWxsJDEoKTtcbiAgICB2YXIgbGFzdEZ1bGxTbmFwc2hvdEV2ZW50O1xuICAgIHZhciBpbmNyZW1lbnRhbFNuYXBzaG90Q291bnQgPSAwO1xuICAgIHZhciBldmVudFByb2Nlc3NvciA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHBsdWdpbnMgfHwgW10pLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgcGx1Z2luMyA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHBsdWdpbjMuZXZlbnRQcm9jZXNzb3IpIHtcbiAgICAgICAgICAgICAgICBlMiA9IHBsdWdpbjMuZXZlbnRQcm9jZXNzb3IoZTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYWNrRm4gJiYgLy8gRGlzYWJsZSBwYWNraW5nIGV2ZW50cyB3aGljaCB3aWxsIGJlIGVtaXR0ZWQgdG8gcGFyZW50IGZyYW1lcy5cbiAgICAgICAgIXBhc3NFbWl0c1RvUGFyZW50KSB7XG4gICAgICAgICAgICBlMiA9IHBhY2tGbihlMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGUyO1xuICAgIH07XG4gICAgd3JhcHBlZEVtaXQgPSBmdW5jdGlvbihyMiwgaXNDaGVja291dCkge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICB2YXIgZTIgPSByMjtcbiAgICAgICAgZTIudGltZXN0YW1wID0gbm93VGltZXN0YW1wKCk7XG4gICAgICAgIGlmICgoKF9hMiA9IG11dGF0aW9uQnVmZmVyc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5pc0Zyb3plbigpKSAmJiBlMi50eXBlICE9PSBFdmVudFR5cGUuRnVsbFNuYXBzaG90ICYmICEoZTIudHlwZSA9PT0gRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QgJiYgZTIuZGF0YS5zb3VyY2UgPT09IEluY3JlbWVudGFsU291cmNlLk11dGF0aW9uKSkge1xuICAgICAgICAgICAgbXV0YXRpb25CdWZmZXJzLmZvckVhY2goZnVuY3Rpb24oYnVmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1Zi51bmZyZWV6ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluRW1pdHRpbmdGcmFtZSkge1xuICAgICAgICAgICAgZW1pdCA9PSBudWxsID8gdm9pZCAwIDogZW1pdChldmVudFByb2Nlc3NvcihlMiksIGlzQ2hlY2tvdXQpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhc3NFbWl0c1RvUGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInJyd2ViXCIsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50UHJvY2Vzc29yKGUyKSxcbiAgICAgICAgICAgICAgICBvcmlnaW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4sXG4gICAgICAgICAgICAgICAgaXNDaGVja291dDogaXNDaGVja291dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdpbmRvdy5wYXJlbnQucG9zdE1lc3NhZ2UobWVzc2FnZSwgXCIqXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlMi50eXBlID09PSBFdmVudFR5cGUuRnVsbFNuYXBzaG90KSB7XG4gICAgICAgICAgICBsYXN0RnVsbFNuYXBzaG90RXZlbnQgPSBlMjtcbiAgICAgICAgICAgIGluY3JlbWVudGFsU25hcHNob3RDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZTIudHlwZSA9PT0gRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QpIHtcbiAgICAgICAgICAgIGlmIChlMi5kYXRhLnNvdXJjZSA9PT0gSW5jcmVtZW50YWxTb3VyY2UuTXV0YXRpb24gJiYgZTIuZGF0YS5pc0F0dGFjaElmcmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluY3JlbWVudGFsU25hcHNob3RDb3VudCsrO1xuICAgICAgICAgICAgdmFyIGV4Y2VlZENvdW50ID0gY2hlY2tvdXRFdmVyeU50aCAmJiBpbmNyZW1lbnRhbFNuYXBzaG90Q291bnQgPj0gY2hlY2tvdXRFdmVyeU50aDtcbiAgICAgICAgICAgIHZhciBleGNlZWRUaW1lID0gY2hlY2tvdXRFdmVyeU5tcyAmJiBlMi50aW1lc3RhbXAgLSBsYXN0RnVsbFNuYXBzaG90RXZlbnQudGltZXN0YW1wID4gY2hlY2tvdXRFdmVyeU5tcztcbiAgICAgICAgICAgIGlmIChleGNlZWRDb3VudCB8fCBleGNlZWRUaW1lKSB7XG4gICAgICAgICAgICAgICAgdGFrZUZ1bGxTbmFwc2hvdCQxKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgd3JhcHBlZE11dGF0aW9uRW1pdCA9IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICBkYXRhOiBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5NdXRhdGlvblxuICAgICAgICAgICAgfSwgbSlcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgd3JhcHBlZFNjcm9sbEVtaXQgPSBmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgIGRhdGE6IF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLlNjcm9sbFxuICAgICAgICAgICAgfSwgcClcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgd3JhcHBlZENhbnZhc011dGF0aW9uRW1pdCA9IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgZGF0YTogX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuQ2FudmFzTXV0YXRpb25cbiAgICAgICAgICAgIH0sIHApXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdmFyIHdyYXBwZWRBZG9wdGVkU3R5bGVTaGVldEVtaXQgPSBmdW5jdGlvbihhMikge1xuICAgICAgICByZXR1cm4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICBkYXRhOiBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5BZG9wdGVkU3R5bGVTaGVldFxuICAgICAgICAgICAgfSwgYTIpXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdmFyIHN0eWxlc2hlZXRNYW5hZ2VyID0gbmV3IFN0eWxlc2hlZXRNYW5hZ2VyKHtcbiAgICAgICAgbXV0YXRpb25DYjogd3JhcHBlZE11dGF0aW9uRW1pdCxcbiAgICAgICAgYWRvcHRlZFN0eWxlU2hlZXRDYjogd3JhcHBlZEFkb3B0ZWRTdHlsZVNoZWV0RW1pdFxuICAgIH0pO1xuICAgIHZhciBpZnJhbWVNYW5hZ2VyID0gbmV3IElmcmFtZU1hbmFnZXIoe1xuICAgICAgICBtaXJyb3I6IG1pcnJvcixcbiAgICAgICAgbXV0YXRpb25DYjogd3JhcHBlZE11dGF0aW9uRW1pdCxcbiAgICAgICAgc3R5bGVzaGVldE1hbmFnZXI6IHN0eWxlc2hlZXRNYW5hZ2VyLFxuICAgICAgICByZWNvcmRDcm9zc09yaWdpbklmcmFtZXM6IHJlY29yZENyb3NzT3JpZ2luSWZyYW1lcyxcbiAgICAgICAgd3JhcHBlZEVtaXQ6IHdyYXBwZWRFbWl0XG4gICAgfSk7XG4gICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UocGx1Z2lucyB8fCBbXSksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgdmFyIHBsdWdpbjMgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgaWYgKHBsdWdpbjMuZ2V0TWlycm9yKSBwbHVnaW4zLmdldE1pcnJvcih7XG4gICAgICAgICAgICBub2RlTWlycm9yOiBtaXJyb3IsXG4gICAgICAgICAgICBjcm9zc09yaWdpbklmcmFtZU1pcnJvcjogaWZyYW1lTWFuYWdlci5jcm9zc09yaWdpbklmcmFtZU1pcnJvcixcbiAgICAgICAgICAgIGNyb3NzT3JpZ2luSWZyYW1lU3R5bGVNaXJyb3I6IGlmcmFtZU1hbmFnZXIuY3Jvc3NPcmlnaW5JZnJhbWVTdHlsZU1pcnJvclxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHByb2Nlc3NlZE5vZGVNYW5hZ2VyID0gbmV3IFByb2Nlc3NlZE5vZGVNYW5hZ2VyKCk7XG4gICAgY2FudmFzTWFuYWdlciA9IG5ldyBDYW52YXNNYW5hZ2VyKHtcbiAgICAgICAgcmVjb3JkQ2FudmFzOiByZWNvcmRDYW52YXMsXG4gICAgICAgIG11dGF0aW9uQ2I6IHdyYXBwZWRDYW52YXNNdXRhdGlvbkVtaXQsXG4gICAgICAgIHdpbjogd2luZG93LFxuICAgICAgICBibG9ja0NsYXNzOiBibG9ja0NsYXNzLFxuICAgICAgICBibG9ja1NlbGVjdG9yOiBibG9ja1NlbGVjdG9yLFxuICAgICAgICBtaXJyb3I6IG1pcnJvcixcbiAgICAgICAgc2FtcGxpbmc6IHNhbXBsaW5nLmNhbnZhcyxcbiAgICAgICAgZGF0YVVSTE9wdGlvbnM6IGRhdGFVUkxPcHRpb25zXG4gICAgfSk7XG4gICAgdmFyIHNoYWRvd0RvbU1hbmFnZXIgPSBuZXcgU2hhZG93RG9tTWFuYWdlcih7XG4gICAgICAgIG11dGF0aW9uQ2I6IHdyYXBwZWRNdXRhdGlvbkVtaXQsXG4gICAgICAgIHNjcm9sbENiOiB3cmFwcGVkU2Nyb2xsRW1pdCxcbiAgICAgICAgYnlwYXNzT3B0aW9uczoge1xuICAgICAgICAgICAgYmxvY2tDbGFzczogYmxvY2tDbGFzcyxcbiAgICAgICAgICAgIGJsb2NrU2VsZWN0b3I6IGJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgICBtYXNrVGV4dENsYXNzOiBtYXNrVGV4dENsYXNzLFxuICAgICAgICAgICAgbWFza1RleHRTZWxlY3RvcjogbWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQ6IGlubGluZVN0eWxlc2hlZXQsXG4gICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiBtYXNrSW5wdXRPcHRpb25zLFxuICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnM6IGRhdGFVUkxPcHRpb25zLFxuICAgICAgICAgICAgbWFza1RleHRGbjogbWFza1RleHRGbixcbiAgICAgICAgICAgIG1hc2tJbnB1dEZuOiBtYXNrSW5wdXRGbixcbiAgICAgICAgICAgIHJlY29yZENhbnZhczogcmVjb3JkQ2FudmFzLFxuICAgICAgICAgICAgaW5saW5lSW1hZ2VzOiBpbmxpbmVJbWFnZXMsXG4gICAgICAgICAgICBzYW1wbGluZzogc2FtcGxpbmcsXG4gICAgICAgICAgICBzbGltRE9NT3B0aW9uczogc2xpbURPTU9wdGlvbnMsXG4gICAgICAgICAgICBpZnJhbWVNYW5hZ2VyOiBpZnJhbWVNYW5hZ2VyLFxuICAgICAgICAgICAgc3R5bGVzaGVldE1hbmFnZXI6IHN0eWxlc2hlZXRNYW5hZ2VyLFxuICAgICAgICAgICAgY2FudmFzTWFuYWdlcjogY2FudmFzTWFuYWdlcixcbiAgICAgICAgICAgIGtlZXBJZnJhbWVTcmNGbjoga2VlcElmcmFtZVNyY0ZuLFxuICAgICAgICAgICAgcHJvY2Vzc2VkTm9kZU1hbmFnZXI6IHByb2Nlc3NlZE5vZGVNYW5hZ2VyXG4gICAgICAgIH0sXG4gICAgICAgIG1pcnJvcjogbWlycm9yXG4gICAgfSk7XG4gICAgdGFrZUZ1bGxTbmFwc2hvdCQxID0gZnVuY3Rpb24oaXNDaGVja291dCkge1xuICAgICAgICBpZiAoaXNDaGVja291dCA9PT0gdm9pZCAwKSBpc0NoZWNrb3V0ID0gZmFsc2U7XG4gICAgICAgIGlmICghcmVjb3JkRE9NKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLk1ldGEsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgaHJlZjogd2luZG93LmxvY2F0aW9uLmhyZWYsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGdldFdpbmRvd1dpZHRoKCksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBnZXRXaW5kb3dIZWlnaHQoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBpc0NoZWNrb3V0KTtcbiAgICAgICAgc3R5bGVzaGVldE1hbmFnZXIucmVzZXQoKTtcbiAgICAgICAgc2hhZG93RG9tTWFuYWdlci5pbml0KCk7XG4gICAgICAgIG11dGF0aW9uQnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGJ1Zikge1xuICAgICAgICAgICAgcmV0dXJuIGJ1Zi5sb2NrKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbm9kZTIgPSBzbmFwc2hvdChkb2N1bWVudCwge1xuICAgICAgICAgICAgbWlycm9yOiBtaXJyb3IsXG4gICAgICAgICAgICBibG9ja0NsYXNzOiBibG9ja0NsYXNzLFxuICAgICAgICAgICAgYmxvY2tTZWxlY3RvcjogYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICAgIG1hc2tUZXh0Q2xhc3M6IG1hc2tUZXh0Q2xhc3MsXG4gICAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yOiBtYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgICAgICAgaW5saW5lU3R5bGVzaGVldDogaW5saW5lU3R5bGVzaGVldCxcbiAgICAgICAgICAgIG1hc2tBbGxJbnB1dHM6IG1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICAgICAgICBtYXNrVGV4dEZuOiBtYXNrVGV4dEZuLFxuICAgICAgICAgICAgbWFza0lucHV0Rm46IG1hc2tJbnB1dEZuLFxuICAgICAgICAgICAgc2xpbURPTTogc2xpbURPTU9wdGlvbnMsXG4gICAgICAgICAgICBkYXRhVVJMT3B0aW9uczogZGF0YVVSTE9wdGlvbnMsXG4gICAgICAgICAgICByZWNvcmRDYW52YXM6IHJlY29yZENhbnZhcyxcbiAgICAgICAgICAgIGlubGluZUltYWdlczogaW5saW5lSW1hZ2VzLFxuICAgICAgICAgICAgb25TZXJpYWxpemU6IGZ1bmN0aW9uKG4yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU2VyaWFsaXplZElmcmFtZShuMiwgbWlycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICBpZnJhbWVNYW5hZ2VyLmFkZElmcmFtZShuMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1NlcmlhbGl6ZWRTdHlsZXNoZWV0KG4yLCBtaXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnRyYWNrTGlua0VsZW1lbnQobjIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFzU2hhZG93Um9vdChuMikpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhZG93RG9tTWFuYWdlci5hZGRTaGFkb3dSb290KGluZGV4LnNoYWRvd1Jvb3QobjIpLCBkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uSWZyYW1lTG9hZDogZnVuY3Rpb24oaWZyYW1lLCBjaGlsZFNuKSB7XG4gICAgICAgICAgICAgICAgaWZyYW1lTWFuYWdlci5hdHRhY2hJZnJhbWUoaWZyYW1lLCBjaGlsZFNuKTtcbiAgICAgICAgICAgICAgICBzaGFkb3dEb21NYW5hZ2VyLm9ic2VydmVBdHRhY2hTaGFkb3coaWZyYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblN0eWxlc2hlZXRMb2FkOiBmdW5jdGlvbihsaW5rRWwsIGNoaWxkU24pIHtcbiAgICAgICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlci5hdHRhY2hMaW5rRWxlbWVudChsaW5rRWwsIGNoaWxkU24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtlZXBJZnJhbWVTcmNGbjoga2VlcElmcmFtZVNyY0ZuXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIW5vZGUyKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIHNuYXBzaG90IHRoZSBkb2N1bWVudFwiKTtcbiAgICAgICAgfVxuICAgICAgICB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuRnVsbFNuYXBzaG90LFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIG5vZGU6IG5vZGUyLFxuICAgICAgICAgICAgICAgIGluaXRpYWxPZmZzZXQ6IGdldFdpbmRvd1Njcm9sbCh3aW5kb3cpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGlzQ2hlY2tvdXQpO1xuICAgICAgICBtdXRhdGlvbkJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbihidWYpIHtcbiAgICAgICAgICAgIHJldHVybiBidWYudW5sb2NrKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzICYmIGRvY3VtZW50LmFkb3B0ZWRTdHlsZVNoZWV0cy5sZW5ndGggPiAwKSBzdHlsZXNoZWV0TWFuYWdlci5hZG9wdFN0eWxlU2hlZXRzKGRvY3VtZW50LmFkb3B0ZWRTdHlsZVNoZWV0cywgbWlycm9yLmdldElkKGRvY3VtZW50KSk7XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgICB2YXIgaGFuZGxlcnMgPSBbXTtcbiAgICAgICAgdmFyIG9ic2VydmUgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgICAgIHZhciBfYTI7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKGluaXRPYnNlcnZlcnMpKHtcbiAgICAgICAgICAgICAgICBtdXRhdGlvbkNiOiB3cmFwcGVkTXV0YXRpb25FbWl0LFxuICAgICAgICAgICAgICAgIG1vdXNlbW92ZUNiOiBmdW5jdGlvbihwb3NpdGlvbnMsIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25zOiBwb3NpdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtb3VzZUludGVyYWN0aW9uQ2I6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuTW91c2VJbnRlcmFjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzY3JvbGxDYjogd3JhcHBlZFNjcm9sbEVtaXQsXG4gICAgICAgICAgICAgICAgdmlld3BvcnRSZXNpemVDYjogZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5WaWV3cG9ydFJlc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbnB1dENiOiBmdW5jdGlvbih2Mikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5JbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdjIpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbWVkaWFJbnRlcmFjdGlvbkNiOiBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLk1lZGlhSW50ZXJhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHApXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldFJ1bGVDYjogZnVuY3Rpb24ocjIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuU3R5bGVTaGVldFJ1bGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHIyKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0eWxlRGVjbGFyYXRpb25DYjogZnVuY3Rpb24ocjIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuU3R5bGVEZWNsYXJhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcjIpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2FudmFzTXV0YXRpb25DYjogd3JhcHBlZENhbnZhc011dGF0aW9uRW1pdCxcbiAgICAgICAgICAgICAgICBmb250Q2I6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuRm9udFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25DYjogZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgICAgICB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLlNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjdXN0b21FbGVtZW50Q2I6IGZ1bmN0aW9uKGMyKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuQ3VzdG9tRWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgYzIpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYmxvY2tDbGFzczogYmxvY2tDbGFzcyxcbiAgICAgICAgICAgICAgICBpZ25vcmVDbGFzczogaWdub3JlQ2xhc3MsXG4gICAgICAgICAgICAgICAgaWdub3JlU2VsZWN0b3I6IGlnbm9yZVNlbGVjdG9yLFxuICAgICAgICAgICAgICAgIG1hc2tUZXh0Q2xhc3M6IG1hc2tUZXh0Q2xhc3MsXG4gICAgICAgICAgICAgICAgbWFza1RleHRTZWxlY3RvcjogbWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiBtYXNrSW5wdXRPcHRpb25zLFxuICAgICAgICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQ6IGlubGluZVN0eWxlc2hlZXQsXG4gICAgICAgICAgICAgICAgc2FtcGxpbmc6IHNhbXBsaW5nLFxuICAgICAgICAgICAgICAgIHJlY29yZERPTTogcmVjb3JkRE9NLFxuICAgICAgICAgICAgICAgIHJlY29yZENhbnZhczogcmVjb3JkQ2FudmFzLFxuICAgICAgICAgICAgICAgIGlubGluZUltYWdlczogaW5saW5lSW1hZ2VzLFxuICAgICAgICAgICAgICAgIHVzZXJUcmlnZ2VyZWRPbklucHV0OiB1c2VyVHJpZ2dlcmVkT25JbnB1dCxcbiAgICAgICAgICAgICAgICBjb2xsZWN0Rm9udHM6IGNvbGxlY3RGb250cyxcbiAgICAgICAgICAgICAgICBkb2M6IGRvYyxcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbjogbWFza0lucHV0Rm4sXG4gICAgICAgICAgICAgICAgbWFza1RleHRGbjogbWFza1RleHRGbixcbiAgICAgICAgICAgICAgICBrZWVwSWZyYW1lU3JjRm46IGtlZXBJZnJhbWVTcmNGbixcbiAgICAgICAgICAgICAgICBibG9ja1NlbGVjdG9yOiBibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgICAgIHNsaW1ET01PcHRpb25zOiBzbGltRE9NT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBkYXRhVVJMT3B0aW9uczogZGF0YVVSTE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgbWlycm9yOiBtaXJyb3IsXG4gICAgICAgICAgICAgICAgaWZyYW1lTWFuYWdlcjogaWZyYW1lTWFuYWdlcixcbiAgICAgICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlcjogc3R5bGVzaGVldE1hbmFnZXIsXG4gICAgICAgICAgICAgICAgc2hhZG93RG9tTWFuYWdlcjogc2hhZG93RG9tTWFuYWdlcixcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWROb2RlTWFuYWdlcjogcHJvY2Vzc2VkTm9kZU1hbmFnZXIsXG4gICAgICAgICAgICAgICAgY2FudmFzTWFuYWdlcjogY2FudmFzTWFuYWdlcixcbiAgICAgICAgICAgICAgICBpZ25vcmVDU1NBdHRyaWJ1dGVzOiBpZ25vcmVDU1NBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIHBsdWdpbnM6ICgoX2EyID0gcGx1Z2lucyA9PSBudWxsID8gdm9pZCAwIDogcGx1Z2lucy5maWx0ZXIoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcC5vYnNlcnZlcjtcbiAgICAgICAgICAgICAgICB9KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5tYXAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXI6IHAub2JzZXJ2ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBwLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24ocGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5QbHVnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbjogcC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSkpIHx8IFtdXG4gICAgICAgICAgICB9LCBob29rcyk7XG4gICAgICAgIH07XG4gICAgICAgIGlmcmFtZU1hbmFnZXIuYWRkTG9hZExpc3RlbmVyKGZ1bmN0aW9uKGlmcmFtZUVsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJzLnB1c2gob2JzZXJ2ZShpZnJhbWVFbC5jb250ZW50RG9jdW1lbnQpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0YWtlRnVsbFNuYXBzaG90JDEoKTtcbiAgICAgICAgICAgIGhhbmRsZXJzLnB1c2gob2JzZXJ2ZShkb2N1bWVudCkpO1xuICAgICAgICAgICAgcmVjb3JkaW5nID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiaW50ZXJhY3RpdmVcIiB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgICAgICAgIGluaXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZXJzLnB1c2gob24oXCJET01Db250ZW50TG9hZGVkXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkRvbUNvbnRlbnRMb2FkZWQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHt9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZEFmdGVyID09PSBcIkRPTUNvbnRlbnRMb2FkZWRcIikgaW5pdCgpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChvbihcImxvYWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuTG9hZCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge31cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkQWZ0ZXIgPT09IFwibG9hZFwiKSBpbml0KCk7XG4gICAgICAgICAgICB9LCB3aW5kb3cpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9IFN0cmluZyhlcnJvcikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtc2cuaW5jbHVkZXMoXCJjcm9zcy1vcmlnaW5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb2Nlc3NlZE5vZGVNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHJlY29yZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdW5yZWdpc3RlckVycm9ySGFuZGxlcigpO1xuICAgICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihlcnJvcik7XG4gICAgfVxufVxucmVjb3JkLmFkZEN1c3RvbUV2ZW50ID0gZnVuY3Rpb24odGFnLCBwYXlsb2FkKSB7XG4gICAgaWYgKCFyZWNvcmRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGxlYXNlIGFkZCBjdXN0b20gZXZlbnQgYWZ0ZXIgc3RhcnQgcmVjb3JkaW5nXCIpO1xuICAgIH1cbiAgICB3cmFwcGVkRW1pdCh7XG4gICAgICAgIHR5cGU6IEV2ZW50VHlwZS5DdXN0b20sXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHRhZzogdGFnLFxuICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZFxuICAgICAgICB9XG4gICAgfSk7XG59O1xucmVjb3JkLmZyZWV6ZVBhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICBtdXRhdGlvbkJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbihidWYpIHtcbiAgICAgICAgcmV0dXJuIGJ1Zi5mcmVlemUoKTtcbiAgICB9KTtcbn07XG5yZWNvcmQudGFrZUZ1bGxTbmFwc2hvdCA9IGZ1bmN0aW9uKGlzQ2hlY2tvdXQpIHtcbiAgICBpZiAoIXJlY29yZGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwbGVhc2UgdGFrZSBmdWxsIHNuYXBzaG90IGFmdGVyIHN0YXJ0IHJlY29yZGluZ1wiKTtcbiAgICB9XG4gICAgdGFrZUZ1bGxTbmFwc2hvdCQxKGlzQ2hlY2tvdXQpO1xufTtcbnJlY29yZC5taXJyb3IgPSBtaXJyb3I7XG52YXIgbjtcbiFmdW5jdGlvbih0Mikge1xuICAgIHQyW3QyLk5vdFN0YXJ0ZWQgPSAwXSA9IFwiTm90U3RhcnRlZFwiLCB0Mlt0Mi5SdW5uaW5nID0gMV0gPSBcIlJ1bm5pbmdcIiwgdDJbdDIuU3RvcHBlZCA9IDJdID0gXCJTdG9wcGVkXCI7XG59KG4gfHwgKG4gPSB7fSkpO1xucmVjb3JkLmFkZEN1c3RvbUV2ZW50O1xucmVjb3JkLmZyZWV6ZVBhZ2U7XG5yZWNvcmQudGFrZUZ1bGxTbmFwc2hvdDtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xufTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIF9fZGVmTm9ybWFsUHJvcChvYmosICh0eXBlb2Yga2V5ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKGtleSkpICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xufTtcbmZ1bmN0aW9uIHBhdGNoKHNvdXJjZSwgbmFtZSwgcmVwbGFjZW1lbnQpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIShuYW1lIGluIHNvdXJjZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcmlnaW5hbCA9IHNvdXJjZVtuYW1lXTtcbiAgICAgICAgdmFyIHdyYXBwZWQgPSByZXBsYWNlbWVudChvcmlnaW5hbCk7XG4gICAgICAgIGlmICh0eXBlb2Ygd3JhcHBlZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB3cmFwcGVkLnByb3RvdHlwZSA9IHdyYXBwZWQucHJvdG90eXBlIHx8IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMod3JhcHBlZCwge1xuICAgICAgICAgICAgICAgIF9fcnJ3ZWJfb3JpZ2luYWxfXzoge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlW25hbWVdID0gd3JhcHBlZDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc291cmNlW25hbWVdID0gb3JpZ2luYWw7XG4gICAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG59XG52YXIgU3RhY2tGcmFtZSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gU3RhY2tGcmFtZShvYmopIHtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImZpbGVOYW1lXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZnVuY3Rpb25OYW1lXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibGluZU51bWJlclwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNvbHVtbk51bWJlclwiKTtcbiAgICAgICAgdGhpcy5maWxlTmFtZSA9IG9iai5maWxlTmFtZSB8fCBcIlwiO1xuICAgICAgICB0aGlzLmZ1bmN0aW9uTmFtZSA9IG9iai5mdW5jdGlvbk5hbWUgfHwgXCJcIjtcbiAgICAgICAgdGhpcy5saW5lTnVtYmVyID0gb2JqLmxpbmVOdW1iZXI7XG4gICAgICAgIHRoaXMuY29sdW1uTnVtYmVyID0gb2JqLmNvbHVtbk51bWJlcjtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFN0YWNrRnJhbWUucHJvdG90eXBlO1xuICAgIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICB2YXIgbGluZU51bWJlciA9IHRoaXMubGluZU51bWJlciB8fCBcIlwiO1xuICAgICAgICB2YXIgY29sdW1uTnVtYmVyID0gdGhpcy5jb2x1bW5OdW1iZXIgfHwgXCJcIjtcbiAgICAgICAgaWYgKHRoaXMuZnVuY3Rpb25OYW1lKSByZXR1cm4gdGhpcy5mdW5jdGlvbk5hbWUgKyBcIiAoXCIgKyB0aGlzLmZpbGVOYW1lICsgXCI6XCIgKyBsaW5lTnVtYmVyICsgXCI6XCIgKyBjb2x1bW5OdW1iZXIgKyBcIilcIjtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsZU5hbWUgKyBcIjpcIiArIGxpbmVOdW1iZXIgKyBcIjpcIiArIGNvbHVtbk51bWJlcjtcbiAgICB9O1xuICAgIHJldHVybiBTdGFja0ZyYW1lO1xufSgpO1xudmFyIEZJUkVGT1hfU0FGQVJJX1NUQUNLX1JFR0VYUCA9IC8oXnxAKVxcUys6XFxkKy87XG52YXIgQ0hST01FX0lFX1NUQUNLX1JFR0VYUCA9IC9eXFxzKmF0IC4qKFxcUys6XFxkK3xcXChuYXRpdmVcXCkpL207XG52YXIgU0FGQVJJX05BVElWRV9DT0RFX1JFR0VYUCA9IC9eKGV2YWxAKT8oXFxbbmF0aXZlIGNvZGVdKT8kLztcbnZhciBFcnJvclN0YWNrUGFyc2VyID0ge1xuICAgIC8qKlxuICAgKiBHaXZlbiBhbiBFcnJvciBvYmplY3QsIGV4dHJhY3QgdGhlIG1vc3QgaW5mb3JtYXRpb24gZnJvbSBpdC5cbiAgICovIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShlcnJvcikge1xuICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0eXBlb2YgZXJyb3Iuc3RhY2t0cmFjZSAhPT0gXCJ1bmRlZmluZWRcIiB8fCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdHlwZW9mIGVycm9yW1wib3BlcmEjc291cmNlbG9jXCJdICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9wZXJhKGVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvci5zdGFjayAmJiBlcnJvci5zdGFjay5tYXRjaChDSFJPTUVfSUVfU1RBQ0tfUkVHRVhQKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWOE9ySUUoZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yLnN0YWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZGT3JTYWZhcmkoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW2NvbnNvbGUtcmVjb3JkLXBsdWdpbl06IEZhaWxlZCB0byBwYXJzZSBlcnJvciBvYmplY3Q6XCIsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLy8gU2VwYXJhdGUgbGluZSBhbmQgY29sdW1uIG51bWJlcnMgZnJvbSBhIHN0cmluZyBvZiB0aGUgZm9ybTogKFVSSTpMaW5lOkNvbHVtbilcbiAgICBleHRyYWN0TG9jYXRpb246IGZ1bmN0aW9uIGV4dHJhY3RMb2NhdGlvbih1cmxMaWtlKSB7XG4gICAgICAgIGlmICh1cmxMaWtlLmluZGV4T2YoXCI6XCIpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB1cmxMaWtlXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWdFeHAgPSAvKC4rPykoPzo6KFxcZCspKT8oPzo6KFxcZCspKT8kLztcbiAgICAgICAgdmFyIHBhcnRzID0gcmVnRXhwLmV4ZWModXJsTGlrZS5yZXBsYWNlKC9bKCldL2csIFwiXCIpKTtcbiAgICAgICAgaWYgKCFwYXJ0cykgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHBhcnNlIGdpdmVuIHVybDogXCIgKyB1cmxMaWtlKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHBhcnRzWzFdLFxuICAgICAgICAgICAgcGFydHNbMl0gfHwgdm9pZCAwLFxuICAgICAgICAgICAgcGFydHNbM10gfHwgdm9pZCAwXG4gICAgICAgIF07XG4gICAgfSxcbiAgICBwYXJzZVY4T3JJRTogZnVuY3Rpb24gcGFyc2VWOE9ySUUoZXJyb3IpIHtcbiAgICAgICAgdmFyIGZpbHRlcmVkID0gZXJyb3Iuc3RhY2suc3BsaXQoXCJcXG5cIikuZmlsdGVyKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAhIWxpbmUubWF0Y2goQ0hST01FX0lFX1NUQUNLX1JFR0VYUCk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICByZXR1cm4gZmlsdGVyZWQubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoXCIoZXZhbCBcIikgPiAtMSkge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoL2V2YWwgY29kZS9nLCBcImV2YWxcIikucmVwbGFjZSgvKFxcKGV2YWwgYXQgW14oKV0qKXwoXFwpLC4qJCkvZywgXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2FuaXRpemVkTGluZSA9IGxpbmUucmVwbGFjZSgvXlxccysvLCBcIlwiKS5yZXBsYWNlKC9cXChldmFsIGNvZGUvZywgXCIoXCIpO1xuICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gc2FuaXRpemVkTGluZS5tYXRjaCgvIChcXCgoLispOihcXGQrKTooXFxkKylcXCkkKS8pO1xuICAgICAgICAgICAgc2FuaXRpemVkTGluZSA9IGxvY2F0aW9uID8gc2FuaXRpemVkTGluZS5yZXBsYWNlKGxvY2F0aW9uWzBdLCBcIlwiKSA6IHNhbml0aXplZExpbmU7XG4gICAgICAgICAgICB2YXIgdG9rZW5zID0gc2FuaXRpemVkTGluZS5zcGxpdCgvXFxzKy8pLnNsaWNlKDEpO1xuICAgICAgICAgICAgdmFyIGxvY2F0aW9uUGFydHMgPSB0aGlzLmV4dHJhY3RMb2NhdGlvbihsb2NhdGlvbiA/IGxvY2F0aW9uWzFdIDogdG9rZW5zLnBvcCgpKTtcbiAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSB0b2tlbnMuam9pbihcIiBcIikgfHwgdm9pZCAwO1xuICAgICAgICAgICAgdmFyIGZpbGVOYW1lID0gW1xuICAgICAgICAgICAgICAgIFwiZXZhbFwiLFxuICAgICAgICAgICAgICAgIFwiPGFub255bW91cz5cIlxuICAgICAgICAgICAgXS5pbmRleE9mKGxvY2F0aW9uUGFydHNbMF0pID4gLTEgPyB2b2lkIDAgOiBsb2NhdGlvblBhcnRzWzBdO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICBmaWxlTmFtZTogZmlsZU5hbWUsXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbG9jYXRpb25QYXJ0c1sxXSxcbiAgICAgICAgICAgICAgICBjb2x1bW5OdW1iZXI6IGxvY2F0aW9uUGFydHNbMl1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9LFxuICAgIHBhcnNlRkZPclNhZmFyaTogZnVuY3Rpb24gcGFyc2VGRk9yU2FmYXJpKGVycm9yKSB7XG4gICAgICAgIHZhciBmaWx0ZXJlZCA9IGVycm9yLnN0YWNrLnNwbGl0KFwiXFxuXCIpLmZpbHRlcihmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gIWxpbmUubWF0Y2goU0FGQVJJX05BVElWRV9DT0RFX1JFR0VYUCk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICByZXR1cm4gZmlsdGVyZWQubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoXCIgPiBldmFsXCIpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKC8gbGluZSAoXFxkKykoPzogPiBldmFsIGxpbmUgXFxkKykqID4gZXZhbDpcXGQrOlxcZCsvZywgXCI6JDFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKFwiQFwiKSA9PT0gLTEgJiYgbGluZS5pbmRleE9mKFwiOlwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IGxpbmVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZVJlZ2V4ID0gLygoLipcIi4rXCJbXkBdKik/W15AXSopKD86QCkvO1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gbGluZS5tYXRjaChmdW5jdGlvbk5hbWVSZWdleCk7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IG1hdGNoZXMgJiYgbWF0Y2hlc1sxXSA/IG1hdGNoZXNbMV0gOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uUGFydHMgPSB0aGlzLmV4dHJhY3RMb2NhdGlvbihsaW5lLnJlcGxhY2UoZnVuY3Rpb25OYW1lUmVnZXgsIFwiXCIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IGxvY2F0aW9uUGFydHNbMF0sXG4gICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxvY2F0aW9uUGFydHNbMV0sXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbk51bWJlcjogbG9jYXRpb25QYXJ0c1syXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICB9LFxuICAgIHBhcnNlT3BlcmE6IGZ1bmN0aW9uIHBhcnNlT3BlcmEoZSkge1xuICAgICAgICBpZiAoIWUuc3RhY2t0cmFjZSB8fCBlLm1lc3NhZ2UuaW5kZXhPZihcIlxcblwiKSA+IC0xICYmIGUubWVzc2FnZS5zcGxpdChcIlxcblwiKS5sZW5ndGggPiBlLnN0YWNrdHJhY2Uuc3BsaXQoXCJcXG5cIikubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9wZXJhOShlKTtcbiAgICAgICAgfSBlbHNlIGlmICghZS5zdGFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcGVyYTEwKGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcGVyYTExKGUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBwYXJzZU9wZXJhOTogZnVuY3Rpb24gcGFyc2VPcGVyYTkoZSkge1xuICAgICAgICB2YXIgbGluZVJFID0gL0xpbmUgKFxcZCspLipzY3JpcHQgKD86aW4gKT8oXFxTKykvaTtcbiAgICAgICAgdmFyIGxpbmVzID0gZS5tZXNzYWdlLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZvcih2YXIgaSA9IDIsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKXtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IGxpbmVSRS5leGVjKGxpbmVzW2ldKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IG1hdGNoWzJdLFxuICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBwYXJzZUZsb2F0KG1hdGNoWzFdKVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgcGFyc2VPcGVyYTEwOiBmdW5jdGlvbiBwYXJzZU9wZXJhMTAoZSkge1xuICAgICAgICB2YXIgbGluZVJFID0gL0xpbmUgKFxcZCspLipzY3JpcHQgKD86aW4gKT8oXFxTKykoPzo6IEluIGZ1bmN0aW9uIChcXFMrKSk/JC9pO1xuICAgICAgICB2YXIgbGluZXMgPSBlLnN0YWNrdHJhY2Uuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yKHZhciBpID0gMCwgbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDIpe1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gbGluZVJFLmV4ZWMobGluZXNbaV0pO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IG1hdGNoWzNdIHx8IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IG1hdGNoWzJdLFxuICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBwYXJzZUZsb2F0KG1hdGNoWzFdKVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgLy8gT3BlcmEgMTAuNjUrIEVycm9yLnN0YWNrIHZlcnkgc2ltaWxhciB0byBGRi9TYWZhcmlcbiAgICBwYXJzZU9wZXJhMTE6IGZ1bmN0aW9uIHBhcnNlT3BlcmExMShlcnJvcikge1xuICAgICAgICB2YXIgZmlsdGVyZWQgPSBlcnJvci5zdGFjay5zcGxpdChcIlxcblwiKS5maWx0ZXIoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICEhbGluZS5tYXRjaChGSVJFRk9YX1NBRkFSSV9TVEFDS19SRUdFWFApICYmICFsaW5lLm1hdGNoKC9eRXJyb3IgY3JlYXRlZCBhdC8pO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW5zID0gbGluZS5zcGxpdChcIkBcIik7XG4gICAgICAgICAgICB2YXIgbG9jYXRpb25QYXJ0cyA9IHRoaXMuZXh0cmFjdExvY2F0aW9uKHRva2Vucy5wb3AoKSk7XG4gICAgICAgICAgICB2YXIgZnVuY3Rpb25DYWxsID0gdG9rZW5zLnNoaWZ0KCkgfHwgXCJcIjtcbiAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSBmdW5jdGlvbkNhbGwucmVwbGFjZSgvPGFub255bW91cyBmdW5jdGlvbig6IChcXHcrKSk/Pi8sIFwiJDJcIikucmVwbGFjZSgvXFwoW14pXSpcXCkvZywgXCJcIikgfHwgdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICBmaWxlTmFtZTogbG9jYXRpb25QYXJ0c1swXSxcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsb2NhdGlvblBhcnRzWzFdLFxuICAgICAgICAgICAgICAgIGNvbHVtbk51bWJlcjogbG9jYXRpb25QYXJ0c1syXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBwYXRoVG9TZWxlY3Rvcihub2RlKSB7XG4gICAgaWYgKCFub2RlIHx8ICFub2RlLm91dGVySFRNTCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgdmFyIHBhdGggPSBcIlwiO1xuICAgIHdoaWxlKG5vZGUucGFyZW50RWxlbWVudCl7XG4gICAgICAgIHZhciBuYW1lID0gbm9kZS5sb2NhbE5hbWU7XG4gICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgICAgdmFyIGRvbVNpYmxpbmdzID0gW107XG4gICAgICAgIGlmIChwYXJlbnQuY2hpbGRyZW4gJiYgcGFyZW50LmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgIHZhciBzaWJsaW5nID0gcGFyZW50LmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChzaWJsaW5nLmxvY2FsTmFtZSAmJiBzaWJsaW5nLmxvY2FsTmFtZS50b0xvd2VyQ2FzZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2libGluZy5sb2NhbE5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tU2libGluZ3MucHVzaChzaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9tU2libGluZ3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbmFtZSArPSBcIjplcShcIiArIGRvbVNpYmxpbmdzLmluZGV4T2Yobm9kZSkgKyBcIilcIjtcbiAgICAgICAgfVxuICAgICAgICBwYXRoID0gbmFtZSArIChwYXRoID8gXCI+XCIgKyBwYXRoIDogXCJcIik7XG4gICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufVxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xufVxuZnVuY3Rpb24gaXNPYmpUb29EZWVwKG9iaiwgbGltaXQpIHtcbiAgICBpZiAobGltaXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShrZXlzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICB2YXIga2V5ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgIGlmIChpc09iamVjdChvYmpba2V5XSkgJiYgaXNPYmpUb29EZWVwKG9ialtrZXldLCBsaW1pdCAtIDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkob2JqLCBzdHJpbmdpZnlPcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIG51bU9mS2V5c0xpbWl0OiA1MCxcbiAgICAgICAgZGVwdGhPZkxpbWl0OiA0XG4gICAgfTtcbiAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHN0cmluZ2lmeU9wdGlvbnMpO1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHRoaXNQb3MgPSBzdGFjay5pbmRleE9mKHRoaXMpO1xuICAgICAgICAgICAgfnRoaXNQb3MgPyBzdGFjay5zcGxpY2UodGhpc1BvcyArIDEpIDogc3RhY2sucHVzaCh0aGlzKTtcbiAgICAgICAgICAgIH50aGlzUG9zID8ga2V5cy5zcGxpY2UodGhpc1BvcywgSW5maW5pdHksIGtleSkgOiBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIGlmICh+c3RhY2suaW5kZXhPZih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhY2tbMF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gXCJbQ2lyY3VsYXIgfl1cIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiW0NpcmN1bGFyIH4uXCIgKyBrZXlzLnNsaWNlKDAsIHN0YWNrLmluZGV4T2YodmFsdWUpKS5qb2luKFwiLlwiKSArIFwiXVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgcmV0dXJuIFwidW5kZWZpbmVkXCI7XG4gICAgICAgIGlmIChzaG91bGRJZ25vcmUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9TdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKHZhbHVlKSkgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpICsgXCJuXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9pbnN0YW5jZW9mKHZhbHVlLCBFdmVudCkpIHtcbiAgICAgICAgICAgIHZhciBldmVudFJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgZm9yKHZhciBldmVudEtleSBpbiB2YWx1ZSl7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50VmFsdWUgPSB2YWx1ZVtldmVudEtleV07XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRSZXN1bHRbZXZlbnRLZXldID0gcGF0aFRvU2VsZWN0b3IoZXZlbnRWYWx1ZS5sZW5ndGggPyBldmVudFZhbHVlWzBdIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRSZXN1bHRbZXZlbnRLZXldID0gZXZlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRSZXN1bHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoX2luc3RhbmNlb2YodmFsdWUsIE5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoX2luc3RhbmNlb2YodmFsdWUsIEhUTUxFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA/IHZhbHVlLm91dGVySFRNTCA6IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubm9kZU5hbWU7XG4gICAgICAgIH0gZWxzZSBpZiAoX2luc3RhbmNlb2YodmFsdWUsIEVycm9yKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnN0YWNrID8gdmFsdWUuc3RhY2sgKyBcIlxcbkVuZCBvZiBzdGFjayBmb3IgRXJyb3Igb2JqZWN0XCIgOiB2YWx1ZS5uYW1lICsgXCI6IFwiICsgdmFsdWUubWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gc2hvdWxkSWdub3JlKF9vYmopIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KF9vYmopICYmIE9iamVjdC5rZXlzKF9vYmopLmxlbmd0aCA+IG9wdGlvbnMubnVtT2ZLZXlzTGltaXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgX29iaiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNPYmplY3QoX29iaikgJiYgaXNPYmpUb29EZWVwKF9vYmosIG9wdGlvbnMuZGVwdGhPZkxpbWl0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b1N0cmluZyhfb2JqKSB7XG4gICAgICAgIHZhciBzdHIgPSBfb2JqLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChvcHRpb25zLnN0cmluZ0xlbmd0aExpbWl0ICYmIHN0ci5sZW5ndGggPiBvcHRpb25zLnN0cmluZ0xlbmd0aExpbWl0KSB7XG4gICAgICAgICAgICBzdHIgPSBcIlwiICsgc3RyLnNsaWNlKDAsIG9wdGlvbnMuc3RyaW5nTGVuZ3RoTGltaXQpICsgXCIuLi5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbn1cbnZhciBkZWZhdWx0TG9nT3B0aW9ucyA9IHtcbiAgICBsZXZlbDogW1xuICAgICAgICBcImFzc2VydFwiLFxuICAgICAgICBcImNsZWFyXCIsXG4gICAgICAgIFwiY291bnRcIixcbiAgICAgICAgXCJjb3VudFJlc2V0XCIsXG4gICAgICAgIFwiZGVidWdcIixcbiAgICAgICAgXCJkaXJcIixcbiAgICAgICAgXCJkaXJ4bWxcIixcbiAgICAgICAgXCJlcnJvclwiLFxuICAgICAgICBcImdyb3VwXCIsXG4gICAgICAgIFwiZ3JvdXBDb2xsYXBzZWRcIixcbiAgICAgICAgXCJncm91cEVuZFwiLFxuICAgICAgICBcImluZm9cIixcbiAgICAgICAgXCJsb2dcIixcbiAgICAgICAgXCJ0YWJsZVwiLFxuICAgICAgICBcInRpbWVcIixcbiAgICAgICAgXCJ0aW1lRW5kXCIsXG4gICAgICAgIFwidGltZUxvZ1wiLFxuICAgICAgICBcInRyYWNlXCIsXG4gICAgICAgIFwid2FyblwiXG4gICAgXSxcbiAgICBsZW5ndGhUaHJlc2hvbGQ6IDFlMyxcbiAgICBsb2dnZXI6IFwiY29uc29sZVwiXG59O1xuZnVuY3Rpb24gaW5pdExvZ09ic2VydmVyKGNiLCB3aW4sIG9wdGlvbnMpIHtcbiAgICB2YXIgbG9nT3B0aW9ucyA9IG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0TG9nT3B0aW9ucywgb3B0aW9ucykgOiBkZWZhdWx0TG9nT3B0aW9ucztcbiAgICB2YXIgbG9nZ2VyVHlwZSA9IGxvZ09wdGlvbnMubG9nZ2VyO1xuICAgIGlmICghbG9nZ2VyVHlwZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gICAgdmFyIGxvZ2dlcjtcbiAgICBpZiAodHlwZW9mIGxvZ2dlclR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbG9nZ2VyID0gd2luW2xvZ2dlclR5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlciA9IGxvZ2dlclR5cGU7XG4gICAgfVxuICAgIHZhciBsb2dDb3VudCA9IDA7XG4gICAgdmFyIGluU3RhY2sgPSBmYWxzZTtcbiAgICB2YXIgY2FuY2VsSGFuZGxlcnMgPSBbXTtcbiAgICBpZiAobG9nT3B0aW9ucy5sZXZlbC5pbmNsdWRlcyhcImVycm9yXCIpKSB7XG4gICAgICAgIHZhciBlcnJvckhhbmRsZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBldmVudC5tZXNzYWdlLCBlcnJvciA9IGV2ZW50LmVycm9yO1xuICAgICAgICAgICAgdmFyIHRyYWNlID0gRXJyb3JTdGFja1BhcnNlci5wYXJzZShlcnJvcikubWFwKGZ1bmN0aW9uKHN0YWNrRnJhbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2tGcmFtZS50b1N0cmluZygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgcGF5bG9hZCA9IFtcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobWVzc2FnZSwgbG9nT3B0aW9ucy5zdHJpbmdpZnlPcHRpb25zKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNiKHtcbiAgICAgICAgICAgICAgICBsZXZlbDogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIHRyYWNlOiB0cmFjZSxcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBlcnJvckhhbmRsZXIpO1xuICAgICAgICBjYW5jZWxIYW5kbGVycy5wdXNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBlcnJvckhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHVuaGFuZGxlZHJlamVjdGlvbkhhbmRsZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAgICAgdmFyIHBheWxvYWQ7XG4gICAgICAgICAgICBpZiAoX2luc3RhbmNlb2YoZXZlbnQucmVhc29uLCBFcnJvcikpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGV2ZW50LnJlYXNvbjtcbiAgICAgICAgICAgICAgICBwYXlsb2FkID0gW1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdpZnkoXCJVbmNhdWdodCAoaW4gcHJvbWlzZSkgXCIgKyBlcnJvci5uYW1lICsgXCI6IFwiICsgZXJyb3IubWVzc2FnZSwgbG9nT3B0aW9ucy5zdHJpbmdpZnlPcHRpb25zKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IFtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5naWZ5KFwiVW5jYXVnaHQgKGluIHByb21pc2UpXCIsIGxvZ09wdGlvbnMuc3RyaW5naWZ5T3B0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ2lmeShldmVudC5yZWFzb24sIGxvZ09wdGlvbnMuc3RyaW5naWZ5T3B0aW9ucylcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRyYWNlID0gRXJyb3JTdGFja1BhcnNlci5wYXJzZShlcnJvcikubWFwKGZ1bmN0aW9uKHN0YWNrRnJhbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2tGcmFtZS50b1N0cmluZygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYih7XG4gICAgICAgICAgICAgICAgbGV2ZWw6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICB0cmFjZTogdHJhY2UsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKFwidW5oYW5kbGVkcmVqZWN0aW9uXCIsIHVuaGFuZGxlZHJlamVjdGlvbkhhbmRsZXIpO1xuICAgICAgICBjYW5jZWxIYW5kbGVycy5wdXNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ1bmhhbmRsZWRyZWplY3Rpb25cIiwgdW5oYW5kbGVkcmVqZWN0aW9uSGFuZGxlcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShsb2dPcHRpb25zLmxldmVsKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICB2YXIgbGV2ZWxUeXBlID0gX3N0ZXAudmFsdWU7XG4gICAgICAgIGNhbmNlbEhhbmRsZXJzLnB1c2gocmVwbGFjZShsb2dnZXIsIGxldmVsVHlwZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbmNlbEhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgcmV0dXJuIGgoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiByZXBsYWNlKF9sb2dnZXIsIGxldmVsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghX2xvZ2dlcltsZXZlbF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRjaChfbG9nZ2VyLCBsZXZlbCwgZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczEgPSBfdGhpcztcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9yaWdpbmFsLmFwcGx5KF90aGlzMSwgYXJncyk7XG4gICAgICAgICAgICAgICAgaWYgKGxldmVsID09PSBcImFzc2VydFwiICYmICEhYXJnc1swXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpblN0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5TdGFjayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWNlID0gRXJyb3JTdGFja1BhcnNlci5wYXJzZShuZXcgRXJyb3IoKSkubWFwKGZ1bmN0aW9uKHN0YWNrRnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFja0ZyYW1lLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pLnNwbGljZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3NGb3JQYXlsb2FkID0gbGV2ZWwgPT09IFwiYXNzZXJ0XCIgPyBhcmdzLnNsaWNlKDEpIDogYXJncztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBhcmdzRm9yUGF5bG9hZC5tYXAoZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShzLCBsb2dPcHRpb25zLnN0cmluZ2lmeU9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbG9nQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvZ0NvdW50IDwgbG9nT3B0aW9ucy5sZW5ndGhUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogbGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2U6IHRyYWNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxvZ0NvdW50ID09PSBsb2dPcHRpb25zLmxlbmd0aFRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsOiBcIndhcm5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjZTogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmdpZnkoXCJUaGUgbnVtYmVyIG9mIGxvZyByZWNvcmRzIHJlYWNoZWQgdGhlIHRocmVzaG9sZC5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsLmFwcGx5KHZvaWQgMCwgW10uY29uY2F0KFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicnJ3ZWIgbG9nZ2VyIGVycm9yOlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgXSwgYXJncykpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgICAgICAgICAgaW5TdGFjayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbnZhciBQTFVHSU5fTkFNRSA9IFwicnJ3ZWIvY29uc29sZUAxXCI7XG52YXIgZ2V0UmVjb3JkQ29uc29sZVBsdWdpbiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBQTFVHSU5fTkFNRSxcbiAgICAgICAgb2JzZXJ2ZXI6IGluaXRMb2dPYnNlcnZlcixcbiAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgIH07XG59O1xuXG52YXIgc2V0SW1tZWRpYXRlID0gd2luWydzZXRJbW1lZGlhdGUnXTtcbnZhciBidWlsdEluUHJvcCwgY3ljbGUsIHNjaGVkdWxpbmdRdWV1ZSxcbiAgICBUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgdGltZXIgPSAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcpID9cbiAgICAgICAgZnVuY3Rpb24gdGltZXIoZm4pIHsgcmV0dXJuIHNldEltbWVkaWF0ZShmbik7IH0gOlxuICAgICAgICBzZXRUaW1lb3V0O1xuXG4vLyBkYW1taXQsIElFOC5cbnRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCd4Jyx7fSk7XG4gICAgYnVpbHRJblByb3AgPSBmdW5jdGlvbiBidWlsdEluUHJvcChvYmosbmFtZSx2YWwsY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLG5hbWUse1xuICAgICAgICAgICAgdmFsdWU6IHZhbCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBjb25maWcgIT09IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH07XG59XG5jYXRjaCAoZXJyKSB7XG4gICAgYnVpbHRJblByb3AgPSBmdW5jdGlvbiBidWlsdEluUHJvcChvYmosbmFtZSx2YWwpIHtcbiAgICAgICAgb2JqW25hbWVdID0gdmFsO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG59XG5cbi8vIE5vdGU6IHVzaW5nIGEgcXVldWUgaW5zdGVhZCBvZiBhcnJheSBmb3IgZWZmaWNpZW5jeVxuc2NoZWR1bGluZ1F1ZXVlID0gKGZ1bmN0aW9uIFF1ZXVlKCkge1xuICAgIHZhciBmaXJzdCwgbGFzdCwgaXRlbTtcblxuICAgIGZ1bmN0aW9uIEl0ZW0oZm4sc2VsZikge1xuICAgICAgICB0aGlzLmZuID0gZm47XG4gICAgICAgIHRoaXMuc2VsZiA9IHNlbGY7XG4gICAgICAgIHRoaXMubmV4dCA9IHZvaWQgMDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uIGFkZChmbixzZWxmKSB7XG4gICAgICAgICAgICBpdGVtID0gbmV3IEl0ZW0oZm4sc2VsZik7XG4gICAgICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgICAgIGxhc3QubmV4dCA9IGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaXJzdCA9IGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0ID0gaXRlbTtcbiAgICAgICAgICAgIGl0ZW0gPSB2b2lkIDA7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYWluOiBmdW5jdGlvbiBkcmFpbigpIHtcbiAgICAgICAgICAgIHZhciBmID0gZmlyc3Q7XG4gICAgICAgICAgICBmaXJzdCA9IGxhc3QgPSBjeWNsZSA9IHZvaWQgMDtcblxuICAgICAgICAgICAgd2hpbGUgKGYpIHtcbiAgICAgICAgICAgICAgICBmLmZuLmNhbGwoZi5zZWxmKTtcbiAgICAgICAgICAgICAgICBmID0gZi5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5cbmZ1bmN0aW9uIHNjaGVkdWxlKGZuLHNlbGYpIHtcbiAgICBzY2hlZHVsaW5nUXVldWUuYWRkKGZuLHNlbGYpO1xuICAgIGlmICghY3ljbGUpIHtcbiAgICAgICAgY3ljbGUgPSB0aW1lcihzY2hlZHVsaW5nUXVldWUuZHJhaW4pO1xuICAgIH1cbn1cblxuLy8gcHJvbWlzZSBkdWNrIHR5cGluZ1xuZnVuY3Rpb24gaXNUaGVuYWJsZShvKSB7XG4gICAgdmFyIF90aGVuLCBvVHlwZSA9IHR5cGVvZiBvO1xuXG4gICAgaWYgKG8gIT09IG51bGwgJiYgKG9UeXBlID09PSAnb2JqZWN0JyB8fCBvVHlwZSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgX3RoZW4gPSBvLnRoZW47XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgX3RoZW4gPT09ICdmdW5jdGlvbicgPyBfdGhlbiA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBub3RpZnkoKSB7XG4gICAgZm9yICh2YXIgaT0wOyBpPHRoaXMuY2hhaW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbm90aWZ5SXNvbGF0ZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgKHRoaXMuc3RhdGUgPT09IDEpID8gdGhpcy5jaGFpbltpXS5zdWNjZXNzIDogdGhpcy5jaGFpbltpXS5mYWlsdXJlLFxuICAgICAgICAgICAgdGhpcy5jaGFpbltpXVxuICAgICAgICApO1xuICAgIH1cbiAgICB0aGlzLmNoYWluLmxlbmd0aCA9IDA7XG59XG5cbi8vIE5PVEU6IFRoaXMgaXMgYSBzZXBhcmF0ZSBmdW5jdGlvbiB0byBpc29sYXRlXG4vLyB0aGUgYHRyeS4uY2F0Y2hgIHNvIHRoYXQgb3RoZXIgY29kZSBjYW4gYmVcbi8vIG9wdGltaXplZCBiZXR0ZXJcbmZ1bmN0aW9uIG5vdGlmeUlzb2xhdGVkKHNlbGYsY2IsY2hhaW4pIHtcbiAgICB2YXIgcmV0LCBfdGhlbjtcbiAgICB0cnkge1xuICAgICAgICBpZiAoY2IgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjaGFpbi5yZWplY3Qoc2VsZi5tc2cpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNiID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gc2VsZi5tc2c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXQgPSBjYi5jYWxsKHZvaWQgMCxzZWxmLm1zZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZXQgPT09IGNoYWluLnByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBjaGFpbi5yZWplY3QoVHlwZUVycm9yKCdQcm9taXNlLWNoYWluIGN5Y2xlJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgICAgICAgICBlbHNlIGlmIChfdGhlbiA9IGlzVGhlbmFibGUocmV0KSkge1xuICAgICAgICAgICAgICAgIF90aGVuLmNhbGwocmV0LGNoYWluLnJlc29sdmUsY2hhaW4ucmVqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoYWluLnJlc29sdmUocmV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNoYWluLnJlamVjdChlcnIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZShtc2cpIHtcbiAgICB2YXIgX3RoZW4sIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gYWxyZWFkeSB0cmlnZ2VyZWQ/XG4gICAgaWYgKHNlbGYudHJpZ2dlcmVkKSB7IHJldHVybjsgfVxuXG4gICAgc2VsZi50cmlnZ2VyZWQgPSB0cnVlO1xuXG4gICAgLy8gdW53cmFwXG4gICAgaWYgKHNlbGYuZGVmKSB7XG4gICAgICAgIHNlbGYgPSBzZWxmLmRlZjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICAgICAgaWYgKF90aGVuID0gaXNUaGVuYWJsZShtc2cpKSB7XG4gICAgICAgICAgICBzY2hlZHVsZShmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHZhciBkZWZXcmFwcGVyID0gbmV3IE1ha2VEZWZXcmFwcGVyKHNlbGYpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGVuLmNhbGwobXNnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gJHJlc29sdmUkKCl7IHJlc29sdmUuYXBwbHkoZGVmV3JhcHBlcixhcmd1bWVudHMpOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gJHJlamVjdCQoKXsgcmVqZWN0LmFwcGx5KGRlZldyYXBwZXIsYXJndW1lbnRzKTsgfVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdC5jYWxsKGRlZldyYXBwZXIsZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYubXNnID0gbXNnO1xuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9IDE7XG4gICAgICAgICAgICBpZiAoc2VsZi5jaGFpbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGUobm90aWZ5LHNlbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVqZWN0LmNhbGwobmV3IE1ha2VEZWZXcmFwcGVyKHNlbGYpLGVycik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWplY3QobXNnKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gYWxyZWFkeSB0cmlnZ2VyZWQ/XG4gICAgaWYgKHNlbGYudHJpZ2dlcmVkKSB7IHJldHVybjsgfVxuXG4gICAgc2VsZi50cmlnZ2VyZWQgPSB0cnVlO1xuXG4gICAgLy8gdW53cmFwXG4gICAgaWYgKHNlbGYuZGVmKSB7XG4gICAgICAgIHNlbGYgPSBzZWxmLmRlZjtcbiAgICB9XG5cbiAgICBzZWxmLm1zZyA9IG1zZztcbiAgICBzZWxmLnN0YXRlID0gMjtcbiAgICBpZiAoc2VsZi5jaGFpbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNjaGVkdWxlKG5vdGlmeSxzZWxmKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGl0ZXJhdGVQcm9taXNlcyhDb25zdHJ1Y3RvcixhcnIscmVzb2x2ZXIscmVqZWN0ZXIpIHtcbiAgICBmb3IgKHZhciBpZHg9MDsgaWR4PGFyci5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIChmdW5jdGlvbiBJSUZFKGlkeCl7XG4gICAgICAgICAgICBDb25zdHJ1Y3Rvci5yZXNvbHZlKGFycltpZHhdKVxuICAgICAgICAgICAgICAgIC50aGVuKFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAkcmVzb2x2ZXIkKG1zZyl7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlcihpZHgsbXNnKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0ZXJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICB9KShpZHgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gTWFrZURlZldyYXBwZXIoc2VsZikge1xuICAgIHRoaXMuZGVmID0gc2VsZjtcbiAgICB0aGlzLnRyaWdnZXJlZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBNYWtlRGVmKHNlbGYpIHtcbiAgICB0aGlzLnByb21pc2UgPSBzZWxmO1xuICAgIHRoaXMuc3RhdGUgPSAwO1xuICAgIHRoaXMudHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgdGhpcy5jaGFpbiA9IFtdO1xuICAgIHRoaXMubXNnID0gdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBOcG9Qcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ05vdCBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXNbJ19fTlBPX18nXSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ05vdCBhIHByb21pc2UnKTtcbiAgICB9XG5cbiAgICAvLyBpbnN0YW5jZSBzaGFkb3dpbmcgdGhlIGluaGVyaXRlZCBcImJyYW5kXCJcbiAgICAvLyB0byBzaWduYWwgYW4gYWxyZWFkeSBcImluaXRpYWxpemVkXCIgcHJvbWlzZVxuICAgIHRoaXNbJ19fTlBPX18nXSA9IDE7XG5cbiAgICB2YXIgZGVmID0gbmV3IE1ha2VEZWYodGhpcyk7XG5cbiAgICB0aGlzWyd0aGVuJ10gPSBmdW5jdGlvbiB0aGVuKHN1Y2Nlc3MsZmFpbHVyZSkge1xuICAgICAgICB2YXIgbyA9IHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHR5cGVvZiBzdWNjZXNzID09PSAnZnVuY3Rpb24nID8gc3VjY2VzcyA6IHRydWUsXG4gICAgICAgICAgICBmYWlsdXJlOiB0eXBlb2YgZmFpbHVyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhaWx1cmUgOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICAgICAgLy8gTm90ZTogYHRoZW4oLi4pYCBpdHNlbGYgY2FuIGJlIGJvcnJvd2VkIHRvIGJlIHVzZWQgYWdhaW5zdFxuICAgICAgICAgICAgLy8gYSBkaWZmZXJlbnQgcHJvbWlzZSBjb25zdHJ1Y3RvciBmb3IgbWFraW5nIHRoZSBjaGFpbmVkIHByb21pc2UsXG4gICAgICAgICAgICAvLyBieSBzdWJzdGl0dXRpbmcgYSBkaWZmZXJlbnQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICAgIG8ucHJvbWlzZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGZ1bmN0aW9uIGV4dHJhY3RDaGFpbihyZXNvbHZlLHJlamVjdCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNvbHZlICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiByZWplY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ05vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG8ucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICBvLnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZi5jaGFpbi5wdXNoKG8pO1xuXG4gICAgICAgIGlmIChkZWYuc3RhdGUgIT09IDApIHtcbiAgICAgICAgICAgIHNjaGVkdWxlKG5vdGlmeSxkZWYpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG8ucHJvbWlzZTtcbiAgICB9O1xuICAgIHRoaXNbJ2NhdGNoJ10gPSBmdW5jdGlvbiAkY2F0Y2gkKGZhaWx1cmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbih2b2lkIDAsZmFpbHVyZSk7XG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICAgIGV4ZWN1dG9yLmNhbGwoXG4gICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICBmdW5jdGlvbiBwdWJsaWNSZXNvbHZlKG1zZyl7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZS5jYWxsKGRlZixtc2cpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIHB1YmxpY1JlamVjdChtc2cpIHtcbiAgICAgICAgICAgICAgICByZWplY3QuY2FsbChkZWYsbXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QuY2FsbChkZWYsZXJyKTtcbiAgICB9XG59XG5cbnZhciBQcm9taXNlUHJvdG90eXBlID0gYnVpbHRJblByb3Aoe30sJ2NvbnN0cnVjdG9yJyxOcG9Qcm9taXNlLFxuICAgIC8qY29uZmlndXJhYmxlPSovZmFsc2Vcbik7XG5cbiAgICAvLyBOb3RlOiBBbmRyb2lkIDQgY2Fubm90IHVzZSBgT2JqZWN0LmRlZmluZVByb3BlcnR5KC4uKWAgaGVyZVxuTnBvUHJvbWlzZS5wcm90b3R5cGUgPSBQcm9taXNlUHJvdG90eXBlO1xuXG4vLyBidWlsdC1pbiBcImJyYW5kXCIgdG8gc2lnbmFsIGFuIFwidW5pbml0aWFsaXplZFwiIHByb21pc2VcbmJ1aWx0SW5Qcm9wKFByb21pc2VQcm90b3R5cGUsJ19fTlBPX18nLDAsXG4gICAgLypjb25maWd1cmFibGU9Ki9mYWxzZVxuKTtcblxuYnVpbHRJblByb3AoTnBvUHJvbWlzZSwncmVzb2x2ZScsZnVuY3Rpb24gUHJvbWlzZSRyZXNvbHZlKG1zZykge1xuICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgICAvLyBzcGVjIG1hbmRhdGVkIGNoZWNrc1xuICAgIC8vIG5vdGU6IGJlc3QgXCJpc1Byb21pc2VcIiBjaGVjayB0aGF0J3MgcHJhY3RpY2FsIGZvciBub3dcbiAgICBpZiAobXNnICYmIHR5cGVvZiBtc2cgPT09ICdvYmplY3QnICYmIG1zZ1snX19OUE9fXyddID09PSAxKSB7XG4gICAgICAgIHJldHVybiBtc2c7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLHJlamVjdCl7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgcmVqZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ05vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlKG1zZyk7XG4gICAgfSk7XG59KTtcblxuYnVpbHRJblByb3AoTnBvUHJvbWlzZSwncmVqZWN0JyxmdW5jdGlvbiBQcm9taXNlJHJlamVjdChtc2cpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMoZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSxyZWplY3Qpe1xuICAgICAgICBpZiAodHlwZW9mIHJlc29sdmUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHJlamVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdOb3QgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVqZWN0KG1zZyk7XG4gICAgfSk7XG59KTtcblxuYnVpbHRJblByb3AoTnBvUHJvbWlzZSwnYWxsJyxmdW5jdGlvbiBQcm9taXNlJGFsbChhcnIpIHtcbiAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gICAgLy8gc3BlYyBtYW5kYXRlZCBjaGVja3NcbiAgICBpZiAoVG9TdHJpbmcuY2FsbChhcnIpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgIHJldHVybiBDb25zdHJ1Y3Rvci5yZWplY3QoVHlwZUVycm9yKCdOb3QgYW4gYXJyYXknKSk7XG4gICAgfVxuICAgIGlmIChhcnIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBDb25zdHJ1Y3Rvci5yZXNvbHZlKFtdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUscmVqZWN0KXtcbiAgICAgICAgaWYgKHR5cGVvZiByZXNvbHZlICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiByZWplY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignTm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoLCBtc2dzID0gQXJyYXkobGVuKSwgY291bnQgPSAwO1xuXG4gICAgICAgIGl0ZXJhdGVQcm9taXNlcyhDb25zdHJ1Y3RvcixhcnIsZnVuY3Rpb24gcmVzb2x2ZXIoaWR4LG1zZykge1xuICAgICAgICAgICAgbXNnc1tpZHhdID0gbXNnO1xuICAgICAgICAgICAgaWYgKCsrY291bnQgPT09IGxlbikge1xuICAgICAgICAgICAgICAgIHJlc29sdmUobXNncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0scmVqZWN0KTtcbiAgICB9KTtcbn0pO1xuXG5idWlsdEluUHJvcChOcG9Qcm9taXNlLCdyYWNlJyxmdW5jdGlvbiBQcm9taXNlJHJhY2UoYXJyKSB7XG4gICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICAgIC8vIHNwZWMgbWFuZGF0ZWQgY2hlY2tzXG4gICAgaWYgKFRvU3RyaW5nLmNhbGwoYXJyKSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICByZXR1cm4gQ29uc3RydWN0b3IucmVqZWN0KFR5cGVFcnJvcignTm90IGFuIGFycmF5JykpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSxyZWplY3Qpe1xuICAgICAgICBpZiAodHlwZW9mIHJlc29sdmUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHJlamVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdOb3QgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaXRlcmF0ZVByb21pc2VzKENvbnN0cnVjdG9yLGFycixmdW5jdGlvbiByZXNvbHZlcihpZHgsbXNnKXtcbiAgICAgICAgICAgIHJlc29sdmUobXNnKTtcbiAgICAgICAgfSxyZWplY3QpO1xuICAgIH0pO1xufSk7XG5cbnZhciBQcm9taXNlUG9seWZpbGw7XG5pZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIFByb21pc2UudG9TdHJpbmcoKS5pbmRleE9mKCdbbmF0aXZlIGNvZGVdJykgIT09IC0xKSB7XG4gICAgUHJvbWlzZVBvbHlmaWxsID0gUHJvbWlzZTtcbn0gZWxzZSB7XG4gICAgUHJvbWlzZVBvbHlmaWxsID0gTnBvUHJvbWlzZTtcbn1cblxudmFyIENvbmZpZyA9IHtcbiAgICBERUJVRzogZmFsc2UsXG4gICAgTElCX1ZFUlNJT046ICcyLjcyLjAnXG59O1xuXG4vKiBlc2xpbnQgY2FtZWxjYXNlOiBcIm9mZlwiLCBlcWVxZXE6IFwib2ZmXCIgKi9cblxuLy8gTWF4aW11bSBhbGxvd2VkIHNlc3Npb24gcmVjb3JkaW5nIGxlbmd0aFxudmFyIE1BWF9SRUNPUkRJTkdfTVMgPSAyNCAqIDYwICogNjAgKiAxMDAwOyAvLyAyNCBob3Vyc1xuLy8gTWF4aW11bSBhbGxvd2VkIHZhbHVlIGZvciBtaW5pbXVtIHNlc3Npb24gcmVjb3JkaW5nIGxlbmd0aFxudmFyIE1BWF9WQUxVRV9GT1JfTUlOX1JFQ09SRElOR19NUyA9IDggKiAxMDAwOyAvLyA4IHNlY29uZHNcblxuLypcbiAqIFNhdmVkIHJlZmVyZW5jZXMgdG8gbG9uZyB2YXJpYWJsZSBuYW1lcywgc28gdGhhdCBjbG9zdXJlIGNvbXBpbGVyIGNhblxuICogbWluaW1pemUgZmlsZSBzaXplLlxuICovXG5cbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgIEZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBPYmpQcm90byA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgc2xpY2UgPSBBcnJheVByb3RvLnNsaWNlLFxuICAgIHRvU3RyaW5nID0gT2JqUHJvdG8udG9TdHJpbmcsXG4gICAgaGFzT3duUHJvcGVydHkgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eSxcbiAgICB3aW5kb3dDb25zb2xlID0gd2luLmNvbnNvbGUsXG4gICAgbmF2aWdhdG9yID0gd2luLm5hdmlnYXRvcixcbiAgICBkb2N1bWVudCQxID0gd2luLmRvY3VtZW50LFxuICAgIHdpbmRvd09wZXJhID0gd2luLm9wZXJhLFxuICAgIHNjcmVlbiA9IHdpbi5zY3JlZW4sXG4gICAgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcblxudmFyIG5hdGl2ZUJpbmQgPSBGdW5jUHJvdG8uYmluZCxcbiAgICBuYXRpdmVGb3JFYWNoID0gQXJyYXlQcm90by5mb3JFYWNoLFxuICAgIG5hdGl2ZUluZGV4T2YgPSBBcnJheVByb3RvLmluZGV4T2YsXG4gICAgbmF0aXZlTWFwID0gQXJyYXlQcm90by5tYXAsXG4gICAgbmF0aXZlSXNBcnJheSA9IEFycmF5LmlzQXJyYXksXG4gICAgYnJlYWtlciA9IHt9O1xuXG52YXIgXyA9IHtcbiAgICB0cmltOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL1RyaW0jUG9seWZpbGxcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZywgJycpO1xuICAgIH1cbn07XG5cbi8vIENvbnNvbGUgb3ZlcnJpZGVcbnZhciBjb25zb2xlJDEgPSB7XG4gICAgLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKX0gKi9cbiAgICBsb2c6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoQ29uZmlnLkRFQlVHICYmICFfLmlzVW5kZWZpbmVkKHdpbmRvd0NvbnNvbGUpICYmIHdpbmRvd0NvbnNvbGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgd2luZG93Q29uc29sZS5sb2cuYXBwbHkod2luZG93Q29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF8uZWFjaChhcmd1bWVudHMsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3dDb25zb2xlLmxvZyhhcmcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICAvKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopfSAqL1xuICAgIHdhcm46IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoQ29uZmlnLkRFQlVHICYmICFfLmlzVW5kZWZpbmVkKHdpbmRvd0NvbnNvbGUpICYmIHdpbmRvd0NvbnNvbGUpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gWydNaXhwYW5lbCB3YXJuaW5nOiddLmNvbmNhdChfLnRvQXJyYXkoYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdpbmRvd0NvbnNvbGUud2Fybi5hcHBseSh3aW5kb3dDb25zb2xlLCBhcmdzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF8uZWFjaChhcmdzLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Q29uc29sZS53YXJuKGFyZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKil9ICovXG4gICAgZXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoQ29uZmlnLkRFQlVHICYmICFfLmlzVW5kZWZpbmVkKHdpbmRvd0NvbnNvbGUpICYmIHdpbmRvd0NvbnNvbGUpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gWydNaXhwYW5lbCBlcnJvcjonXS5jb25jYXQoXy50b0FycmF5KGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3aW5kb3dDb25zb2xlLmVycm9yLmFwcGx5KHdpbmRvd0NvbnNvbGUsIGFyZ3MpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgXy5lYWNoKGFyZ3MsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3dDb25zb2xlLmVycm9yKGFyZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKil9ICovXG4gICAgY3JpdGljYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQod2luZG93Q29uc29sZSkgJiYgd2luZG93Q29uc29sZSkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbJ01peHBhbmVsIGVycm9yOiddLmNvbmNhdChfLnRvQXJyYXkoYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdpbmRvd0NvbnNvbGUuZXJyb3IuYXBwbHkod2luZG93Q29uc29sZSwgYXJncyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBfLmVhY2goYXJncywgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0NvbnNvbGUuZXJyb3IoYXJnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBsb2dfZnVuY193aXRoX3ByZWZpeCA9IGZ1bmN0aW9uKGZ1bmMsIHByZWZpeCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgYXJndW1lbnRzWzBdID0gJ1snICsgcHJlZml4ICsgJ10gJyArIGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29uc29sZSQxLCBhcmd1bWVudHMpO1xuICAgIH07XG59O1xudmFyIGNvbnNvbGVfd2l0aF9wcmVmaXggPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBsb2c6IGxvZ19mdW5jX3dpdGhfcHJlZml4KGNvbnNvbGUkMS5sb2csIHByZWZpeCksXG4gICAgICAgIGVycm9yOiBsb2dfZnVuY193aXRoX3ByZWZpeChjb25zb2xlJDEuZXJyb3IsIHByZWZpeCksXG4gICAgICAgIGNyaXRpY2FsOiBsb2dfZnVuY193aXRoX3ByZWZpeChjb25zb2xlJDEuY3JpdGljYWwsIHByZWZpeClcbiAgICB9O1xufTtcblxuXG52YXIgc2FmZXdyYXAgPSBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZSQxLmNyaXRpY2FsKCdJbXBsZW1lbnRhdGlvbiBlcnJvci4gUGxlYXNlIHR1cm4gb24gZGVidWcgYW5kIGNvbnRhY3Qgc3VwcG9ydEBtaXhwYW5lbC5jb20uJyk7XG4gICAgICAgICAgICBpZiAoQ29uZmlnLkRFQlVHKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlJDEuY3JpdGljYWwoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxudmFyIHNhZmV3cmFwQ2xhc3MgPSBmdW5jdGlvbihrbGFzcykge1xuICAgIHZhciBwcm90byA9IGtsYXNzLnByb3RvdHlwZTtcbiAgICBmb3IgKHZhciBmdW5jIGluIHByb3RvKSB7XG4gICAgICAgIGlmICh0eXBlb2YocHJvdG9bZnVuY10pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBwcm90b1tmdW5jXSA9IHNhZmV3cmFwKHByb3RvW2Z1bmNdKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuLy8gVU5ERVJTQ09SRVxuLy8gRW1iZWQgcGFydCBvZiB0aGUgVW5kZXJzY29yZSBMaWJyYXJ5XG5fLmJpbmQgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0KSB7XG4gICAgdmFyIGFyZ3MsIGJvdW5kO1xuICAgIGlmIChuYXRpdmVCaW5kICYmIGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCkge1xuICAgICAgICByZXR1cm4gbmF0aXZlQmluZC5hcHBseShmdW5jLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIH1cbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgfVxuICAgIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN0b3IgPSB7fTtcbiAgICAgICAgY3Rvci5wcm90b3R5cGUgPSBmdW5jLnByb3RvdHlwZTtcbiAgICAgICAgdmFyIHNlbGYgPSBuZXcgY3RvcigpO1xuICAgICAgICBjdG9yLnByb3RvdHlwZSA9IG51bGw7XG4gICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHNlbGYsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIHJldHVybiBib3VuZDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHsqPX0gb2JqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKC4uLiopPX0gaXRlcmF0b3JcbiAqIEBwYXJhbSB7T2JqZWN0PX0gY29udGV4dFxuICovXG5fLmVhY2ggPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuYXRpdmVGb3JFYWNoICYmIG9iai5mb3JFYWNoID09PSBuYXRpdmVGb3JFYWNoKSB7XG4gICAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gb2JqICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBicmVha2VyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2tleV0sIGtleSwgb2JqKSA9PT0gYnJlYWtlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuXy5leHRlbmQgPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2goc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VbcHJvcF0gIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG59O1xuXG5fLmlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG4vLyBmcm9tIGEgY29tbWVudCBvbiBodHRwOi8vZGJqLm9yZy9kYmovP3A9Mjg2XG4vLyBmYWlscyBvbiBvbmx5IG9uZSB2ZXJ5IHJhcmUgYW5kIGRlbGliZXJhdGUgY3VzdG9tIG9iamVjdDpcbi8vIHZhciBib21iID0geyB0b1N0cmluZyA6IHVuZGVmaW5lZCwgdmFsdWVPZjogZnVuY3Rpb24obykgeyByZXR1cm4gXCJmdW5jdGlvbiBCT01CQSFcIjsgfX07XG5fLmlzRnVuY3Rpb24gPSBmdW5jdGlvbihmKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIC9eXFxzKlxcYmZ1bmN0aW9uXFxiLy50ZXN0KGYpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5cbl8uaXNBcmd1bWVudHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCAnY2FsbGVlJykpO1xufTtcblxuXy50b0FycmF5ID0gZnVuY3Rpb24oaXRlcmFibGUpIHtcbiAgICBpZiAoIWl0ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhYmxlLnRvQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlLnRvQXJyYXkoKTtcbiAgICB9XG4gICAgaWYgKF8uaXNBcnJheShpdGVyYWJsZSkpIHtcbiAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwoaXRlcmFibGUpO1xuICAgIH1cbiAgICBpZiAoXy5pc0FyZ3VtZW50cyhpdGVyYWJsZSkpIHtcbiAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwoaXRlcmFibGUpO1xuICAgIH1cbiAgICByZXR1cm4gXy52YWx1ZXMoaXRlcmFibGUpO1xufTtcblxuXy5tYXAgPSBmdW5jdGlvbihhcnIsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgaWYgKG5hdGl2ZU1hcCAmJiBhcnIubWFwID09PSBuYXRpdmVNYXApIHtcbiAgICAgICAgcmV0dXJuIGFyci5tYXAoY2FsbGJhY2ssIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIF8uZWFjaChhcnIsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChjYWxsYmFjay5jYWxsKGNvbnRleHQsIGl0ZW0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbn07XG5cbl8ua2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoXSA9IGtleTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbn07XG5cbl8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoXSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xufTtcblxuXy5pbmNsdWRlID0gZnVuY3Rpb24ob2JqLCB0YXJnZXQpIHtcbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgaWYgKG5hdGl2ZUluZGV4T2YgJiYgb2JqLmluZGV4T2YgPT09IG5hdGl2ZUluZGV4T2YpIHtcbiAgICAgICAgcmV0dXJuIG9iai5pbmRleE9mKHRhcmdldCkgIT0gLTE7XG4gICAgfVxuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmIChmb3VuZCB8fCAoZm91bmQgPSAodmFsdWUgPT09IHRhcmdldCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gYnJlYWtlcjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmb3VuZDtcbn07XG5cbl8uaW5jbHVkZXMgPSBmdW5jdGlvbihzdHIsIG5lZWRsZSkge1xuICAgIHJldHVybiBzdHIuaW5kZXhPZihuZWVkbGUpICE9PSAtMTtcbn07XG5cbi8vIFVuZGVyc2NvcmUgQWRkb25zXG5fLmluaGVyaXQgPSBmdW5jdGlvbihzdWJjbGFzcywgc3VwZXJjbGFzcykge1xuICAgIHN1YmNsYXNzLnByb3RvdHlwZSA9IG5ldyBzdXBlcmNsYXNzKCk7XG4gICAgc3ViY2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViY2xhc3M7XG4gICAgc3ViY2xhc3Muc3VwZXJjbGFzcyA9IHN1cGVyY2xhc3MucHJvdG90eXBlO1xuICAgIHJldHVybiBzdWJjbGFzcztcbn07XG5cbl8uaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gKG9iaiA9PT0gT2JqZWN0KG9iaikgJiYgIV8uaXNBcnJheShvYmopKTtcbn07XG5cbl8uaXNFbXB0eU9iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChfLmlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5fLmlzVW5kZWZpbmVkID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdm9pZCAwO1xufTtcblxuXy5pc1N0cmluZyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59O1xuXG5fLmlzRGF0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgRGF0ZV0nO1xufTtcblxuXy5pc051bWJlciA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgTnVtYmVyXSc7XG59O1xuXG5fLmlzRWxlbWVudCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxKTtcbn07XG5cbl8uZW5jb2RlRGF0ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgIGlmIChfLmlzRGF0ZSh2KSkge1xuICAgICAgICAgICAgb2JqW2tdID0gXy5mb3JtYXREYXRlKHYpO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QodikpIHtcbiAgICAgICAgICAgIG9ialtrXSA9IF8uZW5jb2RlRGF0ZXModik7IC8vIHJlY3Vyc2VcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG59O1xuXG5fLnRpbWVzdGFtcCA9IGZ1bmN0aW9uKCkge1xuICAgIERhdGUubm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiArbmV3IERhdGU7XG4gICAgfTtcbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcbn07XG5cbl8uZm9ybWF0RGF0ZSA9IGZ1bmN0aW9uKGQpIHtcbiAgICAvLyBZWVlZLU1NLUREVEhIOk1NOlNTIGluIFVUQ1xuICAgIGZ1bmN0aW9uIHBhZChuKSB7XG4gICAgICAgIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuIDogbjtcbiAgICB9XG4gICAgcmV0dXJuIGQuZ2V0VVRDRnVsbFllYXIoKSArICctJyArXG4gICAgICAgIHBhZChkLmdldFVUQ01vbnRoKCkgKyAxKSArICctJyArXG4gICAgICAgIHBhZChkLmdldFVUQ0RhdGUoKSkgKyAnVCcgK1xuICAgICAgICBwYWQoZC5nZXRVVENIb3VycygpKSArICc6JyArXG4gICAgICAgIHBhZChkLmdldFVUQ01pbnV0ZXMoKSkgKyAnOicgK1xuICAgICAgICBwYWQoZC5nZXRVVENTZWNvbmRzKCkpO1xufTtcblxuXy5zdHJpcF9lbXB0eV9wcm9wZXJ0aWVzID0gZnVuY3Rpb24ocCkge1xuICAgIHZhciByZXQgPSB7fTtcbiAgICBfLmVhY2gocCwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICBpZiAoXy5pc1N0cmluZyh2KSAmJiB2Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldFtrXSA9IHY7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuLypcbiAqIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIGNvcHkgb2Ygb2JqZWN0IGFmdGVyIHRydW5jYXRpbmcgaXQuICBJZlxuICogcGFzc2VkIGFuIEFycmF5IG9yIE9iamVjdCBpdCB3aWxsIGl0ZXJhdGUgdGhyb3VnaCBvYmogYW5kXG4gKiB0cnVuY2F0ZSBhbGwgdGhlIHZhbHVlcyByZWN1cnNpdmVseS5cbiAqL1xuXy50cnVuY2F0ZSA9IGZ1bmN0aW9uKG9iaiwgbGVuZ3RoKSB7XG4gICAgdmFyIHJldDtcblxuICAgIGlmICh0eXBlb2Yob2JqKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0ID0gb2JqLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgfSBlbHNlIGlmIChfLmlzQXJyYXkob2JqKSkge1xuICAgICAgICByZXQgPSBbXTtcbiAgICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICByZXQucHVzaChfLnRydW5jYXRlKHZhbCwgbGVuZ3RoKSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdChvYmopKSB7XG4gICAgICAgIHJldCA9IHt9O1xuICAgICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWwsIGtleSkge1xuICAgICAgICAgICAgcmV0W2tleV0gPSBfLnRydW5jYXRlKHZhbCwgbGVuZ3RoKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gb2JqO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG59O1xuXG5fLkpTT05FbmNvZGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG1peGVkX3ZhbCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBtaXhlZF92YWw7XG4gICAgICAgIHZhciBxdW90ZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICAgICAgdmFyIGVzY2FwYWJsZSA9IC9bXFxcXFwiXFx4MDAtXFx4MWZcXHg3Zi1cXHg5ZlxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbiAgICAgICAgICAgIHZhciBtZXRhID0geyAvLyB0YWJsZSBvZiBjaGFyYWN0ZXIgc3Vic3RpdHV0aW9uc1xuICAgICAgICAgICAgICAgICdcXGInOiAnXFxcXGInLFxuICAgICAgICAgICAgICAgICdcXHQnOiAnXFxcXHQnLFxuICAgICAgICAgICAgICAgICdcXG4nOiAnXFxcXG4nLFxuICAgICAgICAgICAgICAgICdcXGYnOiAnXFxcXGYnLFxuICAgICAgICAgICAgICAgICdcXHInOiAnXFxcXHInLFxuICAgICAgICAgICAgICAgICdcIic6ICdcXFxcXCInLFxuICAgICAgICAgICAgICAgICdcXFxcJzogJ1xcXFxcXFxcJ1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICByZXR1cm4gZXNjYXBhYmxlLnRlc3Qoc3RyaW5nKSA/XG4gICAgICAgICAgICAgICAgJ1wiJyArIHN0cmluZy5yZXBsYWNlKGVzY2FwYWJsZSwgZnVuY3Rpb24oYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IG1ldGFbYV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYyA9PT0gJ3N0cmluZycgPyBjIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXFxcdScgKyAoJzAwMDAnICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgICAgICAgICAgICAgIH0pICsgJ1wiJyA6XG4gICAgICAgICAgICAgICAgJ1wiJyArIHN0cmluZyArICdcIic7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHN0ciA9IGZ1bmN0aW9uKGtleSwgaG9sZGVyKSB7XG4gICAgICAgICAgICB2YXIgZ2FwID0gJyc7XG4gICAgICAgICAgICB2YXIgaW5kZW50ID0gJyAgICAnO1xuICAgICAgICAgICAgdmFyIGkgPSAwOyAvLyBUaGUgbG9vcCBjb3VudGVyLlxuICAgICAgICAgICAgdmFyIGsgPSAnJzsgLy8gVGhlIG1lbWJlciBrZXkuXG4gICAgICAgICAgICB2YXIgdiA9ICcnOyAvLyBUaGUgbWVtYmVyIHZhbHVlLlxuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICAgICAgICB2YXIgbWluZCA9IGdhcDtcbiAgICAgICAgICAgIHZhciBwYXJ0aWFsID0gW107XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBob2xkZXJba2V5XTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGhhcyBhIHRvSlNPTiBtZXRob2QsIGNhbGwgaXQgdG8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihrZXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXaGF0IGhhcHBlbnMgbmV4dCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSdzIHR5cGUuXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBxdW90ZSh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIEVuY29kZSBub24tZmluaXRlIG51bWJlcnMgYXMgbnVsbC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKSA/IFN0cmluZyh2YWx1ZSkgOiAnbnVsbCc7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIGEgYm9vbGVhbiBvciBudWxsLCBjb252ZXJ0IGl0IHRvIGEgc3RyaW5nLiBOb3RlOlxuICAgICAgICAgICAgICAgICAgICAvLyB0eXBlb2YgbnVsbCBkb2VzIG5vdCBwcm9kdWNlICdudWxsJy4gVGhlIGNhc2UgaXMgaW5jbHVkZWQgaGVyZSBpblxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcmVtb3RlIGNoYW5jZSB0aGF0IHRoaXMgZ2V0cyBmaXhlZCBzb21lZGF5LlxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHR5cGUgaXMgJ29iamVjdCcsIHdlIG1pZ2h0IGJlIGRlYWxpbmcgd2l0aCBhbiBvYmplY3Qgb3IgYW4gYXJyYXkgb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gbnVsbC5cbiAgICAgICAgICAgICAgICAgICAgLy8gRHVlIHRvIGEgc3BlY2lmaWNhdGlvbiBibHVuZGVyIGluIEVDTUFTY3JpcHQsIHR5cGVvZiBudWxsIGlzICdvYmplY3QnLFxuICAgICAgICAgICAgICAgICAgICAvLyBzbyB3YXRjaCBvdXQgZm9yIHRoYXQgY2FzZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgYW4gYXJyYXkgdG8gaG9sZCB0aGUgcGFydGlhbCByZXN1bHRzIG9mIHN0cmluZ2lmeWluZyB0aGlzIG9iamVjdCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgZ2FwICs9IGluZGVudDtcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElzIHRoZSB2YWx1ZSBhbiBhcnJheT9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvU3RyaW5nLmFwcGx5KHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHZhbHVlIGlzIGFuIGFycmF5LiBTdHJpbmdpZnkgZXZlcnkgZWxlbWVudC4gVXNlIG51bGwgYXMgYSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIG5vbi1KU09OIHZhbHVlcy5cblxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbFtpXSA9IHN0cihpLCB2YWx1ZSkgfHwgJ251bGwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBKb2luIGFsbCBvZiB0aGUgZWxlbWVudHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcywgYW5kIHdyYXAgdGhlbSBpblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnJhY2tldHMuXG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDAgPyAnW10nIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXAgPyAnW1xcbicgKyBnYXAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwuam9pbignLFxcbicgKyBnYXApICsgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmQgKyAnXScgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnWycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICddJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgb2YgdGhlIGtleXMgaW4gdGhlIG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gocXVvdGUoaykgKyAoZ2FwID8gJzogJyA6ICc6JykgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBKb2luIGFsbCBvZiB0aGUgbWVtYmVyIHRleHRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCB3cmFwIHRoZW0gaW4gYnJhY2VzLlxuICAgICAgICAgICAgICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDAgPyAne30nIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhcCA/ICd7JyArIHBhcnRpYWwuam9pbignLCcpICsgJycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluZCArICd9JyA6ICd7JyArIHBhcnRpYWwuam9pbignLCcpICsgJ30nO1xuICAgICAgICAgICAgICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBNYWtlIGEgZmFrZSByb290IG9iamVjdCBjb250YWluaW5nIG91ciB2YWx1ZSB1bmRlciB0aGUga2V5IG9mICcnLlxuICAgICAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdCBvZiBzdHJpbmdpZnlpbmcgdGhlIHZhbHVlLlxuICAgICAgICByZXR1cm4gc3RyKCcnLCB7XG4gICAgICAgICAgICAnJzogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogRnJvbSBodHRwczovL2dpdGh1Yi5jb20vZG91Z2xhc2Nyb2NrZm9yZC9KU09OLWpzL2Jsb2IvbWFzdGVyL2pzb25fcGFyc2UuanNcbiAqIFNsaWdodGx5IG1vZGlmaWVkIHRvIHRocm93IGEgcmVhbCBFcnJvciByYXRoZXIgdGhhbiBhIFBPSk9cbiAqL1xuXy5KU09ORGVjb2RlID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBhdCwgLy8gVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGNoYXJhY3RlclxuICAgICAgICBjaCwgLy8gVGhlIGN1cnJlbnQgY2hhcmFjdGVyXG4gICAgICAgIGVzY2FwZWUgPSB7XG4gICAgICAgICAgICAnXCInOiAnXCInLFxuICAgICAgICAgICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgICAgICAgICAnLyc6ICcvJyxcbiAgICAgICAgICAgICdiJzogJ1xcYicsXG4gICAgICAgICAgICAnZic6ICdcXGYnLFxuICAgICAgICAgICAgJ24nOiAnXFxuJyxcbiAgICAgICAgICAgICdyJzogJ1xccicsXG4gICAgICAgICAgICAndCc6ICdcXHQnXG4gICAgICAgIH0sXG4gICAgICAgIHRleHQsXG4gICAgICAgIGVycm9yID0gZnVuY3Rpb24obSkge1xuICAgICAgICAgICAgdmFyIGUgPSBuZXcgU3ludGF4RXJyb3IobSk7XG4gICAgICAgICAgICBlLmF0ID0gYXQ7XG4gICAgICAgICAgICBlLnRleHQgPSB0ZXh0O1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSxcbiAgICAgICAgbmV4dCA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgIC8vIElmIGEgYyBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQsIHZlcmlmeSB0aGF0IGl0IG1hdGNoZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgaWYgKGMgJiYgYyAhPT0gY2gpIHtcbiAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgXFwnJyArIGMgKyAnXFwnIGluc3RlYWQgb2YgXFwnJyArIGNoICsgJ1xcJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRoZSBuZXh0IGNoYXJhY3Rlci4gV2hlbiB0aGVyZSBhcmUgbm8gbW9yZSBjaGFyYWN0ZXJzLFxuICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgICAgICAgICBjaCA9IHRleHQuY2hhckF0KGF0KTtcbiAgICAgICAgICAgIGF0ICs9IDE7XG4gICAgICAgICAgICByZXR1cm4gY2g7XG4gICAgICAgIH0sXG4gICAgICAgIG51bWJlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gUGFyc2UgYSBudW1iZXIgdmFsdWUuXG4gICAgICAgICAgICB2YXIgbnVtYmVyLFxuICAgICAgICAgICAgICAgIHN0cmluZyA9ICcnO1xuXG4gICAgICAgICAgICBpZiAoY2ggPT09ICctJykge1xuICAgICAgICAgICAgICAgIHN0cmluZyA9ICctJztcbiAgICAgICAgICAgICAgICBuZXh0KCctJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2ggPT09ICcuJykge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSAnLic7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHQoKSAmJiBjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2ggPT09ICdlJyB8fCBjaCA9PT0gJ0UnKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBudW1iZXIgPSArc3RyaW5nO1xuICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShudW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoJ0JhZCBudW1iZXInKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFBhcnNlIGEgc3RyaW5nIHZhbHVlLlxuICAgICAgICAgICAgdmFyIGhleCxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIHN0cmluZyA9ICcnLFxuICAgICAgICAgICAgICAgIHVmZmZmO1xuICAgICAgICAgICAgLy8gV2hlbiBwYXJzaW5nIGZvciBzdHJpbmcgdmFsdWVzLCB3ZSBtdXN0IGxvb2sgZm9yIFwiIGFuZCBcXCBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgaWYgKGNoID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWZmZmYgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGV4ID0gcGFyc2VJbnQobmV4dCgpLCAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNGaW5pdGUoaGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWZmZmYgPSB1ZmZmZiAqIDE2ICsgaGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1ZmZmZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlc2NhcGVlW2NoXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gZXNjYXBlZVtjaF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IoJ0JhZCBzdHJpbmcnKTtcbiAgICAgICAgfSxcbiAgICAgICAgd2hpdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFNraXAgd2hpdGVzcGFjZS5cbiAgICAgICAgICAgIHdoaWxlIChjaCAmJiBjaCA8PSAnICcpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHdvcmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIHRydWUsIGZhbHNlLCBvciBudWxsLlxuICAgICAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICAgICAgICBuZXh0KCd0Jyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ3InKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgndScpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCdlJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICAgICAgICBuZXh0KCdmJyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ2EnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnbCcpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCdzJyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ2UnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgICAgICAgICBuZXh0KCduJyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ3UnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnbCcpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgXCInICsgY2ggKyAnXCInKTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWUsIC8vIFBsYWNlaG9sZGVyIGZvciB0aGUgdmFsdWUgZnVuY3Rpb24uXG4gICAgICAgIGFycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBQYXJzZSBhbiBhcnJheSB2YWx1ZS5cbiAgICAgICAgICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoY2ggPT09ICdbJykge1xuICAgICAgICAgICAgICAgIG5leHQoJ1snKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ10nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5OyAvLyBlbXB0eSBhcnJheVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXkucHVzaCh2YWx1ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoJ10nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXh0KCcsJyk7XG4gICAgICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IoJ0JhZCBhcnJheScpO1xuICAgICAgICB9LFxuICAgICAgICBvYmplY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFBhcnNlIGFuIG9iamVjdCB2YWx1ZS5cbiAgICAgICAgICAgIHZhciBrZXksXG4gICAgICAgICAgICAgICAgb2JqZWN0ID0ge307XG5cbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgneycpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnfScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0OyAvLyBlbXB0eSBvYmplY3RcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCc6Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdEdXBsaWNhdGUga2V5IFwiJyArIGtleSArICdcIicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdFtrZXldID0gdmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoJ30nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnLCcpO1xuICAgICAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yKCdCYWQgb2JqZWN0Jyk7XG4gICAgICAgIH07XG5cbiAgICB2YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBQYXJzZSBhIEpTT04gdmFsdWUuIEl0IGNvdWxkIGJlIGFuIG9iamVjdCwgYW4gYXJyYXksIGEgc3RyaW5nLFxuICAgICAgICAvLyBhIG51bWJlciwgb3IgYSB3b3JkLlxuICAgICAgICB3aGl0ZSgpO1xuICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0KCk7XG4gICAgICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXkoKTtcbiAgICAgICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nKCk7XG4gICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBjaCA+PSAnMCcgJiYgY2ggPD0gJzknID8gbnVtYmVyKCkgOiB3b3JkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gUmV0dXJuIHRoZSBqc29uX3BhcnNlIGZ1bmN0aW9uLiBJdCB3aWxsIGhhdmUgYWNjZXNzIHRvIGFsbCBvZiB0aGVcbiAgICAvLyBhYm92ZSBmdW5jdGlvbnMgYW5kIHZhcmlhYmxlcy5cbiAgICByZXR1cm4gZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgdGV4dCA9IHNvdXJjZTtcbiAgICAgICAgYXQgPSAwO1xuICAgICAgICBjaCA9ICcgJztcbiAgICAgICAgcmVzdWx0ID0gdmFsdWUoKTtcbiAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgaWYgKGNoKSB7XG4gICAgICAgICAgICBlcnJvcignU3ludGF4IGVycm9yJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xuXG5fLmJhc2U2NEVuY29kZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgYjY0ID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JztcbiAgICB2YXIgbzEsIG8yLCBvMywgaDEsIGgyLCBoMywgaDQsIGJpdHMsIGkgPSAwLFxuICAgICAgICBhYyA9IDAsXG4gICAgICAgIGVuYyA9ICcnLFxuICAgICAgICB0bXBfYXJyID0gW107XG5cbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZGF0YSA9IF8udXRmOEVuY29kZShkYXRhKTtcblxuICAgIGRvIHsgLy8gcGFjayB0aHJlZSBvY3RldHMgaW50byBmb3VyIGhleGV0c1xuICAgICAgICBvMSA9IGRhdGEuY2hhckNvZGVBdChpKyspO1xuICAgICAgICBvMiA9IGRhdGEuY2hhckNvZGVBdChpKyspO1xuICAgICAgICBvMyA9IGRhdGEuY2hhckNvZGVBdChpKyspO1xuXG4gICAgICAgIGJpdHMgPSBvMSA8PCAxNiB8IG8yIDw8IDggfCBvMztcblxuICAgICAgICBoMSA9IGJpdHMgPj4gMTggJiAweDNmO1xuICAgICAgICBoMiA9IGJpdHMgPj4gMTIgJiAweDNmO1xuICAgICAgICBoMyA9IGJpdHMgPj4gNiAmIDB4M2Y7XG4gICAgICAgIGg0ID0gYml0cyAmIDB4M2Y7XG5cbiAgICAgICAgLy8gdXNlIGhleGV0cyB0byBpbmRleCBpbnRvIGI2NCwgYW5kIGFwcGVuZCByZXN1bHQgdG8gZW5jb2RlZCBzdHJpbmdcbiAgICAgICAgdG1wX2FyclthYysrXSA9IGI2NC5jaGFyQXQoaDEpICsgYjY0LmNoYXJBdChoMikgKyBiNjQuY2hhckF0KGgzKSArIGI2NC5jaGFyQXQoaDQpO1xuICAgIH0gd2hpbGUgKGkgPCBkYXRhLmxlbmd0aCk7XG5cbiAgICBlbmMgPSB0bXBfYXJyLmpvaW4oJycpO1xuXG4gICAgc3dpdGNoIChkYXRhLmxlbmd0aCAlIDMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgZW5jID0gZW5jLnNsaWNlKDAsIC0yKSArICc9PSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgZW5jID0gZW5jLnNsaWNlKDAsIC0xKSArICc9JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBlbmM7XG59O1xuXG5fLnV0ZjhFbmNvZGUgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICBzdHJpbmcgPSAoc3RyaW5nICsgJycpLnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJykucmVwbGFjZSgvXFxyL2csICdcXG4nKTtcblxuICAgIHZhciB1dGZ0ZXh0ID0gJycsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBlbmQ7XG4gICAgdmFyIHN0cmluZ2wgPSAwLFxuICAgICAgICBuO1xuXG4gICAgc3RhcnQgPSBlbmQgPSAwO1xuICAgIHN0cmluZ2wgPSBzdHJpbmcubGVuZ3RoO1xuXG4gICAgZm9yIChuID0gMDsgbiA8IHN0cmluZ2w7IG4rKykge1xuICAgICAgICB2YXIgYzEgPSBzdHJpbmcuY2hhckNvZGVBdChuKTtcbiAgICAgICAgdmFyIGVuYyA9IG51bGw7XG5cbiAgICAgICAgaWYgKGMxIDwgMTI4KSB7XG4gICAgICAgICAgICBlbmQrKztcbiAgICAgICAgfSBlbHNlIGlmICgoYzEgPiAxMjcpICYmIChjMSA8IDIwNDgpKSB7XG4gICAgICAgICAgICBlbmMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjMSA+PiA2KSB8IDE5MiwgKGMxICYgNjMpIHwgMTI4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVuYyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMxID4+IDEyKSB8IDIyNCwgKChjMSA+PiA2KSAmIDYzKSB8IDEyOCwgKGMxICYgNjMpIHwgMTI4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5jICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoZW5kID4gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICB1dGZ0ZXh0ICs9IHN0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1dGZ0ZXh0ICs9IGVuYztcbiAgICAgICAgICAgIHN0YXJ0ID0gZW5kID0gbiArIDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW5kID4gc3RhcnQpIHtcbiAgICAgICAgdXRmdGV4dCArPSBzdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCBzdHJpbmcubGVuZ3RoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRmdGV4dDtcbn07XG5cbl8uVVVJRCA9IGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIHVzZSBuYXRpdmUgQ3J5cHRvIEFQSSB3aGVuIGF2YWlsYWJsZVxuICAgICAgICByZXR1cm4gd2luWydjcnlwdG8nXVsncmFuZG9tVVVJRCddKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIGZhbGwgYmFjayB0byBnZW5lcmF0aW5nIG91ciBvd24gVVVJRFxuICAgICAgICAvLyBiYXNlZCBvbiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9zY3dvb2QvM2JmZjQyY2MwMDVjYzIwYWI3ZWM5OGYwZDhlMWQ1OWRcbiAgICAgICAgdmFyIHV1aWQgPSBuZXcgQXJyYXkoMzYpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM2OyBpKyspIHtcbiAgICAgICAgICAgIHV1aWRbaV0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxNik7XG4gICAgICAgIH1cbiAgICAgICAgdXVpZFsxNF0gPSA0OyAvLyBzZXQgYml0cyAxMi0xNSBvZiB0aW1lLWhpZ2gtYW5kLXZlcnNpb24gdG8gMDEwMFxuICAgICAgICB1dWlkWzE5XSA9IHV1aWRbMTldICY9IC01OyAvLyBzZXQgYml0IDYgb2YgY2xvY2stc2VxLWFuZC1yZXNlcnZlZCB0byB6ZXJvXG4gICAgICAgIHV1aWRbMTldID0gdXVpZFsxOV0gfD0gKDEgPDwgMyk7IC8vIHNldCBiaXQgNyBvZiBjbG9jay1zZXEtYW5kLXJlc2VydmVkIHRvIG9uZVxuICAgICAgICB1dWlkWzhdID0gdXVpZFsxM10gPSB1dWlkWzE4XSA9IHV1aWRbMjNdID0gJy0nO1xuXG4gICAgICAgIHJldHVybiBfLm1hcCh1dWlkLCBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgICByZXR1cm4geC50b1N0cmluZygxNik7XG4gICAgICAgIH0pLmpvaW4oJycpO1xuICAgIH1cbn07XG5cbi8vIF8uaXNCbG9ja2VkVUEoKVxuLy8gVGhpcyBpcyB0byBibG9jayB2YXJpb3VzIHdlYiBzcGlkZXJzIGZyb20gZXhlY3V0aW5nIG91ciBKUyBhbmRcbi8vIHNlbmRpbmcgZmFsc2UgdHJhY2tpbmcgZGF0YVxudmFyIEJMT0NLRURfVUFfU1RSUyA9IFtcbiAgICAnYWhyZWZzYm90JyxcbiAgICAnYWhyZWZzc2l0ZWF1ZGl0JyxcbiAgICAnYW1hem9uYm90JyxcbiAgICAnYmFpZHVzcGlkZXInLFxuICAgICdiaW5nYm90JyxcbiAgICAnYmluZ3ByZXZpZXcnLFxuICAgICdjaHJvbWUtbGlnaHRob3VzZScsXG4gICAgJ2ZhY2Vib29rZXh0ZXJuYWwnLFxuICAgICdwZXRhbGJvdCcsXG4gICAgJ3BpbnRlcmVzdCcsXG4gICAgJ3NjcmVhbWluZyBmcm9nJyxcbiAgICAneWFob28hIHNsdXJwJyxcbiAgICAneWFuZGV4JyxcblxuICAgIC8vIGEgd2hvbGUgYnVuY2ggb2YgZ29vZy1zcGVjaWZpYyBjcmF3bGVyc1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3NlYXJjaC9kb2NzL2FkdmFuY2VkL2NyYXdsaW5nL292ZXJ2aWV3LWdvb2dsZS1jcmF3bGVyc1xuICAgICdhZHNib3QtZ29vZ2xlJyxcbiAgICAnYXBpcy1nb29nbGUnLFxuICAgICdkdXBsZXh3ZWItZ29vZ2xlJyxcbiAgICAnZmVlZGZldGNoZXItZ29vZ2xlJyxcbiAgICAnZ29vZ2xlIGZhdmljb24nLFxuICAgICdnb29nbGUgd2ViIHByZXZpZXcnLFxuICAgICdnb29nbGUtcmVhZC1hbG91ZCcsXG4gICAgJ2dvb2dsZWJvdCcsXG4gICAgJ2dvb2dsZXdlYmxpZ2h0JyxcbiAgICAnbWVkaWFwYXJ0bmVycy1nb29nbGUnLFxuICAgICdzdG9yZWJvdC1nb29nbGUnXG5dO1xuXy5pc0Jsb2NrZWRVQSA9IGZ1bmN0aW9uKHVhKSB7XG4gICAgdmFyIGk7XG4gICAgdWEgPSB1YS50b0xvd2VyQ2FzZSgpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBCTE9DS0VEX1VBX1NUUlMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHVhLmluZGV4T2YoQkxPQ0tFRF9VQV9TVFJTW2ldKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q9fSBmb3JtZGF0YVxuICogQHBhcmFtIHtzdHJpbmc9fSBhcmdfc2VwYXJhdG9yXG4gKi9cbl8uSFRUUEJ1aWxkUXVlcnkgPSBmdW5jdGlvbihmb3JtZGF0YSwgYXJnX3NlcGFyYXRvcikge1xuICAgIHZhciB1c2VfdmFsLCB1c2Vfa2V5LCB0bXBfYXJyID0gW107XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChhcmdfc2VwYXJhdG9yKSkge1xuICAgICAgICBhcmdfc2VwYXJhdG9yID0gJyYnO1xuICAgIH1cblxuICAgIF8uZWFjaChmb3JtZGF0YSwgZnVuY3Rpb24odmFsLCBrZXkpIHtcbiAgICAgICAgdXNlX3ZhbCA9IGVuY29kZVVSSUNvbXBvbmVudCh2YWwudG9TdHJpbmcoKSk7XG4gICAgICAgIHVzZV9rZXkgPSBlbmNvZGVVUklDb21wb25lbnQoa2V5KTtcbiAgICAgICAgdG1wX2Fyclt0bXBfYXJyLmxlbmd0aF0gPSB1c2Vfa2V5ICsgJz0nICsgdXNlX3ZhbDtcbiAgICB9KTtcblxuICAgIHJldHVybiB0bXBfYXJyLmpvaW4oYXJnX3NlcGFyYXRvcik7XG59O1xuXG5fLmdldFF1ZXJ5UGFyYW0gPSBmdW5jdGlvbih1cmwsIHBhcmFtKSB7XG4gICAgLy8gRXhwZWN0cyBhIHJhdyBVUkxcblxuICAgIHBhcmFtID0gcGFyYW0ucmVwbGFjZSgvW1tdL2csICdcXFxcWycpLnJlcGxhY2UoL1tcXF1dL2csICdcXFxcXScpO1xuICAgIHZhciByZWdleFMgPSAnW1xcXFw/Jl0nICsgcGFyYW0gKyAnPShbXiYjXSopJyxcbiAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4UyksXG4gICAgICAgIHJlc3VsdHMgPSByZWdleC5leGVjKHVybCk7XG4gICAgaWYgKHJlc3VsdHMgPT09IG51bGwgfHwgKHJlc3VsdHMgJiYgdHlwZW9mKHJlc3VsdHNbMV0pICE9PSAnc3RyaW5nJyAmJiByZXN1bHRzWzFdLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRzWzFdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZGVjb2RlVVJJQ29tcG9uZW50KHJlc3VsdCk7XG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlJDEuZXJyb3IoJ1NraXBwaW5nIGRlY29kaW5nIGZvciBtYWxmb3JtZWQgcXVlcnkgcGFyYW06ICcgKyByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgfVxufTtcblxuXG4vLyBfLmNvb2tpZVxuLy8gTWV0aG9kcyBwYXJ0aWFsbHkgYm9ycm93ZWQgZnJvbSBxdWlya3Ntb2RlLm9yZy9qcy9jb29raWVzLmh0bWxcbl8uY29va2llID0ge1xuICAgIGdldDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgbmFtZUVRID0gbmFtZSArICc9JztcbiAgICAgICAgdmFyIGNhID0gZG9jdW1lbnQkMS5jb29raWUuc3BsaXQoJzsnKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGMgPSBjYVtpXTtcbiAgICAgICAgICAgIHdoaWxlIChjLmNoYXJBdCgwKSA9PSAnICcpIHtcbiAgICAgICAgICAgICAgICBjID0gYy5zdWJzdHJpbmcoMSwgYy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMuaW5kZXhPZihuYW1lRVEpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChjLnN1YnN0cmluZyhuYW1lRVEubGVuZ3RoLCBjLmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICBwYXJzZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgY29va2llO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29va2llID0gXy5KU09ORGVjb2RlKF8uY29va2llLmdldChuYW1lKSkgfHwge307XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb29raWU7XG4gICAgfSxcblxuICAgIHNldF9zZWNvbmRzOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgc2Vjb25kcywgaXNfY3Jvc3Nfc3ViZG9tYWluLCBpc19zZWN1cmUsIGlzX2Nyb3NzX3NpdGUsIGRvbWFpbl9vdmVycmlkZSkge1xuICAgICAgICB2YXIgY2RvbWFpbiA9ICcnLFxuICAgICAgICAgICAgZXhwaXJlcyA9ICcnLFxuICAgICAgICAgICAgc2VjdXJlID0gJyc7XG5cbiAgICAgICAgaWYgKGRvbWFpbl9vdmVycmlkZSkge1xuICAgICAgICAgICAgY2RvbWFpbiA9ICc7IGRvbWFpbj0nICsgZG9tYWluX292ZXJyaWRlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzX2Nyb3NzX3N1YmRvbWFpbikge1xuICAgICAgICAgICAgdmFyIGRvbWFpbiA9IGV4dHJhY3RfZG9tYWluKGRvY3VtZW50JDEubG9jYXRpb24uaG9zdG5hbWUpO1xuICAgICAgICAgICAgY2RvbWFpbiA9IGRvbWFpbiA/ICc7IGRvbWFpbj0uJyArIGRvbWFpbiA6ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlY29uZHMpIHtcbiAgICAgICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArIChzZWNvbmRzICogMTAwMCkpO1xuICAgICAgICAgICAgZXhwaXJlcyA9ICc7IGV4cGlyZXM9JyArIGRhdGUudG9HTVRTdHJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc19jcm9zc19zaXRlKSB7XG4gICAgICAgICAgICBpc19zZWN1cmUgPSB0cnVlO1xuICAgICAgICAgICAgc2VjdXJlID0gJzsgU2FtZVNpdGU9Tm9uZSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzX3NlY3VyZSkge1xuICAgICAgICAgICAgc2VjdXJlICs9ICc7IHNlY3VyZSc7XG4gICAgICAgIH1cblxuICAgICAgICBkb2N1bWVudCQxLmNvb2tpZSA9IG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpICsgZXhwaXJlcyArICc7IHBhdGg9LycgKyBjZG9tYWluICsgc2VjdXJlO1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBkYXlzLCBpc19jcm9zc19zdWJkb21haW4sIGlzX3NlY3VyZSwgaXNfY3Jvc3Nfc2l0ZSwgZG9tYWluX292ZXJyaWRlKSB7XG4gICAgICAgIHZhciBjZG9tYWluID0gJycsIGV4cGlyZXMgPSAnJywgc2VjdXJlID0gJyc7XG5cbiAgICAgICAgaWYgKGRvbWFpbl9vdmVycmlkZSkge1xuICAgICAgICAgICAgY2RvbWFpbiA9ICc7IGRvbWFpbj0nICsgZG9tYWluX292ZXJyaWRlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzX2Nyb3NzX3N1YmRvbWFpbikge1xuICAgICAgICAgICAgdmFyIGRvbWFpbiA9IGV4dHJhY3RfZG9tYWluKGRvY3VtZW50JDEubG9jYXRpb24uaG9zdG5hbWUpO1xuICAgICAgICAgICAgY2RvbWFpbiA9IGRvbWFpbiA/ICc7IGRvbWFpbj0uJyArIGRvbWFpbiA6ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRheXMpIHtcbiAgICAgICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArIChkYXlzICogMjQgKiA2MCAqIDYwICogMTAwMCkpO1xuICAgICAgICAgICAgZXhwaXJlcyA9ICc7IGV4cGlyZXM9JyArIGRhdGUudG9HTVRTdHJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc19jcm9zc19zaXRlKSB7XG4gICAgICAgICAgICBpc19zZWN1cmUgPSB0cnVlO1xuICAgICAgICAgICAgc2VjdXJlID0gJzsgU2FtZVNpdGU9Tm9uZSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzX3NlY3VyZSkge1xuICAgICAgICAgICAgc2VjdXJlICs9ICc7IHNlY3VyZSc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV3X2Nvb2tpZV92YWwgPSBuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSArIGV4cGlyZXMgKyAnOyBwYXRoPS8nICsgY2RvbWFpbiArIHNlY3VyZTtcbiAgICAgICAgZG9jdW1lbnQkMS5jb29raWUgPSBuZXdfY29va2llX3ZhbDtcbiAgICAgICAgcmV0dXJuIG5ld19jb29raWVfdmFsO1xuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uKG5hbWUsIGlzX2Nyb3NzX3N1YmRvbWFpbiwgZG9tYWluX292ZXJyaWRlKSB7XG4gICAgICAgIF8uY29va2llLnNldChuYW1lLCAnJywgLTEsIGlzX2Nyb3NzX3N1YmRvbWFpbiwgZmFsc2UsIGZhbHNlLCBkb21haW5fb3ZlcnJpZGUpO1xuICAgIH1cbn07XG5cbnZhciBfdGVzdFN0b3JhZ2VTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoc3RvcmFnZSkge1xuICAgIHZhciBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBrZXkgPSAnX19tcGxzc18nICsgY2hlYXBfZ3VpZCg4KSxcbiAgICAgICAgICAgIHZhbCA9ICd4eXonO1xuICAgICAgICBzdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWwpO1xuICAgICAgICBpZiAoc3RvcmFnZS5nZXRJdGVtKGtleSkgIT09IHZhbCkge1xuICAgICAgICAgICAgc3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc3VwcG9ydGVkO1xufTtcblxudmFyIF9sb2NhbFN0b3JhZ2VTdXBwb3J0ZWQgPSBudWxsO1xudmFyIGxvY2FsU3RvcmFnZVN1cHBvcnRlZCA9IGZ1bmN0aW9uKHN0b3JhZ2UsIGZvcmNlQ2hlY2spIHtcbiAgICBpZiAoX2xvY2FsU3RvcmFnZVN1cHBvcnRlZCAhPT0gbnVsbCAmJiAhZm9yY2VDaGVjaykge1xuICAgICAgICByZXR1cm4gX2xvY2FsU3RvcmFnZVN1cHBvcnRlZDtcbiAgICB9XG4gICAgcmV0dXJuIF9sb2NhbFN0b3JhZ2VTdXBwb3J0ZWQgPSBfdGVzdFN0b3JhZ2VTdXBwb3J0ZWQoc3RvcmFnZSB8fCB3aW4ubG9jYWxTdG9yYWdlKTtcbn07XG5cbnZhciBfc2Vzc2lvblN0b3JhZ2VTdXBwb3J0ZWQgPSBudWxsO1xudmFyIHNlc3Npb25TdG9yYWdlU3VwcG9ydGVkID0gZnVuY3Rpb24oc3RvcmFnZSwgZm9yY2VDaGVjaykge1xuICAgIGlmIChfc2Vzc2lvblN0b3JhZ2VTdXBwb3J0ZWQgIT09IG51bGwgJiYgIWZvcmNlQ2hlY2spIHtcbiAgICAgICAgcmV0dXJuIF9zZXNzaW9uU3RvcmFnZVN1cHBvcnRlZDtcbiAgICB9XG4gICAgcmV0dXJuIF9zZXNzaW9uU3RvcmFnZVN1cHBvcnRlZCA9IF90ZXN0U3RvcmFnZVN1cHBvcnRlZChzdG9yYWdlIHx8IHdpbi5zZXNzaW9uU3RvcmFnZSk7XG59O1xuXG5mdW5jdGlvbiBfc3RvcmFnZVdyYXBwZXIoc3RvcmFnZSwgbmFtZSwgaXNfc3VwcG9ydGVkX2ZuKSB7XG4gICAgdmFyIGxvZ19lcnJvciA9IGZ1bmN0aW9uKG1zZykge1xuICAgICAgICBjb25zb2xlJDEuZXJyb3IobmFtZSArICcgZXJyb3I6ICcgKyBtc2cpO1xuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBpc19zdXBwb3J0ZWQ6IGZ1bmN0aW9uKGZvcmNlQ2hlY2spIHtcbiAgICAgICAgICAgIHZhciBzdXBwb3J0ZWQgPSBpc19zdXBwb3J0ZWRfZm4oc3RvcmFnZSwgZm9yY2VDaGVjayk7XG4gICAgICAgICAgICBpZiAoIXN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUkMS5lcnJvcihuYW1lICsgJyB1bnN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1cHBvcnRlZDtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGxvZ19lcnJvcixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgbG9nX2Vycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5KU09ORGVjb2RlKHN0b3JhZ2UuZ2V0SXRlbShrZXkpKSB8fCB7fTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgbG9nX2Vycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgbG9nX2Vycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5fLmxvY2FsU3RvcmFnZSA9IF9zdG9yYWdlV3JhcHBlcih3aW4ubG9jYWxTdG9yYWdlLCAnbG9jYWxTdG9yYWdlJywgbG9jYWxTdG9yYWdlU3VwcG9ydGVkKTtcbl8uc2Vzc2lvblN0b3JhZ2UgPSBfc3RvcmFnZVdyYXBwZXIod2luLnNlc3Npb25TdG9yYWdlLCAnc2Vzc2lvblN0b3JhZ2UnLCBzZXNzaW9uU3RvcmFnZVN1cHBvcnRlZCk7XG5cbl8ucmVnaXN0ZXJfZXZlbnQgPSAoZnVuY3Rpb24oKSB7XG4gICAgLy8gd3JpdHRlbiBieSBEZWFuIEVkd2FyZHMsIDIwMDVcbiAgICAvLyB3aXRoIGlucHV0IGZyb20gVGlubyBaaWpkZWwgLSBjcmlzcEB4czRhbGwubmxcbiAgICAvLyB3aXRoIGlucHV0IGZyb20gQ2FybCBTdmVycmUgLSBtYWlsQGNhcmxzdmVycmUuY29tXG4gICAgLy8gd2l0aCBpbnB1dCBmcm9tIE1peHBhbmVsXG4gICAgLy8gaHR0cDovL2RlYW4uZWR3YXJkcy5uYW1lL3dlYmxvZy8yMDA1LzEwL2FkZC1ldmVudC9cbiAgICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8xOTMwNDQwXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbiguLi4qKX0gaGFuZGxlclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9sZFNjaG9vbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVzZUNhcHR1cmVcbiAgICAgKi9cbiAgICB2YXIgcmVnaXN0ZXJfZXZlbnQgPSBmdW5jdGlvbihlbGVtZW50LCB0eXBlLCBoYW5kbGVyLCBvbGRTY2hvb2wsIHVzZUNhcHR1cmUpIHtcbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlJDEuZXJyb3IoJ05vIHZhbGlkIGVsZW1lbnQgcHJvdmlkZWQgdG8gcmVnaXN0ZXJfZXZlbnQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIgJiYgIW9sZFNjaG9vbCkge1xuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsICEhdXNlQ2FwdHVyZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgb250eXBlID0gJ29uJyArIHR5cGU7XG4gICAgICAgICAgICB2YXIgb2xkX2hhbmRsZXIgPSBlbGVtZW50W29udHlwZV07IC8vIGNhbiBiZSB1bmRlZmluZWRcbiAgICAgICAgICAgIGVsZW1lbnRbb250eXBlXSA9IG1ha2VIYW5kbGVyKGVsZW1lbnQsIGhhbmRsZXIsIG9sZF9oYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtYWtlSGFuZGxlcihlbGVtZW50LCBuZXdfaGFuZGxlciwgb2xkX2hhbmRsZXJzKSB7XG4gICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50ID0gZXZlbnQgfHwgZml4RXZlbnQod2luLmV2ZW50KTtcblxuICAgICAgICAgICAgLy8gdGhpcyBiYXNpY2FsbHkgaGFwcGVucyBpbiBmaXJlZm94IHdoZW5ldmVyIGFub3RoZXIgc2NyaXB0XG4gICAgICAgICAgICAvLyBvdmVyd3JpdGVzIHRoZSBvbmxvYWQgY2FsbGJhY2sgYW5kIGRvZXNuJ3QgcGFzcyB0aGUgZXZlbnRcbiAgICAgICAgICAgIC8vIG9iamVjdCB0byBwcmV2aW91c2x5IGRlZmluZWQgY2FsbGJhY2tzLiAgQWxsIHRoZSBicm93c2Vyc1xuICAgICAgICAgICAgLy8gdGhhdCBkb24ndCBkZWZpbmUgd2luZG93LmV2ZW50IGltcGxlbWVudCBhZGRFdmVudExpc3RlbmVyXG4gICAgICAgICAgICAvLyBzbyB0aGUgZG9tX2xvYWRlZCBoYW5kbGVyIHdpbGwgc3RpbGwgYmUgZmlyZWQgYXMgdXN1YWwuXG4gICAgICAgICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJldCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkX3Jlc3VsdCwgbmV3X3Jlc3VsdDtcblxuICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihvbGRfaGFuZGxlcnMpKSB7XG4gICAgICAgICAgICAgICAgb2xkX3Jlc3VsdCA9IG9sZF9oYW5kbGVycyhldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdfcmVzdWx0ID0gbmV3X2hhbmRsZXIuY2FsbChlbGVtZW50LCBldmVudCk7XG5cbiAgICAgICAgICAgIGlmICgoZmFsc2UgPT09IG9sZF9yZXN1bHQpIHx8IChmYWxzZSA9PT0gbmV3X3Jlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gaGFuZGxlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaXhFdmVudChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0ID0gZml4RXZlbnQucHJldmVudERlZmF1bHQ7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24gPSBmaXhFdmVudC5zdG9wUHJvcGFnYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1cbiAgICBmaXhFdmVudC5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgfTtcbiAgICBmaXhFdmVudC5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgIH07XG5cbiAgICByZXR1cm4gcmVnaXN0ZXJfZXZlbnQ7XG59KSgpO1xuXG5cbnZhciBUT0tFTl9NQVRDSF9SRUdFWCA9IG5ldyBSZWdFeHAoJ14oXFxcXHcqKVxcXFxbKFxcXFx3KykoWz1+XFxcXHxcXFxcXlxcXFwkXFxcXCpdPyk9P1wiPyhbXlxcXFxdXCJdKilcIj9cXFxcXSQnKTtcblxuXy5kb21fcXVlcnkgPSAoZnVuY3Rpb24oKSB7XG4gICAgLyogZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVNlbGVjdG9yKHNlbGVjdG9yKVxuICAgIC0gcmV0dXJucyBhbiBhcnJheSBvZiBlbGVtZW50IG9iamVjdHMgZnJvbSB0aGUgY3VycmVudCBkb2N1bWVudFxuICAgIG1hdGNoaW5nIHRoZSBDU1Mgc2VsZWN0b3IuIFNlbGVjdG9ycyBjYW4gY29udGFpbiBlbGVtZW50IG5hbWVzLFxuICAgIGNsYXNzIG5hbWVzIGFuZCBpZHMgYW5kIGNhbiBiZSBuZXN0ZWQuIEZvciBleGFtcGxlOlxuXG4gICAgZWxlbWVudHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5U2VsZWN0b3IoJ2RpdiNtYWluIHAgYS5leHRlcm5hbCcpXG5cbiAgICBXaWxsIHJldHVybiBhbiBhcnJheSBvZiBhbGwgJ2EnIGVsZW1lbnRzIHdpdGggJ2V4dGVybmFsJyBpbiB0aGVpclxuICAgIGNsYXNzIGF0dHJpYnV0ZSB0aGF0IGFyZSBjb250YWluZWQgaW5zaWRlICdwJyBlbGVtZW50cyB0aGF0IGFyZVxuICAgIGNvbnRhaW5lZCBpbnNpZGUgdGhlICdkaXYnIGVsZW1lbnQgd2hpY2ggaGFzIGlkPVwibWFpblwiXG5cbiAgICBOZXcgaW4gdmVyc2lvbiAwLjQ6IFN1cHBvcnQgZm9yIENTUzIgYW5kIENTUzMgYXR0cmlidXRlIHNlbGVjdG9yczpcbiAgICBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblxuICAgIFZlcnNpb24gMC40IC0gU2ltb24gV2lsbGlzb24sIE1hcmNoIDI1dGggMjAwM1xuICAgIC0tIFdvcmtzIGluIFBob2VuaXggMC41LCBNb3ppbGxhIDEuMywgT3BlcmEgNywgSW50ZXJuZXQgRXhwbG9yZXIgNiwgSW50ZXJuZXQgRXhwbG9yZXIgNSBvbiBXaW5kb3dzXG4gICAgLS0gT3BlcmEgNyBmYWlsc1xuXG4gICAgVmVyc2lvbiAwLjUgLSBDYXJsIFN2ZXJyZSwgSmFuIDd0aCAyMDEzXG4gICAgLS0gTm93IHVzZXMgalF1ZXJ5LWVzcXVlIGBoYXNDbGFzc2AgZm9yIHRlc3RpbmcgY2xhc3MgbmFtZVxuICAgIGVxdWFsaXR5LiAgVGhpcyBmaXhlcyBhIGJ1ZyByZWxhdGVkIHRvICctJyBjaGFyYWN0ZXJzIGJlaW5nXG4gICAgY29uc2lkZXJlZCBub3QgcGFydCBvZiBhICd3b3JkJyBpbiByZWdleC5cbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gZ2V0QWxsQ2hpbGRyZW4oZSkge1xuICAgICAgICAvLyBSZXR1cm5zIGFsbCBjaGlsZHJlbiBvZiBlbGVtZW50LiBXb3JrYXJvdW5kIHJlcXVpcmVkIGZvciBJRTUvV2luZG93cy4gVWdoLlxuICAgICAgICByZXR1cm4gZS5hbGwgPyBlLmFsbCA6IGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKTtcbiAgICB9XG5cbiAgICB2YXIgYmFkX3doaXRlc3BhY2UgPSAvW1xcdFxcclxcbl0vZztcblxuICAgIGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW0sIHNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSAnICcgKyBzZWxlY3RvciArICcgJztcbiAgICAgICAgcmV0dXJuICgoJyAnICsgZWxlbS5jbGFzc05hbWUgKyAnICcpLnJlcGxhY2UoYmFkX3doaXRlc3BhY2UsICcgJykuaW5kZXhPZihjbGFzc05hbWUpID49IDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVsZW1lbnRzQnlTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgICAgICAvLyBBdHRlbXB0IHRvIGZhaWwgZ3JhY2VmdWxseSBpbiBsZXNzZXIgYnJvd3NlcnNcbiAgICAgICAgaWYgKCFkb2N1bWVudCQxLmdldEVsZW1lbnRzQnlUYWdOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3BsaXQgc2VsZWN0b3IgaW4gdG8gdG9rZW5zXG4gICAgICAgIHZhciB0b2tlbnMgPSBzZWxlY3Rvci5zcGxpdCgnICcpO1xuICAgICAgICB2YXIgdG9rZW4sIGJpdHMsIHRhZ05hbWUsIGZvdW5kLCBmb3VuZENvdW50LCBpLCBqLCBrLCBlbGVtZW50cywgY3VycmVudENvbnRleHRJbmRleDtcbiAgICAgICAgdmFyIGN1cnJlbnRDb250ZXh0ID0gW2RvY3VtZW50JDFdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXS5yZXBsYWNlKC9eXFxzKy8sICcnKS5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbiAgICAgICAgICAgIGlmICh0b2tlbi5pbmRleE9mKCcjJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFRva2VuIGlzIGFuIElEIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgYml0cyA9IHRva2VuLnNwbGl0KCcjJyk7XG4gICAgICAgICAgICAgICAgdGFnTmFtZSA9IGJpdHNbMF07XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gYml0c1sxXTtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50JDEuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgICAgICAgICAgIGlmICghZWxlbWVudCB8fCAodGFnTmFtZSAmJiBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT0gdGFnTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZWxlbWVudCBub3QgZm91bmQgb3IgdGFnIHdpdGggdGhhdCBJRCBub3QgZm91bmQsIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNldCBjdXJyZW50Q29udGV4dCB0byBjb250YWluIGp1c3QgdGhpcyBlbGVtZW50XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBbZWxlbWVudF07XG4gICAgICAgICAgICAgICAgY29udGludWU7IC8vIFNraXAgdG8gbmV4dCB0b2tlblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2VuLmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gVG9rZW4gY29udGFpbnMgYSBjbGFzcyBzZWxlY3RvclxuICAgICAgICAgICAgICAgIGJpdHMgPSB0b2tlbi5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgIHRhZ05hbWUgPSBiaXRzWzBdO1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBiaXRzWzFdO1xuICAgICAgICAgICAgICAgIGlmICghdGFnTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0YWdOYW1lID0gJyonO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBHZXQgZWxlbWVudHMgbWF0Y2hpbmcgdGFnLCBmaWx0ZXIgdGhlbSBmb3IgY2xhc3Mgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICBmb3VuZCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvdW5kQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjdXJyZW50Q29udGV4dC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFnTmFtZSA9PSAnKicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gZ2V0QWxsQ2hpbGRyZW4oY3VycmVudENvbnRleHRbal0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBjdXJyZW50Q29udGV4dFtqXS5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgZWxlbWVudHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kW2ZvdW5kQ291bnQrK10gPSBlbGVtZW50c1trXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dCA9IFtdO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBmb3VuZC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmRbal0uY2xhc3NOYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmlzU3RyaW5nKGZvdW5kW2pdLmNsYXNzTmFtZSkgJiYgLy8gc29tZSBTVkcgZWxlbWVudHMgaGF2ZSBjbGFzc05hbWVzIHdoaWNoIGFyZSBub3Qgc3RyaW5nc1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ2xhc3MoZm91bmRbal0sIGNsYXNzTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dFtjdXJyZW50Q29udGV4dEluZGV4KytdID0gZm91bmRbal07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7IC8vIFNraXAgdG8gbmV4dCB0b2tlblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29kZSB0byBkZWFsIHdpdGggYXR0cmlidXRlIHNlbGVjdG9yc1xuICAgICAgICAgICAgdmFyIHRva2VuX21hdGNoID0gdG9rZW4ubWF0Y2goVE9LRU5fTUFUQ0hfUkVHRVgpO1xuICAgICAgICAgICAgaWYgKHRva2VuX21hdGNoKSB7XG4gICAgICAgICAgICAgICAgdGFnTmFtZSA9IHRva2VuX21hdGNoWzFdO1xuICAgICAgICAgICAgICAgIHZhciBhdHRyTmFtZSA9IHRva2VuX21hdGNoWzJdO1xuICAgICAgICAgICAgICAgIHZhciBhdHRyT3BlcmF0b3IgPSB0b2tlbl9tYXRjaFszXTtcbiAgICAgICAgICAgICAgICB2YXIgYXR0clZhbHVlID0gdG9rZW5fbWF0Y2hbNF07XG4gICAgICAgICAgICAgICAgaWYgKCF0YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZ05hbWUgPSAnKic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEdyYWIgYWxsIG9mIHRoZSB0YWdOYW1lIGVsZW1lbnRzIHdpdGhpbiBjdXJyZW50IGNvbnRleHRcbiAgICAgICAgICAgICAgICBmb3VuZCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvdW5kQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjdXJyZW50Q29udGV4dC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFnTmFtZSA9PSAnKicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gZ2V0QWxsQ2hpbGRyZW4oY3VycmVudENvbnRleHRbal0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBjdXJyZW50Q29udGV4dFtqXS5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgZWxlbWVudHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kW2ZvdW5kQ291bnQrK10gPSBlbGVtZW50c1trXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dCA9IFtdO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHZhciBjaGVja0Z1bmN0aW9uOyAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgdXNlZCB0byBmaWx0ZXIgdGhlIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgc3dpdGNoIChhdHRyT3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnPSc6IC8vIEVxdWFsaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0Z1bmN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpID09IGF0dHJWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ34nOiAvLyBNYXRjaCBvbmUgb2Ygc3BhY2Ugc2VwZXJhdGVkIHdvcmRzXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0Z1bmN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpLm1hdGNoKG5ldyBSZWdFeHAoJ1xcXFxiJyArIGF0dHJWYWx1ZSArICdcXFxcYicpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3wnOiAvLyBNYXRjaCBzdGFydCB3aXRoIHZhbHVlIGZvbGxvd2VkIGJ5IG9wdGlvbmFsIGh5cGhlblxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tGdW5jdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKS5tYXRjaChuZXcgUmVnRXhwKCdeJyArIGF0dHJWYWx1ZSArICctPycpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ14nOiAvLyBNYXRjaCBzdGFydHMgd2l0aCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tGdW5jdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKS5pbmRleE9mKGF0dHJWYWx1ZSkgPT09IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICckJzogLy8gTWF0Y2ggZW5kcyB3aXRoIHZhbHVlIC0gZmFpbHMgd2l0aCBcIldhcm5pbmdcIiBpbiBPcGVyYSA3XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0Z1bmN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpLmxhc3RJbmRleE9mKGF0dHJWYWx1ZSkgPT0gZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpLmxlbmd0aCAtIGF0dHJWYWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICcqJzogLy8gTWF0Y2ggZW5kcyB3aXRoIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0Z1bmN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpLmluZGV4T2YoYXR0clZhbHVlKSA+IC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1c3QgdGVzdCBmb3IgZXhpc3RlbmNlIG9mIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tGdW5jdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBbXTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZm91bmQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrRnVuY3Rpb24oZm91bmRbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dFtjdXJyZW50Q29udGV4dEluZGV4KytdID0gZm91bmRbal07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYWxlcnQoJ0F0dHJpYnV0ZSBTZWxlY3RvcjogJyt0YWdOYW1lKycgJythdHRyTmFtZSsnICcrYXR0ck9wZXJhdG9yKycgJythdHRyVmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRvIG5leHQgdG9rZW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGdldCBoZXJlLCB0b2tlbiBpcyBKVVNUIGFuIGVsZW1lbnQgKG5vdCBhIGNsYXNzIG9yIElEIHNlbGVjdG9yKVxuICAgICAgICAgICAgdGFnTmFtZSA9IHRva2VuO1xuICAgICAgICAgICAgZm91bmQgPSBbXTtcbiAgICAgICAgICAgIGZvdW5kQ291bnQgPSAwO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGN1cnJlbnRDb250ZXh0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMgPSBjdXJyZW50Q29udGV4dFtqXS5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lKTtcbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgZWxlbWVudHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRbZm91bmRDb3VudCsrXSA9IGVsZW1lbnRzW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gZm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRDb250ZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbihxdWVyeSkge1xuICAgICAgICBpZiAoXy5pc0VsZW1lbnQocXVlcnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gW3F1ZXJ5XTtcbiAgICAgICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KHF1ZXJ5KSAmJiAhXy5pc1VuZGVmaW5lZChxdWVyeS5sZW5ndGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RWxlbWVudHNCeVNlbGVjdG9yLmNhbGwodGhpcywgcXVlcnkpO1xuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5cbnZhciBDQU1QQUlHTl9LRVlXT1JEUyA9IFsndXRtX3NvdXJjZScsICd1dG1fbWVkaXVtJywgJ3V0bV9jYW1wYWlnbicsICd1dG1fY29udGVudCcsICd1dG1fdGVybScsICd1dG1faWQnLCAndXRtX3NvdXJjZV9wbGF0Zm9ybScsJ3V0bV9jYW1wYWlnbl9pZCcsICd1dG1fY3JlYXRpdmVfZm9ybWF0JywgJ3V0bV9tYXJrZXRpbmdfdGFjdGljJ107XG52YXIgQ0xJQ0tfSURTID0gWydkY2xpZCcsICdmYmNsaWQnLCAnZ2NsaWQnLCAna29fY2xpY2tfaWQnLCAnbGlfZmF0X2lkJywgJ21zY2xraWQnLCAnc2NjaWQnLCAndHRjbGlkJywgJ3R3Y2xpZCcsICd3YnJhaWQnXTtcblxuXy5pbmZvID0ge1xuICAgIGNhbXBhaWduUGFyYW1zOiBmdW5jdGlvbihkZWZhdWx0X3ZhbHVlKSB7XG4gICAgICAgIHZhciBrdyA9ICcnLFxuICAgICAgICAgICAgcGFyYW1zID0ge307XG4gICAgICAgIF8uZWFjaChDQU1QQUlHTl9LRVlXT1JEUywgZnVuY3Rpb24oa3drZXkpIHtcbiAgICAgICAgICAgIGt3ID0gXy5nZXRRdWVyeVBhcmFtKGRvY3VtZW50JDEuVVJMLCBrd2tleSk7XG4gICAgICAgICAgICBpZiAoa3cubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zW2t3a2V5XSA9IGt3O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkZWZhdWx0X3ZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNba3drZXldID0gZGVmYXVsdF92YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9LFxuXG4gICAgY2xpY2tQYXJhbXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaWQgPSAnJyxcbiAgICAgICAgICAgIHBhcmFtcyA9IHt9O1xuICAgICAgICBfLmVhY2goQ0xJQ0tfSURTLCBmdW5jdGlvbihpZGtleSkge1xuICAgICAgICAgICAgaWQgPSBfLmdldFF1ZXJ5UGFyYW0oZG9jdW1lbnQkMS5VUkwsIGlka2V5KTtcbiAgICAgICAgICAgIGlmIChpZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNbaWRrZXldID0gaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfSxcblxuICAgIG1hcmtldGluZ1BhcmFtczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfLmV4dGVuZChfLmluZm8uY2FtcGFpZ25QYXJhbXMoKSwgXy5pbmZvLmNsaWNrUGFyYW1zKCkpO1xuICAgIH0sXG5cbiAgICBzZWFyY2hFbmdpbmU6IGZ1bmN0aW9uKHJlZmVycmVyKSB7XG4gICAgICAgIGlmIChyZWZlcnJlci5zZWFyY2goJ2h0dHBzPzovLyguKilnb29nbGUuKFteLz9dKiknKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICdnb29nbGUnO1xuICAgICAgICB9IGVsc2UgaWYgKHJlZmVycmVyLnNlYXJjaCgnaHR0cHM/Oi8vKC4qKWJpbmcuY29tJykgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnYmluZyc7XG4gICAgICAgIH0gZWxzZSBpZiAocmVmZXJyZXIuc2VhcmNoKCdodHRwcz86Ly8oLiopeWFob28uY29tJykgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAneWFob28nO1xuICAgICAgICB9IGVsc2UgaWYgKHJlZmVycmVyLnNlYXJjaCgnaHR0cHM/Oi8vKC4qKWR1Y2tkdWNrZ28uY29tJykgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnZHVja2R1Y2tnbyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZWFyY2hJbmZvOiBmdW5jdGlvbihyZWZlcnJlcikge1xuICAgICAgICB2YXIgc2VhcmNoID0gXy5pbmZvLnNlYXJjaEVuZ2luZShyZWZlcnJlciksXG4gICAgICAgICAgICBwYXJhbSA9IChzZWFyY2ggIT0gJ3lhaG9vJykgPyAncScgOiAncCcsXG4gICAgICAgICAgICByZXQgPSB7fTtcblxuICAgICAgICBpZiAoc2VhcmNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXRbJyRzZWFyY2hfZW5naW5lJ10gPSBzZWFyY2g7XG5cbiAgICAgICAgICAgIHZhciBrZXl3b3JkID0gXy5nZXRRdWVyeVBhcmFtKHJlZmVycmVyLCBwYXJhbSk7XG4gICAgICAgICAgICBpZiAoa2V5d29yZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXRbJ21wX2tleXdvcmQnXSA9IGtleXdvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGRldGVjdHMgd2hpY2ggYnJvd3NlciBpcyBydW5uaW5nIHRoaXMgc2NyaXB0LlxuICAgICAqIFRoZSBvcmRlciBvZiB0aGUgY2hlY2tzIGFyZSBpbXBvcnRhbnQgc2luY2UgbWFueSB1c2VyIGFnZW50c1xuICAgICAqIGluY2x1ZGUga2V5IHdvcmRzIHVzZWQgaW4gbGF0ZXIgY2hlY2tzLlxuICAgICAqL1xuICAgIGJyb3dzZXI6IGZ1bmN0aW9uKHVzZXJfYWdlbnQsIHZlbmRvciwgb3BlcmEpIHtcbiAgICAgICAgdmVuZG9yID0gdmVuZG9yIHx8ICcnOyAvLyB2ZW5kb3IgaXMgdW5kZWZpbmVkIGZvciBhdCBsZWFzdCBJRTlcbiAgICAgICAgaWYgKG9wZXJhIHx8IF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJyBPUFIvJykpIHtcbiAgICAgICAgICAgIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdNaW5pJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ09wZXJhIE1pbmknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdPcGVyYSc7XG4gICAgICAgIH0gZWxzZSBpZiAoLyhCbGFja0JlcnJ5fFBsYXlCb29rfEJCMTApL2kudGVzdCh1c2VyX2FnZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuICdCbGFja0JlcnJ5JztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdJRU1vYmlsZScpIHx8IF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ1dQRGVza3RvcCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0ludGVybmV0IEV4cGxvcmVyIE1vYmlsZSc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnU2Ftc3VuZ0Jyb3dzZXIvJykpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLnNhbXN1bmcuY29tL2ludGVybmV0L3VzZXItYWdlbnQtc3RyaW5nLWZvcm1hdFxuICAgICAgICAgICAgcmV0dXJuICdTYW1zdW5nIEludGVybmV0JztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdFZGdlJykgfHwgXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnRWRnLycpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ01pY3Jvc29mdCBFZGdlJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdGQklPUycpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0ZhY2Vib29rIE1vYmlsZSc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnV2hhbGUvJykpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdXNlci1hZ2VudHMubmV0L2Jyb3dzZXJzL3doYWxlLWJyb3dzZXJcbiAgICAgICAgICAgIHJldHVybiAnV2hhbGUgQnJvd3Nlcic7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnQ2hyb21lJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnQ2hyb21lJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdDcmlPUycpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0Nocm9tZSBpT1MnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ1VDV0VCJykgfHwgXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnVUNCcm93c2VyJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnVUMgQnJvd3Nlcic7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnRnhpT1MnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdGaXJlZm94IGlPUyc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh2ZW5kb3IsICdBcHBsZScpKSB7XG4gICAgICAgICAgICBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnTW9iaWxlJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ01vYmlsZSBTYWZhcmknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdTYWZhcmknO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0FuZHJvaWQnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdBbmRyb2lkIE1vYmlsZSc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnS29ucXVlcm9yJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnS29ucXVlcm9yJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdGaXJlZm94JykpIHtcbiAgICAgICAgICAgIHJldHVybiAnRmlyZWZveCc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnTVNJRScpIHx8IF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ1RyaWRlbnQvJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnSW50ZXJuZXQgRXhwbG9yZXInO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0dlY2tvJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnTW96aWxsYSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBkZXRlY3RzIHdoaWNoIGJyb3dzZXIgdmVyc2lvbiBpcyBydW5uaW5nIHRoaXMgc2NyaXB0LFxuICAgICAqIHBhcnNpbmcgbWFqb3IgYW5kIG1pbm9yIHZlcnNpb24gKGUuZy4sIDQyLjEpLiBVc2VyIGFnZW50IHN0cmluZ3MgZnJvbTpcbiAgICAgKiBodHRwOi8vd3d3LnVzZXJhZ2VudHN0cmluZy5jb20vcGFnZXMvdXNlcmFnZW50c3RyaW5nLnBocFxuICAgICAqL1xuICAgIGJyb3dzZXJWZXJzaW9uOiBmdW5jdGlvbih1c2VyQWdlbnQsIHZlbmRvciwgb3BlcmEpIHtcbiAgICAgICAgdmFyIGJyb3dzZXIgPSBfLmluZm8uYnJvd3Nlcih1c2VyQWdlbnQsIHZlbmRvciwgb3BlcmEpO1xuICAgICAgICB2YXIgdmVyc2lvblJlZ2V4cyA9IHtcbiAgICAgICAgICAgICdJbnRlcm5ldCBFeHBsb3JlciBNb2JpbGUnOiAvcnY6KFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnTWljcm9zb2Z0IEVkZ2UnOiAvRWRnZT9cXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdDaHJvbWUnOiAvQ2hyb21lXFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnQ2hyb21lIGlPUyc6IC9DcmlPU1xcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ1VDIEJyb3dzZXInIDogLyhVQ0Jyb3dzZXJ8VUNXRUIpXFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnU2FmYXJpJzogL1ZlcnNpb25cXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdNb2JpbGUgU2FmYXJpJzogL1ZlcnNpb25cXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdPcGVyYSc6IC8oT3BlcmF8T1BSKVxcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ0ZpcmVmb3gnOiAvRmlyZWZveFxcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ0ZpcmVmb3ggaU9TJzogL0Z4aU9TXFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnS29ucXVlcm9yJzogL0tvbnF1ZXJvcjooXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdCbGFja0JlcnJ5JzogL0JsYWNrQmVycnkgKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnQW5kcm9pZCBNb2JpbGUnOiAvYW5kcm9pZFxccyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ1NhbXN1bmcgSW50ZXJuZXQnOiAvU2Ftc3VuZ0Jyb3dzZXJcXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdJbnRlcm5ldCBFeHBsb3Jlcic6IC8ocnY6fE1TSUUgKShcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ01vemlsbGEnOiAvcnY6KFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnV2hhbGUgQnJvd3Nlcic6IC9XaGFsZVxcLyhcXGQrKFxcLlxcZCspPykvXG4gICAgICAgIH07XG4gICAgICAgIHZhciByZWdleCA9IHZlcnNpb25SZWdleHNbYnJvd3Nlcl07XG4gICAgICAgIGlmIChyZWdleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF0Y2hlcyA9IHVzZXJBZ2VudC5tYXRjaChyZWdleCk7XG4gICAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDJdKTtcbiAgICB9LFxuXG4gICAgb3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYSA9IHVzZXJBZ2VudDtcbiAgICAgICAgaWYgKC9XaW5kb3dzL2kudGVzdChhKSkge1xuICAgICAgICAgICAgaWYgKC9QaG9uZS8udGVzdChhKSB8fCAvV1BEZXNrdG9wLy50ZXN0KGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdXaW5kb3dzIFBob25lJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnV2luZG93cyc7XG4gICAgICAgIH0gZWxzZSBpZiAoLyhpUGhvbmV8aVBhZHxpUG9kKS8udGVzdChhKSkge1xuICAgICAgICAgICAgcmV0dXJuICdpT1MnO1xuICAgICAgICB9IGVsc2UgaWYgKC9BbmRyb2lkLy50ZXN0KGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0FuZHJvaWQnO1xuICAgICAgICB9IGVsc2UgaWYgKC8oQmxhY2tCZXJyeXxQbGF5Qm9va3xCQjEwKS9pLnRlc3QoYSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnQmxhY2tCZXJyeSc7XG4gICAgICAgIH0gZWxzZSBpZiAoL01hYy9pLnRlc3QoYSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnTWFjIE9TIFgnO1xuICAgICAgICB9IGVsc2UgaWYgKC9MaW51eC8udGVzdChhKSkge1xuICAgICAgICAgICAgcmV0dXJuICdMaW51eCc7XG4gICAgICAgIH0gZWxzZSBpZiAoL0NyT1MvLnRlc3QoYSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnQ2hyb21lIE9TJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkZXZpY2U6IGZ1bmN0aW9uKHVzZXJfYWdlbnQpIHtcbiAgICAgICAgaWYgKC9XaW5kb3dzIFBob25lL2kudGVzdCh1c2VyX2FnZW50KSB8fCAvV1BEZXNrdG9wLy50ZXN0KHVzZXJfYWdlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1dpbmRvd3MgUGhvbmUnO1xuICAgICAgICB9IGVsc2UgaWYgKC9pUGFkLy50ZXN0KHVzZXJfYWdlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2lQYWQnO1xuICAgICAgICB9IGVsc2UgaWYgKC9pUG9kLy50ZXN0KHVzZXJfYWdlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2lQb2QgVG91Y2gnO1xuICAgICAgICB9IGVsc2UgaWYgKC9pUGhvbmUvLnRlc3QodXNlcl9hZ2VudCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnaVBob25lJztcbiAgICAgICAgfSBlbHNlIGlmICgvKEJsYWNrQmVycnl8UGxheUJvb2t8QkIxMCkvaS50ZXN0KHVzZXJfYWdlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0JsYWNrQmVycnknO1xuICAgICAgICB9IGVsc2UgaWYgKC9BbmRyb2lkLy50ZXN0KHVzZXJfYWdlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0FuZHJvaWQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlZmVycmluZ0RvbWFpbjogZnVuY3Rpb24ocmVmZXJyZXIpIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gcmVmZXJyZXIuc3BsaXQoJy8nKTtcbiAgICAgICAgaWYgKHNwbGl0Lmxlbmd0aCA+PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gc3BsaXRbMl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH0sXG5cbiAgICBjdXJyZW50VXJsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHdpbi5sb2NhdGlvbi5ocmVmO1xuICAgIH0sXG5cbiAgICBwcm9wZXJ0aWVzOiBmdW5jdGlvbihleHRyYV9wcm9wcykge1xuICAgICAgICBpZiAodHlwZW9mIGV4dHJhX3Byb3BzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZXh0cmFfcHJvcHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXy5leHRlbmQoXy5zdHJpcF9lbXB0eV9wcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICckb3MnOiBfLmluZm8ub3MoKSxcbiAgICAgICAgICAgICckYnJvd3Nlcic6IF8uaW5mby5icm93c2VyKHVzZXJBZ2VudCwgbmF2aWdhdG9yLnZlbmRvciwgd2luZG93T3BlcmEpLFxuICAgICAgICAgICAgJyRyZWZlcnJlcic6IGRvY3VtZW50JDEucmVmZXJyZXIsXG4gICAgICAgICAgICAnJHJlZmVycmluZ19kb21haW4nOiBfLmluZm8ucmVmZXJyaW5nRG9tYWluKGRvY3VtZW50JDEucmVmZXJyZXIpLFxuICAgICAgICAgICAgJyRkZXZpY2UnOiBfLmluZm8uZGV2aWNlKHVzZXJBZ2VudClcbiAgICAgICAgfSksIHtcbiAgICAgICAgICAgICckY3VycmVudF91cmwnOiBfLmluZm8uY3VycmVudFVybCgpLFxuICAgICAgICAgICAgJyRicm93c2VyX3ZlcnNpb24nOiBfLmluZm8uYnJvd3NlclZlcnNpb24odXNlckFnZW50LCBuYXZpZ2F0b3IudmVuZG9yLCB3aW5kb3dPcGVyYSksXG4gICAgICAgICAgICAnJHNjcmVlbl9oZWlnaHQnOiBzY3JlZW4uaGVpZ2h0LFxuICAgICAgICAgICAgJyRzY3JlZW5fd2lkdGgnOiBzY3JlZW4ud2lkdGgsXG4gICAgICAgICAgICAnbXBfbGliJzogJ3dlYicsXG4gICAgICAgICAgICAnJGxpYl92ZXJzaW9uJzogQ29uZmlnLkxJQl9WRVJTSU9OLFxuICAgICAgICAgICAgJyRpbnNlcnRfaWQnOiBjaGVhcF9ndWlkKCksXG4gICAgICAgICAgICAndGltZSc6IF8udGltZXN0YW1wKCkgLyAxMDAwIC8vIGVwb2NoIHRpbWUgaW4gc2Vjb25kc1xuICAgICAgICB9LCBfLnN0cmlwX2VtcHR5X3Byb3BlcnRpZXMoZXh0cmFfcHJvcHMpKTtcbiAgICB9LFxuXG4gICAgcGVvcGxlX3Byb3BlcnRpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXy5leHRlbmQoXy5zdHJpcF9lbXB0eV9wcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICckb3MnOiBfLmluZm8ub3MoKSxcbiAgICAgICAgICAgICckYnJvd3Nlcic6IF8uaW5mby5icm93c2VyKHVzZXJBZ2VudCwgbmF2aWdhdG9yLnZlbmRvciwgd2luZG93T3BlcmEpXG4gICAgICAgIH0pLCB7XG4gICAgICAgICAgICAnJGJyb3dzZXJfdmVyc2lvbic6IF8uaW5mby5icm93c2VyVmVyc2lvbih1c2VyQWdlbnQsIG5hdmlnYXRvci52ZW5kb3IsIHdpbmRvd09wZXJhKVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgbXBQYWdlVmlld1Byb3BlcnRpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXy5zdHJpcF9lbXB0eV9wcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICdjdXJyZW50X3BhZ2VfdGl0bGUnOiBkb2N1bWVudCQxLnRpdGxlLFxuICAgICAgICAgICAgJ2N1cnJlbnRfZG9tYWluJzogd2luLmxvY2F0aW9uLmhvc3RuYW1lLFxuICAgICAgICAgICAgJ2N1cnJlbnRfdXJsX3BhdGgnOiB3aW4ubG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgICAgICAnY3VycmVudF91cmxfcHJvdG9jb2wnOiB3aW4ubG9jYXRpb24ucHJvdG9jb2wsXG4gICAgICAgICAgICAnY3VycmVudF91cmxfc2VhcmNoJzogd2luLmxvY2F0aW9uLnNlYXJjaFxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgcnVuIGF0IG1vc3QgZXZlcnkgYHdhaXRNc2AgYW5kIHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgbmV4dCBpbnZvY2F0aW9uLlxuICogVGhyb3R0bGVkIGNhbGxzIHdpbGwgYnVpbGQgdXAgYSBiYXRjaCBvZiBhcmdzIGFuZCBpbnZva2UgdGhlIGNhbGxiYWNrIHdpdGggYWxsIGFyZ3Mgc2luY2UgdGhlIGxhc3QgaW52b2NhdGlvbi5cbiAqL1xudmFyIGJhdGNoZWRUaHJvdHRsZSA9IGZ1bmN0aW9uIChmbiwgd2FpdE1zKSB7XG4gICAgdmFyIHRpbWVvdXRQcm9taXNlID0gbnVsbDtcbiAgICB2YXIgdGhyb3R0bGVkSXRlbXMgPSBbXTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aHJvdHRsZWRJdGVtcy5wdXNoKGl0ZW0pO1xuXG4gICAgICAgIGlmICghdGltZW91dFByb21pc2UpIHtcbiAgICAgICAgICAgIHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBmbi5hcHBseShzZWxmLCBbdGhyb3R0bGVkSXRlbXNdKTtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dFByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdHRsZWRJdGVtcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJldHVyblZhbHVlKTtcbiAgICAgICAgICAgICAgICB9LCB3YWl0TXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpbWVvdXRQcm9taXNlO1xuICAgIH07XG59O1xuXG52YXIgY2hlYXBfZ3VpZCA9IGZ1bmN0aW9uKG1heGxlbikge1xuICAgIHZhciBndWlkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDEwKSArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxMCk7XG4gICAgcmV0dXJuIG1heGxlbiA/IGd1aWQuc3Vic3RyaW5nKDAsIG1heGxlbikgOiBndWlkO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBXM0MgdHJhY2VwYXJlbnQgaGVhZGVyIGZvciBlYXN5IGludGVyb3Agd2l0aCBkaXN0cmlidXRlZCB0cmFjaW5nIHN5c3RlbXMgaS5lIE9wZW4gVGVsZW1ldHJ5XG4gKiBodHRwczovL3d3dy53My5vcmcvVFIvdHJhY2UtY29udGV4dC8jdHJhY2VwYXJlbnQtaGVhZGVyXG4qL1xudmFyIGdlbmVyYXRlVHJhY2VwYXJlbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdHJhY2VJRCA9IF8uVVVJRCgpLnJlcGxhY2UoLy0vZywgJycpO1xuICAgIHZhciBwYXJlbnRJRCA9IF8uVVVJRCgpLnJlcGxhY2UoLy0vZywgJycpLnN1YnN0cmluZygwLCAxNik7XG5cbiAgICAvLyBTYW1wbGVkIHRyYWNlXG4gICAgdmFyIHRyYWNlRmxhZ3MgPSAnMDEnO1xuXG4gICAgcmV0dXJuICcwMC0nICsgdHJhY2VJRCArICctJyArIHBhcmVudElEICsgJy0nICsgdHJhY2VGbGFncztcbn07XG5cbi8vIG5haXZlIHdheSB0byBleHRyYWN0IGRvbWFpbiBuYW1lIChleGFtcGxlLmNvbSkgZnJvbSBmdWxsIGhvc3RuYW1lIChteS5zdWIuZXhhbXBsZS5jb20pXG52YXIgU0lNUExFX0RPTUFJTl9NQVRDSF9SRUdFWCA9IC9bYS16MC05XVthLXowLTktXSpcXC5bYS16XSskL2k7XG4vLyB0aGlzIG5leHQgb25lIGF0dGVtcHRzIHRvIGFjY291bnQgZm9yIHNvbWUgY2NTTERzLCBlLmcuIGV4dHJhY3Rpbmcgb3hmb3JkLmFjLnVrIGZyb20gd3d3Lm94Zm9yZC5hYy51a1xudmFyIERPTUFJTl9NQVRDSF9SRUdFWCA9IC9bYS16MC05XVthLXowLTktXStcXC5bYS16Ll17Miw2fSQvaTtcbi8qKlxuICogQXR0ZW1wdHMgdG8gZXh0cmFjdCBtYWluIGRvbWFpbiBuYW1lIGZyb20gZnVsbCBob3N0bmFtZSwgdXNpbmcgYSBmZXcgYmx1bnQgaGV1cmlzdGljcy4gRm9yXG4gKiBjb21tb24gVExEcyBsaWtlIC5jb20vLm9yZyB0aGF0IGFsd2F5cyBoYXZlIGEgc2ltcGxlIFNMRC5UTEQgc3RydWN0dXJlIChleGFtcGxlLmNvbSksIHdlXG4gKiBzaW1wbHkgZXh0cmFjdCB0aGUgbGFzdCB0d28gLi1zZXBhcmF0ZWQgcGFydHMgb2YgdGhlIGhvc3RuYW1lIChTSU1QTEVfRE9NQUlOX01BVENIX1JFR0VYKS5cbiAqIEZvciBvdGhlcnMsIHdlIGF0dGVtcHQgdG8gYWNjb3VudCBmb3Igc2hvcnQgY2NTTEQrVExEIGNvbWJvcyAoLmFjLnVrKSB3aXRoIHRoZSBsZWdhY3lcbiAqIERPTUFJTl9NQVRDSF9SRUdFWCAoa2VwdCB0byBtYWludGFpbiBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIGV4aXN0aW5nIE1peHBhbmVsXG4gKiBpbnRlZ3JhdGlvbnMpLiBUaGUgb25seSBfcmVsaWFibGVfIHdheSB0byBleHRyYWN0IGRvbWFpbiBmcm9tIGhvc3RuYW1lIGlzIHdpdGggYW4gdXAtdG8tZGF0ZVxuICogbGlzdCBsaWtlIGF0IGh0dHBzOi8vcHVibGljc3VmZml4Lm9yZy8gc28gZm9yIGNhc2VzIHRoYXQgdGhpcyBoZWxwZXIgZmFpbHMgYXQsIHRoZSBTREtcbiAqIG9mZmVycyB0aGUgJ2Nvb2tpZV9kb21haW4nIGNvbmZpZyBvcHRpb24gdG8gc2V0IGl0IGV4cGxpY2l0bHkuXG4gKiBAZXhhbXBsZVxuICogZXh0cmFjdF9kb21haW4oJ215LnN1Yi5leGFtcGxlLmNvbScpXG4gKiAvLyAnZXhhbXBsZS5jb20nXG4gKi9cbnZhciBleHRyYWN0X2RvbWFpbiA9IGZ1bmN0aW9uKGhvc3RuYW1lKSB7XG4gICAgdmFyIGRvbWFpbl9yZWdleCA9IERPTUFJTl9NQVRDSF9SRUdFWDtcbiAgICB2YXIgcGFydHMgPSBob3N0bmFtZS5zcGxpdCgnLicpO1xuICAgIHZhciB0bGQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICBpZiAodGxkLmxlbmd0aCA+IDQgfHwgdGxkID09PSAnY29tJyB8fCB0bGQgPT09ICdvcmcnKSB7XG4gICAgICAgIGRvbWFpbl9yZWdleCA9IFNJTVBMRV9ET01BSU5fTUFUQ0hfUkVHRVg7XG4gICAgfVxuICAgIHZhciBtYXRjaGVzID0gaG9zdG5hbWUubWF0Y2goZG9tYWluX3JlZ2V4KTtcbiAgICByZXR1cm4gbWF0Y2hlcyA/IG1hdGNoZXNbMF0gOiAnJztcbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB3ZSBoYXZlIG5ldHdvcmsgY29ubmVjdGlvbi4gZGVmYXVsdCB0byB0cnVlIGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgbmF2aWdhdG9yLm9uTGluZSAoSUUpXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xudmFyIGlzT25saW5lID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9uTGluZSA9IHdpbi5uYXZpZ2F0b3JbJ29uTGluZSddO1xuICAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9uTGluZSkgfHwgb25MaW5lO1xufTtcblxudmFyIE5PT1BfRlVOQyA9IGZ1bmN0aW9uICgpIHt9O1xuXG52YXIgSlNPTlN0cmluZ2lmeSA9IG51bGwsIEpTT05QYXJzZSA9IG51bGw7XG5pZiAodHlwZW9mIEpTT04gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgSlNPTlN0cmluZ2lmeSA9IEpTT04uc3RyaW5naWZ5O1xuICAgIEpTT05QYXJzZSA9IEpTT04ucGFyc2U7XG59XG5KU09OU3RyaW5naWZ5ID0gSlNPTlN0cmluZ2lmeSB8fCBfLkpTT05FbmNvZGU7XG5KU09OUGFyc2UgPSBKU09OUGFyc2UgfHwgXy5KU09ORGVjb2RlO1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgQ29tcHJlc3Npb25TdHJlYW0gQVBJIHNob3VsZCBiZSB1c2VkLlxuICogUmV0dXJucyBmYWxzZSBmb3IgU2FmYXJpIDE2LjQgYW5kIDE2LjUgd2hpY2ggaGF2ZSBicmVha2luZyBDb21wcmVzc2lvblN0cmVhbSBidWdzLlxuICogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI1NDAyMVxuICogZml4ZWQgaW4gMTYuNiBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vZG9jdW1lbnRhdGlvbi9zYWZhcmktcmVsZWFzZS1ub3Rlcy9zYWZhcmktMTZfNi1yZWxlYXNlLW5vdGVzXG4gKi9cbnZhciBjYW5Vc2VDb21wcmVzc2lvblN0cmVhbSA9IGZ1bmN0aW9uKHVzZXJBZ2VudCwgdmVuZG9yLCBvcGVyYSkge1xuICAgIGlmICghd2luLkNvbXByZXNzaW9uU3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgYnJvd3NlciA9IF8uaW5mby5icm93c2VyKHVzZXJBZ2VudCwgdmVuZG9yLCBvcGVyYSk7XG4gICAgdmFyIHZlcnNpb24gPSBfLmluZm8uYnJvd3NlclZlcnNpb24odXNlckFnZW50LCB2ZW5kb3IsIG9wZXJhKTtcbiAgICBpZiAoYnJvd3NlciA9PT0gJ1NhZmFyaScgfHwgYnJvd3NlciA9PT0gJ01vYmlsZSBTYWZhcmknKSB7XG4gICAgICAgIGlmICh2ZXJzaW9uID49IDE2LjQgJiYgdmVyc2lvbiA8IDE2LjYpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLy8gVU5NSU5JRklFRCBFWFBPUlRTIChmb3IgY2xvc3VyZSBjb21waWxlcilcbl9bJ2luZm8nXSAgICAgICAgICAgICAgICAgICA9IF8uaW5mbztcbl9bJ2luZm8nXVsnYnJvd3NlciddICAgICAgICA9IF8uaW5mby5icm93c2VyO1xuX1snaW5mbyddWydicm93c2VyVmVyc2lvbiddID0gXy5pbmZvLmJyb3dzZXJWZXJzaW9uO1xuX1snaW5mbyddWydkZXZpY2UnXSAgICAgICAgID0gXy5pbmZvLmRldmljZTtcbl9bJ2luZm8nXVsncHJvcGVydGllcyddICAgICA9IF8uaW5mby5wcm9wZXJ0aWVzO1xuX1snaXNCbG9ja2VkVUEnXSAgICAgICAgICAgID0gXy5pc0Jsb2NrZWRVQTtcbl9bJ2lzRW1wdHlPYmplY3QnXSAgICAgICAgICA9IF8uaXNFbXB0eU9iamVjdDtcbl9bJ2lzT2JqZWN0J10gICAgICAgICAgICAgICA9IF8uaXNPYmplY3Q7XG5fWydKU09ORGVjb2RlJ10gICAgICAgICAgICAgPSBfLkpTT05EZWNvZGU7XG5fWydKU09ORW5jb2RlJ10gICAgICAgICAgICAgPSBfLkpTT05FbmNvZGU7XG5fWyd0b0FycmF5J10gICAgICAgICAgICAgICAgPSBfLnRvQXJyYXk7XG5fWydOUE8nXSAgICAgICAgICAgICAgICAgICAgPSBOcG9Qcm9taXNlO1xuXG52YXIgTUlYUEFORUxfREJfTkFNRSA9ICdtaXhwYW5lbEJyb3dzZXJEYic7XG5cbnZhciBSRUNPUkRJTkdfRVZFTlRTX1NUT1JFX05BTUUgPSAnbWl4cGFuZWxSZWNvcmRpbmdFdmVudHMnO1xudmFyIFJFQ09SRElOR19SRUdJU1RSWV9TVE9SRV9OQU1FID0gJ21peHBhbmVsUmVjb3JkaW5nUmVnaXN0cnknO1xuXG4vLyBub3RlOiBpbmNyZW1lbnQgdGhlIHZlcnNpb24gbnVtYmVyIHdoZW4gYWRkaW5nIG5ldyBvYmplY3Qgc3RvcmVzXG52YXIgREJfVkVSU0lPTiA9IDE7XG52YXIgT0JKRUNUX1NUT1JFUyA9IFtSRUNPUkRJTkdfRVZFTlRTX1NUT1JFX05BTUUsIFJFQ09SRElOR19SRUdJU1RSWV9TVE9SRV9OQU1FXTtcblxuLyoqXG4gKiBAdHlwZSB7aW1wb3J0KCcuL3dyYXBwZXInKS5TdG9yYWdlV3JhcHBlcn1cbiAqL1xudmFyIElEQlN0b3JhZ2VXcmFwcGVyID0gZnVuY3Rpb24gKHN0b3JlTmFtZSkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtQcm9taXNlPElEQkRhdGFiYXNlPnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuZGJQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLnN0b3JlTmFtZSA9IHN0b3JlTmFtZTtcbn07XG5cbklEQlN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5fb3BlbkRiID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIG9wZW5SZXF1ZXN0ID0gd2luLmluZGV4ZWREQi5vcGVuKE1JWFBBTkVMX0RCX05BTUUsIERCX1ZFUlNJT04pO1xuICAgICAgICBvcGVuUmVxdWVzdFsnb25lcnJvciddID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVqZWN0KG9wZW5SZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgfTtcblxuICAgICAgICBvcGVuUmVxdWVzdFsnb25zdWNjZXNzJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXNvbHZlKG9wZW5SZXF1ZXN0LnJlc3VsdCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgb3BlblJlcXVlc3RbJ29udXBncmFkZW5lZWRlZCddID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgZGIgPSBldi50YXJnZXQucmVzdWx0O1xuXG4gICAgICAgICAgICBPQkpFQ1RfU1RPUkVTLmZvckVhY2goZnVuY3Rpb24gKHN0b3JlTmFtZSkge1xuICAgICAgICAgICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9KTtcbn07XG5cbklEQlN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghd2luLmluZGV4ZWREQikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlamVjdCgnaW5kZXhlZERCIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmRiUHJvbWlzZSkge1xuICAgICAgICB0aGlzLmRiUHJvbWlzZSA9IHRoaXMuX29wZW5EYigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmRiUHJvbWlzZVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoZGJPckVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZGJPckVycm9yIGluc3RhbmNlb2Ygd2luWydJREJEYXRhYmFzZSddKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVqZWN0KGRiT3JFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xufTtcblxuSURCU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLmlzSW5pdGlhbGl6ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5kYlByb21pc2U7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SURCVHJhbnNhY3Rpb25Nb2RlfSBtb2RlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKElEQk9iamVjdFN0b3JlKTogdm9pZH0gc3RvcmVDYlxuICovXG5JREJTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUubWFrZVRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKG1vZGUsIHN0b3JlQ2IpIHtcbiAgICB2YXIgc3RvcmVOYW1lID0gdGhpcy5zdG9yZU5hbWU7XG4gICAgdmFyIGRvVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAoZGIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oc3RvcmVOYW1lLCBtb2RlKTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLm9uY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25hYm9ydCA9IHRyYW5zYWN0aW9uLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KHRyYW5zYWN0aW9uLmVycm9yKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHN0b3JlQ2IodHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc3RvcmVOYW1lKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy5kYlByb21pc2VcbiAgICAgICAgLnRoZW4oZG9UcmFuc2FjdGlvbilcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyWyduYW1lJ10gPT09ICdJbnZhbGlkU3RhdGVFcnJvcicpIHtcbiAgICAgICAgICAgICAgICAvLyB0cnkgcmVvcGVuaW5nIHRoZSBEQiBpZiB0aGUgY29ubmVjdGlvbiBpcyBjbG9zZWRcbiAgICAgICAgICAgICAgICB0aGlzLmRiUHJvbWlzZSA9IHRoaXMuX29wZW5EYigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRiUHJvbWlzZS50aGVuKGRvVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpO1xufTtcblxuSURCU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLnNldEl0ZW0gPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLm1ha2VUcmFuc2FjdGlvbigncmVhZHdyaXRlJywgZnVuY3Rpb24gKG9iamVjdFN0b3JlKSB7XG4gICAgICAgIG9iamVjdFN0b3JlLnB1dCh2YWx1ZSwga2V5KTtcbiAgICB9KTtcbn07XG5cbklEQlN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5nZXRJdGVtID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciByZXE7XG4gICAgcmV0dXJuIHRoaXMubWFrZVRyYW5zYWN0aW9uKCdyZWFkb25seScsIGZ1bmN0aW9uIChvYmplY3RTdG9yZSkge1xuICAgICAgICByZXEgPSBvYmplY3RTdG9yZS5nZXQoa2V5KTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlcS5yZXN1bHQ7XG4gICAgfSk7XG59O1xuXG5JREJTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUucmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5tYWtlVHJhbnNhY3Rpb24oJ3JlYWR3cml0ZScsIGZ1bmN0aW9uIChvYmplY3RTdG9yZSkge1xuICAgICAgICBvYmplY3RTdG9yZS5kZWxldGUoa2V5KTtcbiAgICB9KTtcbn07XG5cbklEQlN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5nZXRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlcTtcbiAgICByZXR1cm4gdGhpcy5tYWtlVHJhbnNhY3Rpb24oJ3JlYWRvbmx5JywgZnVuY3Rpb24gKG9iamVjdFN0b3JlKSB7XG4gICAgICAgIHJlcSA9IG9iamVjdFN0b3JlLmdldEFsbCgpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVxLnJlc3VsdDtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogR0RQUiB1dGlsc1xuICpcbiAqIFRoZSBHZW5lcmFsIERhdGEgUHJvdGVjdGlvbiBSZWd1bGF0aW9uIChHRFBSKSBpcyBhIHJlZ3VsYXRpb24gaW4gRVUgbGF3IG9uIGRhdGEgcHJvdGVjdGlvblxuICogYW5kIHByaXZhY3kgZm9yIGFsbCBpbmRpdmlkdWFscyB3aXRoaW4gdGhlIEV1cm9wZWFuIFVuaW9uLiBJdCBhZGRyZXNzZXMgdGhlIGV4cG9ydCBvZiBwZXJzb25hbFxuICogZGF0YSBvdXRzaWRlIHRoZSBFVS4gVGhlIEdEUFIgYWltcyBwcmltYXJpbHkgdG8gZ2l2ZSBjb250cm9sIGJhY2sgdG8gY2l0aXplbnMgYW5kIHJlc2lkZW50c1xuICogb3ZlciB0aGVpciBwZXJzb25hbCBkYXRhIGFuZCB0byBzaW1wbGlmeSB0aGUgcmVndWxhdG9yeSBlbnZpcm9ubWVudCBmb3IgaW50ZXJuYXRpb25hbCBidXNpbmVzc1xuICogYnkgdW5pZnlpbmcgdGhlIHJlZ3VsYXRpb24gd2l0aGluIHRoZSBFVS5cbiAqXG4gKiBUaGlzIHNldCBvZiB1dGlsaXRpZXMgaXMgaW50ZW5kZWQgdG8gZW5hYmxlIG9wdCBpbi9vdXQgZnVuY3Rpb25hbGl0eSBpbiB0aGUgTWl4cGFuZWwgSlMgU0RLLlxuICogVGhlc2UgZnVuY3Rpb25zIGFyZSB1c2VkIGludGVybmFsbHkgYnkgdGhlIFNESyBhbmQgYXJlIG5vdCBpbnRlbmRlZCB0byBiZSBwdWJsaWNseSBleHBvc2VkLlxuICovXG5cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHVzZWQgdG8gdHJhY2sgYSBNaXhwYW5lbCBldmVudCAoZS5nLiBNaXhwYW5lbExpYi50cmFjaylcbiAqIEBjYWxsYmFjayB0cmFja0Z1bmN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRfbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuIFRoaXMgY2FuIGJlIGFueXRoaW5nIHRoZSB1c2VyIGRvZXMgLSAnQnV0dG9uIENsaWNrJywgJ1NpZ24gVXAnLCAnSXRlbSBQdXJjaGFzZWQnLCBldGMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIEEgc2V0IG9mIHByb3BlcnRpZXMgdG8gaW5jbHVkZSB3aXRoIHRoZSBldmVudCB5b3UncmUgc2VuZGluZy4gVGhlc2UgZGVzY3JpYmUgdGhlIHVzZXIgd2hvIGRpZCB0aGUgZXZlbnQgb3IgZGV0YWlscyBhYm91dCB0aGUgZXZlbnQgaXRzZWxmLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiAqL1xuXG4vKiogUHVibGljICoqL1xuXG52YXIgR0RQUl9ERUZBVUxUX1BFUlNJU1RFTkNFX1BSRUZJWCA9ICdfX21wX29wdF9pbl9vdXRfJztcblxuLyoqXG4gKiBPcHQgdGhlIHVzZXIgaW4gdG8gZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoZSBnaXZlbiB0b2tlblxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gTWl4cGFuZWwgcHJvamVjdCB0cmFja2luZyB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHt0cmFja0Z1bmN0aW9ufSBbb3B0aW9ucy50cmFja10gLSBmdW5jdGlvbiB1c2VkIGZvciB0cmFja2luZyBhIE1peHBhbmVsIGV2ZW50IHRvIHJlY29yZCB0aGUgb3B0LWluIGFjdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRyYWNrRXZlbnROYW1lXSAtIGV2ZW50IG5hbWUgdG8gYmUgdXNlZCBmb3IgdHJhY2tpbmcgdGhlIG9wdC1pbiBhY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy50cmFja1Byb3BlcnRpZXNdIC0gc2V0IG9mIHByb3BlcnRpZXMgdG8gYmUgdHJhY2tlZCBhbG9uZyB3aXRoIHRoZSBvcHQtaW4gYWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VUeXBlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVByZWZpeD1fX21wX29wdF9pbl9vdXRdIC0gY3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29raWVFeHBpcmF0aW9uXSAtIG51bWJlciBvZiBkYXlzIHVudGlsIHRoZSBvcHQtaW4gY29va2llIGV4cGlyZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVEb21haW5dIC0gY3VzdG9tIGNvb2tpZSBkb21haW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NTaXRlQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXNpdGUtZW5hYmxlZFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc1N1YmRvbWFpbkNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zdWJkb21haW4gb3Igbm90XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlY3VyZUNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBzZWN1cmUgb3Igbm90XG4gKi9cbmZ1bmN0aW9uIG9wdEluKHRva2VuLCBvcHRpb25zKSB7XG4gICAgX29wdEluT3V0KHRydWUsIHRva2VuLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBPcHQgdGhlIHVzZXIgb3V0IG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIE1peHBhbmVsIHByb2plY3QgdHJhY2tpbmcgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVR5cGVdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4PV9fbXBfb3B0X2luX291dF0gLSBjdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb2tpZUV4cGlyYXRpb25dIC0gbnVtYmVyIG9mIGRheXMgdW50aWwgdGhlIG9wdC1vdXQgY29va2llIGV4cGlyZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVEb21haW5dIC0gY3VzdG9tIGNvb2tpZSBkb21haW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NTaXRlQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXNpdGUtZW5hYmxlZFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc1N1YmRvbWFpbkNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtb3V0IGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc3ViZG9tYWluIG9yIG5vdFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWN1cmVDb29raWVdIC0gd2hldGhlciB0aGUgb3B0LW91dCBjb29raWUgaXMgc2V0IGFzIHNlY3VyZSBvciBub3RcbiAqL1xuZnVuY3Rpb24gb3B0T3V0KHRva2VuLCBvcHRpb25zKSB7XG4gICAgX29wdEluT3V0KGZhbHNlLCB0b2tlbiwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgdXNlciBoYXMgb3B0ZWQgaW4gdG8gZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoZSBnaXZlbiB0b2tlblxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gTWl4cGFuZWwgcHJvamVjdCB0cmFja2luZyB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlVHlwZV0gUGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgLSBjb29raWUgb3IgbG9jYWxTdG9yYWdlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VQcmVmaXg9X19tcF9vcHRfaW5fb3V0XSAtIGN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgdXNlciBoYXMgb3B0ZWQgaW4gdG8gdGhlIGdpdmVuIG9wdCB0eXBlXG4gKi9cbmZ1bmN0aW9uIGhhc09wdGVkSW4odG9rZW4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX2dldFN0b3JhZ2VWYWx1ZSh0b2tlbiwgb3B0aW9ucykgPT09ICcxJztcbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXQgb2YgZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoZSBnaXZlbiB0b2tlblxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gTWl4cGFuZWwgcHJvamVjdCB0cmFja2luZyB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlVHlwZV0gUGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgLSBjb29raWUgb3IgbG9jYWxTdG9yYWdlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VQcmVmaXg9X19tcF9vcHRfaW5fb3V0XSAtIGN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlnbm9yZURudF0gLSBmbGFnIHRvIGlnbm9yZSBicm93c2VyIEROVCBzZXR0aW5ncyBhbmQgYWx3YXlzIHJldHVybiBmYWxzZVxuICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIHVzZXIgaGFzIG9wdGVkIG91dCBvZiB0aGUgZ2l2ZW4gb3B0IHR5cGVcbiAqL1xuZnVuY3Rpb24gaGFzT3B0ZWRPdXQodG9rZW4sIG9wdGlvbnMpIHtcbiAgICBpZiAoX2hhc0RvTm90VHJhY2tGbGFnT24ob3B0aW9ucykpIHtcbiAgICAgICAgY29uc29sZSQxLndhcm4oJ1RoaXMgYnJvd3NlciBoYXMgXCJEbyBOb3QgVHJhY2tcIiBlbmFibGVkLiBUaGlzIHdpbGwgcHJldmVudCB0aGUgTWl4cGFuZWwgU0RLIGZyb20gc2VuZGluZyBhbnkgZGF0YS4gVG8gaWdub3JlIHRoZSBcIkRvIE5vdCBUcmFja1wiIGJyb3dzZXIgc2V0dGluZywgaW5pdGlhbGl6ZSB0aGUgTWl4cGFuZWwgaW5zdGFuY2Ugd2l0aCB0aGUgY29uZmlnIFwiaWdub3JlX2RudDogdHJ1ZVwiJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgb3B0ZWRPdXQgPSBfZ2V0U3RvcmFnZVZhbHVlKHRva2VuLCBvcHRpb25zKSA9PT0gJzAnO1xuICAgIGlmIChvcHRlZE91dCkge1xuICAgICAgICBjb25zb2xlJDEud2FybignWW91IGFyZSBvcHRlZCBvdXQgb2YgTWl4cGFuZWwgdHJhY2tpbmcuIFRoaXMgd2lsbCBwcmV2ZW50IHRoZSBNaXhwYW5lbCBTREsgZnJvbSBzZW5kaW5nIGFueSBkYXRhLicpO1xuICAgIH1cbiAgICByZXR1cm4gb3B0ZWRPdXQ7XG59XG5cbi8qKlxuICogV3JhcCBhIE1peHBhbmVsTGliIG1ldGhvZCB3aXRoIGEgY2hlY2sgZm9yIHdoZXRoZXIgdGhlIHVzZXIgaXMgb3B0ZWQgb3V0IG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIElmIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXQsIHJldHVybiBlYXJseSBpbnN0ZWFkIG9mIGV4ZWN1dGluZyB0aGUgbWV0aG9kLlxuICogSWYgYSBjYWxsYmFjayBhcmd1bWVudCB3YXMgcHJvdmlkZWQsIGV4ZWN1dGUgaXQgcGFzc2luZyB0aGUgMCBlcnJvciBjb2RlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIC0gd3JhcHBlZCBtZXRob2QgdG8gYmUgZXhlY3V0ZWQgaWYgdGhlIHVzZXIgaGFzIG5vdCBvcHRlZCBvdXRcbiAqIEByZXR1cm5zIHsqfSB0aGUgcmVzdWx0IG9mIGV4ZWN1dGluZyBtZXRob2QgT1IgdW5kZWZpbmVkIGlmIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXRcbiAqL1xuZnVuY3Rpb24gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYihtZXRob2QpIHtcbiAgICByZXR1cm4gX2FkZE9wdE91dENoZWNrKG1ldGhvZCwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRfY29uZmlnKG5hbWUpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFdyYXAgYSBNaXhwYW5lbFBlb3BsZSBtZXRob2Qgd2l0aCBhIGNoZWNrIGZvciB3aGV0aGVyIHRoZSB1c2VyIGlzIG9wdGVkIG91dCBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhlIGdpdmVuIHRva2VuXG4gKiBJZiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0LCByZXR1cm4gZWFybHkgaW5zdGVhZCBvZiBleGVjdXRpbmcgdGhlIG1ldGhvZC5cbiAqIElmIGEgY2FsbGJhY2sgYXJndW1lbnQgd2FzIHByb3ZpZGVkLCBleGVjdXRlIGl0IHBhc3NpbmcgdGhlIDAgZXJyb3IgY29kZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCAtIHdyYXBwZWQgbWV0aG9kIHRvIGJlIGV4ZWN1dGVkIGlmIHRoZSB1c2VyIGhhcyBub3Qgb3B0ZWQgb3V0XG4gKiBAcmV0dXJucyB7Kn0gdGhlIHJlc3VsdCBvZiBleGVjdXRpbmcgbWV0aG9kIE9SIHVuZGVmaW5lZCBpZiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0XG4gKi9cbmZ1bmN0aW9uIGFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUobWV0aG9kKSB7XG4gICAgcmV0dXJuIF9hZGRPcHRPdXRDaGVjayhtZXRob2QsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldF9jb25maWcobmFtZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogV3JhcCBhIE1peHBhbmVsR3JvdXAgbWV0aG9kIHdpdGggYSBjaGVjayBmb3Igd2hldGhlciB0aGUgdXNlciBpcyBvcHRlZCBvdXQgb2YgZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoZSBnaXZlbiB0b2tlblxuICogSWYgdGhlIHVzZXIgaGFzIG9wdGVkIG91dCwgcmV0dXJuIGVhcmx5IGluc3RlYWQgb2YgZXhlY3V0aW5nIHRoZSBtZXRob2QuXG4gKiBJZiBhIGNhbGxiYWNrIGFyZ3VtZW50IHdhcyBwcm92aWRlZCwgZXhlY3V0ZSBpdCBwYXNzaW5nIHRoZSAwIGVycm9yIGNvZGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgLSB3cmFwcGVkIG1ldGhvZCB0byBiZSBleGVjdXRlZCBpZiB0aGUgdXNlciBoYXMgbm90IG9wdGVkIG91dFxuICogQHJldHVybnMgeyp9IHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIG1ldGhvZCBPUiB1bmRlZmluZWQgaWYgdGhlIHVzZXIgaGFzIG9wdGVkIG91dFxuICovXG5mdW5jdGlvbiBhZGRPcHRPdXRDaGVja01peHBhbmVsR3JvdXAobWV0aG9kKSB7XG4gICAgcmV0dXJuIF9hZGRPcHRPdXRDaGVjayhtZXRob2QsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldF9jb25maWcobmFtZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ2xlYXIgdGhlIHVzZXIncyBvcHQgaW4vb3V0IHN0YXR1cyBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhlIGdpdmVuIHRva2VuXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gLSBNaXhwYW5lbCBwcm9qZWN0IHRyYWNraW5nIHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VUeXBlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVByZWZpeD1fX21wX29wdF9pbl9vdXRdIC0gY3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29raWVFeHBpcmF0aW9uXSAtIG51bWJlciBvZiBkYXlzIHVudGlsIHRoZSBvcHQtaW4gY29va2llIGV4cGlyZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVEb21haW5dIC0gY3VzdG9tIGNvb2tpZSBkb21haW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NTaXRlQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXNpdGUtZW5hYmxlZFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc1N1YmRvbWFpbkNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zdWJkb21haW4gb3Igbm90XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlY3VyZUNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBzZWN1cmUgb3Igbm90XG4gKi9cbmZ1bmN0aW9uIGNsZWFyT3B0SW5PdXQodG9rZW4sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBfZ2V0U3RvcmFnZShvcHRpb25zKS5yZW1vdmUoXG4gICAgICAgIF9nZXRTdG9yYWdlS2V5KHRva2VuLCBvcHRpb25zKSwgISFvcHRpb25zLmNyb3NzU3ViZG9tYWluQ29va2llLCBvcHRpb25zLmNvb2tpZURvbWFpblxuICAgICk7XG59XG5cbi8qKiBQcml2YXRlICoqL1xuXG4vKipcbiAqIEdldCBzdG9yYWdlIHV0aWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVR5cGVdXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBlaXRoZXIgXy5jb29raWUgb3IgXy5sb2NhbHN0b3JhZ2VcbiAqL1xuZnVuY3Rpb24gX2dldFN0b3JhZ2Uob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiBvcHRpb25zLnBlcnNpc3RlbmNlVHlwZSA9PT0gJ2xvY2FsU3RvcmFnZScgPyBfLmxvY2FsU3RvcmFnZSA6IF8uY29va2llO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmFtZSBvZiB0aGUgY29va2llIHRoYXQgaXMgdXNlZCBmb3IgdGhlIGdpdmVuIG9wdCB0eXBlICh0cmFja2luZywgY29va2llLCBldGMuKVxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gTWl4cGFuZWwgcHJvamVjdCB0cmFja2luZyB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4PV9fbXBfb3B0X2luX291dF0gLSBjdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHJldHVybnMge3N0cmluZ30gdGhlIG5hbWUgb2YgdGhlIGNvb2tpZSBmb3IgdGhlIGdpdmVuIG9wdCB0eXBlXG4gKi9cbmZ1bmN0aW9uIF9nZXRTdG9yYWdlS2V5KHRva2VuLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgcmV0dXJuIChvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4IHx8IEdEUFJfREVGQVVMVF9QRVJTSVNURU5DRV9QUkVGSVgpICsgdG9rZW47XG59XG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgY29va2llIHRoYXQgaXMgdXNlZCBmb3IgdGhlIGdpdmVuIG9wdCB0eXBlICh0cmFja2luZywgY29va2llLCBldGMuKVxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gTWl4cGFuZWwgcHJvamVjdCB0cmFja2luZyB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4PV9fbXBfb3B0X2luX291dF0gLSBjdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHJldHVybnMge3N0cmluZ30gdGhlIHZhbHVlIG9mIHRoZSBjb29raWUgZm9yIHRoZSBnaXZlbiBvcHQgdHlwZVxuICovXG5mdW5jdGlvbiBfZ2V0U3RvcmFnZVZhbHVlKHRva2VuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9nZXRTdG9yYWdlKG9wdGlvbnMpLmdldChfZ2V0U3RvcmFnZUtleSh0b2tlbiwgb3B0aW9ucykpO1xufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIHVzZXIgaGFzIHNldCB0aGUgRE5UL2RvTm90VHJhY2sgc2V0dGluZyB0byB0cnVlIGluIHRoZWlyIGJyb3dzZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy53aW5kb3ddIC0gYWx0ZXJuYXRlIHdpbmRvdyBvYmplY3QgdG8gY2hlY2s7IHVzZWQgdG8gZm9yY2UgdmFyaW91cyBETlQgc2V0dGluZ3MgaW4gYnJvd3NlciB0ZXN0c1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pZ25vcmVEbnRdIC0gZmxhZyB0byBpZ25vcmUgYnJvd3NlciBETlQgc2V0dGluZ3MgYW5kIGFsd2F5cyByZXR1cm4gZmFsc2VcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSBETlQgc2V0dGluZyBpcyB0cnVlXG4gKi9cbmZ1bmN0aW9uIF9oYXNEb05vdFRyYWNrRmxhZ09uKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmlnbm9yZURudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB3aW4kMSA9IChvcHRpb25zICYmIG9wdGlvbnMud2luZG93KSB8fCB3aW47XG4gICAgdmFyIG5hdiA9IHdpbiQxWyduYXZpZ2F0b3InXSB8fCB7fTtcbiAgICB2YXIgaGFzRG50T24gPSBmYWxzZTtcblxuICAgIF8uZWFjaChbXG4gICAgICAgIG5hdlsnZG9Ob3RUcmFjayddLCAvLyBzdGFuZGFyZFxuICAgICAgICBuYXZbJ21zRG9Ob3RUcmFjayddLFxuICAgICAgICB3aW4kMVsnZG9Ob3RUcmFjayddXG4gICAgXSwgZnVuY3Rpb24oZG50VmFsdWUpIHtcbiAgICAgICAgaWYgKF8uaW5jbHVkZXMoW3RydWUsIDEsICcxJywgJ3llcyddLCBkbnRWYWx1ZSkpIHtcbiAgICAgICAgICAgIGhhc0RudE9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGhhc0RudE9uO1xufVxuXG4vKipcbiAqIFNldCBjb29raWUvbG9jYWxzdG9yYWdlIGZvciB0aGUgdXNlciBpbmRpY2F0aW5nIHRoYXQgdGhleSBhcmUgb3B0ZWQgaW4gb3Igb3V0IGZvciB0aGUgZ2l2ZW4gb3B0IHR5cGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0VmFsdWUgLSB3aGV0aGVyIHRvIG9wdCB0aGUgdXNlciBpbiBvciBvdXQgZm9yIHRoZSBnaXZlbiBvcHQgdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gTWl4cGFuZWwgcHJvamVjdCB0cmFja2luZyB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHt0cmFja0Z1bmN0aW9ufSBbb3B0aW9ucy50cmFja10gLSBmdW5jdGlvbiB1c2VkIGZvciB0cmFja2luZyBhIE1peHBhbmVsIGV2ZW50IHRvIHJlY29yZCB0aGUgb3B0LWluIGFjdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRyYWNrRXZlbnROYW1lXSAtIGV2ZW50IG5hbWUgdG8gYmUgdXNlZCBmb3IgdHJhY2tpbmcgdGhlIG9wdC1pbiBhY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy50cmFja1Byb3BlcnRpZXNdIC0gc2V0IG9mIHByb3BlcnRpZXMgdG8gYmUgdHJhY2tlZCBhbG9uZyB3aXRoIHRoZSBvcHQtaW4gYWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VQcmVmaXg9X19tcF9vcHRfaW5fb3V0XSAtIGN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29va2llRXhwaXJhdGlvbl0gLSBudW1iZXIgb2YgZGF5cyB1bnRpbCB0aGUgb3B0LWluIGNvb2tpZSBleHBpcmVzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llRG9tYWluXSAtIGN1c3RvbSBjb29raWUgZG9tYWluXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzU2l0ZUNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zaXRlLWVuYWJsZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NTdWJkb21haW5Db29raWVdIC0gd2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc3ViZG9tYWluIG9yIG5vdFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWN1cmVDb29raWVdIC0gd2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgc2VjdXJlIG9yIG5vdFxuICovXG5mdW5jdGlvbiBfb3B0SW5PdXQob3B0VmFsdWUsIHRva2VuLCBvcHRpb25zKSB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKHRva2VuKSB8fCAhdG9rZW4ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnNvbGUkMS5lcnJvcignZ2Rwci4nICsgKG9wdFZhbHVlID8gJ29wdEluJyA6ICdvcHRPdXQnKSArICcgY2FsbGVkIHdpdGggYW4gaW52YWxpZCB0b2tlbicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBfZ2V0U3RvcmFnZShvcHRpb25zKS5zZXQoXG4gICAgICAgIF9nZXRTdG9yYWdlS2V5KHRva2VuLCBvcHRpb25zKSxcbiAgICAgICAgb3B0VmFsdWUgPyAxIDogMCxcbiAgICAgICAgXy5pc051bWJlcihvcHRpb25zLmNvb2tpZUV4cGlyYXRpb24pID8gb3B0aW9ucy5jb29raWVFeHBpcmF0aW9uIDogbnVsbCxcbiAgICAgICAgISFvcHRpb25zLmNyb3NzU3ViZG9tYWluQ29va2llLFxuICAgICAgICAhIW9wdGlvbnMuc2VjdXJlQ29va2llLFxuICAgICAgICAhIW9wdGlvbnMuY3Jvc3NTaXRlQ29va2llLFxuICAgICAgICBvcHRpb25zLmNvb2tpZURvbWFpblxuICAgICk7XG5cbiAgICBpZiAob3B0aW9ucy50cmFjayAmJiBvcHRWYWx1ZSkgeyAvLyBvbmx5IHRyYWNrIGV2ZW50IGlmIG9wdGluZyBpbiAob3B0VmFsdWU9dHJ1ZSlcbiAgICAgICAgb3B0aW9ucy50cmFjayhvcHRpb25zLnRyYWNrRXZlbnROYW1lIHx8ICckb3B0X2luJywgb3B0aW9ucy50cmFja1Byb3BlcnRpZXMsIHtcbiAgICAgICAgICAgICdzZW5kX2ltbWVkaWF0ZWx5JzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogV3JhcCBhIG1ldGhvZCB3aXRoIGEgY2hlY2sgZm9yIHdoZXRoZXIgdGhlIHVzZXIgaXMgb3B0ZWQgb3V0IG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIElmIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXQsIHJldHVybiBlYXJseSBpbnN0ZWFkIG9mIGV4ZWN1dGluZyB0aGUgbWV0aG9kLlxuICogSWYgYSBjYWxsYmFjayBhcmd1bWVudCB3YXMgcHJvdmlkZWQsIGV4ZWN1dGUgaXQgcGFzc2luZyB0aGUgMCBlcnJvciBjb2RlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIC0gd3JhcHBlZCBtZXRob2QgdG8gYmUgZXhlY3V0ZWQgaWYgdGhlIHVzZXIgaGFzIG5vdCBvcHRlZCBvdXRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGdldENvbmZpZ1ZhbHVlIC0gZ2V0dGVyIGZ1bmN0aW9uIGZvciB0aGUgTWl4cGFuZWwgQVBJIHRva2VuIGFuZCBvdGhlciBvcHRpb25zIHRvIGJlIHVzZWQgd2l0aCBvcHQtb3V0IGNoZWNrXG4gKiBAcmV0dXJucyB7Kn0gdGhlIHJlc3VsdCBvZiBleGVjdXRpbmcgbWV0aG9kIE9SIHVuZGVmaW5lZCBpZiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0XG4gKi9cbmZ1bmN0aW9uIF9hZGRPcHRPdXRDaGVjayhtZXRob2QsIGdldENvbmZpZ1ZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0ZWRPdXQgPSBmYWxzZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHRva2VuID0gZ2V0Q29uZmlnVmFsdWUuY2FsbCh0aGlzLCAndG9rZW4nKTtcbiAgICAgICAgICAgIHZhciBpZ25vcmVEbnQgPSBnZXRDb25maWdWYWx1ZS5jYWxsKHRoaXMsICdpZ25vcmVfZG50Jyk7XG4gICAgICAgICAgICB2YXIgcGVyc2lzdGVuY2VUeXBlID0gZ2V0Q29uZmlnVmFsdWUuY2FsbCh0aGlzLCAnb3B0X291dF90cmFja2luZ19wZXJzaXN0ZW5jZV90eXBlJyk7XG4gICAgICAgICAgICB2YXIgcGVyc2lzdGVuY2VQcmVmaXggPSBnZXRDb25maWdWYWx1ZS5jYWxsKHRoaXMsICdvcHRfb3V0X3RyYWNraW5nX2Nvb2tpZV9wcmVmaXgnKTtcbiAgICAgICAgICAgIHZhciB3aW4gPSBnZXRDb25maWdWYWx1ZS5jYWxsKHRoaXMsICd3aW5kb3cnKTsgLy8gdXNlZCB0byBvdmVycmlkZSB3aW5kb3cgZHVyaW5nIGJyb3dzZXIgdGVzdHNcblxuICAgICAgICAgICAgaWYgKHRva2VuKSB7IC8vIGlmIHRoZXJlIHdhcyBhbiBpc3N1ZSBnZXR0aW5nIHRoZSB0b2tlbiwgY29udGludWUgbWV0aG9kIGV4ZWN1dGlvbiBhcyBub3JtYWxcbiAgICAgICAgICAgICAgICBvcHRlZE91dCA9IGhhc09wdGVkT3V0KHRva2VuLCB7XG4gICAgICAgICAgICAgICAgICAgIGlnbm9yZURudDogaWdub3JlRG50LFxuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0ZW5jZVR5cGU6IHBlcnNpc3RlbmNlVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcGVyc2lzdGVuY2VQcmVmaXg6IHBlcnNpc3RlbmNlUHJlZml4LFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3c6IHdpblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgY29uc29sZSQxLmVycm9yKCdVbmV4cGVjdGVkIGVycm9yIHdoZW4gY2hlY2tpbmcgdHJhY2tpbmcgb3B0LW91dCBzdGF0dXM6ICcgKyBlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvcHRlZE91dCkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHR5cGVvZihjYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG59XG5cbnZhciBsb2dnZXIkNiA9IGNvbnNvbGVfd2l0aF9wcmVmaXgoJ2xvY2snKTtcblxuLyoqXG4gKiBTaGFyZWRMb2NrOiBhIG11dGV4IGJ1aWx0IG9uIEhUTUw1IGxvY2FsU3RvcmFnZSwgdG8gZW5zdXJlIHRoYXQgb25seSBvbmUgYnJvd3NlclxuICogd2luZG93L3RhYiBhdCBhIHRpbWUgd2lsbCBiZSBhYmxlIHRvIGFjY2VzcyBzaGFyZWQgcmVzb3VyY2VzLlxuICpcbiAqIEJhc2VkIG9uIHRoZSBBbHVyIGFuZCBUYXViZW5mZWxkIGZhc3QgbG9ja1xuICogKGh0dHA6Ly93d3cuY3Mucm9jaGVzdGVyLmVkdS9yZXNlYXJjaC9zeW5jaHJvbml6YXRpb24vcHNldWRvY29kZS9mYXN0bG9jay5odG1sKVxuICogd2l0aCBhbiBhZGRlZCB0aW1lb3V0IHRvIGVuc3VyZSB0aGVyZSB3aWxsIGJlIGV2ZW50dWFsIHByb2dyZXNzIGluIHRoZSBldmVudFxuICogdGhhdCBhIHdpbmRvdyBpcyBjbG9zZWQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgY2FsbGJhY2suXG4gKlxuICogSW1wbGVtZW50YXRpb24gYmFzZWQgb24gdGhlIG9yaWdpbmFsIHZlcnNpb24gYnkgRGF2aWQgV29sZXZlciAoaHR0cHM6Ly9naXRodWIuY29tL3dvbGV2ZXIpXG4gKiBhdCBodHRwczovL2dpc3QuZ2l0aHViLmNvbS93b2xldmVyLzVmZDc1NzNkMWVmNjE2NmU4ZjhjNGFmMjg2YTY5NDMyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBteUxvY2sgPSBuZXcgU2hhcmVkTG9jaygnc29tZS1rZXknKTtcbiAqIG15TG9jay53aXRoTG9jayhmdW5jdGlvbigpIHtcbiAqICAgY29uc29sZS5sb2coJ0kgaG9sZCB0aGUgbXV0ZXghJyk7XG4gKiB9KTtcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFNoYXJlZExvY2sgPSBmdW5jdGlvbihrZXksIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMuc3RvcmFnZUtleSA9IGtleTtcbiAgICB0aGlzLnN0b3JhZ2UgPSBvcHRpb25zLnN0b3JhZ2UgfHwgd2luLmxvY2FsU3RvcmFnZTtcbiAgICB0aGlzLnBvbGxJbnRlcnZhbE1TID0gb3B0aW9ucy5wb2xsSW50ZXJ2YWxNUyB8fCAxMDA7XG4gICAgdGhpcy50aW1lb3V0TVMgPSBvcHRpb25zLnRpbWVvdXRNUyB8fCAyMDAwO1xuXG4gICAgLy8gZGVwZW5kZW5jeS1pbmplY3QgcHJvbWlzZSBpbXBsZW1lbnRhdGlvbiBmb3IgdGVzdGluZyBwdXJwb3Nlc1xuICAgIHRoaXMucHJvbWlzZUltcGwgPSBvcHRpb25zLnByb21pc2VJbXBsIHx8IFByb21pc2VQb2x5ZmlsbDtcbn07XG5cbi8vIHBhc3MgaW4gYSBzcGVjaWZpYyBwaWQgdG8gdGVzdCBjb250ZW50aW9uIHNjZW5hcmlvczsgb3RoZXJ3aXNlXG4vLyBpdCBpcyBjaG9zZW4gcmFuZG9tbHkgZm9yIGVhY2ggYWNxdWlzaXRpb24gYXR0ZW1wdFxuU2hhcmVkTG9jay5wcm90b3R5cGUud2l0aExvY2sgPSBmdW5jdGlvbihsb2NrZWRDQiwgcGlkKSB7XG4gICAgdmFyIFByb21pc2UgPSB0aGlzLnByb21pc2VJbXBsO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShfLmJpbmQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgaSA9IHBpZCB8fCAobmV3IERhdGUoKS5nZXRUaW1lKCkgKyAnfCcgKyBNYXRoLnJhbmRvbSgpKTtcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5zdG9yYWdlS2V5O1xuICAgICAgICB2YXIgcG9sbEludGVydmFsTVMgPSB0aGlzLnBvbGxJbnRlcnZhbE1TO1xuICAgICAgICB2YXIgdGltZW91dE1TID0gdGhpcy50aW1lb3V0TVM7XG4gICAgICAgIHZhciBzdG9yYWdlID0gdGhpcy5zdG9yYWdlO1xuXG4gICAgICAgIHZhciBrZXlYID0ga2V5ICsgJzpYJztcbiAgICAgICAgdmFyIGtleVkgPSBrZXkgKyAnOlknO1xuICAgICAgICB2YXIga2V5WiA9IGtleSArICc6Wic7XG5cbiAgICAgICAgdmFyIGRlbGF5ID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgICAgIGlmIChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0VGltZSA+IHRpbWVvdXRNUykge1xuICAgICAgICAgICAgICAgIGxvZ2dlciQ2LmVycm9yKCdUaW1lb3V0IHdhaXRpbmcgZm9yIG11dGV4IG9uICcgKyBrZXkgKyAnOyBjbGVhcmluZyBsb2NrLiBbJyArIGkgKyAnXScpO1xuICAgICAgICAgICAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShrZXlaKTtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5WSk7XG4gICAgICAgICAgICAgICAgbG9vcCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBwb2xsSW50ZXJ2YWxNUyAqIChNYXRoLnJhbmRvbSgpICsgMC4xKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHdhaXRGb3IgPSBmdW5jdGlvbihwcmVkaWNhdGUsIGNiKSB7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKCkpIHtcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxheShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FpdEZvcihwcmVkaWNhdGUsIGNiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZ2V0U2V0WSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHZhbFkgPSBzdG9yYWdlLmdldEl0ZW0oa2V5WSk7XG4gICAgICAgICAgICBpZiAodmFsWSAmJiB2YWxZICE9PSBpKSB7IC8vIGlmIFkgPT0gaSB0aGVuIHRoaXMgcHJvY2VzcyBhbHJlYWR5IGhhcyB0aGUgbG9jayAodXNlZnVsIGZvciB0ZXN0IGNhc2VzKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RvcmFnZS5zZXRJdGVtKGtleVksIGkpO1xuICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlLmdldEl0ZW0oa2V5WSkgPT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2NhbFN0b3JhZ2VTdXBwb3J0ZWQoc3RvcmFnZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2xvY2FsU3RvcmFnZSBzdXBwb3J0IGRyb3BwZWQgd2hpbGUgYWNxdWlyaW5nIGxvY2snKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc3RvcmFnZS5zZXRJdGVtKGtleVgsIGkpO1xuXG4gICAgICAgICAgICB3YWl0Rm9yKGdldFNldFksIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlLmdldEl0ZW0oa2V5WCkgPT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3JpdGljYWxTZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkZWxheShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2UuZ2V0SXRlbShrZXlZKSAhPT0gaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9vcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdhaXRGb3IoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXN0b3JhZ2UuZ2V0SXRlbShrZXlaKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgY3JpdGljYWxTZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjcml0aWNhbFNlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0SXRlbShrZXlaLCAnMScpO1xuICAgICAgICAgICAgdmFyIHJlbW92ZUxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKGtleVopO1xuICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlLmdldEl0ZW0oa2V5WSkgPT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKGtleVkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZS5nZXRJdGVtKGtleVgpID09PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShrZXlYKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBsb2NrZWRDQigpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJldCkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVMb2NrKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmV0KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUxvY2soKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChsb2NhbFN0b3JhZ2VTdXBwb3J0ZWQoc3RvcmFnZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICBsb29wKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbG9jYWxTdG9yYWdlIHN1cHBvcnQgY2hlY2sgZmFpbGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgIH0sIHRoaXMpKTtcbn07XG5cbi8qKlxuICogQHR5cGUge2ltcG9ydCgnLi93cmFwcGVyJykuU3RvcmFnZVdyYXBwZXJ9XG4gKi9cbnZhciBMb2NhbFN0b3JhZ2VXcmFwcGVyID0gZnVuY3Rpb24gKHN0b3JhZ2VPdmVycmlkZSkge1xuICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2VPdmVycmlkZSB8fCB3aW4ubG9jYWxTdG9yYWdlO1xufTtcblxuTG9jYWxTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTtcbn07XG5cbkxvY2FsU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLmlzSW5pdGlhbGl6ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5Mb2NhbFN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5zZXRJdGVtID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChfLmJpbmQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OU3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCk7XG4gICAgfSwgdGhpcykpO1xufTtcblxuTG9jYWxTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuZ2V0SXRlbSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChfLmJpbmQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgaXRlbTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGl0ZW0gPSBKU09OUGFyc2UodGhpcy5zdG9yYWdlLmdldEl0ZW0oa2V5KSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKGl0ZW0pO1xuICAgIH0sIHRoaXMpKTtcbn07XG5cbkxvY2FsU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLnJlbW92ZUl0ZW0gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoXy5iaW5kKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCk7XG4gICAgfSwgdGhpcykpO1xufTtcblxudmFyIGxvZ2dlciQ1ID0gY29uc29sZV93aXRoX3ByZWZpeCgnYmF0Y2gnKTtcblxuLyoqXG4gKiBSZXF1ZXN0UXVldWU6IHF1ZXVlIGZvciBiYXRjaGluZyBBUEkgcmVxdWVzdHMgd2l0aCBsb2NhbFN0b3JhZ2UgYmFja3VwIGZvciByZXRyaWVzLlxuICogTWFpbnRhaW5zIGFuIGluLW1lbW9yeSBxdWV1ZSB3aGljaCByZXByZXNlbnRzIHRoZSBzb3VyY2Ugb2YgdHJ1dGggZm9yIHRoZSBjdXJyZW50XG4gKiBwYWdlLCBidXQgYWxzbyB3cml0ZXMgYWxsIGl0ZW1zIG91dCB0byBhIGNvcHkgaW4gdGhlIGJyb3dzZXIncyBsb2NhbFN0b3JhZ2UsIHdoaWNoXG4gKiBjYW4gYmUgcmVhZCBvbiBzdWJzZXF1ZW50IHBhZ2Vsb2FkcyBhbmQgcmV0cmllZC4gRm9yIGJhdGNoYWJpbGl0eSwgYWxsIHRoZSByZXF1ZXN0XG4gKiBpdGVtcyBpbiB0aGUgcXVldWUgc2hvdWxkIGJlIG9mIHRoZSBzYW1lIHR5cGUgKGV2ZW50cywgcGVvcGxlIHVwZGF0ZXMsIGdyb3VwIHVwZGF0ZXMpXG4gKiBzbyB0aGV5IGNhbiBiZSBzZW50IGluIGEgc2luZ2xlIHJlcXVlc3QgdG8gdGhlIHNhbWUgQVBJIGVuZHBvaW50LlxuICpcbiAqIExvY2FsU3RvcmFnZSBrZXlpbmcgYW5kIGxvY2tpbmc6IEluIG9yZGVyIGZvciByZWxvYWRzIGFuZCBzdWJzZXF1ZW50IHBhZ2Vsb2FkcyBvZlxuICogdGhlIHNhbWUgc2l0ZSB0byBhY2Nlc3MgdGhlIHNhbWUgcGVyc2lzdGVkIGRhdGEsIHRoZXkgbXVzdCBzaGFyZSB0aGUgc2FtZSBsb2NhbFN0b3JhZ2VcbiAqIGtleSAoZm9yIGluc3RhbmNlIGJhc2VkIG9uIHByb2plY3QgdG9rZW4gYW5kIHF1ZXVlIHR5cGUpLiBUaGVyZWZvcmUgYWNjZXNzIHRvIHRoZVxuICogbG9jYWxTdG9yYWdlIGVudHJ5IGlzIGd1YXJkZWQgYnkgYW4gYXN5bmNocm9ub3VzIG11dGV4IChTaGFyZWRMb2NrKSB0byBwcmV2ZW50XG4gKiBzaW11bHRhbmVvdXNseSBvcGVuIHdpbmRvd3MvdGFicyBmcm9tIG92ZXJ3cml0aW5nIGVhY2ggb3RoZXIncyBkYXRhICh3aGljaCB3b3VsZCBsZWFkXG4gKiB0byBkYXRhIGxvc3MgaW4gc29tZSBzaXR1YXRpb25zKS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgUmVxdWVzdFF1ZXVlID0gZnVuY3Rpb24gKHN0b3JhZ2VLZXksIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLnN0b3JhZ2VLZXkgPSBzdG9yYWdlS2V5O1xuICAgIHRoaXMudXNlUGVyc2lzdGVuY2UgPSBvcHRpb25zLnVzZVBlcnNpc3RlbmNlO1xuICAgIGlmICh0aGlzLnVzZVBlcnNpc3RlbmNlKSB7XG4gICAgICAgIHRoaXMucXVldWVTdG9yYWdlID0gb3B0aW9ucy5xdWV1ZVN0b3JhZ2UgfHwgbmV3IExvY2FsU3RvcmFnZVdyYXBwZXIoKTtcbiAgICAgICAgdGhpcy5sb2NrID0gbmV3IFNoYXJlZExvY2soc3RvcmFnZUtleSwge1xuICAgICAgICAgICAgc3RvcmFnZTogb3B0aW9ucy5zaGFyZWRMb2NrU3RvcmFnZSB8fCB3aW4ubG9jYWxTdG9yYWdlLFxuICAgICAgICAgICAgdGltZW91dE1TOiBvcHRpb25zLnNoYXJlZExvY2tUaW1lb3V0TVMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnJlcG9ydEVycm9yID0gb3B0aW9ucy5lcnJvclJlcG9ydGVyIHx8IF8uYmluZChsb2dnZXIkNS5lcnJvciwgbG9nZ2VyJDUpO1xuXG4gICAgdGhpcy5waWQgPSBvcHRpb25zLnBpZCB8fCBudWxsOyAvLyBwYXNzIHBpZCB0byB0ZXN0IG91dCBzdG9yYWdlIGxvY2sgY29udGVudGlvbiBzY2VuYXJpb3NcblxuICAgIHRoaXMubWVtUXVldWUgPSBbXTtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgICBpZiAob3B0aW9ucy5lbnF1ZXVlVGhyb3R0bGVNcykge1xuICAgICAgICB0aGlzLmVucXVldWVQZXJzaXN0ZWQgPSBiYXRjaGVkVGhyb3R0bGUoXy5iaW5kKHRoaXMuX2VucXVldWVQZXJzaXN0ZWQsIHRoaXMpLCBvcHRpb25zLmVucXVldWVUaHJvdHRsZU1zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVucXVldWVQZXJzaXN0ZWQgPSBfLmJpbmQoZnVuY3Rpb24gKHF1ZXVlRW50cnkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbnF1ZXVlUGVyc2lzdGVkKFtxdWV1ZUVudHJ5XSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbn07XG5cblJlcXVlc3RRdWV1ZS5wcm90b3R5cGUuZW5zdXJlSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pbml0aWFsaXplZCB8fCAhdGhpcy51c2VQZXJzaXN0ZW5jZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5xdWV1ZVN0b3JhZ2VcbiAgICAgICAgLmluaXQoKVxuICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAuY2F0Y2goXy5iaW5kKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIGluaXRpYWxpemluZyBxdWV1ZSBwZXJzaXN0ZW5jZS4gRGlzYWJsaW5nIHBlcnNpc3RlbmNlJywgZXJyKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy51c2VQZXJzaXN0ZW5jZSA9IGZhbHNlO1xuICAgICAgICB9LCB0aGlzKSk7XG59O1xuXG4vKipcbiAqIEFkZCBvbmUgaXRlbSB0byBxdWV1ZXMgKG1lbW9yeSBhbmQgbG9jYWxTdG9yYWdlKS4gVGhlIHF1ZXVlZCBlbnRyeSBpbmNsdWRlc1xuICogdGhlIGdpdmVuIGl0ZW0gYWxvbmcgd2l0aCBhbiBhdXRvLWdlbmVyYXRlZCBJRCBhbmQgYSBcImZsdXNoLWFmdGVyXCIgdGltZXN0YW1wLlxuICogSXQgaXMgZXhwZWN0ZWQgdGhhdCB0aGUgaXRlbSB3aWxsIGJlIHNlbnQgb3ZlciB0aGUgbmV0d29yayBhbmQgZGVxdWV1ZWRcbiAqIGJlZm9yZSB0aGUgZmx1c2gtYWZ0ZXIgdGltZTsgaWYgdGhpcyBkb2Vzbid0IGhhcHBlbiBpdCBpcyBjb25zaWRlcmVkIG9ycGhhbmVkXG4gKiAoZS5nLiwgdGhlIG9yaWdpbmFsIHRhYiB3aGVyZSBpdCB3YXMgZW5xdWV1ZWQgZ290IGNsb3NlZCBiZWZvcmUgaXQgY291bGQgYmVcbiAqIHNlbnQpIGFuZCB0aGUgaXRlbSBjYW4gYmUgc2VudCBieSBhbnkgdGFiIHRoYXQgZmluZHMgaXQgaW4gbG9jYWxTdG9yYWdlLlxuICpcbiAqIFRoZSBmaW5hbCBjYWxsYmFjayBwYXJhbSBpcyBjYWxsZWQgd2l0aCBhIHBhcmFtIGluZGljYXRpbmcgc3VjY2VzcyBvclxuICogZmFpbHVyZSBvZiB0aGUgZW5xdWV1ZSBvcGVyYXRpb247IGl0IGlzIGFzeW5jaHJvbm91cyBiZWNhdXNlIHRoZSBsb2NhbFN0b3JhZ2VcbiAqIGxvY2sgaXMgYXN5bmNocm9ub3VzLlxuICovXG5SZXF1ZXN0UXVldWUucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbiAoaXRlbSwgZmx1c2hJbnRlcnZhbCkge1xuICAgIHZhciBxdWV1ZUVudHJ5ID0ge1xuICAgICAgICAnaWQnOiBjaGVhcF9ndWlkKCksXG4gICAgICAgICdmbHVzaEFmdGVyJzogbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBmbHVzaEludGVydmFsICogMixcbiAgICAgICAgJ3BheWxvYWQnOiBpdGVtXG4gICAgfTtcblxuICAgIGlmICghdGhpcy51c2VQZXJzaXN0ZW5jZSkge1xuICAgICAgICB0aGlzLm1lbVF1ZXVlLnB1c2gocXVldWVFbnRyeSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSh0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnF1ZXVlUGVyc2lzdGVkKHF1ZXVlRW50cnkpO1xuICAgIH1cbn07XG5cblJlcXVlc3RRdWV1ZS5wcm90b3R5cGUuX2VucXVldWVQZXJzaXN0ZWQgPSBmdW5jdGlvbiAocXVldWVFbnRyaWVzKSB7XG4gICAgdmFyIGVucXVldWVJdGVtID0gXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlSW5pdCgpXG4gICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRGcm9tU3RvcmFnZSgpO1xuICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKHN0b3JlZFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2F2ZVRvU3RvcmFnZShzdG9yZWRRdWV1ZS5jb25jYXQocXVldWVFbnRyaWVzKSk7XG4gICAgICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoc3VjY2VlZGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSBhZGQgdG8gaW4tbWVtb3J5IHF1ZXVlIHdoZW4gc3RvcmFnZSBzdWNjZWVkc1xuICAgICAgICAgICAgICAgIGlmIChzdWNjZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZW1RdWV1ZSA9IHRoaXMubWVtUXVldWUuY29uY2F0KHF1ZXVlRW50cmllcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2NlZWRlZDtcbiAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgZW5xdWV1ZWluZyBpdGVtcycsIGVyciwgcXVldWVFbnRyaWVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICByZXR1cm4gdGhpcy5sb2NrXG4gICAgICAgIC53aXRoTG9jayhlbnF1ZXVlSXRlbSwgdGhpcy5waWQpXG4gICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgYWNxdWlyaW5nIHN0b3JhZ2UgbG9jaycsIGVycik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sIHRoaXMpKTtcbn07XG5cbi8qKlxuICogUmVhZCBvdXQgdGhlIGdpdmVuIG51bWJlciBvZiBxdWV1ZSBlbnRyaWVzLiBJZiB0aGlzLm1lbVF1ZXVlXG4gKiBoYXMgZmV3ZXIgdGhhbiBiYXRjaFNpemUgaXRlbXMsIHRoZW4gbG9vayBmb3IgXCJvcnBoYW5lZFwiIGl0ZW1zXG4gKiBpbiB0aGUgcGVyc2lzdGVkIHF1ZXVlIChpdGVtcyB3aGVyZSB0aGUgJ2ZsdXNoQWZ0ZXInIHRpbWUgaGFzXG4gKiBhbHJlYWR5IHBhc3NlZCkuXG4gKi9cblJlcXVlc3RRdWV1ZS5wcm90b3R5cGUuZmlsbEJhdGNoID0gZnVuY3Rpb24gKGJhdGNoU2l6ZSkge1xuICAgIHZhciBiYXRjaCA9IHRoaXMubWVtUXVldWUuc2xpY2UoMCwgYmF0Y2hTaXplKTtcbiAgICBpZiAodGhpcy51c2VQZXJzaXN0ZW5jZSAmJiBiYXRjaC5sZW5ndGggPCBiYXRjaFNpemUpIHtcbiAgICAgICAgLy8gZG9uJ3QgbmVlZCBsb2NrIGp1c3QgdG8gcmVhZCBldmVudHM7IGxvY2FsU3RvcmFnZSBpcyB0aHJlYWQtc2FmZVxuICAgICAgICAvLyBhbmQgdGhlIHdvcnN0IHRoYXQgY291bGQgaGFwcGVuIGlzIGEgZHVwbGljYXRlIHNlbmQgb2Ygc29tZVxuICAgICAgICAvLyBvcnBoYW5lZCBldmVudHMsIHdoaWNoIHdpbGwgYmUgZGVkdXBsaWNhdGVkIG9uIHRoZSBzZXJ2ZXIgc2lkZVxuICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVJbml0KClcbiAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZEZyb21TdG9yYWdlKCk7XG4gICAgICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoc3RvcmVkUXVldWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmVkUXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGl0ZW0gSURzIGFscmVhZHkgaW4gYmF0Y2g7IGRvbid0IGR1cGxpY2F0ZSBvdXQgb2Ygc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgICB2YXIgaWRzSW5CYXRjaCA9IHt9OyAvLyBwb29yIG1hbidzIFNldFxuICAgICAgICAgICAgICAgICAgICBfLmVhY2goYmF0Y2gsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHNJbkJhdGNoW2l0ZW1bJ2lkJ11dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdG9yZWRRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBzdG9yZWRRdWV1ZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXcgRGF0ZSgpLmdldFRpbWUoKSA+IGl0ZW1bJ2ZsdXNoQWZ0ZXInXSAmJiAhaWRzSW5CYXRjaFtpdGVtWydpZCddXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ub3JwaGFuZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhdGNoLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJhdGNoLmxlbmd0aCA+PSBiYXRjaFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhdGNoO1xuICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZShiYXRjaCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgaXRlbXMgd2l0aCBtYXRjaGluZyAnaWQnIGZyb20gYXJyYXkgKGltbXV0YWJseSlcbiAqIGFsc28gcmVtb3ZlIGFueSBpdGVtIHdpdGhvdXQgYSB2YWxpZCBpZCAoZS5nLiwgbWFsZm9ybWVkXG4gKiBzdG9yYWdlIGVudHJpZXMpLlxuICovXG52YXIgZmlsdGVyT3V0SURzQW5kSW52YWxpZCA9IGZ1bmN0aW9uIChpdGVtcywgaWRTZXQpIHtcbiAgICB2YXIgZmlsdGVyZWRJdGVtcyA9IFtdO1xuICAgIF8uZWFjaChpdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW1bJ2lkJ10gJiYgIWlkU2V0W2l0ZW1bJ2lkJ11dKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZEl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZmlsdGVyZWRJdGVtcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGl0ZW1zIHdpdGggbWF0Y2hpbmcgSURzIGZyb20gYm90aCBpbi1tZW1vcnkgcXVldWVcbiAqIGFuZCBwZXJzaXN0ZWQgcXVldWVcbiAqL1xuUmVxdWVzdFF1ZXVlLnByb3RvdHlwZS5yZW1vdmVJdGVtc0J5SUQgPSBmdW5jdGlvbiAoaWRzKSB7XG4gICAgdmFyIGlkU2V0ID0ge307IC8vIHBvb3IgbWFuJ3MgU2V0XG4gICAgXy5lYWNoKGlkcywgZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlkU2V0W2lkXSA9IHRydWU7XG4gICAgfSk7XG5cbiAgICB0aGlzLm1lbVF1ZXVlID0gZmlsdGVyT3V0SURzQW5kSW52YWxpZCh0aGlzLm1lbVF1ZXVlLCBpZFNldCk7XG4gICAgaWYgKCF0aGlzLnVzZVBlcnNpc3RlbmNlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSh0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVtb3ZlRnJvbVN0b3JhZ2UgPSBfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlSW5pdCgpXG4gICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZEZyb21TdG9yYWdlKCk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uIChzdG9yZWRRdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZWRRdWV1ZSA9IGZpbHRlck91dElEc0FuZEludmFsaWQoc3RvcmVkUXVldWUsIGlkU2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2F2ZVRvU3RvcmFnZShzdG9yZWRRdWV1ZSk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZEZyb21TdG9yYWdlKCk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uIChzdG9yZWRRdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhbiBleHRyYSBjaGVjazogZGlkIHN0b3JhZ2UgcmVwb3J0IHN1Y2Nlc3MgYnV0IHNvbWVob3dcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGl0ZW1zIGFyZSBzdGlsbCB0aGVyZT9cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdG9yZWRRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBzdG9yZWRRdWV1ZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtWydpZCddICYmICEhaWRTZXRbaXRlbVsnaWQnXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0l0ZW0gbm90IHJlbW92ZWQgZnJvbSBzdG9yYWdlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIHJlbW92aW5nIGl0ZW1zJywgZXJyLCBpZHMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5sb2NrXG4gICAgICAgICAgICAud2l0aExvY2socmVtb3ZlRnJvbVN0b3JhZ2UsIHRoaXMucGlkKVxuICAgICAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgYWNxdWlyaW5nIHN0b3JhZ2UgbG9jaycsIGVycik7XG4gICAgICAgICAgICAgICAgaWYgKCFsb2NhbFN0b3JhZ2VTdXBwb3J0ZWQodGhpcy5sb2NrLnN0b3JhZ2UsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExvb2tzIGxpa2UgbG9jYWxTdG9yYWdlIHdyaXRlcyBoYXZlIHN0b3BwZWQgd29ya2luZyBzb21ldGltZSBhZnRlclxuICAgICAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXphdGlvbiAocHJvYmFibHkgZnVsbCksIGFuZCBzbyBub2JvZHkgY2FuIGFjcXVpcmUgbG9ja3NcbiAgICAgICAgICAgICAgICAgICAgLy8gYW55bW9yZS4gQ29uc2lkZXIgaXQgdGVtcG9yYXJpbHkgc2FmZSB0byByZW1vdmUgaXRlbXMgd2l0aG91dCB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9jaywgc2luY2Ugbm9ib2R5J3Mgd3JpdGluZyBzdWNjZXNzZnVsbHkgYW55d2F5LlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlRnJvbVN0b3JhZ2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9LLCB3ZSBjb3VsZG4ndCBldmVuIHdyaXRlIG91dCB0aGUgc21hbGxlciBxdWV1ZS4gVHJ5IGNsZWFyaW5nIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZVN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLnN0b3JhZ2VLZXkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2VzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgY2xlYXJpbmcgcXVldWUnLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgIH1cbn07XG5cbi8vIGludGVybmFsIGhlbHBlciBmb3IgUmVxdWVzdFF1ZXVlLnVwZGF0ZVBheWxvYWRzXG52YXIgdXBkYXRlUGF5bG9hZHMgPSBmdW5jdGlvbiAoZXhpc3RpbmdJdGVtcywgaXRlbXNUb1VwZGF0ZSkge1xuICAgIHZhciBuZXdJdGVtcyA9IFtdO1xuICAgIF8uZWFjaChleGlzdGluZ0l0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgaWQgPSBpdGVtWydpZCddO1xuICAgICAgICBpZiAoaWQgaW4gaXRlbXNUb1VwZGF0ZSkge1xuICAgICAgICAgICAgdmFyIG5ld1BheWxvYWQgPSBpdGVtc1RvVXBkYXRlW2lkXTtcbiAgICAgICAgICAgIGlmIChuZXdQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlbVsncGF5bG9hZCddID0gbmV3UGF5bG9hZDtcbiAgICAgICAgICAgICAgICBuZXdJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbm8gdXBkYXRlXG4gICAgICAgICAgICBuZXdJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld0l0ZW1zO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgcGF5bG9hZHMgb2YgZ2l2ZW4gaXRlbXMgaW4gYm90aCBpbi1tZW1vcnkgcXVldWUgYW5kXG4gKiBwZXJzaXN0ZWQgcXVldWUuIEl0ZW1zIHNldCB0byBudWxsIGFyZSByZW1vdmVkIGZyb20gcXVldWVzLlxuICovXG5SZXF1ZXN0UXVldWUucHJvdG90eXBlLnVwZGF0ZVBheWxvYWRzID0gZnVuY3Rpb24gKGl0ZW1zVG9VcGRhdGUpIHtcbiAgICB0aGlzLm1lbVF1ZXVlID0gdXBkYXRlUGF5bG9hZHModGhpcy5tZW1RdWV1ZSwgaXRlbXNUb1VwZGF0ZSk7XG4gICAgaWYgKCF0aGlzLnVzZVBlcnNpc3RlbmNlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSh0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NrXG4gICAgICAgICAgICAud2l0aExvY2soXy5iaW5kKGZ1bmN0aW9uIGxvY2tBY3F1aXJlZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVJbml0KClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRGcm9tU3RvcmFnZSgpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uIChzdG9yZWRRdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVkUXVldWUgPSB1cGRhdGVQYXlsb2FkcyhzdG9yZWRRdWV1ZSwgaXRlbXNUb1VwZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zYXZlVG9TdG9yYWdlKHN0b3JlZFF1ZXVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgdXBkYXRpbmcgaXRlbXMnLCBpdGVtc1RvVXBkYXRlLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgICAgICB9LCB0aGlzKSwgdGhpcy5waWQpXG4gICAgICAgICAgICAuY2F0Y2goXy5iaW5kKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciBhY3F1aXJpbmcgc3RvcmFnZSBsb2NrJywgZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZWFkIGFuZCBwYXJzZSBpdGVtcyBhcnJheSBmcm9tIGxvY2FsU3RvcmFnZSBlbnRyeSwgaGFuZGxpbmdcbiAqIG1hbGZvcm1lZC9taXNzaW5nIGRhdGEgaWYgbmVjZXNzYXJ5LlxuICovXG5SZXF1ZXN0UXVldWUucHJvdG90eXBlLnJlYWRGcm9tU3RvcmFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnN1cmVJbml0KClcbiAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlU3RvcmFnZS5nZXRJdGVtKHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKHN0b3JhZ2VFbnRyeSkge1xuICAgICAgICAgICAgaWYgKHN0b3JhZ2VFbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghXy5pc0FycmF5KHN0b3JhZ2VFbnRyeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignSW52YWxpZCBzdG9yYWdlIGVudHJ5OicsIHN0b3JhZ2VFbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2VFbnRyeSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0b3JhZ2VFbnRyeSB8fCBbXTtcbiAgICAgICAgfSwgdGhpcykpXG4gICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgcmV0cmlldmluZyBxdWV1ZScsIGVycik7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0sIHRoaXMpKTtcbn07XG5cbi8qKlxuICogU2VyaWFsaXplIHRoZSBnaXZlbiBpdGVtcyBhcnJheSB0byBsb2NhbFN0b3JhZ2UuXG4gKi9cblJlcXVlc3RRdWV1ZS5wcm90b3R5cGUuc2F2ZVRvU3RvcmFnZSA9IGZ1bmN0aW9uIChxdWV1ZSkge1xuICAgIHJldHVybiB0aGlzLmVuc3VyZUluaXQoKVxuICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWVTdG9yYWdlLnNldEl0ZW0odGhpcy5zdG9yYWdlS2V5LCBxdWV1ZSk7XG4gICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciBzYXZpbmcgcXVldWUnLCBlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LCB0aGlzKSk7XG59O1xuXG4vKipcbiAqIENsZWFyIG91dCBxdWV1ZXMgKG1lbW9yeSBhbmQgbG9jYWxTdG9yYWdlKS5cbiAqL1xuUmVxdWVzdFF1ZXVlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm1lbVF1ZXVlID0gW107XG5cbiAgICBpZiAodGhpcy51c2VQZXJzaXN0ZW5jZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVJbml0KClcbiAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWVTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTtcbiAgICB9XG59O1xuXG4vLyBtYXhpbXVtIGludGVydmFsIGJldHdlZW4gcmVxdWVzdCByZXRyaWVzIGFmdGVyIGV4cG9uZW50aWFsIGJhY2tvZmZcbnZhciBNQVhfUkVUUllfSU5URVJWQUxfTVMgPSAxMCAqIDYwICogMTAwMDsgLy8gMTAgbWludXRlc1xuXG52YXIgbG9nZ2VyJDQgPSBjb25zb2xlX3dpdGhfcHJlZml4KCdiYXRjaCcpO1xuXG4vKipcbiAqIFJlcXVlc3RCYXRjaGVyOiBtYW5hZ2VzIHRoZSBxdWV1ZWluZywgZmx1c2hpbmcsIHJldHJ5IGV0YyBvZiByZXF1ZXN0cyBvZiBvbmVcbiAqIHR5cGUgKGV2ZW50cywgcGVvcGxlLCBncm91cHMpLlxuICogVXNlcyBSZXF1ZXN0UXVldWUgdG8gbWFuYWdlIHRoZSBiYWNraW5nIHN0b3JlLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBSZXF1ZXN0QmF0Y2hlciA9IGZ1bmN0aW9uKHN0b3JhZ2VLZXksIG9wdGlvbnMpIHtcbiAgICB0aGlzLmVycm9yUmVwb3J0ZXIgPSBvcHRpb25zLmVycm9yUmVwb3J0ZXI7XG4gICAgdGhpcy5xdWV1ZSA9IG5ldyBSZXF1ZXN0UXVldWUoc3RvcmFnZUtleSwge1xuICAgICAgICBlcnJvclJlcG9ydGVyOiBfLmJpbmQodGhpcy5yZXBvcnRFcnJvciwgdGhpcyksXG4gICAgICAgIHF1ZXVlU3RvcmFnZTogb3B0aW9ucy5xdWV1ZVN0b3JhZ2UsXG4gICAgICAgIHNoYXJlZExvY2tTdG9yYWdlOiBvcHRpb25zLnNoYXJlZExvY2tTdG9yYWdlLFxuICAgICAgICBzaGFyZWRMb2NrVGltZW91dE1TOiBvcHRpb25zLnNoYXJlZExvY2tUaW1lb3V0TVMsXG4gICAgICAgIHVzZVBlcnNpc3RlbmNlOiBvcHRpb25zLnVzZVBlcnNpc3RlbmNlLFxuICAgICAgICBlbnF1ZXVlVGhyb3R0bGVNczogb3B0aW9ucy5lbnF1ZXVlVGhyb3R0bGVNc1xuICAgIH0pO1xuXG4gICAgdGhpcy5saWJDb25maWcgPSBvcHRpb25zLmxpYkNvbmZpZztcbiAgICB0aGlzLnNlbmRSZXF1ZXN0ID0gb3B0aW9ucy5zZW5kUmVxdWVzdEZ1bmM7XG4gICAgdGhpcy5iZWZvcmVTZW5kSG9vayA9IG9wdGlvbnMuYmVmb3JlU2VuZEhvb2s7XG4gICAgdGhpcy5zdG9wQWxsQmF0Y2hpbmcgPSBvcHRpb25zLnN0b3BBbGxCYXRjaGluZ0Z1bmM7XG5cbiAgICAvLyBzZWVkIHZhcmlhYmxlIGJhdGNoIHNpemUgKyBmbHVzaCBpbnRlcnZhbCB3aXRoIGNvbmZpZ3VyZWQgdmFsdWVzXG4gICAgdGhpcy5iYXRjaFNpemUgPSB0aGlzLmxpYkNvbmZpZ1snYmF0Y2hfc2l6ZSddO1xuICAgIHRoaXMuZmx1c2hJbnRlcnZhbCA9IHRoaXMubGliQ29uZmlnWydiYXRjaF9mbHVzaF9pbnRlcnZhbF9tcyddO1xuXG4gICAgdGhpcy5zdG9wcGVkID0gIXRoaXMubGliQ29uZmlnWydiYXRjaF9hdXRvc3RhcnQnXTtcbiAgICB0aGlzLmNvbnNlY3V0aXZlUmVtb3ZhbEZhaWx1cmVzID0gMDtcblxuICAgIC8vIGV4dHJhIGNsaWVudC1zaWRlIGRlZHVwZVxuICAgIHRoaXMuaXRlbUlkc1NlbnRTdWNjZXNzZnVsbHkgPSB7fTtcblxuICAgIC8vIE1ha2UgdGhlIGZsdXNoIG9jY3VyIGF0IHRoZSBpbnRlcnZhbCBzcGVjaWZpZWQgYnkgZmx1c2hJbnRlcnZhbE1zLCBkZWZhdWx0IGJlaGF2aW9yIHdpbGwgYXR0ZW1wdCBjb25zZWN1dGl2ZSBmbHVzaGVzXG4gICAgLy8gYXMgbG9uZyBhcyB0aGUgcXVldWUgaXMgbm90IGVtcHR5LiBUaGlzIGlzIHVzZWZ1bCBmb3IgaGlnaC1mcmVxdWVuY3kgZXZlbnRzIGxpa2UgU2Vzc2lvbiBSZXBsYXkgd2hlcmUgd2UgbWlnaHQgZW5kIHVwXG4gICAgLy8gaW4gYSByZXF1ZXN0IGxvb3AgYW5kIGdldCByYXRlbGltaXRlZCBieSB0aGUgc2VydmVyLlxuICAgIHRoaXMuZmx1c2hPbmx5T25JbnRlcnZhbCA9IG9wdGlvbnMuZmx1c2hPbmx5T25JbnRlcnZhbCB8fCBmYWxzZTtcblxuICAgIHRoaXMuX2ZsdXNoUHJvbWlzZSA9IG51bGw7XG59O1xuXG4vKipcbiAqIEFkZCBvbmUgaXRlbSB0byBxdWV1ZS5cbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIHRoaXMucXVldWUuZW5xdWV1ZShpdGVtLCB0aGlzLmZsdXNoSW50ZXJ2YWwpO1xufTtcblxuLyoqXG4gKiBTdGFydCBmbHVzaGluZyBiYXRjaGVzIGF0IHRoZSBjb25maWd1cmVkIHRpbWUgaW50ZXJ2YWwuIE11c3QgY2FsbFxuICogdGhpcyBtZXRob2QgdXBvbiBTREsgaW5pdCBpbiBvcmRlciB0byBzZW5kIGFueXRoaW5nIG92ZXIgdGhlIG5ldHdvcmsuXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3RvcHBlZCA9IGZhbHNlO1xuICAgIHRoaXMuY29uc2VjdXRpdmVSZW1vdmFsRmFpbHVyZXMgPSAwO1xuICAgIHJldHVybiB0aGlzLmZsdXNoKCk7XG59O1xuXG4vKipcbiAqIFN0b3AgZmx1c2hpbmcgYmF0Y2hlcy4gQ2FuIGJlIHJlc3RhcnRlZCBieSBjYWxsaW5nIHN0YXJ0KCkuXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy50aW1lb3V0SUQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElEKTtcbiAgICAgICAgdGhpcy50aW1lb3V0SUQgPSBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ2xlYXIgb3V0IHF1ZXVlLlxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZS5jbGVhcigpO1xufTtcblxuLyoqXG4gKiBSZXN0b3JlIGJhdGNoIHNpemUgY29uZmlndXJhdGlvbiB0byB3aGF0ZXZlciBpcyBzZXQgaW4gdGhlIG1haW4gU0RLLlxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUucmVzZXRCYXRjaFNpemUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmJhdGNoU2l6ZSA9IHRoaXMubGliQ29uZmlnWydiYXRjaF9zaXplJ107XG59O1xuXG4vKipcbiAqIFJlc3RvcmUgZmx1c2ggaW50ZXJ2YWwgdGltZSBjb25maWd1cmF0aW9uIHRvIHdoYXRldmVyIGlzIHNldCBpbiB0aGUgbWFpbiBTREsuXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5yZXNldEZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zY2hlZHVsZUZsdXNoKHRoaXMubGliQ29uZmlnWydiYXRjaF9mbHVzaF9pbnRlcnZhbF9tcyddKTtcbn07XG5cbi8qKlxuICogU2NoZWR1bGUgdGhlIG5leHQgZmx1c2ggaW4gdGhlIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMuXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5zY2hlZHVsZUZsdXNoID0gZnVuY3Rpb24oZmx1c2hNUykge1xuICAgIHRoaXMuZmx1c2hJbnRlcnZhbCA9IGZsdXNoTVM7XG4gICAgaWYgKCF0aGlzLnN0b3BwZWQpIHsgLy8gZG9uJ3Qgc2NoZWR1bGUgYW55bW9yZSBpZiBiYXRjaGluZyBoYXMgYmVlbiBzdG9wcGVkXG4gICAgICAgIHRoaXMudGltZW91dElEID0gc2V0VGltZW91dChfLmJpbmQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZsdXNoUHJvbWlzZSA9IHRoaXMuZmx1c2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyksIHRoaXMuZmx1c2hJbnRlcnZhbCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBTZW5kIGEgcmVxdWVzdCB1c2luZyB0aGUgc2VuZFJlcXVlc3QgY2FsbGJhY2ssIGJ1dCBwcm9taXNpZmllZC5cbiAqIFRPRE86IHNlbmRSZXF1ZXN0IHNob3VsZCBiZSBwcm9taXNpZmllZCBpbiB0aGUgZmlyc3QgcGxhY2UuXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5zZW5kUmVxdWVzdFByb21pc2UgPSBmdW5jdGlvbihkYXRhLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoXy5iaW5kKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChkYXRhLCBvcHRpb25zLCByZXNvbHZlKTtcbiAgICB9LCB0aGlzKSk7XG59O1xuXG5cbi8qKlxuICogRmx1c2ggb25lIGJhdGNoIHRvIG5ldHdvcmsuIERlcGVuZGluZyBvbiBzdWNjZXNzL2ZhaWx1cmUgbW9kZXMsIGl0IHdpbGwgZWl0aGVyXG4gKiByZW1vdmUgdGhlIGJhdGNoIGZyb20gdGhlIHF1ZXVlIG9yIGxlYXZlIGl0IGluIGZvciByZXRyeSwgYW5kIHNjaGVkdWxlIHRoZSBuZXh0XG4gKiBmbHVzaC4gSW4gY2FzZXMgb2YgbW9zdCBuZXR3b3JrIG9yIEFQSSBmYWlsdXJlcywgaXQgd2lsbCBiYWNrIG9mZiBleHBvbmVudGlhbGx5XG4gKiB3aGVuIHJldHJ5aW5nLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZW5kQmVhY29uXSAtIHdoZXRoZXIgdG8gc2VuZCBiYXRjaCB3aXRoXG4gKiBuYXZpZ2F0b3Iuc2VuZEJlYWNvbiAob25seSB1c2VmdWwgZm9yIHNlbmRpbmcgYmF0Y2hlcyBiZWZvcmUgcGFnZSB1bmxvYWRzLCBhc1xuICogc2VuZEJlYWNvbiBvZmZlcnMgbm8gY2FsbGJhY2tzIG9yIHN0YXR1cyBpbmRpY2F0aW9ucylcbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICh0aGlzLnJlcXVlc3RJblByb2dyZXNzKSB7XG4gICAgICAgIGxvZ2dlciQ0LmxvZygnRmx1c2g6IFJlcXVlc3QgYWxyZWFkeSBpbiBwcm9ncmVzcycpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlcXVlc3RJblByb2dyZXNzID0gdHJ1ZTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciB0aW1lb3V0TVMgPSB0aGlzLmxpYkNvbmZpZ1snYmF0Y2hfcmVxdWVzdF90aW1lb3V0X21zJ107XG4gICAgdmFyIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIHZhciBjdXJyZW50QmF0Y2hTaXplID0gdGhpcy5iYXRjaFNpemU7XG5cbiAgICByZXR1cm4gdGhpcy5xdWV1ZS5maWxsQmF0Y2goY3VycmVudEJhdGNoU2l6ZSlcbiAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uKGJhdGNoKSB7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3MgbW9yZSBpdGVtcyBpbiB0aGUgcXVldWUgdGhhbiB0aGUgYmF0Y2ggc2l6ZSwgYXR0ZW1wdFxuICAgICAgICAgICAgLy8gdG8gZmx1c2ggYWdhaW4gYWZ0ZXIgdGhlIGN1cnJlbnQgYmF0Y2ggaXMgZG9uZS5cbiAgICAgICAgICAgIHZhciBhdHRlbXB0U2Vjb25kYXJ5Rmx1c2ggPSBiYXRjaC5sZW5ndGggPT09IGN1cnJlbnRCYXRjaFNpemU7XG4gICAgICAgICAgICB2YXIgZGF0YUZvclJlcXVlc3QgPSBbXTtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZEl0ZW1zID0ge307XG4gICAgICAgICAgICBfLmVhY2goYmF0Y2gsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF5bG9hZCA9IGl0ZW1bJ3BheWxvYWQnXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5iZWZvcmVTZW5kSG9vayAmJiAhaXRlbS5vcnBoYW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkID0gdGhpcy5iZWZvcmVTZW5kSG9vayhwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbXBfc2VudF9ieV9saWJfdmVyc2lvbiBwcm9wIGNhcHR1cmVzIHdoaWNoIGxpYiB2ZXJzaW9uIGFjdHVhbGx5XG4gICAgICAgICAgICAgICAgICAgIC8vIHNlbmRzIGVhY2ggZXZlbnQgKHJlZ2FyZGxlc3Mgb2Ygd2hpY2ggdmVyc2lvbiBvcmlnaW5hbGx5IHF1ZXVlZFxuICAgICAgICAgICAgICAgICAgICAvLyBpdCBmb3Igc2VuZGluZylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBheWxvYWRbJ2V2ZW50J10gJiYgcGF5bG9hZFsncHJvcGVydGllcyddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkWydwcm9wZXJ0aWVzJ10gPSBfLmV4dGVuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkWydwcm9wZXJ0aWVzJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeydtcF9zZW50X2J5X2xpYl92ZXJzaW9uJzogQ29uZmlnLkxJQl9WRVJTSU9OfVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgYWRkUGF5bG9hZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtSWQgPSBpdGVtWydpZCddO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRoaXMuaXRlbUlkc1NlbnRTdWNjZXNzZnVsbHlbaXRlbUlkXSB8fCAwKSA+IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdbZHVwZV0gaXRlbSBJRCBzZW50IHRvbyBtYW55IHRpbWVzLCBub3Qgc2VuZGluZycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmF0Y2hTaXplOiBiYXRjaC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzU2VudDogdGhpcy5pdGVtSWRzU2VudFN1Y2Nlc3NmdWxseVtpdGVtSWRdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUGF5bG9hZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignW2R1cGVdIGZvdW5kIGl0ZW0gd2l0aCBubyBJRCcsIHtpdGVtOiBpdGVtfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkUGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUZvclJlcXVlc3QucHVzaChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZEl0ZW1zW2l0ZW1bJ2lkJ11dID0gcGF5bG9hZDtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICBpZiAoZGF0YUZvclJlcXVlc3QubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdEluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0Rmx1c2goKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTsgLy8gbm90aGluZyB0byBkb1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVtb3ZlSXRlbXNGcm9tUXVldWUgPSBfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlXG4gICAgICAgICAgICAgICAgICAgIC5yZW1vdmVJdGVtc0J5SUQoXG4gICAgICAgICAgICAgICAgICAgICAgICBfLm1hcChiYXRjaCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVsnaWQnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uIChzdWNjZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNsaWVudC1zaWRlIGRlZHVwZVxuICAgICAgICAgICAgICAgICAgICAgICAgXy5lYWNoKGJhdGNoLCBfLmJpbmQoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtSWQgPSBpdGVtWydpZCddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVtSWRzU2VudFN1Y2Nlc3NmdWxseVtpdGVtSWRdID0gdGhpcy5pdGVtSWRzU2VudFN1Y2Nlc3NmdWxseVtpdGVtSWRdIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbUlkc1NlbnRTdWNjZXNzZnVsbHlbaXRlbUlkXSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pdGVtSWRzU2VudFN1Y2Nlc3NmdWxseVtpdGVtSWRdID4gNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignW2R1cGVdIGl0ZW0gSUQgc2VudCB0b28gbWFueSB0aW1lcycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhdGNoU2l6ZTogYmF0Y2gubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzU2VudDogdGhpcy5pdGVtSWRzU2VudFN1Y2Nlc3NmdWxseVtpdGVtSWRdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ1tkdXBlXSBmb3VuZCBpdGVtIHdpdGggbm8gSUQgd2hpbGUgcmVtb3ZpbmcnLCB7aXRlbTogaXRlbX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1Y2NlZWRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc2VjdXRpdmVSZW1vdmFsRmFpbHVyZXMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZsdXNoT25seU9uSW50ZXJ2YWwgJiYgIWF0dGVtcHRTZWNvbmRhcnlGbHVzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0Rmx1c2goKTsgLy8gc2NoZWR1bGUgbmV4dCBiYXRjaCB3aXRoIGEgZGVsYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmx1c2goKTsgLy8gaGFuZGxlIG5leHQgYmF0Y2ggaWYgdGhlIHF1ZXVlIGlzbid0IGVtcHR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKyt0aGlzLmNvbnNlY3V0aXZlUmVtb3ZhbEZhaWx1cmVzID4gNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdUb28gbWFueSBxdWV1ZSBmYWlsdXJlczsgZGlzYWJsaW5nIGJhdGNoaW5nIHN5c3RlbS4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wQWxsQmF0Y2hpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0Rmx1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICB2YXIgYmF0Y2hTZW5kQ2FsbGJhY2sgPSBfLmJpbmQoZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0SW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgQVBJIHJlc3BvbnNlIGluIGEgdHJ5LWNhdGNoIHRvIG1ha2Ugc3VyZSB3ZSBjYW4gcmVzZXQgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGZsdXNoIG9wZXJhdGlvbiBpZiBzb21ldGhpbmcgZ29lcyB3cm9uZ1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnVubG9hZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHBlcnNpc3RlZCBkYXRhIHRvIGluY2x1ZGUgaG9vayB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlLnVwZGF0ZVBheWxvYWRzKHRyYW5zZm9ybWVkSXRlbXMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgXy5pc09iamVjdChyZXMpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLmVycm9yID09PSAndGltZW91dCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0VGltZSA+PSB0aW1lb3V0TVNcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdOZXR3b3JrIHRpbWVvdXQ7IHJldHJ5aW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgXy5pc09iamVjdChyZXMpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMuaHR0cFN0YXR1c0NvZGUgPj0gNTAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHJlcy5odHRwU3RhdHVzQ29kZSA9PT0gNDI5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IChyZXMuaHR0cFN0YXR1c0NvZGUgPD0gMCAmJiAhaXNPbmxpbmUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgcmVzLmVycm9yID09PSAndGltZW91dCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV0d29yayBvciBBUEkgZXJyb3IsIG9yIDQyOSBUb28gTWFueSBSZXF1ZXN0cywgcmV0cnlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXRyeU1TID0gdGhpcy5mbHVzaEludGVydmFsICogMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXMucmV0cnlBZnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHJ5TVMgPSAocGFyc2VJbnQocmVzLnJldHJ5QWZ0ZXIsIDEwKSAqIDEwMDApIHx8IHJldHJ5TVM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRyeU1TID0gTWF0aC5taW4oTUFYX1JFVFJZX0lOVEVSVkFMX01TLCByZXRyeU1TKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yOyByZXRyeSBpbiAnICsgcmV0cnlNUyArICcgbXMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVGbHVzaChyZXRyeU1TKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QocmVzKSAmJiByZXMuaHR0cFN0YXR1c0NvZGUgPT09IDQxMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gNDEzIFBheWxvYWQgVG9vIExhcmdlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYWx2ZWRCYXRjaFNpemUgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKGN1cnJlbnRCYXRjaFNpemUgLyAyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iYXRjaFNpemUgPSBNYXRoLm1pbih0aGlzLmJhdGNoU2l6ZSwgaGFsdmVkQmF0Y2hTaXplLCBiYXRjaC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCc0MTMgcmVzcG9uc2U7IHJlZHVjaW5nIGJhdGNoIHNpemUgdG8gJyArIHRoaXMuYmF0Y2hTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0Rmx1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignU2luZ2xlLWV2ZW50IHJlcXVlc3QgdG9vIGxhcmdlOyBkcm9wcGluZycsIGJhdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0QmF0Y2hTaXplKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUl0ZW1zRnJvbVF1ZXVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdWNjZXNzZnVsIG5ldHdvcmsgcmVxdWVzdCtyZXNwb25zZTsgcmVtb3ZlIGVhY2ggaXRlbSBpbiBiYXRjaCBmcm9tIHF1ZXVlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAoZXZlbiBpZiBpdCB3YXMgZS5nLiBhIDQwMCwgaW4gd2hpY2ggY2FzZSByZXRyeWluZyB3b24ndCBoZWxwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUl0ZW1zRnJvbVF1ZXVlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciBoYW5kbGluZyBBUEkgcmVzcG9uc2UnLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0Rmx1c2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICB2ZXJib3NlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlnbm9yZV9qc29uX2Vycm9yczogdHJ1ZSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICAgICAgICAgICAgICB0aW1lb3V0X21zOiB0aW1lb3V0TVMgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAob3B0aW9ucy51bmxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0T3B0aW9ucy50cmFuc3BvcnQgPSAnc2VuZEJlYWNvbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIkNC5sb2coJ01JWFBBTkVMIFJFUVVFU1Q6JywgZGF0YUZvclJlcXVlc3QpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3RQcm9taXNlKGRhdGFGb3JSZXF1ZXN0LCByZXF1ZXN0T3B0aW9ucykudGhlbihiYXRjaFNlbmRDYWxsYmFjayk7XG4gICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAuY2F0Y2goXy5iaW5kKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgZmx1c2hpbmcgcmVxdWVzdCBxdWV1ZScsIGVycik7XG4gICAgICAgICAgICB0aGlzLnJlc2V0Rmx1c2goKTtcbiAgICAgICAgfSwgdGhpcykpO1xufTtcblxuLyoqXG4gKiBMb2cgZXJyb3IgdG8gZ2xvYmFsIGxvZ2dlciBhbmQgb3B0aW9uYWwgdXNlci1kZWZpbmVkIGxvZ2dlci5cbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLnJlcG9ydEVycm9yID0gZnVuY3Rpb24obXNnLCBlcnIpIHtcbiAgICBsb2dnZXIkNC5lcnJvci5hcHBseShsb2dnZXIkNC5lcnJvciwgYXJndW1lbnRzKTtcbiAgICBpZiAodGhpcy5lcnJvclJlcG9ydGVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICAgICAgICBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXJyb3JSZXBvcnRlcihtc2csIGVycik7XG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICBsb2dnZXIkNC5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9zZXNzaW9uLXJlY29yZGluZycpLlNlcmlhbGl6ZWRSZWNvcmRpbmd9IHNlcmlhbGl6ZWRSZWNvcmRpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG52YXIgaXNSZWNvcmRpbmdFeHBpcmVkID0gZnVuY3Rpb24oc2VyaWFsaXplZFJlY29yZGluZykge1xuICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgIHJldHVybiAhc2VyaWFsaXplZFJlY29yZGluZyB8fCBub3cgPiBzZXJpYWxpemVkUmVjb3JkaW5nWydtYXhFeHBpcmVzJ10gfHwgbm93ID4gc2VyaWFsaXplZFJlY29yZGluZ1snaWRsZUV4cGlyZXMnXTtcbn07XG5cbnZhciBSRUNPUkRfRU5RVUVVRV9USFJPVFRMRV9NUyA9IDI1MDtcblxudmFyIGxvZ2dlciQzID0gY29uc29sZV93aXRoX3ByZWZpeCgncmVjb3JkZXInKTtcbnZhciBDb21wcmVzc2lvblN0cmVhbSA9IHdpblsnQ29tcHJlc3Npb25TdHJlYW0nXTtcblxudmFyIFJFQ09SREVSX0JBVENIRVJfTElCX0NPTkZJRyA9IHtcbiAgICAnYmF0Y2hfc2l6ZSc6IDEwMDAsXG4gICAgJ2JhdGNoX2ZsdXNoX2ludGVydmFsX21zJzogMTAgKiAxMDAwLFxuICAgICdiYXRjaF9yZXF1ZXN0X3RpbWVvdXRfbXMnOiA5MCAqIDEwMDAsXG4gICAgJ2JhdGNoX2F1dG9zdGFydCc6IHRydWVcbn07XG5cbnZhciBBQ1RJVkVfU09VUkNFUyA9IG5ldyBTZXQoW1xuICAgIEluY3JlbWVudGFsU291cmNlLk1vdXNlTW92ZSxcbiAgICBJbmNyZW1lbnRhbFNvdXJjZS5Nb3VzZUludGVyYWN0aW9uLFxuICAgIEluY3JlbWVudGFsU291cmNlLlNjcm9sbCxcbiAgICBJbmNyZW1lbnRhbFNvdXJjZS5WaWV3cG9ydFJlc2l6ZSxcbiAgICBJbmNyZW1lbnRhbFNvdXJjZS5JbnB1dCxcbiAgICBJbmNyZW1lbnRhbFNvdXJjZS5Ub3VjaE1vdmUsXG4gICAgSW5jcmVtZW50YWxTb3VyY2UuTWVkaWFJbnRlcmFjdGlvbixcbiAgICBJbmNyZW1lbnRhbFNvdXJjZS5EcmFnLFxuICAgIEluY3JlbWVudGFsU291cmNlLlNlbGVjdGlvbixcbl0pO1xuXG5mdW5jdGlvbiBpc1VzZXJFdmVudChldikge1xuICAgIHJldHVybiBldi50eXBlID09PSBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCAmJiBBQ1RJVkVfU09VUkNFUy5oYXMoZXYuZGF0YS5zb3VyY2UpO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNlcmlhbGl6ZWRSZWNvcmRpbmdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpZGxlRXhwaXJlc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IG1heEV4cGlyZXNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZXBsYXlTdGFydFRpbWVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsYXN0RXZlbnRUaW1lc3RhbXBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZXFOb1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGJhdGNoU3RhcnRVcmxcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSByZXBsYXlJZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRhYklkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcmVwbGF5U3RhcnRVcmxcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNlc3Npb25SZWNvcmRpbmdPcHRpb25zXG4gKiBAcHJvcGVydHkge09iamVjdH0gW29wdGlvbnMubWl4cGFuZWxJbnN0YW5jZV0gLSByZWZlcmVuY2UgdG8gdGhlIGNvcmUgTWl4cGFuZWxMaWJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbb3B0aW9ucy5yZXBsYXlJZF0gLSB1bmlxdWUgdXVpZCBmb3IgYSBzaW5nbGUgcmVwbGF5XG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbklkbGVUaW1lb3V0XSAtIGNhbGxiYWNrIHdoZW4gYSByZWNvcmRpbmcgcmVhY2hlcyBpZGxlIHRpbWVvdXRcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtvcHRpb25zLm9uTWF4TGVuZ3RoUmVhY2hlZF0gLSBjYWxsYmFjayB3aGVuIGEgcmVjb3JkaW5nIHJlYWNoZXMgaXRzIG1heGltdW0gbGVuZ3RoXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbb3B0aW9ucy5ycndlYlJlY29yZF0gLSBycndlYidzIGByZWNvcmRgIGZ1bmN0aW9uXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkJhdGNoU2VudF0gLSBjYWxsYmFjayB3aGVuIGEgYmF0Y2ggb2YgZXZlbnRzIGlzIHNlbnQgdG8gdGhlIHNlcnZlclxuICogQHByb3BlcnR5IHtTdG9yYWdlfSBbb3B0aW9ucy5zaGFyZWRMb2NrU3RvcmFnZV0gLSBvcHRpb25hbCBzdG9yYWdlIGZvciBzaGFyZWQgbG9jaywgdXNlZCBmb3IgdGVzdCBkZXBlbmRlbmN5IGluamVjdGlvblxuICogb3B0aW9uYWwgcHJvcGVydGllcyBmb3IgZGVzZXJpYWxpemF0aW9uOlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGlkbGVFeHBpcmVzXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWF4RXhwaXJlc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHJlcGxheVN0YXJ0VGltZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxhc3RFdmVudFRpbWVzdGFtcCAtIHRoZSB1bml4IHRpbWVzdGFtcCBvZiB0aGUgbGFzdCByZWNvcmRlZCBldmVudCBmcm9tIHJyd2ViXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2VxTm9cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBiYXRjaFN0YXJ0VXJsXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcmVwbGF5U3RhcnRVcmxcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFVzZXJJZEluZm9cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkaXN0aW5jdF9pZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHVzZXJfaWRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXZpY2VfaWRcbiAqL1xuXG5cbi8qKlxuICogVGhpcyBjbGFzcyBlbmNhcHN1bGF0ZXMgYSBzaW5nbGUgc2Vzc2lvbiByZWNvcmRpbmcgYW5kIGl0cyBsaWZlY3ljbGUuXG4gKiBAcGFyYW0ge1Nlc3Npb25SZWNvcmRpbmdPcHRpb25zfSBvcHRpb25zXG4gKi9cbnZhciBTZXNzaW9uUmVjb3JkaW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuX21peHBhbmVsID0gb3B0aW9ucy5taXhwYW5lbEluc3RhbmNlO1xuICAgIHRoaXMuX29uSWRsZVRpbWVvdXQgPSBvcHRpb25zLm9uSWRsZVRpbWVvdXQgfHwgTk9PUF9GVU5DO1xuICAgIHRoaXMuX29uTWF4TGVuZ3RoUmVhY2hlZCA9IG9wdGlvbnMub25NYXhMZW5ndGhSZWFjaGVkIHx8IE5PT1BfRlVOQztcbiAgICB0aGlzLl9vbkJhdGNoU2VudCA9IG9wdGlvbnMub25CYXRjaFNlbnQgfHwgTk9PUF9GVU5DO1xuICAgIHRoaXMuX3Jyd2ViUmVjb3JkID0gb3B0aW9ucy5ycndlYlJlY29yZCB8fCBudWxsO1xuXG4gICAgLy8gaW50ZXJuYWwgcnJ3ZWIgc3RvcFJlY29yZGluZyBmdW5jdGlvblxuICAgIHRoaXMuX3N0b3BSZWNvcmRpbmcgPSBudWxsO1xuICAgIHRoaXMucmVwbGF5SWQgPSBvcHRpb25zLnJlcGxheUlkO1xuXG4gICAgdGhpcy5iYXRjaFN0YXJ0VXJsID0gb3B0aW9ucy5iYXRjaFN0YXJ0VXJsIHx8IG51bGw7XG4gICAgdGhpcy5yZXBsYXlTdGFydFVybCA9IG9wdGlvbnMucmVwbGF5U3RhcnRVcmwgfHwgbnVsbDtcbiAgICB0aGlzLmlkbGVFeHBpcmVzID0gb3B0aW9ucy5pZGxlRXhwaXJlcyB8fCBudWxsO1xuICAgIHRoaXMubWF4RXhwaXJlcyA9IG9wdGlvbnMubWF4RXhwaXJlcyB8fCBudWxsO1xuICAgIHRoaXMucmVwbGF5U3RhcnRUaW1lID0gb3B0aW9ucy5yZXBsYXlTdGFydFRpbWUgfHwgbnVsbDtcbiAgICB0aGlzLmxhc3RFdmVudFRpbWVzdGFtcCA9IG9wdGlvbnMubGFzdEV2ZW50VGltZXN0YW1wIHx8IG51bGw7XG4gICAgdGhpcy5zZXFObyA9IG9wdGlvbnMuc2VxTm8gfHwgMDtcblxuICAgIHRoaXMuaWRsZVRpbWVvdXRJZCA9IG51bGw7XG4gICAgdGhpcy5tYXhUaW1lb3V0SWQgPSBudWxsO1xuXG4gICAgdGhpcy5yZWNvcmRNYXhNcyA9IE1BWF9SRUNPUkRJTkdfTVM7XG4gICAgdGhpcy5yZWNvcmRNaW5NcyA9IDA7XG5cbiAgICAvLyBkaXNhYmxlIHBlcnNpc3RlbmNlIGlmIGxvY2FsU3RvcmFnZSBpcyBub3Qgc3VwcG9ydGVkXG4gICAgLy8gcmVxdWVzdC1xdWV1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgZGlzYWJsZSBwZXJzaXN0ZW5jZSBpZiBpbmRleGVkREIgZmFpbHMgdG8gaW5pdGlhbGl6ZVxuICAgIHZhciB1c2VQZXJzaXN0ZW5jZSA9IGxvY2FsU3RvcmFnZVN1cHBvcnRlZChvcHRpb25zLnNoYXJlZExvY2tTdG9yYWdlLCB0cnVlKSAmJiAhdGhpcy5nZXRDb25maWcoJ2Rpc2FibGVfcGVyc2lzdGVuY2UnKTtcblxuICAgIC8vIGVhY2ggcmVwbGF5IGhhcyBpdHMgb3duIGJhdGNoZXIga2V5IHRvIGF2b2lkIGNvbmZsaWN0cyBiZXR3ZWVuIHJyd2ViIGV2ZW50cyBvZiBkaWZmZXJlbnQgcmVjb3JkaW5nc1xuICAgIHRoaXMuYmF0Y2hlcktleSA9ICdfX21wcmVjXycgKyB0aGlzLmdldENvbmZpZygnbmFtZScpICsgJ18nICsgdGhpcy5nZXRDb25maWcoJ3Rva2VuJykgKyAnXycgKyB0aGlzLnJlcGxheUlkO1xuICAgIHRoaXMucXVldWVTdG9yYWdlID0gbmV3IElEQlN0b3JhZ2VXcmFwcGVyKFJFQ09SRElOR19FVkVOVFNfU1RPUkVfTkFNRSk7XG4gICAgdGhpcy5iYXRjaGVyID0gbmV3IFJlcXVlc3RCYXRjaGVyKHRoaXMuYmF0Y2hlcktleSwge1xuICAgICAgICBlcnJvclJlcG9ydGVyOiB0aGlzLnJlcG9ydEVycm9yLmJpbmQodGhpcyksXG4gICAgICAgIGZsdXNoT25seU9uSW50ZXJ2YWw6IHRydWUsXG4gICAgICAgIGxpYkNvbmZpZzogUkVDT1JERVJfQkFUQ0hFUl9MSUJfQ09ORklHLFxuICAgICAgICBzZW5kUmVxdWVzdEZ1bmM6IHRoaXMuZmx1c2hFdmVudHNXaXRoT3B0T3V0LmJpbmQodGhpcyksXG4gICAgICAgIHF1ZXVlU3RvcmFnZTogdGhpcy5xdWV1ZVN0b3JhZ2UsXG4gICAgICAgIHNoYXJlZExvY2tTdG9yYWdlOiBvcHRpb25zLnNoYXJlZExvY2tTdG9yYWdlLFxuICAgICAgICB1c2VQZXJzaXN0ZW5jZTogdXNlUGVyc2lzdGVuY2UsXG4gICAgICAgIHN0b3BBbGxCYXRjaGluZ0Z1bmM6IHRoaXMuc3RvcFJlY29yZGluZy5iaW5kKHRoaXMpLFxuXG4gICAgICAgIC8vIGluY3JlYXNlZCB0aHJvdHRsZSBhbmQgc2hhcmVkIGxvY2sgdGltZW91dCBiZWNhdXNlIHJlY29yZGluZyBldmVudHMgYXJlIHZlcnkgaGlnaCBmcmVxdWVuY3kuXG4gICAgICAgIC8vIHRoaXMgd2lsbCBtaW5pbWl6ZSB0aGUgYW1vdW50IG9mIGxvY2sgY29udGVudGlvbiBiZXR3ZWVuIGVucXVldWVkIGV2ZW50cy5cbiAgICAgICAgLy8gZm9yIHNlc3Npb24gcmVjb3JkaW5ncyB0aGVyZSBpcyBhIGxvY2sgZm9yIGVhY2ggdGFiIGFueXdheSwgc28gdGhlcmUncyBubyByaXNrIG9mIGRlYWRsb2NrIGJldHdlZW4gdGFicy5cbiAgICAgICAgZW5xdWV1ZVRocm90dGxlTXM6IFJFQ09SRF9FTlFVRVVFX1RIUk9UVExFX01TLFxuICAgICAgICBzaGFyZWRMb2NrVGltZW91dE1TOiAxMCAqIDEwMDAsXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtVc2VySWRJbmZvfVxuICovXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5nZXRVc2VySWRJbmZvID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmZpbmFsRmx1c2hVc2VySWRJbmZvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmFsRmx1c2hVc2VySWRJbmZvO1xuICAgIH1cblxuICAgIHZhciB1c2VySWRJbmZvID0ge1xuICAgICAgICAnZGlzdGluY3RfaWQnOiBTdHJpbmcodGhpcy5fbWl4cGFuZWwuZ2V0X2Rpc3RpbmN0X2lkKCkpLFxuICAgIH07XG5cbiAgICAvLyBzZW5kIElEIG1hbmFnZW1lbnQgcHJvcHMgaWYgdGhleSBleGlzdFxuICAgIHZhciBkZXZpY2VJZCA9IHRoaXMuX21peHBhbmVsLmdldF9wcm9wZXJ0eSgnJGRldmljZV9pZCcpO1xuICAgIGlmIChkZXZpY2VJZCkge1xuICAgICAgICB1c2VySWRJbmZvWyckZGV2aWNlX2lkJ10gPSBkZXZpY2VJZDtcbiAgICB9XG4gICAgdmFyIHVzZXJJZCA9IHRoaXMuX21peHBhbmVsLmdldF9wcm9wZXJ0eSgnJHVzZXJfaWQnKTtcbiAgICBpZiAodXNlcklkKSB7XG4gICAgICAgIHVzZXJJZEluZm9bJyR1c2VyX2lkJ10gPSB1c2VySWQ7XG4gICAgfVxuICAgIHJldHVybiB1c2VySWRJbmZvO1xufTtcblxuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUudW5sb2FkUGVyc2lzdGVkRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmJhdGNoZXIuc3RvcCgpO1xuXG4gICAgcmV0dXJuIHRoaXMucXVldWVTdG9yYWdlLmluaXQoKS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIGluaXRpYWxpemluZyBJbmRleGVkREIgc3RvcmFnZSBmb3IgdW5sb2FkaW5nIHBlcnNpc3RlZCBkYXRhLicpO1xuICAgIH0uYmluZCh0aGlzKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGlmIHRoZSByZWNvcmRpbmcgaXMgdG9vIHNob3J0LCBqdXN0IGRlbGV0ZSBhbnkgc3RvcmVkIGV2ZW50cyB3aXRob3V0IGZsdXNoaW5nXG4gICAgICAgIGlmICh0aGlzLmdldER1cmF0aW9uTXMoKSA8IHRoaXMuX2dldFJlY29yZE1pbk1zKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuYmF0Y2hlcktleSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5iYXRjaGVyLmZsdXNoKClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZVN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLmJhdGNoZXJLZXkpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LmJpbmQodGhpcykpO1xufTtcblxuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24oY29uZmlnVmFyKSB7XG4gICAgcmV0dXJuIHRoaXMuX21peHBhbmVsLmdldF9jb25maWcoY29uZmlnVmFyKTtcbn07XG5cbi8vIEFsaWFzIGZvciBnZXRDb25maWcsIHVzZWQgYnkgdGhlIGNvbW1vbiBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliIGZ1bmN0aW9uIHdoaWNoXG4vLyByZWFjaGVzIGludG8gdGhpcyBjbGFzcyBpbnN0YW5jZSBhbmQgZXhwZWN0cyB0aGUgc25ha2UgY2FzZSB2ZXJzaW9uIG9mIHRoZSBmdW5jdGlvbi5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2VcblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLmdldF9jb25maWcgPSBmdW5jdGlvbihjb25maWdWYXIpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDb25maWcoY29uZmlnVmFyKTtcbn07XG5cblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLnN0YXJ0UmVjb3JkaW5nID0gZnVuY3Rpb24gKHNob3VsZFN0b3BCYXRjaGVyKSB7XG4gICAgaWYgKHRoaXMuX3Jyd2ViUmVjb3JkID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ3Jyd2ViIHJlY29yZCBmdW5jdGlvbiBub3QgcHJvdmlkZWQuICcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3N0b3BSZWNvcmRpbmcgIT09IG51bGwpIHtcbiAgICAgICAgbG9nZ2VyJDMubG9nKCdSZWNvcmRpbmcgYWxyZWFkeSBpbiBwcm9ncmVzcywgc2tpcHBpbmcgc3RhcnRSZWNvcmRpbmcuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnJlY29yZE1heE1zID0gdGhpcy5nZXRDb25maWcoJ3JlY29yZF9tYXhfbXMnKTtcbiAgICBpZiAodGhpcy5yZWNvcmRNYXhNcyA+IE1BWF9SRUNPUkRJTkdfTVMpIHtcbiAgICAgICAgdGhpcy5yZWNvcmRNYXhNcyA9IE1BWF9SRUNPUkRJTkdfTVM7XG4gICAgICAgIGxvZ2dlciQzLmNyaXRpY2FsKCdyZWNvcmRfbWF4X21zIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gJyArIE1BWF9SRUNPUkRJTkdfTVMgKyAnbXMuIENhcHBpbmcgdmFsdWUuJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm1heEV4cGlyZXMpIHtcbiAgICAgICAgdGhpcy5tYXhFeHBpcmVzID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyB0aGlzLnJlY29yZE1heE1zO1xuICAgIH1cblxuICAgIHRoaXMucmVjb3JkTWluTXMgPSB0aGlzLl9nZXRSZWNvcmRNaW5NcygpO1xuXG4gICAgaWYgKCF0aGlzLnJlcGxheVN0YXJ0VGltZSkge1xuICAgICAgICB0aGlzLnJlcGxheVN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB0aGlzLmJhdGNoU3RhcnRVcmwgPSBfLmluZm8uY3VycmVudFVybCgpO1xuICAgICAgICB0aGlzLnJlcGxheVN0YXJ0VXJsID0gXy5pbmZvLmN1cnJlbnRVcmwoKTtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkU3RvcEJhdGNoZXIgfHwgdGhpcy5yZWNvcmRNaW5NcyA+IDApIHtcbiAgICAgICAgLy8gdGhlIHByaW1hcnkgY2FzZSBmb3Igc2hvdWxkU3RvcEJhdGNoZXIgaXMgd2hlbiB3ZSdyZSBzdGFydGluZyByZWNvcmRpbmcgYWZ0ZXIgYSByZXNldFxuICAgICAgICAvLyBhbmQgZG9uJ3Qgd2FudCB0byBzZW5kIGFueXRoaW5nIG92ZXIgdGhlIG5ldHdvcmsgdW50aWwgdGhlcmUnc1xuICAgICAgICAvLyBhY3R1YWwgdXNlciBhY3Rpdml0eVxuICAgICAgICAvLyB0aGlzIGFsc28gYXBwbGllcyBpZiB0aGUgbWluaW11bSByZWNvcmRpbmcgbGVuZ3RoIGhhcyBub3QgYmVlbiBoaXQgeWV0XG4gICAgICAgIC8vIHNvIHRoYXQgd2UgZG9uJ3Qgc2VuZCBkYXRhIHVudGlsIHdlIGtub3cgdGhlIHJlY29yZGluZyB3aWxsIGJlIGxvbmcgZW5vdWdoXG4gICAgICAgIHRoaXMuYmF0Y2hlci5zdG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5iYXRjaGVyLnN0YXJ0KCk7XG4gICAgfVxuXG4gICAgdmFyIHJlc2V0SWRsZVRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmlkbGVUaW1lb3V0SWQpO1xuICAgICAgICB2YXIgaWRsZVRpbWVvdXRNcyA9IHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfaWRsZV90aW1lb3V0X21zJyk7XG4gICAgICAgIHRoaXMuaWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQodGhpcy5fb25JZGxlVGltZW91dCwgaWRsZVRpbWVvdXRNcyk7XG4gICAgICAgIHRoaXMuaWRsZUV4cGlyZXMgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIGlkbGVUaW1lb3V0TXM7XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIHJlc2V0SWRsZVRpbWVvdXQoKTtcblxuICAgIHZhciBibG9ja1NlbGVjdG9yID0gdGhpcy5nZXRDb25maWcoJ3JlY29yZF9ibG9ja19zZWxlY3RvcicpO1xuICAgIGlmIChibG9ja1NlbGVjdG9yID09PSAnJyB8fCBibG9ja1NlbGVjdG9yID09PSBudWxsKSB7XG4gICAgICAgIGJsb2NrU2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fc3RvcFJlY29yZGluZyA9IHRoaXMuX3Jyd2ViUmVjb3JkKHtcbiAgICAgICAgICAgICdlbWl0JzogZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRsZUV4cGlyZXMgJiYgdGhpcy5pZGxlRXhwaXJlcyA8IGV2LnRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbklkbGVUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzVXNlckV2ZW50KGV2KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5iYXRjaGVyLnN0b3BwZWQgJiYgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLnJlcGxheVN0YXJ0VGltZSA+PSB0aGlzLnJlY29yZE1pbk1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCBmbHVzaGluZyBhZ2FpbiBhZnRlciB1c2VyIGFjdGl2aXR5XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJhdGNoZXIuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNldElkbGVUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHByb21pc2Ugb25seSB1c2VkIHRvIGF3YWl0IGR1cmluZyB0ZXN0c1xuICAgICAgICAgICAgICAgIHRoaXMuX19lbnF1ZXVlUHJvbWlzZSA9IHRoaXMuYmF0Y2hlci5lbnF1ZXVlKGV2KTtcblxuICAgICAgICAgICAgICAgIC8vIENhcHR1cmUgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbGFzdCBldmVudCBmb3IgZHVyYXRpb24gY2FsY3VsYXRpb24uXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGFzdEV2ZW50VGltZXN0YW1wID09PSBudWxsIHx8IGV2LnRpbWVzdGFtcCA+IHRoaXMubGFzdEV2ZW50VGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdEV2ZW50VGltZXN0YW1wID0gZXYudGltZXN0YW1wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgICAgICAgICdibG9ja0NsYXNzJzogdGhpcy5nZXRDb25maWcoJ3JlY29yZF9ibG9ja19jbGFzcycpLFxuICAgICAgICAgICAgJ2Jsb2NrU2VsZWN0b3InOiBibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgJ2NvbGxlY3RGb250cyc6IHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfY29sbGVjdF9mb250cycpLFxuICAgICAgICAgICAgJ2RhdGFVUkxPcHRpb25zJzogeyAvLyBjYW52YXMgaW1hZ2Ugb3B0aW9ucyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxDYW52YXNFbGVtZW50L3RvRGF0YVVSTClcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdpbWFnZS93ZWJwJyxcbiAgICAgICAgICAgICAgICAncXVhbGl0eSc6IDAuNlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdtYXNrQWxsSW5wdXRzJzogdHJ1ZSxcbiAgICAgICAgICAgICdtYXNrVGV4dENsYXNzJzogdGhpcy5nZXRDb25maWcoJ3JlY29yZF9tYXNrX3RleHRfY2xhc3MnKSxcbiAgICAgICAgICAgICdtYXNrVGV4dFNlbGVjdG9yJzogdGhpcy5nZXRDb25maWcoJ3JlY29yZF9tYXNrX3RleHRfc2VsZWN0b3InKSxcbiAgICAgICAgICAgICdyZWNvcmRDYW52YXMnOiB0aGlzLmdldENvbmZpZygncmVjb3JkX2NhbnZhcycpLFxuICAgICAgICAgICAgJ3NhbXBsaW5nJzoge1xuICAgICAgICAgICAgICAgICdjYW52YXMnOiAxNVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdwbHVnaW5zJzogdGhpcy5nZXRDb25maWcoJ3JlY29yZF9jb25zb2xlJykgPyBbXG4gICAgICAgICAgICAgICAgZ2V0UmVjb3JkQ29uc29sZVBsdWdpbih7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ2lmeU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ0xlbmd0aExpbWl0OiAxMDAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtT2ZLZXlzTGltaXQ6IDUwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGhPZkxpbWl0OiAyXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgXSA6IFtdXG4gICAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdVbmV4cGVjdGVkIGVycm9yIHdoZW4gc3RhcnRpbmcgcnJ3ZWIgcmVjb3JkaW5nLicsIGVycik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLl9zdG9wUmVjb3JkaW5nICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ3Jyd2ViIGZhaWxlZCB0byBzdGFydCwgc2tpcHBpbmcgdGhpcyByZWNvcmRpbmcuJyk7XG4gICAgICAgIHRoaXMuX3N0b3BSZWNvcmRpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLnN0b3BSZWNvcmRpbmcoKTsgLy8gc3RvcCBiYXRjaGVyIGxvb3BpbmcgYW5kIGFueSB0aW1lb3V0c1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG1heFRpbWVvdXRNcyA9IHRoaXMubWF4RXhwaXJlcyAtIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIHRoaXMubWF4VGltZW91dElkID0gc2V0VGltZW91dCh0aGlzLl9vbk1heExlbmd0aFJlYWNoZWQuYmluZCh0aGlzKSwgbWF4VGltZW91dE1zKTtcbn07XG5cblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLnN0b3BSZWNvcmRpbmcgPSBmdW5jdGlvbiAoc2tpcEZsdXNoKSB7XG4gICAgLy8gc3RvcmUgdGhlIHVzZXIgSUQgaW5mbyBpbiBjYXNlIHRoaXMgaXMgZ2V0dGluZyBjYWxsZWQgaW4gbWl4cGFuZWwucmVzZXQoKVxuICAgIHRoaXMuZmluYWxGbHVzaFVzZXJJZEluZm8gPSB0aGlzLmdldFVzZXJJZEluZm8oKTtcblxuICAgIGlmICghdGhpcy5pc1Jyd2ViU3RvcHBlZCgpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9zdG9wUmVjb3JkaW5nKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3Igd2l0aCBycndlYiBzdG9wUmVjb3JkaW5nJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdG9wUmVjb3JkaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgZmx1c2hQcm9taXNlO1xuICAgIGlmICh0aGlzLmJhdGNoZXIuc3RvcHBlZCkge1xuICAgICAgICAvLyBuZXZlciBnb3QgdXNlciBhY3Rpdml0eSB0byBmbHVzaCBhZnRlciByZXNldCwgc28ganVzdCBjbGVhciB0aGUgYmF0Y2hlclxuICAgICAgICBmbHVzaFByb21pc2UgPSB0aGlzLmJhdGNoZXIuY2xlYXIoKTtcbiAgICB9IGVsc2UgaWYgKCFza2lwRmx1c2gpIHtcbiAgICAgICAgLy8gZmx1c2ggYW55IHJlbWFpbmluZyBldmVudHMgZnJvbSBydW5uaW5nIGJhdGNoZXJcbiAgICAgICAgZmx1c2hQcm9taXNlID0gdGhpcy5iYXRjaGVyLmZsdXNoKCk7XG4gICAgfVxuICAgIHRoaXMuYmF0Y2hlci5zdG9wKCk7XG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy5pZGxlVGltZW91dElkKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5tYXhUaW1lb3V0SWQpO1xuICAgIHJldHVybiBmbHVzaFByb21pc2U7XG59O1xuXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5pc1Jyd2ViU3RvcHBlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RvcFJlY29yZGluZyA9PT0gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBGbHVzaGVzIHRoZSBjdXJyZW50IGJhdGNoIG9mIGV2ZW50cyB0byB0aGUgc2VydmVyLCBidXQgcGFzc2VzIGFuIG9wdC1vdXQgY2FsbGJhY2sgdG8gbWFrZSBzdXJlXG4gKiB3ZSBzdG9wIHJlY29yZGluZyBhbmQgZHVtcCBhbnkgcXVldWVkIGV2ZW50cyBpZiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0LlxuICovXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5mbHVzaEV2ZW50c1dpdGhPcHRPdXQgPSBmdW5jdGlvbiAoZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICB2YXIgb25PcHRPdXQgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICAvLyBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliIGludm9rZXMgdGhpcyBmdW5jdGlvbiB3aXRoIGNvZGU9MCB3aGVuIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXRcbiAgICAgICAgaWYgKGNvZGUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcFJlY29yZGluZygpO1xuICAgICAgICAgICAgY2Ioe2Vycm9yOiAnVHJhY2tpbmcgaGFzIGJlZW4gb3B0ZWQgb3V0LCBzdG9wcGluZyByZWNvcmRpbmcuJ30pO1xuICAgICAgICB9XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fZmx1c2hFdmVudHMoZGF0YSwgb3B0aW9ucywgY2IsIG9uT3B0T3V0KTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge1NlcmlhbGl6ZWRSZWNvcmRpbmd9XG4gKi9cblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBkb24ndCBicmVhayBpZiBtaXhwYW5lbCBpbnN0YW5jZSB3YXMgZGVzdHJveWVkIGF0IHNvbWUgcG9pbnRcbiAgICB2YXIgdGFiSWQ7XG4gICAgdHJ5IHtcbiAgICAgICAgdGFiSWQgPSB0aGlzLl9taXhwYW5lbC5nZXRfdGFiX2lkKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciBnZXR0aW5nIHRhYiBJRCBmb3Igc2VyaWFsaXphdGlvbiAnLCBlKTtcbiAgICAgICAgdGFiSWQgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgICdyZXBsYXlJZCc6IHRoaXMucmVwbGF5SWQsXG4gICAgICAgICdzZXFObyc6IHRoaXMuc2VxTm8sXG4gICAgICAgICdyZXBsYXlTdGFydFRpbWUnOiB0aGlzLnJlcGxheVN0YXJ0VGltZSxcbiAgICAgICAgJ2JhdGNoU3RhcnRVcmwnOiB0aGlzLmJhdGNoU3RhcnRVcmwsXG4gICAgICAgICdyZXBsYXlTdGFydFVybCc6IHRoaXMucmVwbGF5U3RhcnRVcmwsXG4gICAgICAgICdsYXN0RXZlbnRUaW1lc3RhbXAnOiB0aGlzLmxhc3RFdmVudFRpbWVzdGFtcCxcbiAgICAgICAgJ2lkbGVFeHBpcmVzJzogdGhpcy5pZGxlRXhwaXJlcyxcbiAgICAgICAgJ21heEV4cGlyZXMnOiB0aGlzLm1heEV4cGlyZXMsXG4gICAgICAgICd0YWJJZCc6IHRhYklkLFxuICAgIH07XG59O1xuXG5cbi8qKlxuICogQHN0YXRpY1xuICogQHBhcmFtIHtTZXJpYWxpemVkUmVjb3JkaW5nfSBzZXJpYWxpemVkUmVjb3JkaW5nXG4gKiBAcGFyYW0ge1Nlc3Npb25SZWNvcmRpbmdPcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyB7U2Vzc2lvblJlY29yZGluZ31cbiAqL1xuU2Vzc2lvblJlY29yZGluZy5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChzZXJpYWxpemVkUmVjb3JkaW5nLCBvcHRpb25zKSB7XG4gICAgdmFyIHJlY29yZGluZyA9IG5ldyBTZXNzaW9uUmVjb3JkaW5nKF8uZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIHJlcGxheUlkOiBzZXJpYWxpemVkUmVjb3JkaW5nWydyZXBsYXlJZCddLFxuICAgICAgICBiYXRjaFN0YXJ0VXJsOiBzZXJpYWxpemVkUmVjb3JkaW5nWydiYXRjaFN0YXJ0VXJsJ10sXG4gICAgICAgIHJlcGxheVN0YXJ0VXJsOiBzZXJpYWxpemVkUmVjb3JkaW5nWydyZXBsYXlTdGFydFVybCddLFxuICAgICAgICBpZGxlRXhwaXJlczogc2VyaWFsaXplZFJlY29yZGluZ1snaWRsZUV4cGlyZXMnXSxcbiAgICAgICAgbWF4RXhwaXJlczogc2VyaWFsaXplZFJlY29yZGluZ1snbWF4RXhwaXJlcyddLFxuICAgICAgICByZXBsYXlTdGFydFRpbWU6IHNlcmlhbGl6ZWRSZWNvcmRpbmdbJ3JlcGxheVN0YXJ0VGltZSddLFxuICAgICAgICBsYXN0RXZlbnRUaW1lc3RhbXA6IHNlcmlhbGl6ZWRSZWNvcmRpbmdbJ2xhc3RFdmVudFRpbWVzdGFtcCddLFxuICAgICAgICBzZXFObzogc2VyaWFsaXplZFJlY29yZGluZ1snc2VxTm8nXSxcbiAgICAgICAgc2hhcmVkTG9ja1N0b3JhZ2U6IG9wdGlvbnMuc2hhcmVkTG9ja1N0b3JhZ2UsXG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIHJlY29yZGluZztcbn07XG5cblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLl9zZW5kUmVxdWVzdCA9IGZ1bmN0aW9uKGN1cnJlbnRSZXBsYXlJZCwgcmVxUGFyYW1zLCByZXFCb2R5LCBjYWxsYmFjaykge1xuICAgIHZhciBvblN1Y2Nlc3MgPSBmdW5jdGlvbiAocmVzcG9uc2UsIHJlc3BvbnNlQm9keSkge1xuICAgICAgICAvLyBVcGRhdGUgYmF0Y2ggc3BlY2lmaWMgcHJvcHMgb25seSBpZiB0aGUgcmVxdWVzdCB3YXMgc3VjY2Vzc2Z1bCB0byBndWFyYW50ZWUgb3JkZXJpbmcuXG4gICAgICAgIC8vIFJlcXVlc3RCYXRjaGVyIHdpbGwgYWx3YXlzIGZsdXNoIHRoZSBuZXh0IGJhdGNoIGFmdGVyIHRoZSBwcmV2aW91cyBvbmUgc3VjY2VlZHMuXG4gICAgICAgIC8vIGV4dHJhIGNoZWNrIHRvIHNlZSBpZiB0aGUgcmVwbGF5IElEIGhhcyBjaGFuZ2VkIHNvIHRoYXQgd2UgZG9uJ3QgaW5jcmVtZW50IHRoZSBzZXFObyBvbiB0aGUgd3JvbmcgcmVwbGF5XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCAmJiB0aGlzLnJlcGxheUlkID09PSBjdXJyZW50UmVwbGF5SWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VxTm8rKztcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hTdGFydFVybCA9IF8uaW5mby5jdXJyZW50VXJsKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9vbkJhdGNoU2VudCgpO1xuICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICBzdGF0dXM6IDAsXG4gICAgICAgICAgICBodHRwU3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgcmVzcG9uc2VCb2R5OiByZXNwb25zZUJvZHksXG4gICAgICAgICAgICByZXRyeUFmdGVyOiByZXNwb25zZS5oZWFkZXJzLmdldCgnUmV0cnktQWZ0ZXInKVxuICAgICAgICB9KTtcbiAgICB9LmJpbmQodGhpcyk7XG4gICAgdmFyIGFwaUhvc3QgPSAodGhpcy5fbWl4cGFuZWwuZ2V0X2FwaV9ob3N0ICYmIHRoaXMuX21peHBhbmVsLmdldF9hcGlfaG9zdCgncmVjb3JkJykpIHx8IHRoaXMuZ2V0Q29uZmlnKCdhcGlfaG9zdCcpO1xuICAgIHdpblsnZmV0Y2gnXShhcGlIb3N0ICsgJy8nICsgdGhpcy5nZXRDb25maWcoJ2FwaV9yb3V0ZXMnKVsncmVjb3JkJ10gKyAnPycgKyBuZXcgVVJMU2VhcmNoUGFyYW1zKHJlcVBhcmFtcyksIHtcbiAgICAgICAgJ21ldGhvZCc6ICdQT1NUJyxcbiAgICAgICAgJ2hlYWRlcnMnOiB7XG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6ICdCYXNpYyAnICsgYnRvYSh0aGlzLmdldENvbmZpZygndG9rZW4nKSArICc6JyksXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSdcbiAgICAgICAgfSxcbiAgICAgICAgJ2JvZHknOiByZXFCb2R5LFxuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIHJlc3BvbnNlLmpzb24oKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZUJvZHkpIHtcbiAgICAgICAgICAgIG9uU3VjY2VzcyhyZXNwb25zZSwgcmVzcG9uc2VCb2R5KTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBjYWxsYmFjayh7ZXJyb3I6IGVycm9yfSk7XG4gICAgICAgIH0pO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBjYWxsYmFjayh7ZXJyb3I6IGVycm9yLCBodHRwU3RhdHVzQ29kZTogMH0pO1xuICAgIH0pO1xufTtcblxuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUuX2ZsdXNoRXZlbnRzID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYihmdW5jdGlvbiAoZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICB2YXIgbnVtRXZlbnRzID0gZGF0YS5sZW5ndGg7XG5cbiAgICBpZiAobnVtRXZlbnRzID4gMCkge1xuICAgICAgICB2YXIgcmVwbGF5SWQgPSB0aGlzLnJlcGxheUlkO1xuXG4gICAgICAgIC8vIGVhY2ggcnJ3ZWIgZXZlbnQgaGFzIGEgdGltZXN0YW1wIC0gbGV2ZXJhZ2UgdGhvc2UgdG8gZ2V0IHRpbWUgcHJvcGVydGllc1xuICAgICAgICB2YXIgYmF0Y2hTdGFydFRpbWUgPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIGJhdGNoRW5kVGltZSA9IC1JbmZpbml0eTtcbiAgICAgICAgdmFyIGhhc0Z1bGxTbmFwc2hvdCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUV2ZW50czsgaSsrKSB7XG4gICAgICAgICAgICBiYXRjaFN0YXJ0VGltZSA9IE1hdGgubWluKGJhdGNoU3RhcnRUaW1lLCBkYXRhW2ldLnRpbWVzdGFtcCk7XG4gICAgICAgICAgICBiYXRjaEVuZFRpbWUgPSBNYXRoLm1heChiYXRjaEVuZFRpbWUsIGRhdGFbaV0udGltZXN0YW1wKTtcbiAgICAgICAgICAgIGlmIChkYXRhW2ldLnR5cGUgPT09IEV2ZW50VHlwZS5GdWxsU25hcHNob3QpIHtcbiAgICAgICAgICAgICAgICBoYXNGdWxsU25hcHNob3QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2VxTm8gPT09IDApIHtcbiAgICAgICAgICAgIGlmICghaGFzRnVsbFNuYXBzaG90KSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soe2Vycm9yOiAnRmlyc3QgYmF0Y2ggZG9lcyBub3QgY29udGFpbiBhIGZ1bGwgc25hcHNob3QuIEFib3J0aW5nIHJlY29yZGluZy4nfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wUmVjb3JkaW5nKHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVwbGF5U3RhcnRUaW1lID0gYmF0Y2hTdGFydFRpbWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMucmVwbGF5U3RhcnRUaW1lKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdSZXBsYXkgc3RhcnQgdGltZSBub3Qgc2V0IGJ1dCBzZXFObyBpcyBub3QgMC4gVXNpbmcgY3VycmVudCBiYXRjaCBzdGFydCB0aW1lIGFzIGEgZmFsbGJhY2suJyk7XG4gICAgICAgICAgICB0aGlzLnJlcGxheVN0YXJ0VGltZSA9IGJhdGNoU3RhcnRUaW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlcGxheUxlbmd0aE1zID0gYmF0Y2hFbmRUaW1lIC0gdGhpcy5yZXBsYXlTdGFydFRpbWU7XG5cbiAgICAgICAgdmFyIHJlcVBhcmFtcyA9IHtcbiAgICAgICAgICAgICckY3VycmVudF91cmwnOiB0aGlzLmJhdGNoU3RhcnRVcmwsXG4gICAgICAgICAgICAnJGxpYl92ZXJzaW9uJzogQ29uZmlnLkxJQl9WRVJTSU9OLFxuICAgICAgICAgICAgJ2JhdGNoX3N0YXJ0X3RpbWUnOiBiYXRjaFN0YXJ0VGltZSAvIDEwMDAsXG4gICAgICAgICAgICAnbXBfbGliJzogJ3dlYicsXG4gICAgICAgICAgICAncmVwbGF5X2lkJzogcmVwbGF5SWQsXG4gICAgICAgICAgICAncmVwbGF5X2xlbmd0aF9tcyc6IHJlcGxheUxlbmd0aE1zLFxuICAgICAgICAgICAgJ3JlcGxheV9zdGFydF90aW1lJzogdGhpcy5yZXBsYXlTdGFydFRpbWUgLyAxMDAwLFxuICAgICAgICAgICAgJ3JlcGxheV9zdGFydF91cmwnOiB0aGlzLnJlcGxheVN0YXJ0VXJsLFxuICAgICAgICAgICAgJ3NlcSc6IHRoaXMuc2VxTm9cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGV2ZW50c0pzb24gPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihyZXFQYXJhbXMsIHRoaXMuZ2V0VXNlcklkSW5mbygpKTtcblxuICAgICAgICBpZiAoY2FuVXNlQ29tcHJlc3Npb25TdHJlYW0odXNlckFnZW50LCBuYXZpZ2F0b3IudmVuZG9yLCB3aW5kb3dPcGVyYSkpIHtcbiAgICAgICAgICAgIHZhciBqc29uU3RyZWFtID0gbmV3IEJsb2IoW2V2ZW50c0pzb25dLCB7dHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nfSkuc3RyZWFtKCk7XG4gICAgICAgICAgICB2YXIgZ3ppcFN0cmVhbSA9IGpzb25TdHJlYW0ucGlwZVRocm91Z2gobmV3IENvbXByZXNzaW9uU3RyZWFtKCdnemlwJykpO1xuICAgICAgICAgICAgbmV3IFJlc3BvbnNlKGd6aXBTdHJlYW0pXG4gICAgICAgICAgICAgICAgLmJsb2IoKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGNvbXByZXNzZWRCbG9iKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcVBhcmFtc1snZm9ybWF0J10gPSAnZ3ppcCc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbmRSZXF1ZXN0KHJlcGxheUlkLCByZXFQYXJhbXMsIGNvbXByZXNzZWRCbG9iLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcVBhcmFtc1snZm9ybWF0J10gPSAnYm9keSc7XG4gICAgICAgICAgICB0aGlzLl9zZW5kUmVxdWVzdChyZXBsYXlJZCwgcmVxUGFyYW1zLCBldmVudHNKc29uLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5yZXBvcnRFcnJvciA9IGZ1bmN0aW9uKG1zZywgZXJyKSB7XG4gICAgbG9nZ2VyJDMuZXJyb3IuYXBwbHkobG9nZ2VyJDMuZXJyb3IsIGFyZ3VtZW50cyk7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKCFlcnIgJiYgIShtc2cgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICAgIG1zZyA9IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2V0Q29uZmlnKCdlcnJvcl9yZXBvcnRlcicpKG1zZywgZXJyKTtcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgICBsb2dnZXIkMy5lcnJvcihlcnIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZHVyYXRpb24gb2YgdGhlIHJlY29yZGluZyBpbiBtaWxsaXNlY29uZHMsIGJhc2VkIG9uIHRoZSBzdGFydCB0aW1lIGFuZCB0aW1lIG9mIGxhc3QgcmVjb3JkZWQgZXZlbnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgZHVyYXRpb24gb2YgdGhlIHJlY29yZGluZyBpbiBtaWxsaXNlY29uZHMuIFJldHVybnMgMCBpZiByZWNvcmRpbmcgaGFzbid0IHN0YXJ0ZWQuXG4gKi9cblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLmdldER1cmF0aW9uTXMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5yZXBsYXlTdGFydFRpbWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHJlY29yZGluZyBoYXMgbm8gZXZlbnRzLCBhc3N1bWUgaXQgaXMgaW4gcHJvZ3Jlc3MgYW5kIHVzZSB0aGUgY3VycmVudCB0aW1lIGFzIHRoZSBlbmQgdGltZS5cbiAgICBpZiAodGhpcy5sYXN0RXZlbnRUaW1lc3RhbXAgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5yZXBsYXlTdGFydFRpbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubGFzdEV2ZW50VGltZXN0YW1wIC0gdGhpcy5yZXBsYXlTdGFydFRpbWU7XG59O1xuXG4vKipcbiAqIExhemlseSBsb2FkcyB0aGUgbWluaW11bSByZWNvcmRpbmcgbGVuZ3RoIGNvbmZpZyBpbiBtaWxsaXNlY29uZHMsIHJlc3BlY3RpbmcgdGhlIG1heGltdW0gbGltaXQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbWluaW11bSByZWNvcmRpbmcgbGVuZ3RoIGluIG1pbGxpc2Vjb25kcy5cbiAqL1xuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUuX2dldFJlY29yZE1pbk1zID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbmZpZ1ZhbHVlID0gdGhpcy5nZXRDb25maWcoJ3JlY29yZF9taW5fbXMnKTtcblxuICAgIGlmIChjb25maWdWYWx1ZSA+IE1BWF9WQUxVRV9GT1JfTUlOX1JFQ09SRElOR19NUykge1xuICAgICAgICBsb2dnZXIkMy5jcml0aWNhbCgncmVjb3JkX21pbl9tcyBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuICcgKyBNQVhfVkFMVUVfRk9SX01JTl9SRUNPUkRJTkdfTVMgKyAnbXMuIENhcHBpbmcgdmFsdWUuJyk7XG4gICAgICAgIHJldHVybiBNQVhfVkFMVUVfRk9SX01JTl9SRUNPUkRJTkdfTVM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmZpZ1ZhbHVlO1xufTtcblxuLyoqXG4gKiBNb2R1bGUgZm9yIGhhbmRsaW5nIHRoZSBzdG9yYWdlIGFuZCByZXRyaWV2YWwgb2YgcmVjb3JkaW5nIG1ldGFkYXRhIGFzIHdlbGwgYXMgYW55IGFjdGl2ZSByZWNvcmRpbmdzLlxuICogTWFrZXMgc3VyZSB0aGF0IG9ubHkgb25lIHRhYiBjYW4gYmUgcmVjb3JkaW5nIGF0IGEgdGltZS5cbiAqL1xudmFyIFJlY29yZGluZ1JlZ2lzdHJ5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAvKiogQHR5cGUge0lEQlN0b3JhZ2VXcmFwcGVyfSAqL1xuICAgIHRoaXMuaWRiID0gbmV3IElEQlN0b3JhZ2VXcmFwcGVyKFJFQ09SRElOR19SRUdJU1RSWV9TVE9SRV9OQU1FKTtcbiAgICB0aGlzLmVycm9yUmVwb3J0ZXIgPSBvcHRpb25zLmVycm9yUmVwb3J0ZXI7XG4gICAgdGhpcy5taXhwYW5lbEluc3RhbmNlID0gb3B0aW9ucy5taXhwYW5lbEluc3RhbmNlO1xuICAgIHRoaXMuc2hhcmVkTG9ja1N0b3JhZ2UgPSBvcHRpb25zLnNoYXJlZExvY2tTdG9yYWdlO1xufTtcblxuUmVjb3JkaW5nUmVnaXN0cnkucHJvdG90eXBlLmlzUGVyc2lzdGVuY2VFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICF0aGlzLm1peHBhbmVsSW5zdGFuY2UuZ2V0X2NvbmZpZygnZGlzYWJsZV9wZXJzaXN0ZW5jZScpO1xufTtcblxuUmVjb3JkaW5nUmVnaXN0cnkucHJvdG90eXBlLmhhbmRsZUVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgIHRoaXMuZXJyb3JSZXBvcnRlcignSW5kZXhlZERCIGVycm9yOiAnLCBlcnIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9zZXNzaW9uLXJlY29yZGluZycpLlNlcmlhbGl6ZWRSZWNvcmRpbmd9IHNlcmlhbGl6ZWRSZWNvcmRpbmdcbiAqL1xuUmVjb3JkaW5nUmVnaXN0cnkucHJvdG90eXBlLnNldEFjdGl2ZVJlY29yZGluZyA9IGZ1bmN0aW9uIChzZXJpYWxpemVkUmVjb3JkaW5nKSB7XG4gICAgaWYgKCF0aGlzLmlzUGVyc2lzdGVuY2VFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgdmFyIHRhYklkID0gc2VyaWFsaXplZFJlY29yZGluZ1sndGFiSWQnXTtcbiAgICBpZiAoIXRhYklkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignTm8gdGFiIElEIGlzIHNldCwgY2Fubm90IHBlcnNpc3QgcmVjb3JkaW5nIG1ldGFkYXRhLicpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5pZGIuaW5pdCgpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlkYi5zZXRJdGVtKHRhYklkLCBzZXJpYWxpemVkUmVjb3JkaW5nKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAuY2F0Y2godGhpcy5oYW5kbGVFcnJvci5iaW5kKHRoaXMpKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge1Byb21pc2U8aW1wb3J0KCcuL3Nlc3Npb24tcmVjb3JkaW5nJykuU2VyaWFsaXplZFJlY29yZGluZz59XG4gKi9cblJlY29yZGluZ1JlZ2lzdHJ5LnByb3RvdHlwZS5nZXRBY3RpdmVSZWNvcmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzUGVyc2lzdGVuY2VFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKG51bGwpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmlkYi5pbml0KClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWRiLmdldEl0ZW0odGhpcy5taXhwYW5lbEluc3RhbmNlLmdldF90YWJfaWQoKSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHNlcmlhbGl6ZWRSZWNvcmRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1JlY29yZGluZ0V4cGlyZWQoc2VyaWFsaXplZFJlY29yZGluZykgPyBudWxsIDogc2VyaWFsaXplZFJlY29yZGluZztcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAuY2F0Y2godGhpcy5oYW5kbGVFcnJvci5iaW5kKHRoaXMpKTtcbn07XG5cblJlY29yZGluZ1JlZ2lzdHJ5LnByb3RvdHlwZS5jbGVhckFjdGl2ZVJlY29yZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pc1BlcnNpc3RlbmNlRW5hYmxlZCgpKSB7XG4gICAgICAgIC8vIG1hcmsgcmVjb3JkaW5nIGFzIGV4cGlyZWQgaW5zdGVhZCBvZiBkZWxldGluZyBpdCBpbiBjYXNlIHRoZSBwYWdlIHVubG9hZHMgbWlkLWZsdXNoIGFuZCBkb2Vzbid0IG1ha2UgaXQgdG8gaW5nZXN0aW9uLlxuICAgICAgICAvLyB0aGlzIHdpbGwgZW5zdXJlIHRoZSBuZXh0IHBhZ2Vsb2FkIHdpbGwgZmx1c2ggdGhlIHJlbWFpbmluZyBldmVudHMsIGJ1dCBub3QgdHJ5IHRvIGNvbnRpbnVlIHRoZSByZWNvcmRpbmcuXG4gICAgICAgIHJldHVybiB0aGlzLm1hcmtBY3RpdmVSZWNvcmRpbmdFeHBpcmVkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZXRlQWN0aXZlUmVjb3JkaW5nKCk7XG4gICAgfVxufTtcblxuUmVjb3JkaW5nUmVnaXN0cnkucHJvdG90eXBlLm1hcmtBY3RpdmVSZWNvcmRpbmdFeHBpcmVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldEFjdGl2ZVJlY29yZGluZygpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChzZXJpYWxpemVkUmVjb3JkaW5nKSB7XG4gICAgICAgICAgICBpZiAoc2VyaWFsaXplZFJlY29yZGluZykge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWRSZWNvcmRpbmdbJ21heEV4cGlyZXMnXSA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0QWN0aXZlUmVjb3JkaW5nKHNlcmlhbGl6ZWRSZWNvcmRpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC5jYXRjaCh0aGlzLmhhbmRsZUVycm9yLmJpbmQodGhpcykpO1xufTtcblxuUmVjb3JkaW5nUmVnaXN0cnkucHJvdG90eXBlLmRlbGV0ZUFjdGl2ZVJlY29yZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBhdm9pZCBpbml0aWFsaXppbmcgSURCIGlmIHRoaXMgcmVnaXN0cnkgaW5zdGFuY2UgaGFzbid0IGFscmVhZHkgd3JpdHRlbiBhIHJlY29yZGluZ1xuICAgIGlmICh0aGlzLmlkYi5pc0luaXRpYWxpemVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWRiLnJlbW92ZUl0ZW0odGhpcy5taXhwYW5lbEluc3RhbmNlLmdldF90YWJfaWQoKSlcbiAgICAgICAgICAgIC5jYXRjaCh0aGlzLmhhbmRsZUVycm9yLmJpbmQodGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogRmx1c2ggYW55IGluYWN0aXZlIHJlY29yZGluZ3MgZnJvbSB0aGUgcmVnaXN0cnkgdG8gbWluaW1pemUgZGF0YSBsb3NzLlxuICogVGhlIG1haW4gaWRlYSBoZXJlIGlzIHRoYXQgd2UgY2FuIGZsdXNoIHJlbWFpbmluZyBycndlYiBldmVudHMgb24gdGhlIG5leHQgcGFnZSBsb2FkIGlmIGEgdGFiIGlzIGNsb3NlZCBtaWQtYmF0Y2guXG4gKi9cblJlY29yZGluZ1JlZ2lzdHJ5LnByb3RvdHlwZS5mbHVzaEluYWN0aXZlUmVjb3JkaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaXNQZXJzaXN0ZW5jZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoW10pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmlkYi5pbml0KClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pZGIuZ2V0QWxsKCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHNlcmlhbGl6ZWRSZWNvcmRpbmdzKSB7XG4gICAgICAgICAgICAvLyBjbGVhbiB1cCBhbnkgZXhwaXJlZCByZWNvcmRpbmdzIGZyb20gdGhlIHJlZ2lzdHJ5LCBub24tZXhwaXJlZCBvbmVzIG1heSBiZSBhY3RpdmUgaW4gb3RoZXIgdGFic1xuICAgICAgICAgICAgdmFyIHVubG9hZFByb21pc2VzID0gc2VyaWFsaXplZFJlY29yZGluZ3NcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChzZXJpYWxpemVkUmVjb3JkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc1JlY29yZGluZ0V4cGlyZWQoc2VyaWFsaXplZFJlY29yZGluZyk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzZXJpYWxpemVkUmVjb3JkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXNzaW9uUmVjb3JkaW5nID0gU2Vzc2lvblJlY29yZGluZy5kZXNlcmlhbGl6ZShzZXJpYWxpemVkUmVjb3JkaW5nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaXhwYW5lbEluc3RhbmNlOiB0aGlzLm1peHBhbmVsSW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFyZWRMb2NrU3RvcmFnZTogdGhpcy5zaGFyZWRMb2NrU3RvcmFnZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlc3Npb25SZWNvcmRpbmcudW5sb2FkUGVyc2lzdGVkRGF0YSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhwaXJlZCByZWNvcmRpbmcgd2FzIHN1Y2Nlc3NmdWxseSBmbHVzaGVkLCB3ZSBjYW4gY2xlYW4gaXQgdXAgZnJvbSB0aGUgcmVnaXN0cnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pZGIucmVtb3ZlSXRlbShzZXJpYWxpemVkUmVjb3JkaW5nWyd0YWJJZCddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCh0aGlzLmhhbmRsZUVycm9yLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwuYWxsKHVubG9hZFByb21pc2VzKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAuY2F0Y2godGhpcy5oYW5kbGVFcnJvci5iaW5kKHRoaXMpKTtcbn07XG5cbnZhciBsb2dnZXIkMiA9IGNvbnNvbGVfd2l0aF9wcmVmaXgoJ3JlY29yZGVyJyk7XG5cbi8qKlxuICogUmVjb3JkZXIgQVBJOiBidW5kbGVzIHJyd2ViIGFuZCBhbmQgZXhwb3NlcyBtZXRob2RzIHRvIHN0YXJ0IGFuZCBzdG9wIHJlY29yZGluZ3MuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubWl4cGFuZWxJbnN0YW5jZV0gLSByZWZlcmVuY2UgdG8gdGhlIGNvcmUgTWl4cGFuZWxMaWJcbiovXG52YXIgTWl4cGFuZWxSZWNvcmRlciA9IGZ1bmN0aW9uKG1peHBhbmVsSW5zdGFuY2UsIHJyd2ViUmVjb3JkLCBzaGFyZWRMb2NrU3RvcmFnZSkge1xuICAgIHRoaXMubWl4cGFuZWxJbnN0YW5jZSA9IG1peHBhbmVsSW5zdGFuY2U7XG4gICAgdGhpcy5ycndlYlJlY29yZCA9IHJyd2ViUmVjb3JkIHx8IHJlY29yZDtcbiAgICB0aGlzLnNoYXJlZExvY2tTdG9yYWdlID0gc2hhcmVkTG9ja1N0b3JhZ2U7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtpbXBvcnQoJy4vcmVnaXN0cnknKS5SZWNvcmRpbmdSZWdpc3RyeX1cbiAgICAgKi9cbiAgICB0aGlzLnJlY29yZGluZ1JlZ2lzdHJ5ID0gbmV3IFJlY29yZGluZ1JlZ2lzdHJ5KHtcbiAgICAgICAgbWl4cGFuZWxJbnN0YW5jZTogdGhpcy5taXhwYW5lbEluc3RhbmNlLFxuICAgICAgICBlcnJvclJlcG9ydGVyOiBsb2dnZXIkMi5lcnJvcixcbiAgICAgICAgc2hhcmVkTG9ja1N0b3JhZ2U6IHNoYXJlZExvY2tTdG9yYWdlXG4gICAgfSk7XG4gICAgdGhpcy5fZmx1c2hJbmFjdGl2ZVByb21pc2UgPSB0aGlzLnJlY29yZGluZ1JlZ2lzdHJ5LmZsdXNoSW5hY3RpdmVSZWNvcmRpbmdzKCk7XG5cbiAgICB0aGlzLmFjdGl2ZVJlY29yZGluZyA9IG51bGw7XG4gICAgdGhpcy5zdG9wUmVjb3JkaW5nSW5Qcm9ncmVzcyA9IGZhbHNlO1xufTtcblxuTWl4cGFuZWxSZWNvcmRlci5wcm90b3R5cGUuc3RhcnRSZWNvcmRpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKHRoaXMuYWN0aXZlUmVjb3JkaW5nICYmICF0aGlzLmFjdGl2ZVJlY29yZGluZy5pc1Jyd2ViU3RvcHBlZCgpKSB7XG4gICAgICAgIGxvZ2dlciQyLmxvZygnUmVjb3JkaW5nIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHNraXBwaW5nIHN0YXJ0UmVjb3JkaW5nLicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG9uSWRsZVRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlciQyLmxvZygnSWRsZSB0aW1lb3V0IHJlYWNoZWQsIHJlc3RhcnRpbmcgcmVjb3JkaW5nLicpO1xuICAgICAgICB0aGlzLnJlc2V0UmVjb3JkaW5nKCk7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgdmFyIG9uTWF4TGVuZ3RoUmVhY2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyJDIubG9nKCdNYXggcmVjb3JkaW5nIGxlbmd0aCByZWFjaGVkLCBzdG9wcGluZyByZWNvcmRpbmcuJyk7XG4gICAgICAgIHRoaXMucmVzZXRSZWNvcmRpbmcoKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB2YXIgb25CYXRjaFNlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVjb3JkaW5nUmVnaXN0cnkuc2V0QWN0aXZlUmVjb3JkaW5nKHRoaXMuYWN0aXZlUmVjb3JkaW5nLnNlcmlhbGl6ZSgpKTtcbiAgICAgICAgdGhpc1snX19mbHVzaFByb21pc2UnXSA9IHRoaXMuYWN0aXZlUmVjb3JkaW5nLmJhdGNoZXIuX2ZsdXNoUHJvbWlzZTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KCcuL3Nlc3Npb24tcmVjb3JkaW5nJykuU2Vzc2lvblJlY29yZGluZ09wdGlvbnN9XG4gICAgICovXG4gICAgdmFyIHNlc3Npb25SZWNvcmRpbmdPcHRpb25zID0ge1xuICAgICAgICBtaXhwYW5lbEluc3RhbmNlOiB0aGlzLm1peHBhbmVsSW5zdGFuY2UsXG4gICAgICAgIG9uQmF0Y2hTZW50OiBvbkJhdGNoU2VudCxcbiAgICAgICAgb25JZGxlVGltZW91dDogb25JZGxlVGltZW91dCxcbiAgICAgICAgb25NYXhMZW5ndGhSZWFjaGVkOiBvbk1heExlbmd0aFJlYWNoZWQsXG4gICAgICAgIHJlcGxheUlkOiBfLlVVSUQoKSxcbiAgICAgICAgcnJ3ZWJSZWNvcmQ6IHRoaXMucnJ3ZWJSZWNvcmQsXG4gICAgICAgIHNoYXJlZExvY2tTdG9yYWdlOiB0aGlzLnNoYXJlZExvY2tTdG9yYWdlXG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLmFjdGl2ZVNlcmlhbGl6ZWRSZWNvcmRpbmcpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVSZWNvcmRpbmcgPSBTZXNzaW9uUmVjb3JkaW5nLmRlc2VyaWFsaXplKG9wdGlvbnMuYWN0aXZlU2VyaWFsaXplZFJlY29yZGluZywgc2Vzc2lvblJlY29yZGluZ09wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWN0aXZlUmVjb3JkaW5nID0gbmV3IFNlc3Npb25SZWNvcmRpbmcoc2Vzc2lvblJlY29yZGluZ09wdGlvbnMpO1xuICAgIH1cblxuICAgIHRoaXMuYWN0aXZlUmVjb3JkaW5nLnN0YXJ0UmVjb3JkaW5nKG9wdGlvbnMuc2hvdWxkU3RvcEJhdGNoZXIpO1xuICAgIHJldHVybiB0aGlzLnJlY29yZGluZ1JlZ2lzdHJ5LnNldEFjdGl2ZVJlY29yZGluZyh0aGlzLmFjdGl2ZVJlY29yZGluZy5zZXJpYWxpemUoKSk7XG59O1xuXG5NaXhwYW5lbFJlY29yZGVyLnByb3RvdHlwZS5zdG9wUmVjb3JkaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gUHJldmVudHMgYWN0aXZlU2VyaWFsaXplZFJlY29yZGluZyBmcm9tIGJlaW5nIHJldXNlZCB3aGVuIHN0b3BwaW5nIHRoZSByZWNvcmRpbmcuXG4gICAgdGhpcy5zdG9wUmVjb3JkaW5nSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3BDdXJyZW50UmVjb3JkaW5nKGZhbHNlLCB0cnVlKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWNvcmRpbmdSZWdpc3RyeS5jbGVhckFjdGl2ZVJlY29yZGluZygpO1xuICAgIH0uYmluZCh0aGlzKSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zdG9wUmVjb3JkaW5nSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgIH0uYmluZCh0aGlzKSk7XG59O1xuXG5NaXhwYW5lbFJlY29yZGVyLnByb3RvdHlwZS5wYXVzZVJlY29yZGluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9zdG9wQ3VycmVudFJlY29yZGluZyhmYWxzZSk7XG59O1xuXG5NaXhwYW5lbFJlY29yZGVyLnByb3RvdHlwZS5fc3RvcEN1cnJlbnRSZWNvcmRpbmcgPSBmdW5jdGlvbihza2lwRmx1c2gsIGRpc2FibGVBY3RpdmVSZWNvcmRpbmcpIHtcbiAgICBpZiAodGhpcy5hY3RpdmVSZWNvcmRpbmcpIHtcbiAgICAgICAgdmFyIHN0b3BSZWNvcmRpbmdQcm9taXNlID0gdGhpcy5hY3RpdmVSZWNvcmRpbmcuc3RvcFJlY29yZGluZyhza2lwRmx1c2gpO1xuICAgICAgICBpZiAoZGlzYWJsZUFjdGl2ZVJlY29yZGluZykge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVSZWNvcmRpbmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdG9wUmVjb3JkaW5nUHJvbWlzZTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG59O1xuXG5NaXhwYW5lbFJlY29yZGVyLnByb3RvdHlwZS5yZXN1bWVSZWNvcmRpbmcgPSBmdW5jdGlvbiAoc3RhcnROZXdJZkluYWN0aXZlKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlUmVjb3JkaW5nICYmIHRoaXMuYWN0aXZlUmVjb3JkaW5nLmlzUnJ3ZWJTdG9wcGVkKCkpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVSZWNvcmRpbmcuc3RhcnRSZWNvcmRpbmcoZmFsc2UpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUobnVsbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVjb3JkaW5nUmVnaXN0cnkuZ2V0QWN0aXZlUmVjb3JkaW5nKClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGFjdGl2ZVNlcmlhbGl6ZWRSZWNvcmRpbmcpIHtcbiAgICAgICAgICAgIGlmIChhY3RpdmVTZXJpYWxpemVkUmVjb3JkaW5nICYmICF0aGlzLnN0b3BSZWNvcmRpbmdJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRSZWNvcmRpbmcoe2FjdGl2ZVNlcmlhbGl6ZWRSZWNvcmRpbmc6IGFjdGl2ZVNlcmlhbGl6ZWRSZWNvcmRpbmd9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnROZXdJZkluYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRSZWNvcmRpbmcoe3Nob3VsZFN0b3BCYXRjaGVyOiBmYWxzZX0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkMi5sb2coJ05vIHJlc3VtYWJsZSByZWNvcmRpbmcgZm91bmQuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG59O1xuXG5cbk1peHBhbmVsUmVjb3JkZXIucHJvdG90eXBlLnJlc2V0UmVjb3JkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc3RvcFJlY29yZGluZygpO1xuICAgIHRoaXMuc3RhcnRSZWNvcmRpbmcoe3Nob3VsZFN0b3BCYXRjaGVyOiB0cnVlfSk7XG59O1xuXG5NaXhwYW5lbFJlY29yZGVyLnByb3RvdHlwZS5nZXRBY3RpdmVSZXBsYXlJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5hY3RpdmVSZWNvcmRpbmcgJiYgIXRoaXMuYWN0aXZlUmVjb3JkaW5nLmlzUnJ3ZWJTdG9wcGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlUmVjb3JkaW5nLnJlcGxheUlkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbi8vIGdldHRlciBzbyB0aGF0IG9sZGVyIG1peHBhbmVsLWNvcmUgdmVyc2lvbnMgY2FuIHN0aWxsIHJldHJpZXZlIHRoZSByZXBsYXkgSURcbi8vIHdoZW4gcHVsbGluZyB0aGUgbGF0ZXN0IHJlY29yZGVyIGJ1bmRsZSBmcm9tIHRoZSBDRE5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNaXhwYW5lbFJlY29yZGVyLnByb3RvdHlwZSwgJ3JlcGxheUlkJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBY3RpdmVSZXBsYXlJZCgpO1xuICAgIH1cbn0pO1xuXG53aW5bJ19fbXBfcmVjb3JkZXInXSA9IE1peHBhbmVsUmVjb3JkZXI7XG5cbi8vIHN0YXRlbGVzcyB1dGlsc1xuLy8gbW9zdGx5IGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21peHBhbmVsL21peHBhbmVsLWpzL2Jsb2IvOTg5YWRhNTBmNTE4ZWRhYjQ3YjljNGZkOTUzNWY5ZmJkNWVjNWZjMC9zcmMvYXV0b3RyYWNrLXV0aWxzLmpzXG5cblxudmFyIEVWX0NIQU5HRSA9ICdjaGFuZ2UnO1xudmFyIEVWX0NMSUNLID0gJ2NsaWNrJztcbnZhciBFVl9IQVNIQ0hBTkdFID0gJ2hhc2hjaGFuZ2UnO1xudmFyIEVWX0lOUFVUID0gJ2lucHV0JztcbnZhciBFVl9MT0FEID0gJ2xvYWQnO1xudmFyIEVWX01QX0xPQ0FUSU9OX0NIQU5HRSA9ICdtcF9sb2NhdGlvbmNoYW5nZSc7XG52YXIgRVZfUE9QU1RBVEUgPSAncG9wc3RhdGUnO1xuLy8gVE9ETyBzY3JvbGxlbmQgaXNuJ3QgYXZhaWxhYmxlIGluIFNhZmFyaTogZG9jdW1lbnQgb3IgcG9seWZpbGw/XG52YXIgRVZfU0NST0xMRU5EID0gJ3Njcm9sbGVuZCc7XG52YXIgRVZfU0NST0xMID0gJ3Njcm9sbCc7XG52YXIgRVZfU0VMRUNUID0gJ3NlbGVjdCc7XG52YXIgRVZfU1VCTUlUID0gJ3N1Ym1pdCc7XG52YXIgRVZfVE9HR0xFID0gJ3RvZ2dsZSc7XG52YXIgRVZfVklTSUJJTElUWUNIQU5HRSA9ICd2aXNpYmlsaXR5Y2hhbmdlJztcblxudmFyIENMSUNLX0VWRU5UX1BST1BTID0gW1xuICAgICdjbGllbnRYJywgJ2NsaWVudFknLFxuICAgICdvZmZzZXRYJywgJ29mZnNldFknLFxuICAgICdwYWdlWCcsICdwYWdlWScsXG4gICAgJ3NjcmVlblgnLCAnc2NyZWVuWScsXG4gICAgJ3gnLCAneSdcbl07XG52YXIgT1BUX0lOX0NMQVNTRVMgPSBbJ21wLWluY2x1ZGUnXTtcbnZhciBPUFRfT1VUX0NMQVNTRVMgPSBbJ21wLW5vLXRyYWNrJ107XG52YXIgU0VOU0lUSVZFX0RBVEFfQ0xBU1NFUyA9IE9QVF9PVVRfQ0xBU1NFUy5jb25jYXQoWydtcC1zZW5zaXRpdmUnXSk7XG52YXIgVFJBQ0tFRF9BVFRSUyA9IFtcbiAgICAnYXJpYS1sYWJlbCcsICdhcmlhLWxhYmVsbGVkYnknLCAnYXJpYS1kZXNjcmliZWRieScsXG4gICAgJ2hyZWYnLCAnbmFtZScsICdyb2xlJywgJ3RpdGxlJywgJ3R5cGUnXG5dO1xuXG52YXIgSU5URVJBQ1RJVkVfQVJJQV9ST0xFUyA9IHtcbiAgICAnYnV0dG9uJzogdHJ1ZSxcbiAgICAnY2hlY2tib3gnOiB0cnVlLFxuICAgICdjb21ib2JveCc6IHRydWUsXG4gICAgJ2dyaWQnOiB0cnVlLFxuICAgICdsaW5rJzogdHJ1ZSxcbiAgICAnbGlzdGJveCc6IHRydWUsXG4gICAgJ21lbnUnOiB0cnVlLFxuICAgICdtZW51YmFyJzogdHJ1ZSxcbiAgICAnbWVudWl0ZW0nOiB0cnVlLFxuICAgICdtZW51aXRlbWNoZWNrYm94JzogdHJ1ZSxcbiAgICAnbWVudWl0ZW1yYWRpbyc6IHRydWUsXG4gICAgJ25hdmlnYXRpb24nOiB0cnVlLFxuICAgICdvcHRpb24nOiB0cnVlLFxuICAgICdyYWRpbyc6IHRydWUsXG4gICAgJ3JhZGlvZ3JvdXAnOiB0cnVlLFxuICAgICdzZWFyY2hib3gnOiB0cnVlLFxuICAgICdzbGlkZXInOiB0cnVlLFxuICAgICdzcGluYnV0dG9uJzogdHJ1ZSxcbiAgICAnc3dpdGNoJzogdHJ1ZSxcbiAgICAndGFiJzogdHJ1ZSxcbiAgICAndGFibGlzdCc6IHRydWUsXG4gICAgJ3RleHRib3gnOiB0cnVlLFxuICAgICd0cmVlJzogdHJ1ZSxcbiAgICAndHJlZWdyaWQnOiB0cnVlLFxuICAgICd0cmVlaXRlbSc6IHRydWVcbn07XG5cbnZhciBBTFdBWVNfTk9OX0lOVEVSQUNUSVZFX1RBR1MgPSB7XG4gICAgLy8gRG9jdW1lbnQgbWV0YWRhdGFcbiAgICAnYmFzZSc6IHRydWUsXG4gICAgJ2hlYWQnOiB0cnVlLFxuICAgICdodG1sJzogdHJ1ZSxcbiAgICAnbGluayc6IHRydWUsXG4gICAgJ21ldGEnOiB0cnVlLFxuICAgICdzY3JpcHQnOiB0cnVlLFxuICAgICdzdHlsZSc6IHRydWUsXG4gICAgJ3RpdGxlJzogdHJ1ZSxcbiAgICAvLyBUZXh0IGZvcm1hdHRpbmdcbiAgICAnYnInOiB0cnVlLFxuICAgICdocic6IHRydWUsXG4gICAgJ3dicic6IHRydWUsXG4gICAgLy8gT3RoZXJcbiAgICAnbm9zY3JpcHQnOiB0cnVlLFxuICAgICdwaWN0dXJlJzogdHJ1ZSxcbiAgICAnc291cmNlJzogdHJ1ZSxcbiAgICAndGVtcGxhdGUnOiB0cnVlLFxuICAgICd0cmFjayc6IHRydWVcbn07XG5cbi8vIENvbW1vbiBjb250YWluZXIgdGFncyB0aGF0IG5lZWQgYWRkaXRpb25hbCBjaGVja3NcbnZhciBURVhUX0NPTlRBSU5FUl9UQUdTID0ge1xuICAgICdhcnRpY2xlJzogdHJ1ZSxcbiAgICAnZGl2JzogdHJ1ZSxcbiAgICAnaDEnOiB0cnVlLFxuICAgICdoMic6IHRydWUsXG4gICAgJ2gzJzogdHJ1ZSxcbiAgICAnaDQnOiB0cnVlLFxuICAgICdoNSc6IHRydWUsXG4gICAgJ2g2JzogdHJ1ZSxcbiAgICAncCc6IHRydWUsXG4gICAgJ3NlY3Rpb24nOiB0cnVlLFxuICAgICdzcGFuJzogdHJ1ZVxufTtcblxudmFyIEVWRU5UX0hBTkRMRVJfQVRUUklCVVRFUyA9IFtcbiAgICAnb25jbGljaycsICdvbm1vdXNlZG93bicsICdvbm1vdXNldXAnLCAnb25wb2ludGVyZG93bicsICdvbnBvaW50ZXJ1cCcsICdvbnRvdWNoZW5kJywgJ29udG91Y2hzdGFydCdcbl07XG5cbnZhciBNQVhfREVQVEggPSA1O1xuXG52YXIgbG9nZ2VyJDEgPSBjb25zb2xlX3dpdGhfcHJlZml4KCdhdXRvY2FwdHVyZScpO1xuXG5cbmZ1bmN0aW9uIGdldENsYXNzZXMoZWwpIHtcbiAgICB2YXIgY2xhc3NlcyA9IHt9O1xuICAgIHZhciBjbGFzc0xpc3QgPSBnZXRDbGFzc05hbWUoZWwpLnNwbGl0KCcgJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGFzc0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNscyA9IGNsYXNzTGlzdFtpXTtcbiAgICAgICAgaWYgKGNscykge1xuICAgICAgICAgICAgY2xhc3Nlc1tjbHNdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xhc3Nlcztcbn1cblxuLypcbiAqIEdldCB0aGUgY2xhc3NOYW1lIG9mIGFuIGVsZW1lbnQsIGFjY291bnRpbmcgZm9yIGVkZ2UgY2FzZXMgd2hlcmUgZWxlbWVudC5jbGFzc05hbWUgaXMgYW4gb2JqZWN0XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsIC0gZWxlbWVudCB0byBnZXQgdGhlIGNsYXNzTmFtZSBvZlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGVsZW1lbnQncyBjbGFzc1xuICovXG5mdW5jdGlvbiBnZXRDbGFzc05hbWUoZWwpIHtcbiAgICBzd2l0Y2godHlwZW9mIGVsLmNsYXNzTmFtZSkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIGVsLmNsYXNzTmFtZTtcbiAgICAgICAgY2FzZSAnb2JqZWN0JzogLy8gaGFuZGxlIGNhc2VzIHdoZXJlIGNsYXNzTmFtZSBtaWdodCBiZSBTVkdBbmltYXRlZFN0cmluZyBvciBzb21lIG90aGVyIHR5cGVcbiAgICAgICAgICAgIHJldHVybiBlbC5jbGFzc05hbWUuYmFzZVZhbCB8fCBlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJyc7XG4gICAgICAgIGRlZmF1bHQ6IC8vIGZ1dHVyZSBwcm9vZlxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0UHJldmlvdXNFbGVtZW50U2libGluZyhlbCkge1xuICAgIGlmIChlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSB7XG4gICAgICAgIHJldHVybiBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGVsID0gZWwucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICB9IHdoaWxlIChlbCAmJiAhaXNFbGVtZW50Tm9kZShlbCkpO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRQcm9wZXJ0aWVzRnJvbUVsZW1lbnQoZWwsIGV2LCBibG9ja0F0dHJzU2V0LCBleHRyYUF0dHJzLCBhbGxvd0VsZW1lbnRDYWxsYmFjaywgYWxsb3dTZWxlY3RvcnMpIHtcbiAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICckY2xhc3Nlcyc6IGdldENsYXNzTmFtZShlbCkuc3BsaXQoJyAnKSxcbiAgICAgICAgJyR0YWdfbmFtZSc6IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKVxuICAgIH07XG4gICAgdmFyIGVsSWQgPSBlbC5pZDtcbiAgICBpZiAoZWxJZCkge1xuICAgICAgICBwcm9wc1snJGlkJ10gPSBlbElkO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja0VsZW1lbnREZXRhaWxzKGVsLCBldiwgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKSkge1xuICAgICAgICBfLmVhY2goVFJBQ0tFRF9BVFRSUy5jb25jYXQoZXh0cmFBdHRycyksIGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoYXR0cikgJiYgIWJsb2NrQXR0cnNTZXRbYXR0cl0pIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0clZhbCA9IGVsLmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkVHJhY2tWYWx1ZShhdHRyVmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wc1snJGF0dHItJyArIGF0dHJdID0gYXR0clZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBudGhDaGlsZCA9IDE7XG4gICAgdmFyIG50aE9mVHlwZSA9IDE7XG4gICAgdmFyIGN1cnJlbnRFbGVtID0gZWw7XG4gICAgd2hpbGUgKGN1cnJlbnRFbGVtID0gZ2V0UHJldmlvdXNFbGVtZW50U2libGluZyhjdXJyZW50RWxlbSkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25kLWFzc2lnblxuICAgICAgICBudGhDaGlsZCsrO1xuICAgICAgICBpZiAoY3VycmVudEVsZW0udGFnTmFtZSA9PT0gZWwudGFnTmFtZSkge1xuICAgICAgICAgICAgbnRoT2ZUeXBlKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvcHNbJyRudGhfY2hpbGQnXSA9IG50aENoaWxkO1xuICAgIHByb3BzWyckbnRoX29mX3R5cGUnXSA9IG50aE9mVHlwZTtcblxuICAgIHJldHVybiBwcm9wcztcbn1cblxuZnVuY3Rpb24gZ2V0UHJvcHNGb3JET01FdmVudChldiwgY29uZmlnKSB7XG4gICAgdmFyIGFsbG93RWxlbWVudENhbGxiYWNrID0gY29uZmlnLmFsbG93RWxlbWVudENhbGxiYWNrO1xuICAgIHZhciBhbGxvd1NlbGVjdG9ycyA9IGNvbmZpZy5hbGxvd1NlbGVjdG9ycyB8fCBbXTtcbiAgICB2YXIgYmxvY2tBdHRycyA9IGNvbmZpZy5ibG9ja0F0dHJzIHx8IFtdO1xuICAgIHZhciBibG9ja0VsZW1lbnRDYWxsYmFjayA9IGNvbmZpZy5ibG9ja0VsZW1lbnRDYWxsYmFjaztcbiAgICB2YXIgYmxvY2tTZWxlY3RvcnMgPSBjb25maWcuYmxvY2tTZWxlY3RvcnMgfHwgW107XG4gICAgdmFyIGNhcHR1cmVUZXh0Q29udGVudCA9IGNvbmZpZy5jYXB0dXJlVGV4dENvbnRlbnQgfHwgZmFsc2U7XG4gICAgdmFyIGNhcHR1cmVFeHRyYUF0dHJzID0gY29uZmlnLmNhcHR1cmVFeHRyYUF0dHJzIHx8IFtdO1xuICAgIHZhciBjYXB0dXJlZEZvckhlYXRNYXAgPSBjb25maWcuY2FwdHVyZWRGb3JIZWF0TWFwIHx8IGZhbHNlO1xuXG4gICAgLy8gY29udmVydCBhcnJheSB0byBzZXQgZXZlcnkgdGltZSwgYXMgdGhlIGNvbmZpZyBtYXkgaGF2ZSBjaGFuZ2VkXG4gICAgdmFyIGJsb2NrQXR0cnNTZXQgPSB7fTtcbiAgICBfLmVhY2goYmxvY2tBdHRycywgZnVuY3Rpb24oYXR0cikge1xuICAgICAgICBibG9ja0F0dHJzU2V0W2F0dHJdID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIHZhciBwcm9wcyA9IG51bGw7XG5cbiAgICB2YXIgdGFyZ2V0ID0gdHlwZW9mIGV2LnRhcmdldCA9PT0gJ3VuZGVmaW5lZCcgPyBldi5zcmNFbGVtZW50IDogZXYudGFyZ2V0O1xuICAgIGlmIChpc1RleHROb2RlKHRhcmdldCkpIHsgLy8gZGVmZWF0IFNhZmFyaSBidWcgKHNlZTogaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9qcy9ldmVudHNfcHJvcGVydGllcy5odG1sKVxuICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAgIHNob3VsZFRyYWNrRG9tRXZlbnQodGFyZ2V0LCBldikgJiZcbiAgICAgICAgaXNFbGVtZW50QWxsb3dlZCh0YXJnZXQsIGV2LCBhbGxvd0VsZW1lbnRDYWxsYmFjaywgYWxsb3dTZWxlY3RvcnMpICYmXG4gICAgICAgICFpc0VsZW1lbnRCbG9ja2VkKHRhcmdldCwgZXYsIGJsb2NrRWxlbWVudENhbGxiYWNrLCBibG9ja1NlbGVjdG9ycylcbiAgICApIHtcbiAgICAgICAgdmFyIHRhcmdldEVsZW1lbnRMaXN0ID0gW3RhcmdldF07XG4gICAgICAgIHZhciBjdXJFbCA9IHRhcmdldDtcbiAgICAgICAgd2hpbGUgKGN1ckVsLnBhcmVudE5vZGUgJiYgIWlzVGFnKGN1ckVsLCAnYm9keScpKSB7XG4gICAgICAgICAgICB0YXJnZXRFbGVtZW50TGlzdC5wdXNoKGN1ckVsLnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgY3VyRWwgPSBjdXJFbC5wYXJlbnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsZW1lbnRzSnNvbiA9IFtdO1xuICAgICAgICB2YXIgaHJlZiwgZXhwbGljaXROb1RyYWNrID0gZmFsc2U7XG4gICAgICAgIF8uZWFjaCh0YXJnZXRFbGVtZW50TGlzdCwgZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIHZhciBzaG91bGRUcmFja0RldGFpbHMgPSBzaG91bGRUcmFja0VsZW1lbnREZXRhaWxzKGVsLCBldiwgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKTtcblxuICAgICAgICAgICAgLy8gaWYgdGhlIGVsZW1lbnQgb3IgYSBwYXJlbnQgZWxlbWVudCBpcyBhbiBhbmNob3IgdGFnXG4gICAgICAgICAgICAvLyBpbmNsdWRlIHRoZSBocmVmIGFzIGEgcHJvcGVydHlcbiAgICAgICAgICAgIGlmICghYmxvY2tBdHRyc1NldFsnaHJlZiddICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG4gICAgICAgICAgICAgICAgaHJlZiA9IGVsLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgICAgICAgICAgIGhyZWYgPSBzaG91bGRUcmFja0RldGFpbHMgJiYgc2hvdWxkVHJhY2tWYWx1ZShocmVmKSAmJiBocmVmO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNFbGVtZW50QmxvY2tlZChlbCwgZXYsIGJsb2NrRWxlbWVudENhbGxiYWNrLCBibG9ja1NlbGVjdG9ycykpIHtcbiAgICAgICAgICAgICAgICBleHBsaWNpdE5vVHJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbGVtZW50c0pzb24ucHVzaChnZXRQcm9wZXJ0aWVzRnJvbUVsZW1lbnQoZWwsIGV2LCBibG9ja0F0dHJzU2V0LCBjYXB0dXJlRXh0cmFBdHRycywgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGlmICghZXhwbGljaXROb1RyYWNrKSB7XG4gICAgICAgICAgICB2YXIgZG9jRWxlbWVudCA9IGRvY3VtZW50JDFbJ2RvY3VtZW50RWxlbWVudCddO1xuICAgICAgICAgICAgcHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgJyRldmVudF90eXBlJzogZXYudHlwZSxcbiAgICAgICAgICAgICAgICAnJGhvc3QnOiB3aW4ubG9jYXRpb24uaG9zdCxcbiAgICAgICAgICAgICAgICAnJHBhdGhuYW1lJzogd2luLmxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICckZWxlbWVudHMnOiAgZWxlbWVudHNKc29uLFxuICAgICAgICAgICAgICAgICckZWxfYXR0cl9faHJlZic6IGhyZWYsXG4gICAgICAgICAgICAgICAgJyR2aWV3cG9ydEhlaWdodCc6IE1hdGgubWF4KGRvY0VsZW1lbnRbJ2NsaWVudEhlaWdodCddLCB3aW5bJ2lubmVySGVpZ2h0J10gfHwgMCksXG4gICAgICAgICAgICAgICAgJyR2aWV3cG9ydFdpZHRoJzogTWF0aC5tYXgoZG9jRWxlbWVudFsnY2xpZW50V2lkdGgnXSwgd2luWydpbm5lcldpZHRoJ10gfHwgMCksXG4gICAgICAgICAgICAgICAgJyRwYWdlSGVpZ2h0JzogZG9jdW1lbnQkMVsnYm9keSddWydvZmZzZXRIZWlnaHQnXSB8fCAwLFxuICAgICAgICAgICAgICAgICckcGFnZVdpZHRoJzogZG9jdW1lbnQkMVsnYm9keSddWydvZmZzZXRXaWR0aCddIHx8IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXy5lYWNoKGNhcHR1cmVFeHRyYUF0dHJzLCBmdW5jdGlvbihhdHRyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFibG9ja0F0dHJzU2V0W2F0dHJdICYmIHRhcmdldC5oYXNBdHRyaWJ1dGUoYXR0cikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJWYWwgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKGF0dHIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkVHJhY2tWYWx1ZShhdHRyVmFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbJyRlbF9hdHRyX18nICsgYXR0cl0gPSBhdHRyVmFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChjYXB0dXJlVGV4dENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50VGV4dCA9IGdldFNhZmVUZXh0KHRhcmdldCwgZXYsIGFsbG93RWxlbWVudENhbGxiYWNrLCBhbGxvd1NlbGVjdG9ycyk7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRUZXh0ICYmIGVsZW1lbnRUZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wc1snJGVsX3RleHQnXSA9IGVsZW1lbnRUZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV2LnR5cGUgPT09IEVWX0NMSUNLKSB7XG4gICAgICAgICAgICAgICAgXy5lYWNoKENMSUNLX0VWRU5UX1BST1BTLCBmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wIGluIGV2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1snJCcgKyBwcm9wXSA9IGV2W3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGNhcHR1cmVkRm9ySGVhdE1hcCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wc1snJGNhcHR1cmVkX2Zvcl9oZWF0bWFwJ10gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBndWVzc1JlYWxDbGlja1RhcmdldChldik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwcmlvcml0aXplIHRleHQgY29udGVudCBmcm9tIFwicmVhbFwiIGNsaWNrIHRhcmdldCBpZiBkaWZmZXJlbnQgZnJvbSBvcmlnaW5hbCB0YXJnZXRcbiAgICAgICAgICAgIGlmIChjYXB0dXJlVGV4dENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudFRleHQgPSBnZXRTYWZlVGV4dCh0YXJnZXQsIGV2LCBhbGxvd0VsZW1lbnRDYWxsYmFjaywgYWxsb3dTZWxlY3RvcnMpO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50VGV4dCAmJiBlbGVtZW50VGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNbJyRlbF90ZXh0J10gPSBlbGVtZW50VGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAvLyB0YXJnZXQgbWF5IGhhdmUgYmVlbiByZWNhbGN1bGF0ZWQ7IGNoZWNrIGFsbG93bGlzdHMgYW5kIGJsb2NrbGlzdHMgYWdhaW5cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICFpc0VsZW1lbnRBbGxvd2VkKHRhcmdldCwgZXYsIGFsbG93RWxlbWVudENhbGxiYWNrLCBhbGxvd1NlbGVjdG9ycykgfHxcbiAgICAgICAgICAgICAgICAgICAgaXNFbGVtZW50QmxvY2tlZCh0YXJnZXQsIGV2LCBibG9ja0VsZW1lbnRDYWxsYmFjaywgYmxvY2tTZWxlY3RvcnMpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRQcm9wcyA9IGdldFByb3BlcnRpZXNGcm9tRWxlbWVudCh0YXJnZXQsIGV2LCBibG9ja0F0dHJzU2V0LCBjYXB0dXJlRXh0cmFBdHRycywgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKTtcbiAgICAgICAgICAgICAgICBwcm9wc1snJHRhcmdldCddID0gdGFyZ2V0UHJvcHM7XG4gICAgICAgICAgICAgICAgLy8gcHVsbCB1cCBtb3JlIHByb3BzIG9udG8gbWFpbiBldmVudCBwcm9wc1xuICAgICAgICAgICAgICAgIHByb3BzWyckZWxfY2xhc3NlcyddID0gdGFyZ2V0UHJvcHNbJyRjbGFzc2VzJ107XG4gICAgICAgICAgICAgICAgXy5leHRlbmQocHJvcHMsIF8uc3RyaXBfZW1wdHlfcHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgICAgICckZWxfaWQnOiB0YXJnZXRQcm9wc1snJGlkJ10sXG4gICAgICAgICAgICAgICAgICAgICckZWxfdGFnX25hbWUnOiB0YXJnZXRQcm9wc1snJHRhZ19uYW1lJ11cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcHM7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIGRpcmVjdCB0ZXh0IGNvbnRlbnQgb2YgYW4gZWxlbWVudCwgcHJvdGVjdGluZyBhZ2FpbnN0IHNlbnNpdGl2ZSBkYXRhIGNvbGxlY3Rpb24uXG4gKiBDb25jYXRzIHRleHRDb250ZW50IG9mIGVhY2ggb2YgdGhlIGVsZW1lbnQncyB0ZXh0IG5vZGUgY2hpbGRyZW47IHRoaXMgYXZvaWRzIHBvdGVudGlhbFxuICogY29sbGVjdGlvbiBvZiBzZW5zaXRpdmUgZGF0YSB0aGF0IGNvdWxkIGhhcHBlbiBpZiB3ZSB1c2VkIGVsZW1lbnQudGV4dENvbnRlbnQgYW5kIHRoZVxuICogZWxlbWVudCBoYWQgc2Vuc2l0aXZlIGNoaWxkIGVsZW1lbnRzLCBzaW5jZSBlbGVtZW50LnRleHRDb250ZW50IGluY2x1ZGVzIGNoaWxkIGNvbnRlbnQuXG4gKiBTY3J1YnMgdmFsdWVzIHRoYXQgbG9vayBsaWtlIHRoZXkgY291bGQgYmUgc2Vuc2l0aXZlIChpLmUuIGNjIG9yIHNzbiBudW1iZXIpLlxuICogQHBhcmFtIHtFbGVtZW50fSBlbCAtIGVsZW1lbnQgdG8gZ2V0IHRoZSB0ZXh0IG9mXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGFsbG93U2VsZWN0b3JzIC0gQ1NTIHNlbGVjdG9ycyBmb3IgZWxlbWVudHMgdGhhdCBzaG91bGQgYmUgaW5jbHVkZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBlbGVtZW50J3MgZGlyZWN0IHRleHQgY29udGVudFxuICovXG5mdW5jdGlvbiBnZXRTYWZlVGV4dChlbCwgZXYsIGFsbG93RWxlbWVudENhbGxiYWNrLCBhbGxvd1NlbGVjdG9ycykge1xuICAgIHZhciBlbFRleHQgPSAnJztcblxuICAgIGlmIChzaG91bGRUcmFja0VsZW1lbnREZXRhaWxzKGVsLCBldiwgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKSAmJiBlbC5jaGlsZE5vZGVzICYmIGVsLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIF8uZWFjaChlbC5jaGlsZE5vZGVzLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGlzVGV4dE5vZGUoY2hpbGQpICYmIGNoaWxkLnRleHRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgZWxUZXh0ICs9IF8udHJpbShjaGlsZC50ZXh0Q29udGVudClcbiAgICAgICAgICAgICAgICAgICAgLy8gc2NydWIgcG90ZW50aWFsbHkgc2Vuc2l0aXZlIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAuc3BsaXQoLyhcXHMrKS8pLmZpbHRlcihzaG91bGRUcmFja1ZhbHVlKS5qb2luKCcnKVxuICAgICAgICAgICAgICAgICAgICAvLyBub3JtYWxpemUgd2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xcclxcbl0vZywgJyAnKS5yZXBsYWNlKC9bIF0rL2csICcgJylcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJ1bmNhdGVcbiAgICAgICAgICAgICAgICAgICAgLnN1YnN0cmluZygwLCAyNTUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gXy50cmltKGVsVGV4dCk7XG59XG5cbmZ1bmN0aW9uIGd1ZXNzUmVhbENsaWNrVGFyZ2V0KGV2KSB7XG4gICAgdmFyIHRhcmdldCA9IGV2LnRhcmdldDtcbiAgICB2YXIgY29tcG9zZWRQYXRoID0gZXZbJ2NvbXBvc2VkUGF0aCddKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb3NlZFBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBjb21wb3NlZFBhdGhbaV07XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGlzVGFnKG5vZGUsICdhJykgfHxcbiAgICAgICAgICAgIGlzVGFnKG5vZGUsICdidXR0b24nKSB8fFxuICAgICAgICAgICAgaXNUYWcobm9kZSwgJ2lucHV0JykgfHxcbiAgICAgICAgICAgIGlzVGFnKG5vZGUsICdzZWxlY3QnKSB8fFxuICAgICAgICAgICAgKG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKCdyb2xlJykgPT09ICdidXR0b24nKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRhcmdldCA9IG5vZGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBpc0VsZW1lbnRBbGxvd2VkKGVsLCBldiwgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKSB7XG4gICAgaWYgKGFsbG93RWxlbWVudENhbGxiYWNrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWFsbG93RWxlbWVudENhbGxiYWNrKGVsLCBldikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyJDEuY3JpdGljYWwoJ0Vycm9yIHdoaWxlIGNoZWNraW5nIGVsZW1lbnQgaW4gYWxsb3dFbGVtZW50Q2FsbGJhY2snLCBlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFhbGxvd1NlbGVjdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgLy8gbm8gYWxsb3dsaXN0OyBhbGwgZWxlbWVudHMgYXJlIGZhaXIgZ2FtZVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbG93U2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWwgPSBhbGxvd1NlbGVjdG9yc1tpXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChlbFsnbWF0Y2hlcyddKHNlbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBsb2dnZXIkMS5jcml0aWNhbCgnRXJyb3Igd2hpbGUgY2hlY2tpbmcgc2VsZWN0b3I6ICcgKyBzZWwsIGVycik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0VsZW1lbnRCbG9ja2VkKGVsLCBldiwgYmxvY2tFbGVtZW50Q2FsbGJhY2ssIGJsb2NrU2VsZWN0b3JzKSB7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAoYmxvY2tFbGVtZW50Q2FsbGJhY2spIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChibG9ja0VsZW1lbnRDYWxsYmFjayhlbCwgZXYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyJDEuY3JpdGljYWwoJ0Vycm9yIHdoaWxlIGNoZWNraW5nIGVsZW1lbnQgaW4gYmxvY2tFbGVtZW50Q2FsbGJhY2snLCBlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYmxvY2tTZWxlY3RvcnMgJiYgYmxvY2tTZWxlY3RvcnMubGVuZ3RoKSB7XG4gICAgICAgIC8vIHByb2dyYW1tYXRpY2FsbHkgcHJldmVudCB0cmFja2luZyBvZiBlbGVtZW50cyB0aGF0IG1hdGNoIENTUyBzZWxlY3RvcnNcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJsb2NrU2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2VsID0gYmxvY2tTZWxlY3RvcnNbaV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChlbFsnbWF0Y2hlcyddKHNlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDEuY3JpdGljYWwoJ0Vycm9yIHdoaWxlIGNoZWNraW5nIHNlbGVjdG9yOiAnICsgc2VsLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgdXNlcnMgdG8gcHJvZ3JhbW1hdGljYWxseSBwcmV2ZW50IHRyYWNraW5nIG9mIGVsZW1lbnRzIGJ5IGFkZGluZyBkZWZhdWx0IGNsYXNzZXMgc3VjaCBhcyAnbXAtbm8tdHJhY2snXG4gICAgdmFyIGNsYXNzZXMgPSBnZXRDbGFzc2VzKGVsKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgT1BUX09VVF9DTEFTU0VTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjbGFzc2VzW09QVF9PVVRfQ0xBU1NFU1tpXV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKlxuICogQ2hlY2sgd2hldGhlciBhIERPTSBub2RlIGhhcyBub2RlVHlwZSBOb2RlLkVMRU1FTlRfTk9ERVxuICogQHBhcmFtIHtOb2RlfSBub2RlIC0gbm9kZSB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgbm9kZSBpcyBvZiB0aGUgY29ycmVjdCBub2RlVHlwZVxuICovXG5mdW5jdGlvbiBpc0VsZW1lbnROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAmJiBub2RlLm5vZGVUeXBlID09PSAxOyAvLyBOb2RlLkVMRU1FTlRfTk9ERSAtIHVzZSBpbnRlZ2VyIGNvbnN0YW50IGZvciBicm93c2VyIHBvcnRhYmlsaXR5XG59XG5cbi8qXG4gKiBDaGVjayB3aGV0aGVyIGFuIGVsZW1lbnQgaXMgb2YgYSBnaXZlbiB0YWcgdHlwZS5cbiAqIER1ZSB0byBwb3RlbnRpYWwgcmVmZXJlbmNlIGRpc2NyZXBhbmNpZXMgKHN1Y2ggYXMgdGhlIHdlYmNvbXBvbmVudHMuanMgcG9seWZpbGwpLFxuICogd2Ugd2FudCB0byBtYXRjaCB0YWdOYW1lcyBpbnN0ZWFkIG9mIHNwZWNpZmljIHJlZmVyZW5jZXMgYmVjYXVzZSBzb21ldGhpbmcgbGlrZVxuICogZWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keSB3b24ndCBhbHdheXMgd29yayBiZWNhdXNlIGVsZW1lbnQgbWlnaHQgbm90IGJlIGEgbmF0aXZlXG4gKiBlbGVtZW50LlxuICogQHBhcmFtIHtFbGVtZW50fSBlbCAtIGVsZW1lbnQgdG8gY2hlY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgLSB0YWcgbmFtZSAoZS5nLiwgXCJkaXZcIilcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIGVsIGlzIG9mIHRoZSBnaXZlbiB0YWcgdHlwZVxuICovXG5mdW5jdGlvbiBpc1RhZyhlbCwgdGFnKSB7XG4gICAgcmV0dXJuIGVsICYmIGVsLnRhZ05hbWUgJiYgZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSB0YWcudG9Mb3dlckNhc2UoKTtcbn1cblxuLypcbiAqIENoZWNrIHdoZXRoZXIgYSBET00gbm9kZSBpcyBhIFRFWFRfTk9ERVxuICogQHBhcmFtIHtOb2RlfSBub2RlIC0gbm9kZSB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgbm9kZSBpcyBvZiB0eXBlIE5vZGUuVEVYVF9OT0RFXG4gKi9cbmZ1bmN0aW9uIGlzVGV4dE5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlICYmIG5vZGUubm9kZVR5cGUgPT09IDM7IC8vIE5vZGUuVEVYVF9OT0RFIC0gdXNlIGludGVnZXIgY29uc3RhbnQgZm9yIGJyb3dzZXIgcG9ydGFiaWxpdHlcbn1cblxuZnVuY3Rpb24gbWluRE9NQXBpc1N1cHBvcnRlZCgpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgdGVzdEVsID0gZG9jdW1lbnQkMS5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgcmV0dXJuICEhdGVzdEVsWydtYXRjaGVzJ107XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHdlYWtTZXRTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBXZWFrU2V0ICE9PSAndW5kZWZpbmVkJztcbn1cblxuLypcbiAqIENoZWNrIHdoZXRoZXIgYSBET00gZXZlbnQgc2hvdWxkIGJlIFwidHJhY2tlZFwiIG9yIGlmIGl0IG1heSBjb250YWluIHNlbnNpdGl2ZSBkYXRhXG4gKiB1c2luZyBhIHZhcmlldHkgb2YgaGV1cmlzdGljcy5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWwgLSBlbGVtZW50IHRvIGNoZWNrXG4gKiBAcGFyYW0ge0V2ZW50fSBldiAtIGV2ZW50IHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgZXZlbnQgc2hvdWxkIGJlIHRyYWNrZWRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVHJhY2tEb21FdmVudChlbCwgZXYpIHtcbiAgICBpZiAoIWVsIHx8IGlzVGFnKGVsLCAnaHRtbCcpIHx8ICFpc0VsZW1lbnROb2RlKGVsKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB0YWcgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICAgICAgICByZXR1cm4gZXYudHlwZSA9PT0gRVZfU1VCTUlUO1xuICAgICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgICAgICBpZiAoWydidXR0b24nLCAnc3VibWl0J10uaW5kZXhPZihlbC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2LnR5cGUgPT09IEVWX0NIQU5HRTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2LnR5cGUgPT09IEVWX0NMSUNLO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgICAgICByZXR1cm4gZXYudHlwZSA9PT0gRVZfQ0hBTkdFO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGV2LnR5cGUgPT09IEVWX0NMSUNLO1xuICAgIH1cbn1cblxuLypcbiAqIENoZWNrIHdoZXRoZXIgYSBET00gZWxlbWVudCBzaG91bGQgYmUgXCJ0cmFja2VkXCIgb3IgaWYgaXQgbWF5IGNvbnRhaW4gc2Vuc2l0aXZlIGRhdGFcbiAqIHVzaW5nIGEgdmFyaWV0eSBvZiBoZXVyaXN0aWNzLlxuICogQHBhcmFtIHtFbGVtZW50fSBlbCAtIGVsZW1lbnQgdG8gY2hlY2tcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYWxsb3dTZWxlY3RvcnMgLSBDU1Mgc2VsZWN0b3JzIGZvciBlbGVtZW50cyB0aGF0IHNob3VsZCBiZSBpbmNsdWRlZFxuICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIGVsZW1lbnQgc2hvdWxkIGJlIHRyYWNrZWRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVHJhY2tFbGVtZW50RGV0YWlscyhlbCwgZXYsIGFsbG93RWxlbWVudENhbGxiYWNrLCBhbGxvd1NlbGVjdG9ycykge1xuICAgIHZhciBpO1xuXG4gICAgaWYgKCFpc0VsZW1lbnRBbGxvd2VkKGVsLCBldiwgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgY3VyRWwgPSBlbDsgY3VyRWwucGFyZW50Tm9kZSAmJiAhaXNUYWcoY3VyRWwsICdib2R5Jyk7IGN1ckVsID0gY3VyRWwucGFyZW50Tm9kZSkge1xuICAgICAgICB2YXIgY2xhc3NlcyA9IGdldENsYXNzZXMoY3VyRWwpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgU0VOU0lUSVZFX0RBVEFfQ0xBU1NFUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNsYXNzZXNbU0VOU0lUSVZFX0RBVEFfQ0xBU1NFU1tpXV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZWxDbGFzc2VzID0gZ2V0Q2xhc3NlcyhlbCk7XG4gICAgZm9yIChpID0gMDsgaSA8IE9QVF9JTl9DTEFTU0VTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChlbENsYXNzZXNbT1BUX0lOX0NMQVNTRVNbaV1dKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRvbid0IHNlbmQgZGF0YSBmcm9tIGlucHV0cyBvciBzaW1pbGFyIGVsZW1lbnRzIHNpbmNlIHRoZXJlIHdpbGwgYWx3YXlzIGJlXG4gICAgLy8gYSByaXNrIG9mIGNsaWVudHNpZGUgamF2YXNjcmlwdCBwbGFjaW5nIHNlbnNpdGl2ZSBkYXRhIGluIGF0dHJpYnV0ZXNcbiAgICBpZiAoXG4gICAgICAgIGlzVGFnKGVsLCAnaW5wdXQnKSB8fFxuICAgICAgICBpc1RhZyhlbCwgJ3NlbGVjdCcpIHx8XG4gICAgICAgIGlzVGFnKGVsLCAndGV4dGFyZWEnKSB8fFxuICAgICAgICBlbC5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpID09PSAndHJ1ZSdcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGRvbid0IGluY2x1ZGUgaGlkZGVuIG9yIHBhc3N3b3JkIGZpZWxkc1xuICAgIHZhciB0eXBlID0gZWwudHlwZSB8fCAnJztcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7IC8vIGl0J3MgcG9zc2libGUgZm9yIGVsLnR5cGUgdG8gYmUgYSBET00gZWxlbWVudCBpZiBlbCBpcyBhIGZvcm0gd2l0aCBhIGNoaWxkIGlucHV0W25hbWU9XCJ0eXBlXCJdXG4gICAgICAgIHN3aXRjaCh0eXBlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ2hpZGRlbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FzZSAncGFzc3dvcmQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZpbHRlciBvdXQgZGF0YSBmcm9tIGZpZWxkcyB0aGF0IGxvb2sgbGlrZSBzZW5zaXRpdmUgZmllbGRzXG4gICAgdmFyIG5hbWUgPSBlbC5uYW1lIHx8IGVsLmlkIHx8ICcnO1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHsgLy8gaXQncyBwb3NzaWJsZSBmb3IgZWwubmFtZSBvciBlbC5pZCB0byBiZSBhIERPTSBlbGVtZW50IGlmIGVsIGlzIGEgZm9ybSB3aXRoIGEgY2hpbGQgaW5wdXRbbmFtZT1cIm5hbWVcIl1cbiAgICAgICAgdmFyIHNlbnNpdGl2ZU5hbWVSZWdleCA9IC9eY2N8Y2FyZG51bXxjY251bXxjcmVkaXRjYXJkfGNzY3xjdmN8Y3Z2fGV4cHxwYXNzfHB3ZHxyb3V0aW5nfHNlY2NvZGV8c2VjdXJpdHljb2RlfHNlY3VyaXR5bnVtfHNvY2lhbHNlY3xzb2NzZWN8c3NuL2k7XG4gICAgICAgIGlmIChzZW5zaXRpdmVOYW1lUmVnZXgudGVzdChuYW1lLnJlcGxhY2UoL1teYS16QS1aMC05XS9nLCAnJykpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuXG4vKlxuICogQ2hlY2sgd2hldGhlciBhIHN0cmluZyB2YWx1ZSBzaG91bGQgYmUgXCJ0cmFja2VkXCIgb3IgaWYgaXQgbWF5IGNvbnRhaW4gc2Vuc2l0aXZlIGRhdGFcbiAqIHVzaW5nIGEgdmFyaWV0eSBvZiBoZXVyaXN0aWNzLlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gc3RyaW5nIHZhbHVlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgZWxlbWVudCBzaG91bGQgYmUgdHJhY2tlZFxuICovXG5mdW5jdGlvbiBzaG91bGRUcmFja1ZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IF8uaXNVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YWx1ZSA9IF8udHJpbSh2YWx1ZSk7XG5cbiAgICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIGlucHV0IHZhbHVlIGxvb2tzIGxpa2UgYSBjcmVkaXQgY2FyZCBudW1iZXJcbiAgICAgICAgLy8gc2VlOiBodHRwczovL3d3dy5zYWZhcmlib29rc29ubGluZS5jb20vbGlicmFyeS92aWV3L3JlZ3VsYXItZXhwcmVzc2lvbnMtY29va2Jvb2svOTc4MTQ0OTMyNzQ1My9jaDA0czIwLmh0bWxcbiAgICAgICAgdmFyIGNjUmVnZXggPSAvXig/Oig0WzAtOV17MTJ9KD86WzAtOV17M30pPyl8KDVbMS01XVswLTldezE0fSl8KDYoPzowMTF8NVswLTldezJ9KVswLTldezEyfSl8KDNbNDddWzAtOV17MTN9KXwoMyg/OjBbMC01XXxbNjhdWzAtOV0pWzAtOV17MTF9KXwoKD86MjEzMXwxODAwfDM1WzAtOV17M30pWzAtOV17MTF9KSkkLztcbiAgICAgICAgaWYgKGNjUmVnZXgudGVzdCgodmFsdWUgfHwgJycpLnJlcGxhY2UoL1stIF0vZywgJycpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIGlucHV0IHZhbHVlIGxvb2tzIGxpa2UgYSBzb2NpYWwgc2VjdXJpdHkgbnVtYmVyXG4gICAgICAgIHZhciBzc25SZWdleCA9IC8oXlxcZHszfS0/XFxkezJ9LT9cXGR7NH0kKS87XG4gICAgICAgIGlmIChzc25SZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNyb3NzLWJyb3dzZXIgY29tcGF0aWJsZSBzY3JvbGwgZW5kIGZ1bmN0aW9uIHdpdGggYXBwcm9wcmlhdGUgZXZlbnQgbGlzdGVuZXIuXG4gKiBGb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IHNjcm9sbGVuZCwgcmV0dXJucyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gd2l0aCBzY3JvbGxlbmQgZXZlbnQuXG4gKiBGb3IgYnJvd3NlcnMgd2l0aG91dCBzY3JvbGxlbmQgc3VwcG9ydCwgcmV0dXJucyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IHRyaWdnZXJzXG4gKiAxMDBtcyBhZnRlciB0aGUgbGFzdCBzY3JvbGwgZXZlbnQgdG8gc2ltdWxhdGUgc2Nyb2xsZW5kIGJlaGF2aW9yLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3JpZ2luYWxGdW5jdGlvbiAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gc2Nyb2xsaW5nIGVuZHNcbiAqIEByZXR1cm5zIHtPYmplY3R9IE9iamVjdCBjb250YWluaW5nIGxpc3RlbmVyIGZ1bmN0aW9uIGFuZCBldmVudFR5cGUgc3RyaW5nXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IHJldHVybnMubGlzdGVuZXIgLSBUaGUgd3JhcHBlZCBmdW5jdGlvbiB0byB1c2UgYXMgZXZlbnQgbGlzdGVuZXJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHJldHVybnMuZXZlbnRUeXBlIC0gVGhlIGV2ZW50IHR5cGUgdG8gbGlzdGVuIGZvciAoJ3Njcm9sbGVuZCcgb3IgJ3Njcm9sbCcpXG4gKi9cbmZ1bmN0aW9uIGdldFBvbHlmaWxsU2Nyb2xsRW5kRnVuY3Rpb24ob3JpZ2luYWxGdW5jdGlvbikge1xuICAgIHZhciBzdXBwb3J0c1Njcm9sbEVuZCA9ICdvbnNjcm9sbGVuZCcgaW4gd2luO1xuICAgIHZhciBwb2x5ZmlsbEZ1bmN0aW9uID0gc2FmZXdyYXAob3JpZ2luYWxGdW5jdGlvbik7XG4gICAgdmFyIHBvbHlmaWxsRXZlbnQgPSBFVl9TQ1JPTExFTkQ7XG4gICAgaWYgKCFzdXBwb3J0c1Njcm9sbEVuZCkge1xuICAgICAgICAvLyBQb2x5ZmlsbCBmb3IgYnJvd3NlcnMgd2l0aG91dCBzY3JvbGxlbmQgc3VwcG9ydDogd2FpdCAxMDBtcyBhZnRlciB0aGUgbGFzdCBzY3JvbGwgZXZlbnRcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9ibG9nL3Njcm9sbGVuZC1hLW5ldy1qYXZhc2NyaXB0LWV2ZW50XG4gICAgICAgIHZhciBzY3JvbGxUaW1lciA9IG51bGw7XG4gICAgICAgIHZhciBzY3JvbGxEZWxheU1zID0gMTAwO1xuXG4gICAgICAgIHBvbHlmaWxsRnVuY3Rpb24gPSBzYWZld3JhcChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChzY3JvbGxUaW1lcik7XG4gICAgICAgICAgICBzY3JvbGxUaW1lciA9IHNldFRpbWVvdXQob3JpZ2luYWxGdW5jdGlvbiwgc2Nyb2xsRGVsYXlNcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHBvbHlmaWxsRXZlbnQgPSBFVl9TQ1JPTEw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGlzdGVuZXI6IHBvbHlmaWxsRnVuY3Rpb24sXG4gICAgICAgIGV2ZW50VHlwZTogcG9seWZpbGxFdmVudFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGhhc0lubGluZUV2ZW50SGFuZGxlcnMoZWxlbWVudCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgRVZFTlRfSEFORExFUl9BVFRSSUJVVEVTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZShFVkVOVF9IQU5ETEVSX0FUVFJJQlVURVNbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGhhc0ludGVyYWN0aXZlQXJpYVJvbGUoZWxlbWVudCkge1xuICAgIHZhciByb2xlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKTtcbiAgICBpZiAoIXJvbGUpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIEhhbmRsZSBpbnZhbGlkIG1hcmt1cCB3aGVyZSBtdWx0aXBsZSByb2xlcyBtaWdodCBiZSBzcGVjaWZpZWRcbiAgICAvLyBPbmx5IHRoZSBmaXJzdCB0b2tlbiBpcyByZWNvZ25pemVkIHBlciBBUklBIHNwZWNcbiAgICB2YXIgcHJpbWFyeVJvbGUgPSByb2xlLnRyaW0oKS5zcGxpdCgvXFxzKy8pWzBdLnRvTG93ZXJDYXNlKCk7XG5cbiAgICByZXR1cm4gSU5URVJBQ1RJVkVfQVJJQV9ST0xFU1twcmltYXJ5Um9sZV07XG59XG5cbmZ1bmN0aW9uIGhhc0FueUludGVyYWN0aXZpdHlJbmRpY2F0b3JzKGVsZW1lbnQpIHtcbiAgICB2YXIgdGFnTmFtZSA9IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gQ2hlY2sgZm9yIGludGVyYWN0aXZlIEhUTUwgZWxlbWVudHNcbiAgICBpZiAodGFnTmFtZSA9PT0gJ2J1dHRvbicgfHxcbiAgICAgICAgdGFnTmFtZSA9PT0gJ2lucHV0JyB8fFxuICAgICAgICB0YWdOYW1lID09PSAnc2VsZWN0JyB8fFxuICAgICAgICB0YWdOYW1lID09PSAndGV4dGFyZWEnIHx8XG4gICAgICAgIHRhZ05hbWUgPT09ICdkZXRhaWxzJyB8fFxuICAgICAgICB0YWdOYW1lID09PSAnZGlhbG9nJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5pc0NvbnRlbnRFZGl0YWJsZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5vbmNsaWNrIHx8IGVsZW1lbnQub25tb3VzZWRvd24gfHwgZWxlbWVudC5vbm1vdXNldXAgfHwgZWxlbWVudC5vbnRvdWNoc3RhcnQgfHwgZWxlbWVudC5vbnRvdWNoZW5kKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChoYXNJbmxpbmVFdmVudEhhbmRsZXJzKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChoYXNJbnRlcmFjdGl2ZUFyaWFSb2xlKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0YWdOYW1lID09PSAnYScgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2hyZWYnKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5cbmZ1bmN0aW9uIGlzRGVmaW5pdGVseU5vbkludGVyYWN0aXZlKGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQudGFnTmFtZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgdGFnTmFtZSA9IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gVGhlc2UgdGFncyBhcmUgZGVmaW5pdGVseSBub24taW50ZXJhY3RpdmVcbiAgICBpZiAoQUxXQVlTX05PTl9JTlRFUkFDVElWRV9UQUdTW3RhZ05hbWVdKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZvciBhbGwgb3RoZXIgZWxlbWVudHMsIHdlIGNhbiBvbmx5IGJlIGNlcnRhaW4gdGhleSdyZSBub24taW50ZXJhY3RpdmUgaWYgdGhleSBsYWNrIEFMTCBpbmRpY2F0b3JzIG9mIGludGVyYWN0aXZpdHlcbiAgICAvLyBDaGVjayBmb3IgYW55IHNpZ25zIG9mIGludGVyYWN0aXZpdHlcbiAgICBpZiAoaGFzQW55SW50ZXJhY3Rpdml0eUluZGljYXRvcnMoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHBhcmVudCBjaGFpbiBmb3IgaW50ZXJhY3RpdmUgY29udGV4dFxuICAgIHZhciBwYXJlbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgdmFyIGRlcHRoID0gMDtcblxuICAgIHdoaWxlIChwYXJlbnQgJiYgZGVwdGggPCBNQVhfREVQVEgpIHtcbiAgICAgICAgaWYgKGhhc0FueUludGVyYWN0aXZpdHlJbmRpY2F0b3JzKHBhcmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gRWxlbWVudCBpcyBpbnNpZGUgYW4gaW50ZXJhY3RpdmUgcGFyZW50XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyZW50LmdldFJvb3ROb2RlICYmIHBhcmVudC5nZXRSb290Tm9kZSgpICE9PSBkb2N1bWVudCQxKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IHBhcmVudC5nZXRSb290Tm9kZSgpO1xuICAgICAgICAgICAgaWYgKHJvb3QuaG9zdCAmJiBoYXNBbnlJbnRlcmFjdGl2aXR5SW5kaWNhdG9ycyhyb290Lmhvc3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBJbnNpZGUgYW4gaW50ZXJhY3RpdmUgc2hhZG93IGhvc3RcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICBkZXB0aCsrO1xuICAgIH1cblxuICAgIC8vIFB1cmUgdGV4dCBjb250YWluZXJzIHdpdGhvdXQgYW55IGludGVyYWN0aXZlIGNvbnRleHRcbiAgICBpZiAoVEVYVF9DT05UQUlORVJfVEFHU1t0YWdOYW1lXSkge1xuICAgICAgICAvLyBUaGVzZSBhcmUgbm9uLWludGVyYWN0aXZlIE9OTFkgaWYgdGhleSBoYXZlIG5vIGludGVyYWN0aXZlIGluZGljYXRvcnMgKGFscmVhZHkgY2hlY2tlZCBhcyBwYXJ0IG9mIGhhc0FueUludGVyYWN0aXZpdHlJbmRpY2F0b3JzKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0OiB3ZSBjYW4ndCBiZSBjZXJ0YWluIGl0J3Mgbm9uLWludGVyYWN0aXZlXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgY29tcG9zZWQgcGF0aCBvZiBhIGNsaWNrIGV2ZW50IGZvciBlbGVtZW50cyBlbWJlZGRlZCBpbiBzaGFkb3cgRE9NLlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBldmVudCB0byBnZXQgdGhlIGNvbXBvc2VkIHBhdGggZnJvbVxuICogQHJldHVybnMge0FycmF5fSB0aGUgY29tcG9zZWQgcGF0aCBvZiB0aGUgY2xpY2sgZXZlbnRcbiovXG5mdW5jdGlvbiBnZXRDbGlja0V2ZW50Q29tcG9zZWRQYXRoKGV2ZW50KSB7XG4gICAgaWYgKCdjb21wb3NlZFBhdGgnIGluIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBldmVudFsnY29tcG9zZWRQYXRoJ10oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG59XG5cbi8qKlxuICogR2V0IHRoZSBlbGVtZW50IGZyb20gYSBjbGljayBldmVudCwgYWNjb3VudGluZyBmb3IgZWxlbWVudHMgZW1iZWRkZWQgaW4gc2hhZG93IERPTS5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gZXZlbnQgdG8gZ2V0IHRoZSB0YXJnZXQgZnJvbVxuICogQHJldHVybnMge0VsZW1lbnQgfCBudWxsfSB0aGUgZWxlbWVudCB0aGF0IHdhcyB0aGUgdGFyZ2V0IG9mIHRoZSBjbGljayBldmVudFxuICovXG5mdW5jdGlvbiBnZXRDbGlja0V2ZW50VGFyZ2V0RWxlbWVudChldmVudCkge1xuICAgIHZhciBwYXRoID0gZ2V0Q2xpY2tFdmVudENvbXBvc2VkUGF0aChldmVudCk7XG5cbiAgICBpZiAocGF0aCAmJiBwYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHBhdGhbMF07XG4gICAgfVxuXG4gICAgcmV0dXJuIGV2ZW50Wyd0YXJnZXQnXSB8fCBldmVudFsnc3JjRWxlbWVudCddO1xufVxuXG4vKiogQGNvbnN0ICovIHZhciBERUZBVUxUX1JBR0VfQ0xJQ0tfVEhSRVNIT0xEX1BYID0gMzA7XG4vKiogQGNvbnN0ICovIHZhciBERUZBVUxUX1JBR0VfQ0xJQ0tfVElNRU9VVF9NUyA9IDEwMDA7XG4vKiogQGNvbnN0ICovIHZhciBERUZBVUxUX1JBR0VfQ0xJQ0tfQ0xJQ0tfQ09VTlQgPSA0O1xuLyoqIEBjb25zdCAqLyB2YXIgREVGQVVMVF9SQUdFX0NMSUNLX0lOVEVSQUNUSVZFX0VMRU1FTlRTX09OTFkgPSBmYWxzZTtcblxuZnVuY3Rpb24gUmFnZUNsaWNrVHJhY2tlcigpIHtcbiAgICB0aGlzLmNsaWNrcyA9IFtdO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBjbGljayBldmVudCBpcyBwYXJ0IG9mIGEgcmFnZSBjbGljayBzZXF1ZW5jZS5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gdGhlIG9yaWdpbmFsIGNsaWNrIGV2ZW50LlxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2luZGV4LmQudHMnKS5SYWdlQ2xpY2tDb25maWd9IG9wdGlvbnMgLSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHJhZ2UgY2xpY2sgZGV0ZWN0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IC0gdHJ1ZSBpZiB0aGUgY2xpY2sgaXMgY29uc2lkZXJlZCBhIHJhZ2UgY2xpY2ssIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuUmFnZUNsaWNrVHJhY2tlci5wcm90b3R5cGUuaXNSYWdlQ2xpY2sgPSBmdW5jdGlvbihldmVudCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciB0aHJlc2hvbGRQeCA9IG9wdGlvbnNbJ3RocmVzaG9sZF9weCddIHx8IERFRkFVTFRfUkFHRV9DTElDS19USFJFU0hPTERfUFg7XG4gICAgdmFyIHRpbWVvdXRNcyA9IG9wdGlvbnNbJ3RpbWVvdXRfbXMnXSB8fCBERUZBVUxUX1JBR0VfQ0xJQ0tfVElNRU9VVF9NUztcbiAgICB2YXIgY2xpY2tDb3VudCA9IG9wdGlvbnNbJ2NsaWNrX2NvdW50J10gfHwgREVGQVVMVF9SQUdFX0NMSUNLX0NMSUNLX0NPVU5UO1xuICAgIHZhciBpbnRlcmFjdGl2ZUVsZW1lbnRzT25seSA9IG9wdGlvbnNbJ2ludGVyYWN0aXZlX2VsZW1lbnRzX29ubHknXSB8fCBERUZBVUxUX1JBR0VfQ0xJQ0tfSU5URVJBQ1RJVkVfRUxFTUVOVFNfT05MWTtcblxuICAgIGlmIChpbnRlcmFjdGl2ZUVsZW1lbnRzT25seSkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZ2V0Q2xpY2tFdmVudFRhcmdldEVsZW1lbnQoZXZlbnQpO1xuICAgICAgICBpZiAoIXRhcmdldCB8fCBpc0RlZmluaXRlbHlOb25JbnRlcmFjdGl2ZSh0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgeCA9IGV2ZW50WydwYWdlWCddLCB5ID0gZXZlbnRbJ3BhZ2VZJ107XG5cbiAgICB2YXIgbGFzdENsaWNrID0gdGhpcy5jbGlja3NbdGhpcy5jbGlja3MubGVuZ3RoIC0gMV07XG4gICAgaWYgKFxuICAgICAgICBsYXN0Q2xpY2sgJiZcbiAgICAgICAgdGltZXN0YW1wIC0gbGFzdENsaWNrLnRpbWVzdGFtcCA8IHRpbWVvdXRNcyAmJlxuICAgICAgICBNYXRoLnNxcnQoTWF0aC5wb3coeCAtIGxhc3RDbGljay54LCAyKSArIE1hdGgucG93KHkgLSBsYXN0Q2xpY2sueSwgMikpIDwgdGhyZXNob2xkUHhcbiAgICApIHtcbiAgICAgICAgdGhpcy5jbGlja3MucHVzaCh7IHg6IHgsIHk6IHksIHRpbWVzdGFtcDogdGltZXN0YW1wIH0pO1xuICAgICAgICBpZiAodGhpcy5jbGlja3MubGVuZ3RoID49IGNsaWNrQ291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuY2xpY2tzID0gW107XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2xpY2tzID0gW3sgeDogeCwgeTogeSwgdGltZXN0YW1wOiB0aW1lc3RhbXAgfV07XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIFNoYWRvd0RPTU9ic2VydmVyKGNoYW5nZUNhbGxiYWNrLCBvYnNlcnZlckNvbmZpZykge1xuICAgIHRoaXMuY2hhbmdlQ2FsbGJhY2sgPSBjaGFuZ2VDYWxsYmFjayB8fCBmdW5jdGlvbigpIHt9O1xuICAgIHRoaXMub2JzZXJ2ZXJDb25maWcgPSBvYnNlcnZlckNvbmZpZztcblxuICAgIHRoaXMub2JzZXJ2ZWRTaGFkb3dSb290cyA9IG51bGw7XG4gICAgdGhpcy5zaGFkb3dPYnNlcnZlcnMgPSBbXTtcbn1cblxuU2hhZG93RE9NT2JzZXJ2ZXIucHJvdG90eXBlLmdldEV2ZW50VGFyZ2V0ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMub2JzZXJ2ZWRTaGFkb3dSb290cykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldENsaWNrRXZlbnRUYXJnZXRFbGVtZW50KGV2ZW50KTtcbn07XG5cblNoYWRvd0RPTU9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlRnJvbUV2ZW50ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMub2JzZXJ2ZWRTaGFkb3dSb290cykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhdGggPSBnZXRDbGlja0V2ZW50Q29tcG9zZWRQYXRoKGV2ZW50KTtcblxuICAgIC8vIENoZWNrIGVhY2ggZWxlbWVudCBpbiBwYXRoIGZvciBzaGFkb3cgcm9vdHNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBwYXRoW2ldO1xuXG4gICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlU2hhZG93Um9vdChlbGVtZW50LnNoYWRvd1Jvb3QpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5TaGFkb3dET01PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZVNoYWRvd1Jvb3QgPSBmdW5jdGlvbihzaGFkb3dSb290KSB7XG4gICAgaWYgKCF0aGlzLm9ic2VydmVkU2hhZG93Um9vdHMgfHwgdGhpcy5vYnNlcnZlZFNoYWRvd1Jvb3RzLmhhcyhzaGFkb3dSb290KSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy5vYnNlcnZlZFNoYWRvd1Jvb3RzLmFkZChzaGFkb3dSb290KTtcblxuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmNoYW5nZUNhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUoc2hhZG93Um9vdCwgdGhpcy5vYnNlcnZlckNvbmZpZyk7XG4gICAgICAgIHRoaXMuc2hhZG93T2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2VyJDEuY3JpdGljYWwoJ0Vycm9yIHdoaWxlIG9ic2VydmluZyBzaGFkb3cgcm9vdCcsIGUpO1xuICAgIH1cbn07XG5cblxuU2hhZG93RE9NT2JzZXJ2ZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMub2JzZXJ2ZWRTaGFkb3dSb290cykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF3ZWFrU2V0U3VwcG9ydGVkKCkpIHtcbiAgICAgICAgbG9nZ2VyJDEuY3JpdGljYWwoJ1NoYWRvdyBET00gb2JzZXJ2YXRpb24gdW5hdmFpbGFibGU6IFdlYWtTZXQgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5vYnNlcnZlZFNoYWRvd1Jvb3RzID0gbmV3IFdlYWtTZXQoKTtcbn07XG5cblNoYWRvd0RPTU9ic2VydmVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLm9ic2VydmVkU2hhZG93Um9vdHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zaGFkb3dPYnNlcnZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc2hhZG93T2JzZXJ2ZXJzW2ldLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nZ2VyJDEuY3JpdGljYWwoJ0Vycm9yIHdoaWxlIGRpc2Nvbm5lY3Rpbmcgc2hhZG93IERPTSBvYnNlcnZlcicsIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2hhZG93T2JzZXJ2ZXJzID0gW107XG4gICAgdGhpcy5vYnNlcnZlZFNoYWRvd1Jvb3RzID0gbnVsbDtcbn07XG5cbi8qKiBAY29uc3QgKi8gdmFyIERFRkFVTFRfREVBRF9DTElDS19USU1FT1VUX01TID0gNTAwO1xuLyoqIEBjb25zdCAqLyB2YXIgSU5URVJBQ1RJT05fRVZFTlRTID0gW0VWX0NIQU5HRSwgRVZfSU5QVVQsIEVWX1NVQk1JVCwgRVZfU0VMRUNULCBFVl9UT0dHTEVdO1xuLyoqIEBjb25zdCAqLyB2YXIgTEFZT1VUX0VWRU5UUyA9IFtFVl9TQ1JPTExFTkRdO1xuLyoqIEBjb25zdCAqLyB2YXIgTkFWSUdBVElPTl9FVkVOVFMgPSBbRVZfSEFTSENIQU5HRV07XG4vKiogQGNvbnN0ICovIHZhciBNVVRBVElPTl9PQlNFUlZFUl9DT05GSUcgPSB7XG4gICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgc3VidHJlZTogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgIGF0dHJpYnV0ZUZpbHRlcjogWydzdHlsZScsICdjbGFzcycsICdoaWRkZW4nLCAnY2hlY2tlZCcsICdzZWxlY3RlZCcsICd2YWx1ZScsICdkaXNwbGF5JywgJ3Zpc2liaWxpdHknXVxufTtcblxuXG5mdW5jdGlvbiBEZWFkQ2xpY2tUcmFja2VyKG9uRGVhZENsaWNrQ2FsbGJhY2spIHtcbiAgICB0aGlzLmV2ZW50TGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyID0gbnVsbDtcbiAgICB0aGlzLnNoYWRvd0RPTU9ic2VydmVyID0gbnVsbDtcblxuICAgIHRoaXMuaXNUcmFja2luZyA9IGZhbHNlO1xuICAgIHRoaXMubGFzdENoYW5nZUV2ZW50VGltZXN0YW1wID0gMDtcbiAgICB0aGlzLnBlbmRpbmdDbGlja3MgPSBbXTtcbiAgICB0aGlzLm9uRGVhZENsaWNrQ2FsbGJhY2sgPSBvbkRlYWRDbGlja0NhbGxiYWNrO1xuICAgIHRoaXMucHJvY2Vzc2luZ0FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMucHJvY2Vzc2luZ1RpbWVvdXQgPSBudWxsO1xufVxuXG5cbkRlYWRDbGlja1RyYWNrZXIucHJvdG90eXBlLmFkZENsaWNrID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuc2hhZG93RE9NT2JzZXJ2ZXIgJiYgdGhpcy5zaGFkb3dET01PYnNlcnZlci5nZXRFdmVudFRhcmdldChldmVudCk7XG5cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudCA9IGV2ZW50Wyd0YXJnZXQnXSB8fCBldmVudFsnc3JjRWxlbWVudCddO1xuICAgIH1cblxuICAgIGlmICghZWxlbWVudCB8fCBpc0RlZmluaXRlbHlOb25JbnRlcmFjdGl2ZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2hhZG93RE9NT2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5zaGFkb3dET01PYnNlcnZlci5vYnNlcnZlRnJvbUV2ZW50KGV2ZW50KTtcbiAgICB9XG4gICAgdGhpcy5wZW5kaW5nQ2xpY2tzLnB1c2goe1xuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuRGVhZENsaWNrVHJhY2tlci5wcm90b3R5cGUudHJhY2tDbGljayA9IGZ1bmN0aW9uKGV2ZW50LCBjb25maWcpIHtcbiAgICBpZiAoIXRoaXMuaXNUcmFja2luZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGFkZGVkID0gdGhpcy5hZGRDbGljayhldmVudCk7XG4gICAgaWYgKGFkZGVkKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlclByb2Nlc3NpbmcoY29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIGFkZGVkO1xufTtcblxuRGVhZENsaWNrVHJhY2tlci5wcm90b3R5cGUuZ2V0RGVhZENsaWNrcyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIGlmICh0aGlzLnBlbmRpbmdDbGlja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgdGltZW91dE1zID0gY29uZmlnWyd0aW1lb3V0X21zJ107XG4gICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgdmFyIGNsaWNrc1RvRXZhbHVhdGUgPSB0aGlzLnBlbmRpbmdDbGlja3Muc2xpY2UoKTsgLy8gQ29weSBhcnJheVxuICAgIHRoaXMucGVuZGluZ0NsaWNrcyA9IFtdOyAvLyBDbGVhciBvcmlnaW5hbFxuXG4gICAgdmFyIGRlYWRDbGlja3MgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpY2tzVG9FdmFsdWF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2xpY2sgPSBjbGlja3NUb0V2YWx1YXRlW2ldO1xuXG4gICAgICAgIGlmIChub3cgLSBjbGljay50aW1lc3RhbXAgPj0gdGltZW91dE1zKSB7XG4gICAgICAgICAgICAvLyBDbGljayBoYXMgZXhjZWVkZWQgdGltZW91dCwgY2hlY2sgaWYgaXQncyBkZWFkIGJ5IGxvb2tpbmcgZm9yIGNoYW5nZXMgYWZ0ZXIgdGhpcyBzcGVjaWZpYyBjbGlja1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc0NoYW5nZXNBZnRlcihjbGljay50aW1lc3RhbXApKSB7XG4gICAgICAgICAgICAgICAgZGVhZENsaWNrcy5wdXNoKGNsaWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFN0aWxsIHBlbmRpbmcgLSBhZGQgYmFja1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ2xpY2tzLnB1c2goY2xpY2spO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlYWRDbGlja3M7XG59O1xuXG5EZWFkQ2xpY2tUcmFja2VyLnByb3RvdHlwZS5oYXNDaGFuZ2VzQWZ0ZXIgPSBmdW5jdGlvbih0aW1lc3RhbXApIHtcbiAgICAvLyAxMDBtcyB0b2xlcmFuY2UgZm9yIHJhY2UgY29uZGl0aW9uIGJldHdlZW4gd2hlbiB3ZSByZWNvcmQgdGhlIGNsaWNrIGFuZCB0aGUgY2hhbmdlIGV2ZW50XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYW5nZUV2ZW50VGltZXN0YW1wID49ICh0aW1lc3RhbXAgLSAxMDApO1xufTtcblxuRGVhZENsaWNrVHJhY2tlci5wcm90b3R5cGUucmVjb3JkQ2hhbmdlRXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmxhc3RDaGFuZ2VFdmVudFRpbWVzdGFtcCA9IERhdGUubm93KCk7XG59O1xuXG5EZWFkQ2xpY2tUcmFja2VyLnByb3RvdHlwZS50cmlnZ2VyUHJvY2Vzc2luZyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIC8vIFByZXZlbnQgbXVsdGlwbGUgY29uY3VycmVudCBwcm9jZXNzaW5nIGNoYWluc1xuICAgIGlmICh0aGlzLnByb2Nlc3NpbmdBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnByb2Nlc3NpbmdBY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMucHJvY2Vzc1JlY3Vyc2l2ZWx5KGNvbmZpZyk7XG59O1xuXG5EZWFkQ2xpY2tUcmFja2VyLnByb3RvdHlwZS5wcm9jZXNzUmVjdXJzaXZlbHkgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICBpZiAoIXRoaXMuaXNUcmFja2luZyB8fCAhdGhpcy5vbkRlYWRDbGlja0NhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRpbWVvdXRNcyA9IGNvbmZpZ1sndGltZW91dF9tcyddO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMucHJvY2Vzc2luZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXNlbGYucHJvY2Vzc2luZ0FjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlYWRDbGlja3MgPSBzZWxmLmdldERlYWRDbGlja3MoY29uZmlnKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlYWRDbGlja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNlbGYub25EZWFkQ2xpY2tDYWxsYmFjayhkZWFkQ2xpY2tzW2ldLmV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLnBlbmRpbmdDbGlja3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc2VsZi5wcm9jZXNzUmVjdXJzaXZlbHkoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYucHJvY2Vzc2luZ0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSwgdGltZW91dE1zKTtcbn07XG5cbkRlYWRDbGlja1RyYWNrZXIucHJvdG90eXBlLnN0YXJ0VHJhY2tpbmcgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5pc1RyYWNraW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmlzVHJhY2tpbmcgPSB0cnVlO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgSU5URVJBQ1RJT05fRVZFTlRTLmZvckVhY2goZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYucmVjb3JkQ2hhbmdlRXZlbnQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgeyBjYXB0dXJlOiB0cnVlLCBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICBzZWxmLmV2ZW50TGlzdGVuZXJzLnB1c2goeyB0YXJnZXQ6IGRvY3VtZW50LCBldmVudDogZXZlbnQsIGhhbmRsZXI6IGhhbmRsZXIsIG9wdGlvbnM6IHsgY2FwdHVyZTogdHJ1ZSwgcGFzc2l2ZTogdHJ1ZSB9IH0pO1xuICAgIH0pO1xuICAgIE5BVklHQVRJT05fRVZFTlRTLmZvckVhY2goZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYucmVjb3JkQ2hhbmdlRXZlbnQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgICBzZWxmLmV2ZW50TGlzdGVuZXJzLnB1c2goeyB0YXJnZXQ6IHdpbmRvdywgZXZlbnQ6IGV2ZW50LCBoYW5kbGVyOiBoYW5kbGVyIH0pO1xuICAgIH0pO1xuICAgIExBWU9VVF9FVkVOVFMuZm9yRWFjaChmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5yZWNvcmRDaGFuZ2VFdmVudCgpO1xuICAgICAgICB9O1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICBzZWxmLmV2ZW50TGlzdGVuZXJzLnB1c2goeyB0YXJnZXQ6IHdpbmRvdywgZXZlbnQ6IGV2ZW50LCBoYW5kbGVyOiBoYW5kbGVyLCBvcHRpb25zOiB7IHBhc3NpdmU6IHRydWUgfSB9KTtcbiAgICB9KTtcbiAgICB2YXIgc2VsZWN0aW9uSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLnJlY29yZENoYW5nZUV2ZW50KCk7XG4gICAgfTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBzZWxlY3Rpb25IYW5kbGVyKTtcbiAgICBzZWxmLmV2ZW50TGlzdGVuZXJzLnB1c2goeyB0YXJnZXQ6IGRvY3VtZW50LCBldmVudDogJ3NlbGVjdGlvbmNoYW5nZScsIGhhbmRsZXI6IHNlbGVjdGlvbkhhbmRsZXIgfSk7XG5cbiAgICAvLyBTZXQgdXAgTXV0YXRpb25PYnNlcnZlclxuICAgIGlmICh3aW5kb3cuTXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyID0gbmV3IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYucmVjb3JkQ2hhbmdlRXZlbnQoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgTVVUQVRJT05fT0JTRVJWRVJfQ09ORklHKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nZ2VyJDEuY3JpdGljYWwoJ0Vycm9yIHdoaWxlIHNldHRpbmcgdXAgbXV0YXRpb24gb2JzZXJ2ZXInLCBlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCB1cCBTaGFkb3cgRE9NIG9ic2VydmVyXG4gICAgaWYgKHdpbmRvdy5jdXN0b21FbGVtZW50cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zaGFkb3dET01PYnNlcnZlciA9IG5ldyBTaGFkb3dET01PYnNlcnZlcihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZWNvcmRDaGFuZ2VFdmVudCgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgTVVUQVRJT05fT0JTRVJWRVJfQ09ORklHXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5zaGFkb3dET01PYnNlcnZlci5zdGFydCgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dnZXIkMS5jcml0aWNhbCgnRXJyb3Igd2hpbGUgc2V0dGluZyB1cCBzaGFkb3cgRE9NIG9ic2VydmVyJywgZSk7XG4gICAgICAgICAgICB0aGlzLnNoYWRvd0RPTU9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkRlYWRDbGlja1RyYWNrZXIucHJvdG90eXBlLnN0b3BUcmFja2luZyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5pc1RyYWNraW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmlzVHJhY2tpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnBlbmRpbmdDbGlja3MgPSBbXTtcbiAgICB0aGlzLmxhc3RDaGFuZ2VFdmVudFRpbWVzdGFtcCA9IDA7XG4gICAgdGhpcy5wcm9jZXNzaW5nQWN0aXZlID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5wcm9jZXNzaW5nVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wcm9jZXNzaW5nVGltZW91dCk7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ1RpbWVvdXQgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbGwgZXZlbnQgbGlzdGVuZXJzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmV2ZW50TGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lciA9IHRoaXMuZXZlbnRMaXN0ZW5lcnNbaV07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsaXN0ZW5lci50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihsaXN0ZW5lci5ldmVudCwgbGlzdGVuZXIuaGFuZGxlciwgbGlzdGVuZXIub3B0aW9ucyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlciQxLmNyaXRpY2FsKCdFcnJvciB3aGlsZSByZW1vdmluZyBldmVudCBsaXN0ZW5lcicsIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMgPSBbXTtcblxuICAgIGlmICh0aGlzLm11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlciQxLmNyaXRpY2FsKCdFcnJvciB3aGlsZSBkaXNjb25uZWN0aW5nIG11dGF0aW9uIG9ic2VydmVyJywgZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zaGFkb3dET01PYnNlcnZlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zaGFkb3dET01PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlciQxLmNyaXRpY2FsKCdFcnJvciB3aGlsZSBzdG9wcGluZyBzaGFkb3cgRE9NIG9ic2VydmVyJywgZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaGFkb3dET01PYnNlcnZlciA9IG51bGw7XG4gICAgfVxufTtcblxudmFyIEFVVE9DQVBUVVJFX0NPTkZJR19LRVkgPSAnYXV0b2NhcHR1cmUnO1xudmFyIExFR0FDWV9QQUdFVklFV19DT05GSUdfS0VZID0gJ3RyYWNrX3BhZ2V2aWV3JztcblxudmFyIFBBR0VWSUVXX09QVElPTl9GVUxMX1VSTCA9ICdmdWxsLXVybCc7XG52YXIgUEFHRVZJRVdfT1BUSU9OX1VSTF9XSVRIX1BBVEhfQU5EX1FVRVJZX1NUUklORyA9ICd1cmwtd2l0aC1wYXRoLWFuZC1xdWVyeS1zdHJpbmcnO1xudmFyIFBBR0VWSUVXX09QVElPTl9VUkxfV0lUSF9QQVRIID0gJ3VybC13aXRoLXBhdGgnO1xuXG52YXIgQ09ORklHX0FMTE9XX0VMRU1FTlRfQ0FMTEJBQ0sgPSAnYWxsb3dfZWxlbWVudF9jYWxsYmFjayc7XG52YXIgQ09ORklHX0FMTE9XX1NFTEVDVE9SUyA9ICdhbGxvd19zZWxlY3RvcnMnO1xudmFyIENPTkZJR19BTExPV19VUkxfUkVHRVhFUyA9ICdhbGxvd191cmxfcmVnZXhlcyc7XG52YXIgQ09ORklHX0JMT0NLX0FUVFJTID0gJ2Jsb2NrX2F0dHJzJztcbnZhciBDT05GSUdfQkxPQ0tfRUxFTUVOVF9DQUxMQkFDSyA9ICdibG9ja19lbGVtZW50X2NhbGxiYWNrJztcbnZhciBDT05GSUdfQkxPQ0tfU0VMRUNUT1JTID0gJ2Jsb2NrX3NlbGVjdG9ycyc7XG52YXIgQ09ORklHX0JMT0NLX1VSTF9SRUdFWEVTID0gJ2Jsb2NrX3VybF9yZWdleGVzJztcbnZhciBDT05GSUdfQ0FQVFVSRV9FWFRSQV9BVFRSUyA9ICdjYXB0dXJlX2V4dHJhX2F0dHJzJztcbnZhciBDT05GSUdfQ0FQVFVSRV9URVhUX0NPTlRFTlQgPSAnY2FwdHVyZV90ZXh0X2NvbnRlbnQnO1xudmFyIENPTkZJR19TQ1JPTExfQ0FQVFVSRV9BTEwgPSAnc2Nyb2xsX2NhcHR1cmVfYWxsJztcbnZhciBDT05GSUdfU0NST0xMX0NIRUNLUE9JTlRTID0gJ3Njcm9sbF9kZXB0aF9wZXJjZW50X2NoZWNrcG9pbnRzJztcbnZhciBDT05GSUdfVFJBQ0tfQ0xJQ0sgPSAnY2xpY2snO1xudmFyIENPTkZJR19UUkFDS19ERUFEX0NMSUNLID0gJ2RlYWRfY2xpY2snO1xudmFyIENPTkZJR19UUkFDS19JTlBVVCA9ICdpbnB1dCc7XG52YXIgQ09ORklHX1RSQUNLX1BBR0VWSUVXID0gJ3BhZ2V2aWV3JztcbnZhciBDT05GSUdfVFJBQ0tfUkFHRV9DTElDSyA9ICdyYWdlX2NsaWNrJztcbnZhciBDT05GSUdfVFJBQ0tfU0NST0xMID0gJ3Njcm9sbCc7XG52YXIgQ09ORklHX1RSQUNLX1BBR0VfTEVBVkUgPSAncGFnZV9sZWF2ZSc7XG52YXIgQ09ORklHX1RSQUNLX1NVQk1JVCA9ICdzdWJtaXQnO1xuXG52YXIgQ09ORklHX0RFRkFVTFRTJDEgPSB7fTtcbkNPTkZJR19ERUZBVUxUUyQxW0NPTkZJR19BTExPV19TRUxFQ1RPUlNdID0gW107XG5DT05GSUdfREVGQVVMVFMkMVtDT05GSUdfQUxMT1dfVVJMX1JFR0VYRVNdID0gW107XG5DT05GSUdfREVGQVVMVFMkMVtDT05GSUdfQkxPQ0tfQVRUUlNdID0gW107XG5DT05GSUdfREVGQVVMVFMkMVtDT05GSUdfQkxPQ0tfRUxFTUVOVF9DQUxMQkFDS10gPSBudWxsO1xuQ09ORklHX0RFRkFVTFRTJDFbQ09ORklHX0JMT0NLX1NFTEVDVE9SU10gPSBbXTtcbkNPTkZJR19ERUZBVUxUUyQxW0NPTkZJR19CTE9DS19VUkxfUkVHRVhFU10gPSBbXTtcbkNPTkZJR19ERUZBVUxUUyQxW0NPTkZJR19DQVBUVVJFX0VYVFJBX0FUVFJTXSA9IFtdO1xuQ09ORklHX0RFRkFVTFRTJDFbQ09ORklHX0NBUFRVUkVfVEVYVF9DT05URU5UXSA9IGZhbHNlO1xuQ09ORklHX0RFRkFVTFRTJDFbQ09ORklHX1NDUk9MTF9DQVBUVVJFX0FMTF0gPSBmYWxzZTtcbkNPTkZJR19ERUZBVUxUUyQxW0NPTkZJR19TQ1JPTExfQ0hFQ0tQT0lOVFNdID0gWzI1LCA1MCwgNzUsIDEwMF07XG5DT05GSUdfREVGQVVMVFMkMVtDT05GSUdfVFJBQ0tfQ0xJQ0tdID0gdHJ1ZTtcbkNPTkZJR19ERUZBVUxUUyQxW0NPTkZJR19UUkFDS19ERUFEX0NMSUNLXSA9IHRydWU7XG5DT05GSUdfREVGQVVMVFMkMVtDT05GSUdfVFJBQ0tfSU5QVVRdID0gdHJ1ZTtcbkNPTkZJR19ERUZBVUxUUyQxW0NPTkZJR19UUkFDS19QQUdFVklFV10gPSBQQUdFVklFV19PUFRJT05fRlVMTF9VUkw7XG5DT05GSUdfREVGQVVMVFMkMVtDT05GSUdfVFJBQ0tfUkFHRV9DTElDS10gPSB0cnVlO1xuQ09ORklHX0RFRkFVTFRTJDFbQ09ORklHX1RSQUNLX1NDUk9MTF0gPSB0cnVlO1xuQ09ORklHX0RFRkFVTFRTJDFbQ09ORklHX1RSQUNLX1BBR0VfTEVBVkVdID0gZmFsc2U7XG5DT05GSUdfREVGQVVMVFMkMVtDT05GSUdfVFJBQ0tfU1VCTUlUXSA9IHRydWU7XG5cbnZhciBERUZBVUxUX1BST1BTID0ge1xuICAgICckbXBfYXV0b2NhcHR1cmUnOiB0cnVlXG59O1xuXG52YXIgTVBfRVZfQ0xJQ0sgPSAnJG1wX2NsaWNrJztcbnZhciBNUF9FVl9ERUFEX0NMSUNLID0gJyRtcF9kZWFkX2NsaWNrJztcbnZhciBNUF9FVl9JTlBVVCA9ICckbXBfaW5wdXRfY2hhbmdlJztcbnZhciBNUF9FVl9SQUdFX0NMSUNLID0gJyRtcF9yYWdlX2NsaWNrJztcbnZhciBNUF9FVl9TQ1JPTEwgPSAnJG1wX3Njcm9sbCc7XG52YXIgTVBfRVZfU1VCTUlUID0gJyRtcF9zdWJtaXQnO1xudmFyIE1QX0VWX1BBR0VfTEVBVkUgPSAnJG1wX3BhZ2VfbGVhdmUnO1xuXG4vKipcbiAqIEF1dG9jYXB0dXJlOiBtYW5hZ2VzIGF1dG9tYXRpYyBldmVudCB0cmFja2luZ1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBBdXRvY2FwdHVyZSA9IGZ1bmN0aW9uKG1wKSB7XG4gICAgdGhpcy5tcCA9IG1wO1xuICAgIHRoaXMubWF4U2Nyb2xsVmlld0RlcHRoID0gMDtcbiAgICB0aGlzLmhhc1RyYWNrZWRTY3JvbGxTZXNzaW9uID0gZmFsc2U7XG4gICAgdGhpcy5wcmV2aW91c1Njcm9sbEhlaWdodCA9IDA7XG59O1xuXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghbWluRE9NQXBpc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgIGxvZ2dlciQxLmNyaXRpY2FsKCdBdXRvY2FwdHVyZSB1bmF2YWlsYWJsZTogbWlzc2luZyByZXF1aXJlZCBET00gQVBJcycpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaW5pdFBhZ2VMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmluaXRQYWdldmlld1RyYWNraW5nKCk7XG4gICAgdGhpcy5pbml0Q2xpY2tUcmFja2luZygpO1xuICAgIHRoaXMuaW5pdERlYWRDbGlja1RyYWNraW5nKCk7XG4gICAgdGhpcy5pbml0SW5wdXRUcmFja2luZygpO1xuICAgIHRoaXMuaW5pdFNjcm9sbFRyYWNraW5nKCk7XG4gICAgdGhpcy5pbml0U3VibWl0VHJhY2tpbmcoKTtcbiAgICB0aGlzLmluaXRSYWdlQ2xpY2tUcmFja2luZygpO1xuICAgIHRoaXMuaW5pdFBhZ2VMZWF2ZVRyYWNraW5nKCk7XG59O1xuXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUuZ2V0RnVsbENvbmZpZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhdXRvY2FwdHVyZUNvbmZpZyA9IHRoaXMubXAuZ2V0X2NvbmZpZyhBVVRPQ0FQVFVSRV9DT05GSUdfS0VZKTtcbiAgICBpZiAoIWF1dG9jYXB0dXJlQ29uZmlnKSB7XG4gICAgICAgIC8vIEF1dG9jYXB0dXJlIGlzIGNvbXBsZXRlbHkgb2ZmXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QoYXV0b2NhcHR1cmVDb25maWcpKSB7XG4gICAgICAgIHJldHVybiBfLmV4dGVuZCh7fSwgQ09ORklHX0RFRkFVTFRTJDEsIGF1dG9jYXB0dXJlQ29uZmlnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdXRvY2FwdHVyZSBjb25maWcgaXMgbm9uLW9iamVjdCB0cnV0aHkgdmFsdWUsIHJldHVybiBkZWZhdWx0XG4gICAgICAgIHJldHVybiBDT05GSUdfREVGQVVMVFMkMTtcbiAgICB9XG59O1xuXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RnVsbENvbmZpZygpW2tleV07XG59O1xuXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUuY3VycmVudFVybEJsb2NrZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgY3VycmVudFVybCA9IF8uaW5mby5jdXJyZW50VXJsKCk7XG5cbiAgICB2YXIgYWxsb3dVcmxSZWdleGVzID0gdGhpcy5nZXRDb25maWcoQ09ORklHX0FMTE9XX1VSTF9SRUdFWEVTKSB8fCBbXTtcbiAgICBpZiAoYWxsb3dVcmxSZWdleGVzLmxlbmd0aCkge1xuICAgICAgICAvLyB3ZSdyZSB1c2luZyBhbiBhbGxvd2xpc3QsIG9ubHkgdHJhY2sgaWYgY3VycmVudCBVUkwgbWF0Y2hlc1xuICAgICAgICB2YXIgYWxsb3dlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYWxsb3dVcmxSZWdleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYWxsb3dSZWdleCA9IGFsbG93VXJsUmVnZXhlc1tpXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRVcmwubWF0Y2goYWxsb3dSZWdleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGxvZ2dlciQxLmNyaXRpY2FsKCdFcnJvciB3aGlsZSBjaGVja2luZyBibG9jayBVUkwgcmVnZXg6ICcgKyBhbGxvd1JlZ2V4LCBlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYWxsb3dlZCkge1xuICAgICAgICAgICAgLy8gd2Fzbid0IGFsbG93ZWQgYnkgYW55IHJlZ2V4XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBibG9ja1VybFJlZ2V4ZXMgPSB0aGlzLmdldENvbmZpZyhDT05GSUdfQkxPQ0tfVVJMX1JFR0VYRVMpIHx8IFtdO1xuICAgIGlmICghYmxvY2tVcmxSZWdleGVzIHx8ICFibG9ja1VybFJlZ2V4ZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tVcmxSZWdleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFVybC5tYXRjaChibG9ja1VybFJlZ2V4ZXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyJDEuY3JpdGljYWwoJ0Vycm9yIHdoaWxlIGNoZWNraW5nIGJsb2NrIFVSTCByZWdleDogJyArIGJsb2NrVXJsUmVnZXhlc1tpXSwgZXJyKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbkF1dG9jYXB0dXJlLnByb3RvdHlwZS5wYWdldmlld1RyYWNraW5nQ29uZmlnID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gc3VwcG9ydHMgYm90aCBhdXRvY2FwdHVyZSBjb25maWcgYW5kIG9sZCB0cmFja19wYWdldmlldyBjb25maWdcbiAgICBpZiAodGhpcy5tcC5nZXRfY29uZmlnKEFVVE9DQVBUVVJFX0NPTkZJR19LRVkpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbmZpZyhDT05GSUdfVFJBQ0tfUEFHRVZJRVcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1wLmdldF9jb25maWcoTEVHQUNZX1BBR0VWSUVXX0NPTkZJR19LRVkpO1xuICAgIH1cbn07XG5cbi8vIGhlbHBlciBmb3IgZXZlbnQgaGFuZGxlcnNcbkF1dG9jYXB0dXJlLnByb3RvdHlwZS50cmFja0RvbUV2ZW50ID0gZnVuY3Rpb24oZXYsIG1wRXZlbnROYW1lKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudFVybEJsb2NrZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGlzQ2FwdHVyZWRGb3JIZWF0TWFwID0gdGhpcy5tcC5pc19yZWNvcmRpbmdfaGVhdG1hcF9kYXRhKCkgJiYgKFxuICAgICAgICAobXBFdmVudE5hbWUgPT09IE1QX0VWX0NMSUNLICYmICF0aGlzLmdldENvbmZpZyhDT05GSUdfVFJBQ0tfQ0xJQ0spKSB8fFxuICAgICAgICAobXBFdmVudE5hbWUgPT09IE1QX0VWX1JBR0VfQ0xJQ0sgJiYgIXRoaXMuX2dldENsaWNrVHJhY2tpbmdDb25maWcoQ09ORklHX1RSQUNLX1JBR0VfQ0xJQ0spKSB8fFxuICAgICAgICAobXBFdmVudE5hbWUgPT09IE1QX0VWX0RFQURfQ0xJQ0sgJiYgIXRoaXMuX2dldENsaWNrVHJhY2tpbmdDb25maWcoQ09ORklHX1RSQUNLX0RFQURfQ0xJQ0spKVxuICAgICk7XG5cbiAgICB2YXIgcHJvcHMgPSBnZXRQcm9wc0ZvckRPTUV2ZW50KGV2LCB7XG4gICAgICAgIGFsbG93RWxlbWVudENhbGxiYWNrOiB0aGlzLmdldENvbmZpZyhDT05GSUdfQUxMT1dfRUxFTUVOVF9DQUxMQkFDSyksXG4gICAgICAgIGFsbG93U2VsZWN0b3JzOiB0aGlzLmdldENvbmZpZyhDT05GSUdfQUxMT1dfU0VMRUNUT1JTKSxcbiAgICAgICAgYmxvY2tBdHRyczogdGhpcy5nZXRDb25maWcoQ09ORklHX0JMT0NLX0FUVFJTKSxcbiAgICAgICAgYmxvY2tFbGVtZW50Q2FsbGJhY2s6IHRoaXMuZ2V0Q29uZmlnKENPTkZJR19CTE9DS19FTEVNRU5UX0NBTExCQUNLKSxcbiAgICAgICAgYmxvY2tTZWxlY3RvcnM6IHRoaXMuZ2V0Q29uZmlnKENPTkZJR19CTE9DS19TRUxFQ1RPUlMpLFxuICAgICAgICBjYXB0dXJlRXh0cmFBdHRyczogdGhpcy5nZXRDb25maWcoQ09ORklHX0NBUFRVUkVfRVhUUkFfQVRUUlMpLFxuICAgICAgICBjYXB0dXJlVGV4dENvbnRlbnQ6IHRoaXMuZ2V0Q29uZmlnKENPTkZJR19DQVBUVVJFX1RFWFRfQ09OVEVOVCksXG4gICAgICAgIGNhcHR1cmVkRm9ySGVhdE1hcDogaXNDYXB0dXJlZEZvckhlYXRNYXAsXG4gICAgfSk7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIF8uZXh0ZW5kKHByb3BzLCBERUZBVUxUX1BST1BTKTtcbiAgICAgICAgdGhpcy5tcC50cmFjayhtcEV2ZW50TmFtZSwgcHJvcHMpO1xuICAgIH1cbn07XG5cbkF1dG9jYXB0dXJlLnByb3RvdHlwZS5pbml0UGFnZUxpc3RlbmVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKEVWX1BPUFNUQVRFLCB0aGlzLmxpc3RlbmVyUG9wc3RhdGUpO1xuICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKEVWX0hBU0hDSEFOR0UsIHRoaXMubGlzdGVuZXJIYXNoY2hhbmdlKTtcblxuICAgIGlmICghdGhpcy5wYWdldmlld1RyYWNraW5nQ29uZmlnKCkgJiYgIXRoaXMuZ2V0Q29uZmlnKENPTkZJR19UUkFDS19QQUdFX0xFQVZFKSAmJiAhdGhpcy5tcC5nZXRfY29uZmlnKCdyZWNvcmRfaGVhdG1hcF9kYXRhJykpIHtcbiAgICAgICAgLy8gVGhlc2UgYXJlIGFsbCB0aGUgY29uZmlncyB0aGF0IHVzZSB0aGVzZSBsaXN0ZW5lcnNcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubGlzdGVuZXJQb3BzdGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB3aW4uZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZfTVBfTE9DQVRJT05fQ0hBTkdFKSk7XG4gICAgfTtcbiAgICB0aGlzLmxpc3RlbmVySGFzaGNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB3aW4uZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZfTVBfTE9DQVRJT05fQ0hBTkdFKSk7XG4gICAgfTtcblxuICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKEVWX1BPUFNUQVRFLCB0aGlzLmxpc3RlbmVyUG9wc3RhdGUpO1xuICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKEVWX0hBU0hDSEFOR0UsIHRoaXMubGlzdGVuZXJIYXNoY2hhbmdlKTtcbiAgICB2YXIgbmF0aXZlUHVzaFN0YXRlID0gd2luLmhpc3RvcnkucHVzaFN0YXRlO1xuICAgIGlmICh0eXBlb2YgbmF0aXZlUHVzaFN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdpbi5oaXN0b3J5LnB1c2hTdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlLCB1bnVzZWQsIHVybCkge1xuICAgICAgICAgICAgbmF0aXZlUHVzaFN0YXRlLmNhbGwod2luLmhpc3RvcnksIHN0YXRlLCB1bnVzZWQsIHVybCk7XG4gICAgICAgICAgICB3aW4uZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZfTVBfTE9DQVRJT05fQ0hBTkdFKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBuYXRpdmVSZXBsYWNlU3RhdGUgPSB3aW4uaGlzdG9yeS5yZXBsYWNlU3RhdGU7XG4gICAgaWYgKHR5cGVvZiBuYXRpdmVSZXBsYWNlU3RhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2luLmhpc3RvcnkucmVwbGFjZVN0YXRlID0gZnVuY3Rpb24oc3RhdGUsIHVudXNlZCwgdXJsKSB7XG4gICAgICAgICAgICBuYXRpdmVSZXBsYWNlU3RhdGUuY2FsbCh3aW4uaGlzdG9yeSwgc3RhdGUsIHVudXNlZCwgdXJsKTtcbiAgICAgICAgICAgIHdpbi5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVl9NUF9MT0NBVElPTl9DSEFOR0UpKTtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUuX2dldENsaWNrVHJhY2tpbmdDb25maWcgPSBmdW5jdGlvbihjb25maWdLZXkpIHtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5nZXRDb25maWcoY29uZmlnS2V5KTtcblxuICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBudWxsOyAvLyBjbGljayB0cmFja2luZyBkaXNhYmxlZFxuICAgIH1cblxuICAgIGlmIChjb25maWcgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHt9OyAvLyB1c2UgZGVmYXVsdHNcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZzsgLy8gdXNlIGN1c3RvbSBjb25maWd1cmF0aW9uXG4gICAgfVxuXG4gICAgcmV0dXJuIHt9OyAvLyBmYWxsYmFjayB0byBkZWZhdWx0cyBmb3IgYW55IG90aGVyIHRydXRoeSB2YWx1ZVxufTtcblxuQXV0b2NhcHR1cmUucHJvdG90eXBlLl90cmFja1BhZ2VMZWF2ZSA9IGZ1bmN0aW9uKGV2LCBjdXJyZW50VXJsLCBjdXJyZW50U2Nyb2xsSGVpZ2h0KSB7XG4gICAgaWYgKHRoaXMuaGFzVHJhY2tlZFNjcm9sbFNlc3Npb24pIHtcbiAgICAgICAgLy8gVXNlciBoYXMgbmF2aWdhdGVkIGF3YXkgYWxyZWFkeSBlbmRpbmcgdGhlaXIgaW1wcmVzc2lvbi5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5nZXRDb25maWcoQ09ORklHX1RSQUNLX1BBR0VfTEVBVkUpICYmICF0aGlzLm1wLmlzX3JlY29yZGluZ19oZWF0bWFwX2RhdGEoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5oYXNUcmFja2VkU2Nyb2xsU2Vzc2lvbiA9IHRydWU7XG4gICAgdmFyIHZpZXdwb3J0SGVpZ2h0ID0gTWF0aC5tYXgoZG9jdW1lbnQkMS5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LCB3aW4uaW5uZXJIZWlnaHQgfHwgMCk7XG4gICAgdmFyIHNjcm9sbFBlcmNlbnRhZ2UgPSBNYXRoLnJvdW5kKE1hdGgubWF4KHRoaXMubWF4U2Nyb2xsVmlld0RlcHRoIC0gdmlld3BvcnRIZWlnaHQsIDApIC8gKGN1cnJlbnRTY3JvbGxIZWlnaHQgLSB2aWV3cG9ydEhlaWdodCkgKiAxMDApO1xuICAgIHZhciBmb2xkTGluZVBlcmNlbnRhZ2UgPSBNYXRoLnJvdW5kKCh2aWV3cG9ydEhlaWdodCAvIGN1cnJlbnRTY3JvbGxIZWlnaHQpICogMTAwKTtcbiAgICBpZiAoY3VycmVudFNjcm9sbEhlaWdodCA8PSB2aWV3cG9ydEhlaWdodCkge1xuICAgICAgICAvLyBJZiB0aGUgY29udGVudCBmaXRzIHdpdGhpbiB0aGUgdmlld3BvcnQsIGNvbnNpZGVyIGl0IGZ1bGx5IHNjcm9sbGVkXG4gICAgICAgIHNjcm9sbFBlcmNlbnRhZ2UgPSAxMDA7XG4gICAgICAgIGZvbGRMaW5lUGVyY2VudGFnZSA9IDEwMDtcbiAgICB9XG5cbiAgICB2YXIgcHJvcHMgPSBfLmV4dGVuZCh7XG4gICAgICAgICckbWF4X3Njcm9sbF92aWV3X2RlcHRoJzogdGhpcy5tYXhTY3JvbGxWaWV3RGVwdGgsXG4gICAgICAgICckbWF4X3Njcm9sbF9wZXJjZW50YWdlJzogc2Nyb2xsUGVyY2VudGFnZSxcbiAgICAgICAgJyRmb2xkX2xpbmVfcGVyY2VudGFnZSc6IGZvbGRMaW5lUGVyY2VudGFnZSxcbiAgICAgICAgJyRzY3JvbGxfaGVpZ2h0JzogIGN1cnJlbnRTY3JvbGxIZWlnaHQsXG4gICAgICAgICckZXZlbnRfdHlwZSc6IGV2LnR5cGUsXG4gICAgICAgICckY3VycmVudF91cmwnOiBjdXJyZW50VXJsIHx8IF8uaW5mby5jdXJyZW50VXJsKCksXG4gICAgICAgICckdmlld3BvcnRIZWlnaHQnOiB2aWV3cG9ydEhlaWdodCwgLy8gVGhpcyBpcyB0aGUgZm9sZCBsaW5lXG4gICAgICAgICckdmlld3BvcnRXaWR0aCc6ICBNYXRoLm1heChkb2N1bWVudCQxLmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCwgd2luLmlubmVyV2lkdGggfHwgMCksXG4gICAgICAgICckY2FwdHVyZWRfZm9yX2hlYXRtYXAnOiB0aGlzLm1wLmlzX3JlY29yZGluZ19oZWF0bWFwX2RhdGEoKVxuICAgIH0sIERFRkFVTFRfUFJPUFMpO1xuXG4gICAgLy8gU2VuZCB3aXRoIGJlYWNvbiB0cmFuc3BvcnQgdG8gZW5zdXJlIGV2ZW50IGlzIHNlbnQgYmVmb3JlIHVubG9hZFxuICAgIHRoaXMubXAudHJhY2soTVBfRVZfUEFHRV9MRUFWRSwgcHJvcHMsIHt0cmFuc3BvcnQ6ICdzZW5kQmVhY29uJ30pO1xufTtcblxuQXV0b2NhcHR1cmUucHJvdG90eXBlLl9pbml0U2Nyb2xsRGVwdGhUcmFja2luZyA9IGZ1bmN0aW9uKCkge1xuICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKEVWX1NDUk9MTCwgdGhpcy5saXN0ZW5lclNjcm9sbERlcHRoKTtcbiAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVl9TQ1JPTExFTkQsIHRoaXMubGlzdGVuZXJTY3JvbGxEZXB0aCk7XG5cbiAgICBpZiAoIXRoaXMubXAuZ2V0X2NvbmZpZygncmVjb3JkX2hlYXRtYXBfZGF0YScpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsb2dnZXIkMS5sb2coJ0luaXRpYWxpemluZyBzY3JvbGwgZGVwdGggdHJhY2tpbmcnKTtcblxuICAgIHRoaXMubWF4U2Nyb2xsVmlld0RlcHRoID0gTWF0aC5tYXgoZG9jdW1lbnQkMS5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LCB3aW4uaW5uZXJIZWlnaHQgfHwgMCk7XG5cbiAgICB2YXIgdXBkYXRlU2Nyb2xsRGVwdGggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFVybEJsb2NrZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY3JvbGxWaWV3SGVpZ2h0ID0gTWF0aC5tYXgoZG9jdW1lbnQkMS5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LCB3aW4uaW5uZXJIZWlnaHQgfHwgMCkgKyB3aW4uc2Nyb2xsWTtcbiAgICAgICAgaWYgKHNjcm9sbFZpZXdIZWlnaHQgPiB0aGlzLm1heFNjcm9sbFZpZXdEZXB0aCkge1xuICAgICAgICAgICAgdGhpcy5tYXhTY3JvbGxWaWV3RGVwdGggPSBzY3JvbGxWaWV3SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJldmlvdXNTY3JvbGxIZWlnaHQgPSBkb2N1bWVudCQxLmJvZHkuc2Nyb2xsSGVpZ2h0O1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHZhciBzY3JvbGxFbmRQb2x5ZmlsbCA9IGdldFBvbHlmaWxsU2Nyb2xsRW5kRnVuY3Rpb24odXBkYXRlU2Nyb2xsRGVwdGgpO1xuICAgIHRoaXMubGlzdGVuZXJTY3JvbGxEZXB0aCA9IHNjcm9sbEVuZFBvbHlmaWxsLmxpc3RlbmVyO1xuICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKHNjcm9sbEVuZFBvbHlmaWxsLmV2ZW50VHlwZSwgdGhpcy5saXN0ZW5lclNjcm9sbERlcHRoKTtcbn07XG5cbkF1dG9jYXB0dXJlLnByb3RvdHlwZS5pbml0Q2xpY2tUcmFja2luZyA9IGZ1bmN0aW9uKCkge1xuICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKEVWX0NMSUNLLCB0aGlzLmxpc3RlbmVyQ2xpY2spO1xuXG4gICAgaWYgKCF0aGlzLmdldENvbmZpZyhDT05GSUdfVFJBQ0tfQ0xJQ0spICYmICF0aGlzLm1wLmdldF9jb25maWcoJ3JlY29yZF9oZWF0bWFwX2RhdGEnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvZ2dlciQxLmxvZygnSW5pdGlhbGl6aW5nIGNsaWNrIHRyYWNraW5nJyk7XG5cbiAgICB0aGlzLmxpc3RlbmVyQ2xpY2sgPSBmdW5jdGlvbihldikge1xuICAgICAgICBpZiAoIXRoaXMuZ2V0Q29uZmlnKENPTkZJR19UUkFDS19DTElDSykgJiYgIXRoaXMubXAuaXNfcmVjb3JkaW5nX2hlYXRtYXBfZGF0YSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFja0RvbUV2ZW50KGV2LCBNUF9FVl9DTElDSyk7XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKEVWX0NMSUNLLCB0aGlzLmxpc3RlbmVyQ2xpY2spO1xufTtcblxuQXV0b2NhcHR1cmUucHJvdG90eXBlLmluaXREZWFkQ2xpY2tUcmFja2luZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkZWFkQ2xpY2tDb25maWcgPSB0aGlzLl9nZXRDbGlja1RyYWNraW5nQ29uZmlnKENPTkZJR19UUkFDS19ERUFEX0NMSUNLKTtcblxuICAgIGlmICghZGVhZENsaWNrQ29uZmlnICYmICF0aGlzLm1wLmdldF9jb25maWcoJ3JlY29yZF9oZWF0bWFwX2RhdGEnKSkge1xuICAgICAgICB0aGlzLnN0b3BEZWFkQ2xpY2tUcmFja2luZygpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbG9nZ2VyJDEubG9nKCdJbml0aWFsaXppbmcgZGVhZCBjbGljayB0cmFja2luZycpO1xuICAgIGlmICghdGhpcy5fZGVhZENsaWNrVHJhY2tlcikge1xuICAgICAgICB0aGlzLl9kZWFkQ2xpY2tUcmFja2VyID0gbmV3IERlYWRDbGlja1RyYWNrZXIoZnVuY3Rpb24oZGVhZENsaWNrRXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2tEb21FdmVudChkZWFkQ2xpY2tFdmVudCwgTVBfRVZfREVBRF9DTElDSyk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX2RlYWRDbGlja1RyYWNrZXIuc3RhcnRUcmFja2luZygpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5saXN0ZW5lckRlYWRDbGljaykge1xuICAgICAgICB0aGlzLmxpc3RlbmVyRGVhZENsaWNrID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50RGVhZENsaWNrQ29uZmlnID0gdGhpcy5fZ2V0Q2xpY2tUcmFja2luZ0NvbmZpZyhDT05GSUdfVFJBQ0tfREVBRF9DTElDSyk7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnREZWFkQ2xpY2tDb25maWcgJiYgIXRoaXMubXAuaXNfcmVjb3JkaW5nX2hlYXRtYXBfZGF0YSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFVybEJsb2NrZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBjb25maWcgdG8gZW5zdXJlIHRpbWVvdXRfbXMgaXMgYWx3YXlzIHNldFxuICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRDb25maWcgPSBjdXJyZW50RGVhZENsaWNrQ29uZmlnIHx8IHt9O1xuICAgICAgICAgICAgaWYgKCFub3JtYWxpemVkQ29uZmlnWyd0aW1lb3V0X21zJ10pIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkQ29uZmlnWyd0aW1lb3V0X21zJ10gPSBERUZBVUxUX0RFQURfQ0xJQ0tfVElNRU9VVF9NUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RlYWRDbGlja1RyYWNrZXIudHJhY2tDbGljayhldiwgbm9ybWFsaXplZENvbmZpZyk7XG4gICAgICAgIH0uYmluZCh0aGlzKTtcbiAgICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoRVZfQ0xJQ0ssIHRoaXMubGlzdGVuZXJEZWFkQ2xpY2spO1xuICAgIH1cbn07XG5cbkF1dG9jYXB0dXJlLnByb3RvdHlwZS5pbml0SW5wdXRUcmFja2luZyA9IGZ1bmN0aW9uKCkge1xuICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKEVWX0NIQU5HRSwgdGhpcy5saXN0ZW5lckNoYW5nZSk7XG5cbiAgICBpZiAoIXRoaXMuZ2V0Q29uZmlnKENPTkZJR19UUkFDS19JTlBVVCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsb2dnZXIkMS5sb2coJ0luaXRpYWxpemluZyBpbnB1dCB0cmFja2luZycpO1xuXG4gICAgdGhpcy5saXN0ZW5lckNoYW5nZSA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGlmICghdGhpcy5nZXRDb25maWcoQ09ORklHX1RSQUNLX0lOUFVUKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2tEb21FdmVudChldiwgTVBfRVZfSU5QVVQpO1xuICAgIH0uYmluZCh0aGlzKTtcbiAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihFVl9DSEFOR0UsIHRoaXMubGlzdGVuZXJDaGFuZ2UpO1xufTtcblxuQXV0b2NhcHR1cmUucHJvdG90eXBlLmluaXRQYWdldmlld1RyYWNraW5nID0gZnVuY3Rpb24oKSB7XG4gICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZfTVBfTE9DQVRJT05fQ0hBTkdFLCB0aGlzLmxpc3RlbmVyTG9jYXRpb25jaGFuZ2UpO1xuXG4gICAgaWYgKCF0aGlzLnBhZ2V2aWV3VHJhY2tpbmdDb25maWcoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvZ2dlciQxLmxvZygnSW5pdGlhbGl6aW5nIHBhZ2V2aWV3IHRyYWNraW5nJyk7XG5cbiAgICB2YXIgcHJldmlvdXNUcmFja2VkVXJsID0gJyc7XG4gICAgdmFyIHRyYWNrZWQgPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuY3VycmVudFVybEJsb2NrZWQoKSkge1xuICAgICAgICB0cmFja2VkID0gdGhpcy5tcC50cmFja19wYWdldmlldyhERUZBVUxUX1BST1BTKTtcbiAgICB9XG4gICAgaWYgKHRyYWNrZWQpIHtcbiAgICAgICAgcHJldmlvdXNUcmFja2VkVXJsID0gXy5pbmZvLmN1cnJlbnRVcmwoKTtcbiAgICB9XG5cbiAgICB0aGlzLmxpc3RlbmVyTG9jYXRpb25jaGFuZ2UgPSBzYWZld3JhcChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFVybEJsb2NrZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN1cnJlbnRVcmwgPSBfLmluZm8uY3VycmVudFVybCgpO1xuICAgICAgICB2YXIgc2hvdWxkVHJhY2sgPSBmYWxzZTtcbiAgICAgICAgdmFyIGRpZFBhdGhDaGFuZ2UgPSBjdXJyZW50VXJsLnNwbGl0KCcjJylbMF0uc3BsaXQoJz8nKVswXSAhPT0gcHJldmlvdXNUcmFja2VkVXJsLnNwbGl0KCcjJylbMF0uc3BsaXQoJz8nKVswXTtcbiAgICAgICAgdmFyIHRyYWNrUGFnZXZpZXdPcHRpb24gPSB0aGlzLnBhZ2V2aWV3VHJhY2tpbmdDb25maWcoKTtcbiAgICAgICAgaWYgKHRyYWNrUGFnZXZpZXdPcHRpb24gPT09IFBBR0VWSUVXX09QVElPTl9GVUxMX1VSTCkge1xuICAgICAgICAgICAgc2hvdWxkVHJhY2sgPSBjdXJyZW50VXJsICE9PSBwcmV2aW91c1RyYWNrZWRVcmw7XG4gICAgICAgIH0gZWxzZSBpZiAodHJhY2tQYWdldmlld09wdGlvbiA9PT0gUEFHRVZJRVdfT1BUSU9OX1VSTF9XSVRIX1BBVEhfQU5EX1FVRVJZX1NUUklORykge1xuICAgICAgICAgICAgc2hvdWxkVHJhY2sgPSBjdXJyZW50VXJsLnNwbGl0KCcjJylbMF0gIT09IHByZXZpb3VzVHJhY2tlZFVybC5zcGxpdCgnIycpWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKHRyYWNrUGFnZXZpZXdPcHRpb24gPT09IFBBR0VWSUVXX09QVElPTl9VUkxfV0lUSF9QQVRIKSB7XG4gICAgICAgICAgICBzaG91bGRUcmFjayA9IGRpZFBhdGhDaGFuZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvdWxkVHJhY2spIHtcbiAgICAgICAgICAgIHZhciB0cmFja2VkID0gdGhpcy5tcC50cmFja19wYWdldmlldyhERUZBVUxUX1BST1BTKTtcbiAgICAgICAgICAgIGlmICh0cmFja2VkKSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNUcmFja2VkVXJsID0gY3VycmVudFVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaWRQYXRoQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0U2Nyb2xsQ2hlY2twb2ludCA9IDA7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDEubG9nKCdQYXRoIGNoYW5nZTogcmUtaW5pdGlhbGl6aW5nIHNjcm9sbCBkZXB0aCBjaGVja3BvaW50cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihFVl9NUF9MT0NBVElPTl9DSEFOR0UsIHRoaXMubGlzdGVuZXJMb2NhdGlvbmNoYW5nZSk7XG59O1xuXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUuaW5pdFJhZ2VDbGlja1RyYWNraW5nID0gZnVuY3Rpb24oKSB7XG4gICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZfQ0xJQ0ssIHRoaXMubGlzdGVuZXJSYWdlQ2xpY2spO1xuXG4gICAgdmFyIHJhZ2VDbGlja0NvbmZpZyA9IHRoaXMuX2dldENsaWNrVHJhY2tpbmdDb25maWcoQ09ORklHX1RSQUNLX1JBR0VfQ0xJQ0spO1xuICAgIGlmICghcmFnZUNsaWNrQ29uZmlnICYmICF0aGlzLm1wLmdldF9jb25maWcoJ3JlY29yZF9oZWF0bWFwX2RhdGEnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbG9nZ2VyJDEubG9nKCdJbml0aWFsaXppbmcgcmFnZSBjbGljayB0cmFja2luZycpO1xuICAgIGlmICghdGhpcy5fcmFnZUNsaWNrVHJhY2tlcikge1xuICAgICAgICB0aGlzLl9yYWdlQ2xpY2tUcmFja2VyID0gbmV3IFJhZ2VDbGlja1RyYWNrZXIoKTtcbiAgICB9XG5cbiAgICB0aGlzLmxpc3RlbmVyUmFnZUNsaWNrID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRSYWdlQ2xpY2tDb25maWcgPSB0aGlzLl9nZXRDbGlja1RyYWNraW5nQ29uZmlnKENPTkZJR19UUkFDS19SQUdFX0NMSUNLKTtcbiAgICAgICAgaWYgKCFjdXJyZW50UmFnZUNsaWNrQ29uZmlnICYmICF0aGlzLm1wLmlzX3JlY29yZGluZ19oZWF0bWFwX2RhdGEoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFVybEJsb2NrZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3JhZ2VDbGlja1RyYWNrZXIuaXNSYWdlQ2xpY2soZXYsIGN1cnJlbnRSYWdlQ2xpY2tDb25maWcpKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNrRG9tRXZlbnQoZXYsIE1QX0VWX1JBR0VfQ0xJQ0spO1xuICAgICAgICB9XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKEVWX0NMSUNLLCB0aGlzLmxpc3RlbmVyUmFnZUNsaWNrKTtcbn07XG5cbkF1dG9jYXB0dXJlLnByb3RvdHlwZS5pbml0U2Nyb2xsVHJhY2tpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVl9TQ1JPTExFTkQsIHRoaXMubGlzdGVuZXJTY3JvbGwpO1xuICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKEVWX1NDUk9MTCwgdGhpcy5saXN0ZW5lclNjcm9sbCk7XG5cblxuICAgIGlmICghdGhpcy5nZXRDb25maWcoQ09ORklHX1RSQUNLX1NDUk9MTCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsb2dnZXIkMS5sb2coJ0luaXRpYWxpemluZyBzY3JvbGwgdHJhY2tpbmcnKTtcbiAgICB0aGlzLmxhc3RTY3JvbGxDaGVja3BvaW50ID0gMDtcblxuICAgIHZhciBzY3JvbGxUcmFja0Z1bmN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5nZXRDb25maWcoQ09ORklHX1RSQUNLX1NDUk9MTCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50VXJsQmxvY2tlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hvdWxkVHJhY2sgPSB0aGlzLmdldENvbmZpZyhDT05GSUdfU0NST0xMX0NBUFRVUkVfQUxMKTtcbiAgICAgICAgdmFyIHNjcm9sbENoZWNrcG9pbnRzID0gKHRoaXMuZ2V0Q29uZmlnKENPTkZJR19TQ1JPTExfQ0hFQ0tQT0lOVFMpIHx8IFtdKVxuICAgICAgICAgICAgLnNsaWNlKClcbiAgICAgICAgICAgIC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9KTtcblxuICAgICAgICB2YXIgc2Nyb2xsVG9wID0gd2luLnNjcm9sbFk7XG4gICAgICAgIHZhciBwcm9wcyA9IF8uZXh0ZW5kKHsnJHNjcm9sbF90b3AnOiBzY3JvbGxUb3B9LCBERUZBVUxUX1BST1BTKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBzY3JvbGxIZWlnaHQgPSBkb2N1bWVudCQxLmJvZHkuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgICAgdmFyIHNjcm9sbFBlcmNlbnRhZ2UgPSBNYXRoLnJvdW5kKChzY3JvbGxUb3AgLyAoc2Nyb2xsSGVpZ2h0IC0gd2luLmlubmVySGVpZ2h0KSkgKiAxMDApO1xuICAgICAgICAgICAgcHJvcHNbJyRzY3JvbGxfaGVpZ2h0J10gPSBzY3JvbGxIZWlnaHQ7XG4gICAgICAgICAgICBwcm9wc1snJHNjcm9sbF9wZXJjZW50YWdlJ10gPSBzY3JvbGxQZXJjZW50YWdlO1xuICAgICAgICAgICAgaWYgKHNjcm9sbFBlcmNlbnRhZ2UgPiB0aGlzLmxhc3RTY3JvbGxDaGVja3BvaW50KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzY3JvbGxDaGVja3BvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hlY2twb2ludCA9IHNjcm9sbENoZWNrcG9pbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxQZXJjZW50YWdlID49IGNoZWNrcG9pbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdFNjcm9sbENoZWNrcG9pbnQgPCBjaGVja3BvaW50XG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbJyRzY3JvbGxfY2hlY2twb2ludCddID0gY2hlY2twb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdFNjcm9sbENoZWNrcG9pbnQgPSBjaGVja3BvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkVHJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGxvZ2dlciQxLmNyaXRpY2FsKCdFcnJvciB3aGlsZSBjYWxjdWxhdGluZyBzY3JvbGwgcGVyY2VudGFnZScsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFRyYWNrKSB7XG4gICAgICAgICAgICB0aGlzLm1wLnRyYWNrKE1QX0VWX1NDUk9MTCwgcHJvcHMpO1xuICAgICAgICB9XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgdmFyIHNjcm9sbEVuZFBvbHlmaWxsID0gZ2V0UG9seWZpbGxTY3JvbGxFbmRGdW5jdGlvbihzY3JvbGxUcmFja0Z1bmN0aW9uKTtcbiAgICB0aGlzLmxpc3RlbmVyU2Nyb2xsID0gc2Nyb2xsRW5kUG9seWZpbGwubGlzdGVuZXI7XG4gICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoc2Nyb2xsRW5kUG9seWZpbGwuZXZlbnRUeXBlLCB0aGlzLmxpc3RlbmVyU2Nyb2xsKTtcbn07XG5cbkF1dG9jYXB0dXJlLnByb3RvdHlwZS5pbml0U3VibWl0VHJhY2tpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVl9TVUJNSVQsIHRoaXMubGlzdGVuZXJTdWJtaXQpO1xuXG4gICAgaWYgKCF0aGlzLmdldENvbmZpZyhDT05GSUdfVFJBQ0tfU1VCTUlUKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvZ2dlciQxLmxvZygnSW5pdGlhbGl6aW5nIHN1Ym1pdCB0cmFja2luZycpO1xuXG4gICAgdGhpcy5saXN0ZW5lclN1Ym1pdCA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGlmICghdGhpcy5nZXRDb25maWcoQ09ORklHX1RSQUNLX1NVQk1JVCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNrRG9tRXZlbnQoZXYsIE1QX0VWX1NVQk1JVCk7XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKEVWX1NVQk1JVCwgdGhpcy5saXN0ZW5lclN1Ym1pdCk7XG59O1xuXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUuaW5pdFBhZ2VMZWF2ZVRyYWNraW5nID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gQ2FwdHVyZSBwYWdlX2xlYXZlIGJvdGggd2hlbiB0aGUgdXNlciBuYXZpZ2F0ZXMgYXdheSBmcm9tIHRoZSBwYWdlICh2aXNpYmlsaXR5Y2hhbmdlKSBhcyB3ZWxsXG4gICAgLy8gYXMgd2hlbiB0aGV5IG5hdmlnYXRlIHRvIGEgZGlmZmVyZW50IHBhZ2Ugd2l0aGluIHRoZSBTUEEgKHBvcHN0YXRlL3B1c2hzdGF0ZS9oYXNoY2hhbmdlKS5cbiAgICBkb2N1bWVudCQxLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZfVklTSUJJTElUWUNIQU5HRSwgdGhpcy5saXN0ZW5lclBhZ2VMZWF2ZVZpc2liaWxpdHljaGFuZ2UpO1xuICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKEVWX01QX0xPQ0FUSU9OX0NIQU5HRSwgdGhpcy5saXN0ZW5lclBhZ2VMZWF2ZUxvY2F0aW9uY2hhbmdlKTtcbiAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVl9MT0FELCB0aGlzLmxpc3RlbmVyUGFnZUxvYWQpO1xuXG4gICAgaWYgKCF0aGlzLmdldENvbmZpZyhDT05GSUdfVFJBQ0tfUEFHRV9MRUFWRSkgJiYgIXRoaXMubXAuZ2V0X2NvbmZpZygncmVjb3JkX2hlYXRtYXBfZGF0YScpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsb2dnZXIkMS5sb2coJ0luaXRpYWxpemluZyBwYWdlIHZpc2liaWxpdHkgdHJhY2tpbmcuJyk7XG4gICAgdGhpcy5faW5pdFNjcm9sbERlcHRoVHJhY2tpbmcoKTtcbiAgICB2YXIgcHJldmlvdXNUcmFja2VkVXJsID0gXy5pbmZvLmN1cnJlbnRVcmwoKTtcblxuICAgIC8vIEluaXRpYWxpemUgcHJldmlvdXNTY3JvbGxIZWlnaHQgb24gYGxvYWRgIHdoaWNoIGhhbmRsZXMgYXN5bmMgbG9hZGluZ1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cvbG9hZF9ldmVudFxuICAgIHRoaXMubGlzdGVuZXJQYWdlTG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnByZXZpb3VzU2Nyb2xsSGVpZ2h0ID0gZG9jdW1lbnQkMS5ib2R5LnNjcm9sbEhlaWdodDtcbiAgICB9LmJpbmQodGhpcyk7XG4gICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoRVZfTE9BRCwgdGhpcy5saXN0ZW5lclBhZ2VMb2FkKTtcblxuICAgIC8vIFRyYWNrIHBhZ2UgbmF2aWdhdGlvbiBldmVudHMgc2ltaWxhciB0byBob3cgaW5pdFBhZ2V2aWV3VHJhY2tpbmcgZG9lcyBpdFxuICAgIHRoaXMubGlzdGVuZXJQYWdlTGVhdmVMb2NhdGlvbmNoYW5nZSA9IHNhZmV3cmFwKGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRVcmxCbG9ja2VkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdXJyZW50VXJsID0gXy5pbmZvLmN1cnJlbnRVcmwoKTtcbiAgICAgICAgLy8gVHJhY2sgYWxsIFVSTCBjaGFuZ2VzIGluY2x1ZGluZyBxdWVyeSBzdHJpbmcgb3IgZnJhZ21lbnQgY2hhbmdlcyBhcyBzZXBhcmF0ZSBzY3JvbGwgc2Vzc2lvbnNcbiAgICAgICAgdmFyIHNob3VsZFRyYWNrID0gY3VycmVudFVybCAhPT0gcHJldmlvdXNUcmFja2VkVXJsO1xuXG4gICAgICAgIGlmIChzaG91bGRUcmFjaykge1xuICAgICAgICAgICAgdGhpcy5fdHJhY2tQYWdlTGVhdmUoZXYsIHByZXZpb3VzVHJhY2tlZFVybCwgdGhpcy5wcmV2aW91c1Njcm9sbEhlaWdodCk7XG4gICAgICAgICAgICBwcmV2aW91c1RyYWNrZWRVcmwgPSBjdXJyZW50VXJsO1xuICAgICAgICAgICAgLy8gRnJhZ21lbnQgbmF2aWdhdGlvbiBzaG91bGQgY2FsbCBzY3JvbGwoZW5kKSBhbmQgdHJpZ2dlciBsaXN0ZW5lciwgZG9uJ3QgYWRkIHdpbmRvdy5zY3JvbGxZIGhlcmUuXG4gICAgICAgICAgICB0aGlzLm1heFNjcm9sbFZpZXdEZXB0aCA9IE1hdGgubWF4KGRvY3VtZW50JDEuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCwgd2luLmlubmVySGVpZ2h0IHx8IDApO1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c1Njcm9sbEhlaWdodCA9IGRvY3VtZW50JDEuYm9keS5zY3JvbGxIZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmhhc1RyYWNrZWRTY3JvbGxTZXNzaW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xuICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKEVWX01QX0xPQ0FUSU9OX0NIQU5HRSwgdGhpcy5saXN0ZW5lclBhZ2VMZWF2ZUxvY2F0aW9uY2hhbmdlKTtcblxuICAgIHRoaXMubGlzdGVuZXJQYWdlTGVhdmVWaXNpYmlsaXR5Y2hhbmdlID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50JDEuaGlkZGVuKSB7XG4gICAgICAgICAgICB0aGlzLl90cmFja1BhZ2VMZWF2ZShldiwgcHJldmlvdXNUcmFja2VkVXJsLCB0aGlzLnByZXZpb3VzU2Nyb2xsSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH0uYmluZCh0aGlzKTtcbiAgICBkb2N1bWVudCQxLmFkZEV2ZW50TGlzdGVuZXIoRVZfVklTSUJJTElUWUNIQU5HRSwgdGhpcy5saXN0ZW5lclBhZ2VMZWF2ZVZpc2liaWxpdHljaGFuZ2UpO1xufTtcblxuQXV0b2NhcHR1cmUucHJvdG90eXBlLnN0b3BEZWFkQ2xpY2tUcmFja2luZyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmxpc3RlbmVyRGVhZENsaWNrKSB7XG4gICAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKEVWX0NMSUNLLCB0aGlzLmxpc3RlbmVyRGVhZENsaWNrKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lckRlYWRDbGljayA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RlYWRDbGlja1RyYWNrZXIpIHtcbiAgICAgICAgdGhpcy5fZGVhZENsaWNrVHJhY2tlci5zdG9wVHJhY2tpbmcoKTtcbiAgICAgICAgdGhpcy5fZGVhZENsaWNrVHJhY2tlciA9IG51bGw7XG4gICAgfVxufTtcblxuLy8gVE9ETyBpbnRlZ3JhdGUgZXJyb3JfcmVwb3J0ZXIgZnJvbSBtaXhwYW5lbCBpbnN0YW5jZVxuc2FmZXdyYXBDbGFzcyhBdXRvY2FwdHVyZSk7XG5cbnZhciBsb2dnZXIgPSBjb25zb2xlX3dpdGhfcHJlZml4KCdmbGFncycpO1xuXG52YXIgRkxBR1NfQ09ORklHX0tFWSA9ICdmbGFncyc7XG5cbnZhciBDT05GSUdfQ09OVEVYVCA9ICdjb250ZXh0JztcbnZhciBDT05GSUdfREVGQVVMVFMgPSB7fTtcbkNPTkZJR19ERUZBVUxUU1tDT05GSUdfQ09OVEVYVF0gPSB7fTtcblxuLyoqXG4gKiBGZWF0dXJlRmxhZ01hbmFnZXI6IHN1cHBvcnQgZm9yIE1peHBhbmVsJ3MgZmVhdHVyZSBmbGFnZ2luZyBwcm9kdWN0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEZlYXR1cmVGbGFnTWFuYWdlciA9IGZ1bmN0aW9uKGluaXRPcHRpb25zKSB7XG4gICAgdGhpcy5mZXRjaCA9IHdpblsnZmV0Y2gnXTtcbiAgICB0aGlzLmdldEZ1bGxBcGlSb3V0ZSA9IGluaXRPcHRpb25zLmdldEZ1bGxBcGlSb3V0ZTtcbiAgICB0aGlzLmdldE1wQ29uZmlnID0gaW5pdE9wdGlvbnMuZ2V0Q29uZmlnRnVuYztcbiAgICB0aGlzLnNldE1wQ29uZmlnID0gaW5pdE9wdGlvbnMuc2V0Q29uZmlnRnVuYztcbiAgICB0aGlzLmdldE1wUHJvcGVydHkgPSBpbml0T3B0aW9ucy5nZXRQcm9wZXJ0eUZ1bmM7XG4gICAgdGhpcy50cmFjayA9IGluaXRPcHRpb25zLnRyYWNraW5nRnVuYztcbn07XG5cbkZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5taW5BcGlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgbG9nZ2VyLmNyaXRpY2FsKCdGZWF0dXJlIEZsYWdzIHVuYXZhaWxhYmxlOiBtaXNzaW5nIG1pbmltdW0gcmVxdWlyZWQgQVBJcycpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5mbGFncyA9IG51bGw7XG4gICAgdGhpcy5mZXRjaEZsYWdzKCk7XG5cbiAgICB0aGlzLnRyYWNrZWRGZWF0dXJlcyA9IG5ldyBTZXQoKTtcbn07XG5cbkZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGUuZ2V0RnVsbENvbmZpZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmZkNvbmZpZyA9IHRoaXMuZ2V0TXBDb25maWcoRkxBR1NfQ09ORklHX0tFWSk7XG4gICAgaWYgKCFmZkNvbmZpZykge1xuICAgICAgICAvLyBmbGFncyBhcmUgY29tcGxldGVseSBvZmZcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdChmZkNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKHt9LCBDT05GSUdfREVGQVVMVFMsIGZmQ29uZmlnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb25maWcgaXMgbm9uLW9iamVjdCB0cnV0aHkgdmFsdWUsIHJldHVybiBkZWZhdWx0XG4gICAgICAgIHJldHVybiBDT05GSUdfREVGQVVMVFM7XG4gICAgfVxufTtcblxuRmVhdHVyZUZsYWdNYW5hZ2VyLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRGdWxsQ29uZmlnKClba2V5XTtcbn07XG5cbkZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGUuaXNTeXN0ZW1FbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhdGhpcy5nZXRNcENvbmZpZyhGTEFHU19DT05GSUdfS0VZKTtcbn07XG5cbkZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGUudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKG5ld0NvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuaXNTeXN0ZW1FbmFibGVkKCkpIHtcbiAgICAgICAgbG9nZ2VyLmNyaXRpY2FsKCdGZWF0dXJlIEZsYWdzIG5vdCBlbmFibGVkLCBjYW5ub3QgdXBkYXRlIGNvbnRleHQnKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIHZhciBmZkNvbmZpZyA9IHRoaXMuZ2V0TXBDb25maWcoRkxBR1NfQ09ORklHX0tFWSk7XG4gICAgaWYgKCFfLmlzT2JqZWN0KGZmQ29uZmlnKSkge1xuICAgICAgICBmZkNvbmZpZyA9IHt9O1xuICAgIH1cbiAgICB2YXIgb2xkQ29udGV4dCA9IChvcHRpb25zICYmIG9wdGlvbnNbJ3JlcGxhY2UnXSkgPyB7fSA6IHRoaXMuZ2V0Q29uZmlnKENPTkZJR19DT05URVhUKTtcbiAgICBmZkNvbmZpZ1tDT05GSUdfQ09OVEVYVF0gPSBfLmV4dGVuZCh7fSwgb2xkQ29udGV4dCwgbmV3Q29udGV4dCk7XG5cbiAgICB0aGlzLnNldE1wQ29uZmlnKEZMQUdTX0NPTkZJR19LRVksIGZmQ29uZmlnKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEZsYWdzKCk7XG59O1xuXG5GZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlLmFyZUZsYWdzUmVhZHkgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuaXNTeXN0ZW1FbmFibGVkKCkpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdGZWF0dXJlIEZsYWdzIG5vdCBlbmFibGVkJyk7XG4gICAgfVxuICAgIHJldHVybiAhIXRoaXMuZmxhZ3M7XG59O1xuXG5GZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlLmZldGNoRmxhZ3MgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuaXNTeXN0ZW1FbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIHZhciBkaXN0aW5jdElkID0gdGhpcy5nZXRNcFByb3BlcnR5KCdkaXN0aW5jdF9pZCcpO1xuICAgIHZhciBkZXZpY2VJZCA9IHRoaXMuZ2V0TXBQcm9wZXJ0eSgnJGRldmljZV9pZCcpO1xuICAgIHZhciB0cmFjZXBhcmVudCA9IGdlbmVyYXRlVHJhY2VwYXJlbnQoKTtcbiAgICBsb2dnZXIubG9nKCdGZXRjaGluZyBmbGFncyBmb3IgZGlzdGluY3QgSUQ6ICcgKyBkaXN0aW5jdElkKTtcblxuICAgIHZhciBjb250ZXh0ID0gXy5leHRlbmQoeydkaXN0aW5jdF9pZCc6IGRpc3RpbmN0SWQsICdkZXZpY2VfaWQnOiBkZXZpY2VJZH0sIHRoaXMuZ2V0Q29uZmlnKENPTkZJR19DT05URVhUKSk7XG4gICAgdmFyIHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBzZWFyY2hQYXJhbXMuc2V0KCdjb250ZXh0JywgSlNPTi5zdHJpbmdpZnkoY29udGV4dCkpO1xuICAgIHNlYXJjaFBhcmFtcy5zZXQoJ3Rva2VuJywgdGhpcy5nZXRNcENvbmZpZygndG9rZW4nKSk7XG4gICAgc2VhcmNoUGFyYW1zLnNldCgnbXBfbGliJywgJ3dlYicpO1xuICAgIHNlYXJjaFBhcmFtcy5zZXQoJyRsaWJfdmVyc2lvbicsIENvbmZpZy5MSUJfVkVSU0lPTik7XG4gICAgdmFyIHVybCA9IHRoaXMuZ2V0RnVsbEFwaVJvdXRlKCkgKyAnPycgKyBzZWFyY2hQYXJhbXMudG9TdHJpbmcoKTtcblxuICAgIHRoaXMuX2ZldGNoSW5Qcm9ncmVzc1N0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgdGhpcy5mZXRjaFByb21pc2UgPSB0aGlzLmZldGNoLmNhbGwod2luLCB1cmwsIHtcbiAgICAgICAgJ21ldGhvZCc6ICdHRVQnLFxuICAgICAgICAnaGVhZGVycyc6IHtcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogJ0Jhc2ljICcgKyBidG9hKHRoaXMuZ2V0TXBDb25maWcoJ3Rva2VuJykgKyAnOicpLFxuICAgICAgICAgICAgJ3RyYWNlcGFyZW50JzogdHJhY2VwYXJlbnRcbiAgICAgICAgfVxuICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy5tYXJrRmV0Y2hDb21wbGV0ZSgpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2VCb2R5KSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2VGbGFncyA9IHJlc3BvbnNlQm9keVsnZmxhZ3MnXTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2VGbGFncykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZmxhZ3MgaW4gQVBJIHJlc3BvbnNlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZmxhZ3MgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBfLmVhY2gocmVzcG9uc2VGbGFncywgZnVuY3Rpb24oZGF0YSwga2V5KSB7XG4gICAgICAgICAgICAgICAgZmxhZ3Muc2V0KGtleSwge1xuICAgICAgICAgICAgICAgICAgICAna2V5JzogZGF0YVsndmFyaWFudF9rZXknXSxcbiAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJzogZGF0YVsndmFyaWFudF92YWx1ZSddLFxuICAgICAgICAgICAgICAgICAgICAnZXhwZXJpbWVudF9pZCc6IGRhdGFbJ2V4cGVyaW1lbnRfaWQnXSxcbiAgICAgICAgICAgICAgICAgICAgJ2lzX2V4cGVyaW1lbnRfYWN0aXZlJzogZGF0YVsnaXNfZXhwZXJpbWVudF9hY3RpdmUnXSxcbiAgICAgICAgICAgICAgICAgICAgJ2lzX3FhX3Rlc3Rlcic6IGRhdGFbJ2lzX3FhX3Rlc3RlciddXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgICAgIHRoaXMuX3RyYWNlcGFyZW50ID0gdHJhY2VwYXJlbnQ7XG4gICAgICAgIH0uYmluZCh0aGlzKSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMubWFya0ZldGNoQ29tcGxldGUoKTtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihlcnJvcik7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfS5iaW5kKHRoaXMpKS5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICB0aGlzLm1hcmtGZXRjaENvbXBsZXRlKCk7XG4gICAgICAgIGxvZ2dlci5lcnJvcihlcnJvcik7XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIHJldHVybiB0aGlzLmZldGNoUHJvbWlzZTtcbn07XG5cbkZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGUubWFya0ZldGNoQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX2ZldGNoSW5Qcm9ncmVzc1N0YXJ0VGltZSkge1xuICAgICAgICBsb2dnZXIuZXJyb3IoJ0ZldGNoIGluIHByb2dyZXNzIHN0YXJ0ZWQgdGltZSBub3Qgc2V0LCBjYW5ub3QgbWFyayBmZXRjaCBjb21wbGV0ZScpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2ZldGNoU3RhcnRUaW1lID0gdGhpcy5fZmV0Y2hJblByb2dyZXNzU3RhcnRUaW1lO1xuICAgIHRoaXMuX2ZldGNoQ29tcGxldGVUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLl9mZXRjaExhdGVuY3kgPSB0aGlzLl9mZXRjaENvbXBsZXRlVGltZSAtIHRoaXMuX2ZldGNoU3RhcnRUaW1lO1xuICAgIHRoaXMuX2ZldGNoSW5Qcm9ncmVzc1N0YXJ0VGltZSA9IG51bGw7XG59O1xuXG5GZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlLmdldFZhcmlhbnQgPSBmdW5jdGlvbihmZWF0dXJlTmFtZSwgZmFsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuZmV0Y2hQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICBsb2dnZXIuY3JpdGljYWwoJ0ZlYXR1cmUgRmxhZ3Mgbm90IGluaXRpYWxpemVkJyk7XG4gICAgICAgICAgICByZXNvbHZlKGZhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hQcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFZhcmlhbnRTeW5jKGZlYXR1cmVOYW1lLCBmYWxsYmFjayk7XG4gICAgfS5iaW5kKHRoaXMpKS5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgfSk7XG59O1xuXG5GZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlLmdldFZhcmlhbnRTeW5jID0gZnVuY3Rpb24oZmVhdHVyZU5hbWUsIGZhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLmFyZUZsYWdzUmVhZHkoKSkge1xuICAgICAgICBsb2dnZXIubG9nKCdGbGFncyBub3QgbG9hZGVkIHlldCcpO1xuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgfVxuICAgIHZhciBmZWF0dXJlID0gdGhpcy5mbGFncy5nZXQoZmVhdHVyZU5hbWUpO1xuICAgIGlmICghZmVhdHVyZSkge1xuICAgICAgICBsb2dnZXIubG9nKCdObyBmbGFnIGZvdW5kOiBcIicgKyBmZWF0dXJlTmFtZSArICdcIicpO1xuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgfVxuICAgIHRoaXMudHJhY2tGZWF0dXJlQ2hlY2soZmVhdHVyZU5hbWUsIGZlYXR1cmUpO1xuICAgIHJldHVybiBmZWF0dXJlO1xufTtcblxuRmVhdHVyZUZsYWdNYW5hZ2VyLnByb3RvdHlwZS5nZXRWYXJpYW50VmFsdWUgPSBmdW5jdGlvbihmZWF0dXJlTmFtZSwgZmFsbGJhY2tWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmdldFZhcmlhbnQoZmVhdHVyZU5hbWUsIHsndmFsdWUnOiBmYWxsYmFja1ZhbHVlfSkudGhlbihmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgICAgIHJldHVybiBmZWF0dXJlWyd2YWx1ZSddO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihlcnJvcik7XG4gICAgICAgIHJldHVybiBmYWxsYmFja1ZhbHVlO1xuICAgIH0pO1xufTtcblxuLy8gVE9ETyByZW1vdmUgZGVwcmVjYXRlZCBtZXRob2RcbkZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGUuZ2V0RmVhdHVyZURhdGEgPSBmdW5jdGlvbihmZWF0dXJlTmFtZSwgZmFsbGJhY2tWYWx1ZSkge1xuICAgIGxvZ2dlci5jcml0aWNhbCgnbWl4cGFuZWwuZmxhZ3MuZ2V0X2ZlYXR1cmVfZGF0YSgpIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLiBVc2UgbWl4cGFuZWwuZmxhZ3MuZ2V0X3ZhcmlhbnRfdmFsdWUoKSBpbnN0ZWFkLicpO1xuICAgIHJldHVybiB0aGlzLmdldFZhcmlhbnRWYWx1ZShmZWF0dXJlTmFtZSwgZmFsbGJhY2tWYWx1ZSk7XG59O1xuXG5GZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlLmdldFZhcmlhbnRWYWx1ZVN5bmMgPSBmdW5jdGlvbihmZWF0dXJlTmFtZSwgZmFsbGJhY2tWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmdldFZhcmlhbnRTeW5jKGZlYXR1cmVOYW1lLCB7J3ZhbHVlJzogZmFsbGJhY2tWYWx1ZX0pWyd2YWx1ZSddO1xufTtcblxuRmVhdHVyZUZsYWdNYW5hZ2VyLnByb3RvdHlwZS5pc0VuYWJsZWQgPSBmdW5jdGlvbihmZWF0dXJlTmFtZSwgZmFsbGJhY2tWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmdldFZhcmlhbnRWYWx1ZShmZWF0dXJlTmFtZSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNFbmFibGVkU3luYyhmZWF0dXJlTmFtZSwgZmFsbGJhY2tWYWx1ZSk7XG4gICAgfS5iaW5kKHRoaXMpKS5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tWYWx1ZTtcbiAgICB9KTtcbn07XG5cbkZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGUuaXNFbmFibGVkU3luYyA9IGZ1bmN0aW9uKGZlYXR1cmVOYW1lLCBmYWxsYmFja1ZhbHVlKSB7XG4gICAgZmFsbGJhY2tWYWx1ZSA9IGZhbGxiYWNrVmFsdWUgfHwgZmFsc2U7XG4gICAgdmFyIHZhbCA9IHRoaXMuZ2V0VmFyaWFudFZhbHVlU3luYyhmZWF0dXJlTmFtZSwgZmFsbGJhY2tWYWx1ZSk7XG4gICAgaWYgKHZhbCAhPT0gdHJ1ZSAmJiB2YWwgIT09IGZhbHNlKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcignRmVhdHVyZSBmbGFnIFwiJyArIGZlYXR1cmVOYW1lICsgJ1wiIHZhbHVlOiAnICsgdmFsICsgJyBpcyBub3QgYSBib29sZWFuOyByZXR1cm5pbmcgZmFsbGJhY2sgdmFsdWU6ICcgKyBmYWxsYmFja1ZhbHVlKTtcbiAgICAgICAgdmFsID0gZmFsbGJhY2tWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn07XG5cbkZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGUudHJhY2tGZWF0dXJlQ2hlY2sgPSBmdW5jdGlvbihmZWF0dXJlTmFtZSwgZmVhdHVyZSkge1xuICAgIGlmICh0aGlzLnRyYWNrZWRGZWF0dXJlcy5oYXMoZmVhdHVyZU5hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy50cmFja2VkRmVhdHVyZXMuYWRkKGZlYXR1cmVOYW1lKTtcblxuICAgIHZhciB0cmFja2luZ1Byb3BlcnRpZXMgPSB7XG4gICAgICAgICdFeHBlcmltZW50IG5hbWUnOiBmZWF0dXJlTmFtZSxcbiAgICAgICAgJ1ZhcmlhbnQgbmFtZSc6IGZlYXR1cmVbJ2tleSddLFxuICAgICAgICAnJGV4cGVyaW1lbnRfdHlwZSc6ICdmZWF0dXJlX2ZsYWcnLFxuICAgICAgICAnVmFyaWFudCBmZXRjaCBzdGFydCB0aW1lJzogbmV3IERhdGUodGhpcy5fZmV0Y2hTdGFydFRpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICdWYXJpYW50IGZldGNoIGNvbXBsZXRlIHRpbWUnOiBuZXcgRGF0ZSh0aGlzLl9mZXRjaENvbXBsZXRlVGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgJ1ZhcmlhbnQgZmV0Y2ggbGF0ZW5jeSAobXMpJzogdGhpcy5fZmV0Y2hMYXRlbmN5LFxuICAgICAgICAnVmFyaWFudCBmZXRjaCB0cmFjZXBhcmVudCc6IHRoaXMuX3RyYWNlcGFyZW50LFxuICAgIH07XG5cbiAgICBpZiAoZmVhdHVyZVsnZXhwZXJpbWVudF9pZCddICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0cmFja2luZ1Byb3BlcnRpZXNbJyRleHBlcmltZW50X2lkJ10gPSBmZWF0dXJlWydleHBlcmltZW50X2lkJ107XG4gICAgfVxuICAgIGlmIChmZWF0dXJlWydpc19leHBlcmltZW50X2FjdGl2ZSddICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0cmFja2luZ1Byb3BlcnRpZXNbJyRpc19leHBlcmltZW50X2FjdGl2ZSddID0gZmVhdHVyZVsnaXNfZXhwZXJpbWVudF9hY3RpdmUnXTtcbiAgICB9XG4gICAgaWYgKGZlYXR1cmVbJ2lzX3FhX3Rlc3RlciddICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0cmFja2luZ1Byb3BlcnRpZXNbJyRpc19xYV90ZXN0ZXInXSA9IGZlYXR1cmVbJ2lzX3FhX3Rlc3RlciddO1xuICAgIH1cblxuICAgIHRoaXMudHJhY2soJyRleHBlcmltZW50X3N0YXJ0ZWQnLCB0cmFja2luZ1Byb3BlcnRpZXMpO1xufTtcblxuRmVhdHVyZUZsYWdNYW5hZ2VyLnByb3RvdHlwZS5taW5BcGlzU3VwcG9ydGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhdGhpcy5mZXRjaCAmJlxuICAgICAgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgdHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCc7XG59O1xuXG5zYWZld3JhcENsYXNzKEZlYXR1cmVGbGFnTWFuYWdlcik7XG5cbkZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGVbJ2FyZV9mbGFnc19yZWFkeSddID0gRmVhdHVyZUZsYWdNYW5hZ2VyLnByb3RvdHlwZS5hcmVGbGFnc1JlYWR5O1xuRmVhdHVyZUZsYWdNYW5hZ2VyLnByb3RvdHlwZVsnZ2V0X3ZhcmlhbnQnXSA9IEZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGUuZ2V0VmFyaWFudDtcbkZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGVbJ2dldF92YXJpYW50X3N5bmMnXSA9IEZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGUuZ2V0VmFyaWFudFN5bmM7XG5GZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlWydnZXRfdmFyaWFudF92YWx1ZSddID0gRmVhdHVyZUZsYWdNYW5hZ2VyLnByb3RvdHlwZS5nZXRWYXJpYW50VmFsdWU7XG5GZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlWydnZXRfdmFyaWFudF92YWx1ZV9zeW5jJ10gPSBGZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlLmdldFZhcmlhbnRWYWx1ZVN5bmM7XG5GZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlWydpc19lbmFibGVkJ10gPSBGZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlLmlzRW5hYmxlZDtcbkZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGVbJ2lzX2VuYWJsZWRfc3luYyddID0gRmVhdHVyZUZsYWdNYW5hZ2VyLnByb3RvdHlwZS5pc0VuYWJsZWRTeW5jO1xuRmVhdHVyZUZsYWdNYW5hZ2VyLnByb3RvdHlwZVsndXBkYXRlX2NvbnRleHQnXSA9IEZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGUudXBkYXRlQ29udGV4dDtcblxuLy8gRGVwcmVjYXRlZCBtZXRob2RcbkZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGVbJ2dldF9mZWF0dXJlX2RhdGEnXSA9IEZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGUuZ2V0RmVhdHVyZURhdGE7XG5cbi8qIGVzbGludCBjYW1lbGNhc2U6IFwib2ZmXCIgKi9cblxuXG4vKipcbiAqIERvbVRyYWNrZXIgT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIERvbVRyYWNrZXIgPSBmdW5jdGlvbigpIHt9O1xuXG5cbi8vIGludGVyZmFjZVxuRG9tVHJhY2tlci5wcm90b3R5cGUuY3JlYXRlX3Byb3BlcnRpZXMgPSBmdW5jdGlvbigpIHt9O1xuRG9tVHJhY2tlci5wcm90b3R5cGUuZXZlbnRfaGFuZGxlciA9IGZ1bmN0aW9uKCkge307XG5Eb21UcmFja2VyLnByb3RvdHlwZS5hZnRlcl90cmFja19oYW5kbGVyID0gZnVuY3Rpb24oKSB7fTtcblxuRG9tVHJhY2tlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKG1peHBhbmVsX2luc3RhbmNlKSB7XG4gICAgdGhpcy5tcCA9IG1peHBhbmVsX2luc3RhbmNlO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IHF1ZXJ5XG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRfbmFtZVxuICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge2Z1bmN0aW9uPX0gdXNlcl9jYWxsYmFja1xuICovXG5Eb21UcmFja2VyLnByb3RvdHlwZS50cmFjayA9IGZ1bmN0aW9uKHF1ZXJ5LCBldmVudF9uYW1lLCBwcm9wZXJ0aWVzLCB1c2VyX2NhbGxiYWNrKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciBlbGVtZW50cyA9IF8uZG9tX3F1ZXJ5KHF1ZXJ5KTtcblxuICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc29sZSQxLmVycm9yKCdUaGUgRE9NIHF1ZXJ5ICgnICsgcXVlcnkgKyAnKSByZXR1cm5lZCAwIGVsZW1lbnRzJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfLmVhY2goZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgXy5yZWdpc3Rlcl9ldmVudChlbGVtZW50LCB0aGlzLm92ZXJyaWRlX2V2ZW50LCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIHByb3BzID0gdGhhdC5jcmVhdGVfcHJvcGVydGllcyhwcm9wZXJ0aWVzLCB0aGlzKTtcbiAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gdGhhdC5tcC5nZXRfY29uZmlnKCd0cmFja19saW5rc190aW1lb3V0Jyk7XG5cbiAgICAgICAgICAgIHRoYXQuZXZlbnRfaGFuZGxlcihlLCB0aGlzLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGUgbWl4cGFuZWwgc2VydmVycyBkb24ndCBnZXQgYmFjayB0byB1cyBpbiB0aW1lXG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCh0aGF0LnRyYWNrX2NhbGxiYWNrKHVzZXJfY2FsbGJhY2ssIHByb3BzLCBvcHRpb25zLCB0cnVlKSwgdGltZW91dCk7XG5cbiAgICAgICAgICAgIC8vIGZpcmUgdGhlIHRyYWNraW5nIGV2ZW50XG4gICAgICAgICAgICB0aGF0Lm1wLnRyYWNrKGV2ZW50X25hbWUsIHByb3BzLCB0aGF0LnRyYWNrX2NhbGxiYWNrKHVzZXJfY2FsbGJhY2ssIHByb3BzLCBvcHRpb25zKSk7XG4gICAgICAgIH0pO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHVzZXJfY2FsbGJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtib29sZWFuPX0gdGltZW91dF9vY2N1cmVkXG4gKi9cbkRvbVRyYWNrZXIucHJvdG90eXBlLnRyYWNrX2NhbGxiYWNrID0gZnVuY3Rpb24odXNlcl9jYWxsYmFjaywgcHJvcHMsIG9wdGlvbnMsIHRpbWVvdXRfb2NjdXJlZCkge1xuICAgIHRpbWVvdXRfb2NjdXJlZCA9IHRpbWVvdXRfb2NjdXJlZCB8fCBmYWxzZTtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIG9wdGlvbnMgaXMgcmVmZXJlbmNlZCBmcm9tIGJvdGggY2FsbGJhY2tzLCBzbyB3ZSBjYW4gaGF2ZVxuICAgICAgICAvLyBhICdsb2NrJyBvZiBzb3J0cyB0byBlbnN1cmUgb25seSBvbmUgZmlyZXNcbiAgICAgICAgaWYgKG9wdGlvbnMuY2FsbGJhY2tfZmlyZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgIG9wdGlvbnMuY2FsbGJhY2tfZmlyZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmICh1c2VyX2NhbGxiYWNrICYmIHVzZXJfY2FsbGJhY2sodGltZW91dF9vY2N1cmVkLCBwcm9wcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyB1c2VyIGNhbiBwcmV2ZW50IHRoZSBkZWZhdWx0IGZ1bmN0aW9uYWxpdHkgYnlcbiAgICAgICAgICAgIC8vIHJldHVybmluZyBmYWxzZSBmcm9tIHRoZWlyIGNhbGxiYWNrXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGF0LmFmdGVyX3RyYWNrX2hhbmRsZXIocHJvcHMsIG9wdGlvbnMsIHRpbWVvdXRfb2NjdXJlZCk7XG4gICAgfTtcbn07XG5cbkRvbVRyYWNrZXIucHJvdG90eXBlLmNyZWF0ZV9wcm9wZXJ0aWVzID0gZnVuY3Rpb24ocHJvcGVydGllcywgZWxlbWVudCkge1xuICAgIHZhciBwcm9wcztcblxuICAgIGlmICh0eXBlb2YocHJvcGVydGllcykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJvcHMgPSBwcm9wZXJ0aWVzKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BzID0gXy5leHRlbmQoe30sIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wcztcbn07XG5cbi8qKlxuICogTGlua1RyYWNrZXIgT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIERvbVRyYWNrZXJcbiAqL1xudmFyIExpbmtUcmFja2VyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5vdmVycmlkZV9ldmVudCA9ICdjbGljayc7XG59O1xuXy5pbmhlcml0KExpbmtUcmFja2VyLCBEb21UcmFja2VyKTtcblxuTGlua1RyYWNrZXIucHJvdG90eXBlLmNyZWF0ZV9wcm9wZXJ0aWVzID0gZnVuY3Rpb24ocHJvcGVydGllcywgZWxlbWVudCkge1xuICAgIHZhciBwcm9wcyA9IExpbmtUcmFja2VyLnN1cGVyY2xhc3MuY3JlYXRlX3Byb3BlcnRpZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIGlmIChlbGVtZW50LmhyZWYpIHsgcHJvcHNbJ3VybCddID0gZWxlbWVudC5ocmVmOyB9XG5cbiAgICByZXR1cm4gcHJvcHM7XG59O1xuXG5MaW5rVHJhY2tlci5wcm90b3R5cGUuZXZlbnRfaGFuZGxlciA9IGZ1bmN0aW9uKGV2dCwgZWxlbWVudCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMubmV3X3RhYiA9IChcbiAgICAgICAgZXZ0LndoaWNoID09PSAyIHx8XG4gICAgICAgIGV2dC5tZXRhS2V5IHx8XG4gICAgICAgIGV2dC5jdHJsS2V5IHx8XG4gICAgICAgIGVsZW1lbnQudGFyZ2V0ID09PSAnX2JsYW5rJ1xuICAgICk7XG4gICAgb3B0aW9ucy5ocmVmID0gZWxlbWVudC5ocmVmO1xuXG4gICAgaWYgKCFvcHRpb25zLm5ld190YWIpIHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxufTtcblxuTGlua1RyYWNrZXIucHJvdG90eXBlLmFmdGVyX3RyYWNrX2hhbmRsZXIgPSBmdW5jdGlvbihwcm9wcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLm5ld190YWIpIHsgcmV0dXJuOyB9XG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24gPSBvcHRpb25zLmhyZWY7XG4gICAgfSwgMCk7XG59O1xuXG4vKipcbiAqIEZvcm1UcmFja2VyIE9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBEb21UcmFja2VyXG4gKi9cbnZhciBGb3JtVHJhY2tlciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMub3ZlcnJpZGVfZXZlbnQgPSAnc3VibWl0Jztcbn07XG5fLmluaGVyaXQoRm9ybVRyYWNrZXIsIERvbVRyYWNrZXIpO1xuXG5Gb3JtVHJhY2tlci5wcm90b3R5cGUuZXZlbnRfaGFuZGxlciA9IGZ1bmN0aW9uKGV2dCwgZWxlbWVudCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG59O1xuXG5Gb3JtVHJhY2tlci5wcm90b3R5cGUuYWZ0ZXJfdHJhY2tfaGFuZGxlciA9IGZ1bmN0aW9uKHByb3BzLCBvcHRpb25zKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgb3B0aW9ucy5lbGVtZW50LnN1Ym1pdCgpO1xuICAgIH0sIDApO1xufTtcblxuLyogZXNsaW50IGNhbWVsY2FzZTogXCJvZmZcIiAqL1xuXG5cbi8qKiBAY29uc3QgKi8gdmFyIFNFVF9BQ1RJT04gICAgICA9ICckc2V0Jztcbi8qKiBAY29uc3QgKi8gdmFyIFNFVF9PTkNFX0FDVElPTiA9ICckc2V0X29uY2UnO1xuLyoqIEBjb25zdCAqLyB2YXIgVU5TRVRfQUNUSU9OICAgID0gJyR1bnNldCc7XG4vKiogQGNvbnN0ICovIHZhciBBRERfQUNUSU9OICAgICAgPSAnJGFkZCc7XG4vKiogQGNvbnN0ICovIHZhciBBUFBFTkRfQUNUSU9OICAgPSAnJGFwcGVuZCc7XG4vKiogQGNvbnN0ICovIHZhciBVTklPTl9BQ1RJT04gICAgPSAnJHVuaW9uJztcbi8qKiBAY29uc3QgKi8gdmFyIFJFTU9WRV9BQ1RJT04gICA9ICckcmVtb3ZlJztcbi8qKiBAY29uc3QgKi8gdmFyIERFTEVURV9BQ1RJT04gICA9ICckZGVsZXRlJztcblxuLy8gQ29tbW9uIGludGVybmFsIG1ldGhvZHMgZm9yIG1peHBhbmVsLnBlb3BsZSBhbmQgbWl4cGFuZWwuZ3JvdXAgQVBJcy5cbi8vIFRoZXNlIG1ldGhvZHMgc2hvdWxkbid0IGludm9sdmUgbmV0d29yayBJL08uXG52YXIgYXBpQWN0aW9ucyA9IHtcbiAgICBzZXRfYWN0aW9uOiBmdW5jdGlvbihwcm9wLCB0bykge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICB2YXIgJHNldCA9IHt9O1xuICAgICAgICBpZiAoXy5pc09iamVjdChwcm9wKSkge1xuICAgICAgICAgICAgXy5lYWNoKHByb3AsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzX3Jlc2VydmVkX3Byb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgICAgICRzZXRba10gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHNldFtwcm9wXSA9IHRvO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVtTRVRfQUNUSU9OXSA9ICRzZXQ7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICB1bnNldF9hY3Rpb246IGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgdmFyICR1bnNldCA9IFtdO1xuICAgICAgICBpZiAoIV8uaXNBcnJheShwcm9wKSkge1xuICAgICAgICAgICAgcHJvcCA9IFtwcm9wXTtcbiAgICAgICAgfVxuXG4gICAgICAgIF8uZWFjaChwcm9wLCBmdW5jdGlvbihrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzX3Jlc2VydmVkX3Byb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgJHVuc2V0LnB1c2goayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGRhdGFbVU5TRVRfQUNUSU9OXSA9ICR1bnNldDtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIHNldF9vbmNlX2FjdGlvbjogZnVuY3Rpb24ocHJvcCwgdG8pIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgdmFyICRzZXRfb25jZSA9IHt9O1xuICAgICAgICBpZiAoXy5pc09iamVjdChwcm9wKSkge1xuICAgICAgICAgICAgXy5lYWNoKHByb3AsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzX3Jlc2VydmVkX3Byb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgICAgICRzZXRfb25jZVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkc2V0X29uY2VbcHJvcF0gPSB0bztcbiAgICAgICAgfVxuICAgICAgICBkYXRhW1NFVF9PTkNFX0FDVElPTl0gPSAkc2V0X29uY2U7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICB1bmlvbl9hY3Rpb246IGZ1bmN0aW9uKGxpc3RfbmFtZSwgdmFsdWVzKSB7XG4gICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgIHZhciAkdW5pb24gPSB7fTtcbiAgICAgICAgaWYgKF8uaXNPYmplY3QobGlzdF9uYW1lKSkge1xuICAgICAgICAgICAgXy5lYWNoKGxpc3RfbmFtZSwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNfcmVzZXJ2ZWRfcHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgJHVuaW9uW2tdID0gXy5pc0FycmF5KHYpID8gdiA6IFt2XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICR1bmlvbltsaXN0X25hbWVdID0gXy5pc0FycmF5KHZhbHVlcykgPyB2YWx1ZXMgOiBbdmFsdWVzXTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhW1VOSU9OX0FDVElPTl0gPSAkdW5pb247XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICBhcHBlbmRfYWN0aW9uOiBmdW5jdGlvbihsaXN0X25hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgIHZhciAkYXBwZW5kID0ge307XG4gICAgICAgIGlmIChfLmlzT2JqZWN0KGxpc3RfbmFtZSkpIHtcbiAgICAgICAgICAgIF8uZWFjaChsaXN0X25hbWUsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzX3Jlc2VydmVkX3Byb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgICAgICRhcHBlbmRba10gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGFwcGVuZFtsaXN0X25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtBUFBFTkRfQUNUSU9OXSA9ICRhcHBlbmQ7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICByZW1vdmVfYWN0aW9uOiBmdW5jdGlvbihsaXN0X25hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgIHZhciAkcmVtb3ZlID0ge307XG4gICAgICAgIGlmIChfLmlzT2JqZWN0KGxpc3RfbmFtZSkpIHtcbiAgICAgICAgICAgIF8uZWFjaChsaXN0X25hbWUsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzX3Jlc2VydmVkX3Byb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgICAgICRyZW1vdmVba10gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHJlbW92ZVtsaXN0X25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtSRU1PVkVfQUNUSU9OXSA9ICRyZW1vdmU7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICBkZWxldGVfYWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgZGF0YVtERUxFVEVfQUNUSU9OXSA9ICcnO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG59O1xuXG4vKiBlc2xpbnQgY2FtZWxjYXNlOiBcIm9mZlwiICovXG5cbi8qKlxuICogTWl4cGFuZWwgR3JvdXAgT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE1peHBhbmVsR3JvdXAgPSBmdW5jdGlvbigpIHt9O1xuXG5fLmV4dGVuZChNaXhwYW5lbEdyb3VwLnByb3RvdHlwZSwgYXBpQWN0aW9ucyk7XG5cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24obWl4cGFuZWxfaW5zdGFuY2UsIGdyb3VwX2tleSwgZ3JvdXBfaWQpIHtcbiAgICB0aGlzLl9taXhwYW5lbCA9IG1peHBhbmVsX2luc3RhbmNlO1xuICAgIHRoaXMuX2dyb3VwX2tleSA9IGdyb3VwX2tleTtcbiAgICB0aGlzLl9ncm91cF9pZCA9IGdyb3VwX2lkO1xufTtcblxuLyoqXG4gKiBTZXQgcHJvcGVydGllcyBvbiBhIGdyb3VwLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgbWl4cGFuZWwuZ2V0X2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJykuc2V0KCdMb2NhdGlvbicsICc0MDUgSG93YXJkJyk7XG4gKlxuICogICAgIC8vIG9yIHNldCBtdWx0aXBsZSBwcm9wZXJ0aWVzIGF0IG9uY2VcbiAqICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKS5zZXQoe1xuICogICAgICAgICAgJ0xvY2F0aW9uJzogJzQwNSBIb3dhcmQnLFxuICogICAgICAgICAgJ0ZvdW5kZWQnIDogMjAwOSxcbiAqICAgICB9KTtcbiAqICAgICAvLyBwcm9wZXJ0aWVzIGNhbiBiZSBzdHJpbmdzLCBpbnRlZ2VycywgZGF0ZXMsIG9yIGxpc3RzXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBwcm9wIElmIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS4gSWYgYW4gb2JqZWN0LCB0aGlzIGlzIGFuIGFzc29jaWF0aXZlIGFycmF5IG9mIG5hbWVzIGFuZCB2YWx1ZXMuXG4gKiBAcGFyYW0geyp9IFt0b10gQSB2YWx1ZSB0byBzZXQgb24gdGhlIGdpdmVuIHByb3BlcnR5IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgdHJhY2tpbmcgZXZlbnRcbiAqL1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUuc2V0ID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbEdyb3VwKGZ1bmN0aW9uKHByb3AsIHRvLCBjYWxsYmFjaykge1xuICAgIHZhciBkYXRhID0gdGhpcy5zZXRfYWN0aW9uKHByb3AsIHRvKTtcbiAgICBpZiAoXy5pc09iamVjdChwcm9wKSkge1xuICAgICAgICBjYWxsYmFjayA9IHRvO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKipcbiAqIFNldCBwcm9wZXJ0aWVzIG9uIGEgZ3JvdXAsIG9ubHkgaWYgdGhleSBkbyBub3QgeWV0IGV4aXN0LlxuICogVGhpcyB3aWxsIG5vdCBvdmVyd3JpdGUgcHJldmlvdXMgZ3JvdXAgcHJvcGVydHkgdmFsdWVzLCB1bmxpa2VcbiAqIGdyb3VwLnNldCgpLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgbWl4cGFuZWwuZ2V0X2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJykuc2V0X29uY2UoJ0xvY2F0aW9uJywgJzQwNSBIb3dhcmQnKTtcbiAqXG4gKiAgICAgLy8gb3Igc2V0IG11bHRpcGxlIHByb3BlcnRpZXMgYXQgb25jZVxuICogICAgIG1peHBhbmVsLmdldF9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpLnNldF9vbmNlKHtcbiAqICAgICAgICAgICdMb2NhdGlvbic6ICc0MDUgSG93YXJkJyxcbiAqICAgICAgICAgICdGb3VuZGVkJyA6IDIwMDksXG4gKiAgICAgfSk7XG4gKiAgICAgLy8gcHJvcGVydGllcyBjYW4gYmUgc3RyaW5ncywgaW50ZWdlcnMsIGxpc3RzIG9yIGRhdGVzXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBwcm9wIElmIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS4gSWYgYW4gb2JqZWN0LCB0aGlzIGlzIGFuIGFzc29jaWF0aXZlIGFycmF5IG9mIG5hbWVzIGFuZCB2YWx1ZXMuXG4gKiBAcGFyYW0geyp9IFt0b10gQSB2YWx1ZSB0byBzZXQgb24gdGhlIGdpdmVuIHByb3BlcnR5IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgdHJhY2tpbmcgZXZlbnRcbiAqL1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUuc2V0X29uY2UgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsR3JvdXAoZnVuY3Rpb24ocHJvcCwgdG8sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnNldF9vbmNlX2FjdGlvbihwcm9wLCB0byk7XG4gICAgaWYgKF8uaXNPYmplY3QocHJvcCkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSB0bztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLyoqXG4gKiBVbnNldCBwcm9wZXJ0aWVzIG9uIGEgZ3JvdXAgcGVybWFuZW50bHkuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKS51bnNldCgnRm91bmRlZCcpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgdHJhY2tpbmcgZXZlbnRcbiAqL1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUudW5zZXQgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsR3JvdXAoZnVuY3Rpb24ocHJvcCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMudW5zZXRfYWN0aW9uKHByb3ApO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qKlxuICogTWVyZ2UgYSBnaXZlbiBsaXN0IHdpdGggYSBsaXN0LXZhbHVlZCBncm91cCBwcm9wZXJ0eSwgZXhjbHVkaW5nIGR1cGxpY2F0ZSB2YWx1ZXMuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyBtZXJnZSBhIHZhbHVlIHRvIGEgbGlzdCwgY3JlYXRpbmcgaXQgaWYgbmVlZGVkXG4gKiAgICAgbWl4cGFuZWwuZ2V0X2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJykudW5pb24oJ0xvY2F0aW9uJywgWydTYW4gRnJhbmNpc2NvJywgJ0xvbmRvbiddKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbGlzdF9uYW1lIE5hbWUgb2YgdGhlIHByb3BlcnR5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFZhbHVlcyB0byBtZXJnZSB3aXRoIHRoZSBnaXZlbiBwcm9wZXJ0eVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSB0cmFja2luZyBldmVudFxuICovXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS51bmlvbiA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxHcm91cChmdW5jdGlvbihsaXN0X25hbWUsIHZhbHVlcywgY2FsbGJhY2spIHtcbiAgICBpZiAoXy5pc09iamVjdChsaXN0X25hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdmFsdWVzO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHRoaXMudW5pb25fYWN0aW9uKGxpc3RfbmFtZSwgdmFsdWVzKTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKipcbiAqIFBlcm1hbmVudGx5IGRlbGV0ZSBhIGdyb3VwLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgbWl4cGFuZWwuZ2V0X2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJykuZGVsZXRlKCk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSB0cmFja2luZyBldmVudFxuICovXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBhZGRPcHRPdXRDaGVja01peHBhbmVsR3JvdXAoZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAvLyBicmFja2V0IG5vdGF0aW9uIGFib3ZlIHByZXZlbnRzIGEgbWluaWZpY2F0aW9uIGVycm9yIHJlbGF0ZWQgdG8gcmVzZXJ2ZWQgd29yZHNcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGVsZXRlX2FjdGlvbigpO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qKlxuICogUmVtb3ZlIGEgcHJvcGVydHkgZnJvbSBhIGdyb3VwLiBUaGUgdmFsdWUgd2lsbCBiZSBpZ25vcmVkIGlmIGRvZXNuJ3QgZXhpc3QuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKS5yZW1vdmUoJ0xvY2F0aW9uJywgJ0xvbmRvbicpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBsaXN0X25hbWUgTmFtZSBvZiB0aGUgcHJvcGVydHkuXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgVmFsdWUgdG8gcmVtb3ZlIGZyb20gdGhlIGdpdmVuIGdyb3VwIHByb3BlcnR5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIHRyYWNraW5nIGV2ZW50XG4gKi9cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLnJlbW92ZSA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxHcm91cChmdW5jdGlvbihsaXN0X25hbWUsIHZhbHVlLCBjYWxsYmFjaykge1xuICAgIHZhciBkYXRhID0gdGhpcy5yZW1vdmVfYWN0aW9uKGxpc3RfbmFtZSwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLl9zZW5kX3JlcXVlc3QgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xuICAgIGRhdGFbJyRncm91cF9rZXknXSA9IHRoaXMuX2dyb3VwX2tleTtcbiAgICBkYXRhWyckZ3JvdXBfaWQnXSA9IHRoaXMuX2dyb3VwX2lkO1xuICAgIGRhdGFbJyR0b2tlbiddID0gdGhpcy5fZ2V0X2NvbmZpZygndG9rZW4nKTtcblxuICAgIHZhciBkYXRlX2VuY29kZWRfZGF0YSA9IF8uZW5jb2RlRGF0ZXMoZGF0YSk7XG4gICAgcmV0dXJuIHRoaXMuX21peHBhbmVsLl90cmFja19vcl9iYXRjaCh7XG4gICAgICAgIHR5cGU6ICdncm91cHMnLFxuICAgICAgICBkYXRhOiBkYXRlX2VuY29kZWRfZGF0YSxcbiAgICAgICAgZW5kcG9pbnQ6IHRoaXMuX21peHBhbmVsLmdldF9hcGlfaG9zdCgnZ3JvdXBzJykgKyAnLycgKyAgdGhpcy5fZ2V0X2NvbmZpZygnYXBpX3JvdXRlcycpWydncm91cHMnXSxcbiAgICAgICAgYmF0Y2hlcjogdGhpcy5fbWl4cGFuZWwucmVxdWVzdF9iYXRjaGVycy5ncm91cHNcbiAgICB9LCBjYWxsYmFjayk7XG59O1xuXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS5faXNfcmVzZXJ2ZWRfcHJvcGVydHkgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgcmV0dXJuIHByb3AgPT09ICckZ3JvdXBfa2V5JyB8fCBwcm9wID09PSAnJGdyb3VwX2lkJztcbn07XG5cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLl9nZXRfY29uZmlnID0gZnVuY3Rpb24oY29uZikge1xuICAgIHJldHVybiB0aGlzLl9taXhwYW5lbC5nZXRfY29uZmlnKGNvbmYpO1xufTtcblxuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbWl4cGFuZWwudG9TdHJpbmcoKSArICcuZ3JvdXAuJyArIHRoaXMuX2dyb3VwX2tleSArICcuJyArIHRoaXMuX2dyb3VwX2lkO1xufTtcblxuLy8gTWl4cGFuZWxHcm91cCBFeHBvcnRzXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZVsncmVtb3ZlJ10gICA9IE1peHBhbmVsR3JvdXAucHJvdG90eXBlLnJlbW92ZTtcbk1peHBhbmVsR3JvdXAucHJvdG90eXBlWydzZXQnXSAgICAgID0gTWl4cGFuZWxHcm91cC5wcm90b3R5cGUuc2V0O1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGVbJ3NldF9vbmNlJ10gPSBNaXhwYW5lbEdyb3VwLnByb3RvdHlwZS5zZXRfb25jZTtcbk1peHBhbmVsR3JvdXAucHJvdG90eXBlWyd1bmlvbiddICAgID0gTWl4cGFuZWxHcm91cC5wcm90b3R5cGUudW5pb247XG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZVsndW5zZXQnXSAgICA9IE1peHBhbmVsR3JvdXAucHJvdG90eXBlLnVuc2V0O1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGVbJ3RvU3RyaW5nJ10gPSBNaXhwYW5lbEdyb3VwLnByb3RvdHlwZS50b1N0cmluZztcblxuLyogZXNsaW50IGNhbWVsY2FzZTogXCJvZmZcIiAqL1xuXG4vKipcbiAqIE1peHBhbmVsIFBlb3BsZSBPYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTWl4cGFuZWxQZW9wbGUgPSBmdW5jdGlvbigpIHt9O1xuXG5fLmV4dGVuZChNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUsIGFwaUFjdGlvbnMpO1xuXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbihtaXhwYW5lbF9pbnN0YW5jZSkge1xuICAgIHRoaXMuX21peHBhbmVsID0gbWl4cGFuZWxfaW5zdGFuY2U7XG59O1xuXG4vKlxuKiBTZXQgcHJvcGVydGllcyBvbiBhIHVzZXIgcmVjb3JkLlxuKlxuKiAjIyMgVXNhZ2U6XG4qXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuc2V0KCdnZW5kZXInLCAnbScpO1xuKlxuKiAgICAgLy8gb3Igc2V0IG11bHRpcGxlIHByb3BlcnRpZXMgYXQgb25jZVxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnNldCh7XG4qICAgICAgICAgJ0NvbXBhbnknOiAnQWNtZScsXG4qICAgICAgICAgJ1BsYW4nOiAnUHJlbWl1bScsXG4qICAgICAgICAgJ1VwZ3JhZGUgZGF0ZSc6IG5ldyBEYXRlKClcbiogICAgIH0pO1xuKiAgICAgLy8gcHJvcGVydGllcyBjYW4gYmUgc3RyaW5ncywgaW50ZWdlcnMsIGRhdGVzLCBvciBsaXN0c1xuKlxuKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHByb3AgSWYgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBJZiBhbiBvYmplY3QsIHRoaXMgaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbmFtZXMgYW5kIHZhbHVlcy5cbiogQHBhcmFtIHsqfSBbdG9dIEEgdmFsdWUgdG8gc2V0IG9uIHRoZSBnaXZlbiBwcm9wZXJ0eSBuYW1lXG4qIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4qL1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnNldCA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUoZnVuY3Rpb24ocHJvcCwgdG8sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnNldF9hY3Rpb24ocHJvcCwgdG8pO1xuICAgIGlmIChfLmlzT2JqZWN0KHByb3ApKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdG87XG4gICAgfVxuICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHRoZSByZWZlcnJlciBpbmZvIGhhcyBiZWVuIHVwZGF0ZWQgYW5kIHNhdmVkXG4gICAgaWYgKHRoaXMuX2dldF9jb25maWcoJ3NhdmVfcmVmZXJyZXInKSkge1xuICAgICAgICB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS51cGRhdGVfcmVmZXJyZXJfaW5mbyhkb2N1bWVudC5yZWZlcnJlcik7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlICRzZXQgb2JqZWN0IHdpdGggZGVmYXVsdCBwZW9wbGUgcHJvcGVydGllc1xuICAgIGRhdGFbU0VUX0FDVElPTl0gPSBfLmV4dGVuZChcbiAgICAgICAge30sXG4gICAgICAgIF8uaW5mby5wZW9wbGVfcHJvcGVydGllcygpLFxuICAgICAgICBkYXRhW1NFVF9BQ1RJT05dXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKlxuKiBTZXQgcHJvcGVydGllcyBvbiBhIHVzZXIgcmVjb3JkLCBvbmx5IGlmIHRoZXkgZG8gbm90IHlldCBleGlzdC5cbiogVGhpcyB3aWxsIG5vdCBvdmVyd3JpdGUgcHJldmlvdXMgcGVvcGxlIHByb3BlcnR5IHZhbHVlcywgdW5saWtlXG4qIHBlb3BsZS5zZXQoKS5cbipcbiogIyMjIFVzYWdlOlxuKlxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnNldF9vbmNlKCdGaXJzdCBMb2dpbiBEYXRlJywgbmV3IERhdGUoKSk7XG4qXG4qICAgICAvLyBvciBzZXQgbXVsdGlwbGUgcHJvcGVydGllcyBhdCBvbmNlXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuc2V0X29uY2Uoe1xuKiAgICAgICAgICdGaXJzdCBMb2dpbiBEYXRlJzogbmV3IERhdGUoKSxcbiogICAgICAgICAnU3RhcnRpbmcgUGxhbic6ICdQcmVtaXVtJ1xuKiAgICAgfSk7XG4qXG4qICAgICAvLyBwcm9wZXJ0aWVzIGNhbiBiZSBzdHJpbmdzLCBpbnRlZ2VycyBvciBkYXRlc1xuKlxuKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHByb3AgSWYgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBJZiBhbiBvYmplY3QsIHRoaXMgaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbmFtZXMgYW5kIHZhbHVlcy5cbiogQHBhcmFtIHsqfSBbdG9dIEEgdmFsdWUgdG8gc2V0IG9uIHRoZSBnaXZlbiBwcm9wZXJ0eSBuYW1lXG4qIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4qL1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnNldF9vbmNlID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbFBlb3BsZShmdW5jdGlvbihwcm9wLCB0bywgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuc2V0X29uY2VfYWN0aW9uKHByb3AsIHRvKTtcbiAgICBpZiAoXy5pc09iamVjdChwcm9wKSkge1xuICAgICAgICBjYWxsYmFjayA9IHRvO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKlxuKiBVbnNldCBwcm9wZXJ0aWVzIG9uIGEgdXNlciByZWNvcmQgKHBlcm1hbmVudGx5IHJlbW92ZXMgdGhlIHByb3BlcnRpZXMgYW5kIHRoZWlyIHZhbHVlcyBmcm9tIGEgcHJvZmlsZSkuXG4qXG4qICMjIyBVc2FnZTpcbipcbiogICAgIG1peHBhbmVsLnBlb3BsZS51bnNldCgnZ2VuZGVyJyk7XG4qXG4qICAgICAvLyBvciB1bnNldCBtdWx0aXBsZSBwcm9wZXJ0aWVzIGF0IG9uY2VcbiogICAgIG1peHBhbmVsLnBlb3BsZS51bnNldChbJ2dlbmRlcicsICdDb21wYW55J10pO1xuKlxuKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gcHJvcCBJZiBhIHN0cmluZywgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuIElmIGFuIGFycmF5LCB0aGlzIGlzIGEgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcy5cbiogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUudW5zZXQgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsUGVvcGxlKGZ1bmN0aW9uKHByb3AsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnVuc2V0X2FjdGlvbihwcm9wKTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKlxuKiBJbmNyZW1lbnQvZGVjcmVtZW50IG51bWVyaWMgcGVvcGxlIGFuYWx5dGljcyBwcm9wZXJ0aWVzLlxuKlxuKiAjIyMgVXNhZ2U6XG4qXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuaW5jcmVtZW50KCdwYWdlX3ZpZXdzJywgMSk7XG4qXG4qICAgICAvLyBvciwgZm9yIGNvbnZlbmllbmNlLCBpZiB5b3UncmUganVzdCBpbmNyZW1lbnRpbmcgYSBjb3VudGVyIGJ5XG4qICAgICAvLyAxLCB5b3UgY2FuIHNpbXBseSBkb1xuKiAgICAgbWl4cGFuZWwucGVvcGxlLmluY3JlbWVudCgncGFnZV92aWV3cycpO1xuKlxuKiAgICAgLy8gdG8gZGVjcmVtZW50IGEgY291bnRlciwgcGFzcyBhIG5lZ2F0aXZlIG51bWJlclxuKiAgICAgbWl4cGFuZWwucGVvcGxlLmluY3JlbWVudCgnY3JlZGl0c19sZWZ0JywgLTEpO1xuKlxuKiAgICAgLy8gbGlrZSBtaXhwYW5lbC5wZW9wbGUuc2V0KCksIHlvdSBjYW4gaW5jcmVtZW50IG11bHRpcGxlXG4qICAgICAvLyBwcm9wZXJ0aWVzIGF0IG9uY2U6XG4qICAgICBtaXhwYW5lbC5wZW9wbGUuaW5jcmVtZW50KHtcbiogICAgICAgICBjb3VudGVyMTogMSxcbiogICAgICAgICBjb3VudGVyMjogNlxuKiAgICAgfSk7XG4qXG4qIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcHJvcCBJZiBhIHN0cmluZywgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuIElmIGFuIG9iamVjdCwgdGhpcyBpcyBhbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBuYW1lcyBhbmQgbnVtZXJpYyB2YWx1ZXMuXG4qIEBwYXJhbSB7TnVtYmVyfSBbYnldIEFuIGFtb3VudCB0byBpbmNyZW1lbnQgdGhlIGdpdmVuIHByb3BlcnR5XG4qIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4qL1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLmluY3JlbWVudCA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUoZnVuY3Rpb24ocHJvcCwgYnksIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSB7fTtcbiAgICB2YXIgJGFkZCA9IHt9O1xuICAgIGlmIChfLmlzT2JqZWN0KHByb3ApKSB7XG4gICAgICAgIF8uZWFjaChwcm9wLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzX3Jlc2VydmVkX3Byb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHBhcnNlRmxvYXQodikpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUkMS5lcnJvcignSW52YWxpZCBpbmNyZW1lbnQgdmFsdWUgcGFzc2VkIHRvIG1peHBhbmVsLnBlb3BsZS5pbmNyZW1lbnQgLSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkYWRkW2tdID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICBjYWxsYmFjayA9IGJ5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbnZlbmllbmNlOiBtaXhwYW5lbC5wZW9wbGUuaW5jcmVtZW50KCdwcm9wZXJ0eScpOyB3aWxsXG4gICAgICAgIC8vIGluY3JlbWVudCAncHJvcGVydHknIGJ5IDFcbiAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQoYnkpKSB7XG4gICAgICAgICAgICBieSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgJGFkZFtwcm9wXSA9IGJ5O1xuICAgIH1cbiAgICBkYXRhW0FERF9BQ1RJT05dID0gJGFkZDtcblxuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qXG4qIEFwcGVuZCBhIHZhbHVlIHRvIGEgbGlzdC12YWx1ZWQgcGVvcGxlIGFuYWx5dGljcyBwcm9wZXJ0eS5cbipcbiogIyMjIFVzYWdlOlxuKlxuKiAgICAgLy8gYXBwZW5kIGEgdmFsdWUgdG8gYSBsaXN0LCBjcmVhdGluZyBpdCBpZiBuZWVkZWRcbiogICAgIG1peHBhbmVsLnBlb3BsZS5hcHBlbmQoJ3BhZ2VzX3Zpc2l0ZWQnLCAnaG9tZXBhZ2UnKTtcbipcbiogICAgIC8vIGxpa2UgbWl4cGFuZWwucGVvcGxlLnNldCgpLCB5b3UgY2FuIGFwcGVuZCBtdWx0aXBsZVxuKiAgICAgLy8gcHJvcGVydGllcyBhdCBvbmNlOlxuKiAgICAgbWl4cGFuZWwucGVvcGxlLmFwcGVuZCh7XG4qICAgICAgICAgbGlzdDE6ICdib2InLFxuKiAgICAgICAgIGxpc3QyOiAxMjNcbiogICAgIH0pO1xuKlxuKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGxpc3RfbmFtZSBJZiBhIHN0cmluZywgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuIElmIGFuIG9iamVjdCwgdGhpcyBpcyBhbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBuYW1lcyBhbmQgdmFsdWVzLlxuKiBAcGFyYW0geyp9IFt2YWx1ZV0gdmFsdWUgQW4gaXRlbSB0byBhcHBlbmQgdG8gdGhlIGxpc3RcbiogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuYXBwZW5kID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbFBlb3BsZShmdW5jdGlvbihsaXN0X25hbWUsIHZhbHVlLCBjYWxsYmFjaykge1xuICAgIGlmIChfLmlzT2JqZWN0KGxpc3RfbmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSB2YWx1ZTtcbiAgICB9XG4gICAgdmFyIGRhdGEgPSB0aGlzLmFwcGVuZF9hY3Rpb24obGlzdF9uYW1lLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLypcbiogUmVtb3ZlIGEgdmFsdWUgZnJvbSBhIGxpc3QtdmFsdWVkIHBlb3BsZSBhbmFseXRpY3MgcHJvcGVydHkuXG4qXG4qICMjIyBVc2FnZTpcbipcbiogICAgIG1peHBhbmVsLnBlb3BsZS5yZW1vdmUoJ1NjaG9vbCcsICdVQ0InKTtcbipcbiogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsaXN0X25hbWUgSWYgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBJZiBhbiBvYmplY3QsIHRoaXMgaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbmFtZXMgYW5kIHZhbHVlcy5cbiogQHBhcmFtIHsqfSBbdmFsdWVdIHZhbHVlIEl0ZW0gdG8gcmVtb3ZlIGZyb20gdGhlIGxpc3RcbiogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUucmVtb3ZlID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbFBlb3BsZShmdW5jdGlvbihsaXN0X25hbWUsIHZhbHVlLCBjYWxsYmFjaykge1xuICAgIGlmIChfLmlzT2JqZWN0KGxpc3RfbmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSB2YWx1ZTtcbiAgICB9XG4gICAgdmFyIGRhdGEgPSB0aGlzLnJlbW92ZV9hY3Rpb24obGlzdF9uYW1lLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLypcbiogTWVyZ2UgYSBnaXZlbiBsaXN0IHdpdGggYSBsaXN0LXZhbHVlZCBwZW9wbGUgYW5hbHl0aWNzIHByb3BlcnR5LFxuKiBleGNsdWRpbmcgZHVwbGljYXRlIHZhbHVlcy5cbipcbiogIyMjIFVzYWdlOlxuKlxuKiAgICAgLy8gbWVyZ2UgYSB2YWx1ZSB0byBhIGxpc3QsIGNyZWF0aW5nIGl0IGlmIG5lZWRlZFxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnVuaW9uKCdwYWdlc192aXNpdGVkJywgJ2hvbWVwYWdlJyk7XG4qXG4qICAgICAvLyBsaWtlIG1peHBhbmVsLnBlb3BsZS5zZXQoKSwgeW91IGNhbiBhcHBlbmQgbXVsdGlwbGVcbiogICAgIC8vIHByb3BlcnRpZXMgYXQgb25jZTpcbiogICAgIG1peHBhbmVsLnBlb3BsZS51bmlvbih7XG4qICAgICAgICAgbGlzdDE6ICdib2InLFxuKiAgICAgICAgIGxpc3QyOiAxMjNcbiogICAgIH0pO1xuKlxuKiAgICAgLy8gbGlrZSBtaXhwYW5lbC5wZW9wbGUuYXBwZW5kKCksIHlvdSBjYW4gYXBwZW5kIG11bHRpcGxlXG4qICAgICAvLyB2YWx1ZXMgdG8gdGhlIHNhbWUgbGlzdDpcbiogICAgIG1peHBhbmVsLnBlb3BsZS51bmlvbih7XG4qICAgICAgICAgbGlzdDE6IFsnYm9iJywgJ2JpbGx5J11cbiogICAgIH0pO1xuKlxuKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGxpc3RfbmFtZSBJZiBhIHN0cmluZywgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuIElmIGFuIG9iamVjdCwgdGhpcyBpcyBhbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBuYW1lcyBhbmQgdmFsdWVzLlxuKiBAcGFyYW0geyp9IFt2YWx1ZV0gVmFsdWUgLyB2YWx1ZXMgdG8gbWVyZ2Ugd2l0aCB0aGUgZ2l2ZW4gcHJvcGVydHlcbiogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUudW5pb24gPSBhZGRPcHRPdXRDaGVja01peHBhbmVsUGVvcGxlKGZ1bmN0aW9uKGxpc3RfbmFtZSwgdmFsdWVzLCBjYWxsYmFjaykge1xuICAgIGlmIChfLmlzT2JqZWN0KGxpc3RfbmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSB2YWx1ZXM7XG4gICAgfVxuICAgIHZhciBkYXRhID0gdGhpcy51bmlvbl9hY3Rpb24obGlzdF9uYW1lLCB2YWx1ZXMpO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qXG4gKiBSZWNvcmQgdGhhdCB5b3UgaGF2ZSBjaGFyZ2VkIHRoZSBjdXJyZW50IHVzZXIgYSBjZXJ0YWluIGFtb3VudFxuICogb2YgbW9uZXkuIENoYXJnZXMgcmVjb3JkZWQgd2l0aCB0cmFja19jaGFyZ2UoKSB3aWxsIGFwcGVhciBpbiB0aGVcbiAqIE1peHBhbmVsIHJldmVudWUgcmVwb3J0LlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gY2hhcmdlIGEgdXNlciAkNTBcbiAqICAgICBtaXhwYW5lbC5wZW9wbGUudHJhY2tfY2hhcmdlKDUwKTtcbiAqXG4gKiAgICAgLy8gY2hhcmdlIGEgdXNlciAkMzAuNTAgb24gdGhlIDJuZCBvZiBqYW51YXJ5XG4gKiAgICAgbWl4cGFuZWwucGVvcGxlLnRyYWNrX2NoYXJnZSgzMC41MCwge1xuICogICAgICAgICAnJHRpbWUnOiBuZXcgRGF0ZSgnamFuIDEgMjAxMicpXG4gKiAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCBUaGUgYW1vdW50IG9mIG1vbmV5IGNoYXJnZWQgdG8gdGhlIGN1cnJlbnQgdXNlclxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBBbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBwcm9wZXJ0aWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2hhcmdlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgc2VydmVyIHJlc3BvbmRzXG4gKiBAZGVwcmVjYXRlZFxuICovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUudHJhY2tfY2hhcmdlID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbFBlb3BsZShmdW5jdGlvbigpIHtcbiAgICBjb25zb2xlJDEuZXJyb3IoJ21peHBhbmVsLnBlb3BsZS50cmFja19jaGFyZ2UoKSBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgaGFzIGFueSBlZmZlY3QuJyk7XG59KTtcblxuLypcbiAqIFBlcm1hbmVudGx5IGNsZWFyIGFsbCByZXZlbnVlIHJlcG9ydCB0cmFuc2FjdGlvbnMgZnJvbSB0aGVcbiAqIGN1cnJlbnQgdXNlcidzIHBlb3BsZSBhbmFseXRpY3MgcHJvZmlsZS5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIG1peHBhbmVsLnBlb3BsZS5jbGVhcl9jaGFyZ2VzKCk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiAqIEBkZXByZWNhdGVkXG4gKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5jbGVhcl9jaGFyZ2VzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5zZXQoJyR0cmFuc2FjdGlvbnMnLCBbXSwgY2FsbGJhY2spO1xufTtcblxuLypcbiogUGVybWFuZW50bHkgZGVsZXRlcyB0aGUgY3VycmVudCBwZW9wbGUgYW5hbHl0aWNzIHByb2ZpbGUgZnJvbVxuKiBNaXhwYW5lbCAodXNpbmcgdGhlIGN1cnJlbnQgZGlzdGluY3RfaWQpLlxuKlxuKiAjIyMgVXNhZ2U6XG4qXG4qICAgICAvLyByZW1vdmUgdGhlIGFsbCBkYXRhIHlvdSBoYXZlIHN0b3JlZCBhYm91dCB0aGUgY3VycmVudCB1c2VyXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuZGVsZXRlX3VzZXIoKTtcbipcbiovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuZGVsZXRlX3VzZXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX2lkZW50aWZ5X2NhbGxlZCgpKSB7XG4gICAgICAgIGNvbnNvbGUkMS5lcnJvcignbWl4cGFuZWwucGVvcGxlLmRlbGV0ZV91c2VyKCkgcmVxdWlyZXMgeW91IHRvIGNhbGwgaWRlbnRpZnkoKSBmaXJzdCcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBkYXRhID0geyckZGVsZXRlJzogdGhpcy5fbWl4cGFuZWwuZ2V0X2Rpc3RpbmN0X2lkKCl9O1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSk7XG59O1xuXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbWl4cGFuZWwudG9TdHJpbmcoKSArICcucGVvcGxlJztcbn07XG5cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5fc2VuZF9yZXF1ZXN0ID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcbiAgICBkYXRhWyckdG9rZW4nXSA9IHRoaXMuX2dldF9jb25maWcoJ3Rva2VuJyk7XG4gICAgZGF0YVsnJGRpc3RpbmN0X2lkJ10gPSB0aGlzLl9taXhwYW5lbC5nZXRfZGlzdGluY3RfaWQoKTtcbiAgICB2YXIgZGV2aWNlX2lkID0gdGhpcy5fbWl4cGFuZWwuZ2V0X3Byb3BlcnR5KCckZGV2aWNlX2lkJyk7XG4gICAgdmFyIHVzZXJfaWQgPSB0aGlzLl9taXhwYW5lbC5nZXRfcHJvcGVydHkoJyR1c2VyX2lkJyk7XG4gICAgdmFyIGhhZF9wZXJzaXN0ZWRfZGlzdGluY3RfaWQgPSB0aGlzLl9taXhwYW5lbC5nZXRfcHJvcGVydHkoJyRoYWRfcGVyc2lzdGVkX2Rpc3RpbmN0X2lkJyk7XG4gICAgaWYgKGRldmljZV9pZCkge1xuICAgICAgICBkYXRhWyckZGV2aWNlX2lkJ10gPSBkZXZpY2VfaWQ7XG4gICAgfVxuICAgIGlmICh1c2VyX2lkKSB7XG4gICAgICAgIGRhdGFbJyR1c2VyX2lkJ10gPSB1c2VyX2lkO1xuICAgIH1cbiAgICBpZiAoaGFkX3BlcnNpc3RlZF9kaXN0aW5jdF9pZCkge1xuICAgICAgICBkYXRhWyckaGFkX3BlcnNpc3RlZF9kaXN0aW5jdF9pZCddID0gaGFkX3BlcnNpc3RlZF9kaXN0aW5jdF9pZDtcbiAgICB9XG5cbiAgICB2YXIgZGF0ZV9lbmNvZGVkX2RhdGEgPSBfLmVuY29kZURhdGVzKGRhdGEpO1xuXG4gICAgaWYgKCF0aGlzLl9pZGVudGlmeV9jYWxsZWQoKSkge1xuICAgICAgICB0aGlzLl9lbnF1ZXVlKGRhdGEpO1xuICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQoY2FsbGJhY2spKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZ2V0X2NvbmZpZygndmVyYm9zZScpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soe3N0YXR1czogLTEsIGVycm9yOiBudWxsfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXy50cnVuY2F0ZShkYXRlX2VuY29kZWRfZGF0YSwgMjU1KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fbWl4cGFuZWwuX3RyYWNrX29yX2JhdGNoKHtcbiAgICAgICAgdHlwZTogJ3Blb3BsZScsXG4gICAgICAgIGRhdGE6IGRhdGVfZW5jb2RlZF9kYXRhLFxuICAgICAgICBlbmRwb2ludDogdGhpcy5fbWl4cGFuZWwuZ2V0X2FwaV9ob3N0KCdwZW9wbGUnKSArICcvJyArICB0aGlzLl9nZXRfY29uZmlnKCdhcGlfcm91dGVzJylbJ2VuZ2FnZSddLFxuICAgICAgICBiYXRjaGVyOiB0aGlzLl9taXhwYW5lbC5yZXF1ZXN0X2JhdGNoZXJzLnBlb3BsZVxuICAgIH0sIGNhbGxiYWNrKTtcbn07XG5cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5fZ2V0X2NvbmZpZyA9IGZ1bmN0aW9uKGNvbmZfdmFyKSB7XG4gICAgcmV0dXJuIHRoaXMuX21peHBhbmVsLmdldF9jb25maWcoY29uZl92YXIpO1xufTtcblxuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLl9pZGVudGlmeV9jYWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbWl4cGFuZWwuX2ZsYWdzLmlkZW50aWZ5X2NhbGxlZCA9PT0gdHJ1ZTtcbn07XG5cbi8vIFF1ZXVlIHVwIGVuZ2FnZSBvcGVyYXRpb25zIGlmIGlkZW50aWZ5IGhhc24ndCBiZWVuIGNhbGxlZCB5ZXQuXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuX2VucXVldWUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgaWYgKFNFVF9BQ1RJT04gaW4gZGF0YSkge1xuICAgICAgICB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fYWRkX3RvX3Blb3BsZV9xdWV1ZShTRVRfQUNUSU9OLCBkYXRhKTtcbiAgICB9IGVsc2UgaWYgKFNFVF9PTkNFX0FDVElPTiBpbiBkYXRhKSB7XG4gICAgICAgIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKFNFVF9PTkNFX0FDVElPTiwgZGF0YSk7XG4gICAgfSBlbHNlIGlmIChVTlNFVF9BQ1RJT04gaW4gZGF0YSkge1xuICAgICAgICB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fYWRkX3RvX3Blb3BsZV9xdWV1ZShVTlNFVF9BQ1RJT04sIGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoQUREX0FDVElPTiBpbiBkYXRhKSB7XG4gICAgICAgIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKEFERF9BQ1RJT04sIGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoQVBQRU5EX0FDVElPTiBpbiBkYXRhKSB7XG4gICAgICAgIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKEFQUEVORF9BQ1RJT04sIGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoUkVNT1ZFX0FDVElPTiBpbiBkYXRhKSB7XG4gICAgICAgIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKFJFTU9WRV9BQ1RJT04sIGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoVU5JT05fQUNUSU9OIGluIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoVU5JT05fQUNUSU9OLCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlJDEuZXJyb3IoJ0ludmFsaWQgY2FsbCB0byBfZW5xdWV1ZSgpOicsIGRhdGEpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5fZmx1c2hfb25lX3F1ZXVlID0gZnVuY3Rpb24oYWN0aW9uLCBhY3Rpb25fbWV0aG9kLCBjYWxsYmFjaywgcXVldWVfdG9fcGFyYW1zX2ZuKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgcXVldWVkX2RhdGEgPSBfLmV4dGVuZCh7fSwgdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10ubG9hZF9xdWV1ZShhY3Rpb24pKTtcbiAgICB2YXIgYWN0aW9uX3BhcmFtcyA9IHF1ZXVlZF9kYXRhO1xuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHF1ZXVlZF9kYXRhKSAmJiBfLmlzT2JqZWN0KHF1ZXVlZF9kYXRhKSAmJiAhXy5pc0VtcHR5T2JqZWN0KHF1ZXVlZF9kYXRhKSkge1xuICAgICAgICBfdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZShhY3Rpb24sIHF1ZXVlZF9kYXRhKTtcbiAgICAgICAgX3RoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLnNhdmUoKTtcbiAgICAgICAgaWYgKHF1ZXVlX3RvX3BhcmFtc19mbikge1xuICAgICAgICAgICAgYWN0aW9uX3BhcmFtcyA9IHF1ZXVlX3RvX3BhcmFtc19mbihxdWV1ZWRfZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aW9uX21ldGhvZC5jYWxsKF90aGlzLCBhY3Rpb25fcGFyYW1zLCBmdW5jdGlvbihyZXNwb25zZSwgZGF0YSkge1xuICAgICAgICAgICAgLy8gb24gYmFkIHJlc3BvbnNlLCB3ZSB3YW50IHRvIGFkZCBpdCBiYWNrIHRvIHRoZSBxdWV1ZVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKGFjdGlvbiwgcXVldWVkX2RhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLy8gRmx1c2ggcXVldWVkIGVuZ2FnZSBvcGVyYXRpb25zIC0gb3JkZXIgZG9lcyBub3QgbWF0dGVyLFxuLy8gYW5kIHRoZXJlIGFyZSBuZXR3b3JrIGxldmVsIHJhY2UgY29uZGl0aW9ucyBhbnl3YXlcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbihcbiAgICBfc2V0X2NhbGxiYWNrLCBfYWRkX2NhbGxiYWNrLCBfYXBwZW5kX2NhbGxiYWNrLCBfc2V0X29uY2VfY2FsbGJhY2ssIF91bmlvbl9jYWxsYmFjaywgX3Vuc2V0X2NhbGxiYWNrLCBfcmVtb3ZlX2NhbGxiYWNrXG4pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5fZmx1c2hfb25lX3F1ZXVlKFNFVF9BQ1RJT04sIHRoaXMuc2V0LCBfc2V0X2NhbGxiYWNrKTtcbiAgICB0aGlzLl9mbHVzaF9vbmVfcXVldWUoU0VUX09OQ0VfQUNUSU9OLCB0aGlzLnNldF9vbmNlLCBfc2V0X29uY2VfY2FsbGJhY2spO1xuICAgIHRoaXMuX2ZsdXNoX29uZV9xdWV1ZShVTlNFVF9BQ1RJT04sIHRoaXMudW5zZXQsIF91bnNldF9jYWxsYmFjaywgZnVuY3Rpb24ocXVldWUpIHsgcmV0dXJuIF8ua2V5cyhxdWV1ZSk7IH0pO1xuICAgIHRoaXMuX2ZsdXNoX29uZV9xdWV1ZShBRERfQUNUSU9OLCB0aGlzLmluY3JlbWVudCwgX2FkZF9jYWxsYmFjayk7XG4gICAgdGhpcy5fZmx1c2hfb25lX3F1ZXVlKFVOSU9OX0FDVElPTiwgdGhpcy51bmlvbiwgX3VuaW9uX2NhbGxiYWNrKTtcblxuICAgIC8vIHdlIGhhdmUgdG8gZmlyZSBvZmYgZWFjaCAkYXBwZW5kIGluZGl2aWR1YWxseSBzaW5jZSB0aGVyZSBpc1xuICAgIC8vIG5vIGNvbmNhdCBtZXRob2Qgc2VydmVyIHNpZGVcbiAgICB2YXIgJGFwcGVuZF9xdWV1ZSA9IHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLmxvYWRfcXVldWUoQVBQRU5EX0FDVElPTik7XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKCRhcHBlbmRfcXVldWUpICYmIF8uaXNBcnJheSgkYXBwZW5kX3F1ZXVlKSAmJiAkYXBwZW5kX3F1ZXVlLmxlbmd0aCkge1xuICAgICAgICB2YXIgJGFwcGVuZF9pdGVtO1xuICAgICAgICB2YXIgYXBwZW5kX2NhbGxiYWNrID0gZnVuY3Rpb24ocmVzcG9uc2UsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fYWRkX3RvX3Blb3BsZV9xdWV1ZShBUFBFTkRfQUNUSU9OLCAkYXBwZW5kX2l0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKF9hcHBlbmRfY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgX2FwcGVuZF9jYWxsYmFjayhyZXNwb25zZSwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGkgPSAkYXBwZW5kX3F1ZXVlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAkYXBwZW5kX3F1ZXVlID0gdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10ubG9hZF9xdWV1ZShBUFBFTkRfQUNUSU9OKTtcbiAgICAgICAgICAgICRhcHBlbmRfaXRlbSA9ICRhcHBlbmRfcXVldWUucG9wKCk7XG4gICAgICAgICAgICBfdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uc2F2ZSgpO1xuICAgICAgICAgICAgaWYgKCFfLmlzRW1wdHlPYmplY3QoJGFwcGVuZF9pdGVtKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmFwcGVuZCgkYXBwZW5kX2l0ZW0sIGFwcGVuZF9jYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzYW1lIGZvciAkcmVtb3ZlXG4gICAgdmFyICRyZW1vdmVfcXVldWUgPSB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5sb2FkX3F1ZXVlKFJFTU9WRV9BQ1RJT04pO1xuICAgIGlmICghXy5pc1VuZGVmaW5lZCgkcmVtb3ZlX3F1ZXVlKSAmJiBfLmlzQXJyYXkoJHJlbW92ZV9xdWV1ZSkgJiYgJHJlbW92ZV9xdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyICRyZW1vdmVfaXRlbTtcbiAgICAgICAgdmFyIHJlbW92ZV9jYWxsYmFjayA9IGZ1bmN0aW9uKHJlc3BvbnNlLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UgPT09IDApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoUkVNT1ZFX0FDVElPTiwgJHJlbW92ZV9pdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChfcmVtb3ZlX2NhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgIF9yZW1vdmVfY2FsbGJhY2socmVzcG9uc2UsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBqID0gJHJlbW92ZV9xdWV1ZS5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgJHJlbW92ZV9xdWV1ZSA9IHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLmxvYWRfcXVldWUoUkVNT1ZFX0FDVElPTik7XG4gICAgICAgICAgICAkcmVtb3ZlX2l0ZW0gPSAkcmVtb3ZlX3F1ZXVlLnBvcCgpO1xuICAgICAgICAgICAgX3RoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLnNhdmUoKTtcbiAgICAgICAgICAgIGlmICghXy5pc0VtcHR5T2JqZWN0KCRyZW1vdmVfaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZW1vdmUoJHJlbW92ZV9pdGVtLCByZW1vdmVfY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLl9pc19yZXNlcnZlZF9wcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgICByZXR1cm4gcHJvcCA9PT0gJyRkaXN0aW5jdF9pZCcgfHwgcHJvcCA9PT0gJyR0b2tlbicgfHwgcHJvcCA9PT0gJyRkZXZpY2VfaWQnIHx8IHByb3AgPT09ICckdXNlcl9pZCcgfHwgcHJvcCA9PT0gJyRoYWRfcGVyc2lzdGVkX2Rpc3RpbmN0X2lkJztcbn07XG5cbi8vIE1peHBhbmVsUGVvcGxlIEV4cG9ydHNcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsnc2V0J10gICAgICAgICAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnNldDtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsnc2V0X29uY2UnXSAgICAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnNldF9vbmNlO1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWyd1bnNldCddICAgICAgICAgPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUudW5zZXQ7XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ2luY3JlbWVudCddICAgICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5pbmNyZW1lbnQ7XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ2FwcGVuZCddICAgICAgICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5hcHBlbmQ7XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ3JlbW92ZSddICAgICAgICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5yZW1vdmU7XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ3VuaW9uJ10gICAgICAgICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS51bmlvbjtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsndHJhY2tfY2hhcmdlJ10gID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnRyYWNrX2NoYXJnZTtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsnY2xlYXJfY2hhcmdlcyddID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLmNsZWFyX2NoYXJnZXM7XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ2RlbGV0ZV91c2VyJ10gICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5kZWxldGVfdXNlcjtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsndG9TdHJpbmcnXSAgICAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiBlc2xpbnQgY2FtZWxjYXNlOiBcIm9mZlwiICovXG5cblxuLypcbiAqIENvbnN0YW50c1xuICovXG4vKiogQGNvbnN0ICovIHZhciBTRVRfUVVFVUVfS0VZICAgICAgICAgID0gJ19fbXBzJztcbi8qKiBAY29uc3QgKi8gdmFyIFNFVF9PTkNFX1FVRVVFX0tFWSAgICAgPSAnX19tcHNvJztcbi8qKiBAY29uc3QgKi8gdmFyIFVOU0VUX1FVRVVFX0tFWSAgICAgICAgPSAnX19tcHVzJztcbi8qKiBAY29uc3QgKi8gdmFyIEFERF9RVUVVRV9LRVkgICAgICAgICAgPSAnX19tcGEnO1xuLyoqIEBjb25zdCAqLyB2YXIgQVBQRU5EX1FVRVVFX0tFWSAgICAgICA9ICdfX21wYXAnO1xuLyoqIEBjb25zdCAqLyB2YXIgUkVNT1ZFX1FVRVVFX0tFWSAgICAgICA9ICdfX21wcic7XG4vKiogQGNvbnN0ICovIHZhciBVTklPTl9RVUVVRV9LRVkgICAgICAgID0gJ19fbXB1Jztcbi8vIFRoaXMga2V5IGlzIGRlcHJlY2F0ZWQsIGJ1dCB3ZSB3YW50IHRvIGNoZWNrIGZvciBpdCB0byBzZWUgd2hldGhlciBhbGlhc2luZyBpcyBhbGxvd2VkLlxuLyoqIEBjb25zdCAqLyB2YXIgUEVPUExFX0RJU1RJTkNUX0lEX0tFWSA9ICckcGVvcGxlX2Rpc3RpbmN0X2lkJztcbi8qKiBAY29uc3QgKi8gdmFyIEFMSUFTX0lEX0tFWSAgICAgICAgICAgPSAnX19hbGlhcyc7XG4vKiogQGNvbnN0ICovIHZhciBFVkVOVF9USU1FUlNfS0VZICAgICAgID0gJ19fdGltZXJzJztcbi8qKiBAY29uc3QgKi8gdmFyIFJFU0VSVkVEX1BST1BFUlRJRVMgPSBbXG4gICAgU0VUX1FVRVVFX0tFWSxcbiAgICBTRVRfT05DRV9RVUVVRV9LRVksXG4gICAgVU5TRVRfUVVFVUVfS0VZLFxuICAgIEFERF9RVUVVRV9LRVksXG4gICAgQVBQRU5EX1FVRVVFX0tFWSxcbiAgICBSRU1PVkVfUVVFVUVfS0VZLFxuICAgIFVOSU9OX1FVRVVFX0tFWSxcbiAgICBQRU9QTEVfRElTVElOQ1RfSURfS0VZLFxuICAgIEFMSUFTX0lEX0tFWSxcbiAgICBFVkVOVF9USU1FUlNfS0VZXG5dO1xuXG4vKipcbiAqIE1peHBhbmVsIFBlcnNpc3RlbmNlIE9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBNaXhwYW5lbFBlcnNpc3RlbmNlID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpc1sncHJvcHMnXSA9IHt9O1xuICAgIHRoaXMuY2FtcGFpZ25fcGFyYW1zX3NhdmVkID0gZmFsc2U7XG5cbiAgICBpZiAoY29uZmlnWydwZXJzaXN0ZW5jZV9uYW1lJ10pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gJ21wXycgKyBjb25maWdbJ3BlcnNpc3RlbmNlX25hbWUnXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm5hbWUgPSAnbXBfJyArIGNvbmZpZ1sndG9rZW4nXSArICdfbWl4cGFuZWwnO1xuICAgIH1cblxuICAgIHZhciBzdG9yYWdlX3R5cGUgPSBjb25maWdbJ3BlcnNpc3RlbmNlJ107XG4gICAgaWYgKHN0b3JhZ2VfdHlwZSAhPT0gJ2Nvb2tpZScgJiYgc3RvcmFnZV90eXBlICE9PSAnbG9jYWxTdG9yYWdlJykge1xuICAgICAgICBjb25zb2xlJDEuY3JpdGljYWwoJ1Vua25vd24gcGVyc2lzdGVuY2UgdHlwZSAnICsgc3RvcmFnZV90eXBlICsgJzsgZmFsbGluZyBiYWNrIHRvIGNvb2tpZScpO1xuICAgICAgICBzdG9yYWdlX3R5cGUgPSBjb25maWdbJ3BlcnNpc3RlbmNlJ10gPSAnY29va2llJztcbiAgICB9XG5cbiAgICBpZiAoc3RvcmFnZV90eXBlID09PSAnbG9jYWxTdG9yYWdlJyAmJiBfLmxvY2FsU3RvcmFnZS5pc19zdXBwb3J0ZWQoKSkge1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBfLmxvY2FsU3RvcmFnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBfLmNvb2tpZTtcbiAgICB9XG5cbiAgICB0aGlzLmxvYWQoKTtcbiAgICB0aGlzLnVwZGF0ZV9jb25maWcoY29uZmlnKTtcbiAgICB0aGlzLnVwZ3JhZGUoKTtcbiAgICB0aGlzLnNhdmUoKTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnByb3BlcnRpZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcCA9IHt9O1xuXG4gICAgdGhpcy5sb2FkKCk7XG5cbiAgICAvLyBGaWx0ZXIgb3V0IHJlc2VydmVkIHByb3BlcnRpZXNcbiAgICBfLmVhY2godGhpc1sncHJvcHMnXSwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICBpZiAoIV8uaW5jbHVkZShSRVNFUlZFRF9QUk9QRVJUSUVTLCBrKSkge1xuICAgICAgICAgICAgcFtrXSA9IHY7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcDtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cblxuICAgIHZhciBlbnRyeSA9IHRoaXMuc3RvcmFnZS5wYXJzZSh0aGlzLm5hbWUpO1xuXG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICAgIHRoaXNbJ3Byb3BzJ10gPSBfLmV4dGVuZCh7fSwgZW50cnkpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnVwZ3JhZGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb2xkX2Nvb2tpZSxcbiAgICAgICAgb2xkX2xvY2Fsc3RvcmFnZTtcblxuICAgIC8vIGlmIHRyYW5zZmVycmluZyBmcm9tIGNvb2tpZSB0byBsb2NhbFN0b3JhZ2Ugb3IgdmljZS12ZXJzYSwgY29weSBleGlzdGluZ1xuICAgIC8vIHN1cGVyIHByb3BlcnRpZXMgb3ZlciB0byBuZXcgc3RvcmFnZSBtb2RlXG4gICAgaWYgKHRoaXMuc3RvcmFnZSA9PT0gXy5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgb2xkX2Nvb2tpZSA9IF8uY29va2llLnBhcnNlKHRoaXMubmFtZSk7XG5cbiAgICAgICAgXy5jb29raWUucmVtb3ZlKHRoaXMubmFtZSk7XG4gICAgICAgIF8uY29va2llLnJlbW92ZSh0aGlzLm5hbWUsIHRydWUpO1xuXG4gICAgICAgIGlmIChvbGRfY29va2llKSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyX29uY2Uob2xkX2Nvb2tpZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RvcmFnZSA9PT0gXy5jb29raWUpIHtcbiAgICAgICAgb2xkX2xvY2Fsc3RvcmFnZSA9IF8ubG9jYWxTdG9yYWdlLnBhcnNlKHRoaXMubmFtZSk7XG5cbiAgICAgICAgXy5sb2NhbFN0b3JhZ2UucmVtb3ZlKHRoaXMubmFtZSk7XG5cbiAgICAgICAgaWYgKG9sZF9sb2NhbHN0b3JhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJfb25jZShvbGRfbG9jYWxzdG9yYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cblxuICAgIHRoaXMuc3RvcmFnZS5zZXQoXG4gICAgICAgIHRoaXMubmFtZSxcbiAgICAgICAgSlNPTlN0cmluZ2lmeSh0aGlzWydwcm9wcyddKSxcbiAgICAgICAgdGhpcy5leHBpcmVfZGF5cyxcbiAgICAgICAgdGhpcy5jcm9zc19zdWJkb21haW4sXG4gICAgICAgIHRoaXMuc2VjdXJlLFxuICAgICAgICB0aGlzLmNyb3NzX3NpdGUsXG4gICAgICAgIHRoaXMuY29va2llX2RvbWFpblxuICAgICk7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5sb2FkX3Byb3AgPSBmdW5jdGlvbihrZXkpIHtcbiAgICB0aGlzLmxvYWQoKTtcbiAgICByZXR1cm4gdGhpc1sncHJvcHMnXVtrZXldO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gcmVtb3ZlIGJvdGggZG9tYWluIGFuZCBzdWJkb21haW4gY29va2llc1xuICAgIHRoaXMuc3RvcmFnZS5yZW1vdmUodGhpcy5uYW1lLCBmYWxzZSwgdGhpcy5jb29raWVfZG9tYWluKTtcbiAgICB0aGlzLnN0b3JhZ2UucmVtb3ZlKHRoaXMubmFtZSwgdHJ1ZSwgdGhpcy5jb29raWVfZG9tYWluKTtcbn07XG5cbi8vIHJlbW92ZXMgdGhlIHN0b3JhZ2UgZW50cnkgYW5kIGRlbGV0ZXMgYWxsIGxvYWRlZCBkYXRhXG4vLyBmb3JjZWQgbmFtZSBmb3IgdGVzdHNcbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgICB0aGlzWydwcm9wcyddID0ge307XG59O1xuXG4vKipcbiogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4qIEBwYXJhbSB7Kj19IGRlZmF1bHRfdmFsdWVcbiogQHBhcmFtIHtudW1iZXI9fSBkYXlzXG4qL1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUucmVnaXN0ZXJfb25jZSA9IGZ1bmN0aW9uKHByb3BzLCBkZWZhdWx0X3ZhbHVlLCBkYXlzKSB7XG4gICAgaWYgKF8uaXNPYmplY3QocHJvcHMpKSB7XG4gICAgICAgIGlmICh0eXBlb2YoZGVmYXVsdF92YWx1ZSkgPT09ICd1bmRlZmluZWQnKSB7IGRlZmF1bHRfdmFsdWUgPSAnTm9uZSc7IH1cbiAgICAgICAgdGhpcy5leHBpcmVfZGF5cyA9ICh0eXBlb2YoZGF5cykgPT09ICd1bmRlZmluZWQnKSA/IHRoaXMuZGVmYXVsdF9leHBpcnkgOiBkYXlzO1xuXG4gICAgICAgIHRoaXMubG9hZCgpO1xuXG4gICAgICAgIF8uZWFjaChwcm9wcywgZnVuY3Rpb24odmFsLCBwcm9wKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXNbJ3Byb3BzJ10uaGFzT3duUHJvcGVydHkocHJvcCkgfHwgdGhpc1sncHJvcHMnXVtwcm9wXSA9PT0gZGVmYXVsdF92YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXNbJ3Byb3BzJ11bcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4qIEBwYXJhbSB7bnVtYmVyPX0gZGF5c1xuKi9cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24ocHJvcHMsIGRheXMpIHtcbiAgICBpZiAoXy5pc09iamVjdChwcm9wcykpIHtcbiAgICAgICAgdGhpcy5leHBpcmVfZGF5cyA9ICh0eXBlb2YoZGF5cykgPT09ICd1bmRlZmluZWQnKSA/IHRoaXMuZGVmYXVsdF9leHBpcnkgOiBkYXlzO1xuXG4gICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICBfLmV4dGVuZCh0aGlzWydwcm9wcyddLCBwcm9wcyk7XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS51bnJlZ2lzdGVyID0gZnVuY3Rpb24ocHJvcCkge1xuICAgIHRoaXMubG9hZCgpO1xuICAgIGlmIChwcm9wIGluIHRoaXNbJ3Byb3BzJ10pIHtcbiAgICAgICAgZGVsZXRlIHRoaXNbJ3Byb3BzJ11bcHJvcF07XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnVwZGF0ZV9zZWFyY2hfa2V5d29yZCA9IGZ1bmN0aW9uKHJlZmVycmVyKSB7XG4gICAgdGhpcy5yZWdpc3RlcihfLmluZm8uc2VhcmNoSW5mbyhyZWZlcnJlcikpO1xufTtcblxuLy8gRVhQT1JURUQgTUVUSE9ELCB3ZSB0ZXN0IHRoaXMgZGlyZWN0bHkuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS51cGRhdGVfcmVmZXJyZXJfaW5mbyA9IGZ1bmN0aW9uKHJlZmVycmVyKSB7XG4gICAgLy8gSWYgcmVmZXJyZXIgZG9lc24ndCBleGlzdCwgd2Ugd2FudCB0byBub3RlIHRoZSBmYWN0IHRoYXQgaXQgd2FzIHR5cGUtaW4gdHJhZmZpYy5cbiAgICB0aGlzLnJlZ2lzdGVyX29uY2Uoe1xuICAgICAgICAnJGluaXRpYWxfcmVmZXJyZXInOiByZWZlcnJlciB8fCAnJGRpcmVjdCcsXG4gICAgICAgICckaW5pdGlhbF9yZWZlcnJpbmdfZG9tYWluJzogXy5pbmZvLnJlZmVycmluZ0RvbWFpbihyZWZlcnJlcikgfHwgJyRkaXJlY3QnXG4gICAgfSwgJycpO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuZ2V0X3JlZmVycmVyX2luZm8gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXy5zdHJpcF9lbXB0eV9wcm9wZXJ0aWVzKHtcbiAgICAgICAgJyRpbml0aWFsX3JlZmVycmVyJzogdGhpc1sncHJvcHMnXVsnJGluaXRpYWxfcmVmZXJyZXInXSxcbiAgICAgICAgJyRpbml0aWFsX3JlZmVycmluZ19kb21haW4nOiB0aGlzWydwcm9wcyddWyckaW5pdGlhbF9yZWZlcnJpbmdfZG9tYWluJ11cbiAgICB9KTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnVwZGF0ZV9jb25maWcgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB0aGlzLmRlZmF1bHRfZXhwaXJ5ID0gdGhpcy5leHBpcmVfZGF5cyA9IGNvbmZpZ1snY29va2llX2V4cGlyYXRpb24nXTtcbiAgICB0aGlzLnNldF9kaXNhYmxlZChjb25maWdbJ2Rpc2FibGVfcGVyc2lzdGVuY2UnXSk7XG4gICAgdGhpcy5zZXRfY29va2llX2RvbWFpbihjb25maWdbJ2Nvb2tpZV9kb21haW4nXSk7XG4gICAgdGhpcy5zZXRfY3Jvc3Nfc2l0ZShjb25maWdbJ2Nyb3NzX3NpdGVfY29va2llJ10pO1xuICAgIHRoaXMuc2V0X2Nyb3NzX3N1YmRvbWFpbihjb25maWdbJ2Nyb3NzX3N1YmRvbWFpbl9jb29raWUnXSk7XG4gICAgdGhpcy5zZXRfc2VjdXJlKGNvbmZpZ1snc2VjdXJlX2Nvb2tpZSddKTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnNldF9kaXNhYmxlZCA9IGZ1bmN0aW9uKGRpc2FibGVkKSB7XG4gICAgdGhpcy5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuc2V0X2Nvb2tpZV9kb21haW4gPSBmdW5jdGlvbihjb29raWVfZG9tYWluKSB7XG4gICAgaWYgKGNvb2tpZV9kb21haW4gIT09IHRoaXMuY29va2llX2RvbWFpbikge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLmNvb2tpZV9kb21haW4gPSBjb29raWVfZG9tYWluO1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5zZXRfY3Jvc3Nfc2l0ZSA9IGZ1bmN0aW9uKGNyb3NzX3NpdGUpIHtcbiAgICBpZiAoY3Jvc3Nfc2l0ZSAhPT0gdGhpcy5jcm9zc19zaXRlKSB7XG4gICAgICAgIHRoaXMuY3Jvc3Nfc2l0ZSA9IGNyb3NzX3NpdGU7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnNldF9jcm9zc19zdWJkb21haW4gPSBmdW5jdGlvbihjcm9zc19zdWJkb21haW4pIHtcbiAgICBpZiAoY3Jvc3Nfc3ViZG9tYWluICE9PSB0aGlzLmNyb3NzX3N1YmRvbWFpbikge1xuICAgICAgICB0aGlzLmNyb3NzX3N1YmRvbWFpbiA9IGNyb3NzX3N1YmRvbWFpbjtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuZ2V0X2Nyb3NzX3N1YmRvbWFpbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNyb3NzX3N1YmRvbWFpbjtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnNldF9zZWN1cmUgPSBmdW5jdGlvbihzZWN1cmUpIHtcbiAgICBpZiAoc2VjdXJlICE9PSB0aGlzLnNlY3VyZSkge1xuICAgICAgICB0aGlzLnNlY3VyZSA9IHNlY3VyZSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuX2FkZF90b19wZW9wbGVfcXVldWUgPSBmdW5jdGlvbihxdWV1ZSwgZGF0YSkge1xuICAgIHZhciBxX2tleSA9IHRoaXMuX2dldF9xdWV1ZV9rZXkocXVldWUpLFxuICAgICAgICBxX2RhdGEgPSBkYXRhW3F1ZXVlXSxcbiAgICAgICAgc2V0X3EgPSB0aGlzLl9nZXRfb3JfY3JlYXRlX3F1ZXVlKFNFVF9BQ1RJT04pLFxuICAgICAgICBzZXRfb25jZV9xID0gdGhpcy5fZ2V0X29yX2NyZWF0ZV9xdWV1ZShTRVRfT05DRV9BQ1RJT04pLFxuICAgICAgICB1bnNldF9xID0gdGhpcy5fZ2V0X29yX2NyZWF0ZV9xdWV1ZShVTlNFVF9BQ1RJT04pLFxuICAgICAgICBhZGRfcSA9IHRoaXMuX2dldF9vcl9jcmVhdGVfcXVldWUoQUREX0FDVElPTiksXG4gICAgICAgIHVuaW9uX3EgPSB0aGlzLl9nZXRfb3JfY3JlYXRlX3F1ZXVlKFVOSU9OX0FDVElPTiksXG4gICAgICAgIHJlbW92ZV9xID0gdGhpcy5fZ2V0X29yX2NyZWF0ZV9xdWV1ZShSRU1PVkVfQUNUSU9OLCBbXSksXG4gICAgICAgIGFwcGVuZF9xID0gdGhpcy5fZ2V0X29yX2NyZWF0ZV9xdWV1ZShBUFBFTkRfQUNUSU9OLCBbXSk7XG5cbiAgICBpZiAocV9rZXkgPT09IFNFVF9RVUVVRV9LRVkpIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBzZXQgcXVldWUgLSB3ZSBjYW4gb3ZlcnJpZGUgYW55IGV4aXN0aW5nIHZhbHVlc1xuICAgICAgICBfLmV4dGVuZChzZXRfcSwgcV9kYXRhKTtcbiAgICAgICAgLy8gaWYgdGhlcmUgd2FzIGEgcGVuZGluZyBpbmNyZW1lbnQsIG92ZXJyaWRlIGl0XG4gICAgICAgIC8vIHdpdGggdGhlIHNldC5cbiAgICAgICAgdGhpcy5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlKEFERF9BQ1RJT04sIHFfZGF0YSk7XG4gICAgICAgIC8vIGlmIHRoZXJlIHdhcyBhIHBlbmRpbmcgdW5pb24sIG92ZXJyaWRlIGl0XG4gICAgICAgIC8vIHdpdGggdGhlIHNldC5cbiAgICAgICAgdGhpcy5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlKFVOSU9OX0FDVElPTiwgcV9kYXRhKTtcbiAgICAgICAgdGhpcy5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlKFVOU0VUX0FDVElPTiwgcV9kYXRhKTtcbiAgICB9IGVsc2UgaWYgKHFfa2V5ID09PSBTRVRfT05DRV9RVUVVRV9LRVkpIHtcbiAgICAgICAgLy8gb25seSBxdWV1ZSB0aGUgZGF0YSBpZiB0aGVyZSBpcyBub3QgYWxyZWFkeSBhIHNldF9vbmNlIGNhbGwgZm9yIGl0LlxuICAgICAgICBfLmVhY2gocV9kYXRhLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICBpZiAoIShrIGluIHNldF9vbmNlX3EpKSB7XG4gICAgICAgICAgICAgICAgc2V0X29uY2VfcVtrXSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUoVU5TRVRfQUNUSU9OLCBxX2RhdGEpO1xuICAgIH0gZWxzZSBpZiAocV9rZXkgPT09IFVOU0VUX1FVRVVFX0tFWSkge1xuICAgICAgICBfLmVhY2gocV9kYXRhLCBmdW5jdGlvbihwcm9wKSB7XG5cbiAgICAgICAgICAgIC8vIHVuZG8gcHJldmlvdXNseS1xdWV1ZWQgYWN0aW9ucyBvbiB0aGlzIGtleVxuICAgICAgICAgICAgXy5lYWNoKFtzZXRfcSwgc2V0X29uY2VfcSwgYWRkX3EsIHVuaW9uX3FdLCBmdW5jdGlvbihlbnF1ZXVlZF9vYmopIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCBpbiBlbnF1ZXVlZF9vYmopIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGVucXVldWVkX29ialtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF8uZWFjaChhcHBlbmRfcSwgZnVuY3Rpb24oYXBwZW5kX29iaikge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wIGluIGFwcGVuZF9vYmopIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGFwcGVuZF9vYmpbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHVuc2V0X3FbcHJvcF0gPSB0cnVlO1xuXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocV9rZXkgPT09IEFERF9RVUVVRV9LRVkpIHtcbiAgICAgICAgXy5lYWNoKHFfZGF0YSwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgLy8gSWYgaXQgZXhpc3RzIGluIHRoZSBzZXQgcXVldWUsIGluY3JlbWVudFxuICAgICAgICAgICAgLy8gdGhlIHZhbHVlXG4gICAgICAgICAgICBpZiAoayBpbiBzZXRfcSkge1xuICAgICAgICAgICAgICAgIHNldF9xW2tdICs9IHY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIGl0IGRvZXNuJ3QgZXhpc3QsIHVwZGF0ZSB0aGUgYWRkXG4gICAgICAgICAgICAgICAgLy8gcXVldWVcbiAgICAgICAgICAgICAgICBpZiAoIShrIGluIGFkZF9xKSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRfcVtrXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZF9xW2tdICs9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB0aGlzLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUoVU5TRVRfQUNUSU9OLCBxX2RhdGEpO1xuICAgIH0gZWxzZSBpZiAocV9rZXkgPT09IFVOSU9OX1FVRVVFX0tFWSkge1xuICAgICAgICBfLmVhY2gocV9kYXRhLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICBpZiAoXy5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoayBpbiB1bmlvbl9xKSkge1xuICAgICAgICAgICAgICAgICAgICB1bmlvbl9xW2tdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgZHVwbGljYXRlIHZhbHVlc1xuICAgICAgICAgICAgICAgIF8uZWFjaCh2LCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghXy5pbmNsdWRlKHVuaW9uX3Fba10sIGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlvbl9xW2tdLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZShVTlNFVF9BQ1RJT04sIHFfZGF0YSk7XG4gICAgfSBlbHNlIGlmIChxX2tleSA9PT0gUkVNT1ZFX1FVRVVFX0tFWSkge1xuICAgICAgICByZW1vdmVfcS5wdXNoKHFfZGF0YSk7XG4gICAgICAgIHRoaXMuX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZShBUFBFTkRfQUNUSU9OLCBxX2RhdGEpO1xuICAgIH0gZWxzZSBpZiAocV9rZXkgPT09IEFQUEVORF9RVUVVRV9LRVkpIHtcbiAgICAgICAgYXBwZW5kX3EucHVzaChxX2RhdGEpO1xuICAgICAgICB0aGlzLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUoVU5TRVRfQUNUSU9OLCBxX2RhdGEpO1xuICAgIH1cblxuICAgIGNvbnNvbGUkMS5sb2coJ01JWFBBTkVMIFBFT1BMRSBSRVFVRVNUIChRVUVVRUQsIFBFTkRJTkcgSURFTlRJRlkpOicpO1xuICAgIGNvbnNvbGUkMS5sb2coZGF0YSk7XG5cbiAgICB0aGlzLnNhdmUoKTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUgPSBmdW5jdGlvbihxdWV1ZSwgZGF0YSkge1xuICAgIHZhciBxID0gdGhpc1sncHJvcHMnXVt0aGlzLl9nZXRfcXVldWVfa2V5KHF1ZXVlKV07XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHEpKSB7XG4gICAgICAgIF8uZWFjaChkYXRhLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICBpZiAocXVldWUgPT09IEFQUEVORF9BQ1RJT04gfHwgcXVldWUgPT09IFJFTU9WRV9BQ1RJT04pIHtcbiAgICAgICAgICAgICAgICAvLyBsaXN0IGFjdGlvbnM6IG9ubHkgcmVtb3ZlIGlmIGJvdGggayt2IG1hdGNoXG4gICAgICAgICAgICAgICAgLy8gZS5nLiByZW1vdmUgc2hvdWxkIG5vdCBvdmVycmlkZSBhcHBlbmQgaW4gYSBjYXNlIGxpa2VcbiAgICAgICAgICAgICAgICAvLyBhcHBlbmQoe2ZvbzogJ2Jhcid9KTsgcmVtb3ZlKHtmb286ICdxdXgnfSlcbiAgICAgICAgICAgICAgICBfLmVhY2gocSwgZnVuY3Rpb24ocXVldWVkX2FjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocXVldWVkX2FjdGlvbltrXSA9PT0gdikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHF1ZXVlZF9hY3Rpb25ba107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHFba107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLmxvYWRfcXVldWUgPSBmdW5jdGlvbihxdWV1ZSkge1xuICAgIHJldHVybiB0aGlzLmxvYWRfcHJvcCh0aGlzLl9nZXRfcXVldWVfa2V5KHF1ZXVlKSk7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5fZ2V0X3F1ZXVlX2tleSA9IGZ1bmN0aW9uKHF1ZXVlKSB7XG4gICAgaWYgKHF1ZXVlID09PSBTRVRfQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBTRVRfUVVFVUVfS0VZO1xuICAgIH0gZWxzZSBpZiAocXVldWUgPT09IFNFVF9PTkNFX0FDVElPTikge1xuICAgICAgICByZXR1cm4gU0VUX09OQ0VfUVVFVUVfS0VZO1xuICAgIH0gZWxzZSBpZiAocXVldWUgPT09IFVOU0VUX0FDVElPTikge1xuICAgICAgICByZXR1cm4gVU5TRVRfUVVFVUVfS0VZO1xuICAgIH0gZWxzZSBpZiAocXVldWUgPT09IEFERF9BQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIEFERF9RVUVVRV9LRVk7XG4gICAgfSBlbHNlIGlmIChxdWV1ZSA9PT0gQVBQRU5EX0FDVElPTikge1xuICAgICAgICByZXR1cm4gQVBQRU5EX1FVRVVFX0tFWTtcbiAgICB9IGVsc2UgaWYgKHF1ZXVlID09PSBSRU1PVkVfQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBSRU1PVkVfUVVFVUVfS0VZO1xuICAgIH0gZWxzZSBpZiAocXVldWUgPT09IFVOSU9OX0FDVElPTikge1xuICAgICAgICByZXR1cm4gVU5JT05fUVVFVUVfS0VZO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUkMS5lcnJvcignSW52YWxpZCBxdWV1ZTonLCBxdWV1ZSk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuX2dldF9vcl9jcmVhdGVfcXVldWUgPSBmdW5jdGlvbihxdWV1ZSwgZGVmYXVsdF92YWwpIHtcbiAgICB2YXIga2V5ID0gdGhpcy5fZ2V0X3F1ZXVlX2tleShxdWV1ZSk7XG4gICAgZGVmYXVsdF92YWwgPSBfLmlzVW5kZWZpbmVkKGRlZmF1bHRfdmFsKSA/IHt9IDogZGVmYXVsdF92YWw7XG4gICAgcmV0dXJuIHRoaXNbJ3Byb3BzJ11ba2V5XSB8fCAodGhpc1sncHJvcHMnXVtrZXldID0gZGVmYXVsdF92YWwpO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuc2V0X2V2ZW50X3RpbWVyID0gZnVuY3Rpb24oZXZlbnRfbmFtZSwgdGltZXN0YW1wKSB7XG4gICAgdmFyIHRpbWVycyA9IHRoaXMubG9hZF9wcm9wKEVWRU5UX1RJTUVSU19LRVkpIHx8IHt9O1xuICAgIHRpbWVyc1tldmVudF9uYW1lXSA9IHRpbWVzdGFtcDtcbiAgICB0aGlzWydwcm9wcyddW0VWRU5UX1RJTUVSU19LRVldID0gdGltZXJzO1xuICAgIHRoaXMuc2F2ZSgpO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUucmVtb3ZlX2V2ZW50X3RpbWVyID0gZnVuY3Rpb24oZXZlbnRfbmFtZSkge1xuICAgIHZhciB0aW1lcnMgPSB0aGlzLmxvYWRfcHJvcChFVkVOVF9USU1FUlNfS0VZKSB8fCB7fTtcbiAgICB2YXIgdGltZXN0YW1wID0gdGltZXJzW2V2ZW50X25hbWVdO1xuICAgIGlmICghXy5pc1VuZGVmaW5lZCh0aW1lc3RhbXApKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzWydwcm9wcyddW0VWRU5UX1RJTUVSU19LRVldW2V2ZW50X25hbWVdO1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbWVzdGFtcDtcbn07XG5cbi8qIGVzbGludCBjYW1lbGNhc2U6IFwib2ZmXCIgKi9cblxuLypcbiAqIE1peHBhbmVsIEpTIExpYnJhcnlcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMiwgTWl4cGFuZWwsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZFxuICogaHR0cDovL21peHBhbmVsLmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBwb3J0aW9ucyBvZiBVbmRlcnNjb3JlLmpzXG4gKiBodHRwOi8vZG9jdW1lbnRjbG91ZC5naXRodWIuY29tL3VuZGVyc2NvcmUvXG4gKiAoYykgMjAxMSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgSW5jLlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbi8qXG5TSU1QTEUgU1RZTEUgR1VJREU6XG5cbnRoaXMueCA9PT0gcHVibGljIGZ1bmN0aW9uXG50aGlzLl94ID09PSBpbnRlcm5hbCAtIG9ubHkgdXNlIHdpdGhpbiB0aGlzIGZpbGVcbnRoaXMuX194ID09PSBwcml2YXRlIC0gb25seSB1c2Ugd2l0aGluIHRoZSBjbGFzc1xuXG5HbG9iYWxzIHNob3VsZCBiZSBhbGwgY2Fwc1xuKi9cblxudmFyIGluaXRfdHlwZTsgICAgICAgLy8gTU9EVUxFIG9yIFNOSVBQRVQgbG9hZGVyXG4vLyBhbGxvdyBidW5kbGVycyB0byBzcGVjaWZ5IGhvdyBleHRyYSBjb2RlIChyZWNvcmRlciBidW5kbGUpIHNob3VsZCBiZSBsb2FkZWRcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xudmFyIGxvYWRfZXh0cmFfYnVuZGxlID0gZnVuY3Rpb24oc3JjLCBfb25sb2FkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHNyYyArICcgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGJ1aWxkLicpO1xufTtcblxudmFyIG1peHBhbmVsX21hc3RlcjsgLy8gbWFpbiBtaXhwYW5lbCBpbnN0YW5jZSAvIG9iamVjdFxudmFyIElOSVRfTU9EVUxFICA9IDA7XG52YXIgSU5JVF9TTklQUEVUID0gMTtcblxudmFyIElERU5USVRZX0ZVTkMgPSBmdW5jdGlvbih4KSB7cmV0dXJuIHg7fTtcblxuLyoqIEBjb25zdCAqLyB2YXIgUFJJTUFSWV9JTlNUQU5DRV9OQU1FID0gJ21peHBhbmVsJztcbi8qKiBAY29uc3QgKi8gdmFyIFBBWUxPQURfVFlQRV9CQVNFNjQgICA9ICdiYXNlNjQnO1xuLyoqIEBjb25zdCAqLyB2YXIgUEFZTE9BRF9UWVBFX0pTT04gICAgID0gJ2pzb24nO1xuLyoqIEBjb25zdCAqLyB2YXIgREVWSUNFX0lEX1BSRUZJWCAgICAgID0gJyRkZXZpY2U6JztcblxuXG4vKlxuICogRHluYW1pYy4uLiBjb25zdGFudHM/IElzIHRoYXQgYW4gb3h5bW9yb24/XG4gKi9cbi8vIGh0dHA6Ly9oYWNrcy5tb3ppbGxhLm9yZy8yMDA5LzA3L2Nyb3NzLXNpdGUteG1saHR0cHJlcXVlc3Qtd2l0aC1jb3JzL1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9ET00vWE1MSHR0cFJlcXVlc3Qjd2l0aENyZWRlbnRpYWxzXG52YXIgVVNFX1hIUiA9ICh3aW4uWE1MSHR0cFJlcXVlc3QgJiYgJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCkpO1xuXG4vLyBJRTwxMCBkb2VzIG5vdCBzdXBwb3J0IGNyb3NzLW9yaWdpbiBYSFIncyBidXQgc2NyaXB0IHRhZ3Ncbi8vIHdpdGggZGVmZXIgd29uJ3QgYmxvY2sgd2luZG93Lm9ubG9hZDsgRU5RVUVVRV9SRVFVRVNUU1xuLy8gc2hvdWxkIG9ubHkgYmUgdHJ1ZSBmb3IgT3BlcmE8MTJcbnZhciBFTlFVRVVFX1JFUVVFU1RTID0gIVVTRV9YSFIgJiYgKHVzZXJBZ2VudC5pbmRleE9mKCdNU0lFJykgPT09IC0xKSAmJiAodXNlckFnZW50LmluZGV4T2YoJ01vemlsbGEnKSA9PT0gLTEpO1xuXG4vLyBzYXZlIHJlZmVyZW5jZSB0byBuYXZpZ2F0b3Iuc2VuZEJlYWNvbiBzbyBpdCBjYW4gYmUgbWluaWZpZWRcbnZhciBzZW5kQmVhY29uID0gbnVsbDtcbmlmIChuYXZpZ2F0b3JbJ3NlbmRCZWFjb24nXSkge1xuICAgIHNlbmRCZWFjb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gbGF0ZSByZWZlcmVuY2UgdG8gbmF2aWdhdG9yLnNlbmRCZWFjb24gdG8gYWxsb3cgcGF0Y2hpbmcvc3B5aW5nXG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3JbJ3NlbmRCZWFjb24nXS5hcHBseShuYXZpZ2F0b3IsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxudmFyIERFRkFVTFRfQVBJX1JPVVRFUyA9IHtcbiAgICAndHJhY2snOiAgJ3RyYWNrLycsXG4gICAgJ2VuZ2FnZSc6ICdlbmdhZ2UvJyxcbiAgICAnZ3JvdXBzJzogJ2dyb3Vwcy8nLFxuICAgICdyZWNvcmQnOiAncmVjb3JkLycsXG4gICAgJ2ZsYWdzJzogICdmbGFncy8nXG59O1xuXG4vKlxuICogTW9kdWxlLWxldmVsIGdsb2JhbHNcbiAqL1xudmFyIERFRkFVTFRfQ09ORklHID0ge1xuICAgICdhcGlfaG9zdCc6ICAgICAgICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9hcGktanMubWl4cGFuZWwuY29tJyxcbiAgICAnYXBpX2hvc3RzJzogICAgICAgICAgICAgICAgICAgICAgICAge30sXG4gICAgJ2FwaV9yb3V0ZXMnOiAgICAgICAgICAgICAgICAgICAgICAgIERFRkFVTFRfQVBJX1JPVVRFUyxcbiAgICAnYXBpX2V4dHJhX3F1ZXJ5X3BhcmFtcyc6ICAgICAgICAgICAge30sXG4gICAgJ2FwaV9tZXRob2QnOiAgICAgICAgICAgICAgICAgICAgICAgICdQT1NUJyxcbiAgICAnYXBpX3RyYW5zcG9ydCc6ICAgICAgICAgICAgICAgICAgICAgJ1hIUicsXG4gICAgJ2FwaV9wYXlsb2FkX2Zvcm1hdCc6ICAgICAgICAgICAgICAgIFBBWUxPQURfVFlQRV9CQVNFNjQsXG4gICAgJ2FwcF9ob3N0JzogICAgICAgICAgICAgICAgICAgICAgICAgICdodHRwczovL21peHBhbmVsLmNvbScsXG4gICAgJ2F1dG9jYXB0dXJlJzogICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdjZG4nOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9jZG4ubXhwbmwuY29tJyxcbiAgICAnY3Jvc3Nfc2l0ZV9jb29raWUnOiAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ2Nyb3NzX3N1YmRvbWFpbl9jb29raWUnOiAgICAgICAgICAgIHRydWUsXG4gICAgJ2Vycm9yX3JlcG9ydGVyJzogICAgICAgICAgICAgICAgICAgIE5PT1BfRlVOQyxcbiAgICAnZmxhZ3MnOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ3BlcnNpc3RlbmNlJzogICAgICAgICAgICAgICAgICAgICAgICdjb29raWUnLFxuICAgICdwZXJzaXN0ZW5jZV9uYW1lJzogICAgICAgICAgICAgICAgICAnJyxcbiAgICAnY29va2llX2RvbWFpbic6ICAgICAgICAgICAgICAgICAgICAgJycsXG4gICAgJ2Nvb2tpZV9uYW1lJzogICAgICAgICAgICAgICAgICAgICAgICcnLFxuICAgICdsb2FkZWQnOiAgICAgICAgICAgICAgICAgICAgICAgICAgICBOT09QX0ZVTkMsXG4gICAgJ21wX2xvYWRlcic6ICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgJ3RyYWNrX21hcmtldGluZyc6ICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgJ3RyYWNrX3BhZ2V2aWV3JzogICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdza2lwX2ZpcnN0X3RvdWNoX21hcmtldGluZyc6ICAgICAgICBmYWxzZSxcbiAgICAnc3RvcmVfZ29vZ2xlJzogICAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAnc3RvcF91dG1fcGVyc2lzdGVuY2UnOiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ3NhdmVfcmVmZXJyZXInOiAgICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgJ3Rlc3QnOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICd2ZXJib3NlJzogICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnaW1nJzogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ2RlYnVnJzogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICd0cmFja19saW5rc190aW1lb3V0JzogICAgICAgICAgICAgICAzMDAsXG4gICAgJ2Nvb2tpZV9leHBpcmF0aW9uJzogICAgICAgICAgICAgICAgIDM2NSxcbiAgICAndXBncmFkZSc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ2Rpc2FibGVfcGVyc2lzdGVuY2UnOiAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdkaXNhYmxlX2Nvb2tpZSc6ICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnc2VjdXJlX2Nvb2tpZSc6ICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ2lwJzogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgJ29wdF9vdXRfdHJhY2tpbmdfYnlfZGVmYXVsdCc6ICAgICAgIGZhbHNlLFxuICAgICdvcHRfb3V0X3BlcnNpc3RlbmNlX2J5X2RlZmF1bHQnOiAgICBmYWxzZSxcbiAgICAnb3B0X291dF90cmFja2luZ19wZXJzaXN0ZW5jZV90eXBlJzogJ2xvY2FsU3RvcmFnZScsXG4gICAgJ29wdF9vdXRfdHJhY2tpbmdfY29va2llX3ByZWZpeCc6ICAgIG51bGwsXG4gICAgJ3Byb3BlcnR5X2JsYWNrbGlzdCc6ICAgICAgICAgICAgICAgIFtdLFxuICAgICd4aHJfaGVhZGVycyc6ICAgICAgICAgICAgICAgICAgICAgICB7fSwgLy8geyBoZWFkZXI6IHZhbHVlLCBoZWFkZXIyOiB2YWx1ZSB9XG4gICAgJ2lnbm9yZV9kbnQnOiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdiYXRjaF9yZXF1ZXN0cyc6ICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICdiYXRjaF9zaXplJzogICAgICAgICAgICAgICAgICAgICAgICA1MCxcbiAgICAnYmF0Y2hfZmx1c2hfaW50ZXJ2YWxfbXMnOiAgICAgICAgICAgNTAwMCxcbiAgICAnYmF0Y2hfcmVxdWVzdF90aW1lb3V0X21zJzogICAgICAgICAgOTAwMDAsXG4gICAgJ2JhdGNoX2F1dG9zdGFydCc6ICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgJ2hvb2tzJzogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt9LFxuICAgICdyZWNvcmRfYmxvY2tfY2xhc3MnOiAgICAgICAgICAgICAgICBuZXcgUmVnRXhwKCdeKG1wLWJsb2NrfGZzLWV4Y2x1ZGV8YW1wLWJsb2NrfHJyLWJsb2NrfHBoLW5vLWNhcHR1cmUpJCcpLFxuICAgICdyZWNvcmRfYmxvY2tfc2VsZWN0b3InOiAgICAgICAgICAgICAnaW1nLCB2aWRlbywgYXVkaW8nLFxuICAgICdyZWNvcmRfY2FudmFzJzogICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAncmVjb3JkX2NvbGxlY3RfZm9udHMnOiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ3JlY29yZF9jb25zb2xlJzogICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgJ3JlY29yZF9oZWF0bWFwX2RhdGEnOiAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdyZWNvcmRfaWRsZV90aW1lb3V0X21zJzogICAgICAgICAgICAzMCAqIDYwICogMTAwMCwgLy8gMzAgbWludXRlc1xuICAgICdyZWNvcmRfbWFza190ZXh0X2NsYXNzJzogICAgICAgICAgICBuZXcgUmVnRXhwKCdeKG1wLW1hc2t8ZnMtbWFza3xhbXAtbWFza3xyci1tYXNrfHBoLW1hc2spJCcpLFxuICAgICdyZWNvcmRfbWFza190ZXh0X3NlbGVjdG9yJzogICAgICAgICAnKicsXG4gICAgJ3JlY29yZF9tYXhfbXMnOiAgICAgICAgICAgICAgICAgICAgIE1BWF9SRUNPUkRJTkdfTVMsXG4gICAgJ3JlY29yZF9taW5fbXMnOiAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgJ3JlY29yZF9zZXNzaW9uc19wZXJjZW50JzogICAgICAgICAgIDAsXG4gICAgJ3JlY29yZGVyX3NyYyc6ICAgICAgICAgICAgICAgICAgICAgICdodHRwczovL2Nkbi5teHBubC5jb20vbGlicy9taXhwYW5lbC1yZWNvcmRlci5taW4uanMnXG59O1xuXG52YXIgRE9NX0xPQURFRCA9IGZhbHNlO1xuXG4vKipcbiAqIE1peHBhbmVsIExpYnJhcnkgT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE1peHBhbmVsTGliID0gZnVuY3Rpb24oKSB7fTtcblxuXG4vKipcbiAqIGNyZWF0ZV9tcGxpYih0b2tlbjpzdHJpbmcsIGNvbmZpZzpvYmplY3QsIG5hbWU6c3RyaW5nKVxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBieSB0aGUgaW5pdCBtZXRob2Qgb2YgTWl4cGFuZWxMaWIgb2JqZWN0c1xuICogYXMgd2VsbCBhcyB0aGUgbWFpbiBpbml0aWFsaXplciBhdCB0aGUgZW5kIG9mIHRoZSBKU0xpYiAodGhhdFxuICogaW5pdGlhbGl6ZXMgZG9jdW1lbnQubWl4cGFuZWwgYXMgd2VsbCBhcyBhbnkgYWRkaXRpb25hbCBpbnN0YW5jZXNcbiAqIGRlY2xhcmVkIGJlZm9yZSB0aGlzIGZpbGUgaGFzIGxvYWRlZCkuXG4gKi9cbnZhciBjcmVhdGVfbXBsaWIgPSBmdW5jdGlvbih0b2tlbiwgY29uZmlnLCBuYW1lKSB7XG4gICAgdmFyIGluc3RhbmNlLFxuICAgICAgICB0YXJnZXQgPSAobmFtZSA9PT0gUFJJTUFSWV9JTlNUQU5DRV9OQU1FKSA/IG1peHBhbmVsX21hc3RlciA6IG1peHBhbmVsX21hc3RlcltuYW1lXTtcblxuICAgIGlmICh0YXJnZXQgJiYgaW5pdF90eXBlID09PSBJTklUX01PRFVMRSkge1xuICAgICAgICBpbnN0YW5jZSA9IHRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGFyZ2V0ICYmICFfLmlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICAgICAgY29uc29sZSQxLmVycm9yKCdZb3UgaGF2ZSBhbHJlYWR5IGluaXRpYWxpemVkICcgKyBuYW1lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZSA9IG5ldyBNaXhwYW5lbExpYigpO1xuICAgIH1cblxuICAgIGluc3RhbmNlLl9jYWNoZWRfZ3JvdXBzID0ge307IC8vIGNhY2hlIGdyb3VwcyBpbiBhIHBvb2xcblxuICAgIGluc3RhbmNlLl9pbml0KHRva2VuLCBjb25maWcsIG5hbWUpO1xuXG4gICAgaW5zdGFuY2VbJ3Blb3BsZSddID0gbmV3IE1peHBhbmVsUGVvcGxlKCk7XG4gICAgaW5zdGFuY2VbJ3Blb3BsZSddLl9pbml0KGluc3RhbmNlKTtcblxuICAgIGlmICghaW5zdGFuY2UuZ2V0X2NvbmZpZygnc2tpcF9maXJzdF90b3VjaF9tYXJrZXRpbmcnKSkge1xuICAgICAgICAvLyBXZSBuZWVkIG51bGwgVVRNIHBhcmFtcyBpbiB0aGUgb2JqZWN0IGJlY2F1c2VcbiAgICAgICAgLy8gVVRNIHBhcmFtZXRlcnMgYWN0IGFzIGEgdHVwbGUuIElmIGFueSBVVE0gcGFyYW1cbiAgICAgICAgLy8gaXMgcHJlc2VudCwgdGhlbiB3ZSBzZXQgYWxsIFVUTSBwYXJhbXMgaW5jbHVkaW5nXG4gICAgICAgIC8vIGVtcHR5IG9uZXMgdG9nZXRoZXJcbiAgICAgICAgdmFyIHV0bV9wYXJhbXMgPSBfLmluZm8uY2FtcGFpZ25QYXJhbXMobnVsbCk7XG4gICAgICAgIHZhciBpbml0aWFsX3V0bV9wYXJhbXMgPSB7fTtcbiAgICAgICAgdmFyIGhhc191dG0gPSBmYWxzZTtcbiAgICAgICAgXy5lYWNoKHV0bV9wYXJhbXMsIGZ1bmN0aW9uKHV0bV92YWx1ZSwgdXRtX2tleSkge1xuICAgICAgICAgICAgaW5pdGlhbF91dG1fcGFyYW1zWydpbml0aWFsXycgKyB1dG1fa2V5XSA9IHV0bV92YWx1ZTtcbiAgICAgICAgICAgIGlmICh1dG1fdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBoYXNfdXRtID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChoYXNfdXRtKSB7XG4gICAgICAgICAgICBpbnN0YW5jZVsncGVvcGxlJ10uc2V0X29uY2UoaW5pdGlhbF91dG1fcGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIGFueSBpbnN0YW5jZSBvbiB0aGUgcGFnZSBoYXMgZGVidWcgPSB0cnVlLCB3ZSBzZXQgdGhlXG4gICAgLy8gZ2xvYmFsIGRlYnVnIHRvIGJlIHRydWVcbiAgICBDb25maWcuREVCVUcgPSBDb25maWcuREVCVUcgfHwgaW5zdGFuY2UuZ2V0X2NvbmZpZygnZGVidWcnKTtcblxuICAgIC8vIGlmIHRhcmdldCBpcyBub3QgZGVmaW5lZCwgd2UgY2FsbGVkIGluaXQgYWZ0ZXIgdGhlIGxpYiBhbHJlYWR5XG4gICAgLy8gbG9hZGVkLCBzbyB0aGVyZSB3b24ndCBiZSBhbiBhcnJheSBvZiB0aGluZ3MgdG8gZXhlY3V0ZVxuICAgIGlmICghXy5pc1VuZGVmaW5lZCh0YXJnZXQpICYmIF8uaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgIC8vIENydW5jaCB0aHJvdWdoIHRoZSBwZW9wbGUgcXVldWUgZmlyc3QgLSB3ZSBxdWV1ZSB0aGlzIGRhdGEgdXAgJlxuICAgICAgICAvLyBmbHVzaCBvbiBpZGVudGlmeSwgc28gaXQncyBiZXR0ZXIgdG8gZG8gYWxsIHRoZXNlIG9wZXJhdGlvbnMgZmlyc3RcbiAgICAgICAgaW5zdGFuY2UuX2V4ZWN1dGVfYXJyYXkuY2FsbChpbnN0YW5jZVsncGVvcGxlJ10sIHRhcmdldFsncGVvcGxlJ10pO1xuICAgICAgICBpbnN0YW5jZS5fZXhlY3V0ZV9hcnJheSh0YXJnZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbn07XG5cbi8vIEluaXRpYWxpemF0aW9uIG1ldGhvZHNcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBNaXhwYW5lbCB0cmFja2luZyBvYmplY3QuXG4gKiBBbGwgbmV3IGluc3RhbmNlcyBhcmUgYWRkZWQgdG8gdGhlIG1haW4gbWl4cGFuZWwgb2JqZWN0IGFzIHN1YiBwcm9wZXJ0aWVzIChzdWNoIGFzXG4gKiBtaXhwYW5lbC5saWJyYXJ5X25hbWUpIGFuZCBhbHNvIHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb24uIFRvIGRlZmluZSBhXG4gKiBzZWNvbmQgaW5zdGFuY2Ugb24gdGhlIHBhZ2UsIHlvdSB3b3VsZCBjYWxsOlxuICpcbiAqICAgICBtaXhwYW5lbC5pbml0KCduZXcgdG9rZW4nLCB7IHlvdXI6ICdjb25maWcnIH0sICdsaWJyYXJ5X25hbWUnKTtcbiAqXG4gKiBhbmQgdXNlIGl0IGxpa2Ugc286XG4gKlxuICogICAgIG1peHBhbmVsLmxpYnJhcnlfbmFtZS50cmFjayguLi4pO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlbiAgIFlvdXIgTWl4cGFuZWwgQVBJIHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gIEEgZGljdGlvbmFyeSBvZiBjb25maWcgb3B0aW9ucyB0byBvdmVycmlkZS4gPGEgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9taXhwYW5lbC9taXhwYW5lbC1qcy9ibG9iL3YyLjQ2LjAvc3JjL21peHBhbmVsLWNvcmUuanMjTDg4LUwxMjdcIj5TZWUgYSBsaXN0IG9mIGRlZmF1bHQgY29uZmlnIG9wdGlvbnM8L2E+LlxuICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lXSAgICBUaGUgbmFtZSBmb3IgdGhlIG5ldyBtaXhwYW5lbCBpbnN0YW5jZSB0aGF0IHlvdSB3YW50IGNyZWF0ZWRcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAodG9rZW4sIGNvbmZpZywgbmFtZSkge1xuICAgIGlmIChfLmlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdZb3UgbXVzdCBuYW1lIHlvdXIgbmV3IGxpYnJhcnk6IGluaXQodG9rZW4sIGNvbmZpZywgbmFtZSknKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gUFJJTUFSWV9JTlNUQU5DRV9OQU1FKSB7XG4gICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdZb3UgbXVzdCBpbml0aWFsaXplIHRoZSBtYWluIG1peHBhbmVsIG9iamVjdCByaWdodCBhZnRlciB5b3UgaW5jbHVkZSB0aGUgTWl4cGFuZWwganMgc25pcHBldCcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlID0gY3JlYXRlX21wbGliKHRva2VuLCBjb25maWcsIG5hbWUpO1xuICAgIG1peHBhbmVsX21hc3RlcltuYW1lXSA9IGluc3RhbmNlO1xuICAgIGluc3RhbmNlLl9sb2FkZWQoKTtcblxuICAgIHJldHVybiBpbnN0YW5jZTtcbn07XG5cbi8vIG1peHBhbmVsLl9pbml0KHRva2VuOnN0cmluZywgY29uZmlnOm9iamVjdCwgbmFtZTpzdHJpbmcpXG4vL1xuLy8gVGhpcyBmdW5jdGlvbiBzZXRzIHVwIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIHRoZSBtaXhwYW5lbFxuLy8gbGlicmFyeS4gIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhpcyBtZXRob2QgYW5kIHRoZSBpbml0KC4uLilcbi8vIG1ldGhvZCBpcyB0aGlzIG9uZSBpbml0aWFsaXplcyB0aGUgYWN0dWFsIGluc3RhbmNlLCB3aGVyZWFzIHRoZVxuLy8gaW5pdCguLi4pIG1ldGhvZCBzZXRzIHVwIGEgbmV3IGxpYnJhcnkgYW5kIGNhbGxzIF9pbml0IG9uIGl0LlxuLy9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKHRva2VuLCBjb25maWcsIG5hbWUpIHtcbiAgICBjb25maWcgPSBjb25maWcgfHwge307XG5cbiAgICB0aGlzWydfX2xvYWRlZCddID0gdHJ1ZTtcbiAgICB0aGlzWydjb25maWcnXSA9IHt9O1xuXG4gICAgdmFyIHZhcmlhYmxlX2ZlYXR1cmVzID0ge307XG5cbiAgICAvLyBkZWZhdWx0IHRvIEpTT04gcGF5bG9hZCBmb3Igc3RhbmRhcmQgbWl4cGFuZWwuY29tIEFQSSBob3N0c1xuICAgIGlmICghKCdhcGlfcGF5bG9hZF9mb3JtYXQnIGluIGNvbmZpZykpIHtcbiAgICAgICAgdmFyIGFwaV9ob3N0ID0gY29uZmlnWydhcGlfaG9zdCddIHx8IERFRkFVTFRfQ09ORklHWydhcGlfaG9zdCddO1xuICAgICAgICBpZiAoYXBpX2hvc3QubWF0Y2goL1xcLm1peHBhbmVsXFwuY29tLykpIHtcbiAgICAgICAgICAgIHZhcmlhYmxlX2ZlYXR1cmVzWydhcGlfcGF5bG9hZF9mb3JtYXQnXSA9IFBBWUxPQURfVFlQRV9KU09OO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZXRfY29uZmlnKF8uZXh0ZW5kKHt9LCBERUZBVUxUX0NPTkZJRywgdmFyaWFibGVfZmVhdHVyZXMsIGNvbmZpZywge1xuICAgICAgICAnbmFtZSc6IG5hbWUsXG4gICAgICAgICd0b2tlbic6IHRva2VuLFxuICAgICAgICAnY2FsbGJhY2tfZm4nOiAoKG5hbWUgPT09IFBSSU1BUllfSU5TVEFOQ0VfTkFNRSkgPyBuYW1lIDogUFJJTUFSWV9JTlNUQU5DRV9OQU1FICsgJy4nICsgbmFtZSkgKyAnLl9qc2MnXG4gICAgfSkpO1xuXG4gICAgdGhpc1snX2pzYyddID0gTk9PUF9GVU5DO1xuXG4gICAgdGhpcy5fX2RvbV9sb2FkZWRfcXVldWUgPSBbXTtcbiAgICB0aGlzLl9fcmVxdWVzdF9xdWV1ZSA9IFtdO1xuICAgIHRoaXMuX19kaXNhYmxlZF9ldmVudHMgPSBbXTtcbiAgICB0aGlzLl9mbGFncyA9IHtcbiAgICAgICAgJ2Rpc2FibGVfYWxsX2V2ZW50cyc6IGZhbHNlLFxuICAgICAgICAnaWRlbnRpZnlfY2FsbGVkJzogZmFsc2VcbiAgICB9O1xuXG4gICAgLy8gc2V0IHVwIHJlcXVlc3QgcXVldWVpbmcvYmF0Y2hpbmdcbiAgICB0aGlzLnJlcXVlc3RfYmF0Y2hlcnMgPSB7fTtcbiAgICB0aGlzLl9iYXRjaF9yZXF1ZXN0cyA9IHRoaXMuZ2V0X2NvbmZpZygnYmF0Y2hfcmVxdWVzdHMnKTtcbiAgICBpZiAodGhpcy5fYmF0Y2hfcmVxdWVzdHMpIHtcbiAgICAgICAgaWYgKCFfLmxvY2FsU3RvcmFnZS5pc19zdXBwb3J0ZWQodHJ1ZSkgfHwgIVVTRV9YSFIpIHtcbiAgICAgICAgICAgIHRoaXMuX2JhdGNoX3JlcXVlc3RzID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zb2xlJDEubG9nKCdUdXJuaW5nIG9mZiBNaXhwYW5lbCByZXF1ZXN0LXF1ZXVlaW5nOyBuZWVkcyBYSFIgYW5kIGxvY2FsU3RvcmFnZSBzdXBwb3J0Jyk7XG4gICAgICAgICAgICBfLmVhY2godGhpcy5nZXRfYmF0Y2hlcl9jb25maWdzKCksIGZ1bmN0aW9uKGJhdGNoZXJfY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZSQxLmxvZygnQ2xlYXJpbmcgYmF0Y2ggcXVldWUgJyArIGJhdGNoZXJfY29uZmlnLnF1ZXVlX2tleSk7XG4gICAgICAgICAgICAgICAgXy5sb2NhbFN0b3JhZ2UucmVtb3ZlKGJhdGNoZXJfY29uZmlnLnF1ZXVlX2tleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdF9iYXRjaGVycygpO1xuICAgICAgICAgICAgaWYgKHNlbmRCZWFjb24gJiYgd2luLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBCZWZvcmUgcGFnZSBjbG9zZXMgb3IgaGlkZXMgKHVzZXIgdGFicyBhd2F5IGV0YyksIGF0dGVtcHQgdG8gZmx1c2ggYW55IGV2ZW50c1xuICAgICAgICAgICAgICAgIC8vIHF1ZXVlZCB1cCB2aWEgbmF2aWdhdG9yLnNlbmRCZWFjb24uIFNpbmNlIHNlbmRCZWFjb24gZG9lc24ndCByZXBvcnQgc3VjY2Vzcy9mYWlsdXJlLFxuICAgICAgICAgICAgICAgIC8vIGV2ZW50cyB3aWxsIG5vdCBiZSByZW1vdmVkIGZyb20gdGhlIHBlcnNpc3RlbnQgc3RvcmU7IGlmIHRoZSBzaXRlIGlzIGxvYWRlZCBhZ2FpbixcbiAgICAgICAgICAgICAgICAvLyB0aGUgZXZlbnRzIHdpbGwgYmUgZmx1c2hlZCBhZ2FpbiBvbiBzdGFydHVwIGFuZCBkZWR1cGxpY2F0ZWQgb24gdGhlIE1peHBhbmVsIHNlcnZlclxuICAgICAgICAgICAgICAgIC8vIHNpZGUuXG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gcmVsaWFibGUgd2F5IHRvIGNhcHR1cmUgb25seSBwYWdlIGNsb3NlIGV2ZW50cywgc28gd2UgbGVhbiBvbiB0aGVcbiAgICAgICAgICAgICAgICAvLyB2aXNpYmlsaXR5Y2hhbmdlIGFuZCBwYWdlaGlkZSBldmVudHMgYXMgcmVjb21tZW5kZWQgYXRcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L3VubG9hZF9ldmVudCN1c2FnZV9ub3Rlcy5cbiAgICAgICAgICAgICAgICAvLyBUaGVzZSBldmVudHMgZmlyZSB3aGVuIHRoZSB1c2VyIGNsaWNrcyBhd2F5IGZyb20gdGhlIGN1cnJlbnQgcGFnZS90YWIsIHNvIHdpbGwgb2NjdXJcbiAgICAgICAgICAgICAgICAvLyBtb3JlIGZyZXF1ZW50bHkgdGhhbiBwYWdlIHVubG9hZCwgYnV0IGFyZSB0aGUgb25seSBtZWNoYW5pc20gY3VycmVudGx5IGZvciBjYXB0dXJpbmdcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHNjZW5hcmlvIHNvbWV3aGF0IHJlbGlhYmx5LlxuICAgICAgICAgICAgICAgIHZhciBmbHVzaF9vbl91bmxvYWQgPSBfLmJpbmQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5yZXF1ZXN0X2JhdGNoZXJzLmV2ZW50cy5zdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RfYmF0Y2hlcnMuZXZlbnRzLmZsdXNoKHt1bmxvYWRpbmc6IHRydWV9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldlsncGVyc2lzdGVkJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsdXNoX29uX3VubG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50JDFbJ3Zpc2liaWxpdHlTdGF0ZSddID09PSAnaGlkZGVuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmx1c2hfb25fdW5sb2FkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10gPSB0aGlzWydjb29raWUnXSA9IG5ldyBNaXhwYW5lbFBlcnNpc3RlbmNlKHRoaXNbJ2NvbmZpZyddKTtcbiAgICB0aGlzLnVucGVyc2lzdGVkX3N1cGVycHJvcHMgPSB7fTtcbiAgICB0aGlzLl9nZHByX2luaXQoKTtcblxuICAgIHZhciB1dWlkID0gXy5VVUlEKCk7XG4gICAgaWYgKCF0aGlzLmdldF9kaXN0aW5jdF9pZCgpKSB7XG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIG5lZWQgdG8gc2V0IHRoZSBkaXN0aW5jdCBpZFxuICAgICAgICAvLyBvciB0aGUgZGV2aWNlIGlkIGlmIHNvbWV0aGluZyB3YXMgYWxyZWFkeSBzdG9yZWRcbiAgICAgICAgLy8gaW4gdGhlIHBlcnNpdGVuY2VcbiAgICAgICAgdGhpcy5yZWdpc3Rlcl9vbmNlKHtcbiAgICAgICAgICAgICdkaXN0aW5jdF9pZCc6IERFVklDRV9JRF9QUkVGSVggKyB1dWlkLFxuICAgICAgICAgICAgJyRkZXZpY2VfaWQnOiB1dWlkXG4gICAgICAgIH0sICcnKTtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gbmV3IEZlYXR1cmVGbGFnTWFuYWdlcih7XG4gICAgICAgIGdldEZ1bGxBcGlSb3V0ZTogXy5iaW5kKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0X2FwaV9ob3N0KCdmbGFncycpICsgJy8nICsgdGhpcy5nZXRfY29uZmlnKCdhcGlfcm91dGVzJylbJ2ZsYWdzJ107XG4gICAgICAgIH0sIHRoaXMpLFxuICAgICAgICBnZXRDb25maWdGdW5jOiBfLmJpbmQodGhpcy5nZXRfY29uZmlnLCB0aGlzKSxcbiAgICAgICAgc2V0Q29uZmlnRnVuYzogXy5iaW5kKHRoaXMuc2V0X2NvbmZpZywgdGhpcyksXG4gICAgICAgIGdldFByb3BlcnR5RnVuYzogXy5iaW5kKHRoaXMuZ2V0X3Byb3BlcnR5LCB0aGlzKSxcbiAgICAgICAgdHJhY2tpbmdGdW5jOiBfLmJpbmQodGhpcy50cmFjaywgdGhpcylcbiAgICB9KTtcbiAgICB0aGlzLmZsYWdzLmluaXQoKTtcbiAgICB0aGlzWydmbGFncyddID0gdGhpcy5mbGFncztcblxuICAgIHRoaXMuYXV0b2NhcHR1cmUgPSBuZXcgQXV0b2NhcHR1cmUodGhpcyk7XG4gICAgdGhpcy5hdXRvY2FwdHVyZS5pbml0KCk7XG5cbiAgICB0aGlzLl9pbml0X3RhYl9pZCgpO1xuICAgIHRoaXMuX2NoZWNrX2FuZF9zdGFydF9zZXNzaW9uX3JlY29yZGluZygpO1xufTtcblxuLyoqXG4gKiBBc3NpZ25zIGEgdW5pcXVlIFVVSUQgdG8gdGhpcyB0YWIgLyB3aW5kb3cgYnkgbGV2ZXJhZ2luZyBzZXNzaW9uU3RvcmFnZS5cbiAqIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgZm9yIHNlc3Npb24gcmVjb3JkaW5nLCB3aGVyZSBkYXRhIG11c3QgYmUgaXNvbGF0ZWQgdG8gdGhlIGN1cnJlbnQgdGFiLlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2luaXRfdGFiX2lkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygnZGlzYWJsZV9wZXJzaXN0ZW5jZScpKSB7XG4gICAgICAgIGNvbnNvbGUkMS5sb2coJ1RhYiBJRCBpbml0aWFsaXphdGlvbiBza2lwcGVkIGR1ZSB0byBkaXNhYmxlX3BlcnNpc3RlbmNlIGNvbmZpZycpO1xuICAgIH0gZWxzZSBpZiAoXy5zZXNzaW9uU3RvcmFnZS5pc19zdXBwb3J0ZWQoKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGtleV9zdWZmaXggPSB0aGlzLmdldF9jb25maWcoJ25hbWUnKSArICdfJyArIHRoaXMuZ2V0X2NvbmZpZygndG9rZW4nKTtcbiAgICAgICAgICAgIHZhciB0YWJfaWRfa2V5ID0gJ21wX3RhYl9pZF8nICsga2V5X3N1ZmZpeDtcblxuICAgICAgICAgICAgLy8gQSBmbGFnIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHNlc3Npb25TdG9yYWdlIGlzIGNvcGllZCBvdmVyIGFuZCB3ZSBuZWVkIHRvIGdlbmVyYXRlIGEgbmV3IHRhYiBJRC5cbiAgICAgICAgICAgIC8vIFRoaXMgZW5mb3JjZXMgYSB1bmlxdWUgSUQgaW4gdGhlIGNhc2VzIGxpa2UgZHVwbGljYXRlZCB0YWIsIHdpbmRvdy5vcGVuKC4uLilcbiAgICAgICAgICAgIHZhciBzaG91bGRfZ2VuZXJhdGVfbmV3X3RhYl9pZF9rZXkgPSAnbXBfZ2VuX25ld190YWJfaWRfJyArIGtleV9zdWZmaXg7XG4gICAgICAgICAgICBpZiAoXy5zZXNzaW9uU3RvcmFnZS5nZXQoc2hvdWxkX2dlbmVyYXRlX25ld190YWJfaWRfa2V5KSB8fCAhXy5zZXNzaW9uU3RvcmFnZS5nZXQodGFiX2lkX2tleSkpIHtcbiAgICAgICAgICAgICAgICBfLnNlc3Npb25TdG9yYWdlLnNldCh0YWJfaWRfa2V5LCAnJHRhYi0nICsgXy5VVUlEKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfLnNlc3Npb25TdG9yYWdlLnNldChzaG91bGRfZ2VuZXJhdGVfbmV3X3RhYl9pZF9rZXksICcxJyk7XG4gICAgICAgICAgICB0aGlzLnRhYl9pZCA9IF8uc2Vzc2lvblN0b3JhZ2UuZ2V0KHRhYl9pZF9rZXkpO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGZsYWcgd2hlbiB0aGUgdGFiIGlzIHVubG9hZGVkIHRvIGluZGljYXRlIHRoZSBzdG9yZWQgdGFiIElEIGNhbiBiZSByZXVzZWQuIFRoaXMgZXZlbnQgaXMgbm90IHJlbGlhYmxlIHRvIGRldGVjdCBhbGwgcGFnZSB1bmxvYWRzLFxuICAgICAgICAgICAgLy8gYnV0IHJlbGlhYmxlIGluIGNhc2VzIHdoZXJlIHRoZSB1c2VyIHJlbWFpbnMgaW4gdGhlIHRhYiBlLmcuIGEgcmVmcmVzaCBvciBocmVmIG5hdmlnYXRpb24uXG4gICAgICAgICAgICAvLyBJZiB0aGUgZmxhZyBpcyBhYnNlbnQsIHRoaXMgaW5kaWNhdGVzIHRvIHRoZSBuZXh0IFNESyBpbnN0YW5jZSB0aGF0IHdlIGNhbiByZXVzZSB0aGUgc3RvcmVkIHRhYl9pZC5cbiAgICAgICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgXy5zZXNzaW9uU3RvcmFnZS5yZW1vdmUoc2hvdWxkX2dlbmVyYXRlX25ld190YWJfaWRfa2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoJ0Vycm9yIGluaXRpYWxpemluZyB0YWIgaWQnLCBlcnIpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoJ1Nlc3Npb24gc3RvcmFnZSBpcyBub3Qgc3VwcG9ydGVkLCBjYW5ub3Qga2VlcCB0cmFjayBvZiB1bmlxdWUgdGFiIElELicpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfdGFiX2lkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnRhYl9pZCB8fCBudWxsO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9zaG91bGRfbG9hZF9yZWNvcmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5nZXRfY29uZmlnKCdkaXNhYmxlX3BlcnNpc3RlbmNlJykpIHtcbiAgICAgICAgY29uc29sZSQxLmxvZygnTG9hZCByZWNvcmRlciBjaGVjayBza2lwcGVkIGR1ZSB0byBkaXNhYmxlX3BlcnNpc3RlbmNlIGNvbmZpZycpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkaW5nX3JlZ2lzdHJ5X2lkYiA9IG5ldyBJREJTdG9yYWdlV3JhcHBlcihSRUNPUkRJTkdfUkVHSVNUUllfU1RPUkVfTkFNRSk7XG4gICAgdmFyIHRhYl9pZCA9IHRoaXMuZ2V0X3RhYl9pZCgpO1xuICAgIHJldHVybiByZWNvcmRpbmdfcmVnaXN0cnlfaWRiLmluaXQoKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkaW5nX3JlZ2lzdHJ5X2lkYi5nZXRBbGwoKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlY29yZGluZ3MpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjb3JkaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBleHBpcmVkIHJlY29yZGluZ3MgaW4gdGhlIHJlZ2lzdHJ5LCB3ZSBzaG91bGQgbG9hZCB0aGUgcmVjb3JkZXIgdG8gZmx1c2ggdGhlbVxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3MgYSByZWNvcmRpbmcgZm9yIHRoaXMgdGFiIGlkLCB3ZSBzaG91bGQgbG9hZCB0aGUgcmVjb3JkZXIgdG8gY29udGludWUgdGhlIHJlY29yZGluZ1xuICAgICAgICAgICAgICAgIGlmIChpc1JlY29yZGluZ0V4cGlyZWQocmVjb3JkaW5nc1tpXSkgfHwgcmVjb3JkaW5nc1tpXVsndGFiSWQnXSA9PT0gdGFiX2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydF9lcnJvcignRXJyb3IgY2hlY2tpbmcgcmVjb3JkaW5nIHJlZ2lzdHJ5JywgZXJyKTtcbiAgICAgICAgfSwgdGhpcykpO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9jaGVja19hbmRfc3RhcnRfc2Vzc2lvbl9yZWNvcmRpbmcgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliKGZ1bmN0aW9uKGZvcmNlX3N0YXJ0KSB7XG4gICAgaWYgKCF3aW5bJ011dGF0aW9uT2JzZXJ2ZXInXSkge1xuICAgICAgICBjb25zb2xlJDEuY3JpdGljYWwoJ0Jyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBNdXRhdGlvbk9ic2VydmVyOyBza2lwcGluZyBzZXNzaW9uIHJlY29yZGluZycpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGxvYWRSZWNvcmRlciA9IF8uYmluZChmdW5jdGlvbihzdGFydE5ld0lmSW5hY3RpdmUpIHtcbiAgICAgICAgdmFyIGhhbmRsZUxvYWRlZFJlY29yZGVyID0gXy5iaW5kKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fcmVjb3JkZXIgPSB0aGlzLl9yZWNvcmRlciB8fCBuZXcgd2luWydfX21wX3JlY29yZGVyJ10odGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9yZWNvcmRlclsncmVzdW1lUmVjb3JkaW5nJ10oc3RhcnROZXdJZkluYWN0aXZlKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQod2luWydfX21wX3JlY29yZGVyJ10pKSB7XG4gICAgICAgICAgICBsb2FkX2V4dHJhX2J1bmRsZSh0aGlzLmdldF9jb25maWcoJ3JlY29yZGVyX3NyYycpLCBoYW5kbGVMb2FkZWRSZWNvcmRlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVMb2FkZWRSZWNvcmRlcigpO1xuICAgICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgdXNlciBpcyBzYW1wbGVkIG9yIHN0YXJ0X3Nlc3Npb25fcmVjb3JkaW5nIGlzIGNhbGxlZCwgd2UgYWx3YXlzIGxvYWQgdGhlIHJlY29yZGVyIHNpbmNlIGl0J3MgZ3VhcmFudGVlZCBhIHJlY29yZGluZyBzaG91bGQgc3RhcnQuXG4gICAgICogT3RoZXJ3aXNlLCBpZiB0aGUgcmVjb3JkaW5nIHJlZ2lzdHJ5IGhhcyBhbnkgcmVjb3JkcyB0aGVuIGl0J3MgbGlrZWx5IHRoZXJlJ3MgYSByZWNvcmRpbmcgaW4gcHJvZ3Jlc3Mgb3Igb3JwaGFuZWQgZGF0YSB0aGF0IG5lZWRzIHRvIGJlIGZsdXNoZWQuXG4gICAgICovXG4gICAgdmFyIGlzX3NhbXBsZWQgPSB0aGlzLmdldF9jb25maWcoJ3JlY29yZF9zZXNzaW9uc19wZXJjZW50JykgPiAwICYmIE1hdGgucmFuZG9tKCkgKiAxMDAgPD0gdGhpcy5nZXRfY29uZmlnKCdyZWNvcmRfc2Vzc2lvbnNfcGVyY2VudCcpO1xuICAgIGlmIChmb3JjZV9zdGFydCB8fCBpc19zYW1wbGVkKSB7XG4gICAgICAgIGxvYWRSZWNvcmRlcih0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zaG91bGRfbG9hZF9yZWNvcmRlcigpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoc2hvdWxkTG9hZCkge1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRMb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRSZWNvcmRlcihmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5zdGFydF9zZXNzaW9uX3JlY29yZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jaGVja19hbmRfc3RhcnRfc2Vzc2lvbl9yZWNvcmRpbmcodHJ1ZSk7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuc3RvcF9zZXNzaW9uX3JlY29yZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVjb3JkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlY29yZGVyWydzdG9wUmVjb3JkaW5nJ10oKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLnBhdXNlX3Nlc3Npb25fcmVjb3JkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWNvcmRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVjb3JkZXJbJ3BhdXNlUmVjb3JkaW5nJ10oKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlc3VtZV9zZXNzaW9uX3JlY29yZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVjb3JkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlY29yZGVyWydyZXN1bWVSZWNvcmRpbmcnXSgpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuaXNfcmVjb3JkaW5nX2hlYXRtYXBfZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0X3Nlc3Npb25fcmVwbGF5X2lkKCkgJiYgdGhpcy5nZXRfY29uZmlnKCdyZWNvcmRfaGVhdG1hcF9kYXRhJyk7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X3Nlc3Npb25fcmVjb3JkaW5nX3Byb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIHJlcGxheV9pZCA9IHRoaXMuX2dldF9zZXNzaW9uX3JlcGxheV9pZCgpO1xuICAgIGlmIChyZXBsYXlfaWQpIHtcbiAgICAgICAgcHJvcHNbJyRtcF9yZXBsYXlfaWQnXSA9IHJlcGxheV9pZDtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BzO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9zZXNzaW9uX3JlcGxheV91cmwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlcGxheV91cmwgPSBudWxsO1xuICAgIHZhciByZXBsYXlfaWQgPSB0aGlzLl9nZXRfc2Vzc2lvbl9yZXBsYXlfaWQoKTtcbiAgICBpZiAocmVwbGF5X2lkKSB7XG4gICAgICAgIHZhciBxdWVyeV9wYXJhbXMgPSBfLkhUVFBCdWlsZFF1ZXJ5KHtcbiAgICAgICAgICAgICdyZXBsYXlfaWQnOiByZXBsYXlfaWQsXG4gICAgICAgICAgICAnZGlzdGluY3RfaWQnOiB0aGlzLmdldF9kaXN0aW5jdF9pZCgpLFxuICAgICAgICAgICAgJ3Rva2VuJzogdGhpcy5nZXRfY29uZmlnKCd0b2tlbicpXG4gICAgICAgIH0pO1xuICAgICAgICByZXBsYXlfdXJsID0gJ2h0dHBzOi8vbWl4cGFuZWwuY29tL3Byb2plY3RzL3JlcGxheS1yZWRpcmVjdD8nICsgcXVlcnlfcGFyYW1zO1xuICAgIH1cbiAgICByZXR1cm4gcmVwbGF5X3VybDtcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fZ2V0X3Nlc3Npb25fcmVwbGF5X2lkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXBsYXlfaWQgPSBudWxsO1xuICAgIGlmICh0aGlzLl9yZWNvcmRlcikge1xuICAgICAgICByZXBsYXlfaWQgPSB0aGlzLl9yZWNvcmRlclsncmVwbGF5SWQnXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcGxheV9pZCB8fCBudWxsO1xufTtcblxuLy8gXCJwcml2YXRlXCIgcHVibGljIG1ldGhvZCB0byByZWFjaCBpbnRvIHRoZSByZWNvcmRlciBpbiB0ZXN0IGNhc2VzXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX19nZXRfcmVjb3JkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlY29yZGVyO1xufTtcblxuLy8gUHJpdmF0ZSBtZXRob2RzXG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fbG9hZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5nZXRfY29uZmlnKCdsb2FkZWQnKSh0aGlzKTtcbiAgICB0aGlzLl9zZXRfZGVmYXVsdF9zdXBlcnByb3BzKCk7XG4gICAgdGhpc1sncGVvcGxlJ10uc2V0X29uY2UodGhpc1sncGVyc2lzdGVuY2UnXS5nZXRfcmVmZXJyZXJfaW5mbygpKTtcblxuICAgIC8vIGBzdG9yZV9nb29nbGVgIGlzIG5vdyBkZXByZWNhdGVkIGFuZCBwcmV2aW91c2x5IHN0b3JlZCBVVE0gcGFyYW1ldGVycyBhcmUgY2xlYXJlZFxuICAgIC8vIGZyb20gcGVyc2lzdGVuY2UgYnkgZGVmYXVsdC5cbiAgICBpZiAodGhpcy5nZXRfY29uZmlnKCdzdG9yZV9nb29nbGUnKSAmJiB0aGlzLmdldF9jb25maWcoJ3N0b3BfdXRtX3BlcnNpc3RlbmNlJykpIHtcbiAgICAgICAgdmFyIHV0bV9wYXJhbXMgPSBfLmluZm8uY2FtcGFpZ25QYXJhbXMobnVsbCk7XG4gICAgICAgIF8uZWFjaCh1dG1fcGFyYW1zLCBmdW5jdGlvbihfdXRtX3ZhbHVlLCB1dG1fa2V5KSB7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHVucmVnaXN0ZXIgcGVyc2lzdGVkIFVUTSBwYXJhbWV0ZXJzIHNvIG9sZCB2YWx1ZXNcbiAgICAgICAgICAgIC8vIGFyZSBub3QgbWl4ZWQgd2l0aCB0aGUgbmV3IFVUTSBwYXJhbWV0ZXJzXG4gICAgICAgICAgICB0aGlzLnVucmVnaXN0ZXIodXRtX2tleSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfVxufTtcblxuLy8gdXBkYXRlIHBlcnNpc3RlbmNlIHdpdGggaW5mbyBvbiByZWZlcnJlciwgVVRNIHBhcmFtcywgZXRjXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX3NldF9kZWZhdWx0X3N1cGVycHJvcHMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnVwZGF0ZV9zZWFyY2hfa2V5d29yZChkb2N1bWVudCQxLnJlZmVycmVyKTtcbiAgICAvLyBSZWdpc3RlcmluZyBzdXBlciBwcm9wZXJ0aWVzIGZvciBVVE0gcGVyc2lzdGVuY2UgYnkgJ3N0b3JlX2dvb2dsZScgaXMgZGVwcmVjYXRlZC5cbiAgICBpZiAodGhpcy5nZXRfY29uZmlnKCdzdG9yZV9nb29nbGUnKSAmJiAhdGhpcy5nZXRfY29uZmlnKCdzdG9wX3V0bV9wZXJzaXN0ZW5jZScpKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoXy5pbmZvLmNhbXBhaWduUGFyYW1zKCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5nZXRfY29uZmlnKCdzYXZlX3JlZmVycmVyJykpIHtcbiAgICAgICAgdGhpc1sncGVyc2lzdGVuY2UnXS51cGRhdGVfcmVmZXJyZXJfaW5mbyhkb2N1bWVudCQxLnJlZmVycmVyKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2RvbV9sb2FkZWQgPSBmdW5jdGlvbigpIHtcbiAgICBfLmVhY2godGhpcy5fX2RvbV9sb2FkZWRfcXVldWUsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5fdHJhY2tfZG9tLmFwcGx5KHRoaXMsIGl0ZW0pO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgaWYgKCF0aGlzLmhhc19vcHRlZF9vdXRfdHJhY2tpbmcoKSkge1xuICAgICAgICBfLmVhY2godGhpcy5fX3JlcXVlc3RfcXVldWUsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRfcmVxdWVzdC5hcHBseSh0aGlzLCBpdGVtKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuXG4gICAgZGVsZXRlIHRoaXMuX19kb21fbG9hZGVkX3F1ZXVlO1xuICAgIGRlbGV0ZSB0aGlzLl9fcmVxdWVzdF9xdWV1ZTtcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fdHJhY2tfZG9tID0gZnVuY3Rpb24oRG9tQ2xhc3MsIGFyZ3MpIHtcbiAgICBpZiAodGhpcy5nZXRfY29uZmlnKCdpbWcnKSkge1xuICAgICAgICB0aGlzLnJlcG9ydF9lcnJvcignWW91IGNhblxcJ3QgdXNlIERPTSB0cmFja2luZyBmdW5jdGlvbnMgd2l0aCBpbWcgPSB0cnVlLicpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFET01fTE9BREVEKSB7XG4gICAgICAgIHRoaXMuX19kb21fbG9hZGVkX3F1ZXVlLnB1c2goW0RvbUNsYXNzLCBhcmdzXSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZHQgPSBuZXcgRG9tQ2xhc3MoKS5pbml0KHRoaXMpO1xuICAgIHJldHVybiBkdC50cmFjay5hcHBseShkdCwgYXJncyk7XG59O1xuXG4vKipcbiAqIF9wcmVwYXJlX2NhbGxiYWNrKCkgc2hvdWxkIGJlIGNhbGxlZCBieSBjYWxsZXJzIG9mIF9zZW5kX3JlcXVlc3QgZm9yIHVzZVxuICogYXMgdGhlIGNhbGxiYWNrIGFyZ3VtZW50LlxuICpcbiAqIElmIHRoZXJlIGlzIG5vIGNhbGxiYWNrLCB0aGlzIHJldHVybnMgbnVsbC5cbiAqIElmIHdlIGFyZSBnb2luZyB0byBtYWtlIFhIUi9YRFIgcmVxdWVzdHMsIHRoaXMgcmV0dXJucyBhIGZ1bmN0aW9uLlxuICogSWYgd2UgYXJlIGdvaW5nIHRvIHVzZSBzY3JpcHQgdGFncywgdGhpcyByZXR1cm5zIGEgc3RyaW5nIHRvIHVzZSBhcyB0aGVcbiAqIGNhbGxiYWNrIEdFVCBwYXJhbS5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9wcmVwYXJlX2NhbGxiYWNrID0gZnVuY3Rpb24oY2FsbGJhY2ssIGRhdGEpIHtcbiAgICBpZiAoXy5pc1VuZGVmaW5lZChjYWxsYmFjaykpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKFVTRV9YSFIpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrX2Z1bmN0aW9uID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlLCBkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrX2Z1bmN0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIHRoZSB1c2VyIGdpdmVzIHVzIGEgY2FsbGJhY2ssIHdlIHN0b3JlIGFzIGEgcmFuZG9tXG4gICAgICAgIC8vIHByb3BlcnR5IG9uIHRoaXMgaW5zdGFuY2VzIGpzYyBmdW5jdGlvbiBhbmQgdXBkYXRlIG91clxuICAgICAgICAvLyBjYWxsYmFjayBzdHJpbmcgdG8gcmVmbGVjdCB0aGF0LlxuICAgICAgICB2YXIganNjID0gdGhpc1snX2pzYyddO1xuICAgICAgICB2YXIgcmFuZG9taXplZF9jYiA9ICcnICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMDAwKTtcbiAgICAgICAgdmFyIGNhbGxiYWNrX3N0cmluZyA9IHRoaXMuZ2V0X2NvbmZpZygnY2FsbGJhY2tfZm4nKSArICdbJyArIHJhbmRvbWl6ZWRfY2IgKyAnXSc7XG4gICAgICAgIGpzY1tyYW5kb21pemVkX2NiXSA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBkZWxldGUganNjW3JhbmRvbWl6ZWRfY2JdO1xuICAgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2UsIGRhdGEpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2FsbGJhY2tfc3RyaW5nO1xuICAgIH1cbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fc2VuZF9yZXF1ZXN0ID0gZnVuY3Rpb24odXJsLCBkYXRhLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHZhciBzdWNjZWVkZWQgPSB0cnVlO1xuXG4gICAgaWYgKEVOUVVFVUVfUkVRVUVTVFMpIHtcbiAgICAgICAgdGhpcy5fX3JlcXVlc3RfcXVldWUucHVzaChhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gc3VjY2VlZGVkO1xuICAgIH1cblxuICAgIHZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgICAgIG1ldGhvZDogdGhpcy5nZXRfY29uZmlnKCdhcGlfbWV0aG9kJyksXG4gICAgICAgIHRyYW5zcG9ydDogdGhpcy5nZXRfY29uZmlnKCdhcGlfdHJhbnNwb3J0JyksXG4gICAgICAgIHZlcmJvc2U6IHRoaXMuZ2V0X2NvbmZpZygndmVyYm9zZScpXG4gICAgfTtcbiAgICB2YXIgYm9keV9kYXRhID0gbnVsbDtcblxuICAgIGlmICghY2FsbGJhY2sgJiYgKF8uaXNGdW5jdGlvbihvcHRpb25zKSB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBfLmV4dGVuZChERUZBVUxUX09QVElPTlMsIG9wdGlvbnMgfHwge30pO1xuICAgIGlmICghVVNFX1hIUikge1xuICAgICAgICBvcHRpb25zLm1ldGhvZCA9ICdHRVQnO1xuICAgIH1cbiAgICB2YXIgdXNlX3Bvc3QgPSBvcHRpb25zLm1ldGhvZCA9PT0gJ1BPU1QnO1xuICAgIHZhciB1c2Vfc2VuZEJlYWNvbiA9IHNlbmRCZWFjb24gJiYgdXNlX3Bvc3QgJiYgb3B0aW9ucy50cmFuc3BvcnQudG9Mb3dlckNhc2UoKSA9PT0gJ3NlbmRiZWFjb24nO1xuXG4gICAgLy8gbmVlZGVkIHRvIGNvcnJlY3RseSBmb3JtYXQgcmVzcG9uc2VzXG4gICAgdmFyIHZlcmJvc2VfbW9kZSA9IG9wdGlvbnMudmVyYm9zZTtcbiAgICBpZiAoZGF0YVsndmVyYm9zZSddKSB7IHZlcmJvc2VfbW9kZSA9IHRydWU7IH1cblxuICAgIGlmICh0aGlzLmdldF9jb25maWcoJ3Rlc3QnKSkgeyBkYXRhWyd0ZXN0J10gPSAxOyB9XG4gICAgaWYgKHZlcmJvc2VfbW9kZSkgeyBkYXRhWyd2ZXJib3NlJ10gPSAxOyB9XG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygnaW1nJykpIHsgZGF0YVsnaW1nJ10gPSAxOyB9XG4gICAgaWYgKCFVU0VfWEhSKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgZGF0YVsnY2FsbGJhY2snXSA9IGNhbGxiYWNrO1xuICAgICAgICB9IGVsc2UgaWYgKHZlcmJvc2VfbW9kZSB8fCB0aGlzLmdldF9jb25maWcoJ3Rlc3QnKSkge1xuICAgICAgICAgICAgLy8gVmVyYm9zZSBvdXRwdXQgKGZyb20gdmVyYm9zZSBtb2RlLCBvciBhbiBlcnJvciBpbiB0ZXN0IG1vZGUpIGlzIGEganNvbiBibG9iLFxuICAgICAgICAgICAgLy8gd2hpY2ggYnkgaXRzZWxmIGlzIG5vdCB2YWxpZCBqYXZhc2NyaXB0LiBXaXRob3V0IGEgY2FsbGJhY2ssIHRoaXMgdmVyYm9zZSBvdXRwdXQgd2lsbFxuICAgICAgICAgICAgLy8gY2F1c2UgYW4gZXJyb3Igd2hlbiByZXR1cm5lZCB2aWEganNvbnAsIHNvIHdlIGZvcmNlIGEgbm8tb3AgY2FsbGJhY2sgcGFyYW0uXG4gICAgICAgICAgICAvLyBTZWUgdGhlIEVDTUEgc2NyaXB0IHNwZWM6IGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi81LjEvI3NlYy0xMi40XG4gICAgICAgICAgICBkYXRhWydjYWxsYmFjayddID0gJyhmdW5jdGlvbigpe30pJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRhdGFbJ2lwJ10gPSB0aGlzLmdldF9jb25maWcoJ2lwJyk/MTowO1xuICAgIGRhdGFbJ18nXSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAodXNlX3Bvc3QpIHtcbiAgICAgICAgYm9keV9kYXRhID0gJ2RhdGE9JyArIGVuY29kZVVSSUNvbXBvbmVudChkYXRhWydkYXRhJ10pO1xuICAgICAgICBkZWxldGUgZGF0YVsnZGF0YSddO1xuICAgIH1cblxuICAgIF8uZXh0ZW5kKGRhdGEsIHRoaXMuZ2V0X2NvbmZpZygnYXBpX2V4dHJhX3F1ZXJ5X3BhcmFtcycpKTtcblxuICAgIHVybCArPSAnPycgKyBfLkhUVFBCdWlsZFF1ZXJ5KGRhdGEpO1xuXG4gICAgdmFyIGxpYiA9IHRoaXM7XG4gICAgaWYgKCdpbWcnIGluIGRhdGEpIHtcbiAgICAgICAgdmFyIGltZyA9IGRvY3VtZW50JDEuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgIGltZy5zcmMgPSB1cmw7XG4gICAgICAgIGRvY3VtZW50JDEuYm9keS5hcHBlbmRDaGlsZChpbWcpO1xuICAgIH0gZWxzZSBpZiAodXNlX3NlbmRCZWFjb24pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN1Y2NlZWRlZCA9IHNlbmRCZWFjb24odXJsLCBib2R5X2RhdGEpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsaWIucmVwb3J0X2Vycm9yKGUpO1xuICAgICAgICAgICAgc3VjY2VlZGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHN1Y2NlZWRlZCA/IDEgOiAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbGliLnJlcG9ydF9lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoVVNFX1hIUikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgcmVxLm9wZW4ob3B0aW9ucy5tZXRob2QsIHVybCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHZhciBoZWFkZXJzID0gdGhpcy5nZXRfY29uZmlnKCd4aHJfaGVhZGVycycpO1xuICAgICAgICAgICAgaWYgKHVzZV9wb3N0KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF8uZWFjaChoZWFkZXJzLCBmdW5jdGlvbihoZWFkZXJWYWx1ZSwgaGVhZGVyTmFtZSkge1xuICAgICAgICAgICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlck5hbWUsIGhlYWRlclZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy50aW1lb3V0X21zICYmIHR5cGVvZiByZXEudGltZW91dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXEudGltZW91dCA9IG9wdGlvbnMudGltZW91dF9tcztcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRfdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZW5kIHRoZSBtcF9vcHRvdXQgY29va2llXG4gICAgICAgICAgICAvLyB3aXRoQ3JlZGVudGlhbHMgY2Fubm90IGJlIG1vZGlmaWVkIHVudGlsIGFmdGVyIGNhbGxpbmcgLm9wZW4gb24gQW5kcm9pZCBhbmQgTW9iaWxlIFNhZmFyaVxuICAgICAgICAgICAgcmVxLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICAgICAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXEucmVhZHlTdGF0ZSA9PT0gNCkgeyAvLyBYTUxIdHRwUmVxdWVzdC5ET05FID09IDQsIGV4Y2VwdCBpbiBzYWZhcmkgNFxuICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmVyYm9zZV9tb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gXy5KU09ORGVjb2RlKHJlcS5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaWIucmVwb3J0X2Vycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaWdub3JlX2pzb25fZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSByZXEucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKE51bWJlcihyZXEucmVzcG9uc2VUZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS50aW1lb3V0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIXJlcS5zdGF0dXMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0X3RpbWUgPj0gcmVxLnRpbWVvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gJ3RpbWVvdXQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9ICdCYWQgSFRUUCBzdGF0dXM6ICcgKyByZXEuc3RhdHVzICsgJyAnICsgcmVxLnN0YXR1c1RleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaWIucmVwb3J0X2Vycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlX21vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlX2hlYWRlcnMgPSByZXFbJ3Jlc3BvbnNlSGVhZGVycyddIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh7c3RhdHVzOiAwLCBodHRwU3RhdHVzQ29kZTogcmVxWydzdGF0dXMnXSwgZXJyb3I6IGVycm9yLCByZXRyeUFmdGVyOiByZXNwb25zZV9oZWFkZXJzWydSZXRyeS1BZnRlciddfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlcS5zZW5kKGJvZHlfZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxpYi5yZXBvcnRfZXJyb3IoZSk7XG4gICAgICAgICAgICBzdWNjZWVkZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudCQxLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICAgICAgICBzY3JpcHQuZGVmZXIgPSB0cnVlO1xuICAgICAgICBzY3JpcHQuc3JjID0gdXJsO1xuICAgICAgICB2YXIgcyA9IGRvY3VtZW50JDEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdO1xuICAgICAgICBzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1Y2NlZWRlZDtcbn07XG5cbi8qKlxuICogX2V4ZWN1dGVfYXJyYXkoKSBkZWFscyB3aXRoIHByb2Nlc3NpbmcgYW55IG1peHBhbmVsIGZ1bmN0aW9uXG4gKiBjYWxscyB0aGF0IHdlcmUgY2FsbGVkIGJlZm9yZSB0aGUgTWl4cGFuZWwgbGlicmFyeSB3ZXJlIGxvYWRlZFxuICogKGFuZCBhcmUgdGh1cyBzdG9yZWQgaW4gYW4gYXJyYXkgc28gdGhleSBjYW4gYmUgY2FsbGVkIGxhdGVyKVxuICpcbiAqIE5vdGU6IHdlIGZpcmUgb2ZmIGFsbCB0aGUgbWl4cGFuZWwgZnVuY3Rpb24gY2FsbHMgJiYgdXNlciBkZWZpbmVkXG4gKiBmdW5jdGlvbnMgQkVGT1JFIHdlIGZpcmUgb2ZmIG1peHBhbmVsIHRyYWNraW5nIGNhbGxzLiBUaGlzIGlzIHNvXG4gKiBpZGVudGlmeS9yZWdpc3Rlci9zZXRfY29uZmlnIGNhbGxzIGNhbiBwcm9wZXJseSBtb2RpZnkgZWFybHlcbiAqIHRyYWNraW5nIGNhbGxzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fZXhlY3V0ZV9hcnJheSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIGZuX25hbWUsIGFsaWFzX2NhbGxzID0gW10sIG90aGVyX2NhbGxzID0gW10sIHRyYWNraW5nX2NhbGxzID0gW107XG4gICAgXy5lYWNoKGFycmF5LCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICBmbl9uYW1lID0gaXRlbVswXTtcbiAgICAgICAgICAgIGlmIChfLmlzQXJyYXkoZm5fbmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0cmFja2luZ19jYWxscy5wdXNoKGl0ZW0pOyAvLyBjaGFpbmVkIGNhbGwgZS5nLiBtaXhwYW5lbC5nZXRfZ3JvdXAoKS5zZXQoKVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YoaXRlbSkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF8uaXNBcnJheShpdGVtKSAmJiBmbl9uYW1lID09PSAnYWxpYXMnKSB7XG4gICAgICAgICAgICAgICAgYWxpYXNfY2FsbHMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5pc0FycmF5KGl0ZW0pICYmIGZuX25hbWUuaW5kZXhPZigndHJhY2snKSAhPT0gLTEgJiYgdHlwZW9mKHRoaXNbZm5fbmFtZV0pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdHJhY2tpbmdfY2FsbHMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3RoZXJfY2FsbHMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgdmFyIGV4ZWN1dGUgPSBmdW5jdGlvbihjYWxscywgY29udGV4dCkge1xuICAgICAgICBfLmVhY2goY2FsbHMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChfLmlzQXJyYXkoaXRlbVswXSkpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGFpbmVkIGNhbGxcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGVyID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICBfLmVhY2goaXRlbSwgZnVuY3Rpb24oY2FsbCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsZXIgPSBjYWxsZXJbY2FsbFswXV0uYXBwbHkoY2FsbGVyLCBjYWxsLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1tpdGVtWzBdXS5hcHBseSh0aGlzLCBpdGVtLnNsaWNlKDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgY29udGV4dCk7XG4gICAgfTtcblxuICAgIGV4ZWN1dGUoYWxpYXNfY2FsbHMsIHRoaXMpO1xuICAgIGV4ZWN1dGUob3RoZXJfY2FsbHMsIHRoaXMpO1xuICAgIGV4ZWN1dGUodHJhY2tpbmdfY2FsbHMsIHRoaXMpO1xufTtcblxuLy8gcmVxdWVzdCBxdWV1ZWluZyB1dGlsc1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuYXJlX2JhdGNoZXJzX2luaXRpYWxpemVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhdGhpcy5yZXF1ZXN0X2JhdGNoZXJzLmV2ZW50cztcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfYmF0Y2hlcl9jb25maWdzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHF1ZXVlX3ByZWZpeCA9ICdfX21wcV8nICsgdGhpcy5nZXRfY29uZmlnKCd0b2tlbicpO1xuICAgIHRoaXMuX2JhdGNoZXJfY29uZmlncyA9IHRoaXMuX2JhdGNoZXJfY29uZmlncyB8fCB7XG4gICAgICAgIGV2ZW50czoge3R5cGU6ICdldmVudHMnLCBhcGlfbmFtZTogJ3RyYWNrJywgcXVldWVfa2V5OiBxdWV1ZV9wcmVmaXggKyAnX2V2J30sXG4gICAgICAgIHBlb3BsZToge3R5cGU6ICdwZW9wbGUnLCBhcGlfbmFtZTogJ2VuZ2FnZScsIHF1ZXVlX2tleTogcXVldWVfcHJlZml4ICsgJ19wcCd9LFxuICAgICAgICBncm91cHM6IHt0eXBlOiAnZ3JvdXBzJywgYXBpX25hbWU6ICdncm91cHMnLCBxdWV1ZV9rZXk6IHF1ZXVlX3ByZWZpeCArICdfZ3InfVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2JhdGNoZXJfY29uZmlncztcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5pbml0X2JhdGNoZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmFyZV9iYXRjaGVyc19pbml0aWFsaXplZCgpKSB7XG4gICAgICAgIHZhciBiYXRjaGVyX2ZvciA9IF8uYmluZChmdW5jdGlvbihhdHRycykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXF1ZXN0QmF0Y2hlcihcbiAgICAgICAgICAgICAgICBhdHRycy5xdWV1ZV9rZXksXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsaWJDb25maWc6IHRoaXNbJ2NvbmZpZyddLFxuICAgICAgICAgICAgICAgICAgICBlcnJvclJlcG9ydGVyOiB0aGlzLmdldF9jb25maWcoJ2Vycm9yX3JlcG9ydGVyJyksXG4gICAgICAgICAgICAgICAgICAgIHNlbmRSZXF1ZXN0RnVuYzogXy5iaW5kKGZ1bmN0aW9uKGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXBpX3JvdXRlcyA9IHRoaXMuZ2V0X2NvbmZpZygnYXBpX3JvdXRlcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VuZF9yZXF1ZXN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0X2FwaV9ob3N0KGF0dHJzLmFwaV9uYW1lKSArICcvJyArIGFwaV9yb3V0ZXNbYXR0cnMuYXBpX25hbWVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VuY29kZV9kYXRhX2Zvcl9yZXF1ZXN0KGRhdGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJlcGFyZV9jYWxsYmFjayhjYiwgZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICBiZWZvcmVTZW5kSG9vazogXy5iaW5kKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ydW5faG9vaygnYmVmb3JlX3NlbmRfJyArIGF0dHJzLnR5cGUsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgc3RvcEFsbEJhdGNoaW5nRnVuYzogXy5iaW5kKHRoaXMuc3RvcF9iYXRjaF9zZW5kZXJzLCB0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgdXNlUGVyc2lzdGVuY2U6IHRydWUsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHZhciBiYXRjaGVyX2NvbmZpZ3MgPSB0aGlzLmdldF9iYXRjaGVyX2NvbmZpZ3MoKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0X2JhdGNoZXJzID0ge1xuICAgICAgICAgICAgZXZlbnRzOiBiYXRjaGVyX2ZvcihiYXRjaGVyX2NvbmZpZ3MuZXZlbnRzKSxcbiAgICAgICAgICAgIHBlb3BsZTogYmF0Y2hlcl9mb3IoYmF0Y2hlcl9jb25maWdzLnBlb3BsZSksXG4gICAgICAgICAgICBncm91cHM6IGJhdGNoZXJfZm9yKGJhdGNoZXJfY29uZmlncy5ncm91cHMpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLmdldF9jb25maWcoJ2JhdGNoX2F1dG9zdGFydCcpKSB7XG4gICAgICAgIHRoaXMuc3RhcnRfYmF0Y2hfc2VuZGVycygpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5zdGFydF9iYXRjaF9zZW5kZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYmF0Y2hlcnNfd2VyZV9zdGFydGVkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5hcmVfYmF0Y2hlcnNfaW5pdGlhbGl6ZWQoKSkge1xuICAgICAgICB0aGlzLl9iYXRjaF9yZXF1ZXN0cyA9IHRydWU7XG4gICAgICAgIF8uZWFjaCh0aGlzLnJlcXVlc3RfYmF0Y2hlcnMsIGZ1bmN0aW9uKGJhdGNoZXIpIHtcbiAgICAgICAgICAgIGJhdGNoZXIuc3RhcnQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLnN0b3BfYmF0Y2hfc2VuZGVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2JhdGNoX3JlcXVlc3RzID0gZmFsc2U7XG4gICAgXy5lYWNoKHRoaXMucmVxdWVzdF9iYXRjaGVycywgZnVuY3Rpb24oYmF0Y2hlcikge1xuICAgICAgICBiYXRjaGVyLnN0b3AoKTtcbiAgICAgICAgYmF0Y2hlci5jbGVhcigpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBwdXNoKCkga2VlcHMgdGhlIHN0YW5kYXJkIGFzeW5jLWFycmF5LXB1c2hcbiAqIGJlaGF2aW9yIGFyb3VuZCBhZnRlciB0aGUgbGliIGlzIGxvYWRlZC5cbiAqIFRoaXMgaXMgb25seSB1c2VmdWwgZm9yIGV4dGVybmFsIGludGVncmF0aW9ucyB0aGF0XG4gKiBkbyBub3Qgd2lzaCB0byByZWx5IG9uIG91ciBjb252ZW5pZW5jZSBtZXRob2RzXG4gKiAoY3JlYXRlZCBpbiB0aGUgc25pcHBldCkuXG4gKlxuICogIyMjIFVzYWdlOlxuICogICAgIG1peHBhbmVsLnB1c2goWydyZWdpc3RlcicsIHsgYTogJ2InIH1dKTtcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBpdGVtIEEgW2Z1bmN0aW9uX25hbWUsIGFyZ3MuLi5dIGFycmF5IHRvIGJlIGV4ZWN1dGVkXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oaXRlbSkge1xuICAgIHRoaXMuX2V4ZWN1dGVfYXJyYXkoW2l0ZW1dKTtcbn07XG5cbi8qKlxuICogRGlzYWJsZSBldmVudHMgb24gdGhlIE1peHBhbmVsIG9iamVjdC4gSWYgcGFzc2VkIG5vIGFyZ3VtZW50cyxcbiAqIHRoaXMgZnVuY3Rpb24gZGlzYWJsZXMgdHJhY2tpbmcgb2YgYW55IGV2ZW50LiBJZiBwYXNzZWQgYW5cbiAqIGFycmF5IG9mIGV2ZW50IG5hbWVzLCB0aG9zZSBldmVudHMgd2lsbCBiZSBkaXNhYmxlZCwgYnV0IG90aGVyXG4gKiBldmVudHMgd2lsbCBjb250aW51ZSB0byBiZSB0cmFja2VkLlxuICpcbiAqIE5vdGU6IHRoaXMgZnVuY3Rpb24gZG9lcyBub3Qgc3RvcCBvdGhlciBtaXhwYW5lbCBmdW5jdGlvbnMgZnJvbVxuICogZmlyaW5nLCBzdWNoIGFzIHJlZ2lzdGVyKCkgb3IgcGVvcGxlLnNldCgpLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IFtldmVudHNdIEFuIGFycmF5IG9mIGV2ZW50IG5hbWVzIHRvIGRpc2FibGVcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbihldmVudHMpIHtcbiAgICBpZiAodHlwZW9mKGV2ZW50cykgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuX2ZsYWdzLmRpc2FibGVfYWxsX2V2ZW50cyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fX2Rpc2FibGVkX2V2ZW50cyA9IHRoaXMuX19kaXNhYmxlZF9ldmVudHMuY29uY2F0KGV2ZW50cyk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9lbmNvZGVfZGF0YV9mb3JfcmVxdWVzdCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgZW5jb2RlZF9kYXRhID0gSlNPTlN0cmluZ2lmeShkYXRhKTtcbiAgICBpZiAodGhpcy5nZXRfY29uZmlnKCdhcGlfcGF5bG9hZF9mb3JtYXQnKSA9PT0gUEFZTE9BRF9UWVBFX0JBU0U2NCkge1xuICAgICAgICBlbmNvZGVkX2RhdGEgPSBfLmJhc2U2NEVuY29kZShlbmNvZGVkX2RhdGEpO1xuICAgIH1cbiAgICByZXR1cm4geydkYXRhJzogZW5jb2RlZF9kYXRhfTtcbn07XG5cbi8vIGludGVybmFsIG1ldGhvZCBmb3IgaGFuZGxpbmcgdHJhY2sgdnMgYmF0Y2gtZW5xdWV1ZSBsb2dpY1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLl90cmFja19vcl9iYXRjaCA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHRydW5jYXRlZF9kYXRhID0gXy50cnVuY2F0ZShvcHRpb25zLmRhdGEsIDI1NSk7XG4gICAgdmFyIGVuZHBvaW50ID0gb3B0aW9ucy5lbmRwb2ludDtcbiAgICB2YXIgYmF0Y2hlciA9IG9wdGlvbnMuYmF0Y2hlcjtcbiAgICB2YXIgc2hvdWxkX3NlbmRfaW1tZWRpYXRlbHkgPSBvcHRpb25zLnNob3VsZF9zZW5kX2ltbWVkaWF0ZWx5O1xuICAgIHZhciBzZW5kX3JlcXVlc3Rfb3B0aW9ucyA9IG9wdGlvbnMuc2VuZF9yZXF1ZXN0X29wdGlvbnMgfHwge307XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBOT09QX0ZVTkM7XG5cbiAgICB2YXIgcmVxdWVzdF9lbnF1ZXVlZF9vcl9pbml0aWF0ZWQgPSB0cnVlO1xuICAgIHZhciBzZW5kX3JlcXVlc3RfaW1tZWRpYXRlbHkgPSBfLmJpbmQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghc2VuZF9yZXF1ZXN0X29wdGlvbnMuc2tpcF9ob29rcykge1xuICAgICAgICAgICAgdHJ1bmNhdGVkX2RhdGEgPSB0aGlzLl9ydW5faG9vaygnYmVmb3JlX3NlbmRfJyArIG9wdGlvbnMudHlwZSwgdHJ1bmNhdGVkX2RhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cnVuY2F0ZWRfZGF0YSkge1xuICAgICAgICAgICAgY29uc29sZSQxLmxvZygnTUlYUEFORUwgUkVRVUVTVDonKTtcbiAgICAgICAgICAgIGNvbnNvbGUkMS5sb2codHJ1bmNhdGVkX2RhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChcbiAgICAgICAgICAgICAgICBlbmRwb2ludCxcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmNvZGVfZGF0YV9mb3JfcmVxdWVzdCh0cnVuY2F0ZWRfZGF0YSksXG4gICAgICAgICAgICAgICAgc2VuZF9yZXF1ZXN0X29wdGlvbnMsXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJlcGFyZV9jYWxsYmFjayhjYWxsYmFjaywgdHJ1bmNhdGVkX2RhdGEpXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIGlmICh0aGlzLl9iYXRjaF9yZXF1ZXN0cyAmJiAhc2hvdWxkX3NlbmRfaW1tZWRpYXRlbHkpIHtcbiAgICAgICAgYmF0Y2hlci5lbnF1ZXVlKHRydW5jYXRlZF9kYXRhKS50aGVuKGZ1bmN0aW9uKHN1Y2NlZWRlZCkge1xuICAgICAgICAgICAgaWYgKHN1Y2NlZWRlZCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKDEsIHRydW5jYXRlZF9kYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VuZF9yZXF1ZXN0X2ltbWVkaWF0ZWx5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcXVlc3RfZW5xdWV1ZWRfb3JfaW5pdGlhdGVkID0gc2VuZF9yZXF1ZXN0X2ltbWVkaWF0ZWx5KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcXVlc3RfZW5xdWV1ZWRfb3JfaW5pdGlhdGVkICYmIHRydW5jYXRlZF9kYXRhO1xufTtcblxuLyoqXG4gKiBUcmFjayBhbiBldmVudC4gVGhpcyBpcyB0aGUgbW9zdCBpbXBvcnRhbnQgYW5kXG4gKiBmcmVxdWVudGx5IHVzZWQgTWl4cGFuZWwgZnVuY3Rpb24uXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyB0cmFjayBhbiBldmVudCBuYW1lZCAnUmVnaXN0ZXJlZCdcbiAqICAgICBtaXhwYW5lbC50cmFjaygnUmVnaXN0ZXJlZCcsIHsnR2VuZGVyJzogJ01hbGUnLCAnQWdlJzogMjF9KTtcbiAqXG4gKiAgICAgLy8gdHJhY2sgYW4gZXZlbnQgdXNpbmcgbmF2aWdhdG9yLnNlbmRCZWFjb25cbiAqICAgICBtaXhwYW5lbC50cmFjaygnTGVmdCBwYWdlJywgeydkdXJhdGlvbl9zZWNvbmRzJzogMzV9LCB7dHJhbnNwb3J0OiAnc2VuZEJlYWNvbid9KTtcbiAqXG4gKiBUbyB0cmFjayBsaW5rIGNsaWNrcyBvciBmb3JtIHN1Ym1pc3Npb25zLCBzZWUgdHJhY2tfbGlua3MoKSBvciB0cmFja19mb3JtcygpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudF9uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudC4gVGhpcyBjYW4gYmUgYW55dGhpbmcgdGhlIHVzZXIgZG9lcyAtICdCdXR0b24gQ2xpY2snLCAnU2lnbiBVcCcsICdJdGVtIFB1cmNoYXNlZCcsIGV0Yy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc10gQSBzZXQgb2YgcHJvcGVydGllcyB0byBpbmNsdWRlIHdpdGggdGhlIGV2ZW50IHlvdSdyZSBzZW5kaW5nLiBUaGVzZSBkZXNjcmliZSB0aGUgdXNlciB3aG8gZGlkIHRoZSBldmVudCBvciBkZXRhaWxzIGFib3V0IHRoZSBldmVudCBpdHNlbGYuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gZm9yIHRoaXMgdHJhY2sgcmVxdWVzdC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50cmFuc3BvcnRdIFRyYW5zcG9ydCBtZXRob2QgZm9yIG5ldHdvcmsgcmVxdWVzdCAoJ3hocicgb3IgJ3NlbmRCZWFjb24nKS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2VuZF9pbW1lZGlhdGVseV0gV2hldGhlciB0byBieXBhc3MgYmF0Y2hpbmcvcXVldWVpbmcgYW5kIHNlbmQgdHJhY2sgcmVxdWVzdCBpbW1lZGlhdGVseS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbnxPYmplY3R9IElmIHRoZSB0cmFja2luZyByZXF1ZXN0IHdhcyBzdWNjZXNzZnVsbHkgaW5pdGlhdGVkL3F1ZXVlZCwgYW4gb2JqZWN0XG4gKiB3aXRoIHRoZSB0cmFja2luZyBwYXlsb2FkIHNlbnQgdG8gdGhlIEFQSSBzZXJ2ZXIgaXMgcmV0dXJuZWQ7IG90aGVyd2lzZSBmYWxzZS5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnRyYWNrID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYihmdW5jdGlvbihldmVudF9uYW1lLCBwcm9wZXJ0aWVzLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2sgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIHRyYW5zcG9ydCA9IG9wdGlvbnNbJ3RyYW5zcG9ydCddOyAvLyBleHRlcm5hbCBBUEksIGRvbid0IG1pbmlmeSAndHJhbnNwb3J0JyBwcm9wXG4gICAgaWYgKHRyYW5zcG9ydCkge1xuICAgICAgICBvcHRpb25zLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDsgLy8gJ3RyYW5zcG9ydCcgcHJvcCBuYW1lIGNhbiBiZSBtaW5pZmllZCBpbnRlcm5hbGx5XG4gICAgfVxuICAgIHZhciBzaG91bGRfc2VuZF9pbW1lZGlhdGVseSA9IG9wdGlvbnNbJ3NlbmRfaW1tZWRpYXRlbHknXTtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gTk9PUF9GVU5DO1xuICAgIH1cblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKGV2ZW50X25hbWUpKSB7XG4gICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdObyBldmVudCBuYW1lIHByb3ZpZGVkIHRvIG1peHBhbmVsLnRyYWNrJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRfaXNfZGlzYWJsZWQoZXZlbnRfbmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2soMCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzZXQgZGVmYXVsdHNcbiAgICBwcm9wZXJ0aWVzID0gXy5leHRlbmQoe30sIHByb3BlcnRpZXMpO1xuICAgIHByb3BlcnRpZXNbJ3Rva2VuJ10gPSB0aGlzLmdldF9jb25maWcoJ3Rva2VuJyk7XG5cbiAgICAvLyBzZXQgJGR1cmF0aW9uIGlmIHRpbWVfZXZlbnQgd2FzIHByZXZpb3VzbHkgY2FsbGVkIGZvciB0aGlzIGV2ZW50XG4gICAgdmFyIHN0YXJ0X3RpbWVzdGFtcCA9IHRoaXNbJ3BlcnNpc3RlbmNlJ10ucmVtb3ZlX2V2ZW50X3RpbWVyKGV2ZW50X25hbWUpO1xuICAgIGlmICghXy5pc1VuZGVmaW5lZChzdGFydF90aW1lc3RhbXApKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbl9pbl9tcyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRfdGltZXN0YW1wO1xuICAgICAgICBwcm9wZXJ0aWVzWyckZHVyYXRpb24nXSA9IHBhcnNlRmxvYXQoKGR1cmF0aW9uX2luX21zIC8gMTAwMCkudG9GaXhlZCgzKSk7XG4gICAgfVxuXG4gICAgdGhpcy5fc2V0X2RlZmF1bHRfc3VwZXJwcm9wcygpO1xuXG4gICAgdmFyIG1hcmtldGluZ19wcm9wZXJ0aWVzID0gdGhpcy5nZXRfY29uZmlnKCd0cmFja19tYXJrZXRpbmcnKVxuICAgICAgICA/IF8uaW5mby5tYXJrZXRpbmdQYXJhbXMoKVxuICAgICAgICA6IHt9O1xuXG4gICAgLy8gbm90ZTogZXh0ZW5kIHdyaXRlcyB0byB0aGUgZmlyc3Qgb2JqZWN0LCBzbyBsZXRzIG1ha2Ugc3VyZSB3ZVxuICAgIC8vIGRvbid0IHdyaXRlIHRvIHRoZSBwZXJzaXN0ZW5jZSBwcm9wZXJ0aWVzIG9iamVjdCBhbmQgaW5mb1xuICAgIC8vIHByb3BlcnRpZXMgb2JqZWN0IGJ5IHBhc3NpbmcgaW4gYSBuZXcgb2JqZWN0XG5cbiAgICAvLyB1cGRhdGUgcHJvcGVydGllcyB3aXRoIHBhZ2V2aWV3IGluZm8gYW5kIHN1cGVyLXByb3BlcnRpZXNcbiAgICBwcm9wZXJ0aWVzID0gXy5leHRlbmQoXG4gICAgICAgIHt9LFxuICAgICAgICBfLmluZm8ucHJvcGVydGllcyh7J21wX2xvYWRlcic6IHRoaXMuZ2V0X2NvbmZpZygnbXBfbG9hZGVyJyl9KSxcbiAgICAgICAgbWFya2V0aW5nX3Byb3BlcnRpZXMsXG4gICAgICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10ucHJvcGVydGllcygpLFxuICAgICAgICB0aGlzLnVucGVyc2lzdGVkX3N1cGVycHJvcHMsXG4gICAgICAgIHRoaXMuZ2V0X3Nlc3Npb25fcmVjb3JkaW5nX3Byb3BlcnRpZXMoKSxcbiAgICAgICAgcHJvcGVydGllc1xuICAgICk7XG5cbiAgICB2YXIgcHJvcGVydHlfYmxhY2tsaXN0ID0gdGhpcy5nZXRfY29uZmlnKCdwcm9wZXJ0eV9ibGFja2xpc3QnKTtcbiAgICBpZiAoXy5pc0FycmF5KHByb3BlcnR5X2JsYWNrbGlzdCkpIHtcbiAgICAgICAgXy5lYWNoKHByb3BlcnR5X2JsYWNrbGlzdCwgZnVuY3Rpb24oYmxhY2tsaXN0ZWRfcHJvcCkge1xuICAgICAgICAgICAgZGVsZXRlIHByb3BlcnRpZXNbYmxhY2tsaXN0ZWRfcHJvcF07XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBwcm9wZXJ0eV9ibGFja2xpc3QgY29uZmlnOiAnICsgcHJvcGVydHlfYmxhY2tsaXN0KTtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgJ2V2ZW50JzogZXZlbnRfbmFtZSxcbiAgICAgICAgJ3Byb3BlcnRpZXMnOiBwcm9wZXJ0aWVzXG4gICAgfTtcbiAgICB2YXIgcmV0ID0gdGhpcy5fdHJhY2tfb3JfYmF0Y2goe1xuICAgICAgICB0eXBlOiAnZXZlbnRzJyxcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgZW5kcG9pbnQ6IHRoaXMuZ2V0X2FwaV9ob3N0KCdldmVudHMnKSArICcvJyArIHRoaXMuZ2V0X2NvbmZpZygnYXBpX3JvdXRlcycpWyd0cmFjayddLFxuICAgICAgICBiYXRjaGVyOiB0aGlzLnJlcXVlc3RfYmF0Y2hlcnMuZXZlbnRzLFxuICAgICAgICBzaG91bGRfc2VuZF9pbW1lZGlhdGVseTogc2hvdWxkX3NlbmRfaW1tZWRpYXRlbHksXG4gICAgICAgIHNlbmRfcmVxdWVzdF9vcHRpb25zOiBvcHRpb25zXG4gICAgfSwgY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHJldDtcbn0pO1xuXG4vKipcbiAqIFJlZ2lzdGVyIHRoZSBjdXJyZW50IHVzZXIgaW50byBvbmUvbWFueSBncm91cHMuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAgbWl4cGFuZWwuc2V0X2dyb3VwKCdjb21wYW55JywgWydtaXhwYW5lbCcsICdnb29nbGUnXSkgLy8gYW4gYXJyYXkgb2YgSURzXG4gKiAgICAgIG1peHBhbmVsLnNldF9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpXG4gKiAgICAgIG1peHBhbmVsLnNldF9ncm91cCgnY29tcGFueScsIDEyODc0NjMxMilcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBfa2V5IEdyb3VwIGtleVxuICogQHBhcmFtIHtBcnJheXxTdHJpbmd8TnVtYmVyfSBncm91cF9pZHMgQW4gYXJyYXkgb2YgZ3JvdXAgSURzLCBvciBhIHNpbmd1bGFyIGdyb3VwIElEXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuICpcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnNldF9ncm91cCA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIoZnVuY3Rpb24oZ3JvdXBfa2V5LCBncm91cF9pZHMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFfLmlzQXJyYXkoZ3JvdXBfaWRzKSkge1xuICAgICAgICBncm91cF9pZHMgPSBbZ3JvdXBfaWRzXTtcbiAgICB9XG4gICAgdmFyIHByb3AgPSB7fTtcbiAgICBwcm9wW2dyb3VwX2tleV0gPSBncm91cF9pZHM7XG4gICAgdGhpcy5yZWdpc3Rlcihwcm9wKTtcbiAgICByZXR1cm4gdGhpc1sncGVvcGxlJ10uc2V0KGdyb3VwX2tleSwgZ3JvdXBfaWRzLCBjYWxsYmFjayk7XG59KTtcblxuLyoqXG4gKiBBZGQgYSBuZXcgZ3JvdXAgZm9yIHRoaXMgdXNlci5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgICBtaXhwYW5lbC5hZGRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBncm91cF9rZXkgR3JvdXAga2V5XG4gKiBAcGFyYW0geyp9IGdyb3VwX2lkIEEgdmFsaWQgTWl4cGFuZWwgcHJvcGVydHkgdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmFkZF9ncm91cCA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIoZnVuY3Rpb24oZ3JvdXBfa2V5LCBncm91cF9pZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgb2xkX3ZhbHVlcyA9IHRoaXMuZ2V0X3Byb3BlcnR5KGdyb3VwX2tleSk7XG4gICAgdmFyIHByb3AgPSB7fTtcbiAgICBpZiAob2xkX3ZhbHVlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BbZ3JvdXBfa2V5XSA9IFtncm91cF9pZF07XG4gICAgICAgIHRoaXMucmVnaXN0ZXIocHJvcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9sZF92YWx1ZXMuaW5kZXhPZihncm91cF9pZCkgPT09IC0xKSB7XG4gICAgICAgICAgICBvbGRfdmFsdWVzLnB1c2goZ3JvdXBfaWQpO1xuICAgICAgICAgICAgcHJvcFtncm91cF9rZXldID0gb2xkX3ZhbHVlcztcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIocHJvcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXNbJ3Blb3BsZSddLnVuaW9uKGdyb3VwX2tleSwgZ3JvdXBfaWQsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKipcbiAqIFJlbW92ZSBhIGdyb3VwIGZyb20gdGhpcyB1c2VyLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgIG1peHBhbmVsLnJlbW92ZV9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwX2tleSBHcm91cCBrZXlcbiAqIEBwYXJhbSB7Kn0gZ3JvdXBfaWQgQSB2YWxpZCBNaXhwYW5lbCBwcm9wZXJ0eSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUucmVtb3ZlX2dyb3VwID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYihmdW5jdGlvbihncm91cF9rZXksIGdyb3VwX2lkLCBjYWxsYmFjaykge1xuICAgIHZhciBvbGRfdmFsdWUgPSB0aGlzLmdldF9wcm9wZXJ0eShncm91cF9rZXkpO1xuICAgIC8vIGlmIHRoZSB2YWx1ZSBkb2Vzbid0IGV4aXN0LCB0aGUgcGVyc2lzdGVudCBzdG9yZSBpcyB1bmNoYW5nZWRcbiAgICBpZiAob2xkX3ZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGlkeCA9IG9sZF92YWx1ZS5pbmRleE9mKGdyb3VwX2lkKTtcbiAgICAgICAgaWYgKGlkeCA+IC0xKSB7XG4gICAgICAgICAgICBvbGRfdmFsdWUuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyKHtncm91cF9rZXk6IG9sZF92YWx1ZX0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbGRfdmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnVucmVnaXN0ZXIoZ3JvdXBfa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1sncGVvcGxlJ10ucmVtb3ZlKGdyb3VwX2tleSwgZ3JvdXBfaWQsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKipcbiAqIFRyYWNrIGFuIGV2ZW50IHdpdGggc3BlY2lmaWMgZ3JvdXBzLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgIG1peHBhbmVsLnRyYWNrX3dpdGhfZ3JvdXBzKCdwdXJjaGFzZScsIHsncHJvZHVjdCc6ICdpcGhvbmUnfSwgeydVbml2ZXJzaXR5JzogWydVQ0InLCAnVUNMQSddfSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRfbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKHNlZSBgbWl4cGFuZWwudHJhY2soKWApXG4gKiBAcGFyYW0ge09iamVjdD19IHByb3BlcnRpZXMgQSBzZXQgb2YgcHJvcGVydGllcyB0byBpbmNsdWRlIHdpdGggdGhlIGV2ZW50IHlvdSdyZSBzZW5kaW5nIChzZWUgYG1peHBhbmVsLnRyYWNrKClgKVxuICogQHBhcmFtIHtPYmplY3Q9fSBncm91cHMgQW4gb2JqZWN0IG1hcHBpbmcgZ3JvdXAgbmFtZSBrZXlzIHRvIG9uZSBvciBtb3JlIHZhbHVlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnRyYWNrX3dpdGhfZ3JvdXBzID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYihmdW5jdGlvbihldmVudF9uYW1lLCBwcm9wZXJ0aWVzLCBncm91cHMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHRyYWNraW5nX3Byb3BzID0gXy5leHRlbmQoe30sIHByb3BlcnRpZXMgfHwge30pO1xuICAgIF8uZWFjaChncm91cHMsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgaWYgKHYgIT09IG51bGwgJiYgdiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cmFja2luZ19wcm9wc1trXSA9IHY7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy50cmFjayhldmVudF9uYW1lLCB0cmFja2luZ19wcm9wcywgY2FsbGJhY2spO1xufSk7XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fY3JlYXRlX21hcF9rZXkgPSBmdW5jdGlvbiAoZ3JvdXBfa2V5LCBncm91cF9pZCkge1xuICAgIHJldHVybiBncm91cF9rZXkgKyAnXycgKyBKU09OLnN0cmluZ2lmeShncm91cF9pZCk7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX3JlbW92ZV9ncm91cF9mcm9tX2NhY2hlID0gZnVuY3Rpb24gKGdyb3VwX2tleSwgZ3JvdXBfaWQpIHtcbiAgICBkZWxldGUgdGhpcy5fY2FjaGVkX2dyb3Vwc1t0aGlzLl9jcmVhdGVfbWFwX2tleShncm91cF9rZXksIGdyb3VwX2lkKV07XG59O1xuXG4vKipcbiAqIExvb2sgdXAgcmVmZXJlbmNlIHRvIGEgTWl4cGFuZWwgZ3JvdXBcbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgICAgbWl4cGFuZWwuZ2V0X2dyb3VwKGdyb3VwX2tleSwgZ3JvdXBfaWQpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwX2tleSBHcm91cCBrZXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBncm91cF9pZCBBIHZhbGlkIE1peHBhbmVsIHByb3BlcnR5IHR5cGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IEEgTWl4cGFuZWxHcm91cCBpZGVudGlmaWVyXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfZ3JvdXAgPSBmdW5jdGlvbiAoZ3JvdXBfa2V5LCBncm91cF9pZCkge1xuICAgIHZhciBtYXBfa2V5ID0gdGhpcy5fY3JlYXRlX21hcF9rZXkoZ3JvdXBfa2V5LCBncm91cF9pZCk7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5fY2FjaGVkX2dyb3Vwc1ttYXBfa2V5XTtcbiAgICBpZiAoZ3JvdXAgPT09IHVuZGVmaW5lZCB8fCBncm91cC5fZ3JvdXBfa2V5ICE9PSBncm91cF9rZXkgfHwgZ3JvdXAuX2dyb3VwX2lkICE9PSBncm91cF9pZCkge1xuICAgICAgICBncm91cCA9IG5ldyBNaXhwYW5lbEdyb3VwKCk7XG4gICAgICAgIGdyb3VwLl9pbml0KHRoaXMsIGdyb3VwX2tleSwgZ3JvdXBfaWQpO1xuICAgICAgICB0aGlzLl9jYWNoZWRfZ3JvdXBzW21hcF9rZXldID0gZ3JvdXA7XG4gICAgfVxuICAgIHJldHVybiBncm91cDtcbn07XG5cbi8qKlxuICogVHJhY2sgYSBkZWZhdWx0IE1peHBhbmVsIHBhZ2UgdmlldyBldmVudCwgd2hpY2ggaW5jbHVkZXMgZXh0cmEgZGVmYXVsdCBldmVudCBwcm9wZXJ0aWVzIHRvXG4gKiBpbXByb3ZlIHBhZ2UgdmlldyBkYXRhLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gdHJhY2sgYSBkZWZhdWx0ICRtcF93ZWJfcGFnZV92aWV3IGV2ZW50XG4gKiAgICAgbWl4cGFuZWwudHJhY2tfcGFnZXZpZXcoKTtcbiAqXG4gKiAgICAgLy8gdHJhY2sgYSBwYWdlIHZpZXcgZXZlbnQgd2l0aCBhZGRpdGlvbmFsIGV2ZW50IHByb3BlcnRpZXNcbiAqICAgICBtaXhwYW5lbC50cmFja19wYWdldmlldyh7J2FiX3Rlc3RfdmFyaWFudCc6ICdjYXJkLWxheW91dC1iJ30pO1xuICpcbiAqICAgICAvLyBleGFtcGxlIGFwcHJvYWNoIHRvIHRyYWNrIHBhZ2Ugdmlld3Mgb24gZGlmZmVyZW50IHBhZ2UgdHlwZXMgYXMgZXZlbnQgcHJvcGVydGllc1xuICogICAgIG1peHBhbmVsLnRyYWNrX3BhZ2V2aWV3KHsncGFnZSc6ICdwcmljaW5nJ30pO1xuICogICAgIG1peHBhbmVsLnRyYWNrX3BhZ2V2aWV3KHsncGFnZSc6ICdob21lcGFnZSd9KTtcbiAqXG4gKiAgICAgLy8gVU5DT01NT046IFRyYWNraW5nIGEgcGFnZSB2aWV3IGV2ZW50IHdpdGggYSBjdXN0b20gZXZlbnRfbmFtZSBvcHRpb24uIE5PVCBleHBlY3RlZCB0byBiZSB1c2VkIGZvclxuICogICAgIC8vIGluZGl2aWR1YWwgcGFnZXMgb24gdGhlIHNhbWUgc2l0ZSBvciBwcm9kdWN0LiBVc2UgY2FzZXMgZm9yIGN1c3RvbSBldmVudF9uYW1lIG1heSBiZSBwYWdlXG4gKiAgICAgLy8gdmlld3Mgb24gZGlmZmVyZW50IHByb2R1Y3RzIG9yIGludGVybmFsIGFwcGxpY2F0aW9ucyB0aGF0IGFyZSBjb25zaWRlcmVkIGNvbXBsZXRlbHkgc2VwYXJhdGVcbiAqICAgICBtaXhwYW5lbC50cmFja19wYWdldmlldyh7J3BhZ2UnOiAnY3VzdG9tZXItc2VhcmNoJ30sIHsnZXZlbnRfbmFtZSc6ICdbaW50ZXJuYWxdIEFkbWluIFBhZ2UgVmlldyd9KTtcbiAqXG4gKiAjIyMgTm90ZXM6XG4gKlxuICogVGhlIGBjb25maWcudHJhY2tfcGFnZXZpZXdgIG9wdGlvbiBmb3IgPGEgaHJlZj1cIiNtaXhwYW5lbGluaXRcIj5taXhwYW5lbC5pbml0KCk8L2E+XG4gKiBtYXkgYmUgdHVybmVkIG9uIGZvciB0cmFja2luZyBwYWdlIGxvYWRzIGF1dG9tYXRpY2FsbHkuXG4gKlxuICogICAgIC8vIHRyYWNrIG9ubHkgcGFnZSBsb2Fkc1xuICogICAgIG1peHBhbmVsLmluaXQoUFJPSkVDVF9UT0tFTiwge3RyYWNrX3BhZ2V2aWV3OiB0cnVlfSk7XG4gKlxuICogICAgIC8vIHRyYWNrIHdoZW4gdGhlIFVSTCBjaGFuZ2VzIGluIGFueSBtYW5uZXJcbiAqICAgICBtaXhwYW5lbC5pbml0KFBST0pFQ1RfVE9LRU4sIHt0cmFja19wYWdldmlldzogJ2Z1bGwtdXJsJ30pO1xuICpcbiAqICAgICAvLyB0cmFjayB3aGVuIHRoZSBVUkwgY2hhbmdlcywgaWdub3JpbmcgYW55IGNoYW5nZXMgaW4gdGhlIGhhc2ggcGFydFxuICogICAgIG1peHBhbmVsLmluaXQoUFJPSkVDVF9UT0tFTiwge3RyYWNrX3BhZ2V2aWV3OiAndXJsLXdpdGgtcGF0aC1hbmQtcXVlcnktc3RyaW5nJ30pO1xuICpcbiAqICAgICAvLyB0cmFjayB3aGVuIHRoZSBwYXRoIGNoYW5nZXMsIGlnbm9yaW5nIGFueSBxdWVyeSBwYXJhbWV0ZXIgb3IgaGFzaCBjaGFuZ2VzXG4gKiAgICAgbWl4cGFuZWwuaW5pdChQUk9KRUNUX1RPS0VOLCB7dHJhY2tfcGFnZXZpZXc6ICd1cmwtd2l0aC1wYXRoJ30pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc10gQW4gb3B0aW9uYWwgc2V0IG9mIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0byBzZW5kIHdpdGggdGhlIHBhZ2UgdmlldyBldmVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBQYWdlIHZpZXcgdHJhY2tpbmcgb3B0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmV2ZW50X25hbWVdIC0gQWx0ZXJuYXRlIG5hbWUgZm9yIHRoZSB0cmFja2luZyBldmVudFxuICogQHJldHVybnMge0Jvb2xlYW58T2JqZWN0fSBJZiB0aGUgdHJhY2tpbmcgcmVxdWVzdCB3YXMgc3VjY2Vzc2Z1bGx5IGluaXRpYXRlZC9xdWV1ZWQsIGFuIG9iamVjdFxuICogd2l0aCB0aGUgdHJhY2tpbmcgcGF5bG9hZCBzZW50IHRvIHRoZSBBUEkgc2VydmVyIGlzIHJldHVybmVkOyBvdGhlcndpc2UgZmFsc2UuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS50cmFja19wYWdldmlldyA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIoZnVuY3Rpb24ocHJvcGVydGllcywgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgcHJvcGVydGllcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcHJvcGVydGllcyA9IHt9O1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgZXZlbnRfbmFtZSA9IG9wdGlvbnNbJ2V2ZW50X25hbWUnXSB8fCAnJG1wX3dlYl9wYWdlX3ZpZXcnO1xuXG4gICAgdmFyIGRlZmF1bHRfcGFnZV9wcm9wZXJ0aWVzID0gXy5leHRlbmQoXG4gICAgICAgIF8uaW5mby5tcFBhZ2VWaWV3UHJvcGVydGllcygpLFxuICAgICAgICBfLmluZm8uY2FtcGFpZ25QYXJhbXMoKSxcbiAgICAgICAgXy5pbmZvLmNsaWNrUGFyYW1zKClcbiAgICApO1xuXG4gICAgdmFyIGV2ZW50X3Byb3BlcnRpZXMgPSBfLmV4dGVuZChcbiAgICAgICAge30sXG4gICAgICAgIGRlZmF1bHRfcGFnZV9wcm9wZXJ0aWVzLFxuICAgICAgICBwcm9wZXJ0aWVzXG4gICAgKTtcblxuICAgIHJldHVybiB0aGlzLnRyYWNrKGV2ZW50X25hbWUsIGV2ZW50X3Byb3BlcnRpZXMpO1xufSk7XG5cbi8qKlxuICogVHJhY2sgY2xpY2tzIG9uIGEgc2V0IG9mIGRvY3VtZW50IGVsZW1lbnRzLiBTZWxlY3RvciBtdXN0IGJlIGFcbiAqIHZhbGlkIHF1ZXJ5LiBFbGVtZW50cyBtdXN0IGV4aXN0IG9uIHRoZSBwYWdlIGF0IHRoZSB0aW1lIHRyYWNrX2xpbmtzIGlzIGNhbGxlZC5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIHRyYWNrIGNsaWNrIGZvciBsaW5rIGlkICNuYXZcbiAqICAgICBtaXhwYW5lbC50cmFja19saW5rcygnI25hdicsICdDbGlja2VkIE5hdiBMaW5rJyk7XG4gKlxuICogIyMjIE5vdGVzOlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCB3YWl0IHVwIHRvIDMwMCBtcyBmb3IgdGhlIE1peHBhbmVsXG4gKiBzZXJ2ZXJzIHRvIHJlc3BvbmQuIElmIHRoZXkgaGF2ZSBub3QgcmVzcG9uZGVkIGJ5IHRoYXQgdGltZVxuICogaXQgd2lsbCBoZWFkIHRvIHRoZSBsaW5rIHdpdGhvdXQgZW5zdXJpbmcgdGhhdCB5b3VyIGV2ZW50XG4gKiBoYXMgYmVlbiB0cmFja2VkLiAgVG8gY29uZmlndXJlIHRoaXMgdGltZW91dCBwbGVhc2Ugc2VlIHRoZVxuICogc2V0X2NvbmZpZygpIGRvY3VtZW50YXRpb24gYmVsb3cuXG4gKlxuICogSWYgeW91IHBhc3MgYSBmdW5jdGlvbiBpbiBhcyB0aGUgcHJvcGVydGllcyBhcmd1bWVudCwgdGhlXG4gKiBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgdGhlIERPTUVsZW1lbnQgdGhhdCB0cmlnZ2VyZWQgdGhlXG4gKiBldmVudCBhcyBhbiBhcmd1bWVudC4gIFlvdSBhcmUgZXhwZWN0ZWQgdG8gcmV0dXJuIGFuIG9iamVjdFxuICogZnJvbSB0aGUgZnVuY3Rpb247IGFueSBwcm9wZXJ0aWVzIGRlZmluZWQgb24gdGhpcyBvYmplY3RcbiAqIHdpbGwgYmUgc2VudCB0byBtaXhwYW5lbCBhcyBldmVudCBwcm9wZXJ0aWVzLlxuICpcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcXVlcnkgQSB2YWxpZCBET00gcXVlcnksIGVsZW1lbnQgb3IgalF1ZXJ5LWVzcXVlIGxpc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudF9uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byB0cmFja1xuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IFtwcm9wZXJ0aWVzXSBBIHByb3BlcnRpZXMgb2JqZWN0IG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGRpY3Rpb25hcnkgb2YgcHJvcGVydGllcyB3aGVuIHBhc3NlZCBhIERPTUVsZW1lbnRcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnRyYWNrX2xpbmtzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWNrX2RvbS5jYWxsKHRoaXMsIExpbmtUcmFja2VyLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBUcmFjayBmb3JtIHN1Ym1pc3Npb25zLiBTZWxlY3RvciBtdXN0IGJlIGEgdmFsaWQgcXVlcnkuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyB0cmFjayBzdWJtaXNzaW9uIGZvciBmb3JtIGlkICdyZWdpc3RlcidcbiAqICAgICBtaXhwYW5lbC50cmFja19mb3JtcygnI3JlZ2lzdGVyJywgJ0NyZWF0ZWQgQWNjb3VudCcpO1xuICpcbiAqICMjIyBOb3RlczpcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgd2FpdCB1cCB0byAzMDAgbXMgZm9yIHRoZSBtaXhwYW5lbFxuICogc2VydmVycyB0byByZXNwb25kLCBpZiB0aGV5IGhhdmUgbm90IHJlc3BvbmRlZCBieSB0aGF0IHRpbWVcbiAqIGl0IHdpbGwgaGVhZCB0byB0aGUgbGluayB3aXRob3V0IGVuc3VyaW5nIHRoYXQgeW91ciBldmVudFxuICogaGFzIGJlZW4gdHJhY2tlZC4gIFRvIGNvbmZpZ3VyZSB0aGlzIHRpbWVvdXQgcGxlYXNlIHNlZSB0aGVcbiAqIHNldF9jb25maWcoKSBkb2N1bWVudGF0aW9uIGJlbG93LlxuICpcbiAqIElmIHlvdSBwYXNzIGEgZnVuY3Rpb24gaW4gYXMgdGhlIHByb3BlcnRpZXMgYXJndW1lbnQsIHRoZVxuICogZnVuY3Rpb24gd2lsbCByZWNlaXZlIHRoZSBET01FbGVtZW50IHRoYXQgdHJpZ2dlcmVkIHRoZVxuICogZXZlbnQgYXMgYW4gYXJndW1lbnQuICBZb3UgYXJlIGV4cGVjdGVkIHRvIHJldHVybiBhbiBvYmplY3RcbiAqIGZyb20gdGhlIGZ1bmN0aW9uOyBhbnkgcHJvcGVydGllcyBkZWZpbmVkIG9uIHRoaXMgb2JqZWN0XG4gKiB3aWxsIGJlIHNlbnQgdG8gbWl4cGFuZWwgYXMgZXZlbnQgcHJvcGVydGllcy5cbiAqXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHF1ZXJ5IEEgdmFsaWQgRE9NIHF1ZXJ5LCBlbGVtZW50IG9yIGpRdWVyeS1lc3F1ZSBsaXN0XG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRfbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gdHJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBbcHJvcGVydGllc10gVGhpcyBjYW4gYmUgYSBzZXQgb2YgcHJvcGVydGllcywgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzZXQgb2YgcHJvcGVydGllcyBhZnRlciBiZWluZyBwYXNzZWQgYSBET01FbGVtZW50XG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS50cmFja19mb3JtcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFja19kb20uY2FsbCh0aGlzLCBGb3JtVHJhY2tlciwgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogVGltZSBhbiBldmVudCBieSBpbmNsdWRpbmcgdGhlIHRpbWUgYmV0d2VlbiB0aGlzIGNhbGwgYW5kIGFcbiAqIGxhdGVyICd0cmFjaycgY2FsbCBmb3IgdGhlIHNhbWUgZXZlbnQgaW4gdGhlIHByb3BlcnRpZXMgc2VudFxuICogd2l0aCB0aGUgZXZlbnQuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyB0aW1lIGFuIGV2ZW50IG5hbWVkICdSZWdpc3RlcmVkJ1xuICogICAgIG1peHBhbmVsLnRpbWVfZXZlbnQoJ1JlZ2lzdGVyZWQnKTtcbiAqICAgICBtaXhwYW5lbC50cmFjaygnUmVnaXN0ZXJlZCcsIHsnR2VuZGVyJzogJ01hbGUnLCAnQWdlJzogMjF9KTtcbiAqXG4gKiBXaGVuIGNhbGxlZCBmb3IgYSBwYXJ0aWN1bGFyIGV2ZW50IG5hbWUsIHRoZSBuZXh0IHRyYWNrIGNhbGwgZm9yIHRoYXQgZXZlbnRcbiAqIG5hbWUgd2lsbCBpbmNsdWRlIHRoZSBlbGFwc2VkIHRpbWUgYmV0d2VlbiB0aGUgJ3RpbWVfZXZlbnQnIGFuZCAndHJhY2snXG4gKiBjYWxscy4gVGhpcyB2YWx1ZSBpcyBzdG9yZWQgYXMgc2Vjb25kcyBpbiB0aGUgJyRkdXJhdGlvbicgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50X25hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUudGltZV9ldmVudCA9IGZ1bmN0aW9uKGV2ZW50X25hbWUpIHtcbiAgICBpZiAoXy5pc1VuZGVmaW5lZChldmVudF9uYW1lKSkge1xuICAgICAgICB0aGlzLnJlcG9ydF9lcnJvcignTm8gZXZlbnQgbmFtZSBwcm92aWRlZCB0byBtaXhwYW5lbC50aW1lX2V2ZW50Jyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRfaXNfZGlzYWJsZWQoZXZlbnRfbmFtZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10uc2V0X2V2ZW50X3RpbWVyKGV2ZW50X25hbWUsICBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG59O1xuXG52YXIgUkVHSVNURVJfREVGQVVMVFMgPSB7XG4gICAgJ3BlcnNpc3RlbnQnOiB0cnVlXG59O1xuLyoqXG4gKiBIZWxwZXIgdG8gcGFyc2Ugb3B0aW9ucyBwYXJhbSBmb3IgcmVnaXN0ZXIgbWV0aG9kcywgbWFpbnRhaW5pbmdcbiAqIGxlZ2FjeSBzdXBwb3J0IGZvciBwbGFpbiBcImRheXNcIiBwYXJhbSBpbnN0ZWFkIG9mIG9wdGlvbnMgb2JqZWN0XG4gKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IFtkYXlzX29yX29wdGlvbnNdICdkYXlzJyBvcHRpb24gKE51bWJlciksIG9yIE9wdGlvbnMgb2JqZWN0IGZvciByZWdpc3RlciBtZXRob2RzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBvcHRpb25zIG9iamVjdFxuICovXG52YXIgb3B0aW9uc19mb3JfcmVnaXN0ZXIgPSBmdW5jdGlvbihkYXlzX29yX29wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucztcbiAgICBpZiAoXy5pc09iamVjdChkYXlzX29yX29wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBkYXlzX29yX29wdGlvbnM7XG4gICAgfSBlbHNlIGlmICghXy5pc1VuZGVmaW5lZChkYXlzX29yX29wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7J2RheXMnOiBkYXlzX29yX29wdGlvbnN9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIF8uZXh0ZW5kKHt9LCBSRUdJU1RFUl9ERUZBVUxUUywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgc2V0IG9mIHN1cGVyIHByb3BlcnRpZXMsIHdoaWNoIGFyZSBpbmNsdWRlZCB3aXRoIGFsbFxuICogZXZlbnRzLiBUaGlzIHdpbGwgb3ZlcndyaXRlIHByZXZpb3VzIHN1cGVyIHByb3BlcnR5IHZhbHVlcy5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIHJlZ2lzdGVyICdHZW5kZXInIGFzIGEgc3VwZXIgcHJvcGVydHlcbiAqICAgICBtaXhwYW5lbC5yZWdpc3Rlcih7J0dlbmRlcic6ICdGZW1hbGUnfSk7XG4gKlxuICogICAgIC8vIHJlZ2lzdGVyIHNldmVyYWwgc3VwZXIgcHJvcGVydGllcyB3aGVuIGEgdXNlciBzaWducyB1cFxuICogICAgIG1peHBhbmVsLnJlZ2lzdGVyKHtcbiAqICAgICAgICAgJ0VtYWlsJzogJ2pkb2VAZXhhbXBsZS5jb20nLFxuICogICAgICAgICAnQWNjb3VudCBUeXBlJzogJ0ZyZWUnXG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIHJlZ2lzdGVyIG9ubHkgZm9yIHRoZSBjdXJyZW50IHBhZ2Vsb2FkXG4gKiAgICAgbWl4cGFuZWwucmVnaXN0ZXIoeydOYW1lJzogJ1BhdCd9LCB7cGVyc2lzdGVudDogZmFsc2V9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBBbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBwcm9wZXJ0aWVzIHRvIHN0b3JlIGFib3V0IHRoZSB1c2VyXG4gKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IFtkYXlzX29yX29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0IG9yIG51bWJlciBvZiBkYXlzIHNpbmNlIHRoZSB1c2VyJ3MgbGFzdCB2aXNpdCB0byBzdG9yZSB0aGUgc3VwZXIgcHJvcGVydGllcyAob25seSB2YWxpZCBmb3IgcGVyc2lzdGVkIHByb3BzKVxuICogQHBhcmFtIHtib29sZWFufSBbZGF5c19vcl9vcHRpb25zLmRheXNdIC0gbnVtYmVyIG9mIGRheXMgc2luY2UgdGhlIHVzZXIncyBsYXN0IHZpc2l0IHRvIHN0b3JlIHRoZSBzdXBlciBwcm9wZXJ0aWVzIChvbmx5IHZhbGlkIGZvciBwZXJzaXN0ZWQgcHJvcHMpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtkYXlzX29yX29wdGlvbnMucGVyc2lzdGVudD10cnVlXSAtIHdoZXRoZXIgdG8gcHV0IGluIHBlcnNpc3RlbnQgc3RvcmFnZSAoY29va2llL2xvY2FsU3RvcmFnZSlcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24ocHJvcHMsIGRheXNfb3Jfb3B0aW9ucykge1xuICAgIHZhciBvcHRpb25zID0gb3B0aW9uc19mb3JfcmVnaXN0ZXIoZGF5c19vcl9vcHRpb25zKTtcbiAgICBpZiAob3B0aW9uc1sncGVyc2lzdGVudCddKSB7XG4gICAgICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10ucmVnaXN0ZXIocHJvcHMsIG9wdGlvbnNbJ2RheXMnXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgXy5leHRlbmQodGhpcy51bnBlcnNpc3RlZF9zdXBlcnByb3BzLCBwcm9wcyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIHNldCBvZiBzdXBlciBwcm9wZXJ0aWVzIG9ubHkgb25jZS4gVGhpcyB3aWxsIG5vdFxuICogb3ZlcndyaXRlIHByZXZpb3VzIHN1cGVyIHByb3BlcnR5IHZhbHVlcywgdW5saWtlIHJlZ2lzdGVyKCkuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyByZWdpc3RlciBhIHN1cGVyIHByb3BlcnR5IGZvciB0aGUgZmlyc3QgdGltZSBvbmx5XG4gKiAgICAgbWl4cGFuZWwucmVnaXN0ZXJfb25jZSh7XG4gKiAgICAgICAgICdGaXJzdCBMb2dpbiBEYXRlJzogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIHJlZ2lzdGVyIG9uY2UsIG9ubHkgZm9yIHRoZSBjdXJyZW50IHBhZ2Vsb2FkXG4gKiAgICAgbWl4cGFuZWwucmVnaXN0ZXJfb25jZSh7XG4gKiAgICAgICAgICdGaXJzdCBpbnRlcmFjdGlvbiB0aW1lJzogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gKiAgICAgfSwgJ05vbmUnLCB7cGVyc2lzdGVudDogZmFsc2V9KTtcbiAqXG4gKiAjIyMgTm90ZXM6XG4gKlxuICogSWYgZGVmYXVsdF92YWx1ZSBpcyBzcGVjaWZpZWQsIGN1cnJlbnQgc3VwZXIgcHJvcGVydGllc1xuICogd2l0aCB0aGF0IHZhbHVlIHdpbGwgYmUgb3ZlcndyaXR0ZW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgQW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgcHJvcGVydGllcyB0byBzdG9yZSBhYm91dCB0aGUgdXNlclxuICogQHBhcmFtIHsqfSBbZGVmYXVsdF92YWx1ZV0gVmFsdWUgdG8gb3ZlcnJpZGUgaWYgYWxyZWFkeSBzZXQgaW4gc3VwZXIgcHJvcGVydGllcyAoZXg6ICdGYWxzZScpIERlZmF1bHQ6ICdOb25lJ1xuICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBbZGF5c19vcl9vcHRpb25zXSBPcHRpb25zIG9iamVjdCBvciBudW1iZXIgb2YgZGF5cyBzaW5jZSB0aGUgdXNlcidzIGxhc3QgdmlzaXQgdG8gc3RvcmUgdGhlIHN1cGVyIHByb3BlcnRpZXMgKG9ubHkgdmFsaWQgZm9yIHBlcnNpc3RlZCBwcm9wcylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RheXNfb3Jfb3B0aW9ucy5kYXlzXSAtIG51bWJlciBvZiBkYXlzIHNpbmNlIHRoZSB1c2VyJ3MgbGFzdCB2aXNpdCB0byBzdG9yZSB0aGUgc3VwZXIgcHJvcGVydGllcyAob25seSB2YWxpZCBmb3IgcGVyc2lzdGVkIHByb3BzKVxuICogQHBhcmFtIHtib29sZWFufSBbZGF5c19vcl9vcHRpb25zLnBlcnNpc3RlbnQ9dHJ1ZV0gLSB3aGV0aGVyIHRvIHB1dCBpbiBwZXJzaXN0ZW50IHN0b3JhZ2UgKGNvb2tpZS9sb2NhbFN0b3JhZ2UpXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5yZWdpc3Rlcl9vbmNlID0gZnVuY3Rpb24ocHJvcHMsIGRlZmF1bHRfdmFsdWUsIGRheXNfb3Jfb3B0aW9ucykge1xuICAgIHZhciBvcHRpb25zID0gb3B0aW9uc19mb3JfcmVnaXN0ZXIoZGF5c19vcl9vcHRpb25zKTtcbiAgICBpZiAob3B0aW9uc1sncGVyc2lzdGVudCddKSB7XG4gICAgICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10ucmVnaXN0ZXJfb25jZShwcm9wcywgZGVmYXVsdF92YWx1ZSwgb3B0aW9uc1snZGF5cyddKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mKGRlZmF1bHRfdmFsdWUpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZGVmYXVsdF92YWx1ZSA9ICdOb25lJztcbiAgICAgICAgfVxuICAgICAgICBfLmVhY2gocHJvcHMsIGZ1bmN0aW9uKHZhbCwgcHJvcCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnVucGVyc2lzdGVkX3N1cGVycHJvcHMuaGFzT3duUHJvcGVydHkocHJvcCkgfHwgdGhpcy51bnBlcnNpc3RlZF9zdXBlcnByb3BzW3Byb3BdID09PSBkZWZhdWx0X3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bnBlcnNpc3RlZF9zdXBlcnByb3BzW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIERlbGV0ZSBhIHN1cGVyIHByb3BlcnR5IHN0b3JlZCB3aXRoIHRoZSBjdXJyZW50IHVzZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBzdXBlciBwcm9wZXJ0eSB0byByZW1vdmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucGVyc2lzdGVudD10cnVlXSAtIHdoZXRoZXIgdG8gbG9vayBpbiBwZXJzaXN0ZW50IHN0b3JhZ2UgKGNvb2tpZS9sb2NhbFN0b3JhZ2UpXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS51bnJlZ2lzdGVyID0gZnVuY3Rpb24ocHJvcGVydHksIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9uc19mb3JfcmVnaXN0ZXIob3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnNbJ3BlcnNpc3RlbnQnXSkge1xuICAgICAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnVucmVnaXN0ZXIocHJvcGVydHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnVucGVyc2lzdGVkX3N1cGVycHJvcHNbcHJvcGVydHldO1xuICAgIH1cbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fcmVnaXN0ZXJfc2luZ2xlID0gZnVuY3Rpb24ocHJvcCwgdmFsdWUpIHtcbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICBwcm9wc1twcm9wXSA9IHZhbHVlO1xuICAgIHRoaXMucmVnaXN0ZXIocHJvcHMpO1xufTtcblxuLyoqXG4gKiBJZGVudGlmeSBhIHVzZXIgd2l0aCBhIHVuaXF1ZSBJRCB0byB0cmFjayB1c2VyIGFjdGl2aXR5IGFjcm9zc1xuICogZGV2aWNlcywgdGllIGEgdXNlciB0byB0aGVpciBldmVudHMsIGFuZCBjcmVhdGUgYSB1c2VyIHByb2ZpbGUuXG4gKiBJZiB5b3UgbmV2ZXIgY2FsbCB0aGlzIG1ldGhvZCwgdW5pcXVlIHZpc2l0b3JzIGFyZSB0cmFja2VkIHVzaW5nXG4gKiBhIFVVSUQgZ2VuZXJhdGVkIHRoZSBmaXJzdCB0aW1lIHRoZXkgdmlzaXQgdGhlIHNpdGUuXG4gKlxuICogQ2FsbCBpZGVudGlmeSB3aGVuIHlvdSBrbm93IHRoZSBpZGVudGl0eSBvZiB0aGUgY3VycmVudCB1c2VyLFxuICogdHlwaWNhbGx5IGFmdGVyIGxvZ2luIG9yIHNpZ251cC4gV2UgcmVjb21tZW5kIGFnYWluc3QgdXNpbmdcbiAqIGlkZW50aWZ5IGZvciBhbm9ueW1vdXMgdmlzaXRvcnMgdG8geW91ciBzaXRlLlxuICpcbiAqICMjIyBOb3RlczpcbiAqIElmIHlvdXIgcHJvamVjdCBoYXNcbiAqIDxhIGhyZWY9XCJodHRwczovL2hlbHAubWl4cGFuZWwuY29tL2hjL2VuLXVzL2FydGljbGVzLzM2MDAzOTEzMzg1MVwiPklEIE1lcmdlPC9hPlxuICogZW5hYmxlZCwgdGhlIGlkZW50aWZ5IG1ldGhvZCB3aWxsIGNvbm5lY3QgcHJlLSBhbmRcbiAqIHBvc3QtYXV0aGVudGljYXRpb24gZXZlbnRzIHdoZW4gYXBwcm9wcmlhdGUuXG4gKlxuICogSWYgeW91ciBwcm9qZWN0IGRvZXMgbm90IGhhdmUgSUQgTWVyZ2UgZW5hYmxlZCwgaWRlbnRpZnkgd2lsbFxuICogY2hhbmdlIHRoZSB1c2VyJ3MgbG9jYWwgZGlzdGluY3RfaWQgdG8gdGhlIHVuaXF1ZSBJRCB5b3UgcGFzcy5cbiAqIEV2ZW50cyB0cmFja2VkIHByaW9yIHRvIGF1dGhlbnRpY2F0aW9uIHdpbGwgbm90IGJlIGNvbm5lY3RlZFxuICogdG8gdGhlIHNhbWUgdXNlciBpZGVudGl0eS4gSWYgSUQgTWVyZ2UgaXMgZGlzYWJsZWQsIGFsaWFzIGNhblxuICogYmUgdXNlZCB0byBjb25uZWN0IHByZS0gYW5kIHBvc3QtcmVnaXN0cmF0aW9uIGV2ZW50cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3VuaXF1ZV9pZF0gQSBzdHJpbmcgdGhhdCB1bmlxdWVseSBpZGVudGlmaWVzIGEgdXNlci4gSWYgbm90IHByb3ZpZGVkLCB0aGUgZGlzdGluY3RfaWQgY3VycmVudGx5IGluIHRoZSBwZXJzaXN0ZW50IHN0b3JlIChjb29raWUgb3IgbG9jYWxTdG9yYWdlKSB3aWxsIGJlIHVzZWQuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5pZGVudGlmeSA9IGZ1bmN0aW9uKFxuICAgIG5ld19kaXN0aW5jdF9pZCwgX3NldF9jYWxsYmFjaywgX2FkZF9jYWxsYmFjaywgX2FwcGVuZF9jYWxsYmFjaywgX3NldF9vbmNlX2NhbGxiYWNrLCBfdW5pb25fY2FsbGJhY2ssIF91bnNldF9jYWxsYmFjaywgX3JlbW92ZV9jYWxsYmFja1xuKSB7XG4gICAgLy8gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICAgIC8vICBfc2V0X2NhbGxiYWNrOmZ1bmN0aW9uICBBIGNhbGxiYWNrIHRvIGJlIHJ1biBpZiBhbmQgd2hlbiB0aGUgUGVvcGxlIHNldCBxdWV1ZSBpcyBmbHVzaGVkXG4gICAgLy8gIF9hZGRfY2FsbGJhY2s6ZnVuY3Rpb24gIEEgY2FsbGJhY2sgdG8gYmUgcnVuIGlmIGFuZCB3aGVuIHRoZSBQZW9wbGUgYWRkIHF1ZXVlIGlzIGZsdXNoZWRcbiAgICAvLyAgX2FwcGVuZF9jYWxsYmFjazpmdW5jdGlvbiAgQSBjYWxsYmFjayB0byBiZSBydW4gaWYgYW5kIHdoZW4gdGhlIFBlb3BsZSBhcHBlbmQgcXVldWUgaXMgZmx1c2hlZFxuICAgIC8vICBfc2V0X29uY2VfY2FsbGJhY2s6ZnVuY3Rpb24gIEEgY2FsbGJhY2sgdG8gYmUgcnVuIGlmIGFuZCB3aGVuIHRoZSBQZW9wbGUgc2V0X29uY2UgcXVldWUgaXMgZmx1c2hlZFxuICAgIC8vICBfdW5pb25fY2FsbGJhY2s6ZnVuY3Rpb24gIEEgY2FsbGJhY2sgdG8gYmUgcnVuIGlmIGFuZCB3aGVuIHRoZSBQZW9wbGUgdW5pb24gcXVldWUgaXMgZmx1c2hlZFxuICAgIC8vICBfdW5zZXRfY2FsbGJhY2s6ZnVuY3Rpb24gIEEgY2FsbGJhY2sgdG8gYmUgcnVuIGlmIGFuZCB3aGVuIHRoZSBQZW9wbGUgdW5zZXQgcXVldWUgaXMgZmx1c2hlZFxuXG4gICAgdmFyIHByZXZpb3VzX2Rpc3RpbmN0X2lkID0gdGhpcy5nZXRfZGlzdGluY3RfaWQoKTtcbiAgICBpZiAobmV3X2Rpc3RpbmN0X2lkICYmIHByZXZpb3VzX2Rpc3RpbmN0X2lkICE9PSBuZXdfZGlzdGluY3RfaWQpIHtcbiAgICAgICAgLy8gd2UgYWxsb3cgdGhlIGZvbGxvd2luZyBjb25kaXRpb24gaWYgcHJldmlvdXMgZGlzdGluY3RfaWQgaXMgc2FtZSBhcyBuZXdfZGlzdGluY3RfaWRcbiAgICAgICAgLy8gc28gdGhhdCB5b3UgY2FuIGZvcmNlIGZsdXNoIHBlb3BsZSB1cGRhdGVzIGZvciBhbm9ueW1vdXMgcHJvZmlsZXMuXG4gICAgICAgIGlmICh0eXBlb2YgbmV3X2Rpc3RpbmN0X2lkID09PSAnc3RyaW5nJyAmJiBuZXdfZGlzdGluY3RfaWQuaW5kZXhPZihERVZJQ0VfSURfUFJFRklYKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoJ2Rpc3RpbmN0X2lkIGNhbm5vdCBoYXZlICRkZXZpY2U6IHByZWZpeCcpO1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoeyckdXNlcl9pZCc6IG5ld19kaXN0aW5jdF9pZH0pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5nZXRfcHJvcGVydHkoJyRkZXZpY2VfaWQnKSkge1xuICAgICAgICAvLyBUaGUgcGVyc2lzdGVkIGRpc3RpbmN0IGlkIG1pZ2h0IG5vdCBhY3R1YWxseSBiZSBhIGRldmljZSBpZCBhdCBhbGxcbiAgICAgICAgLy8gaXQgbWlnaHQgYmUgYSBkaXN0aW5jdCBpZCBvZiB0aGUgdXNlciBmcm9tIGJlZm9yZVxuICAgICAgICB2YXIgZGV2aWNlX2lkID0gcHJldmlvdXNfZGlzdGluY3RfaWQ7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJfb25jZSh7XG4gICAgICAgICAgICAnJGhhZF9wZXJzaXN0ZWRfZGlzdGluY3RfaWQnOiB0cnVlLFxuICAgICAgICAgICAgJyRkZXZpY2VfaWQnOiBkZXZpY2VfaWRcbiAgICAgICAgfSwgJycpO1xuICAgIH1cblxuICAgIC8vIGlkZW50aWZ5IG9ubHkgY2hhbmdlcyB0aGUgZGlzdGluY3QgaWQgaWYgaXQgZG9lc24ndCBtYXRjaCBlaXRoZXIgdGhlIGV4aXN0aW5nIG9yIHRoZSBhbGlhcztcbiAgICAvLyBpZiBpdCdzIG5ldywgYmxvdyBhd2F5IHRoZSBhbGlhcyBhcyB3ZWxsLlxuICAgIGlmIChuZXdfZGlzdGluY3RfaWQgIT09IHByZXZpb3VzX2Rpc3RpbmN0X2lkICYmIG5ld19kaXN0aW5jdF9pZCAhPT0gdGhpcy5nZXRfcHJvcGVydHkoQUxJQVNfSURfS0VZKSkge1xuICAgICAgICB0aGlzLnVucmVnaXN0ZXIoQUxJQVNfSURfS0VZKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih7J2Rpc3RpbmN0X2lkJzogbmV3X2Rpc3RpbmN0X2lkfSk7XG4gICAgfVxuICAgIHRoaXMuX2ZsYWdzLmlkZW50aWZ5X2NhbGxlZCA9IHRydWU7XG4gICAgLy8gRmx1c2ggYW55IHF1ZXVlZCB1cCBwZW9wbGUgcmVxdWVzdHNcbiAgICB0aGlzWydwZW9wbGUnXS5fZmx1c2goX3NldF9jYWxsYmFjaywgX2FkZF9jYWxsYmFjaywgX2FwcGVuZF9jYWxsYmFjaywgX3NldF9vbmNlX2NhbGxiYWNrLCBfdW5pb25fY2FsbGJhY2ssIF91bnNldF9jYWxsYmFjaywgX3JlbW92ZV9jYWxsYmFjayk7XG5cbiAgICAvLyBzZW5kIGFuICRpZGVudGlmeSBldmVudCBhbnkgdGltZSB0aGUgZGlzdGluY3RfaWQgaXMgY2hhbmdpbmcgLSBsb2dpYyBvbiB0aGUgc2VydmVyXG4gICAgLy8gd2lsbCBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgdG8gZG8gYW55dGhpbmcgd2l0aCBpdC5cbiAgICBpZiAobmV3X2Rpc3RpbmN0X2lkICE9PSBwcmV2aW91c19kaXN0aW5jdF9pZCkge1xuICAgICAgICB0aGlzLnRyYWNrKCckaWRlbnRpZnknLCB7XG4gICAgICAgICAgICAnZGlzdGluY3RfaWQnOiBuZXdfZGlzdGluY3RfaWQsXG4gICAgICAgICAgICAnJGFub25fZGlzdGluY3RfaWQnOiBwcmV2aW91c19kaXN0aW5jdF9pZFxuICAgICAgICB9LCB7c2tpcF9ob29rczogdHJ1ZX0pO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZlYXR1cmUgZmxhZ3MgYWdhaW4gaWYgZGlzdGluY3QgaWQgaGFzIGNoYW5nZWRcbiAgICBpZiAobmV3X2Rpc3RpbmN0X2lkICE9PSBwcmV2aW91c19kaXN0aW5jdF9pZCkge1xuICAgICAgICB0aGlzLmZsYWdzLmZldGNoRmxhZ3MoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENsZWFycyBzdXBlciBwcm9wZXJ0aWVzIGFuZCBnZW5lcmF0ZXMgYSBuZXcgcmFuZG9tIGRpc3RpbmN0X2lkIGZvciB0aGlzIGluc3RhbmNlLlxuICogVXNlZnVsIGZvciBjbGVhcmluZyBkYXRhIHdoZW4gYSB1c2VyIGxvZ3Mgb3V0LlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0b3Bfc2Vzc2lvbl9yZWNvcmRpbmcoKTtcbiAgICB0aGlzWydwZXJzaXN0ZW5jZSddLmNsZWFyKCk7XG4gICAgdGhpcy5fZmxhZ3MuaWRlbnRpZnlfY2FsbGVkID0gZmFsc2U7XG4gICAgdmFyIHV1aWQgPSBfLlVVSUQoKTtcbiAgICB0aGlzLnJlZ2lzdGVyX29uY2Uoe1xuICAgICAgICAnZGlzdGluY3RfaWQnOiBERVZJQ0VfSURfUFJFRklYICsgdXVpZCxcbiAgICAgICAgJyRkZXZpY2VfaWQnOiB1dWlkXG4gICAgfSwgJycpO1xuICAgIHRoaXMuX2NoZWNrX2FuZF9zdGFydF9zZXNzaW9uX3JlY29yZGluZygpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IGRpc3RpbmN0IGlkIG9mIHRoZSB1c2VyLiBUaGlzIGlzIGVpdGhlciB0aGUgaWQgYXV0b21hdGljYWxseVxuICogZ2VuZXJhdGVkIGJ5IHRoZSBsaWJyYXJ5IG9yIHRoZSBpZCB0aGF0IGhhcyBiZWVuIHBhc3NlZCBieSBhIGNhbGwgdG8gaWRlbnRpZnkoKS5cbiAqXG4gKiAjIyMgTm90ZXM6XG4gKlxuICogZ2V0X2Rpc3RpbmN0X2lkKCkgY2FuIG9ubHkgYmUgY2FsbGVkIGFmdGVyIHRoZSBNaXhwYW5lbCBsaWJyYXJ5IGhhcyBmaW5pc2hlZCBsb2FkaW5nLlxuICogaW5pdCgpIGhhcyBhIGxvYWRlZCBmdW5jdGlvbiBhdmFpbGFibGUgdG8gaGFuZGxlIHRoaXMgYXV0b21hdGljYWxseS4gRm9yIGV4YW1wbGU6XG4gKlxuICogICAgIC8vIHNldCBkaXN0aW5jdF9pZCBhZnRlciB0aGUgbWl4cGFuZWwgbGlicmFyeSBoYXMgbG9hZGVkXG4gKiAgICAgbWl4cGFuZWwuaW5pdCgnWU9VUiBQUk9KRUNUIFRPS0VOJywge1xuICogICAgICAgICBsb2FkZWQ6IGZ1bmN0aW9uKG1peHBhbmVsKSB7XG4gKiAgICAgICAgICAgICBkaXN0aW5jdF9pZCA9IG1peHBhbmVsLmdldF9kaXN0aW5jdF9pZCgpO1xuICogICAgICAgICB9XG4gKiAgICAgfSk7XG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfZGlzdGluY3RfaWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRfcHJvcGVydHkoJ2Rpc3RpbmN0X2lkJyk7XG59O1xuXG4vKipcbiAqIFRoZSBhbGlhcyBtZXRob2QgY3JlYXRlcyBhbiBhbGlhcyB3aGljaCBNaXhwYW5lbCB3aWxsIHVzZSB0b1xuICogcmVtYXAgb25lIGlkIHRvIGFub3RoZXIuIE11bHRpcGxlIGFsaWFzZXMgY2FuIHBvaW50IHRvIHRoZVxuICogc2FtZSBpZGVudGlmaWVyLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgaXMgYSB2YWxpZCB1c2Ugb2YgYWxpYXM6XG4gKlxuICogICAgIG1peHBhbmVsLmFsaWFzKCduZXdfaWQnLCAnZXhpc3RpbmdfaWQnKTtcbiAqICAgICAvLyBZb3UgY2FuIGFkZCBtdWx0aXBsZSBpZCBhbGlhc2VzIHRvIHRoZSBleGlzdGluZyBJRFxuICogICAgIG1peHBhbmVsLmFsaWFzKCduZXdlcl9pZCcsICdleGlzdGluZ19pZCcpO1xuICpcbiAqIEFsaWFzZXMgY2FuIGFsc28gYmUgY2hhaW5lZCAtIHRoZSBmb2xsb3dpbmcgaXMgYSB2YWxpZCBleGFtcGxlOlxuICpcbiAqICAgICBtaXhwYW5lbC5hbGlhcygnbmV3X2lkJywgJ2V4aXN0aW5nX2lkJyk7XG4gKiAgICAgLy8gY2hhaW4gbmV3ZXJfaWQgLSBuZXdfaWQgLSBleGlzdGluZ19pZFxuICogICAgIG1peHBhbmVsLmFsaWFzKCduZXdlcl9pZCcsICduZXdfaWQnKTtcbiAqXG4gKiBBbGlhc2VzIGNhbm5vdCBwb2ludCB0byBtdWx0aXBsZSBpZGVudGlmaWVycyAtIHRoZSBmb2xsb3dpbmdcbiAqIGV4YW1wbGUgd2lsbCBub3Qgd29yazpcbiAqXG4gKiAgICAgbWl4cGFuZWwuYWxpYXMoJ25ld19pZCcsICdleGlzdGluZ19pZCcpO1xuICogICAgIC8vIHRoaXMgaXMgaW52YWxpZCBhcyAnbmV3X2lkJyBhbHJlYWR5IHBvaW50cyB0byAnZXhpc3RpbmdfaWQnXG4gKiAgICAgbWl4cGFuZWwuYWxpYXMoJ25ld19pZCcsICduZXdlcl9pZCcpO1xuICpcbiAqICMjIyBOb3RlczpcbiAqXG4gKiBJZiB5b3VyIHByb2plY3QgZG9lcyBub3QgaGF2ZVxuICogPGEgaHJlZj1cImh0dHBzOi8vaGVscC5taXhwYW5lbC5jb20vaGMvZW4tdXMvYXJ0aWNsZXMvMzYwMDM5MTMzODUxXCI+SUQgTWVyZ2U8L2E+XG4gKiBlbmFibGVkLCB0aGUgYmVzdCBwcmFjdGljZSBpcyB0byBjYWxsIGFsaWFzIG9uY2Ugd2hlbiBhIHVuaXF1ZVxuICogSUQgaXMgZmlyc3QgY3JlYXRlZCBmb3IgYSB1c2VyIChlLmcuLCB3aGVuIGEgdXNlciBmaXJzdCByZWdpc3RlcnNcbiAqIGZvciBhbiBhY2NvdW50KS4gRG8gbm90IHVzZSBhbGlhcyBtdWx0aXBsZSB0aW1lcyBmb3IgYSBzaW5nbGVcbiAqIHVzZXIgd2l0aG91dCBJRCBNZXJnZSBlbmFibGVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhbGlhcyBBIHVuaXF1ZSBpZGVudGlmaWVyIHRoYXQgeW91IHdhbnQgdG8gdXNlIGZvciB0aGlzIHVzZXIgaW4gdGhlIGZ1dHVyZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3JpZ2luYWxdIFRoZSBjdXJyZW50IGlkZW50aWZpZXIgYmVpbmcgdXNlZCBmb3IgdGhpcyB1c2VyLlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuYWxpYXMgPSBmdW5jdGlvbihhbGlhcywgb3JpZ2luYWwpIHtcbiAgICAvLyBJZiB0aGUgJHBlb3BsZV9kaXN0aW5jdF9pZCBrZXkgZXhpc3RzIGluIHBlcnNpc3RlbmNlLCB0aGVyZSBoYXMgYmVlbiBhIHByZXZpb3VzXG4gICAgLy8gbWl4cGFuZWwucGVvcGxlLmlkZW50aWZ5KCkgY2FsbCBtYWRlIGZvciB0aGlzIHVzZXIuIEl0IGlzIFZFUlkgQkFEIHRvIG1ha2UgYW4gYWxpYXMgd2l0aFxuICAgIC8vIHRoaXMgSUQsIGFzIGl0IHdpbGwgZHVwbGljYXRlIHVzZXJzLlxuICAgIGlmIChhbGlhcyA9PT0gdGhpcy5nZXRfcHJvcGVydHkoUEVPUExFX0RJU1RJTkNUX0lEX0tFWSkpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoJ0F0dGVtcHRpbmcgdG8gY3JlYXRlIGFsaWFzIGZvciBleGlzdGluZyBQZW9wbGUgdXNlciAtIGFib3J0aW5nLicpO1xuICAgICAgICByZXR1cm4gLTI7XG4gICAgfVxuXG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAoXy5pc1VuZGVmaW5lZChvcmlnaW5hbCkpIHtcbiAgICAgICAgb3JpZ2luYWwgPSB0aGlzLmdldF9kaXN0aW5jdF9pZCgpO1xuICAgIH1cbiAgICBpZiAoYWxpYXMgIT09IG9yaWdpbmFsKSB7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyX3NpbmdsZShBTElBU19JRF9LRVksIGFsaWFzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhY2soJyRjcmVhdGVfYWxpYXMnLCB7XG4gICAgICAgICAgICAnYWxpYXMnOiBhbGlhcyxcbiAgICAgICAgICAgICdkaXN0aW5jdF9pZCc6IG9yaWdpbmFsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHNraXBfaG9va3M6IHRydWVcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBGbHVzaCB0aGUgcGVvcGxlIHF1ZXVlXG4gICAgICAgICAgICBfdGhpcy5pZGVudGlmeShhbGlhcyk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdhbGlhcyBtYXRjaGVzIGN1cnJlbnQgZGlzdGluY3RfaWQgLSBza2lwcGluZyBhcGkgY2FsbC4nKTtcbiAgICAgICAgdGhpcy5pZGVudGlmeShhbGlhcyk7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFByb3ZpZGUgYSBzdHJpbmcgdG8gcmVjb2duaXplIHRoZSB1c2VyIGJ5LiBUaGUgc3RyaW5nIHBhc3NlZCB0b1xuICogdGhpcyBtZXRob2Qgd2lsbCBhcHBlYXIgaW4gdGhlIE1peHBhbmVsIFN0cmVhbXMgcHJvZHVjdCByYXRoZXJcbiAqIHRoYW4gYW4gYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgbmFtZS4gTmFtZSB0YWdzIGRvIG5vdCBoYXZlIHRvXG4gKiBiZSB1bmlxdWUuXG4gKlxuICogVGhpcyB2YWx1ZSB3aWxsIG9ubHkgYmUgaW5jbHVkZWQgaW4gU3RyZWFtcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lX3RhZyBBIGh1bWFuIHJlYWRhYmxlIG5hbWUgZm9yIHRoZSB1c2VyXG4gKiBAZGVwcmVjYXRlZFxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUubmFtZV90YWcgPSBmdW5jdGlvbihuYW1lX3RhZykge1xuICAgIHRoaXMuX3JlZ2lzdGVyX3NpbmdsZSgnbXBfbmFtZV90YWcnLCBuYW1lX3RhZyk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgY29uZmlndXJhdGlvbiBvZiBhIG1peHBhbmVsIGxpYnJhcnkgaW5zdGFuY2UuXG4gKlxuICogVGhlIGRlZmF1bHQgY29uZmlnIGlzOlxuICpcbiAqICAgICB7XG4gKiAgICAgICAvLyBob3N0IGZvciByZXF1ZXN0cyAoY3VzdG9taXphYmxlIGZvciBlLmcuIGEgbG9jYWwgcHJveHkpXG4gKiAgICAgICBhcGlfaG9zdDogJ2h0dHBzOi8vYXBpLWpzLm1peHBhbmVsLmNvbScsXG4gKlxuICogICAgICAgLy8gZW5kcG9pbnRzIGZvciBkaWZmZXJlbnQgdHlwZXMgb2YgcmVxdWVzdHNcbiAqICAgICAgIGFwaV9yb3V0ZXM6IHtcbiAqICAgICAgICAgdHJhY2s6ICd0cmFjay8nLFxuICogICAgICAgICBlbmdhZ2U6ICdlbmdhZ2UvJyxcbiAqICAgICAgICAgZ3JvdXBzOiAnZ3JvdXBzLycsXG4gKiAgICAgICB9XG4gKlxuICogICAgICAgLy8gSFRUUCBtZXRob2QgZm9yIHRyYWNraW5nIHJlcXVlc3RzXG4gKiAgICAgICBhcGlfbWV0aG9kOiAnUE9TVCdcbiAqXG4gKiAgICAgICAvLyB0cmFuc3BvcnQgZm9yIHNlbmRpbmcgcmVxdWVzdHMgKCdYSFInIG9yICdzZW5kQmVhY29uJylcbiAqICAgICAgIC8vIE5COiBzZW5kQmVhY29uIHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIHNjZW5hcmlvcyBzdWNoIGFzXG4gKiAgICAgICAvLyBwYWdlIHVubG9hZCB3aGVyZSBhIFwiYmVzdC1lZmZvcnRcIiBhdHRlbXB0IHRvIHNlbmQgaXNcbiAqICAgICAgIC8vIGFjY2VwdGFibGU7IHRoZSBzZW5kQmVhY29uIEFQSSBkb2VzIG5vdCBzdXBwb3J0IGNhbGxiYWNrc1xuICogICAgICAgLy8gb3IgYW55IHdheSB0byBrbm93IHRoZSByZXN1bHQgb2YgdGhlIHJlcXVlc3QuIE1peHBhbmVsXG4gKiAgICAgICAvLyB0cmFja2luZyB2aWEgc2VuZEJlYWNvbiB3aWxsIG5vdCBzdXBwb3J0IGFueSBldmVudC1cbiAqICAgICAgIC8vIGJhdGNoaW5nIG9yIHJldHJ5IG1lY2hhbmlzbXMuXG4gKiAgICAgICBhcGlfdHJhbnNwb3J0OiAnWEhSJ1xuICpcbiAqICAgICAgIC8vIHJlcXVlc3QtYmF0Y2hpbmcvcXVldWVpbmcvcmV0cnlcbiAqICAgICAgIGJhdGNoX3JlcXVlc3RzOiB0cnVlLFxuICpcbiAqICAgICAgIC8vIG1heGltdW0gbnVtYmVyIG9mIGV2ZW50cy91cGRhdGVzIHRvIHNlbmQgaW4gYSBzaW5nbGVcbiAqICAgICAgIC8vIG5ldHdvcmsgcmVxdWVzdFxuICogICAgICAgYmF0Y2hfc2l6ZTogNTAsXG4gKlxuICogICAgICAgLy8gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmV0d2VlbiBzZW5kaW5nIGJhdGNoIHJlcXVlc3RzXG4gKiAgICAgICBiYXRjaF9mbHVzaF9pbnRlcnZhbF9tczogNTAwMCxcbiAqXG4gKiAgICAgICAvLyBtaWxsaXNlY29uZHMgdG8gd2FpdCBmb3IgbmV0d29yayByZXNwb25zZXMgdG8gYmF0Y2ggcmVxdWVzdHNcbiAqICAgICAgIC8vIGJlZm9yZSB0aGV5IGFyZSBjb25zaWRlcmVkIHRpbWVkLW91dCBhbmQgcmV0cmllZFxuICogICAgICAgYmF0Y2hfcmVxdWVzdF90aW1lb3V0X21zOiA5MDAwMCxcbiAqXG4gKiAgICAgICAvLyBvdmVycmlkZSB2YWx1ZSBmb3IgY29va2llIGRvbWFpbiwgb25seSB1c2VmdWwgZm9yIGVuc3VyaW5nXG4gKiAgICAgICAvLyBjb3JyZWN0IGNyb3NzLXN1YmRvbWFpbiBjb29raWVzIG9uIHVudXN1YWwgZG9tYWlucyBsaWtlXG4gKiAgICAgICAvLyBzdWJkb21haW4ubWFpbnNpdGUuYXZvY2F0LmZyOyBOQiB0aGlzIGNhbm5vdCBiZSB1c2VkIHRvXG4gKiAgICAgICAvLyBzZXQgY29va2llcyBvbiBhIGRpZmZlcmVudCBkb21haW4gdGhhbiB0aGUgY3VycmVudCBvcmlnaW5cbiAqICAgICAgIGNvb2tpZV9kb21haW46ICcnXG4gKlxuICogICAgICAgLy8gc3VwZXIgcHJvcGVydGllcyBjb29raWUgZXhwaXJhdGlvbiAoaW4gZGF5cylcbiAqICAgICAgIGNvb2tpZV9leHBpcmF0aW9uOiAzNjVcbiAqXG4gKiAgICAgICAvLyBpZiB0cnVlLCBjb29raWUgd2lsbCBiZSBzZXQgd2l0aCBTYW1lU2l0ZT1Ob25lOyBTZWN1cmVcbiAqICAgICAgIC8vIHRoaXMgaXMgb25seSB1c2VmdWwgaW4gc3BlY2lhbCBzaXR1YXRpb25zLCBsaWtlIGVtYmVkZGVkXG4gKiAgICAgICAvLyAzcmQtcGFydHkgaWZyYW1lcyB0aGF0IHNldCB1cCBhIE1peHBhbmVsIGluc3RhbmNlXG4gKiAgICAgICBjcm9zc19zaXRlX2Nvb2tpZTogZmFsc2VcbiAqXG4gKiAgICAgICAvLyBzdXBlciBwcm9wZXJ0aWVzIHNwYW4gc3ViZG9tYWluc1xuICogICAgICAgY3Jvc3Nfc3ViZG9tYWluX2Nvb2tpZTogdHJ1ZVxuICpcbiAqICAgICAgIC8vIGRlYnVnIG1vZGVcbiAqICAgICAgIGRlYnVnOiBmYWxzZVxuICpcbiAqICAgICAgIC8vIGlmIHRoaXMgaXMgdHJ1ZSwgdGhlIG1peHBhbmVsIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2UgZW50cnlcbiAqICAgICAgIC8vIHdpbGwgYmUgZGVsZXRlZCwgYW5kIG5vIHVzZXIgcGVyc2lzdGVuY2Ugd2lsbCB0YWtlIHBsYWNlXG4gKiAgICAgICBkaXNhYmxlX3BlcnNpc3RlbmNlOiBmYWxzZVxuICpcbiAqICAgICAgIC8vIGlmIHRoaXMgaXMgdHJ1ZSwgTWl4cGFuZWwgd2lsbCBhdXRvbWF0aWNhbGx5IGRldGVybWluZVxuICogICAgICAgLy8gQ2l0eSwgUmVnaW9uIGFuZCBDb3VudHJ5IGRhdGEgdXNpbmcgdGhlIElQIGFkZHJlc3Mgb2ZcbiAqICAgICAgIC8vdGhlIGNsaWVudFxuICogICAgICAgaXA6IHRydWVcbiAqXG4gKiAgICAgICAvLyBvcHQgdXNlcnMgb3V0IG9mIHRyYWNraW5nIGJ5IHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UgYnkgZGVmYXVsdFxuICogICAgICAgb3B0X291dF90cmFja2luZ19ieV9kZWZhdWx0OiBmYWxzZVxuICpcbiAqICAgICAgIC8vIG9wdCB1c2VycyBvdXQgb2YgYnJvd3NlciBkYXRhIHN0b3JhZ2UgYnkgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSBieSBkZWZhdWx0XG4gKiAgICAgICBvcHRfb3V0X3BlcnNpc3RlbmNlX2J5X2RlZmF1bHQ6IGZhbHNlXG4gKlxuICogICAgICAgLy8gcGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgYnkgb3B0LWluL29wdC1vdXQgbWV0aG9kcyAtIGNvb2tpZVxuICogICAgICAgLy8gb3IgbG9jYWxTdG9yYWdlIC0gZmFsbHMgYmFjayB0byBjb29raWUgaWYgbG9jYWxTdG9yYWdlIGlzIHVuYXZhaWxhYmxlXG4gKiAgICAgICBvcHRfb3V0X3RyYWNraW5nX3BlcnNpc3RlbmNlX3R5cGU6ICdsb2NhbFN0b3JhZ2UnXG4gKlxuICogICAgICAgLy8gY3VzdG9taXplIHRoZSBuYW1lIG9mIGNvb2tpZS9sb2NhbFN0b3JhZ2Ugc2V0IGJ5IG9wdC1pbi9vcHQtb3V0IG1ldGhvZHNcbiAqICAgICAgIG9wdF9vdXRfdHJhY2tpbmdfY29va2llX3ByZWZpeDogbnVsbFxuICpcbiAqICAgICAgIC8vIHR5cGUgb2YgcGVyc2lzdGVudCBzdG9yZSBmb3Igc3VwZXIgcHJvcGVydGllcyAoY29va2llL1xuICogICAgICAgLy8gbG9jYWxTdG9yYWdlKSBpZiBzZXQgdG8gJ2xvY2FsU3RvcmFnZScsIGFueSBleGlzdGluZ1xuICogICAgICAgLy8gbWl4cGFuZWwgY29va2llIHZhbHVlIHdpdGggdGhlIHNhbWUgcGVyc2lzdGVuY2VfbmFtZVxuICogICAgICAgLy8gd2lsbCBiZSB0cmFuc2ZlcnJlZCB0byBsb2NhbFN0b3JhZ2UgYW5kIGRlbGV0ZWRcbiAqICAgICAgIHBlcnNpc3RlbmNlOiAnY29va2llJ1xuICpcbiAqICAgICAgIC8vIG5hbWUgZm9yIHN1cGVyIHByb3BlcnRpZXMgcGVyc2lzdGVudCBzdG9yZVxuICogICAgICAgcGVyc2lzdGVuY2VfbmFtZTogJydcbiAqXG4gKiAgICAgICAvLyBuYW1lcyBvZiBwcm9wZXJ0aWVzL3N1cGVycHJvcGVydGllcyB3aGljaCBzaG91bGQgbmV2ZXJcbiAqICAgICAgIC8vIGJlIHNlbnQgd2l0aCB0cmFjaygpIGNhbGxzXG4gKiAgICAgICBwcm9wZXJ0eV9ibGFja2xpc3Q6IFtdXG4gKlxuICogICAgICAgLy8gaWYgdGhpcyBpcyB0cnVlLCBtaXhwYW5lbCBjb29raWVzIHdpbGwgYmUgbWFya2VkIGFzXG4gKiAgICAgICAvLyBzZWN1cmUsIG1lYW5pbmcgdGhleSB3aWxsIG9ubHkgYmUgdHJhbnNtaXR0ZWQgb3ZlciBodHRwc1xuICogICAgICAgc2VjdXJlX2Nvb2tpZTogZmFsc2VcbiAqXG4gKiAgICAgICAvLyBkaXNhYmxlcyBlbnJpY2hpbmcgdXNlciBwcm9maWxlcyB3aXRoIGZpcnN0IHRvdWNoIG1hcmtldGluZyBkYXRhXG4gKiAgICAgICBza2lwX2ZpcnN0X3RvdWNoX21hcmtldGluZzogZmFsc2VcbiAqXG4gKiAgICAgICAvLyB0aGUgYW1vdW50IG9mIHRpbWUgdHJhY2tfbGlua3Mgd2lsbFxuICogICAgICAgLy8gd2FpdCBmb3IgTWl4cGFuZWwncyBzZXJ2ZXJzIHRvIHJlc3BvbmRcbiAqICAgICAgIHRyYWNrX2xpbmtzX3RpbWVvdXQ6IDMwMFxuICpcbiAqICAgICAgIC8vIGFkZHMgYW55IFVUTSBwYXJhbWV0ZXJzIGFuZCBjbGljayBJRHMgcHJlc2VudCBvbiB0aGUgcGFnZSB0byBhbnkgZXZlbnRzIGZpcmVkXG4gKiAgICAgICB0cmFja19tYXJrZXRpbmc6IHRydWVcbiAqXG4gKiAgICAgICAvLyBlbmFibGVzIGF1dG9tYXRpYyBwYWdlIHZpZXcgdHJhY2tpbmcgdXNpbmcgZGVmYXVsdCBwYWdlIHZpZXcgZXZlbnRzIHRocm91Z2hcbiAqICAgICAgIC8vIHRoZSB0cmFja19wYWdldmlldygpIG1ldGhvZFxuICogICAgICAgdHJhY2tfcGFnZXZpZXc6IGZhbHNlXG4gKlxuICogICAgICAgLy8gaWYgeW91IHNldCB1cGdyYWRlIHRvIGJlIHRydWUsIHRoZSBsaWJyYXJ5IHdpbGwgY2hlY2sgZm9yXG4gKiAgICAgICAvLyBhIGNvb2tpZSBmcm9tIG91ciBvbGQganMgbGlicmFyeSBhbmQgaW1wb3J0IHN1cGVyXG4gKiAgICAgICAvLyBwcm9wZXJ0aWVzIGZyb20gaXQsIHRoZW4gdGhlIG9sZCBjb29raWUgaXMgZGVsZXRlZFxuICogICAgICAgLy8gVGhlIHVwZ3JhZGUgY29uZmlnIG9wdGlvbiBvbmx5IHdvcmtzIGluIHRoZSBpbml0aWFsaXphdGlvbixcbiAqICAgICAgIC8vIHNvIG1ha2Ugc3VyZSB5b3Ugc2V0IGl0IHdoZW4geW91IGNyZWF0ZSB0aGUgbGlicmFyeS5cbiAqICAgICAgIHVwZ3JhZGU6IGZhbHNlXG4gKlxuICogICAgICAgLy8gZXh0cmEgSFRUUCByZXF1ZXN0IGhlYWRlcnMgdG8gc2V0IGZvciBlYWNoIEFQSSByZXF1ZXN0LCBpblxuICogICAgICAgLy8gdGhlIGZvcm1hdCB7J0hlYWRlci1OYW1lJzogdmFsdWV9XG4gKiAgICAgICB4aHJfaGVhZGVyczoge31cbiAqXG4gKiAgICAgICAvLyB3aGV0aGVyIHRvIGlnbm9yZSBvciByZXNwZWN0IHRoZSB3ZWIgYnJvd3NlcidzIERvIE5vdCBUcmFjayBzZXR0aW5nXG4gKiAgICAgICBpZ25vcmVfZG50OiBmYWxzZVxuICogICAgIH1cbiAqXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBBIGRpY3Rpb25hcnkgb2YgbmV3IGNvbmZpZ3VyYXRpb24gdmFsdWVzIHRvIHVwZGF0ZVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuc2V0X2NvbmZpZyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIGlmIChfLmlzT2JqZWN0KGNvbmZpZykpIHtcbiAgICAgICAgXy5leHRlbmQodGhpc1snY29uZmlnJ10sIGNvbmZpZyk7XG5cbiAgICAgICAgdmFyIG5ld19iYXRjaF9zaXplID0gY29uZmlnWydiYXRjaF9zaXplJ107XG4gICAgICAgIGlmIChuZXdfYmF0Y2hfc2l6ZSkge1xuICAgICAgICAgICAgXy5lYWNoKHRoaXMucmVxdWVzdF9iYXRjaGVycywgZnVuY3Rpb24oYmF0Y2hlcikge1xuICAgICAgICAgICAgICAgIGJhdGNoZXIucmVzZXRCYXRjaFNpemUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmdldF9jb25maWcoJ3BlcnNpc3RlbmNlX25hbWUnKSkge1xuICAgICAgICAgICAgdGhpc1snY29uZmlnJ11bJ3BlcnNpc3RlbmNlX25hbWUnXSA9IHRoaXNbJ2NvbmZpZyddWydjb29raWVfbmFtZSddO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5nZXRfY29uZmlnKCdkaXNhYmxlX3BlcnNpc3RlbmNlJykpIHtcbiAgICAgICAgICAgIHRoaXNbJ2NvbmZpZyddWydkaXNhYmxlX3BlcnNpc3RlbmNlJ10gPSB0aGlzWydjb25maWcnXVsnZGlzYWJsZV9jb29raWUnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzWydwZXJzaXN0ZW5jZSddKSB7XG4gICAgICAgICAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnVwZGF0ZV9jb25maWcodGhpc1snY29uZmlnJ10pO1xuICAgICAgICB9XG4gICAgICAgIENvbmZpZy5ERUJVRyA9IENvbmZpZy5ERUJVRyB8fCB0aGlzLmdldF9jb25maWcoJ2RlYnVnJyk7XG5cbiAgICAgICAgaWYgKCgnYXV0b2NhcHR1cmUnIGluIGNvbmZpZyB8fCAncmVjb3JkX2hlYXRtYXBfZGF0YScgaW4gY29uZmlnKSAmJiB0aGlzLmF1dG9jYXB0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLmF1dG9jYXB0dXJlLmluaXQoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogcmV0dXJucyB0aGUgY3VycmVudCBjb25maWcgb2JqZWN0IGZvciB0aGUgbGlicmFyeS5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9jb25maWcgPSBmdW5jdGlvbihwcm9wX25hbWUpIHtcbiAgICByZXR1cm4gdGhpc1snY29uZmlnJ11bcHJvcF9uYW1lXTtcbn07XG5cbi8qKlxuICogRmV0Y2ggYSBob29rIGZ1bmN0aW9uIGZyb20gY29uZmlnLCB3aXRoIHNhZmUgZGVmYXVsdCwgYW5kIHJ1biBpdFxuICogYWdhaW5zdCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gaG9va19uYW1lIHdoaWNoIGhvb2sgdG8gcmV0cmlldmVcbiAqIEByZXR1cm5zIHthbnl8bnVsbH0gcmV0dXJuIHZhbHVlIG9mIHVzZXItcHJvdmlkZWQgaG9vaywgb3IgbnVsbCBpZiBub3RoaW5nIHdhcyByZXR1cm5lZFxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX3J1bl9ob29rID0gZnVuY3Rpb24oaG9va19uYW1lKSB7XG4gICAgdmFyIHJldCA9ICh0aGlzWydjb25maWcnXVsnaG9va3MnXVtob29rX25hbWVdIHx8IElERU5USVRZX0ZVTkMpLmFwcGx5KHRoaXMsIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgaWYgKHR5cGVvZiByZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKGhvb2tfbmFtZSArICcgaG9vayBkaWQgbm90IHJldHVybiBhIHZhbHVlJyk7XG4gICAgICAgIHJldCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBzdXBlciBwcm9wZXJ0eSBuYW1lZCBwcm9wZXJ0eV9uYW1lLiBJZiBubyBzdWNoXG4gKiBwcm9wZXJ0eSBpcyBzZXQsIGdldF9wcm9wZXJ0eSgpIHdpbGwgcmV0dXJuIHRoZSB1bmRlZmluZWQgdmFsdWUuXG4gKlxuICogIyMjIE5vdGVzOlxuICpcbiAqIGdldF9wcm9wZXJ0eSgpIGNhbiBvbmx5IGJlIGNhbGxlZCBhZnRlciB0aGUgTWl4cGFuZWwgbGlicmFyeSBoYXMgZmluaXNoZWQgbG9hZGluZy5cbiAqIGluaXQoKSBoYXMgYSBsb2FkZWQgZnVuY3Rpb24gYXZhaWxhYmxlIHRvIGhhbmRsZSB0aGlzIGF1dG9tYXRpY2FsbHkuIEZvciBleGFtcGxlOlxuICpcbiAqICAgICAvLyBncmFiIHZhbHVlIGZvciAndXNlcl9pZCcgYWZ0ZXIgdGhlIG1peHBhbmVsIGxpYnJhcnkgaGFzIGxvYWRlZFxuICogICAgIG1peHBhbmVsLmluaXQoJ1lPVVIgUFJPSkVDVCBUT0tFTicsIHtcbiAqICAgICAgICAgbG9hZGVkOiBmdW5jdGlvbihtaXhwYW5lbCkge1xuICogICAgICAgICAgICAgdXNlcl9pZCA9IG1peHBhbmVsLmdldF9wcm9wZXJ0eSgndXNlcl9pZCcpO1xuICogICAgICAgICB9XG4gKiAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5X25hbWUgVGhlIG5hbWUgb2YgdGhlIHN1cGVyIHByb3BlcnR5IHlvdSB3YW50IHRvIHJldHJpZXZlXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfcHJvcGVydHkgPSBmdW5jdGlvbihwcm9wZXJ0eV9uYW1lKSB7XG4gICAgcmV0dXJuIHRoaXNbJ3BlcnNpc3RlbmNlJ10ubG9hZF9wcm9wKFtwcm9wZXJ0eV9uYW1lXSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgQVBJIGhvc3QgZm9yIGEgc3BlY2lmaWMgZW5kcG9pbnQgdHlwZSwgZmFsbGluZyBiYWNrIHRvIHRoZSBkZWZhdWx0IGFwaV9ob3N0IGlmIG5vdCBzcGVjaWZpZWRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5kcG9pbnRfdHlwZSBUaGUgdHlwZSBvZiBlbmRwb2ludCAoZS5nLiwgXCJldmVudHNcIiwgXCJwZW9wbGVcIiwgXCJncm91cHNcIilcbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBBUEkgaG9zdCB0byB1c2UgZm9yIHRoaXMgZW5kcG9pbnRcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9hcGlfaG9zdCA9IGZ1bmN0aW9uKGVuZHBvaW50X3R5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRfY29uZmlnKCdhcGlfaG9zdHMnKVtlbmRwb2ludF90eXBlXSB8fCB0aGlzLmdldF9jb25maWcoJ2FwaV9ob3N0Jyk7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbmFtZSA9IHRoaXMuZ2V0X2NvbmZpZygnbmFtZScpO1xuICAgIGlmIChuYW1lICE9PSBQUklNQVJZX0lOU1RBTkNFX05BTUUpIHtcbiAgICAgICAgbmFtZSA9IFBSSU1BUllfSU5TVEFOQ0VfTkFNRSArICcuJyArIG5hbWU7XG4gICAgfVxuICAgIHJldHVybiBuYW1lO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9ldmVudF9pc19kaXNhYmxlZCA9IGZ1bmN0aW9uKGV2ZW50X25hbWUpIHtcbiAgICByZXR1cm4gXy5pc0Jsb2NrZWRVQSh1c2VyQWdlbnQpIHx8XG4gICAgICAgIHRoaXMuX2ZsYWdzLmRpc2FibGVfYWxsX2V2ZW50cyB8fFxuICAgICAgICBfLmluY2x1ZGUodGhpcy5fX2Rpc2FibGVkX2V2ZW50cywgZXZlbnRfbmFtZSk7XG59O1xuXG4vLyBwZXJmb3JtIHNvbWUgaG91c2VrZWVwaW5nIGFyb3VuZCBHRFBSIG9wdC1pbi9vdXQgc3RhdGVcbk1peHBhbmVsTGliLnByb3RvdHlwZS5fZ2Rwcl9pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlzX2xvY2FsU3RvcmFnZV9yZXF1ZXN0ZWQgPSB0aGlzLmdldF9jb25maWcoJ29wdF9vdXRfdHJhY2tpbmdfcGVyc2lzdGVuY2VfdHlwZScpID09PSAnbG9jYWxTdG9yYWdlJztcblxuICAgIC8vIHRyeSB0byBjb252ZXJ0IG9wdC1pbi9vdXQgY29va2llcyB0byBsb2NhbFN0b3JhZ2UgaWYgcG9zc2libGVcbiAgICBpZiAoaXNfbG9jYWxTdG9yYWdlX3JlcXVlc3RlZCAmJiBfLmxvY2FsU3RvcmFnZS5pc19zdXBwb3J0ZWQoKSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzX29wdGVkX2luX3RyYWNraW5nKCkgJiYgdGhpcy5oYXNfb3B0ZWRfaW5fdHJhY2tpbmcoeydwZXJzaXN0ZW5jZV90eXBlJzogJ2Nvb2tpZSd9KSkge1xuICAgICAgICAgICAgdGhpcy5vcHRfaW5fdHJhY2tpbmcoeydlbmFibGVfcGVyc2lzdGVuY2UnOiBmYWxzZX0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5oYXNfb3B0ZWRfb3V0X3RyYWNraW5nKCkgJiYgdGhpcy5oYXNfb3B0ZWRfb3V0X3RyYWNraW5nKHsncGVyc2lzdGVuY2VfdHlwZSc6ICdjb29raWUnfSkpIHtcbiAgICAgICAgICAgIHRoaXMub3B0X291dF90cmFja2luZyh7J2NsZWFyX3BlcnNpc3RlbmNlJzogZmFsc2V9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyX29wdF9pbl9vdXRfdHJhY2tpbmcoe1xuICAgICAgICAgICAgJ3BlcnNpc3RlbmNlX3R5cGUnOiAnY29va2llJyxcbiAgICAgICAgICAgICdlbmFibGVfcGVyc2lzdGVuY2UnOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSB1c2VyIGhhcyBhbHJlYWR5IG9wdGVkIG91dCAtIGlmIHNvLCBjbGVhciAmIGRpc2FibGUgcGVyc2lzdGVuY2VcbiAgICBpZiAodGhpcy5oYXNfb3B0ZWRfb3V0X3RyYWNraW5nKCkpIHtcbiAgICAgICAgdGhpcy5fZ2Rwcl91cGRhdGVfcGVyc2lzdGVuY2UoeydjbGVhcl9wZXJzaXN0ZW5jZSc6IHRydWV9KTtcblxuICAgIC8vIGNoZWNrIHdoZXRoZXIgd2Ugc2hvdWxkIG9wdCBvdXQgYnkgZGVmYXVsdFxuICAgIC8vIG5vdGU6IHdlIGRvbid0IGNsZWFyIHBlcnNpc3RlbmNlIGhlcmUgYnkgZGVmYXVsdCBzaW5jZSBvcHQtb3V0IGRlZmF1bHQgc3RhdGUgaXMgb2Z0ZW5cbiAgICAvLyAgICAgICB1c2VkIGFzIGFuIGluaXRpYWwgc3RhdGUgd2hpbGUgR0RQUiBpbmZvcm1hdGlvbiBpcyBiZWluZyBjb2xsZWN0ZWRcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmhhc19vcHRlZF9pbl90cmFja2luZygpICYmIChcbiAgICAgICAgdGhpcy5nZXRfY29uZmlnKCdvcHRfb3V0X3RyYWNraW5nX2J5X2RlZmF1bHQnKSB8fCBfLmNvb2tpZS5nZXQoJ21wX29wdG91dCcpXG4gICAgKSkge1xuICAgICAgICBfLmNvb2tpZS5yZW1vdmUoJ21wX29wdG91dCcpO1xuICAgICAgICB0aGlzLm9wdF9vdXRfdHJhY2tpbmcoe1xuICAgICAgICAgICAgJ2NsZWFyX3BlcnNpc3RlbmNlJzogdGhpcy5nZXRfY29uZmlnKCdvcHRfb3V0X3BlcnNpc3RlbmNlX2J5X2RlZmF1bHQnKVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEVuYWJsZSBvciBkaXNhYmxlIHBlcnNpc3RlbmNlIGJhc2VkIG9uIG9wdGlvbnNcbiAqIG9ubHkgZW5hYmxlL2Rpc2FibGUgaWYgcGVyc2lzdGVuY2UgaXMgbm90IGFscmVhZHkgaW4gdGhpcyBzdGF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jbGVhcl9wZXJzaXN0ZW5jZV0gSWYgdHJ1ZSwgd2lsbCBkZWxldGUgYWxsIGRhdGEgc3RvcmVkIGJ5IHRoZSBzZGsgaW4gcGVyc2lzdGVuY2UgYW5kIGRpc2FibGUgaXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZW5hYmxlX3BlcnNpc3RlbmNlXSBJZiB0cnVlLCB3aWxsIHJlLWVuYWJsZSBzZGsgcGVyc2lzdGVuY2VcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9nZHByX3VwZGF0ZV9wZXJzaXN0ZW5jZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgZGlzYWJsZWQ7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9uc1snY2xlYXJfcGVyc2lzdGVuY2UnXSkge1xuICAgICAgICBkaXNhYmxlZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zICYmIG9wdGlvbnNbJ2VuYWJsZV9wZXJzaXN0ZW5jZSddKSB7XG4gICAgICAgIGRpc2FibGVkID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5nZXRfY29uZmlnKCdkaXNhYmxlX3BlcnNpc3RlbmNlJykgJiYgdGhpc1sncGVyc2lzdGVuY2UnXS5kaXNhYmxlZCAhPT0gZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpc1sncGVyc2lzdGVuY2UnXS5zZXRfZGlzYWJsZWQoZGlzYWJsZWQpO1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICB0aGlzLnN0b3BfYmF0Y2hfc2VuZGVycygpO1xuICAgICAgICB0aGlzLnN0b3Bfc2Vzc2lvbl9yZWNvcmRpbmcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvbmx5IHN0YXJ0IGJhdGNoZXJzIGFmdGVyIG9wdC1pbiBpZiB0aGV5IGhhdmUgcHJldmlvdXNseSBiZWVuIHN0YXJ0ZWRcbiAgICAgICAgLy8gaW4gb3JkZXIgdG8gYXZvaWQgdW5pbnRlbnRpb25hbGx5IHN0YXJ0aW5nIHVwIGJhdGNoaW5nIGZvciB0aGUgZmlyc3QgdGltZVxuICAgICAgICBpZiAodGhpcy5fYmF0Y2hlcnNfd2VyZV9zdGFydGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0X2JhdGNoX3NlbmRlcnMoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIGNhbGwgYSBiYXNlIGdkcHIgZnVuY3Rpb24gYWZ0ZXIgY29uc3RydWN0aW5nIHRoZSBhcHByb3ByaWF0ZSB0b2tlbiBhbmQgb3B0aW9ucyBhcmdzXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2dkcHJfY2FsbF9mdW5jID0gZnVuY3Rpb24oZnVuYywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7XG4gICAgICAgICd0cmFjayc6IF8uYmluZCh0aGlzLnRyYWNrLCB0aGlzKSxcbiAgICAgICAgJ3BlcnNpc3RlbmNlX3R5cGUnOiB0aGlzLmdldF9jb25maWcoJ29wdF9vdXRfdHJhY2tpbmdfcGVyc2lzdGVuY2VfdHlwZScpLFxuICAgICAgICAnY29va2llX3ByZWZpeCc6IHRoaXMuZ2V0X2NvbmZpZygnb3B0X291dF90cmFja2luZ19jb29raWVfcHJlZml4JyksXG4gICAgICAgICdjb29raWVfZXhwaXJhdGlvbic6IHRoaXMuZ2V0X2NvbmZpZygnY29va2llX2V4cGlyYXRpb24nKSxcbiAgICAgICAgJ2Nyb3NzX3NpdGVfY29va2llJzogdGhpcy5nZXRfY29uZmlnKCdjcm9zc19zaXRlX2Nvb2tpZScpLFxuICAgICAgICAnY3Jvc3Nfc3ViZG9tYWluX2Nvb2tpZSc6IHRoaXMuZ2V0X2NvbmZpZygnY3Jvc3Nfc3ViZG9tYWluX2Nvb2tpZScpLFxuICAgICAgICAnY29va2llX2RvbWFpbic6IHRoaXMuZ2V0X2NvbmZpZygnY29va2llX2RvbWFpbicpLFxuICAgICAgICAnc2VjdXJlX2Nvb2tpZSc6IHRoaXMuZ2V0X2NvbmZpZygnc2VjdXJlX2Nvb2tpZScpLFxuICAgICAgICAnaWdub3JlX2RudCc6IHRoaXMuZ2V0X2NvbmZpZygnaWdub3JlX2RudCcpXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICAvLyBjaGVjayBpZiBsb2NhbFN0b3JhZ2UgY2FuIGJlIHVzZWQgZm9yIHJlY29yZGluZyBvcHQgb3V0IHN0YXR1cywgZmFsbCBiYWNrIHRvIGNvb2tpZSBpZiBub3RcbiAgICBpZiAoIV8ubG9jYWxTdG9yYWdlLmlzX3N1cHBvcnRlZCgpKSB7XG4gICAgICAgIG9wdGlvbnNbJ3BlcnNpc3RlbmNlX3R5cGUnXSA9ICdjb29raWUnO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jKHRoaXMuZ2V0X2NvbmZpZygndG9rZW4nKSwge1xuICAgICAgICB0cmFjazogb3B0aW9uc1sndHJhY2snXSxcbiAgICAgICAgdHJhY2tFdmVudE5hbWU6IG9wdGlvbnNbJ3RyYWNrX2V2ZW50X25hbWUnXSxcbiAgICAgICAgdHJhY2tQcm9wZXJ0aWVzOiBvcHRpb25zWyd0cmFja19wcm9wZXJ0aWVzJ10sXG4gICAgICAgIHBlcnNpc3RlbmNlVHlwZTogb3B0aW9uc1sncGVyc2lzdGVuY2VfdHlwZSddLFxuICAgICAgICBwZXJzaXN0ZW5jZVByZWZpeDogb3B0aW9uc1snY29va2llX3ByZWZpeCddLFxuICAgICAgICBjb29raWVEb21haW46IG9wdGlvbnNbJ2Nvb2tpZV9kb21haW4nXSxcbiAgICAgICAgY29va2llRXhwaXJhdGlvbjogb3B0aW9uc1snY29va2llX2V4cGlyYXRpb24nXSxcbiAgICAgICAgY3Jvc3NTaXRlQ29va2llOiBvcHRpb25zWydjcm9zc19zaXRlX2Nvb2tpZSddLFxuICAgICAgICBjcm9zc1N1YmRvbWFpbkNvb2tpZTogb3B0aW9uc1snY3Jvc3Nfc3ViZG9tYWluX2Nvb2tpZSddLFxuICAgICAgICBzZWN1cmVDb29raWU6IG9wdGlvbnNbJ3NlY3VyZV9jb29raWUnXSxcbiAgICAgICAgaWdub3JlRG50OiBvcHRpb25zWydpZ25vcmVfZG50J11cbiAgICB9KTtcbn07XG5cbi8qKlxuICogT3B0IHRoZSB1c2VyIGluIHRvIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGlzIE1peHBhbmVsIGluc3RhbmNlXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyBvcHQgdXNlciBpblxuICogICAgIG1peHBhbmVsLm9wdF9pbl90cmFja2luZygpO1xuICpcbiAqICAgICAvLyBvcHQgdXNlciBpbiB3aXRoIHNwZWNpZmljIGV2ZW50IG5hbWUsIHByb3BlcnRpZXMsIGNvb2tpZSBjb25maWd1cmF0aW9uXG4gKiAgICAgbWl4cGFuZWwub3B0X2luX3RyYWNraW5nKHtcbiAqICAgICAgICAgdHJhY2tfZXZlbnRfbmFtZTogJ1VzZXIgb3B0ZWQgaW4nLFxuICogICAgICAgICB0cmFja19ldmVudF9wcm9wZXJ0aWVzOiB7XG4gKiAgICAgICAgICAgICAnRW1haWwnOiAnamRvZUBleGFtcGxlLmNvbSdcbiAqICAgICAgICAgfSxcbiAqICAgICAgICAgY29va2llX2V4cGlyYXRpb246IDMwLFxuICogICAgICAgICBzZWN1cmVfY29va2llOiB0cnVlXG4gKiAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2YgY29uZmlnIG9wdGlvbnMgdG8gb3ZlcnJpZGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLnRyYWNrXSBGdW5jdGlvbiB1c2VkIGZvciB0cmFja2luZyBhIE1peHBhbmVsIGV2ZW50IHRvIHJlY29yZCB0aGUgb3B0LWluIGFjdGlvbiAoZGVmYXVsdCBpcyB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgdHJhY2sgbWV0aG9kKVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRyYWNrX2V2ZW50X25hbWU9JG9wdF9pbl0gRXZlbnQgbmFtZSB0byBiZSB1c2VkIGZvciB0cmFja2luZyB0aGUgb3B0LWluIGFjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnRyYWNrX3Byb3BlcnRpZXNdIFNldCBvZiBwcm9wZXJ0aWVzIHRvIGJlIHRyYWNrZWQgYWxvbmcgd2l0aCB0aGUgb3B0LWluIGFjdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5lbmFibGVfcGVyc2lzdGVuY2U9dHJ1ZV0gSWYgdHJ1ZSwgd2lsbCByZS1lbmFibGUgc2RrIHBlcnNpc3RlbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VfdHlwZT1sb2NhbFN0b3JhZ2VdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZSAtIGZhbGxzIGJhY2sgdG8gY29va2llIGlmIGxvY2FsU3RvcmFnZSBpcyB1bmF2YWlsYWJsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZV9wcmVmaXg9X19tcF9vcHRfaW5fb3V0XSBDdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb2tpZV9leHBpcmF0aW9uXSBOdW1iZXIgb2YgZGF5cyB1bnRpbCB0aGUgb3B0LWluIGNvb2tpZSBleHBpcmVzIChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llX2RvbWFpbl0gQ3VzdG9tIGNvb2tpZSBkb21haW4gKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3Nfc2l0ZV9jb29raWVdIFdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXNpdGUtZW5hYmxlZCAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc19zdWJkb21haW5fY29va2llXSBXaGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zdWJkb21haW4gb3Igbm90IChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlY3VyZV9jb29raWVdIFdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIHNlY3VyZSBvciBub3QgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLm9wdF9pbl90cmFja2luZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gXy5leHRlbmQoe1xuICAgICAgICAnZW5hYmxlX3BlcnNpc3RlbmNlJzogdHJ1ZVxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5fZ2Rwcl9jYWxsX2Z1bmMob3B0SW4sIG9wdGlvbnMpO1xuICAgIHRoaXMuX2dkcHJfdXBkYXRlX3BlcnNpc3RlbmNlKG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBPcHQgdGhlIHVzZXIgb3V0IG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGlzIE1peHBhbmVsIGluc3RhbmNlXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyBvcHQgdXNlciBvdXRcbiAqICAgICBtaXhwYW5lbC5vcHRfb3V0X3RyYWNraW5nKCk7XG4gKlxuICogICAgIC8vIG9wdCB1c2VyIG91dCB3aXRoIGRpZmZlcmVudCBjb29raWUgY29uZmlndXJhdGlvbiBmcm9tIE1peHBhbmVsIGluc3RhbmNlXG4gKiAgICAgbWl4cGFuZWwub3B0X291dF90cmFja2luZyh7XG4gKiAgICAgICAgIGNvb2tpZV9leHBpcmF0aW9uOiAzMCxcbiAqICAgICAgICAgc2VjdXJlX2Nvb2tpZTogdHJ1ZVxuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9mIGNvbmZpZyBvcHRpb25zIHRvIG92ZXJyaWRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRlbGV0ZV91c2VyPXRydWVdIElmIHRydWUsIHdpbGwgZGVsZXRlIHRoZSBjdXJyZW50bHkgaWRlbnRpZmllZCB1c2VyJ3MgcHJvZmlsZSBhbmQgY2xlYXIgYWxsIGNoYXJnZXMgYWZ0ZXIgb3B0aW5nIHRoZSB1c2VyIG91dFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jbGVhcl9wZXJzaXN0ZW5jZT10cnVlXSBJZiB0cnVlLCB3aWxsIGRlbGV0ZSBhbGwgZGF0YSBzdG9yZWQgYnkgdGhlIHNkayBpbiBwZXJzaXN0ZW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlX3R5cGU9bG9jYWxTdG9yYWdlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2UgLSBmYWxscyBiYWNrIHRvIGNvb2tpZSBpZiBsb2NhbFN0b3JhZ2UgaXMgdW5hdmFpbGFibGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVfcHJlZml4PV9fbXBfb3B0X2luX291dF0gQ3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29raWVfZXhwaXJhdGlvbl0gTnVtYmVyIG9mIGRheXMgdW50aWwgdGhlIG9wdC1pbiBjb29raWUgZXhwaXJlcyAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZV9kb21haW5dIEN1c3RvbSBjb29raWUgZG9tYWluIChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzX3NpdGVfY29va2llXSBXaGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zaXRlLWVuYWJsZWQgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3Nfc3ViZG9tYWluX2Nvb2tpZV0gV2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc3ViZG9tYWluIG9yIG5vdCAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWN1cmVfY29va2llXSBXaGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBzZWN1cmUgb3Igbm90IChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5vcHRfb3V0X3RyYWNraW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7XG4gICAgICAgICdjbGVhcl9wZXJzaXN0ZW5jZSc6IHRydWUsXG4gICAgICAgICdkZWxldGVfdXNlcic6IHRydWVcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIC8vIGRlbGV0ZSB1c2VyIGFuZCBjbGVhciBjaGFyZ2VzIHNpbmNlIHRoZXNlIG1ldGhvZHMgbWF5IGJlIGRpc2FibGVkIGJ5IG9wdC1vdXRcbiAgICBpZiAob3B0aW9uc1snZGVsZXRlX3VzZXInXSAmJiB0aGlzWydwZW9wbGUnXSAmJiB0aGlzWydwZW9wbGUnXS5faWRlbnRpZnlfY2FsbGVkKCkpIHtcbiAgICAgICAgdGhpc1sncGVvcGxlJ10uZGVsZXRlX3VzZXIoKTtcbiAgICAgICAgdGhpc1sncGVvcGxlJ10uY2xlYXJfY2hhcmdlcygpO1xuICAgIH1cblxuICAgIHRoaXMuX2dkcHJfY2FsbF9mdW5jKG9wdE91dCwgb3B0aW9ucyk7XG4gICAgdGhpcy5fZ2Rwcl91cGRhdGVfcGVyc2lzdGVuY2Uob3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIHVzZXIgaGFzIG9wdGVkIGluIHRvIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGlzIE1peHBhbmVsIGluc3RhbmNlXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICB2YXIgaGFzX29wdGVkX2luID0gbWl4cGFuZWwuaGFzX29wdGVkX2luX3RyYWNraW5nKCk7XG4gKiAgICAgLy8gdXNlIGhhc19vcHRlZF9pbiB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9mIGNvbmZpZyBvcHRpb25zIHRvIG92ZXJyaWRlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VfdHlwZT1sb2NhbFN0b3JhZ2VdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZSAtIGZhbGxzIGJhY2sgdG8gY29va2llIGlmIGxvY2FsU3RvcmFnZSBpcyB1bmF2YWlsYWJsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZV9wcmVmaXg9X19tcF9vcHRfaW5fb3V0XSBDdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59IGN1cnJlbnQgb3B0LWluIHN0YXR1c1xuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuaGFzX29wdGVkX2luX3RyYWNraW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9nZHByX2NhbGxfZnVuYyhoYXNPcHRlZEluLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0IG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGlzIE1peHBhbmVsIGluc3RhbmNlXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICB2YXIgaGFzX29wdGVkX291dCA9IG1peHBhbmVsLmhhc19vcHRlZF9vdXRfdHJhY2tpbmcoKTtcbiAqICAgICAvLyB1c2UgaGFzX29wdGVkX291dCB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9mIGNvbmZpZyBvcHRpb25zIHRvIG92ZXJyaWRlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VfdHlwZT1sb2NhbFN0b3JhZ2VdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZSAtIGZhbGxzIGJhY2sgdG8gY29va2llIGlmIGxvY2FsU3RvcmFnZSBpcyB1bmF2YWlsYWJsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZV9wcmVmaXg9X19tcF9vcHRfaW5fb3V0XSBDdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59IGN1cnJlbnQgb3B0LW91dCBzdGF0dXNcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmhhc19vcHRlZF9vdXRfdHJhY2tpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dkcHJfY2FsbF9mdW5jKGhhc09wdGVkT3V0LCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQ2xlYXIgdGhlIHVzZXIncyBvcHQgaW4vb3V0IHN0YXR1cyBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZVxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gY2xlYXIgdXNlcidzIG9wdC1pbi9vdXQgc3RhdHVzXG4gKiAgICAgbWl4cGFuZWwuY2xlYXJfb3B0X2luX291dF90cmFja2luZygpO1xuICpcbiAqICAgICAvLyBjbGVhciB1c2VyJ3Mgb3B0LWluL291dCBzdGF0dXMgd2l0aCBzcGVjaWZpYyBjb29raWUgY29uZmlndXJhdGlvbiAtIHNob3VsZCBtYXRjaFxuICogICAgIC8vIGNvbmZpZ3VyYXRpb24gdXNlZCB3aGVuIG9wdF9pbl90cmFja2luZy9vcHRfb3V0X3RyYWNraW5nIG1ldGhvZHMgd2VyZSBjYWxsZWQuXG4gKiAgICAgbWl4cGFuZWwuY2xlYXJfb3B0X2luX291dF90cmFja2luZyh7XG4gKiAgICAgICAgIGNvb2tpZV9leHBpcmF0aW9uOiAzMCxcbiAqICAgICAgICAgc2VjdXJlX2Nvb2tpZTogdHJ1ZVxuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9mIGNvbmZpZyBvcHRpb25zIHRvIG92ZXJyaWRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZV9wZXJzaXN0ZW5jZT10cnVlXSBJZiB0cnVlLCB3aWxsIHJlLWVuYWJsZSBzZGsgcGVyc2lzdGVuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZV90eXBlPWxvY2FsU3RvcmFnZV0gUGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgLSBjb29raWUgb3IgbG9jYWxTdG9yYWdlIC0gZmFsbHMgYmFjayB0byBjb29raWUgaWYgbG9jYWxTdG9yYWdlIGlzIHVuYXZhaWxhYmxlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llX3ByZWZpeD1fX21wX29wdF9pbl9vdXRdIEN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29va2llX2V4cGlyYXRpb25dIE51bWJlciBvZiBkYXlzIHVudGlsIHRoZSBvcHQtaW4gY29va2llIGV4cGlyZXMgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVfZG9tYWluXSBDdXN0b20gY29va2llIGRvbWFpbiAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc19zaXRlX2Nvb2tpZV0gV2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc2l0ZS1lbmFibGVkIChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzX3N1YmRvbWFpbl9jb29raWVdIFdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXN1YmRvbWFpbiBvciBub3QgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VjdXJlX2Nvb2tpZV0gV2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgc2VjdXJlIG9yIG5vdCAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuY2xlYXJfb3B0X2luX291dF90cmFja2luZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gXy5leHRlbmQoe1xuICAgICAgICAnZW5hYmxlX3BlcnNpc3RlbmNlJzogdHJ1ZVxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5fZ2Rwcl9jYWxsX2Z1bmMoY2xlYXJPcHRJbk91dCwgb3B0aW9ucyk7XG4gICAgdGhpcy5fZ2Rwcl91cGRhdGVfcGVyc2lzdGVuY2Uob3B0aW9ucyk7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUucmVwb3J0X2Vycm9yID0gZnVuY3Rpb24obXNnLCBlcnIpIHtcbiAgICBjb25zb2xlJDEuZXJyb3IuYXBwbHkoY29uc29sZSQxLmVycm9yLCBhcmd1bWVudHMpO1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghZXJyICYmICEobXNnIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgICBtc2cgPSBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdldF9jb25maWcoJ2Vycm9yX3JlcG9ydGVyJykobXNnLCBlcnIpO1xuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIGNvbnNvbGUkMS5lcnJvcihlcnIpO1xuICAgIH1cbn07XG5cbi8vIEVYUE9SVFMgKGZvciBjbG9zdXJlIGNvbXBpbGVyKVxuXG4vLyBNaXhwYW5lbExpYiBFeHBvcnRzXG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2luaXQnXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5pbml0O1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydyZXNldCddICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUucmVzZXQ7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2Rpc2FibGUnXSAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5kaXNhYmxlO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyd0aW1lX2V2ZW50J10gICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUudGltZV9ldmVudDtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsndHJhY2snXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnRyYWNrO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyd0cmFja19saW5rcyddICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2tfbGlua3M7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3RyYWNrX2Zvcm1zJ10gICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS50cmFja19mb3Jtcztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsndHJhY2tfcGFnZXZpZXcnXSAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnRyYWNrX3BhZ2V2aWV3O1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydyZWdpc3RlciddICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUucmVnaXN0ZXI7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3JlZ2lzdGVyX29uY2UnXSAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5yZWdpc3Rlcl9vbmNlO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyd1bnJlZ2lzdGVyJ10gICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUudW5yZWdpc3Rlcjtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnaWRlbnRpZnknXSAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmlkZW50aWZ5O1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydhbGlhcyddICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuYWxpYXM7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ25hbWVfdGFnJ10gICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5uYW1lX3RhZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnc2V0X2NvbmZpZyddICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnNldF9jb25maWc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2dldF9jb25maWcnXSAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfY29uZmlnO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydnZXRfYXBpX2hvc3QnXSAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X2FwaV9ob3N0O1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydnZXRfcHJvcGVydHknXSAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X3Byb3BlcnR5O1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydnZXRfZGlzdGluY3RfaWQnXSAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X2Rpc3RpbmN0X2lkO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyd0b1N0cmluZyddICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUudG9TdHJpbmc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ29wdF9vdXRfdHJhY2tpbmcnXSAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5vcHRfb3V0X3RyYWNraW5nO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydvcHRfaW5fdHJhY2tpbmcnXSAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUub3B0X2luX3RyYWNraW5nO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydoYXNfb3B0ZWRfb3V0X3RyYWNraW5nJ10gICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuaGFzX29wdGVkX291dF90cmFja2luZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnaGFzX29wdGVkX2luX3RyYWNraW5nJ10gICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmhhc19vcHRlZF9pbl90cmFja2luZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnY2xlYXJfb3B0X2luX291dF90cmFja2luZyddICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmNsZWFyX29wdF9pbl9vdXRfdHJhY2tpbmc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2dldF9ncm91cCddICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfZ3JvdXA7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3NldF9ncm91cCddICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5zZXRfZ3JvdXA7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2FkZF9ncm91cCddICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5hZGRfZ3JvdXA7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3JlbW92ZV9ncm91cCddICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5yZW1vdmVfZ3JvdXA7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3RyYWNrX3dpdGhfZ3JvdXBzJ10gICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS50cmFja193aXRoX2dyb3Vwcztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnc3RhcnRfYmF0Y2hfc2VuZGVycyddICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnN0YXJ0X2JhdGNoX3NlbmRlcnM7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3N0b3BfYmF0Y2hfc2VuZGVycyddICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5zdG9wX2JhdGNoX3NlbmRlcnM7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3N0YXJ0X3Nlc3Npb25fcmVjb3JkaW5nJ10gICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5zdGFydF9zZXNzaW9uX3JlY29yZGluZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnc3RvcF9zZXNzaW9uX3JlY29yZGluZyddICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnN0b3Bfc2Vzc2lvbl9yZWNvcmRpbmc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3BhdXNlX3Nlc3Npb25fcmVjb3JkaW5nJ10gICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5wYXVzZV9zZXNzaW9uX3JlY29yZGluZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsncmVzdW1lX3Nlc3Npb25fcmVjb3JkaW5nJ10gICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlc3VtZV9zZXNzaW9uX3JlY29yZGluZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnZ2V0X3Nlc3Npb25fcmVjb3JkaW5nX3Byb3BlcnRpZXMnXSAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9zZXNzaW9uX3JlY29yZGluZ19wcm9wZXJ0aWVzO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydnZXRfc2Vzc2lvbl9yZXBsYXlfdXJsJ10gICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X3Nlc3Npb25fcmVwbGF5X3VybDtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnZ2V0X3RhYl9pZCddICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF90YWJfaWQ7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ0RFRkFVTFRfQVBJX1JPVVRFUyddICAgICAgICAgICAgICAgICA9IERFRkFVTFRfQVBJX1JPVVRFUztcblxuLy8gRXhwb3J0cyBpbnRlbmRlZCBvbmx5IGZvciB0ZXN0aW5nXG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ19fZ2V0X3JlY29yZGVyJ10gICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5fX2dldF9yZWNvcmRlcjtcblxuLy8gTWl4cGFuZWxQZXJzaXN0ZW5jZSBFeHBvcnRzXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZVsncHJvcGVydGllcyddICAgICAgICAgICAgPSBNaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5wcm9wZXJ0aWVzO1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGVbJ3VwZGF0ZV9zZWFyY2hfa2V5d29yZCddID0gTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUudXBkYXRlX3NlYXJjaF9rZXl3b3JkO1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGVbJ3VwZGF0ZV9yZWZlcnJlcl9pbmZvJ10gID0gTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUudXBkYXRlX3JlZmVycmVyX2luZm87XG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZVsnZ2V0X2Nyb3NzX3N1YmRvbWFpbiddICAgPSBNaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5nZXRfY3Jvc3Nfc3ViZG9tYWluO1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGVbJ2NsZWFyJ10gICAgICAgICAgICAgICAgID0gTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuY2xlYXI7XG5cblxudmFyIGluc3RhbmNlcyA9IHt9O1xudmFyIGV4dGVuZF9tcCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIGFkZCBhbGwgdGhlIHN1YiBtaXhwYW5lbCBpbnN0YW5jZXNcbiAgICBfLmVhY2goaW5zdGFuY2VzLCBmdW5jdGlvbihpbnN0YW5jZSwgbmFtZSkge1xuICAgICAgICBpZiAobmFtZSAhPT0gUFJJTUFSWV9JTlNUQU5DRV9OQU1FKSB7IG1peHBhbmVsX21hc3RlcltuYW1lXSA9IGluc3RhbmNlOyB9XG4gICAgfSk7XG5cbiAgICAvLyBhZGQgcHJpdmF0ZSBmdW5jdGlvbnMgYXMgX1xuICAgIG1peHBhbmVsX21hc3RlclsnXyddID0gXztcbn07XG5cbnZhciBvdmVycmlkZV9tcF9pbml0X2Z1bmMgPSBmdW5jdGlvbigpIHtcbiAgICAvLyB3ZSBvdmVycmlkZSB0aGUgc25pcHBldHMgaW5pdCBmdW5jdGlvbiB0byBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgYVxuICAgIC8vIHVzZXIgaW5pdGlhbGl6ZXMgdGhlIG1peHBhbmVsIGxpYnJhcnkgYWZ0ZXIgdGhlIHNjcmlwdCBsb2FkcyAmIHJ1bnNcbiAgICBtaXhwYW5lbF9tYXN0ZXJbJ2luaXQnXSA9IGZ1bmN0aW9uKHRva2VuLCBjb25maWcsIG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIC8vIGluaXRpYWxpemUgYSBzdWIgbGlicmFyeVxuICAgICAgICAgICAgaWYgKCFtaXhwYW5lbF9tYXN0ZXJbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBtaXhwYW5lbF9tYXN0ZXJbbmFtZV0gPSBpbnN0YW5jZXNbbmFtZV0gPSBjcmVhdGVfbXBsaWIodG9rZW4sIGNvbmZpZywgbmFtZSk7XG4gICAgICAgICAgICAgICAgbWl4cGFuZWxfbWFzdGVyW25hbWVdLl9sb2FkZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtaXhwYW5lbF9tYXN0ZXJbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBtaXhwYW5lbF9tYXN0ZXI7XG5cbiAgICAgICAgICAgIGlmIChpbnN0YW5jZXNbUFJJTUFSWV9JTlNUQU5DRV9OQU1FXSkge1xuICAgICAgICAgICAgICAgIC8vIG1haW4gbWl4cGFuZWwgbGliIGFscmVhZHkgaW5pdGlhbGl6ZWRcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IGluc3RhbmNlc1tQUklNQVJZX0lOU1RBTkNFX05BTUVdO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbikge1xuICAgICAgICAgICAgICAgIC8vIGludGlhbGl6ZSB0aGUgbWFpbiBtaXhwYW5lbCBsaWJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IGNyZWF0ZV9tcGxpYih0b2tlbiwgY29uZmlnLCBQUklNQVJZX0lOU1RBTkNFX05BTUUpO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLl9sb2FkZWQoKTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZXNbUFJJTUFSWV9JTlNUQU5DRV9OQU1FXSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtaXhwYW5lbF9tYXN0ZXIgPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIGlmIChpbml0X3R5cGUgPT09IElOSVRfU05JUFBFVCkge1xuICAgICAgICAgICAgICAgIHdpbltQUklNQVJZX0lOU1RBTkNFX05BTUVdID0gbWl4cGFuZWxfbWFzdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXh0ZW5kX21wKCk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxudmFyIGFkZF9kb21fbG9hZGVkX2hhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBDcm9zcyBicm93c2VyIERPTSBMb2FkZWQgc3VwcG9ydFxuICAgIGZ1bmN0aW9uIGRvbV9sb2FkZWRfaGFuZGxlcigpIHtcbiAgICAgICAgLy8gZnVuY3Rpb24gZmxhZyBzaW5jZSB3ZSBvbmx5IHdhbnQgdG8gZXhlY3V0ZSB0aGlzIG9uY2VcbiAgICAgICAgaWYgKGRvbV9sb2FkZWRfaGFuZGxlci5kb25lKSB7IHJldHVybjsgfVxuICAgICAgICBkb21fbG9hZGVkX2hhbmRsZXIuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgRE9NX0xPQURFRCA9IHRydWU7XG4gICAgICAgIEVOUVVFVUVfUkVRVUVTVFMgPSBmYWxzZTtcblxuICAgICAgICBfLmVhY2goaW5zdGFuY2VzLCBmdW5jdGlvbihpbnN0KSB7XG4gICAgICAgICAgICBpbnN0Ll9kb21fbG9hZGVkKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvX3Njcm9sbF9jaGVjaygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRvY3VtZW50JDEuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsKCdsZWZ0Jyk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChkb19zY3JvbGxfY2hlY2ssIDEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9tX2xvYWRlZF9oYW5kbGVyKCk7XG4gICAgfVxuXG4gICAgaWYgKGRvY3VtZW50JDEuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICBpZiAoZG9jdW1lbnQkMS5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgICAgICAvLyBzYWZhcmkgNCBjYW4gZmlyZSB0aGUgRE9NQ29udGVudExvYWRlZCBldmVudCBiZWZvcmUgbG9hZGluZyBhbGxcbiAgICAgICAgICAgIC8vIGV4dGVybmFsIEpTIChpbmNsdWRpbmcgdGhpcyBmaWxlKS4geW91IHdpbGwgc2VlIHNvbWUgY29weXBhc3RhXG4gICAgICAgICAgICAvLyBvbiB0aGUgaW50ZXJuZXQgdGhhdCBjaGVja3MgZm9yICdjb21wbGV0ZScgYW5kICdsb2FkZWQnLCBidXRcbiAgICAgICAgICAgIC8vICdsb2FkZWQnIGlzIGFuIElFIHRoaW5nXG4gICAgICAgICAgICBkb21fbG9hZGVkX2hhbmRsZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvY3VtZW50JDEuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGRvbV9sb2FkZWRfaGFuZGxlciwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudCQxLmF0dGFjaEV2ZW50KSB7XG4gICAgICAgIC8vIElFXG4gICAgICAgIGRvY3VtZW50JDEuYXR0YWNoRXZlbnQoJ29ucmVhZHlzdGF0ZWNoYW5nZScsIGRvbV9sb2FkZWRfaGFuZGxlcik7XG5cbiAgICAgICAgLy8gY2hlY2sgdG8gbWFrZSBzdXJlIHdlIGFybid0IGluIGEgZnJhbWVcbiAgICAgICAgdmFyIHRvcGxldmVsID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0b3BsZXZlbCA9IHdpbi5mcmFtZUVsZW1lbnQgPT09IG51bGw7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvY3VtZW50JDEuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsICYmIHRvcGxldmVsKSB7XG4gICAgICAgICAgICBkb19zY3JvbGxfY2hlY2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZhbGxiYWNrIGhhbmRsZXIsIGFsd2F5cyB3aWxsIHdvcmtcbiAgICBfLnJlZ2lzdGVyX2V2ZW50KHdpbiwgJ2xvYWQnLCBkb21fbG9hZGVkX2hhbmRsZXIsIHRydWUpO1xufTtcblxuZnVuY3Rpb24gaW5pdF9hc19tb2R1bGUoYnVuZGxlX2xvYWRlcikge1xuICAgIGxvYWRfZXh0cmFfYnVuZGxlID0gYnVuZGxlX2xvYWRlcjtcbiAgICBpbml0X3R5cGUgPSBJTklUX01PRFVMRTtcbiAgICBtaXhwYW5lbF9tYXN0ZXIgPSBuZXcgTWl4cGFuZWxMaWIoKTtcblxuICAgIG92ZXJyaWRlX21wX2luaXRfZnVuYygpO1xuICAgIG1peHBhbmVsX21hc3RlclsnaW5pdCddKCk7XG4gICAgYWRkX2RvbV9sb2FkZWRfaGFuZGxlcigpO1xuXG4gICAgcmV0dXJuIG1peHBhbmVsX21hc3Rlcjtcbn1cblxuLy8gRm9yIGxvYWRpbmcgc2VwYXJhdGUgYnVuZGxlcyBhc3luY2hyb25vdXNseSB2aWEgc2NyaXB0IHRhZ1xuLy8gc28gdGhhdCB3ZSBkb24ndCBsb2FkIHRoZW0gdW50aWwgdGhleSBhcmUgbmVlZGVkIGF0IHJ1bnRpbWUuXG5cbi8vIEZvciBidWlsZHMgdGhhdCBoYXZlIGV2ZXJ5dGhpbmcgaW4gb25lIGJ1bmRsZSwgbm8gZXh0cmEgd29yay5cbmZ1bmN0aW9uIGxvYWROb29wIChfc3JjLCBvbmxvYWQpIHtcbiAgICBvbmxvYWQoKTtcbn1cblxuLyogZXNsaW50IGNhbWVsY2FzZTogXCJvZmZcIiAqL1xuXG52YXIgbWl4cGFuZWwgPSBpbml0X2FzX21vZHVsZShsb2FkTm9vcCk7XG5cbmV4cG9ydCB7IG1peHBhbmVsIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/mixpanel-browser/dist/mixpanel.module.js\n");

/***/ })

};
;